
     When this is 'bidi', the drawing order is reversed if and only if
     the value of 'bidi-paragraph-direction' (*note Bidirectional
     Display::) is 'right-to-left' in the buffer displayed in the window
     most recently selected within the main window area of this frame.
     Sometimes that window may be hard to find, so heuristics are used
     to avoid that the drawing order changes inadvertently when another
     window gets selected.

     The layout of side windows on the left or right of a frame is not
     affected by the value of this variable.

   When a frame has side windows, the following function returns the
main window of that frame.

 -- Function: window-main-window &optional frame
     This function returns the main window of the specified FRAME.  The
     optional argument FRAME must be a live frame and defaults to the
     selected one.

     If FRAME has no side windows, it returns FRAME's root window.
     Otherwise, it returns either an internal non-side window such that
     all other non-side windows on FRAME descend from it, or the single
     live non-side window of FRAME.  Note that the main window of a
     frame cannot be deleted via 'delete-window'.

   The following command is handy to toggle the appearance of all side
windows on a specified frame.

 -- Command: window-toggle-side-windows &optional frame
     This command toggles side windows on the specified FRAME.  The
     optional argument FRAME must be a live frame and defaults to the
     selected one.

     If FRAME has at least one side window, this command saves the state
     of FRAME's root window in the FRAME's 'window-state' frame
     parameter and deletes all side windows on FRAME afterwards.

     If FRAME has no side windows, but does have a 'window-state'
     parameter, this command uses that parameter's value to restore the
     side windows on FRAME leaving FRAME's main window alone.

     An error is signaled if FRAME has no side windows and no saved
     state is found for it.

==============================================================================
File: elisp.info,  Node: |Frame_Layouts_with_Side_Windows|,  Prev: |Side_Window_Options_and_Functions|,  Up: |Side_Windows|
==============================================================================

                                               *Frame_Layouts_with_Side_Windows*

28.17.3 Frame Layouts with Side Windows
---------------------------------------

Side windows can be used to create more complex frame layouts like those
provided by integrated development environments (IDEs).  In such
layouts, the area of the main window is where the normal editing
activities take place.  Side windows are not conceived for editing in
the usual sense.  Rather, they are supposed to display information
complementary to the current editing activity, like lists of files, tags
or buffers, help information, search or grep results or shell output.

   The layout of such a frame might appear as follows:

          ___________________________________
         |          *Buffer List*            |
         |___________________________________|
         |     |                       |     |
         |  *  |                       |  *  |
         |  d  |                       |  T  |
         |  i  |                       |  a  |
         |  r  |   Main Window Area    |  g  |
         |  e  |                       |  s  |
         |  d  |                       |  *  |
         |  *  |                       |     |
         |_____|_______________________|_____|
         | help/*grep*/  |  *shell*/       |
         | Completions   |  *compilation*  |
         |_________________|_________________|
         |             Echo Area             |
         |___________________________________|



   The following example illustrates how window parameters (*note Window
Parameters::) can be used with 'display-buffer-in-side-window' (*note
Displaying Buffers in Side Windows::) to set up code for producing the
frame layout sketched above.

     (defvar parameters
       '(window-parameters . ((no-other-window . t)
                              (no-delete-other-windows . t))))

     (setq fit-window-to-buffer-horizontally t)
     (setq window-resize-pixelwise t)

     (setq
      display-buffer-alist
      `(("\\*Buffer List\\*" display-buffer-in-side-window
         (side . top) (slot . 0) (window-height . fit-window-to-buffer)
         (preserve-size . (nil . t)) ,parameters)
        ("\\*Tags List\\*" display-buffer-in-side-window
         (side . right) (slot . 0) (window-width . fit-window-to-buffer)
         (preserve-size . (t . nil)) ,parameters)
        ("\\*\\(?:help\\|grep\\|Completions\\)\\*"
         display-buffer-in-side-window
         (side . bottom) (slot . -1) (preserve-size . (nil . t))
         ,parameters)
        ("\\*\\(?:shell\\|compilation\\)\\*" display-buffer-in-side-window
         (side . bottom) (slot . 1) (preserve-size . (nil . t))
         ,parameters)))

   This specifies 'display-buffer-alist' entries (*note Choosing
Window::) for buffers with fixed names.  In particular, it asks for
showing '*Buffer List*' with adjustable height at the top of the frame
and '*Tags List*' with adjustable width on the frame's right.  It also
asks for having the 'help', '*grep*' and '*Completions*' buffers share
a window on the bottom left side of the frame and the 'shell' and
'compilation' buffers appear in a window on the bottom right side of
the frame.

   Note that the option 'fit-window-to-buffer-horizontally' must have a
non-'nil' value in order to allow horizontal adjustment of windows.
Entries are also added that ask for preserving the height of side
windows at the top and bottom of the frame and the width of side windows
at the left or right of the frame.  To assure that side windows retain
their respective sizes when maximizing the frame, the variable
'window-resize-pixelwise' is set to a non-'nil' value.  *Note Resizing
Windows::.

   The last form also makes sure that none of the created side windows
are accessible via 'C-x o' by installing the 'no-other-window' parameter
for each of these windows.  In addition, it makes sure that side windows
are not deleted via 'C-x 1' by installing the 'no-delete-other-windows'
parameter for each of these windows.

   Since 'dired' buffers have no fixed names, we use a special function
'dired-default-directory-on-left' in order to display a lean directory
buffer on the left side of the frame.

     (defun dired-default-directory-on-left ()
       "Display `default-directory' in side window on left, hiding details."
       (interactive)
       (let ((buffer (dired-noselect default-directory)))
         (with-current-buffer buffer (dired-hide-details-mode t))
         (display-buffer-in-side-window
          buffer `((side . left) (slot . 0)
                   (window-width . fit-window-to-buffer)
                   (preserve-size . (t . nil)) ,parameters))))

   Evaluating the preceding forms and typing, in any order,
'M-x list-buffers', 'C-h f', 'M-x shell', 'M-x list-tags', and 'M-x
dired-default-directory-on-left' should now reproduce the frame layout
sketched above.

==============================================================================
File: elisp.info,  Node: |Atomic_Windows|,  Next: |Window_Point|,  Prev: |Side_Windows|,  Up: |Windows|
==============================================================================

                                                                *Atomic_Windows*

28.18 Atomic Windows
--------------------

Atomic windows are rectangular compositions of at least two live
windows.  They have the following distinctive characteristics:

   * The function 'split-window' (*note Splitting Windows::), when
     applied to a constituent of an atomic window, will try to create
     the new window outside of the atomic window.

   * The function 'delete-window' (*note Deleting Windows::), when
     applied to a constituent of an atomic window, will try to delete
     the entire atomic window instead.

   * The function 'delete-other-windows' (*note Deleting Windows::),
     when applied to a constituent of an atomic window, will try to make
     the atomic window fill its frame or main window (*note Side
     Windows::).

   This means that the basic groups of functions that alter the window
structure treat an atomic window like a live one, thus preserving the
internal structure of the atomic window.

   Atomic windows are useful to construct and preserve window layouts
that are meaningful only when all involved buffers are shown
simultaneously in a specific manner, such as when showing differences
between file revisions, or the same text in different languages or
markups.  They can also be used to permanently display information
pertinent to a specific window in bars on that window's sides.

   Atomic windows are implemented with the help of the reserved
'window-atom' window parameter (*note Window Parameters::) and an
internal window (*note Basic Windows::) called the root window of the
atomic window.  All windows that are part of the same atomic window have
this root window as their common ancestor and are assigned a non-'nil'
'window-atom' parameter.

   The following function returns the root of the atomic window a
specified window is part of:

 -- Function: window-atom-root &optional window
     This functions returns the root of the atomic window WINDOW is a
     part of.  The specified WINDOW must be a valid window and defaults
     to the selected one.  It returns 'nil' if WINDOW is not part of an
     atomic window.

   The most simple approach to make a new atomic window is to take an
existing internal window and apply the following function:

 -- Function: window-make-atom window
     This function converts WINDOW into an atomic window.  The specified
     WINDOW must be an internal window.  All this function does is to
     set the 'window-atom' parameter of each descendant of WINDOW to
     't'.

   To create a new atomic window from an existing live window or to add
a new window to an existing atomic window, the following buffer display
action function (*note Buffer Display Action Functions::) can be used:

 -- Function: display-buffer-in-atom-window buffer alist
     This function tries to display BUFFER in a new window that will be
     combined with an existing window to form an atomic window.  If the
     existing window is already part of an atomic window, it adds the
     new window to that atomic window.

     The specified ALIST is an association list of symbols and values.
     The following symbols have a special meaning:

     'window'
          The value of such an element specifies an existing window the
          new window shall be combined with.  If it specifies an
          internal window, all children of that window become part of
          the atomic window too.  If no window is specified, the new
          window becomes a sibling of the selected window.  The
          'window-atom' parameter of the existing window is set to
          'main' provided that window is live and its 'window-atom'
          parameter was not already set.

     'side'
          The value of such an element denotes the side of the existing
          window where the new window shall be located.  Valid values
          are 'below', 'right', 'above' and 'left'.  The default is
          'below'.  The 'window-atom' parameter of the new window is set
          to this value.

     The return value is the new window, 'nil' when creating that window
     failed.

   Note that the value of the 'window-atom' parameter does not really
matter as long as it is non-'nil'.  The values assigned by
'display-buffer-in-atom-window' just allow for easy retrieval of the
original and the new window after that function has been applied.  Note
also that the 'window-atom' parameter is the only window parameter
assigned by 'display-buffer-in-atom-window'.  Further parameters have to
be set by the application explicitly via a 'window-parameters' entry in
ALIST.

   Atomic windows automatically cease to exist when one of their
constituents gets deleted.  To dissolve an atomic window manually, reset
the 'window-atom' parameter of its constituents--the root of the atomic
window and all its descendants.

   The following code snippet, when applied to a single-window frame,
first splits the selected window and makes the selected and the new
window constituents of an atomic window with their parent as root.  It
then displays the buffer 'Messages' in a new window at the frame's
bottom and makes that new window part of the atomic window just created.

     (let ((window (split-window-right)))
       (window-make-atom (window-parent window))
       (display-buffer-in-atom-window
        (get-buffer-create "Messages")
        `((window . ,(window-parent window)) (window-height . 5))))

   At this moment typing 'C-x 2' in any window of that frame produces a
new window at the bottom of the frame.  Typing 'C-x 3' instead will put
the new window at the frame's right.  In either case, typing now 'C-x 1'
in any window of the atomic window will remove the new window only.
Typing 'C-x 0' in any window of the atomic window will make that new
window fill the frame.

==============================================================================
File: elisp.info,  Node: |Window_Point|,  Next: |Window_Start_and_End|,  Prev: |Atomic_Windows|,  Up: |Windows|
==============================================================================

                                                                  *Window_Point*

28.19 Windows and Point
-----------------------

Each window has its own value of point (*note Point::), independent of
the value of point in other windows displaying the same buffer.  This
makes it useful to have multiple windows showing one buffer.

   * The window point is established when a window is first created; it
     is initialized from the buffer's point, or from the window point of
     another window opened on the buffer if such a window exists.

   * Selecting a window sets the value of point in its buffer from the
     window's value of point.  Conversely, deselecting a window sets the
     window's value of point from that of the buffer.  Thus, when you
     switch between windows that display a given buffer, the point value
     for the selected window is in effect in the buffer, while the point
     values for the other windows are stored in those windows.

   * As long as the selected window displays the current buffer, the
     window's point and the buffer's point always move together; they
     remain equal.

   Emacs displays the cursor, by default as a rectangular block, in each
window at the position of that window's point.  When the user switches
to another buffer in a window, Emacs moves that window's cursor to where
point is in that buffer.  If the exact position of point is hidden
behind some display element, such as a display string or an image, Emacs
displays the cursor immediately before or after that display element.

 -- Function: window-point &optional window
     This function returns the current position of point in WINDOW.  For
     a nonselected window, this is the value point would have (in that
     window's buffer) if that window were selected.  The default for
     WINDOW is the selected window.

     When WINDOW is the selected window, the value returned is the value
     of point in that window's buffer.  Strictly speaking, it would be
     more correct to return the top-level value of point, outside of any
     'save-excursion' forms.  But that value is hard to find.

 -- Function: set-window-point window position
     This function positions point in WINDOW at position POSITION in
     WINDOW's buffer.  It returns POSITION.

     If WINDOW is selected, this simply does 'goto-char' in WINDOW's
     buffer.

 -- Variable: window-point-insertion-type
     This variable specifies the marker insertion type (*note Marker
     Insertion Types::) of 'window-point'.  The default is 'nil', so
     'window-point' will stay behind text inserted there.

==============================================================================
File: elisp.info,  Node: |Window_Start_and_End|,  Next: |Textual_Scrolling|,  Prev: |Window_Point|,  Up: |Windows|
==============================================================================

                                                          *Window_Start_and_End*

28.20 The Window Start and End Positions
----------------------------------------

Each window maintains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the "display-start" position of the window (or just the
"start").  The character after this position is the one that appears at
the upper left corner of the window.  It is usually, but not inevitably,
at the beginning of a text line.

   After switching windows or buffers, and in some other cases, if the
window start is in the middle of a line, Emacs adjusts the window start
to the start of a line.  This prevents certain operations from leaving
the window start at a meaningless point within a line.  This feature may
interfere with testing some Lisp code by executing it using the commands
of Lisp mode, because they trigger this readjustment.  To test such
code, put it into a command and bind the command to a key.

 -- Function: window-start &optional window
     This function returns the display-start position of window WINDOW.
     If WINDOW is 'nil', the selected window is used.

     When you create a window, or display a different buffer in it, the
     display-start position is set to a display-start position recently
     used for the same buffer, or to 'point-min' if the buffer doesn't
     have any.

     Redisplay updates the window-start position (if you have not
     specified it explicitly since the previous redisplay)--to make sure
     point appears on the screen.  Nothing except redisplay
     automatically changes the window-start position; if you move point,
     do not expect the window-start position to change in response until
     after the next redisplay.

 -- Function: window-group-start &optional window
     This function is like 'window-start', except that when WINDOW is a
     part of a group of windows (*note Window Group::),
     'window-group-start' returns the start position of the entire
     group.  This condition holds when the buffer local variable
     'window-group-start-function' is set to a function.  In this case,
     'window-group-start' calls the function with the single argument
     WINDOW, then returns its result.

 -- Function: window-end &optional window update
     This function returns the position where display of its buffer ends
     in WINDOW.  The default for WINDOW is the selected window.

     Simply changing the buffer text or moving point does not update the
     value that 'window-end' returns.  The value is updated only when
     Emacs redisplays and redisplay completes without being preempted.

     If the last redisplay of WINDOW was preempted, and did not finish,
     Emacs does not know the position of the end of display in that
     window.  In that case, this function returns 'nil'.

     If UPDATE is non-'nil', 'window-end' always returns an up-to-date
     value for where display ends, based on the current 'window-start'
     value.  If a previously saved value of that position is still
     valid, 'window-end' returns that value; otherwise it computes the
     correct value by scanning the buffer text.

     Even if UPDATE is non-'nil', 'window-end' does not attempt to
     scroll the display if point has moved off the screen, the way real
     redisplay would do.  It does not alter the 'window-start' value.
     In effect, it reports where the displayed text will end if
     scrolling is not required.  Note that the position it returns might
     be only partially visible.

 -- Function: window-group-end &optional window update
     This function is like 'window-end', except that when WINDOW is a
     part of a group of windows (*note Window Group::),
     'window-group-end' returns the end position of the entire group.
     This condition holds when the buffer local variable
     'window-group-end-function' is set to a function.  In this case,
     'window-group-end' calls the function with the two arguments WINDOW
     and UPDATE, then returns its result.  The argument UPDATE has the
     same meaning as in 'window-end'.

 -- Function: set-window-start window position &optional noforce
     This function sets the display-start position of WINDOW to POSITION
     in WINDOW's buffer.  It returns POSITION.

     The display routines insist that the position of point be visible
     when a buffer is displayed.  Normally, they select the
     display-start position according to their internal logic (and
     scroll the window if necessary) to make point visible.  However, if
     you specify the start position with this function using 'nil' for
     NOFORCE, it means you want display to start at POSITION even if
     that would put the location of point off the screen.  If this does
     place point off screen, the display routines attempt to move point
     to the left margin on the middle line in the window.

     For example, if point is 1 and you set the start of the window
     to 37, the start of the next line, point will be above the top of
     the window.  The display routines will automatically move point if
     it is still 1 when redisplay occurs.  Here is an example:

          ;; Here is what 'foo' looks like before executing
          ;;   the 'set-window-start' expression.

          ---------- Buffer: foo ----------
          -!-This is the contents of buffer foo.
          2
          3
          4
          5
          6
          ---------- Buffer: foo ----------

          (set-window-start
           (selected-window)
           (save-excursion
             (goto-char 1)
             (forward-line 1)
             (point)))
          => 37

          ;; Here is what 'foo' looks like after executing
          ;;   the 'set-window-start' expression.
          ---------- Buffer: foo ----------
          2
          3
          -!-4
          5
          6
          ---------- Buffer: foo ----------

     If the attempt to make point visible (i.e., in a fully-visible
     screen line) fails, the display routines will disregard the
     requested window-start position and compute a new one anyway.
     Thus, for reliable results Lisp programs that call this function
     should always move point to be inside the window whose display
     starts at POSITION.

     If NOFORCE is non-'nil', and POSITION would place point off screen
     at the next redisplay, then redisplay computes a new window-start
     position that works well with point, and thus POSITION is not used.

 -- Function: set-window-group-start window position &optional noforce
     This function is like 'set-window-start', except that when WINDOW
     is a part of a group of windows (*note Window Group::),
     'set-window-group-start' sets the start position of the entire
     group.  This condition holds when the buffer local variable
     'set-window-group-start-function' is set to a function.  In this
     case, 'set-window-group-start' calls the function with the three
     arguments WINDOW, POSITION, and NOFORCE, then returns its result.
     The arguments POSITION and NOFORCE in this function have the same
     meaning as in 'set-window-start'.

 -- Function: pos-visible-in-window-p &optional position window
          partially
     This function returns non-'nil' if POSITION is within the range of
     text currently visible on the screen in WINDOW.  It returns 'nil'
     if POSITION is scrolled vertically out of view.  Locations that are
     partially obscured are not considered visible unless PARTIALLY is
     non-'nil'.  The argument POSITION defaults to the current position
     of point in WINDOW; WINDOW defaults to the selected window.  If
     POSITION is 't', that means to check either the first visible
     position of the last screen line in WINDOW, or the end-of-buffer
     position, whichever comes first.

     This function considers only vertical scrolling.  If POSITION is
     out of view only because WINDOW has been scrolled horizontally,
     'pos-visible-in-window-p' returns non-'nil' anyway.  *Note
     Horizontal Scrolling::.

     If POSITION is visible, 'pos-visible-in-window-p' returns 't' if
     PARTIALLY is 'nil'; if PARTIALLY is non-'nil', and the character
     following POSITION is fully visible, it returns a list of the form
     '(X Y)', where X and Y are the pixel coordinates relative to the
     top left corner of the window; otherwise it returns an extended
     list of the form '(X Y RTOP RBOT ROWH VPOS)', where RTOP and RBOT
     specify the number of off-window pixels at the top and bottom of
     the row at POSITION, ROWH specifies the visible height of that row,
     and VPOS specifies the vertical position (zero-based row number) of
     that row.

     Here is an example:

          ;; If point is off the screen now, recenter it now.
          (or (pos-visible-in-window-p
               (point) (selected-window))
              (recenter 0))

 -- Function: pos-visible-in-window-group-p &optional position window
          partially
     This function is like 'pos-visible-in-window-p', except that when
     WINDOW is a part of a group of windows (*note Window Group::),
     'pos-visible-in-window-group-p' tests the visibility of POS in the
     entire group, not just in the single WINDOW.  This condition holds
     when the buffer local variable
     'pos-visible-in-window-group-p-function' is set to a function.  In
     this case 'pos-visible-in-window-group-p' calls the function with
     the three arguments POSITION, WINDOW, and PARTIALLY, then returns
     its result.  The arguments POSITION and PARTIALLY have the same
     meaning as in 'pos-visible-in-window-p'.

 -- Function: window-line-height &optional line window
     This function returns the height of text line LINE in WINDOW.  If
     LINE is one of 'header-line' or 'mode-line', 'window-line-height'
     returns information about the corresponding line of the window.
     Otherwise, LINE is a text line number starting from 0.  A negative
     number counts from the end of the window.  The default for LINE is
     the current line in WINDOW; the default for WINDOW is the selected
     window.

     If the display is not up to date, 'window-line-height' returns
     'nil'.  In that case, 'pos-visible-in-window-p' may be used to
     obtain related information.

     If there is no line corresponding to the specified LINE,
     'window-line-height' returns 'nil'.  Otherwise, it returns a list
     '(HEIGHT VPOS YPOS OFFBOT)', where HEIGHT is the height in pixels
     of the visible part of the line, VPOS and YPOS are the vertical
     position in lines and pixels of the line relative to the top of the
     first text line, and OFFBOT is the number of off-window pixels at
     the bottom of the text line.  If there are off-window pixels at the
     top of the (first) text line, YPOS is negative.

==============================================================================
File: elisp.info,  Node: |Textual_Scrolling|,  Next: |Vertical_Scrolling|,  Prev: |Window_Start_and_End|,  Up: |Windows|
==============================================================================

                                                             *Textual_Scrolling*

28.21 Textual Scrolling
-----------------------

"Textual scrolling" means moving the text up or down through a window.
It works by changing the window's display-start location.  It may also
change the value of 'window-point' to keep point on the screen (*note
Window Point::).

   The basic textual scrolling functions are 'scroll-up' (which scrolls
forward) and 'scroll-down' (which scrolls backward).  In these function
names, "up" and "down" refer to the direction of motion of the buffer
text relative to the window.  Imagine that the text is written on a long
roll of paper and that the scrolling commands move the paper up and
down.  Thus, if you are looking at the middle of a buffer and repeatedly
call 'scroll-down', you will eventually see the beginning of the buffer.

   Unfortunately, this sometimes causes confusion, because some people
tend to think in terms of the opposite convention: they imagine the
window moving over text that remains in place, so that "down" commands
take you to the end of the buffer.  This convention is consistent with
fact that such a command is bound to a key named <PageDown> on modern
keyboards.

   Textual scrolling functions (aside from 'scroll-other-window') have
unpredictable results if the current buffer is not the one displayed in
the selected window.  *Note Current Buffer::.

   If the window contains a row taller than the height of the window
(for example in the presence of a large image), the scroll functions
will adjust the window's vertical scroll position to scroll the
partially visible row.  Lisp callers can disable this feature by binding
the variable 'auto-window-vscroll' to 'nil' (*note Vertical
Scrolling::).

 -- Command: scroll-up &optional count
     This function scrolls forward by COUNT lines in the selected
     window.

     If COUNT is negative, it scrolls backward instead.  If COUNT is
     'nil' (or omitted), the distance scrolled is
     'next-screen-context-lines' lines less than the height of the
     window's text area.

     If the selected window cannot be scrolled any further, this
     function signals an error.  Otherwise, it returns 'nil'.

 -- Command: scroll-down &optional count
     This function scrolls backward by COUNT lines in the selected
     window.

     If COUNT is negative, it scrolls forward instead.  In other
     respects, it behaves the same way as 'scroll-up' does.

 -- Command: scroll-up-command &optional count
     This behaves like 'scroll-up', except that if the selected window
     cannot be scrolled any further and the value of the variable
     'scroll-error-top-bottom' is 't', it tries to move to the end of
     the buffer instead.  If point is already there, it signals an
     error.

 -- Command: scroll-down-command &optional count
     This behaves like 'scroll-down', except that if the selected window
     cannot be scrolled any further and the value of the variable
     'scroll-error-top-bottom' is 't', it tries to move to the beginning
     of the buffer instead.  If point is already there, it signals an
     error.

 -- Command: scroll-other-window &optional count
     This function scrolls the text in another window upward COUNT
     lines.  Negative values of COUNT, or 'nil', are handled as in
     'scroll-up'.

     You can specify which buffer to scroll by setting the variable
     'other-window-scroll-buffer' to a buffer.  If that buffer isn't
     already displayed, 'scroll-other-window' displays it in some
     window.

     When the selected window is the minibuffer, the next window is
     normally the leftmost one immediately above it.  You can specify a
     different window to scroll, when the minibuffer is selected, by
     setting the variable 'minibuffer-scroll-window'.  This variable has
     no effect when any other window is selected.  When it is non-'nil'
     and the minibuffer is selected, it takes precedence over
     'other-window-scroll-buffer'.  *Note Definition of
     minibuffer-scroll-window::.

     When the minibuffer is active, it is the next window if the
     selected window is the one at the bottom right corner.  In this
     case, 'scroll-other-window' attempts to scroll the minibuffer.  If
     the minibuffer contains just one line, it has nowhere to scroll to,
     so the line reappears after the echo area momentarily displays the
     message 'End of buffer'.

 -- Command: scroll-other-window-down &optional count
     This function scrolls the text in another window downward COUNT
     lines.  Negative values of COUNT, or 'nil', are handled as in
     'scroll-down'.  In other respects, it behaves the same way as
     'scroll-other-window' does.

 -- Variable: other-window-scroll-buffer
     If this variable is non-'nil', it tells 'scroll-other-window' which
     buffer's window to scroll.

 -- User Option: scroll-margin
     This option specifies the size of the scroll margin--a minimum
     number of lines between point and the top or bottom of a window.
     Whenever point gets within this many lines of the top or bottom of
     the window, redisplay scrolls the text automatically (if possible)
     to move point out of the margin, closer to the center of the
     window.

 -- User Option: maximum-scroll-margin
     This variable limits the effective value of 'scroll-margin' to a
     fraction of the current window line height.  For example, if the
     current window has 20 lines and 'maximum-scroll-margin' is 0.1,
     then the scroll margins will never be larger than 2 lines, no
     matter how big 'scroll-margin' is.

     'maximum-scroll-margin' itself has a maximum value of 0.5, which
     allows setting margins large to keep the cursor at the middle line
     of the window (or two middle lines if the window has an even number
     of lines).  If it's set to a larger value (or any value other than
     a float between 0.0 and 0.5) then the default value of 0.25 will be
     used instead.

 -- User Option: scroll-conservatively
     This variable controls how scrolling is done automatically when
     point moves off the screen (or into the scroll margin).  If the
     value is a positive integer N, then redisplay scrolls the text up
     to N lines in either direction, if that will bring point back into
     proper view.  This behavior is called "conservative scrolling".
     Otherwise, scrolling happens in the usual way, under the control of
     other variables such as 'scroll-up-aggressively' and
     'scroll-down-aggressively'.

     The default value is zero, which means that conservative scrolling
     never happens.

 -- User Option: scroll-down-aggressively
     The value of this variable should be either 'nil' or a fraction F
     between 0 and 1.  If it is a fraction, that specifies where on the
     screen to put point when scrolling down.  More precisely, when a
     window scrolls down because point is above the window start, the
     new start position is chosen to put point F part of the window
     height from the top.  The larger F, the more aggressive the
     scrolling.

     A value of 'nil' is equivalent to .5, since its effect is to center
     point.  This variable automatically becomes buffer-local when set
     in any fashion.

 -- User Option: scroll-up-aggressively
     Likewise, for scrolling up.  The value, F, specifies how far point
     should be placed from the bottom of the window; thus, as with
     'scroll-down-aggressively', a larger value scrolls more
     aggressively.

 -- User Option: scroll-step
     This variable is an older variant of 'scroll-conservatively'.  The
     difference is that if its value is N, that permits scrolling only
     by precisely N lines, not a smaller number.  This feature does not
     work with 'scroll-margin'.  The default value is zero.

 -- User Option: scroll-preserve-screen-position
     If this option is 't', whenever a scrolling command moves point
     off-window, Emacs tries to adjust point to keep the cursor at its
     old vertical position in the window, rather than the window edge.

     If the value is non-'nil' and not 't', Emacs adjusts point to keep
     the cursor at the same vertical position, even if the scrolling
     command didn't move point off-window.

     This option affects all scroll commands that have a non-'nil'
     'scroll-command' symbol property.

 -- User Option: next-screen-context-lines
     The value of this variable is the number of lines of continuity to
     retain when scrolling by full screens.  For example, 'scroll-up'
     with an argument of 'nil' scrolls so that this many lines at the
     bottom of the window appear instead at the top.  The default value
     is '2'.

 -- User Option: scroll-error-top-bottom
     If this option is 'nil' (the default), 'scroll-up-command' and
     'scroll-down-command' simply signal an error when no more scrolling
     is possible.

     If the value is 't', these commands instead move point to the
     beginning or end of the buffer (depending on scrolling direction);
     only if point is already on that position do they signal an error.

 -- Command: recenter &optional count redisplay
     This function scrolls the text in the selected window so that point
     is displayed at a specified vertical position within the window.
     It does not move point with respect to the text.

     If COUNT is a non-negative number, that puts the line containing
     point COUNT lines down from the top of the window.  If COUNT is a
     negative number, then it counts upward from the bottom of the
     window, so that -1 stands for the last usable line in the window.

     If COUNT is 'nil' (or a non-'nil' list), 'recenter' puts the line
     containing point in the middle of the window.  If COUNT is 'nil'
     and REDISPLAY is non-'nil', this function may redraw the frame,
     according to the value of 'recenter-redisplay'.  Thus, omitting the
     second argument can be used to countermand the effect of
     'recenter-redisplay' being non-'nil'.  Interactive calls pass
     non-'nil' for REDISPLAY.

     When 'recenter' is called interactively, COUNT is the raw prefix
     argument.  Thus, typing 'C-u' as the prefix sets the COUNT to a
     non-'nil' list, while typing 'C-u 4' sets COUNT to 4, which
     positions the current line four lines from the top.

     With an argument of zero, 'recenter' positions the current line at
     the top of the window.  The command 'recenter-top-bottom' offers a
     more convenient way to achieve this.

 -- Function: recenter-window-group &optional count
     This function is like 'recenter', except that when the selected
     window is part of a group of windows (*note Window Group::),
     'recenter-window-group' scrolls the entire group.  This condition
     holds when the buffer local variable
     'recenter-window-group-function' is set to a function.  In this
     case, 'recenter-window-group' calls the function with the argument
     COUNT, then returns its result.  The argument COUNT has the same
     meaning as in 'recenter', but with respect to the entire window
     group.

 -- User Option: recenter-redisplay
     If this variable is non-'nil', calling 'recenter' with a 'nil'
     COUNT argument and non-'nil' REDISPLAY argument redraws the frame.
     The default value is 'tty', which means only redraw the frame if it
     is a tty frame.

 -- Command: recenter-top-bottom &optional count
     This command, which is the default binding for 'C-l', acts like
     'recenter', except if called with no argument.  In that case,
     successive calls place point according to the cycling order defined
     by the variable 'recenter-positions'.

 -- User Option: recenter-positions
     This variable controls how 'recenter-top-bottom' behaves when
     called with no argument.  The default value is '(middle top
     bottom)', which means that successive calls of
     'recenter-top-bottom' with no argument cycle between placing point
     at the middle, top, and bottom of the window.

==============================================================================
File: elisp.info,  Node: |Vertical_Scrolling|,  Next: |Horizontal_Scrolling|,  Prev: |Textual_Scrolling|,  Up: |Windows|
==============================================================================

                                                            *Vertical_Scrolling*

28.22 Vertical Fractional Scrolling
-----------------------------------

"Vertical fractional scrolling" means shifting text in a window up or
down by a specified multiple or fraction of a line.  Emacs uses it, for
example, on images and screen lines which are taller than the window.
Each window has a "vertical scroll position", which is a number, never
less than zero.  It specifies how far to raise the contents of the
window when displaying them.  Raising the window contents generally
makes all or part of some lines disappear off the top, and all or part
of some other lines appear at the bottom.  The usual value is zero.

   The vertical scroll position is measured in units of the normal line
height, which is the height of the default font.  Thus, if the value is
.5, that means the window contents will be scrolled up half the normal
line height.  If it is 3.3, that means the window contents are scrolled
up somewhat over three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many
lines, depends on what the lines contain.  A value of .5 could scroll a
line whose height is very short off the screen, while a value of 3.3
could scroll just part of the way through a tall line or an image.

 -- Function: window-vscroll &optional window pixels-p
     This function returns the current vertical scroll position of
     WINDOW.  The default for WINDOW is the selected window.  If
     PIXELS-P is non-'nil', the return value is measured in pixels,
     rather than in units of the normal line height.

          (window-vscroll)
               => 0

 -- Function: set-window-vscroll window lines &optional pixels-p
     This function sets WINDOW's vertical scroll position to LINES.  If
     WINDOW is 'nil', the selected window is used.  The argument LINES
     should be zero or positive; if not, it is taken as zero.

     The actual vertical scroll position must always correspond to an
     integral number of pixels, so the value you specify is rounded
     accordingly.

     The return value is the result of this rounding.

          (set-window-vscroll (selected-window) 1.2)
               => 1.13

     If PIXELS-P is non-'nil', LINES specifies a number of pixels.  In
     this case, the return value is LINES.

 -- Variable: auto-window-vscroll
     If this variable is non-'nil', the 'line-move', 'scroll-up', and
     'scroll-down' functions will automatically modify the vertical
     scroll position to scroll through display rows that are taller than
     the height of the window, for example in the presence of large
     images.

==============================================================================
File: elisp.info,  Node: |Horizontal_Scrolling|,  Next: |Coordinates_and_Windows|,  Prev: |Vertical_Scrolling|,  Up: |Windows|
==============================================================================

                                                          *Horizontal_Scrolling*

28.23 Horizontal Scrolling
--------------------------

"Horizontal scrolling" means shifting the image in the window left or
right by a specified multiple of the normal character width.  Each
window has a "horizontal scroll position", which is a number, never less
than zero.  It specifies how far to shift the contents left.  Shifting
the window contents left generally makes all or part of some characters
disappear off the left, and all or part of some other characters appear
at the right.  The usual value is zero.

   The horizontal scroll position is measured in units of the normal
character width, which is the width of space in the default font.  Thus,
if the value is 5, that means the window contents are scrolled left by 5
times the normal character width.  How many characters actually
disappear off to the left depends on their width, and could vary from
line to line.

   Because we read from side to side in the inner loop, and from top to
bottom in the outer loop, the effect of horizontal scrolling is not like
that of textual or vertical scrolling.  Textual scrolling involves
selection of a portion of text to display, and vertical scrolling moves
the window contents contiguously; but horizontal scrolling causes part
of _each line_ to go off screen.

   Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the edge
to be revealed by it; so this is not allowed.  Scrolling to the left is
allowed; it scrolls the first columns of text off the edge of the window
and can reveal additional columns on the right that were truncated
before.  Once a window has a nonzero amount of leftward horizontal
scrolling, you can scroll it back to the right, but only so far as to
reduce the net horizontal scroll to zero.  There is no limit to how far
left you can scroll, but eventually all the text will disappear off the
left edge.

   If 'auto-hscroll-mode' is set, redisplay automatically alters the
horizontal scrolling of a window as necessary to ensure that point is
always visible.  However, you can still set the horizontal scrolling
value explicitly.  The value you specify serves as a lower bound for
automatic scrolling, i.e., automatic scrolling will not scroll a window
to a column less than the specified one.

   The default value of 'auto-hscroll-mode' is 't'; setting it to
'current-line' activates a variant of automatic horizontal scrolling
whereby only the line showing the cursor is horizontally scrolled to
make point visible, the rest of the window is left either unscrolled, or
at the minimum scroll amount set by 'scroll-left' and 'scroll-right',
see below.

 -- Command: scroll-left &optional count set-minimum
     This function scrolls the selected window COUNT columns to the left
     (or to the right if COUNT is negative).  The default for COUNT is
     the window width, minus 2.

     The return value is the total amount of leftward horizontal
     scrolling in effect after the change--just like the value returned
     by 'window-hscroll' (below).

     Note that text in paragraphs whose base direction is right-to-left
     (*note Bidirectional Display::) moves in the opposite direction:
     e.g., it moves to the right when 'scroll-left' is invoked with a
     positive value of COUNT.

     Once you scroll a window as far right as it can go, back to its
     normal position where the total leftward scrolling is zero,
     attempts to scroll any farther right have no effect.

     If SET-MINIMUM is non-'nil', the new scroll amount becomes the
     lower bound for automatic scrolling; that is, automatic scrolling
     will not scroll a window to a column less than the value returned
     by this function.  Interactive calls pass non-'nil' for
     SET-MINIMUM.

 -- Command: scroll-right &optional count set-minimum
     This function scrolls the selected window COUNT columns to the
     right (or to the left if COUNT is negative).  The default for COUNT
     is the window width, minus 2.  Aside from the direction of
     scrolling, this works just like 'scroll-left'.

 -- Function: window-hscroll &optional window
     This function returns the total leftward horizontal scrolling of
     WINDOW--the number of columns by which the text in WINDOW is
     scrolled left past the left margin.  (In right-to-left paragraphs,
     the value is the total amount of the rightward scrolling instead.)
     The default for WINDOW is the selected window.

     The return value is never negative.  It is zero when no horizontal
     scrolling has been done in WINDOW (which is usually the case).

          (window-hscroll)
               => 0
          (scroll-left 5)
               => 5
          (window-hscroll)
               => 5

 -- Function: set-window-hscroll window columns
     This function sets horizontal scrolling of WINDOW.  The value of
     COLUMNS specifies the amount of scrolling, in terms of columns from
     the left margin (right margin in right-to-left paragraphs).  The
     argument COLUMNS should be zero or positive; if not, it is taken as
     zero.  Fractional values of COLUMNS are not supported at present.

     Note that 'set-window-hscroll' may appear not to work if you test
     it by evaluating a call with 'M-:' in a simple way.  What happens
     is that the function sets the horizontal scroll value and returns,
     but then redisplay adjusts the horizontal scrolling to make point
     visible, and this overrides what the function did.  You can observe
     the function's effect if you call it while point is sufficiently
     far from the left margin that it will remain visible.

     The value returned is COLUMNS.

          (set-window-hscroll (selected-window) 10)
               => 10

   Here is how you can determine whether a given position POSITION is
off the screen due to horizontal scrolling:

     (defun hscroll-on-screen (window position)
       (save-excursion
         (goto-char position)
         (and
          (>= (- (current-column) (window-hscroll window)) 0)
          (< (- (current-column) (window-hscroll window))
             (window-width window)))))

==============================================================================
File: elisp.info,  Node: |Coordinates_and_Windows|,  Next: |Mouse_Window_Auto_selection|,  Prev: |Horizontal_Scrolling|,  Up: |Windows|
==============================================================================

                                                       *Coordinates_and_Windows*

28.24 Coordinates and Windows
-----------------------------

This section describes functions that report positions of and within a
window.  Most of these functions report positions relative to an origin
at the native position of the window's frame (*note Frame Geometry::).
Some functions report positions relative to the origin of the display of
the window's frame.  In any case, the origin has the coordinates (0, 0)
and X and Y coordinates increase rightward and downward respectively.

   For the following functions, X and Y coordinates are reported in
integer character units, i.e., numbers of lines and columns
respectively.  On a graphical display, each "line" and "column"
corresponds to the height and width of the default character specified
by the frame's default font (*note Frame Font::).

 -- Function: window-edges &optional window body absolute pixelwise
     This function returns a list of the edge coordinates of WINDOW.  If
     WINDOW is omitted or 'nil', it defaults to the selected window.

     The return value has the form '(LEFT TOP RIGHT BOTTOM)'.  These
     list elements are, respectively, the X coordinate of the leftmost
     column occupied by the window, the Y coordinate of the topmost row,
     the X coordinate one column to the right of the rightmost column,
     and the Y coordinate one row down from the bottommost row.

     Note that these are the actual outer edges of the window, including
     any header line, mode line, scroll bar, fringes, window divider and
     display margins.  On a text terminal, if the window has a neighbor
     on its right, its right edge includes the separator line between
     the window and its neighbor.

     If the optional argument BODY is 'nil', this means to return the
     edges corresponding to the total size of WINDOW.  BODY non-'nil'
     means to return the edges of WINDOW's body (aka text area).  If
     BODY is non-'nil', WINDOW must specify a live window.

     If the optional argument ABSOLUTE is 'nil', this means to return
     edges relative to the native position of WINDOW's frame.  ABSOLUTE
     non-'nil' means to return coordinates relative to the origin (0, 0)
     of WINDOW's display.  On non-graphical systems this argument has no
     effect.

     If the optional argument PIXELWISE is 'nil', this means to return
     the coordinates in terms of the default character width and height
     of WINDOW's frame (*note Frame Font::), rounded if necessary.
     PIXELWISE non-'nil' means to return the coordinates in pixels.
     Note that the pixel specified by RIGHT and BOTTOM is immediately
     outside of these edges.  If ABSOLUTE is non-'nil', PIXELWISE is
     implicitly non-'nil' too.

 -- Function: window-body-edges &optional window
     This function returns the edges of WINDOW's body (*note Window
     Sizes::).  Calling '(window-body-edges window)' is equivalent to
     calling '(window-edges window t)', see above.

   The following functions can be used to relate a set of frame-relative
coordinates to a window:

 -- Function: window-at x y &optional frame
     This function returns the live window at the coordinates X and Y
     given in default character sizes (*note Frame Font::) relative to
     the native position of FRAME (*note Frame Geometry::).

     If there is no window at that position, the return value is 'nil'.
     If FRAME is omitted or 'nil', it defaults to the selected frame.

 -- Function: coordinates-in-window-p coordinates window
     This function checks whether a window WINDOW occupies the frame
     relative coordinates COORDINATES, and if so, which part of the
     window that is.  WINDOW should be a live window.

     COORDINATES should be a cons cell of the form '(X . Y)', where X
     and Y are given in default character sizes (*note Frame Font::)
     relative to the native position of WINDOW's frame (*note Frame
     Geometry::).

     If there is no window at the specified position, the return value
     is 'nil' .  Otherwise, the return value is one of the following:

     '(RELX . RELY)'
          The coordinates are inside WINDOW.  The numbers RELX and RELY
          are the equivalent window-relative coordinates for the
          specified position, counting from 0 at the top left corner of
          the window.

     'mode-line'
          The coordinates are in the mode line of WINDOW.

     'header-line'
          The coordinates are in the header line of WINDOW.

     'tab-line'
          The coordinates are in the tab line of WINDOW.

     'right-divider'
          The coordinates are in the divider separating WINDOW from a
          window on the right.

     'bottom-divider'
          The coordinates are in the divider separating WINDOW from a
          window beneath.

     'vertical-line'
          The coordinates are in the vertical line between WINDOW and
          its neighbor to the right.  This value occurs only if the
          window doesn't have a scroll bar; positions in a scroll bar
          are considered outside the window for these purposes.

     'left-fringe'
     'right-fringe'
          The coordinates are in the left or right fringe of the window.

     'left-margin'
     'right-margin'
          The coordinates are in the left or right margin of the window.

     'nil'
          The coordinates are not in any part of WINDOW.

     The function 'coordinates-in-window-p' does not require a frame as
     argument because it always uses the frame that WINDOW is on.

   The following functions return window positions in pixels, rather
than character units.  Though mostly useful on graphical displays, they
can also be called on text terminals, where the screen area of each text
character is taken to be one pixel.

 -- Function: window-pixel-edges &optional window
     This function returns a list of pixel coordinates for the edges of
     WINDOW.  Calling '(window-pixel-edges window)' is equivalent to
     calling '(window-edges window nil nil t)', see above.

 -- Function: window-body-pixel-edges &optional window
     This function returns the pixel edges of WINDOW's body.  Calling
     '(window-body-pixel-edges window)' is equivalent to calling
     '(window-edges window t nil t)', see above.

   The following functions return window positions in pixels, relative
to the origin of the display screen rather than that of the frame:

 -- Function: window-absolute-pixel-edges &optional window
     This function returns the pixel coordinates of WINDOW relative to
     an origin at (0, 0) of the display of WINDOW's frame.  Calling
     '(window-absolute-pixel-edges)' is equivalent to calling
     '(window-edges window nil t t)', see above.

 -- Function: window-absolute-body-pixel-edges &optional window
     This function returns the pixel coordinates of WINDOW's body
     relative to an origin at (0, 0) of the display of WINDOW's frame.
     Calling '(window-absolute-body-pixel-edges window)' is equivalent
     to calling '(window-edges window t t t)', see above.

     Combined with 'set-mouse-absolute-pixel-position', this function
     can be used to move the mouse pointer to an arbitrary buffer
     position visible in some window:

          (let ((edges (window-absolute-body-pixel-edges))
                (position (pos-visible-in-window-p nil nil t)))
            (set-mouse-absolute-pixel-position
             (+ (nth 0 edges) (nth 0 position))
             (+ (nth 1 edges) (nth 1 position))))

     On a graphical terminal this form "warps" the mouse cursor to the
     upper left corner of the glyph at the selected window's point.  A
     position calculated this way can be also used to show a tooltip
     window there.

   The following function returns the screen coordinates of a buffer
position visible in a window:

 -- Function: window-absolute-pixel-position &optional position window
     If the buffer position POSITION is visible in window WINDOW, this
     function returns the display coordinates of the upper/left corner
     of the glyph at POSITION.  The return value is a cons of the X- and
     Y-coordinates of that corner, relative to an origin at (0, 0) of
     WINDOW's display.  It returns 'nil' if POSITION is not visible in
     WINDOW.

     WINDOW must be a live window and defaults to the selected window.
     POSITION defaults to the value of 'window-point' of WINDOW.

     This means that in order to move the mouse pointer to the position
     of point in the selected window, it's sufficient to write:

          (let ((position (window-absolute-pixel-position)))
            (set-mouse-absolute-pixel-position
             (car position) (cdr position)))

   The following function returns the largest rectangle that can be
inscribed in a window without covering text displayed in that window.

 -- Function: window-largest-empty-rectangle &optional window count
          min-width min-height positions left
     This function calculates the dimensions of the largest empty
     rectangle that can be inscribed in the specified WINDOW's text
     area.  WINDOW must be a live window and defaults to the selected
     one.

     The return value is a triple of the width and the start and end
     y-coordinates of the largest rectangle that can be inscribed into
     the empty space (space not displaying any text) of the text area of
     WINDOW.  No x-coordinates are returned by this function--any such
     rectangle is assumed to end at the right edge of WINDOW's text
     area.  If no empty space can be found, the return value is 'nil'.

     The optional argument COUNT, if non-'nil', specifies a maximum
     number of rectangles to return.  This means that the return value
     is a list of triples specifying rectangles with the largest
     rectangle first.  COUNT can be also a cons cell whose car specifies
     the number of rectangles to return and whose CDR, if non-'nil',
     states that all rectangles returned must be disjoint.

     The optional arguments MIN-WIDTH and MIN-HEIGHT, if non-'nil',
     specify the minimum width and height of any rectangle returned.

     The optional argument POSITIONS, if non-'nil', is a cons cell whose
     CAR specifies the uppermost and whose CDR specifies the lowermost
     pixel position that must be covered by any rectangle returned.
     These positions measure from the start of the text area of WINDOW.

     The optional argument LEFT, if non-'nil', means to return values
     suitable for buffers displaying right to left text.  In that case,
     any rectangle returned is assumed to start at the left edge of
     WINDOW's text area.

     Note that this function has to retrieve the dimensions of each line
     of WINDOW's glyph matrix via 'window-lines-pixel-dimensions' (*note
     Size of Displayed Text::).  Hence, this function may also return
     'nil' when the current glyph matrix of WINDOW is not up-to-date.

==============================================================================
File: elisp.info,  Node: |Mouse_Window_Auto_selection|,  Next: |Window_Configurations|,  Prev: |Coordinates_and_Windows|,  Up: |Windows|
==============================================================================

                                                   *Mouse_Window_Auto_selection*

28.25 Mouse Window Auto-selection
---------------------------------

The following option allows to automatically select the window under the
mouse pointer.  This accomplishes a policy similar to that of window
managers that give focus to a frame (and thus trigger its subsequent
selection) whenever the mouse pointer enters its window-system window
(*note Input Focus::).

 -- User Option: mouse-autoselect-window
     If this variable is non-'nil', Emacs will try to automatically
     select the window under the mouse pointer.  The following values
     are meaningful:

     A positive number
          This specifies a delay in seconds after which auto-selection
          triggers.  The window under the mouse pointer is selected
          after the mouse has remained in it for the entire duration of
          the delay.

     A negative number
          A negative number has a similar effect as a positive number,
          but selects the window under the mouse pointer only after the
          mouse pointer has remained in it for the entire duration of
          the absolute value of that number and in addition has stopped
          moving.

     Other value
          Any other non-'nil' value means to select a window
          instantaneously as soon as the mouse pointer enters it.

     In either case, the mouse pointer must enter the text area of a
     window in order to trigger its selection.  Dragging the scroll bar
     slider or the mode line of a window conceptually should not cause
     its auto-selection.

     Mouse auto-selection selects the minibuffer window only if it is
     active, and never deselects the active minibuffer window.

   Mouse auto-selection can be used to emulate a focus follows mouse
policy for child frames (*note Child Frames::) which usually are not
tracked by the window manager.  This requires to set the value of
'focus-follows-mouse' (*note Input Focus::) to a non-'nil' value.  If
the value of 'focus-follows-mouse' is 'auto-raise', entering a child
frame with the mouse will raise it automatically above all other child
frames of that frame's parent frame.

==============================================================================
File: elisp.info,  Node: |Window_Configurations|,  Next: |Window_Parameters|,  Prev: |Mouse_Window_Auto_selection|,  Up: |Windows|
==============================================================================

                                                         *Window_Configurations*

28.26 Window Configurations
---------------------------

A "window configuration" records the entire layout of one frame--all
windows, their sizes, which buffers they contain, how those buffers are
scrolled, and their value of point; also their fringes, margins, and
scroll bar settings.  It also includes the value of
'minibuffer-scroll-window'.  As a special exception, the window
configuration does not record the value of point in the selected window
for the current buffer.

   You can bring back an entire frame layout by restoring a previously
saved window configuration.  If you want to record the layout of all
frames instead of just one, use a frame configuration instead of a
window configuration.  *Note Frame Configurations::.

 -- Function: current-window-configuration &optional frame
     This function returns a new object representing FRAME's current
     window configuration.  The default for FRAME is the selected frame.
     The variable 'window-persistent-parameters' specifies which window
     parameters (if any) are saved by this function.  *Note Window
     Parameters::.

 -- Function: set-window-configuration configuration
     This function restores the configuration of windows and buffers as
     specified by CONFIGURATION, for the frame that CONFIGURATION was
     created for, regardless of whether that frame is selected or not.
     The argument CONFIGURATION must be a value that was previously
     returned by 'current-window-configuration' for that frame.

     If the frame from which CONFIGURATION was saved is dead, all this
     function does is to restore the value of the variable
     'minibuffer-scroll-window' and to adjust the value returned by
     'minibuffer-selected-window'.  In this case, the function returns
     'nil'.  Otherwise, it returns 't'.

     If the buffer of a window of CONFIGURATION has been killed since
     CONFIGURATION was made, that window is, as a rule, removed from the
     restored configuration.  However, if that window is the last window
     remaining in the restored configuration, another live buffer is
     shown in it.

     Here is a way of using this function to get the same effect as
     'save-window-excursion':

          (let ((config (current-window-configuration)))
            (unwind-protect
                (progn (split-window-below nil)
                       ...)
              (set-window-configuration config)))

 -- Macro: save-window-excursion forms...
     This macro records the window configuration of the selected frame,
     executes FORMS in sequence, then restores the earlier window
     configuration.  The return value is the value of the final form in
     FORMS.

     Most Lisp code should not use this macro; 'save-selected-window' is
     typically sufficient.  In particular, this macro cannot reliably
     prevent the code in FORMS from opening new windows, because new
     windows might be opened in other frames (*note Choosing Window::),
     and 'save-window-excursion' only saves and restores the window
     configuration on the current frame.

 -- Function: window-configuration-p object
     This function returns 't' if OBJECT is a window configuration.

 -- Function: compare-window-configurations config1 config2
     This function compares two window configurations as regards the
     structure of windows, but ignores the values of point and the saved
     scrolling positions--it can return 't' even if those aspects differ.

     The function 'equal' can also compare two window configurations; it
     regards configurations as unequal if they differ in any respect,
     even a saved point.

 -- Function: window-configuration-frame config
     This function returns the frame for which the window configuration
     CONFIG was made.

   Other primitives to look inside of window configurations would make
sense, but are not implemented because we did not need them.  See the
file 'winner.el' for some more operations on windows configurations.

   The objects returned by 'current-window-configuration' die together
with the Emacs process.  In order to store a window configuration on
disk and read it back in another Emacs session, you can use the
functions described next.  These functions are also useful to clone the
state of a frame into an arbitrary live window
('set-window-configuration' effectively clones the windows of a frame
into the root window of that very frame only).

 -- Function: window-state-get &optional window writable
     This function returns the state of WINDOW as a Lisp object.  The
     argument WINDOW must be a valid window and defaults to the root
     window of the selected frame.

     If the optional argument WRITABLE is non-'nil', this means to not
     use markers for sampling positions like 'window-point' or
     'window-start'.  This argument should be non-'nil' when the state
     will be written to disk and read back in another session.

     Together, the argument WRITABLE and the variable
     'window-persistent-parameters' specify which window parameters are
     saved by this function.  *Note Window Parameters::.

   The value returned by 'window-state-get' can be used in the same
session to make a clone of a window in another window.  It can be also
written to disk and read back in another session.  In either case, use
the following function to restore the state of the window.

 -- Function: window-state-put state &optional window ignore
     This function puts the window state STATE into WINDOW.  The
     argument STATE should be the state of a window returned by an
     earlier invocation of 'window-state-get', see above.  The optional
     argument WINDOW can be either a live window or an internal window
     (*note Windows and Frames::).  If WINDOW is not a live window, it
     is replaced by a new live window created on the same frame before
     putting STATE into it.  If WINDOW is 'nil', it puts the window
     state into a new window.

     If the optional argument IGNORE is non-'nil', it means to ignore
     minimum window sizes and fixed-size restrictions.  If IGNORE is
     'safe', this means windows can get as small as one line and/or two
     columns.

   The functions 'window-state-get' and 'window-state-put' also allow to
exchange the contents of two live windows.  The following function does
precisely that:

 -- Command: window-swap-states &optional window-1 window-2 size
     This command swaps the states of the two live windows WINDOW-1 and
     WINDOW-2.  WINDOW-1 must specify a live window and defaults to the
     selected one.  WINDOW-2 must specify a live window and defaults to
     the window following WINDOW-1 in the cyclic ordering of windows,
     excluding minibuffer windows and including live windows on all
     visible frames.

     Optional argument SIZE non-'nil' means to try swapping the sizes of
     WINDOW-1 and WINDOW-2 as well.  A value of 'height' means to swap
     heights only, a value of 'width' means to swap widths only, while
     't' means to swap both widths and heights, if possible.  Frames are
     not resized by this function.

==============================================================================
File: elisp.info,  Node: |Window_Parameters|,  Next: |Window_Hooks|,  Prev: |Window_Configurations|,  Up: |Windows|
==============================================================================

                                                             *Window_Parameters*

28.27 Window Parameters
-----------------------

This section describes the window parameters that can be used to
associate additional information with windows.

 -- Function: window-parameter window parameter
     This function returns WINDOW's value for PARAMETER.  The default
     for WINDOW is the selected window.  If WINDOW has no setting for
     PARAMETER, this function returns 'nil'.

 -- Function: window-parameters &optional window
     This function returns all parameters of WINDOW and their values.
     The default for WINDOW is the selected window.  The return value is
     either 'nil', or an association list whose elements have the form
     '(PARAMETER . VALUE)'.

 -- Function: set-window-parameter window parameter value
     This function sets WINDOW's value of PARAMETER to VALUE and returns
     VALUE.  The default for WINDOW is the selected window.

   By default, the functions that save and restore window configurations
or the states of windows (*note Window Configurations::) do not care
about window parameters.  This means that when you change the value of a
parameter within the body of a 'save-window-excursion', the previous
value is not restored when that macro exits.  It also means that when
you restore via 'window-state-put' a window state saved earlier by
'window-state-get', all cloned windows have their parameters reset to
'nil'.  The following variable allows you to override the standard
behavior:

 -- Variable: window-persistent-parameters
     This variable is an alist specifying which parameters get saved by
     'current-window-configuration' and 'window-state-get', and
     subsequently restored by 'set-window-configuration' and
     'window-state-put'.  *Note Window Configurations::.

     The CAR of each entry of this alist is a symbol specifying the
     parameter.  The CDR should be one of the following:

     'nil'
          This value means the parameter is saved neither by
          'window-state-get' nor by 'current-window-configuration'.

     't'
          This value specifies that the parameter is saved by
          'current-window-configuration' and (provided its WRITABLE
          argument is 'nil') by 'window-state-get'.

     'writable'
          This means that the parameter is saved unconditionally by both
          'current-window-configuration' and 'window-state-get'.  This
          value should not be used for parameters whose values do not
          have a read syntax.  Otherwise, invoking 'window-state-put' in
          another session may fail with an 'invalid-read-syntax' error.

   Some functions (notably 'delete-window', 'delete-other-windows' and
'split-window'), may behave specially when the window specified by their
WINDOW argument has a parameter whose name is equal to the function's
name.  You can override such special behavior by binding the following
variable to a non-'nil' value:

 -- Variable: ignore-window-parameters
     If this variable is non-'nil', some standard functions do not
     process window parameters.  The functions currently affected by
     this are 'split-window', 'delete-window', 'delete-other-windows',
     and 'other-window'.

     An application can bind this variable to a non-'nil' value around
     calls to these functions.  If it does so, the application is fully
     responsible for correctly assigning the parameters of all involved
     windows when exiting that function.

   The following parameters are currently used by the window management
code:

'delete-window'
     This parameter affects the execution of 'delete-window' (*note
     Deleting Windows::).

'delete-other-windows'
     This parameter affects the execution of 'delete-other-windows'
     (*note Deleting Windows::).

'no-delete-other-windows'
     This parameter marks the window as not deletable by
     'delete-other-windows' (*note Deleting Windows::).

'split-window'
     This parameter affects the execution of 'split-window' (*note
     Splitting Windows::).

'other-window'
     This parameter affects the execution of 'other-window' (*note
     Cyclic Window Ordering::).

'no-other-window'
     This parameter marks the window as not selectable by 'other-window'
     (*note Cyclic Window Ordering::).

'clone-of'
     This parameter specifies the window that this one has been cloned
     from.  It is installed by 'window-state-get' (*note Window
     Configurations::).

'window-preserved-size'
     This parameter specifies a buffer, a direction where 'nil' means
     vertical and 't' horizontal, and a size in pixels.  If this window
     displays the specified buffer and its size in the indicated
     direction equals the size specified by this parameter, then Emacs
     will try to preserve the size of this window in the indicated
     direction.  This parameter is installed and updated by the function
     'window-preserve-size' (*note Preserving Window Sizes::).

'quit-restore'
     This parameter is installed by the buffer display functions (*note
     Choosing Window::) and consulted by 'quit-restore-window' (*note
     Quitting Windows::).  It is a list of four elements, see the
     description of 'quit-restore-window' in *note Quitting Windows::
     for details.

'window-side'
'window-slot'
     These parameters are used internally for implementing side windows
     (*note Side Windows::).

'window-atom'
     This parameter is used internally for implementing atomic windows,
     see *note Atomic Windows::.

'mode-line-format'
     This parameter replaces the value of the buffer-local variable
     'mode-line-format' (*note Mode Line Basics::) of this window's
     buffer whenever this window is displayed.  The symbol 'none' means
     to suppress display of a mode line for this window.  Display and
     contents of the mode line on other windows showing this buffer are
     not affected.

'header-line-format'
     This parameter replaces the value of the buffer-local variable
     'header-line-format' (*note Mode Line Basics::) of this window's
     buffer whenever this window is displayed.  The symbol 'none' means
     to suppress display of a header line for this window.  Display and
     contents of the header line on other windows showing this buffer
     are not affected.

'tab-line-format'
     This parameter replaces the value of the buffer-local variable
     'tab-line-format' (*note Mode Line Basics::) of this window's
     buffer whenever this window is displayed.  The symbol 'none' means
     to suppress display of a tab line for this window.  Display and
     contents of the tab line on other windows showing this buffer are
     not affected.

'min-margins'
     The value of this parameter is a cons cell whose CAR and CDR, if
     non-'nil', specify the minimum values (in columns) for the left and
     right margin of this window (*note Display Margins::.  When
     present, Emacs will use these values instead of the actual margin
     widths for determining whether a window can be split or shrunk
     horizontally.

     Emacs never auto-adjusts the margins of any window after splitting
     or resizing it.  It is the sole responsibility of any application
     setting this parameter to adjust the margins of this window as well
     as those of any new window that inherits this window's margins due
     to a split.  Both 'window-configuration-change-hook' and
     'window-size-change-functions' (*note Window Hooks::) should be
     employed for this purpose.

     This parameter was introduced in Emacs version 25.1 to support
     applications that use large margins to center buffer text within a
     window and should be used, with due care, exclusively by those
     applications.  It might be replaced by an improved solution in
     future versions of Emacs.

==============================================================================
File: elisp.info,  Node: |Window_Hooks|,  Prev: |Window_Parameters|,  Up: |Windows|
==============================================================================

                                                                  *Window_Hooks*

28.28 Hooks for Window Scrolling and Changes
--------------------------------------------

This section describes how Lisp programs can take action after a window
has been scrolled or other window modifications occurred.  We first
consider the case where a window shows a different part of its buffer.

 -- Variable: window-scroll-functions
     This variable holds a list of functions that Emacs should call
     before redisplaying a window with scrolling.  Displaying a
     different buffer in a window and making a new window also call
     these functions.

     This variable is not a normal hook, because each function is called
     with two arguments: the window, and its new display-start position.
     At the time of the call, the display-start position of the argument
     window is already set to its new value, and the buffer to be
     displayed in the window is set as the current buffer.

     These functions must take care when using 'window-end' (*note
     Window Start and End::); if you need an up-to-date value, you must
     use the UPDATE argument to ensure you get it.

     Warning: don't use this feature to alter the way the window is
     scrolled.  It's not designed for that, and such use probably won't
     work.

   In addition, you can use 'jit-lock-register' to register a Font Lock
fontification function, which will be called whenever parts of a buffer
are (re)fontified because a window was scrolled or its size changed.
*Note Other Font Lock Variables::.

   The remainder of this section covers six hooks that are called during
redisplay provided a significant, non-scrolling change of a window has
been detected.  For simplicity, these hooks and the functions they call
will be collectively referred to as "window change functions".

   The first of these hooks is run after a "window buffer change" is
detected, which means that a window was created, deleted or assigned
another buffer.

 -- Variable: window-buffer-change-functions
     This variable specifies functions called during redisplay when
     window buffers have changed.  The value should be a list of
     functions that take one argument.

     Functions specified buffer-locally are called for any window
     showing the corresponding buffer if that window has been created or
     assigned that buffer since the last time window change functions
     were run.  In this case the window is passed as argument.

     Functions specified by the default value are called for a frame if
     at least one window on that frame has been added, deleted or
     assigned another buffer since the last time window change functions
     were run.  In this case the frame is passed as argument.

   The second of these hooks is run when a "window size change" has been
detected which means that a window was created, assigned another buffer,
or changed its total size or that of its text area.

 -- Variable: window-size-change-functions
     This variable specifies functions called during redisplay when a
     window size change occurred.  The value should be a list of
     functions that take one argument.

     Functions specified buffer-locally are called for any window
     showing the corresponding buffer if that window has been added or
     assigned another buffer or changed its total or body size since the
     last time window change functions were run.  In this case the
     window is passed as argument.

     Functions specified by the default value are called for a frame if
     at least one window on that frame has been added or assigned
     another buffer or changed its total or body size since the last
     time window change functions were run.  In this case the frame is
     passed as argument.

   The third of these hooks is run when a "window selection change" has
selected another window since the last redisplay.

 -- Variable: window-selection-change-functions
     This variable specifies functions called during redisplay when the
     selected window or a frame's selected window has changed.  The
     value should be a list of functions that take one argument.

     Functions specified buffer-locally are called for any window
     showing the corresponding buffer if that window has been selected
     or deselected (among all windows or among all windows on its frame)
     since the last time window change functions were run.  In this case
     the window is passed as argument.

     Functions specified by the default value are called for a frame if
     that frame has been selected or deselected or the frame's selected
     window has changed since the last time window change functions were
     run.  In this case the frame is passed as argument.

   The fourth of these hooks is run when a "window state change" has
been detected, which means that at least one of the three preceding
window changes has occurred.

 -- Variable: window-state-change-functions
     This variable specifies functions called during redisplay when a
     window buffer or size change occurred or the selected window or a
     frame's selected window has changed.  The value should be a list of
     functions that take one argument.

     Functions specified buffer-locally are called for any window
     showing the corresponding buffer if that window has been added or
     assigned another buffer, changed its total or body size or has been
     selected or deselected (among all windows or among all windows on
     its frame) since the last time window change functions were run.
     In this case the window is passed as argument.

     Functions specified by the default value are called for a frame if
     at least one window on that frame has been added, deleted or
     assigned another buffer, changed its total or body size or that
     frame has been selected or deselected or the frame's selected
     window has changed since the last time window change functions were
     run.  In this case the frame is passed as argument.

     Functions specified by the default value are also run for a frame
     when that frame's window state change flag (see below) has been set
     since last redisplay.

   The fifth of these hooks is run when a "window configuration change"
has been detected which means that either the buffer or the size of a
window changed.  It differs from the four preceding hooks in the way it
is run.

 -- Variable: window-configuration-change-hook
     This variable specifies functions called during redisplay when
     either the buffer or the size of a window has changed.  The value
     should be a list of functions that take no argument.

     Functions specified buffer-locally are called for any window
     showing the corresponding buffer if at least one window on that
     frame has been added, deleted or assigned another buffer or changed
     its total or body size since the last time window change functions
     were run.  Each call is performed with the window showing the
     buffer temporarily selected and its buffer current.

     Functions specified by the default value are called for each frame
     if at least one window on that frame has been added, deleted or
     assigned another buffer or changed its total or body size since the
     last time window change functions were run.  Each call is performed
     with the frame temporarily selected and the selected window's
     buffer current.

   Finally, Emacs runs a normal hook that generalizes the behavior of
'window-state-change-functions'.

 -- Variable: window-state-change-hook
     The default value of this variable specifies functions called
     during redisplay when a window state change has been detected or
     the window state change flag has been set on at least one frame.
     The value should be a list of functions that take no argument.

     Applications should put a function on this hook only if they want
     to react to changes that happened on (or have been signaled for)
     two or more frames since last redisplay.  In every other case,
     putting the function on 'window-state-change-functions' should be
     preferred.

   Window change functions are called during redisplay for each frame as
follows: First, any buffer-local window buffer change function, window
size change function, selected window change and window state change
functions are called in this order.  Next, the default values for these
functions are called in the same order.  Then any buffer-local window
configuration change functions are called followed by functions
specified by the default value of those functions.  Finally, functions
on 'window-state-change-hook' are run.

   Window change functions are run for a specific frame only if a
corresponding change was registered for that frame earlier.  Such
changes include the creation or deletion of a window or the assignment
of another buffer or size to a window.  Note that even when such a
change has been registered, this does not mean that any of the hooks
described above is run.  If, for example, a change was registered within
the scope of a window excursion (*note Window Configurations::), this
will trigger a call of window change functions only if that excursion
still persists at the time change functions are run.  If it is exited
earlier, hooks will be run only if registered by a change outside the
scope of that excursion.

   The "window state change flag" of a frame, if set, will cause the
default values of 'window-state-change-functions' (for that frame) and
'window-state-change-hook' to be run during next redisplay regardless of
whether a window state change actually occurred for that frame or not.
After running any functions on these hooks, the flag is reset for each
frame.  Applications can set that flag and inspect its value using the
following functions.

 -- Function: set-frame-window-state-change &optional frame arg
     This function sets FRAME's window state change flag if ARG is
     non-'nil' and resets it otherwise.  FRAME must be a live frame and
     defaults to the selected one.

 -- Function: frame-window-state-change &optional frame
     This functions returns 't' if FRAME's window state change flag is
     set and 'nil' otherwise.  FRAME must be a live frame and defaults
     to the selected one.

   While window change functions are run, the functions described next
can be called to get more insight into what has changed for a specific
window or frame since the last redisplay.  All these functions take a
live window as single, optional argument, defaulting to the selected
window.

 -- Function: window-old-buffer &optional window
     This function returns the buffer shown in WINDOW at the last time
     window change functions were run for WINDOW's frame.  If it returns
     'nil', WINDOW has been created after that.  If it returns 't',
     WINDOW was not shown at that time but has been restored from a
     previously saved window configuration afterwards.  Otherwise, the
     return value is the buffer shown by 'window' at that time.

 -- Function: window-old-pixel-width &optional window
     This function returns the total pixel width of WINDOW the last time
     window change functions found 'window' live on its frame.  It is
     zero if 'window' was created after that.

 -- Function: window-old-pixel-height &optional window
     This function returns the total pixel height of WINDOW the last
     time window change functions found 'window' live on its frame.  It
     is zero if 'window' was created after that.

 -- Function: window-old-body-pixel-width &optional window
     This function returns the pixel width of WINDOW's text area the
     last time window change functions found 'window' live on its frame.
     It is zero if 'window' was created after that.

 -- Function: window-old-body-pixel-height &optional window
     This function returns the pixel height of WINDOW's text area the
     last time window change functions found 'window' live on its frame.
     It is zero if 'window' was created after that.

   In order to find out which window or frame was selected the last time
window change functions were run, the following functions can be used:

 -- Function: frame-old-selected-window &optional frame
     This function returns the selected window of FRAME at the last time
     window change functions were run.  If omitted or 'nil' FRAME
     defaults to the selected frame.

 -- Function: old-selected-window
     This function returns the selected window at the last time window
     change functions were run.

 -- Function: old-selected-frame
     This function returns the selected frame at the last time window
     change functions were run.

   Note that window change functions provide no information about which
windows have been deleted since the last time they were run.  If
necessary, applications should remember any window showing a specific
buffer in a local variable of that buffer and update it in a function
run by the default values of any of the hooks that are run when a window
buffer change was detected.

   The following caveats should be considered when adding a function to
window change functions:

   * Some operations will not trigger a call of window change functions.
     These include showing another buffer in a minibuffer window or any
     change of a tooltip window.

   * Window change functions should not create or delete windows or
     change the buffer, size or selection status of any window because
     there is no guarantee that the information about such a change will
     be propagated to other window change functions.  If at all, any
     such change should be executed only by the last function listed by
     the default value of 'window-state-change-hook'.

   * Macros like 'save-window-excursion', 'with-selected-window' or
     'with-current-buffer' can be used when running window change
     functions.

   * Running window change functions does not save and restore match
     data.  Unless running 'window-configuration-change-hook' it does
     not save or restore the selected window or frame or the current
     buffer either.

   * Any redisplay triggering the run of window change functions may be
     aborted.  If the abort occurs before window change functions have
     run to their completion, they will be run again with the previous
     values, that is, as if redisplay had not been performed.  If
     aborted later, they will be run with the new values, that is, as if
     redisplay had been actually performed.

==============================================================================
File: elisp.info,  Node: |Frames|,  Next: |Positions|,  Prev: |Windows|,  Up: |Top|
==============================================================================

                                                                        *Frames*

29 Frames
=========

A "frame" is a screen object that contains one or more Emacs windows
(*note Windows::).  It is the kind of object called a "window" in the
terminology of graphical environments; but we can't call it a "window"
here, because Emacs uses that word in a different way.  In Emacs Lisp, a
"frame object" is a Lisp object that represents a frame on the screen.
*Note Frame Type::.

   A frame initially contains a single main window and/or a minibuffer
window; you can subdivide the main window vertically or horizontally
into smaller windows.  *Note Splitting Windows::.

   A "terminal" is a display device capable of displaying one or more
Emacs frames.  In Emacs Lisp, a "terminal object" is a Lisp object that
represents a terminal.  *Note Terminal Type::.

   There are two classes of terminals: "text terminals" and "graphical
terminals".  Text terminals are non-graphics-capable displays, including
'xterm' and other terminal emulators.  On a text terminal, each Emacs
frame occupies the terminal's entire screen; although you can create
additional frames and switch between them, the terminal only shows one
frame at a time.  Graphical terminals, on the other hand, are managed by
graphical display systems such as the X Window System, which allow Emacs
to show multiple frames simultaneously on the same display.

   On GNU and Unix systems, you can create additional frames on any
available terminal, within a single Emacs session, regardless of whether
Emacs was started on a text or graphical terminal.  Emacs can display on
both graphical and text terminals simultaneously.  This comes in handy,
for instance, when you connect to the same session from several remote
locations.  *Note Multiple Terminals::.

 -- Function: framep object
     This predicate returns a non-'nil' value if OBJECT is a frame, and
     'nil' otherwise.  For a frame, the value indicates which kind of
     display the frame uses:

     't'
          The frame is displayed on a text terminal.
     'x'
          The frame is displayed on an X graphical terminal.
     'w32'
          The frame is displayed on a MS-Windows graphical terminal.
     'ns'
          The frame is displayed on a GNUstep or Macintosh Cocoa
          graphical terminal.
     'pc'
          The frame is displayed on an MS-DOS terminal.

 -- Function: frame-terminal &optional frame
     This function returns the terminal object that displays FRAME.  If
     FRAME is 'nil' or unspecified, it defaults to the selected frame.

 -- Function: terminal-live-p object
     This predicate returns a non-'nil' value if OBJECT is a terminal
     that is live (i.e., not deleted), and 'nil' otherwise.  For live
     terminals, the return value indicates what kind of frames are
     displayed on that terminal; the list of possible values is the same
     as for 'framep' above.

   On a graphical terminal we distinguish two types of frames: A normal
"top-level frame" is a frame whose window-system window is a child of
the window-system's root window for that terminal.  A child frame is a
frame whose window-system window is the child of the window-system
window of another Emacs frame.  *Note Child Frames::.

MENU

* |Creating_Frames|::             Creating additional frames.
* |Multiple_Terminals|::          Displaying on several different devices.
* |Frame_Geometry|::              Geometric properties of frames.
* |Frame_Parameters|::            Controlling frame size, position, font, etc.
* |Terminal_Parameters|::         Parameters common for all frames on terminal.
* |Frame_Titles|::                Automatic updating of frame titles.
* |Deleting_Frames|::             Frames last until explicitly deleted.
* |Finding_All_Frames|::          How to examine all existing frames.
* |Minibuffers_and_Frames|::      How a frame finds the minibuffer to use.
* |Input_Focus|::                 Specifying the selected frame.
* |Visibility_of_Frames|::        Frames may be visible or invisible, or icons.
* |Raising_and_Lowering|::        Raising, Lowering and Restacking Frames.
* |Frame_Configurations|::        Saving the state of all frames.
* |Child_Frames|::                Making a frame the child of another.
* |Mouse_Tracking|::              Getting events that say when the mouse moves.
* |Mouse_Position|::              Asking where the mouse is, or moving it.
* |Pop_Up_Menus|::                Displaying a menu for the user to select from.
* |Dialog_Boxes|::                Displaying a box to ask yes or no.
* |Pointer_Shape|::               Specifying the shape of the mouse pointer.
* |Window_System_Selections|::    Transferring text to and from other X clients.
* |Drag_and_Drop|::               Internals of Drag-and-Drop implementation.
* |Color_Names|::                 Getting the definitions of color names.
* |Text_Terminal_Colors|::        Defining colors for text terminals.
* |Resources|::                   Getting resource values from the server.
* |Display_Feature_Testing|::     Determining the features of a terminal.

==============================================================================
File: elisp.info,  Node: |Creating_Frames|,  Next: |Multiple_Terminals|,  Up: |Frames|
==============================================================================

                                                               *Creating_Frames*

29.1 Creating Frames
--------------------

To create a new frame, call the function 'make-frame'.

 -- Command: make-frame &optional parameters
     This function creates and returns a new frame, displaying the
     current buffer.

     The PARAMETERS argument is an alist that specifies frame parameters
     for the new frame.  *Note Frame Parameters::.  If you specify the
     'terminal' parameter in PARAMETERS, the new frame is created on
     that terminal.  Otherwise, if you specify the 'window-system' frame
     parameter in PARAMETERS, that determines whether the frame should
     be displayed on a text terminal or a graphical terminal.  *Note
     Window Systems::.  If neither is specified, the new frame is
     created in the same terminal as the selected frame.

     Any parameters not mentioned in PARAMETERS default to the values in
     the alist 'default-frame-alist' (*note Initial Parameters::);
     parameters not specified there default from the X resources or its
     equivalent on your operating system (*note X Resources: (emacs)X
     Resources.).  After the frame is created, this function applies any
     parameters specified in 'frame-inherited-parameters' (see below) it
     has no assigned yet, taking the values from the frame that was
     selected when 'make-frame' was called.

     Note that on multi-monitor displays (*note Multiple Terminals::),
     the window manager might position the frame differently than
     specified by the positional parameters in PARAMETERS (*note
     Position Parameters::).  For example, some window managers have a
     policy of displaying the frame on the monitor that contains the
     largest part of the window (a.k.a. the "dominating" monitor).

     This function itself does not make the new frame the selected
     frame.  *Note Input Focus::.  The previously selected frame remains
     selected.  On graphical terminals, however, the windowing system
     may select the new frame for its own reasons.

 -- Variable: before-make-frame-hook
     A normal hook run by 'make-frame' before it creates the frame.

 -- Variable: after-make-frame-functions
     An abnormal hook run by 'make-frame' after it created the frame.
     Each function in 'after-make-frame-functions' receives one
     argument, the frame just created.

   Note that any functions added to these hooks by your initial file are
usually not run for the initial frame, since Emacs reads the initial
file only after creating that frame.  However, if the initial frame is
specified to use a separate minibuffer frame (*note Minibuffers and
Frames::), the functions will be run for both, the minibuffer-less and
the minibuffer frame.

 -- Variable: frame-inherited-parameters
     This variable specifies the list of frame parameters that a newly
     created frame inherits from the currently selected frame.  For each
     parameter (a symbol) that is an element in this list and has not
     been assigned earlier when processing 'make-frame', the function
     sets the value of that parameter in the created frame to its value
     in the selected frame.

 -- User Option: server-after-make-frame-hook
     A normal hook run when the Emacs server creates a client frame.
     When this hook is called, the created frame is the selected one.
     *Note (emacs)Emacs Server::.

==============================================================================
File: elisp.info,  Node: |Multiple_Terminals|,  Next: |Frame_Geometry|,  Prev: |Creating_Frames|,  Up: |Frames|
==============================================================================

                                                            *Multiple_Terminals*

29.2 Multiple Terminals
-----------------------

Emacs represents each terminal as a "terminal object" data type (*note
Terminal Type::).  On GNU and Unix systems, Emacs can use multiple
terminals simultaneously in each session.  On other systems, it can only
use a single terminal.  Each terminal object has the following
attributes:

   * The name of the device used by the terminal (e.g., ':0.0' or
     '/dev/tty').

   * The terminal and keyboard coding systems used on the terminal.
     *Note Terminal I/O Encoding::.

   * The kind of display associated with the terminal.  This is the
     symbol returned by the function 'terminal-live-p' (i.e., 'x', 't',
     'w32', 'ns', or 'pc').  *Note Frames::.

   * A list of terminal parameters.  *Note Terminal Parameters::.

   There is no primitive for creating terminal objects.  Emacs creates
them as needed, such as when you call 'make-frame-on-display' (described
below).

 -- Function: terminal-name &optional terminal
     This function returns the file name of the device used by TERMINAL.
     If TERMINAL is omitted or 'nil', it defaults to the selected
     frame's terminal.  TERMINAL can also be a frame, meaning that
     frame's terminal.

 -- Function: terminal-list
     This function returns a list of all live terminal objects.

 -- Function: get-device-terminal device
     This function returns a terminal whose device name is given by
     DEVICE.  If DEVICE is a string, it can be either the file name of a
     terminal device, or the name of an X display of the form
     'HOST:SERVER.SCREEN'.  If DEVICE is a frame, this function returns
     that frame's terminal; 'nil' means the selected frame.  Finally, if
     DEVICE is a terminal object that represents a live terminal, that
     terminal is returned.  The function signals an error if its
     argument is none of the above.

 -- Function: delete-terminal &optional terminal force
     This function deletes all frames on TERMINAL and frees the
     resources used by it.  It runs the abnormal hook
     'delete-terminal-functions', passing TERMINAL as the argument to
     each function.

     If TERMINAL is omitted or 'nil', it defaults to the selected
     frame's terminal.  TERMINAL can also be a frame, meaning that
     frame's terminal.

     Normally, this function signals an error if you attempt to delete
     the sole active terminal, but if FORCE is non-'nil', you are
     allowed to do so.  Emacs automatically calls this function when the
     last frame on a terminal is deleted (*note Deleting Frames::).

 -- Variable: delete-terminal-functions
     An abnormal hook run by 'delete-terminal'.  Each function receives
     one argument, the TERMINAL argument passed to 'delete-terminal'.
     Due to technical details, the functions may be called either just
     before the terminal is deleted, or just afterwards.

   A few Lisp variables are "terminal-local"; that is, they have a
separate binding for each terminal.  The binding in effect at any time
is the one for the terminal that the currently selected frame belongs
to.  These variables include 'default-minibuffer-frame',
'defining-kbd-macro', 'last-kbd-macro', and 'system-key-alist'.  They
are always terminal-local, and can never be buffer-local (*note
Buffer-Local Variables::).

   On GNU and Unix systems, each X display is a separate graphical
terminal.  When Emacs is started from within the X window system, it
uses the X display specified by the 'DISPLAY' environment variable, or
by the '--display' option (*note (emacs)Initial Options::).  Emacs can
connect to other X displays via the command 'make-frame-on-display'.
Each X display has its own selected frame and its own minibuffer
windows; however, only one of those frames is _the_ selected frame at
any given moment (*note Input Focus::).  Emacs can even connect to other
text terminals, by interacting with the 'emacsclient' program.  *Note
(emacs)Emacs Server::.

   A single X server can handle more than one display.  Each X display
has a three-part name, 'HOSTNAME:DISPLAYNUMBER.SCREENNUMBER'.  The first
part, HOSTNAME, specifies the name of the machine to which the display
is physically connected.  The second part, DISPLAYNUMBER, is a
zero-based number that identifies one or more monitors connected to that
machine that share a common keyboard and pointing device (mouse, tablet,
etc.).  The third part, SCREENNUMBER, identifies a zero-based screen
number (a separate monitor) that is part of a single monitor collection
on that X server.  When you use two or more screens belonging to one
server, Emacs knows by the similarity in their names that they share a
single keyboard.

   Systems that don't use the X window system, such as MS-Windows, don't
support the notion of X displays, and have only one display on each
host.  The display name on these systems doesn't follow the above 3-part
format; for example, the display name on MS-Windows systems is a
constant string 'w32', and exists for compatibility, so that you could
pass it to functions that expect a display name.

 -- Command: make-frame-on-display display &optional parameters
     This function creates and returns a new frame on DISPLAY, taking
     the other frame parameters from the alist PARAMETERS.  DISPLAY
     should be the name of an X display (a string).

     Before creating the frame, this function ensures that Emacs is set
     up to display graphics.  For instance, if Emacs has not processed X
     resources (e.g., if it was started on a text terminal), it does so
     at this time.  In all other respects, this function behaves like
     'make-frame' (*note Creating Frames::).

 -- Function: x-display-list
     This function returns a list that indicates which X displays Emacs
     has a connection to.  The elements of the list are strings, and
     each one is a display name.

 -- Function: x-open-connection display &optional xrm-string
          must-succeed
     This function opens a connection to the X display DISPLAY, without
     creating a frame on that display.  Normally, Emacs Lisp programs
     need not call this function, as 'make-frame-on-display' calls it
     automatically.  The only reason for calling it is to check whether
     communication can be established with a given X display.

     The optional argument XRM-STRING, if not 'nil', is a string of
     resource names and values, in the same format used in the
     '.Xresources' file.  *Note X Resources: (emacs)X Resources.  These
     values apply to all Emacs frames created on this display,
     overriding the resource values recorded in the X server.  Here's an
     example of what this string might look like:

          "*BorderWidth: 3\n*InternalBorder: 2\n"

     If MUST-SUCCEED is non-'nil', failure to open the connection
     terminates Emacs.  Otherwise, it is an ordinary Lisp error.

 -- Function: x-close-connection display
     This function closes the connection to display DISPLAY.  Before you
     can do this, you must first delete all the frames that were open on
     that display (*note Deleting Frames::).

   On some multi-monitor setups, a single X display outputs to more than
one physical monitor.  You can use the functions
'display-monitor-attributes-list' and 'frame-monitor-attributes' to
obtain information about such setups.

 -- Function: display-monitor-attributes-list &optional display
     This function returns a list of physical monitor attributes on
     DISPLAY, which can be a display name (a string), a terminal, or a
     frame; if omitted or 'nil', it defaults to the selected frame's
     display.  Each element of the list is an association list,
     representing the attributes of a physical monitor.  The first
     element corresponds to the primary monitor.  The attribute keys and
     values are:

     'geometry'
          Position of the top-left corner of the monitor's screen and
          its size, in pixels, as '(X Y WIDTH HEIGHT)'.  Note that, if
          the monitor is not the primary monitor, some of the
          coordinates might be negative.

     'workarea'
          Position of the top-left corner and size of the work area
          (usable space) in pixels as '(X Y WIDTH HEIGHT)'.  This may be
          different from 'geometry' in that space occupied by various
          window manager features (docks, taskbars, etc.) may be
          excluded from the work area.  Whether or not such features
          actually subtract from the work area depends on the platform
          and environment.  Again, if the monitor is not the primary
          monitor, some of the coordinates might be negative.

     'mm-size'
          Width and height in millimeters as '(WIDTH HEIGHT)'

     'frames'
          List of frames that this physical monitor dominates (see
          below).

     'name'
          Name of the physical monitor as STRING.

     'source'
          Source of the multi-monitor information as STRING; e.g.,
          'XRandr' or 'Xinerama'.

     X, Y, WIDTH, and HEIGHT are integers.  'name' and 'source' may be
     absent.

     A frame is "dominated" by a physical monitor when either the
     largest area of the frame resides in that monitor, or (if the frame
     does not intersect any physical monitors) that monitor is the
     closest to the frame.  Every (non-tooltip) frame (whether visible
     or not) in a graphical display is dominated by exactly one physical
     monitor at a time, though the frame can span multiple (or no)
     physical monitors.

     Here's an example of the data produced by this function on a
     2-monitor display:

            (display-monitor-attributes-list)
            =>
            (((geometry 0 0 1920 1080) ;; Left-hand, primary monitor
              (workarea 0 0 1920 1050) ;; A taskbar occupies some of the height
              (mm-size 677 381)
              (name . "DISPLAY1")
              (frames #<frame emacs@host Messages 0x11578c0>
                      #<frame emacs@host scratch 0x114b838>))
             ((geometry 1920 0 1680 1050) ;; Right-hand monitor
              (workarea 1920 0 1680 1050) ;; Whole screen can be used
              (mm-size 593 370)
              (name . "DISPLAY2")
              (frames)))

 -- Function: frame-monitor-attributes &optional frame
     This function returns the attributes of the physical monitor
     dominating (see above) FRAME, which defaults to the selected frame.

   On multi-monitor displays it is possible to use the command
'make-frame-on-monitor' to make frames on the specified monitor.

 -- Command: make-frame-on-monitor monitor &optional display parameters
     This function creates and returns a new frame on MONITOR located on
     DISPLAY, taking the other frame parameters from the alist
     PARAMETERS.  MONITOR should be the name of the physical monitor,
     the same string as returned by the function
     'display-monitor-attributes-list' in the attribute 'name'.  DISPLAY
     should be the name of an X display (a string).

==============================================================================
File: elisp.info,  Node: |Frame_Geometry|,  Next: |Frame_Parameters|,  Prev: |Multiple_Terminals|,  Up: |Frames|
==============================================================================

                                                                *Frame_Geometry*

29.3 Frame Geometry
-------------------

The geometry of a frame depends on the toolkit that was used to build
this instance of Emacs and the terminal that displays the frame.  This
chapter describes these dependencies and some of the functions to deal
with them.  Note that the FRAME argument of all of these functions has
to specify a live frame (*note Deleting Frames::).  If omitted or 'nil',
it specifies the selected frame (*note Input Focus::).

MENU

* |Frame_Layout|::            Basic layout of frames.
* |Frame_Font|::              The default font of a frame and how to set it.
* |Frame_Position|::          The position of a frame on its display.
* |Frame_Size|::              Specifying and retrieving a frame's size.
* |Implied_Frame_Resizing|::  Implied resizing of frames and how to prevent it.

==============================================================================
File: elisp.info,  Node: |Frame_Layout|,  Next: |Frame_Font|,  Up: |Frame_Geometry|
==============================================================================

                                                                  *Frame_Layout*

29.3.1 Frame Layout
-------------------

A visible frame occupies a rectangular area on its terminal's display.
This area may contain a number of nested rectangles, each serving a
different purpose.  The drawing below sketches the layout of a frame on
a graphical terminal:

             <------------ Outer Frame Width ----------->
             ____________________________________________
          ^(0)  ________ External/Outer Border _______   |
          | |  |_____________ Title Bar ______________|  |
          | | (1)_____________ Menu Bar ______________|  | ^
          | | (2)_____________ Tool Bar ______________|  | ^
          | | (3) _________ Internal Border ________  |  | ^
          | |  | |   ^                              | |  | |
          | |  | |   |                              | |  | |
     Outer  |  | | Inner                            | |  | Native
     Frame  |  | | Frame                            | |  | Frame
     Height |  | | Height                           | |  | Height
          | |  | |   |                              | |  | |
          | |  | |<--+--- Inner Frame Width ------->| |  | |
          | |  | |   |                              | |  | |
          | |  | |___v______________________________| |  | |
          | |  |___________ Internal Border __________|  | v
          v |___________ External/Outer Border __________|
                <-------- Native Frame Width -------->


   In practice not all of the areas shown in the drawing will or may be
present.  The meaning of these areas is described below.

Outer Frame
     The "outer frame" is a rectangle comprising all areas shown in the
     drawing.  The edges of that rectangle are called the "outer edges"
     of the frame.  Together, the "outer width" and "outer height" of
     the frame specify the "outer size" of that rectangle.

     Knowing the outer size of a frame is useful for fitting a frame
     into the working area of its display (*note Multiple Terminals::)
     or for placing two frames adjacent to each other on the screen.
     Usually, the outer size of a frame is available only after the
     frame has been mapped (made visible, *note Visibility of Frames::)
     at least once.  For the initial frame or a frame that has not been
     created yet, the outer size can be only estimated or must be
     calculated from the window-system's or window manager's defaults.
     One workaround is to obtain the differences of the outer and native
     (see below) sizes of a mapped frame and use them for calculating
     the outer size of the new frame.

     The position of the upper left corner of the outer frame (indicated
     by '(0)' in the drawing above) is the "outer position" of the
     frame.  The outer position of a graphical frame is also referred to
     as "the position" of the frame because it usually remains unchanged
     on its display whenever the frame is resized or its layout is
     changed.

     The outer position is specified by and can be set via the 'left'
     and 'top' frame parameters (*note Position Parameters::).  For a
     normal, top-level frame these parameters usually represent its
     absolute position (see below) with respect to its display's origin.
     For a child frame (*note Child Frames::) these parameters represent
     its position relative to the native position (see below) of its
     parent frame.  For frames on text terminals the values of these
     parameters are meaningless and always zero.

External Border
     The "external border" is part of the decorations supplied by the
     window manager.  It is typically used for resizing the frame with
     the mouse and is therefore not shown on "fullboth" and maximized
     frames (*note Size Parameters::).  Its width is determined by the
     window manager and cannot be changed by Emacs' functions.

     External borders don't exist on text terminal frames.  For
     graphical frames, their display can be suppressed by setting the
     'override-redirect' or 'undecorated' frame parameter (*note
     Management Parameters::).

Outer Border
     The "outer border" is a separate border whose width can be
     specified with the 'border-width' frame parameter (*note Layout
     Parameters::).  In practice, either the external or the outer
     border of a frame are displayed but never both at the same time.
     Usually, the outer border is shown only for special frames that are
     not (fully) controlled by the window manager like tooltip frames
     (*note Tooltips::), child frames (*note Child Frames::) and
     'undecorated' or 'override-redirect' frames (*note Management
     Parameters::).

     Outer borders are never shown on text terminal frames and on frames
     generated by GTK+ routines.  On MS-Windows, the outer border is
     emulated with the help of a one pixel wide external border.
     Non-toolkit builds on X allow to change the color of the outer
     border by setting the 'border-color' frame parameter (*note Layout
     Parameters::).

Title Bar
     The "title bar", a.k.a. "caption bar", is also part of the window
     manager's decorations and typically displays the title of the frame
     (*note Frame Titles::) as well as buttons for minimizing,
     maximizing and deleting the frame.  It can be also used for
     dragging the frame with the mouse.  The title bar is usually not
     displayed for fullboth (*note Size Parameters::), tooltip (*note
     Tooltips::) and child frames (*note Child Frames::) and doesn't
     exist for terminal frames.  Display of the title bar can be
     suppressed by setting the 'override-redirect' or the 'undecorated'
     frame parameters (*note Management Parameters::).

Menu Bar
     The menu bar (*note Menu Bar::) can be either internal (drawn by
     Emacs itself) or external (drawn by the toolkit).  Most builds
     (GTK+, Lucid, Motif and MS-Windows) rely on an external menu bar.
     NS also uses an external menu bar which, however, is not part of
     the outer frame.  Non-toolkit builds can provide an internal menu
     bar.  On text terminal frames, the menu bar is part of the frame's
     root window (*note Windows and Frames::).  As a rule, menu bars are
     never shown on child frames (*note Child Frames::).  Display of the
     menu bar can be suppressed by setting the 'menu-bar-lines'
     parameter (*note Layout Parameters::) to zero.

     Whether the menu bar is wrapped or truncated whenever its width
     becomes too large to fit on its frame depends on the toolkit .
     Usually, only Motif and MS-Windows builds can wrap the menu bar.
     When they (un-)wrap the menu bar, they try to keep the outer height
     of the frame unchanged, so the native height of the frame (see
     below) will change instead.

Tool Bar
     Like the menu bar, the tool bar (*note Tool Bar::) can be either
     internal (drawn by Emacs itself) or external (drawn by a toolkit).
     The GTK+ and NS builds have the tool bar drawn by the toolkit.  The
     remaining builds use internal tool bars.  With GTK+ the tool bar
     can be located on either side of the frame, immediately outside the
     internal border, see below.  Tool bars are usually not shown for
     child frames (*note Child Frames::).  Display of the tool bar can
     be suppressed by setting the 'tool-bar-lines' parameter (*note
     Layout Parameters::) to zero.

     If the variable 'auto-resize-tool-bars' is non-'nil', Emacs wraps
     the internal tool bar when its width becomes too large for its
     frame.  If and when Emacs (un-)wraps the internal tool bar, it by
     default keeps the outer height of the frame unchanged, so the
     native height of the frame (see below) will change instead.  Emacs
     built with GTK+, on the other hand, never wraps the tool bar but
     may automatically increase the outer width of a frame in order to
     accommodate an overlong tool bar.

Native Frame
     The "native frame" is a rectangle located entirely within the outer
     frame.  It excludes the areas occupied by an external or outer
     border, the title bar and any external menu or tool bar.  The edges
     of the native frame are called the "native edges" of the frame.
     Together, the "native width" and "native height" of a frame specify
     the "native size" of the frame.

     The native size of a frame is the size Emacs passes to the
     window-system or window manager when creating or resizing the frame
     from within Emacs.  It is also the size Emacs receives from the
     window-system or window manager whenever these resize the frame's
     window-system window, for example, after maximizing the frame by
     clicking on the corresponding button in the title bar or when
     dragging its external border with the mouse.

     The position of the top left corner of the native frame specifies
     the "native position" of the frame.  (1)-(3) in the drawing above
     indicate that position for the various builds:

          (1) non-toolkit and terminal frames

          (2) Lucid, Motif and MS-Windows frames

          (3) GTK+ and NS frames

     Accordingly, the native height of a frame may include the height of
     the tool bar but not that of the menu bar (Lucid, Motif,
     MS-Windows) or those of the menu bar and the tool bar (non-toolkit
     and text terminal frames).

     The native position of a frame is the reference position for
     functions that set or return the current position of the mouse
     (*note Mouse Position::) and for functions dealing with the
     position of windows like 'window-edges', 'window-at' or
     'coordinates-in-window-p' (*note Coordinates and Windows::).  It
     also specifies the (0, 0) origin for locating and positioning child
     frames within this frame (*note Child Frames::).

     Note also that the native position of a frame usually remains
     unaltered on its display when removing or adding the window manager
     decorations by changing the frame's 'override-redirect' or
     'undecorated' parameter (*note Management Parameters::).

Internal Border
     The internal border is a border drawn by Emacs around the inner
     frame (see below).  Its width is specified by the
     'internal-border-width' frame parameter (*note Layout
     Parameters::).  Its color is specified by the background of the
     'internal-border' face.

Inner Frame
     The "inner frame" is the rectangle reserved for the frame's
     windows.  It's enclosed by the internal border which, however, is
     not part of the inner frame.  Its edges are called the "inner
     edges" of the frame.  The "inner width" and "inner height" specify
     the "inner size" of the rectangle.  The inner frame is sometimes
     also referred to as the "display area" of the frame.

     As a rule, the inner frame is subdivided into the frame's root
     window (*note Windows and Frames::) and the frame's minibuffer
     window (*note Minibuffer Windows::).  There are two notable
     exceptions to this rule: A "minibuffer-less frame" contains a root
     window only and does not contain a minibuffer window.  A
     "minibuffer-only frame" contains only a minibuffer window which
     also serves as that frame's root window.  See *note Initial
     Parameters:: for how to create such frame configurations.

Text Area
     The "text area" of a frame is a somewhat fictitious area that can
     be embedded in the native frame.  Its position is unspecified.  Its
     width can be obtained by removing from that of the native width the
     widths of the internal border, one vertical scroll bar, and one
     left and one right fringe if they are specified for this frame, see
     *note Layout Parameters::.  Its height can be obtained by removing
     from that of the native height the widths of the internal border
     and the heights of the frame's internal menu and tool bars and one
     horizontal scroll bar if specified for this frame.

   The "absolute position" of a frame is given as a pair (X, Y) of
horizontal and vertical pixel offsets relative to an origin (0, 0) of
the frame's display.  Correspondingly, the "absolute edges" of a frame
are given as pixel offsets from that origin.

   Note that with multiple monitors, the origin of the display does not
necessarily coincide with the top-left corner of the entire usable
display area of the terminal.  Hence the absolute position of a frame
can be negative in such an environment even when that frame is
completely visible.

   By convention, vertical offsets increase "downwards".  This means
that the height of a frame is obtained by subtracting the offset of its
top edge from that of its bottom edge.  Horizontal offsets increase
"rightwards", as expected, so a frame's width is calculated by
subtracting the offset of its left edge from that of its right edge.

   For a frame on a graphical terminal the following function returns
the sizes of the areas described above:

 -- Function: frame-geometry &optional frame
     This function returns geometric attributes of FRAME.  The return
     value is an association list of the attributes listed below.  All
     coordinate, height and width values are integers counting pixels.
     Note that if FRAME has not been mapped yet, (*note Visibility of
     Frames::) some of the return values may only represent
     approximations of the actual values--those that can be seen after
     the frame has been mapped.

     'outer-position'
          A cons representing the absolute position of the outer FRAME,
          relative to the origin at position (0, 0) of FRAME's display.

     'outer-size'
          A cons of the outer width and height of FRAME.

     'external-border-size'
          A cons of the horizontal and vertical width of FRAME's
          external borders as supplied by the window manager.  If the
          window manager doesn't supply these values, Emacs will try to
          guess them from the coordinates of the outer and inner frame.

     'outer-border-width'
          The width of the outer border of FRAME.  The value is
          meaningful for non-GTK+ X builds only.

     'title-bar-size'
          A cons of the width and height of the title bar of FRAME as
          supplied by the window manager or operating system.  If both
          of them are zero, the frame has no title bar.  If only the
          width is zero, Emacs was not able to retrieve the width
          information.

     'menu-bar-external'
          If non-'nil', this means the menu bar is external (not part of
          the native frame of FRAME).

     'menu-bar-size'
          A cons of the width and height of the menu bar of FRAME.

     'tool-bar-external'
          If non-'nil', this means the tool bar is external (not part of
          the native frame of FRAME).

     'tool-bar-position'
          This tells on which side the tool bar on FRAME is and can be
          one of 'left', 'top', 'right' or 'bottom'.  The only toolkit
          that currently supports a value other than 'top' is GTK+.

     'tool-bar-size'
          A cons of the width and height of the tool bar of FRAME.

     'internal-border-width'
          The width of the internal border of FRAME.

   The following function can be used to retrieve the edges of the
outer, native and inner frame.

 -- Function: frame-edges &optional frame type
     This function returns the absolute edges of the outer, native or
     inner frame of FRAME.  FRAME must be a live frame and defaults to
     the selected one.  The returned list has the form
     '(LEFT TOP RIGHT BOTTOM)' where all values are in pixels relative
     to the origin of FRAME's display.  For terminal frames the values
     returned for LEFT and TOP are always zero.

     Optional argument TYPE specifies the type of the edges to return:
     'outer-edges' means to return the outer edges of FRAME,
     'native-edges' (or 'nil') means to return its native edges and
     'inner-edges' means to return its inner edges.

     By convention, the pixels of the display at the values returned for
     LEFT and TOP are considered to be inside (part of) FRAME.  Hence,
     if LEFT and TOP are both zero, the pixel at the display's origin is
     part of FRAME.  The pixels at BOTTOM and RIGHT, on the other hand,
     are considered to lie immediately outside FRAME.  This means that
     if you have, for example, two side-by-side frames positioned such
     that the right outer edge of the frame on the left equals the left
     outer edge of the frame on the right, the pixels at that edge show
     a part of the frame on the right.

==============================================================================
File: elisp.info,  Node: |Frame_Font|,  Next: |Frame_Position|,  Prev: |Frame_Layout|,  Up: |Frame_Geometry|
==============================================================================

                                                                    *Frame_Font*

29.3.2 Frame Font
-----------------

Each frame has a "default font" which specifies the default character
size for that frame.  This size is meant when retrieving or changing the
size of a frame in terms of columns or lines (*note Size Parameters::).
It is also used when resizing (*note Window Sizes::) or splitting (*note
Splitting Windows::) windows.

   The terms "line height" and "canonical character height" are
sometimes used instead of "default character height".  Similarly, the
terms "column width" and "canonical character width" are used instead of
"default character width".

 -- Function: frame-char-height &optional frame
 -- Function: frame-char-width &optional frame
     These functions return the default height and width of a character
     in FRAME, measured in pixels.  Together, these values establish the
     size of the default font on FRAME.  The values depend on the choice
     of font for FRAME, see *note Font and Color Parameters::.

   The default font can be also set directly with the following
function:

 -- Command: set-frame-font font &optional keep-size frames
     This sets the default font to FONT.  When called interactively, it
     prompts for the name of a font, and uses that font on the selected
     frame.  When called from Lisp, FONT should be a font name (a
     string), a font object, font entity, or a font spec.

     If the optional argument KEEP-SIZE is 'nil', this keeps the number
     of frame lines and columns fixed.  (If non-'nil', the option
     'frame-inhibit-implied-resize' described in the next section will
     override this.)  If KEEP-SIZE is non-'nil' (or with a prefix
     argument), it tries to keep the size of the display area of the
     current frame fixed by adjusting the number of lines and columns.

     If the optional argument FRAMES is 'nil', this applies the font to
     the selected frame only.  If FRAMES is non-'nil', it should be a
     list of frames to act upon, or 't' meaning all existing and all
     future graphical frames.

==============================================================================
File: elisp.info,  Node: |Frame_Position|,  Next: |Frame_Size|,  Prev: |Frame_Font|,  Up: |Frame_Geometry|
==============================================================================

                                                                *Frame_Position*

29.3.3 Frame Position
---------------------

On graphical systems, the position of a normal top-level frame is
specified as the absolute position of its outer frame (*note Frame
Geometry::).  The position of a child frame (*note Child Frames::) is
specified via pixel offsets of its outer edges relative to the native
position of its parent frame.

   You can access or change the position of a frame using the frame
parameters 'left' and 'top' (*note Position Parameters::).  Here are two
additional functions for working with the positions of an existing,
visible frame.  For both functions, the argument FRAME must denote a
live frame and defaults to the selected frame.

 -- Function: frame-position &optional frame
     For a normal, non-child frame this function returns a cons of the
     pixel coordinates of its outer position (*note Frame Layout::) with
     respect to the origin '(0, 0)' of its display.  For a child frame
     (*note Child Frames::) this function returns the pixel coordinates
     of its outer position with respect to an origin '(0, 0)' at the
     native position of FRAME's parent.

     Negative values never indicate an offset from the right or bottom
     edge of FRAME's display or parent frame.  Rather, they mean that
     FRAME's outer position is on the left and/or above the origin of
     its display or the native position of its parent frame.  This
     usually means that FRAME is only partially visible (or completely
     invisible).  However, on systems where the display's origin does
     not coincide with its top-left corner, the frame may be visible on
     a secondary monitor.

     On a text terminal frame both values are zero.

 -- Function: set-frame-position frame x y
     This function sets the outer frame position of FRAME to (X, Y).
     The latter arguments specify pixels and normally count from the
     origin at the position (0, 0) of FRAME's display.  For child
     frames, they count from the native position of FRAME's parent
     frame.

     Negative parameter values position the right edge of the outer
     frame by -X pixels left from the right edge of the screen (or the
     parent frame's native rectangle) and the bottom edge by -Y pixels
     up from the bottom edge of the screen (or the parent frame's native
     rectangle).

     Note that negative values do not permit to align the right or
     bottom edge of FRAME exactly at the right or bottom edge of its
     display or parent frame.  Neither do they allow to specify a
     position that does not lie within the edges of the display or
     parent frame.  The frame parameters 'left' and 'top' (*note
     Position Parameters::) allow to do that, but may still fail to
     provide good results for the initial or a new frame.

     This function has no effect on text terminal frames.

 -- Variable: move-frame-functions
     This hook specifies the functions that are run when an Emacs frame
     is moved (assigned a new position) by the window-system or window
     manager.  The functions are run with one argument, the frame that
     moved.  For a child frame (*note Child Frames::), the functions are
     run only when the position of the frame changes in relation to that
     of its parent frame.

==============================================================================
File: elisp.info,  Node: |Frame_Size|,  Next: |Implied_Frame_Resizing|,  Prev: |Frame_Position|,  Up: |Frame_Geometry|
==============================================================================

                                                                    *Frame_Size*

29.3.4 Frame Size
-----------------

The canonical way to specify the "size of a frame" from within Emacs is
by specifying its "text size"--a tuple of the width and height of the
frame's text area (*note Frame Layout::).  It can be measured either in
pixels or in terms of the frame's canonical character size (*note Frame
Font::).

   For frames with an internal menu or tool bar, the frame's native
height cannot be told exactly before the frame has been actually drawn.
This means that in general you cannot use the native size to specify the
initial size of a frame.  As soon as you know the native size of a
visible frame, you can calculate its outer size (*note Frame Layout::)
by adding in the remaining components from the return value of
'frame-geometry'.  For invisible frames or for frames that have yet to
be created, however, the outer size can only be estimated.  This also
means that calculating an exact initial position of a frame specified
via offsets from the right or bottom edge of the screen (*note Frame
Position::) is impossible.

   The text size of any frame can be set and retrieved with the help of
the 'height' and 'width' frame parameters (*note Size Parameters::).
The text size of the initial frame can be also set with the help of an
X-style geometry specification.  *Note Command Line Arguments for Emacs
Invocation: (emacs)Emacs Invocation.  Below we list some functions to
access and set the size of an existing, visible frame, by default the
selected one.

 -- Function: frame-height &optional frame
 -- Function: frame-width &optional frame
     These functions return the height and width of the text area of
     FRAME, measured in units of the default font height and width of
     FRAME (*note Frame Font::).  These functions are plain shorthands
     for writing '(frame-parameter frame 'height)' and '(frame-parameter
     frame 'width)'.

     If the text area of FRAME measured in pixels is not a multiple of
     its default font size, the values returned by these functions are
     rounded down to the number of characters of the default font that
     fully fit into the text area.

   The functions following next return the pixel widths and heights of
the native, outer and inner frame and the text area (*note Frame
Layout::) of a given frame.  For a text terminal, the results are in
characters rather than pixels.

 -- Function: frame-outer-width &optional frame
 -- Function: frame-outer-height &optional frame
     These functions return the outer width and height of FRAME in
     pixels.

 -- Function: frame-native-height &optional frame
 -- Function: frame-native-width &optional frame
     These functions return the native width and height of FRAME in
     pixels.

 -- Function: frame-inner-width &optional frame
 -- Function: frame-inner-height &optional frame
     These functions return the inner width and height of FRAME in
     pixels.

 -- Function: frame-text-width &optional frame
 -- Function: frame-text-height &optional frame
     These functions return the width and height of the text area of
     FRAME in pixels.

   On window systems that support it, Emacs tries by default to make the
text size of a frame measured in pixels a multiple of the frame's
character size.  This, however, usually means that a frame can be
resized only in character size increments when dragging its external
borders.  It also may break attempts to truly maximize the frame or
making it "fullheight" or "fullwidth" (*note Size Parameters::) leaving
some empty space below and/or on the right of the frame.  The following
option may help in that case.

 -- User Option: frame-resize-pixelwise
     If this option is 'nil' (the default), a frame's text pixel size is
     usually rounded to a multiple of the current values of that frame's
     'frame-char-height' and 'frame-char-width' whenever the frame is
     resized.  If this is non-'nil', no rounding occurs, hence frame
     sizes can increase/decrease by one pixel.

     Setting this variable usually causes the next resize operation to
     pass the corresponding size hints to the window manager.  This
     means that this variable should be set only in a user's initial
     file; applications should never bind it temporarily.

     The precise meaning of a value of 'nil' for this option depends on
     the toolkit used.  Dragging the external border with the mouse is
     done character-wise provided the window manager is willing to
     process the corresponding size hints.  Calling 'set-frame-size'
     (see below) with arguments that do not specify the frame size as an
     integer multiple of its character size, however, may: be ignored,
     cause a rounding (GTK+), or be accepted (Lucid, Motif, MS-Windows).

     With some window managers you may have to set this to non-'nil' in
     order to make a frame appear truly maximized or full-screen.

 -- Function: set-frame-size frame width height &optional pixelwise
     This function sets the size of the text area of FRAME, measured in
     terms of the canonical height and width of a character on FRAME
     (*note Frame Font::).

     The optional argument PIXELWISE non-'nil' means to measure the new
     width and height in units of pixels instead.  Note that if
     'frame-resize-pixelwise' is 'nil', some toolkits may refuse to
     truly honor the request if it does not increase/decrease the frame
     size to a multiple of its character size.

 -- Function: set-frame-height frame height &optional pretend pixelwise
     This function resizes the text area of FRAME to a height of HEIGHT
     lines.  The sizes of existing windows in FRAME are altered
     proportionally to fit.

     If PRETEND is non-'nil', then Emacs displays HEIGHT lines of output
     in FRAME, but does not change its value for the actual height of
     the frame.  This is only useful on text terminals.  Using a smaller
     height than the terminal actually implements may be useful to
     reproduce behavior observed on a smaller screen, or if the terminal
     malfunctions when using its whole screen.  Setting the frame height
     directly does not always work, because knowing the correct actual
     size may be necessary for correct cursor positioning on text
     terminals.

     The optional fourth argument PIXELWISE non-'nil' means that FRAME
     should be HEIGHT pixels high.  Note that if
     'frame-resize-pixelwise' is 'nil', some window managers may refuse
     to truly honor the request if it does not increase/decrease the
     frame height to a multiple of its character height.

     When used interactively, this command will set the height of the
     currently selected frame to the number of lines specified by the
     numeric prefix.

 -- Function: set-frame-width frame width &optional pretend pixelwise
     This function sets the width of the text area of FRAME, measured in
     characters.  The argument PRETEND has the same meaning as in
     'set-frame-height'.

     The optional fourth argument PIXELWISE non-'nil' means that FRAME
     should be WIDTH pixels wide.  Note that if 'frame-resize-pixelwise'
     is 'nil', some window managers may refuse to fully honor the
     request if it does not increase/decrease the frame width to a
     multiple of its character width.

     When used interactively, this command will set the width of the
     currently selected frame to the number of columns specified by the
     numeric prefix.

   None of these three functions will make a frame smaller than needed
to display all of its windows together with their scroll bars, fringes,
margins, dividers, mode and header lines.  This contrasts with requests
by the window manager triggered, for example, by dragging the external
border of a frame with the mouse.  Such requests are always honored by
clipping, if necessary, portions that cannot be displayed at the right,
bottom corner of the frame.  The parameters 'min-width' and 'min-height'
(*note Size Parameters::) can be used to obtain a similar behavior when
changing the frame size from within Emacs.

   The abnormal hook 'window-size-change-functions' (*note Window
Hooks::) tracks all changes of the inner size of a frame including those
induced by request of the window-system or window manager.  To rule out
false positives that might occur when changing only the sizes of a
frame's windows without actually changing the size of the inner frame,
use the following function.

 -- Function: frame-size-changed-p &optional frame
     This function returns non-'nil' when the inner width or height of
     FRAME has changed since 'window-size-change-functions' was run the
     last time for FRAME.  It always returns 'nil' immediately after
     running 'window-size-change-functions' for FRAME.

==============================================================================
File: elisp.info,  Node: |Implied_Frame_Resizing|,  Prev: |Frame_Size|,  Up: |Frame_Geometry|
==============================================================================

                                                        *Implied_Frame_Resizing*

29.3.5 Implied Frame Resizing
-----------------------------

By default, Emacs tries to keep the number of lines and columns of a
frame's text area unaltered when, for example, toggling its menu or tool
bar, changing its default font or setting the width of any of its scroll
bars.  This means that in such case Emacs must ask the window manager to
resize the frame's window in order to accommodate the size change.

   Occasionally, such "implied frame resizing" may be unwanted, for
example, when a frame has been maximized or made full-screen (where it's
turned off by default).  In general, users can disable implied resizing
with the following option:

 -- User Option: frame-inhibit-implied-resize
     If this option is 'nil', changing a frame's font, menu bar, tool
     bar, internal borders, fringes or scroll bars may resize its outer
     frame in order to keep the number of columns or lines of its text
     area unaltered.  If this option is 't', no such resizing is done.

     The value of this option can be also a list of frame parameters.
     In that case, implied resizing is inhibited for the change of a
     parameter that appears in this list.  Parameters currently handled
     by this option are 'font', 'font-backend', 'internal-border-width',
     'menu-bar-lines' and 'tool-bar-lines'.

     Changing any of the 'scroll-bar-width', 'scroll-bar-height',
     'vertical-scroll-bars', 'horizontal-scroll-bars', 'left-fringe' and
     'right-fringe' frame parameters is handled as if the frame
     contained just one live window.  This means, for example, that
     removing vertical scroll bars on a frame containing several side by
     side windows will shrink the outer frame width by the width of one
     scroll bar provided this option is 'nil' and keep it unchanged if
     this option is 't' or a list containing 'vertical-scroll-bars'.

     The default value is ''(tab-bar-lines tool-bar-lines)' for Lucid,
     Motif and MS-Windows (which means that adding/removing a tool or
     tab bar there does not change the outer frame height),
     ''(tab-bar-lines)' on all other window systems including GTK+
     (which means that changing any of the parameters listed above with
     the exception of 'tab-bar-lines' may change the size of the outer
     frame), and 't' otherwise (which means the outer frame size never
     changes implicitly when there's no window system support).

     Note that when a frame is not large enough to accommodate a change
     of any of the parameters listed above, Emacs may try to enlarge the
     frame even if this option is non-'nil'.

     Note also that window managers usually do not ask for resizing a
     frame when they change the number of lines occupied by an external
     menu or tool bar.  Typically, such "wrappings" occur when a user
     shrinks a frame horizontally, making it impossible to display all
     elements of its menu or tool bar.  They may also result from a
     change of the major mode altering the number of items of a menu or
     tool bar.  Any such wrappings may implicitly alter the number of
     lines of a frame's text area and are unaffected by the setting of
     this option.

==============================================================================
File: elisp.info,  Node: |Frame_Parameters|,  Next: |Terminal_Parameters|,  Prev: |Frame_Geometry|,  Up: |Frames|
==============================================================================

                                                              *Frame_Parameters*

29.4 Frame Parameters
---------------------

A frame has many parameters that control its appearance and behavior.
Just what parameters a frame has depends on what display mechanism it
uses.

   Frame parameters exist mostly for the sake of graphical displays.
Most frame parameters have no effect when applied to a frame on a text
terminal; only the 'height', 'width', 'name', 'title', 'menu-bar-lines',
'buffer-list' and 'buffer-predicate' parameters do something special.
If the terminal supports colors, the parameters 'foreground-color',
'background-color', 'background-mode' and 'display-type' are also
meaningful.  If the terminal supports frame transparency, the parameter
'alpha' is also meaningful.

   By default, frame parameters are saved and restored by the desktop
library functions (*note Desktop Save Mode::) when the variable
'desktop-restore-frames' is non-'nil'.  It's the responsibility of
applications that their parameters are included in
'frameset-persistent-filter-alist' to avoid that they get meaningless or
even harmful values in restored sessions.

MENU

* |Parameter_Access|::       How to change a frame's parameters.
* |Initial_Parameters|::     Specifying frame parameters when you make a frame.
* |Window_Frame_Parameters|:: List of frame parameters for window systems.
* |Geometry|::               Parsing geometry specifications.

==============================================================================
File: elisp.info,  Node: |Parameter_Access|,  Next: |Initial_Parameters|,  Up: |Frame_Parameters|
==============================================================================

                                                              *Parameter_Access*

29.4.1 Access to Frame Parameters
---------------------------------

These functions let you read and change the parameter values of a frame.

 -- Function: frame-parameter frame parameter
     This function returns the value of the parameter PARAMETER (a
     symbol) of FRAME.  If FRAME is 'nil', it returns the selected
     frame's parameter.  If FRAME has no setting for PARAMETER, this
     function returns 'nil'.

 -- Function: frame-parameters &optional frame
     The function 'frame-parameters' returns an alist listing all the
     parameters of FRAME and their values.  If FRAME is 'nil' or
     omitted, this returns the selected frame's parameters

 -- Function: modify-frame-parameters frame alist
     This function alters the frame FRAME based on the elements of
     ALIST.  Each element of ALIST has the form '(PARM . VALUE)', where
     PARM is a symbol naming a parameter.  If you don't mention a
     parameter in ALIST, its value doesn't change.  If FRAME is 'nil',
     it defaults to the selected frame.

     Some parameters are only meaningful for frames on certain kinds of
     display (*note Frames::).  If ALIST includes parameters that are
     not meaningful for the FRAME's display, this function will change
     its value in the frame's parameter list, but will otherwise ignore
     it.

     When ALIST specifies more than one parameter whose value can affect
     the new size of FRAME, the final size of the frame may differ
     according to the toolkit used.  For example, specifying that a
     frame should from now on have a menu and/or tool bar instead of
     none and simultaneously specifying the new height of the frame will
     inevitably lead to a recalculation of the frame's height.
     Conceptually, in such case, this function will try to have the
     explicit height specification prevail.  It cannot be excluded,
     however, that the addition (or removal) of the menu or tool bar,
     when eventually performed by the toolkit, will defeat this
     intention.

     Sometimes, binding 'frame-inhibit-implied-resize' (*note Implied
     Frame Resizing::) to a non-'nil' value around calls to this
     function may fix the problem sketched here.  Sometimes, however,
     exactly such binding may be hit by the problem.

 -- Function: set-frame-parameter frame parm value
     This function sets the frame parameter PARM to the specified VALUE.
     If FRAME is 'nil', it defaults to the selected frame.

 -- Function: modify-all-frames-parameters alist
     This function alters the frame parameters of all existing frames
     according to ALIST, then modifies 'default-frame-alist' (and, if
     necessary, 'initial-frame-alist') to apply the same parameter
     values to frames that will be created henceforth.

==============================================================================
File: elisp.info,  Node: |Initial_Parameters|,  Next: |Window_Frame_Parameters|,  Prev: |Parameter_Access|,  Up: |Frame_Parameters|
==============================================================================

                                                            *Initial_Parameters*

29.4.2 Initial Frame Parameters
-------------------------------

You can specify the parameters for the initial startup frame by setting
'initial-frame-alist' in your init file (*note Init File::).

 -- User Option: initial-frame-alist
     This variable's value is an alist of parameter values used when
     creating the initial frame.  You can set this variable to specify
     the appearance of the initial frame without altering subsequent
     frames.  Each element has the form:

          (PARAMETER . VALUE)

     Emacs creates the initial frame before it reads your init file.
     After reading that file, Emacs checks 'initial-frame-alist', and
     applies the parameter settings in the altered value to the already
     created initial frame.

     If these settings affect the frame geometry and appearance, you'll
     see the frame appear with the wrong ones and then change to the
     specified ones.  If that bothers you, you can specify the same
     geometry and appearance with X resources; those do take effect
     before the frame is created.  *Note X Resources: (emacs)X
     Resources.

     X resource settings typically apply to all frames.  If you want to
     specify some X resources solely for the sake of the initial frame,
     and you don't want them to apply to subsequent frames, here's how
     to achieve this.  Specify parameters in 'default-frame-alist' to
     override the X resources for subsequent frames; then, to prevent
     these from affecting the initial frame, specify the same parameters
     in 'initial-frame-alist' with values that match the X resources.

   If these parameters include '(minibuffer . nil)', that indicates that
the initial frame should have no minibuffer.  In this case, Emacs
creates a separate "minibuffer-only frame" as well.

 -- User Option: minibuffer-frame-alist
     This variable's value is an alist of parameter values used when
     creating an initial minibuffer-only frame (i.e., the
     minibuffer-only frame that Emacs creates if 'initial-frame-alist'
     specifies a frame with no minibuffer).

 -- User Option: default-frame-alist
     This is an alist specifying default values of frame parameters for
     all Emacs frames--the first frame, and subsequent frames.  When
     using the X Window System, you can get the same results by means of
     X resources in many cases.

     Setting this variable does not affect existing frames.
     Furthermore, functions that display a buffer in a separate frame
     may override the default parameters by supplying their own
     parameters.

   If you invoke Emacs with command-line options that specify frame
appearance, those options take effect by adding elements to either
'initial-frame-alist' or 'default-frame-alist'.  Options which affect
just the initial frame, such as '--geometry' and '--maximized', add to
'initial-frame-alist'; the others add to 'default-frame-alist'.  *note
Command Line Arguments for Emacs Invocation: (emacs)Emacs Invocation.

==============================================================================
File: elisp.info,  Node: |Window_Frame_Parameters|,  Next: |Geometry|,  Prev: |Initial_Parameters|,  Up: |Frame_Parameters|
==============================================================================

                                                       *Window_Frame_Parameters*

29.4.3 Window Frame Parameters
------------------------------

Just what parameters a frame has depends on what display mechanism it
uses.  This section describes the parameters that have special meanings
on some or all kinds of terminals.  Of these, 'name', 'title', 'height',
'width', 'buffer-list' and 'buffer-predicate' provide meaningful
information in terminal frames, and 'tty-color-mode' is meaningful only
for frames on text terminals.

MENU

* |Basic_Parameters|::            Parameters that are fundamental.
* |Position_Parameters|::         The position of the frame on the screen.
* |Size_Parameters|::             Frame's size.
* |Layout_Parameters|::           Size of parts of the frame, and
                                  enabling or disabling some parts.
* |Buffer_Parameters|::           Which buffers have been or should be shown.
* |Frame_Interaction_Parameters|::  Parameters for interacting with other
                                  frames.
* |Mouse_Dragging_Parameters|::   Parameters for resizing and moving
                                  frames with the mouse.
* |Management_Parameters|::       Communicating with the window manager.
* |Cursor_Parameters|::           Controlling the cursor appearance.
* |Font_and_Color_Parameters|::   Fonts and colors for the frame text.

==============================================================================
File: elisp.info,  Node: |Basic_Parameters|,  Next: |Position_Parameters|,  Up: |Window_Frame_Parameters|
==============================================================================

                                                              *Basic_Parameters*

29.4.3.1 Basic Parameters
-------------------------

These frame parameters give the most basic information about the frame.
'title' and 'name' are meaningful on all terminals.

'display'
     The display on which to open this frame.  It should be a string of
     the form 'HOST:DPY.SCREEN', just like the 'DISPLAY' environment
     variable.  *Note Multiple Terminals::, for more details about
     display names.

'display-type'
     This parameter describes the range of possible colors that can be
     used in this frame.  Its value is 'color', 'grayscale' or 'mono'.

'title'
     If a frame has a non-'nil' title, it appears in the window system's
     title bar at the top of the frame, and also in the mode line of
     windows in that frame if 'mode-line-frame-identification' uses '%F'
     (*note %-Constructs::).  This is normally the case when Emacs is
     not using a window system, and can only display one frame at a
     time.  *Note Frame Titles::.

'name'
     The name of the frame.  The frame name serves as a default for the
     frame title, if the 'title' parameter is unspecified or 'nil'.  If
     you don't specify a name, Emacs sets the frame name automatically
     (*note Frame Titles::).

     If you specify the frame name explicitly when you create the frame,
     the name is also used (instead of the name of the Emacs executable)
     when looking up X resources for the frame.

'explicit-name'
     If the frame name was specified explicitly when the frame was
     created, this parameter will be that name.  If the frame wasn't
     explicitly named, this parameter will be 'nil'.

==============================================================================
File: elisp.info,  Node: |Position_Parameters|,  Next: |Size_Parameters|,  Prev: |Basic_Parameters|,  Up: |Window_Frame_Parameters|
==============================================================================

                                                           *Position_Parameters*

29.4.3.2 Position Parameters
----------------------------

Parameters describing the X- and Y-offsets of a frame are always
measured in pixels.  For a normal, non-child frame they specify the
frame's outer position (*note Frame Geometry::) relative to its
display's origin.  For a child frame (*note Child Frames::) they specify
the frame's outer position relative to the native position of the
frame's parent frame.  (Note that none of these parameters is meaningful
on TTY frames.)

'left'
     The position, in pixels, of the left outer edge of the frame with
     respect to the left edge of the frame's display or parent frame.
     It can be specified in one of the following ways.

     an integer
          A positive integer always relates the left edge of the frame
          to the left edge of its display or parent frame.  A negative
          integer relates the right frame edge to the right edge of the
          display or parent frame.

     '(+ POS)'
          This specifies the position of the left frame edge relative to
          the left edge of its display or parent frame.  The integer POS
          may be positive or negative; a negative value specifies a
          position outside the screen or parent frame or on a monitor
          other than the primary one (for multi-monitor displays).

     '(- POS)'
          This specifies the position of the right frame edge relative
          to the right edge of the display or parent frame.  The integer
          POS may be positive or negative; a negative value specifies a
          position outside the screen or parent frame or on a monitor
          other than the primary one (for multi-monitor displays).

     a floating-point value
          A floating-point value in the range 0.0 to 1.0 specifies the
          left edge's offset via the "left position ratio" of the
          frame--the ratio of the left edge of its outer frame to the
          width of the frame's workarea (*note Multiple Terminals::) or
          its parent's native frame (*note Child Frames::) minus the
          width of the outer frame.  Thus, a left position ratio of 0.0
          flushes a frame to the left, a ratio of 0.5 centers it and a
          ratio of 1.0 flushes it to the right of its display or parent
          frame.  Similarly, the "top position ratio" of a frame is the
          ratio of the frame's top position to the height of its
          workarea or parent frame minus the height of the frame.

          Emacs will try to keep the position ratios of a child frame
          unaltered if that frame has a non-'nil' 'keep-ratio' parameter
          (*note Frame Interaction Parameters::) and its parent frame is
          resized.

          Since the outer size of a frame (*note Frame Geometry::) is
          usually unavailable before a frame has been made visible, it
          is generally not advisable to use floating-point values when
          creating decorated frames.  Floating-point values are more
          suited for ensuring that an (undecorated) child frame is
          positioned nicely within the area of its parent frame.

     Some window managers ignore program-specified positions.  If you
     want to be sure the position you specify is not ignored, specify a
     non-'nil' value for the 'user-position' parameter as in the
     following example:

          (modify-frame-parameters
            nil '((user-position . t) (left . (+ -4))))

     In general, it is not a good idea to position a frame relative to
     the right or bottom edge of its display.  Positioning the initial
     or a new frame is either not accurate (because the size of the
     outer frame is not yet fully known before the frame has been made
     visible) or will cause additional flicker (if the frame has to be
     repositioned after becoming visible).

     Note also, that positions specified relative to the right/bottom
     edge of a display, workarea or parent frame as well as
     floating-point offsets are stored internally as integer offsets
     relative to the left/top edge of the display, workarea or parent
     frame edge.  They are also returned as such by functions like
     'frame-parameters' and restored as such by the desktop saving
     routines.

'top'
     The screen position of the top (or bottom) edge, in pixels, with
     respect to the top (or bottom) edge of the display or parent frame.
     It works just like 'left', except vertically instead of
     horizontally.

'icon-left'
     The screen position of the left edge of the frame's icon, in
     pixels, counting from the left edge of the screen.  This takes
     effect when the frame is iconified, if the window manager supports
     this feature.  If you specify a value for this parameter, then you
     must also specify a value for 'icon-top' and vice versa.

'icon-top'
     The screen position of the top edge of the frame's icon, in pixels,
     counting from the top edge of the screen.  This takes effect when
     the frame is iconified, if the window manager supports this
     feature.

'user-position'
     When you create a frame and specify its screen position with the
     'left' and 'top' parameters, use this parameter to say whether the
     specified position was user-specified (explicitly requested in some
     way by a human user) or merely program-specified (chosen by a
     program).  A non-'nil' value says the position was user-specified.

     Window managers generally heed user-specified positions, and some
     heed program-specified positions too.  But many ignore
     program-specified positions, placing the window in a default
     fashion or letting the user place it with the mouse.  Some window
     managers, including 'twm', let the user specify whether to obey
     program-specified positions or ignore them.

     When you call 'make-frame', you should specify a non-'nil' value
     for this parameter if the values of the 'left' and 'top' parameters
     represent the user's stated preference; otherwise, use 'nil'.

'z-group'
     This parameter specifies a relative position of the frame's
     window-system window in the stacking (Z-) order of the frame's
     display.

     If this is 'above', the window-system will display the window that
     corresponds to the frame above all other window-system windows that
     do not have the 'above' property set.  If this is 'nil', the
     frame's window is displayed below all windows that have the 'above'
     property set and above all windows that have the 'below' property
     set.  If this is 'below', the frame's window is displayed below all
     windows that do not have the 'below' property set.

     To position the frame above or below a specific other frame use the
     function 'frame-restack' (*note Raising and Lowering::).

==============================================================================
File: elisp.info,  Node: |Size_Parameters|,  Next: |Layout_Parameters|,  Prev: |Position_Parameters|,  Up: |Window_Frame_Parameters|
==============================================================================

                                                               *Size_Parameters*

29.4.3.3 Size Parameters
------------------------

Frame parameters usually specify frame sizes in character units.  On
graphical displays, the 'default' face determines the actual pixel sizes
of these character units (*note Face Attributes::).

'width'
     This parameter specifies the width of the frame.  It can be
     specified as in the following ways:

     an integer
          A positive integer specifies the width of the frame's text
          area (*note Frame Geometry::) in characters.

     a cons cell
          If this is a cons cell with the symbol 'text-pixels' in its
          CAR, the CDR of that cell specifies the width of the frame's
          text area in pixels.

     a floating-point value
          A floating-point number between 0.0 and 1.0 can be used to
          specify the width of a frame via its "width ratio"--the ratio
          of its outer width (*note Frame Geometry::) to the width of
          the frame's workarea (*note Multiple Terminals::) or its
          parent frame's (*note Child Frames::) native frame.  Thus, a
          value of 0.5 makes the frame occupy half of the width of its
          workarea or parent frame, a value of 1.0 the full width.
          Similarly, the "height ratio" of a frame is the ratio of its
          outer height to the height of its workarea or its parent's
          native frame.

          Emacs will try to keep the width and height ratio of a child
          frame unaltered if that frame has a non-'nil' 'keep-ratio'
          parameter (*note Frame Interaction Parameters::) and its
          parent frame is resized.

          Since the outer size of a frame is usually unavailable before
          a frame has been made visible, it is generally not advisable
          to use floating-point values when creating decorated frames.
          Floating-point values are more suited to ensure that a child
          frame always fits within the area of its parent frame as, for
          example, when customizing 'display-buffer-alist' (*note
          Choosing Window::) via 'display-buffer-in-child-frame'.

     Regardless of how this parameter was specified, functions reporting
     the value of this parameter like 'frame-parameters' always report
     the width of the frame's text area in characters as an integer
     rounded, if necessary, to a multiple of the frame's default
     character width.  That value is also used by the desktop saving
     routines.

'height'
     This parameter specifies the height of the frame.  It works just
     like 'width', except vertically instead of horizontally.

'user-size'
     This does for the size parameters 'height' and 'width' what the
     'user-position' parameter (*note user-position: Position
     Parameters.) does for the position parameters 'top' and 'left'.

'min-width'
     This parameter specifies the minimum native width (*note Frame
     Geometry::) of the frame, in characters.  Normally, the functions
     that establish a frame's initial width or resize a frame
     horizontally make sure that all the frame's windows, vertical
     scroll bars, fringes, margins and vertical dividers can be
     displayed.  This parameter, if non-'nil' allows to make a frame
     narrower than that with the consequence that any components that do
     not fit will be clipped by the window manager.

'min-height'
     This parameter specifies the minimum native height (*note Frame
     Geometry::) of the frame, in characters.  Normally, the functions
     that establish a frame's initial size or resize a frame make sure
     that all the frame's windows, horizontal scroll bars and dividers,
     mode and header lines, the echo area and the internal menu and tool
     bar can be displayed.  This parameter, if non-'nil' allows to make
     a frame smaller than that with the consequence that any components
     that do not fit will be clipped by the window manager.

'fullscreen'
     This parameter specifies whether to maximize the frame's width,
     height or both.  Its value can be 'fullwidth', 'fullheight',
     'fullboth', or 'maximized'.  A "fullwidth" frame is as wide as
     possible, a "fullheight" frame is as tall as possible, and a
     "fullboth" frame is both as wide and as tall as possible.  A
     "maximized" frame is like a "fullboth" frame, except that it
     usually keeps its title bar and the buttons for resizing and
     closing the frame.  Also, maximized frames typically avoid hiding
     any task bar or panels displayed on the desktop.  A "fullboth"
     frame, on the other hand, usually omits the title bar and occupies
     the entire available screen space.

     Full-height and full-width frames are more similar to maximized
     frames in this regard.  However, these typically display an
     external border which might be absent with maximized frames.  Hence
     the heights of maximized and full-height frames and the widths of
     maximized and full-width frames often differ by a few pixels.

     With some window managers you may have to customize the variable
     'frame-resize-pixelwise' (*note Frame Size::) in order to make a
     frame truly appear maximized or full-screen.  Moreover, some window
     managers might not support smooth transition between the various
     full-screen or maximization states.  Customizing the variable
     'x-frame-normalize-before-maximize' can help to overcome that.

     Full-screen on macOS hides both the tool-bar and the menu-bar,
     however both will be displayed if the mouse pointer is moved to the
     top of the screen.

'fullscreen-restore'
     This parameter specifies the desired fullscreen state of the frame
     after invoking the 'toggle-frame-fullscreen' command (*note
     (emacs)Frame Commands::) in the "fullboth" state.  Normally this
     parameter is installed automatically by that command when toggling
     the state to fullboth.  If, however, you start Emacs in the
     "fullboth" state, you have to specify the desired behavior in your
     initial file as, for example

          (setq default-frame-alist
              '((fullscreen . fullboth)
                (fullscreen-restore . fullheight)))

     This will give a new frame full height after typing in it <F11> for
     the first time.

'fit-frame-to-buffer-margins'
     This parameter allows to override the value of the option
     'fit-frame-to-buffer-margins' when fitting this frame to the buffer
     of its root window with 'fit-frame-to-buffer' (*note Resizing
     Windows::).

'fit-frame-to-buffer-sizes'
     This parameter allows to override the value of the option
     'fit-frame-to-buffer-sizes' when fitting this frame to the buffer
     of its root window with 'fit-frame-to-buffer' (*note Resizing
     Windows::).

==============================================================================
File: elisp.info,  Node: |Layout_Parameters|,  Next: |Buffer_Parameters|,  Prev: |Size_Parameters|,  Up: |Window_Frame_Parameters|
==============================================================================

                                                             *Layout_Parameters*

29.4.3.4 Layout Parameters
--------------------------

These frame parameters enable or disable various parts of the frame, or
control their sizes.

'border-width'
     The width in pixels of the frame's outer border (*note Frame
     Geometry::).

'internal-border-width'
     The width in pixels of the frame's internal border (*note Frame
     Geometry::).

'vertical-scroll-bars'
     Whether the frame has scroll bars (*note Scroll Bars::) for
     vertical scrolling, and which side of the frame they should be on.
     The possible values are 'left', 'right', and 'nil' for no scroll
     bars.

'horizontal-scroll-bars'
     Whether the frame has scroll bars for horizontal scrolling ('t' and
     'bottom' mean yes, 'nil' means no).

'scroll-bar-width'
     The width of vertical scroll bars, in pixels, or 'nil' meaning to
     use the default width.

'scroll-bar-height'
     The height of horizontal scroll bars, in pixels, or 'nil' meaning
     to use the default height.

'left-fringe'
'right-fringe'
     The default width of the left and right fringes of windows in this
     frame (*note Fringes::).  If either of these is zero, that
     effectively removes the corresponding fringe.

     When you use 'frame-parameter' to query the value of either of
     these two frame parameters, the return value is always an integer.
     When using 'set-frame-parameter', passing a 'nil' value imposes an
     actual default value of 8 pixels.

'right-divider-width'
     The width (thickness) reserved for the right divider (*note Window
     Dividers::) of any window on the frame, in pixels.  A value of zero
     means to not draw right dividers.

'bottom-divider-width'
     The width (thickness) reserved for the bottom divider (*note Window
     Dividers::) of any window on the frame, in pixels.  A value of zero
     means to not draw bottom dividers.

'menu-bar-lines'
     The number of lines to allocate at the top of the frame for a menu
     bar (*note Menu Bar::).  The default is one if Menu Bar mode is
     enabled and zero otherwise.  *Note (emacs)Menu Bars::.  For an
     external menu bar (*note Frame Layout::), this value remains
     unchanged even when the menu bar wraps to two or more lines.  In
     that case, the 'menu-bar-size' value returned by 'frame-geometry'
     (*note Frame Geometry::) allows to derive whether the menu bar
     actually occupies one or more lines.

'tool-bar-lines'
     The number of lines to use for the tool bar (*note Tool Bar::).
     The default is one if Tool Bar mode is enabled and zero otherwise.
     *Note (emacs)Tool Bars::.  This value may change whenever the tool
     bar wraps (*note Frame Layout::).

'tool-bar-position'
     The position of the tool bar when Emacs was built with GTK+.  Its
     value can be one of 'top', 'bottom' 'left', 'right'.  The default
     is 'top'.

'line-spacing'
     Additional space to leave below each text line, in pixels (a
     positive integer).  *Note Line Height::, for more information.

'no-special-glyphs'
     If this is non-'nil', it suppresses the display of any truncation
     and continuation glyphs (*note Truncation::) for all buffers
     displayed by this frame.  This is useful to eliminate such glyphs
     when fitting a frame to its buffer via 'fit-frame-to-buffer' (*note
     Resizing Windows::).

==============================================================================
File: elisp.info,  Node: |Buffer_Parameters|,  Next: |Frame_Interaction_Parameters|,  Prev: |Layout_Parameters|,  Up: |Window_Frame_Parameters|
==============================================================================

                                                             *Buffer_Parameters*

29.4.3.5 Buffer Parameters
--------------------------

These frame parameters, meaningful on all kinds of terminals, deal with
which buffers have been, or should, be displayed in the frame.

'minibuffer'
     Whether this frame has its own minibuffer.  The value 't' means
     yes, 'nil' means no, 'only' means this frame is just a minibuffer.
     If the value is a minibuffer window (in some other frame), the
     frame uses that minibuffer.

     This parameter takes effect when the frame is created.  If
     specified as 'nil', Emacs will try to set it to the minibuffer
     window of 'default-minibuffer-frame' (*note Minibuffers and
     Frames::).  For an existing frame, this parameter can be used
     exclusively to specify another minibuffer window.  It is not
     allowed to change it from a minibuffer window to 't' and
     vice-versa, or from 't' to 'nil'.  If the parameter specifies a
     minibuffer window already, setting it to 'nil' has no effect.

     The special value 'child-frame' means to make a minibuffer-only
     child frame (*note Child Frames::) whose parent becomes the frame
     created.  As if specified as 'nil', Emacs will set this parameter
     to the minibuffer window of the child frame but will not select the
     child frame after its creation.

'buffer-predicate'
     The buffer-predicate function for this frame.  The function
     'other-buffer' uses this predicate (from the selected frame) to
     decide which buffers it should consider, if the predicate is not
     'nil'.  It calls the predicate with one argument, a buffer, once
     for each buffer; if the predicate returns a non-'nil' value, it
     considers that buffer.

'buffer-list'
     A list of buffers that have been selected in this frame, ordered
     most-recently-selected first.

'unsplittable'
     If non-'nil', this frame's window is never split automatically.

==============================================================================
File: elisp.info,  Node: |Frame_Interaction_Parameters|,  Next: |Mouse_Dragging_Parameters|,  Prev: |Buffer_Parameters|,  Up: |Window_Frame_Parameters|
==============================================================================

                                                  *Frame_Interaction_Parameters*

29.4.3.6 Frame Interaction Parameters
-------------------------------------

These parameters supply forms of interactions between different frames.

'parent-frame'
     If non-'nil', this means that this frame is a child frame (*note
     Child Frames::), and this parameter specifies its parent frame.  If
     'nil', this means that this frame is a normal, top-level frame.

'delete-before'
     If non-'nil', this parameter specifies another frame whose deletion
     will automatically trigger the deletion of this frame.  *Note
     Deleting Frames::.

'mouse-wheel-frame'
     If non-'nil', this parameter specifies the frame whose windows will
     be scrolled whenever the mouse wheel is scrolled with the mouse
     pointer hovering over this frame, see *note (emacs)Mouse
     Commands::.

'no-other-frame'
     If this is non-'nil', then this frame is not eligible as candidate
     for the functions 'next-frame', 'previous-frame' (*note Finding All
     Frames::) and 'other-frame', see *note (emacs)Frame Commands::.

'auto-hide-function'
     When this parameter specifies a function, that function will be
     called instead of the function specified by the variable
     'frame-auto-hide-function' when quitting the frame's only window
     (*note Quitting Windows::) and there are other frames left.

'minibuffer-exit'
     When this parameter is non-'nil', Emacs will by default make this
     frame invisible whenever the minibuffer (*note Minibuffers::) is
     exited.  Alternatively, it can specify the functions
     'iconify-frame' and 'delete-frame'.  This parameter is useful to
     make a child frame disappear automatically (similar to how Emacs
     deals with a window) when exiting the minibuffer.

'keep-ratio'
     This parameter is currently meaningful for child frames (*note
     Child Frames::) only.  If it is non-'nil', then Emacs will try to
     keep the frame's size (width and height) ratios (*note Size
     Parameters::) as well as its left and right position ratios (*note
     Position Parameters::) unaltered whenever its parent frame is
     resized.

     If the value of this parameter is 'nil', the frame's position and
     size remain unaltered when the parent frame is resized, so the
     position and size ratios may change.  If the value of this
     parameter is 't', Emacs will try to preserve the frame's size and
     position ratios, hence the frame's size and position relative to
     its parent frame may change.

     More individual control is possible by using a cons cell: In that
     case the frame's width ratio is preserved if the CAR of the cell is
     either 't' or 'width-only'.  The height ratio is preserved if the
     CAR of the cell is either 't' or 'height-only'.  The left position
     ratio is preserved if the CDR of the cell is either 't' or
     'left-only'.  The top position ratio is preserved if the CDR of the
     cell is either 't' or 'top-only'.

==============================================================================
File: elisp.info,  Node: |Mouse_Dragging_Parameters|,  Next: |Management_Parameters|,  Prev: |Frame_Interaction_Parameters|,  Up: |Window_Frame_Parameters|
==============================================================================

                                                     *Mouse_Dragging_Parameters*

29.4.3.7 Mouse Dragging Parameters
----------------------------------

The parameters described below provide support for resizing a frame by
dragging its internal borders with the mouse.  They also allow moving a
frame with the mouse by dragging the header line of its topmost or the
mode line of its bottommost window.

   These parameters are mostly useful for child frames (*note Child
Frames::) that come without window manager decorations.  If necessary,
they can be used for undecorated top-level frames as well.

'drag-internal-border'
     If non-'nil', the frame can be resized by dragging its internal
     borders, if present, with the mouse.

'drag-with-header-line'
     If non-'nil', the frame can be moved with the mouse by dragging the
     header line of its topmost window.

'drag-with-mode-line'
     If non-'nil', the frame can be moved with the mouse by dragging the
     mode line of its bottommost window.  Note that such a frame is not
     allowed to have its own minibuffer window.

'snap-width'
     A frame that is moved with the mouse will "snap" at the border(s)
     of the display or its parent frame whenever it is dragged as near
     to such an edge as the number of pixels specified by this
     parameter.

'top-visible'
     If this parameter is a number, the top edge of the frame never
     appears above the top edge of its display or parent frame.
     Moreover, as many pixels of the frame as specified by that number
     will remain visible when the frame is moved against any of the
     remaining edges of its display or parent frame.  Setting this
     parameter is useful to guard against dragging a child frame with a
     non-'nil' 'drag-with-header-line' parameter completely out of the
     area of its parent frame.

'bottom-visible'
     If this parameter is a number, the bottom edge of the frame never
     appears below the bottom edge of its display or parent frame.
     Moreover, as many pixels of the frame as specified by that number
     will remain visible when the frame is moved against any of the
     remaining edges of its display or parent frame.  Setting this
     parameter is useful to guard against dragging a child frame with a
     non-'nil' 'drag-with-mode-line' parameter completely out of the
     area of its parent frame.

==============================================================================
File: elisp.info,  Node: |Management_Parameters|,  Next: |Cursor_Parameters|,  Prev: |Mouse_Dragging_Parameters|,  Up: |Window_Frame_Parameters|
==============================================================================

                                                         *Management_Parameters*

29.4.3.8 Window Management Parameters
-------------------------------------

The following frame parameters control various aspects of the frame's
interaction with the window manager or window system.  They have no
effect on text terminals.

'visibility'
     The state of visibility of the frame.  There are three
     possibilities: 'nil' for invisible, 't' for visible, and 'icon' for
     iconified.  *Note Visibility of Frames::.

'auto-raise'
     If non-'nil', Emacs automatically raises the frame when it is
     selected.  Some window managers do not allow this.

'auto-lower'
     If non-'nil', Emacs automatically lowers the frame when it is
     deselected.  Some window managers do not allow this.

'icon-type'
     The type of icon to use for this frame.  If the value is a string,
     that specifies a file containing a bitmap to use; 'nil' specifies
     no icon (in which case the window manager decides what to show);
     any other non-'nil' value specifies the default Emacs icon.

'icon-name'
     The name to use in the icon for this frame, when and if the icon
     appears.  If this is 'nil', the frame's title is used.

'window-id'
     The ID number which the graphical display uses for this frame.
     Emacs assigns this parameter when the frame is created; changing
     the parameter has no effect on the actual ID number.

'outer-window-id'
     The ID number of the outermost window-system window in which the
     frame exists.  As with 'window-id', changing this parameter has no
     actual effect.

'wait-for-wm'
     If non-'nil', tell Xt to wait for the window manager to confirm
     geometry changes.  Some window managers, including versions of
     Fvwm2 and KDE, fail to confirm, so Xt hangs.  Set this to 'nil' to
     prevent hanging with those window managers.

'sticky'
     If non-'nil', the frame is visible on all virtual desktops on
     systems with virtual desktops.

'inhibit-double-buffering'
     If non-'nil', the frame is drawn to the screen without double
     buffering.  Emacs normally attempts to use double buffering, where
     available, to reduce flicker.  Set this property if you experience
     display bugs or pine for that retro, flicker-y feeling.

'skip-taskbar'
     If non-'nil', this tells the window manager to remove the frame's
     icon from the taskbar associated with the frame's display and
     inhibit switching to the frame's window via the combination
     'Alt-<TAB>'.  On MS-Windows, iconifying such a frame will "roll in"
     its window-system window at the bottom of the desktop.  Some window
     managers may not honor this parameter.

'no-focus-on-map'
     If non-'nil', this means that the frame does not want to receive
     input focus when it is mapped (*note Visibility of Frames::).  Some
     window managers may not honor this parameter.

'no-accept-focus'
     If non-'nil', this means that the frame does not want to receive
     input focus via explicit mouse clicks or when moving the mouse into
     it either via 'focus-follows-mouse' (*note Input Focus::) or
     'mouse-autoselect-window' (*note Mouse Window Auto-selection::).
     This may have the unwanted side-effect that a user cannot scroll a
     non-selected frame with the mouse.  Some window managers may not
     honor this parameter.

'undecorated'
     If non-'nil', this frame's window-system window is drawn without
     decorations, like the title, minimize/maximize boxes and external
     borders.  This usually means that the window cannot be dragged,
     resized, iconified, maximized or deleted with the mouse.  If 'nil',
     the frame's window is usually drawn with all the elements listed
     above unless their display has been suspended via window manager
     settings.

     Under X, Emacs uses the Motif window manager hints to turn off
     decorations.  Some window managers may not honor these hints.

     NS builds consider the tool bar to be a decoration, and therefore
     hide it on an undecorated frame.

'override-redirect'
     If non-'nil', this means that this is an "override redirect"
     frame--a frame not handled by window managers under X.  Override
     redirect frames have no window manager decorations, can be
     positioned and resized only via Emacs' positioning and resizing
     functions and are usually drawn on top of all other frames.
     Setting this parameter has no effect on MS-Windows.

'ns-appearance'
     Only available on macOS, if set to 'dark' draw this frame's
     window-system window using the "vibrant dark" theme, otherwise use
     the system default.  The "vibrant dark" theme can be used to set
     the toolbar and scrollbars to a dark appearance when using an Emacs
     theme with a dark background.

'ns-transparent-titlebar'
     Only available on macOS, if non-'nil', set the titlebar and toolbar
     to be transparent.  This effectively sets the background color of
     both to match the Emacs background color.

==============================================================================
File: elisp.info,  Node: |Cursor_Parameters|,  Next: |Font_and_Color_Parameters|,  Prev: |Management_Parameters|,  Up: |Window_Frame_Parameters|
==============================================================================

                                                             *Cursor_Parameters*

29.4.3.9 Cursor Parameters
--------------------------

This frame parameter controls the way the cursor looks.

'cursor-type'
     How to display the cursor.  Legitimate values are:

     'box'
          Display a filled box.  (This is the default.)
     'hollow'
          Display a hollow box.
     'nil'
          Don't display a cursor.
     'bar'
          Display a vertical bar between characters.
     '(bar . WIDTH)'
          Display a vertical bar WIDTH pixels wide between characters.
     'hbar'
          Display a horizontal bar.
     '(hbar . HEIGHT)'
          Display a horizontal bar HEIGHT pixels high.

   The 'cursor-type' frame parameter may be overridden by the variables
'cursor-type' and 'cursor-in-non-selected-windows':

 -- User Option: cursor-type
     This buffer-local variable controls how the cursor looks in a
     selected window showing the buffer.  If its value is 't', that
     means to use the cursor specified by the 'cursor-type' frame
     parameter.  Otherwise, the value should be one of the cursor types
     listed above, and it overrides the 'cursor-type' frame parameter.

 -- User Option: cursor-in-non-selected-windows
     This buffer-local variable controls how the cursor looks in a
     window that is not selected.  It supports the same values as the
     'cursor-type' frame parameter; also, 'nil' means don't display a
     cursor in nonselected windows, and 't' (the default) means use a
     standard modification of the usual cursor type (solid box becomes
     hollow box, and bar becomes a narrower bar).

 -- User Option: x-stretch-cursor
     This variable controls the width of the block cursor displayed on
     extra-wide glyphs such as a tab or a stretch of white space.  By
     default, the block cursor is only as wide as the font's default
     character, and will not cover all of the width of the glyph under
     it if that glyph is extra-wide.  A non-'nil' value of this variable
     means draw the block cursor as wide as the glyph under it.  The
     default value is 'nil'.

     This variable has no effect on text-mode frames, since the
     text-mode cursor is drawn by the terminal out of Emacs's control.

 -- User Option: blink-cursor-alist
     This variable specifies how to blink the cursor.  Each element has
     the form '(ON-STATE . OFF-STATE)'.  Whenever the cursor type equals
     ON-STATE (comparing using 'equal'), the corresponding OFF-STATE
     specifies what the cursor looks like when it blinks off.  Both
     ON-STATE and OFF-STATE should be suitable values for the
     'cursor-type' frame parameter.

     There are various defaults for how to blink each type of cursor, if
     the type is not mentioned as an ON-STATE here.  Changes in this
     variable do not take effect immediately, only when you specify the
     'cursor-type' frame parameter.

==============================================================================
File: elisp.info,  Node: |Font_and_Color_Parameters|,  Prev: |Cursor_Parameters|,  Up: |Window_Frame_Parameters|
==============================================================================

                                                     *Font_and_Color_Parameters*

29.4.3.10 Font and Color Parameters
-----------------------------------

These frame parameters control the use of fonts and colors.

'font-backend'
     A list of symbols, specifying the "font backends" to use for
     drawing characters on the frame, in order of priority.  In Emacs
     built without Cairo drawing on X, there are currently three
     potentially available font backends: 'x' (the X core font driver),
     'xft' (the Xft font driver), and 'xfthb' (the Xft font driver with
     HarfBuzz text shaping).  If built with Cairo drawing, there are
     also three potentially available font backends on X: 'x', 'ftcr'
     (the FreeType font driver on Cairo), and 'ftcrhb' (the FreeType
     font driver on Cairo with HarfBuzz text shaping).  When Emacs is
     built with HarfBuzz, the default font driver is 'ftcrhb', although
     use of the 'ftcr' driver is still possible, but not recommended.
     On MS-Windows, there are currently three available font backends:
     'gdi' (the core MS-Windows font driver), 'uniscribe' (font driver
     for OTF and TTF fonts with text shaping by the Uniscribe engine),
     and 'harfbuzz' (font driver for OTF and TTF fonts with HarfBuzz
     text shaping) (*note (emacs)Windows Fonts::).  The 'harfbuzz'
     driver is similarly recommended.  On other systems, there is only
     one available font backend, so it does not make sense to modify
     this frame parameter.

'background-mode'
     This parameter is either 'dark' or 'light', according to whether
     the background color is a light one or a dark one.

'tty-color-mode'
     This parameter overrides the terminal's color support as given by
     the system's terminal capabilities database in that this
     parameter's value specifies the color mode to use on a text
     terminal.  The value can be either a symbol or a number.  A number
     specifies the number of colors to use (and, indirectly, what
     commands to issue to produce each color).  For example,
     '(tty-color-mode . 8)' specifies use of the ANSI escape sequences
     for 8 standard text colors.  A value of -1 turns off color support.

     If the parameter's value is a symbol, it specifies a number through
     the value of 'tty-color-mode-alist', and the associated number is
     used instead.

'screen-gamma'
     If this is a number, Emacs performs gamma correction which adjusts
     the brightness of all colors.  The value should be the screen gamma
     of your display.

     Usual PC monitors have a screen gamma of 2.2, so color values in
     Emacs, and in X windows generally, are calibrated to display
     properly on a monitor with that gamma value.  If you specify 2.2
     for 'screen-gamma', that means no correction is needed.  Other
     values request correction, designed to make the corrected colors
     appear on your screen the way they would have appeared without
     correction on an ordinary monitor with a gamma value of 2.2.

     If your monitor displays colors too light, you should specify a
     'screen-gamma' value smaller than 2.2.  This requests correction
     that makes colors darker.  A screen gamma value of 1.5 may give
     good results for LCD color displays.

'alpha'
     This parameter specifies the opacity of the frame, on graphical
     displays that support variable opacity.  It should be an integer
     between 0 and 100, where 0 means completely transparent and 100
     means completely opaque.  It can also have a 'nil' value, which
     tells Emacs not to set the frame opacity (leaving it to the window
     manager).

     To prevent the frame from disappearing completely from view, the
     variable 'frame-alpha-lower-limit' defines a lower opacity limit.
     If the value of the frame parameter is less than the value of this
     variable, Emacs uses the latter.  By default,
     'frame-alpha-lower-limit' is 20.

     The 'alpha' frame parameter can also be a cons cell '(ACTIVE .
     INACTIVE)', where ACTIVE is the opacity of the frame when it is
     selected, and INACTIVE is the opacity when it is not selected.

     Some window systems do not support the 'alpha' parameter for child
     frames (*note Child Frames::).

   The following frame parameters are semi-obsolete in that they are
automatically equivalent to particular face attributes of particular
faces (*note (emacs)Standard Faces::):

'font'
     The name of the font for displaying text in the frame.  This is a
     string, either a valid font name for your system or the name of an
     Emacs fontset (*note Fontsets::).  It is equivalent to the 'font'
     attribute of the 'default' face.

'foreground-color'
     The color to use for the image of a character.  It is equivalent to
     the ':foreground' attribute of the 'default' face.

'background-color'
     The color to use for the background of characters.  It is
     equivalent to the ':background' attribute of the 'default' face.

'mouse-color'
     The color for the mouse pointer.  It is equivalent to the
     ':background' attribute of the 'mouse' face.

'cursor-color'
     The color for the cursor that shows point.  It is equivalent to the
     ':background' attribute of the 'cursor' face.

'border-color'
     The color for the border of the frame.  It is equivalent to the
     ':background' attribute of the 'border' face.

'scroll-bar-foreground'
     If non-'nil', the color for the foreground of scroll bars.  It is
     equivalent to the ':foreground' attribute of the 'scroll-bar' face.

'scroll-bar-background'
     If non-'nil', the color for the background of scroll bars.  It is
     equivalent to the ':background' attribute of the 'scroll-bar' face.

==============================================================================
File: elisp.info,  Node: |Geometry|,  Prev: Window Frame Parameters,  Up: |Frame_Parameters|
==============================================================================

                                                                      *Geometry*

29.4.4 Geometry
---------------

Here's how to examine the data in an X-style window geometry
specification:

 -- Function: x-parse-geometry geom
     The function 'x-parse-geometry' converts a standard X window
     geometry string to an alist that you can use as part of the
     argument to 'make-frame'.

     The alist describes which parameters were specified in GEOM, and
     gives the values specified for them.  Each element looks like
     '(PARAMETER . VALUE)'.  The possible PARAMETER values are 'left',
     'top', 'width', and 'height'.

     For the size parameters, the value must be an integer.  The
     position parameter names 'left' and 'top' are not totally accurate,
     because some values indicate the position of the right or bottom
     edges instead.  The VALUE possibilities for the position parameters
     are: an integer, a list '(+ POS)', or a list '(- POS)'; as
     previously described (*note Position Parameters::).

     Here is an example:

          (x-parse-geometry "35x70+0-0")
               => ((height . 70) (width . 35)
                   (top - 0) (left . 0))

==============================================================================
File: elisp.info,  Node: |Terminal_Parameters|,  Next: |Frame_Titles|,  Prev: |Frame_Parameters|,  Up: |Frames|
==============================================================================

                                                           *Terminal_Parameters*

29.5 Terminal Parameters
------------------------

Each terminal has a list of associated parameters.  These "terminal
parameters" are mostly a convenient way of storage for terminal-local
variables, but some terminal parameters have a special meaning.

   This section describes functions to read and change the parameter
values of a terminal.  They all accept as their argument either a
terminal or a frame; the latter means use that frame's terminal.  An
argument of 'nil' means the selected frame's terminal.

 -- Function: terminal-parameters &optional terminal
     This function returns an alist listing all the parameters of
     TERMINAL and their values.

 -- Function: terminal-parameter terminal parameter
     This function returns the value of the parameter PARAMETER (a
     symbol) of TERMINAL.  If TERMINAL has no setting for PARAMETER,
     this function returns 'nil'.

 -- Function: set-terminal-parameter terminal parameter value
     This function sets the parameter PARAMETER of TERMINAL to the
     specified VALUE, and returns the previous value of that parameter.

   Here's a list of a few terminal parameters that have a special
meaning:

'background-mode'
     The classification of the terminal's background color, either
     'light' or 'dark'.
'normal-erase-is-backspace'
     Value is either 1 or 0, depending on whether
     'normal-erase-is-backspace-mode' is turned on or off on this
     terminal.  *Note (emacs)DEL Does Not Delete::.
'terminal-initted'
     After the terminal is initialized, this is set to the
     terminal-specific initialization function.
'tty-mode-set-strings'
     When present, a list of strings containing escape sequences that
     Emacs will output while configuring a tty for rendering.  Emacs
     emits these strings only when configuring a terminal: if you want
     to enable a mode on a terminal that is already active (for example,
     while in 'tty-setup-hook'), explicitly output the necessary escape
     sequence using 'send-string-to-terminal' in addition to adding the
     sequence to 'tty-mode-set-strings'.
'tty-mode-reset-strings'
     When present, a list of strings that undo the effects of the
     strings in 'tty-mode-set-strings'.  Emacs emits these strings when
     exiting, deleting a terminal, or suspending itself.

==============================================================================
File: elisp.info,  Node: |Frame_Titles|,  Next: |Deleting_Frames|,  Prev: |Terminal_Parameters|,  Up: |Frames|
==============================================================================

                                                                  *Frame_Titles*

29.6 Frame Titles
-----------------

Every frame has a 'name' parameter; this serves as the default for the
frame title which window systems typically display at the top of the
frame.  You can specify a name explicitly by setting the 'name' frame
property.

   Normally you don't specify the name explicitly, and Emacs computes
the frame name automatically based on a template stored in the variable
'frame-title-format'.  Emacs recomputes the name each time the frame is
redisplayed.

 -- Variable: frame-title-format
     This variable specifies how to compute a name for a frame when you
     have not explicitly specified one.  The variable's value is
     actually a mode line construct, just like 'mode-line-format',
     except that the '%c', '%C', and '%l' constructs are ignored.  *Note
     Mode Line Data::.

 -- Variable: icon-title-format
     This variable specifies how to compute the name for an iconified
     frame, when you have not explicitly specified the frame title.
     This title appears in the icon itself.

 -- Variable: multiple-frames
     This variable is set automatically by Emacs.  Its value is 't' when
     there are two or more frames (not counting minibuffer-only frames
     or invisible frames).  The default value of 'frame-title-format'
     uses 'multiple-frames' so as to put the buffer name in the frame
     title only when there is more than one frame.

     The value of this variable is not guaranteed to be accurate except
     while processing 'frame-title-format' or 'icon-title-format'.

==============================================================================
File: elisp.info,  Node: |Deleting_Frames|,  Next: |Finding_All_Frames|,  Prev: |Frame_Titles|,  Up: |Frames|
==============================================================================

                                                               *Deleting_Frames*

29.7 Deleting Frames
--------------------

A "live frame" is one that has not been deleted.  When a frame is
deleted, it is removed from its terminal display, although it may
continue to exist as a Lisp object until there are no more references to
it.

 -- Command: delete-frame &optional frame force
     This function deletes the frame FRAME.  The argument FRAME must
     specify a live frame (see below) and defaults to the selected
     frame.

     It first deletes any child frame of FRAME (*note Child Frames::)
     and any frame whose 'delete-before' frame parameter (*note Frame
     Interaction Parameters::) specifies FRAME.  All such deletions are
     performed recursively; so this step makes sure that no other frames
     with FRAME as their ancestor will exist.  Then, unless FRAME
     specifies a tooltip, this function runs the hook
     'delete-frame-functions' (each function getting one argument,
     FRAME) before actually killing the frame.  After actually killing
     the frame and removing the frame from the frame list,
     'delete-frame' runs 'after-delete-frame-functions'.

     Note that a frame cannot be deleted as long as its minibuffer
     serves as surrogate minibuffer for another frame (*note Minibuffers
     and Frames::).  Normally, you cannot delete a frame if all other
     frames are invisible, but if FORCE is non-'nil', then you are
     allowed to do so.

 -- Function: frame-live-p frame
     This function returns non-'nil' if the frame FRAME has not been
     deleted.  The possible non-'nil' return values are like those of
     'framep'.  *Note Frames::.

   Some window managers provide a command to delete a window.  These
work by sending a special message to the program that operates the
window.  When Emacs gets one of these commands, it generates a
'delete-frame' event, whose normal definition is a command that calls
the function 'delete-frame'.  *Note Misc Events::.

 -- Command: delete-other-frames &optional frame
     This command deletes all frames on FRAME's terminal, except FRAME.
     If FRAME uses another frame's minibuffer, that minibuffer frame is
     left untouched.  The argument FRAME must specify a live frame and
     defaults to the selected frame.  Internally, this command works by
     calling 'delete-frame' with FORCE 'nil' for all frames that shall
     be deleted.

     This function does not delete any of FRAME's child frames (*note
     Child Frames::).  If FRAME is a child frame, it deletes FRAME's
     siblings only.

==============================================================================
File: elisp.info,  Node: |Finding_All_Frames|,  Next: |Minibuffers_and_Frames|,  Prev: |Deleting_Frames|,  Up: |Frames|
==============================================================================

                                                            *Finding_All_Frames*

29.8 Finding All Frames
-----------------------

 -- Function: frame-list
     This function returns a list of all the live frames, i.e., those
     that have not been deleted.  It is analogous to 'buffer-list' for
     buffers, and includes frames on all terminals.  The list that you
     get is newly created, so modifying the list doesn't have any effect
     on the internals of Emacs.

 -- Function: visible-frame-list
     This function returns a list of just the currently visible frames.
     *Note Visibility of Frames::.  Frames on text terminals always
     count as visible, even though only the selected one is actually
     displayed.

 -- Function: frame-list-z-order &optional display
     This function returns a list of Emacs' frames, in Z (stacking)
     order (*note Raising and Lowering::).  The optional argument
     DISPLAY specifies which display to poll.  DISPLAY should be either
     a frame or a display name (a string).  If omitted or 'nil', that
     stands for the selected frame's display.  It returns 'nil' if
     DISPLAY contains no Emacs frame.

     Frames are listed from topmost (first) to bottommost (last).  As a
     special case, if DISPLAY is non-'nil' and specifies a live frame,
     it returns the child frames of that frame in Z (stacking) order.

     This function is not meaningful on text terminals.

 -- Function: next-frame &optional frame minibuf
     This function lets you cycle conveniently through all the frames on
     a specific terminal from an arbitrary starting point.  It returns
     the frame following FRAME, in the list of all live frames, on
     FRAME's terminal.  The argument FRAME must specify a live frame and
     defaults to the selected frame.  It never returns a frame whose
     'no-other-frame' parameter (*note Frame Interaction Parameters::)
     is non-'nil'.

     The second argument, MINIBUF, says which frames to consider:

     'nil'
          Exclude minibuffer-only frames.
     'visible'
          Consider all visible frames.
     0
          Consider all visible or iconified frames.
     a window
          Consider only the frames using that particular window as their
          minibuffer.
     anything else
          Consider all frames.

 -- Function: previous-frame &optional frame minibuf
     Like 'next-frame', but cycles through all frames in the opposite
     direction.

   See also 'next-window' and 'previous-window', in *note Cyclic Window
Ordering::.

==============================================================================
File: elisp.info,  Node: |Minibuffers_and_Frames|,  Next: |Input_Focus|,  Prev: |Finding_All_Frames|,  Up: |Frames|
==============================================================================

                                                        *Minibuffers_and_Frames*

29.9 Minibuffers and Frames
---------------------------

Normally, each frame has its own minibuffer window at the bottom, which
is used whenever that frame is selected.  You can get that window with
the function 'minibuffer-window' (*note Minibuffer Windows::).

   However, you can also create a frame without a minibuffer.  Such a
frame must use the minibuffer window of some other frame.  That other
frame will serve as "surrogate minibuffer frame" for this frame and
cannot be deleted via 'delete-frame' (*note Deleting Frames::) as long
as this frame is live.

   When you create the frame, you can explicitly specify its minibuffer
window (in some other frame) with the 'minibuffer' frame parameter
(*note Buffer Parameters::).  If you don't, then the minibuffer is found
in the frame which is the value of the variable
'default-minibuffer-frame'.  Its value should be a frame that does have
a minibuffer.

   If you use a minibuffer-only frame, you might want that frame to
raise when you enter the minibuffer.  If so, set the variable
'minibuffer-auto-raise' to 't'.  *Note Raising and Lowering::.

 -- Variable: default-minibuffer-frame
     This variable specifies the frame to use for the minibuffer window,
     by default.  It does not affect existing frames.  It is always
     local to the current terminal and cannot be buffer-local.  *Note
     Multiple Terminals::.

==============================================================================
File: elisp.info,  Node: |Input_Focus|,  Next: |Visibility_of_Frames|,  Prev: |Minibuffers_and_Frames|,  Up: |Frames|
==============================================================================

                                                                   *Input_Focus*

29.10 Input Focus
-----------------

At any time, one frame in Emacs is the "selected frame".  The selected
window always resides on the selected frame.

   When Emacs displays its frames on several terminals (*note Multiple
Terminals::), each terminal has its own selected frame.  But only one of
these is _the_ selected frame: it's the frame that belongs to the
terminal from which the most recent input came.  That is, when Emacs
runs a command that came from a certain terminal, the selected frame is
the one of that terminal.  Since Emacs runs only a single command at any
given time, it needs to consider only one selected frame at a time; this
frame is what we call "the selected frame" in this manual.  The display
on which the selected frame is shown is the "selected frame's display".

 -- Function: selected-frame
     This function returns the selected frame.

   Some window systems and window managers direct keyboard input to the
window object that the mouse is in; others require explicit clicks or
commands to "shift the focus" to various window objects.  Either way,
Emacs automatically keeps track of which frames have focus.  To
explicitly switch to a different frame from a Lisp function, call
'select-frame-set-input-focus'.

   The plural "frames" in the previous paragraph is deliberate: while
Emacs itself has only one selected frame, Emacs can have frames on many
different terminals (recall that a connection to a window system counts
as a terminal), and each terminal has its own idea of which frame has
input focus.  When you set the input focus to a frame, you set the focus
for that frame's terminal, but frames on other terminals may still
remain focused.

   Lisp programs can switch frames temporarily by calling the function
'select-frame'.  This does not alter the window system's concept of
focus; rather, it escapes from the window manager's control until that
control is somehow reasserted.

   When using a text terminal, only one frame can be displayed at a time
on the terminal, so after a call to 'select-frame', the next redisplay
actually displays the newly selected frame.  This frame remains selected
until a subsequent call to 'select-frame'.  Each frame on a text
terminal has a number which appears in the mode line before the buffer
name (*note Mode Line Variables::).

 -- Function: select-frame-set-input-focus frame &optional norecord
     This function selects FRAME, raises it (should it happen to be
     obscured by other frames) and tries to give it the window system's
     focus.  On a text terminal, the next redisplay displays the new
     frame on the entire terminal screen.  The optional argument
     NORECORD has the same meaning as for 'select-frame' (see below).
     The return value of this function is not significant.

   Ideally, the function described next should focus a frame without
also raising it above other frames.  Unfortunately, many window-systems
or window managers may refuse to comply.

 -- Function: x-focus-frame frame &optional noactivate
     This function gives FRAME the focus of the X server without
     necessarily raising it.  FRAME 'nil' means use the selected frame.
     Under X, the optional argument NOACTIVATE, if non-'nil', means to
     avoid making FRAME's window-system window the "active" window which
     should insist a bit more on avoiding to raise FRAME above other
     frames.

     On MS-Windows the NOACTIVATE argument has no effect.  However, if
     FRAME is a child frame (*note Child Frames::), this function
     usually focuses FRAME without raising it above other child frames.

     If there is no window system support, this function does nothing.

 -- Command: select-frame frame &optional norecord
     This function selects frame FRAME, temporarily disregarding the
     focus of the X server if any.  The selection of FRAME lasts until
     the next time the user does something to select a different frame,
     or until the next time this function is called.  (If you are using
     a window system, the previously selected frame may be restored as
     the selected frame after return to the command loop, because it
     still may have the window system's input focus.)

     The specified FRAME becomes the selected frame, and its terminal
     becomes the selected terminal.  This function then calls
     'select-window' as a subroutine, passing the window selected within
     FRAME as its first argument and NORECORD as its second argument
     (hence, if NORECORD is non-'nil', this avoids changing the order of
     recently selected windows and the buffer list).  *Note Selecting
     Windows::.

     This function returns FRAME, or 'nil' if FRAME has been deleted.

     In general, you should never use 'select-frame' in a way that could
     switch to a different terminal without switching back when you're
     done.

   Emacs cooperates with the window system by arranging to select frames
as the server and window manager request.  When a window system informs
Emacs that one of its frames has been selected, Emacs internally
generates a "focus-in" event.  When an Emacs frame is displayed on a
text-terminal emulator, such as 'xterm', which supports reporting of
focus-change notification, the focus-in and focus-out events are
available even for text-mode frames.  Focus events are normally handled
by 'handle-focus-in'.

 -- Command: handle-focus-in event
     This function handles focus-in events from window systems and
     terminals that support explicit focus notifications.  It updates
     the per-frame focus flags that 'frame-focus-state' queries and
     calls 'after-focus-change-function'.  In addition, it generates a
     'switch-frame' event in order to switch the Emacs notion of the
     selected frame to the frame most recently focused in some terminal.
     It's important to note that this switching of the Emacs selected
     frame to the most recently focused frame does not mean that other
     frames do not continue to have the focus in their respective
     terminals.  Do not invoke this function yourself: instead, attach
     logic to 'after-focus-change-function'.

 -- Command: handle-switch-frame frame
     This function handles a switch-frame event, which Emacs generates
     for itself upon focus notification or under various other
     circumstances involving an input event arriving at a different
     frame from the last event.  Do not invoke this function yourself.

 -- Function: redirect-frame-focus frame &optional focus-frame
     This function redirects focus from FRAME to FOCUS-FRAME.  This
     means that FOCUS-FRAME will receive subsequent keystrokes and
     events intended for FRAME.  After such an event, the value of
     'last-event-frame' will be FOCUS-FRAME.  Also, switch-frame events
     specifying FRAME will instead select FOCUS-FRAME.

     If FOCUS-FRAME is omitted or 'nil', that cancels any existing
     redirection for FRAME, which therefore once again receives its own
     events.

     One use of focus redirection is for frames that don't have
     minibuffers.  These frames use minibuffers on other frames.
     Activating a minibuffer on another frame redirects focus to that
     frame.  This puts the focus on the minibuffer's frame, where it
     belongs, even though the mouse remains in the frame that activated
     the minibuffer.

     Selecting a frame can also change focus redirections.  Selecting
     frame 'bar', when 'foo' had been selected, changes any redirections
     pointing to 'foo' so that they point to 'bar' instead.  This allows
     focus redirection to work properly when the user switches from one
     frame to another using 'select-window'.

     This means that a frame whose focus is redirected to itself is
     treated differently from a frame whose focus is not redirected.
     'select-frame' affects the former but not the latter.

     The redirection lasts until 'redirect-frame-focus' is called to
     change it.

 -- Function: frame-focus-state frame
     This function retrieves the last known focus state of FRAME.

     It returns 'nil' if the frame is known not to be focused, 't' if
     the frame is known to be focused, or 'unknown' if Emacs does not
     know the focus state of the frame.  (You may see this last state in
     TTY frames running on terminals that do not support explicit focus
     notifications.)

 -- Variable: after-focus-change-function
     This function is an extension point that code can use to receive a
     notification that focus has changed.

     This function is called with no arguments when Emacs notices that
     the set of focused frames may have changed.  Code wanting to do
     something when frame focus changes should use 'add-function' to add
     a function to this one, and in this added function, re-scan the set
     of focused frames, calling 'frame-focus-state' to retrieve the last
     known focus state of each frame.  Focus events are delivered
     asynchronously, and frame input focus according to an external
     system may not correspond to the notion of the Emacs selected
     frame.  Multiple frames may appear to have input focus
     simultaneously due to focus event delivery differences, the
     presence of multiple Emacs terminals, and other factors, and code
     should be robust in the face of this situation.

     Depending on window system, focus events may also be delivered
     repeatedly and with different focus states before settling to the
     expected values.  Code relying on focus notifications should
     "debounce" any user-visible updates arising from focus changes,
     perhaps by deferring work until redisplay.

     This function may be called in arbitrary contexts, including from
     inside 'read-event', so take the same care as you might when
     writing a process filter.

 -- User Option: focus-follows-mouse
     This option informs Emacs whether and how the window manager
     transfers focus when you move the mouse pointer into a frame.  It
     can have three meaningful values:

     'nil'
          The default value 'nil' should be used when your window
          manager follows a "click-to-focus" policy where you have to
          click the mouse inside of a frame in order for that frame to
          gain focus.

     't'
          The value 't' should be used when your window manager has the
          focus automatically follow the position of the mouse pointer
          but a frame that gains focus is not raised automatically and
          may even remain occluded by other window-system windows.

     'auto-raise'
          The value 'auto-raise' should be used when your window manager
          has the focus automatically follow the position of the mouse
          pointer and a frame that gains focus is raised automatically.

     If this option is non-'nil', Emacs moves the mouse pointer to the
     frame selected by 'select-frame-set-input-focus'.  That function is
     used by a number of commands like, for example, 'other-frame' and
     'pop-to-buffer'.

     The distinction between the values 't' and 'auto-raise' is not
     needed for "normal" frames because the window manager usually takes
     care of raising them.  It is useful to automatically raise child
     frames via 'mouse-autoselect-window' (*note Mouse Window
     Auto-selection::).

     Note that this option does not distinguish "sloppy" focus (where
     the frame that previously had focus retains focus as long as the
     mouse pointer does not move into another window manager window)
     from "strict" focus (where a frame immediately loses focus when
     it's left by the mouse pointer).  Neither does it recognize whether
     your window manager supports delayed focusing or auto-raising where
     you can explicitly specify the time until a new frame gets focus or
     is auto-raised.

     You can supply a "focus follows mouse" policy for individual Emacs
     windows by customizing the variable 'mouse-autoselect-window'
     (*note Mouse Window Auto-selection::).

==============================================================================
File: elisp.info,  Node: |Visibility_of_Frames|,  Next: |Raising_and_Lowering|,  Prev: |Input_Focus|,  Up: |Frames|
==============================================================================

                                                          *Visibility_of_Frames*

29.11 Visibility of Frames
--------------------------

A frame on a graphical display may be "visible", "invisible", or
"iconified".  If it is visible, its contents are displayed in the usual
manner.  If it is iconified, its contents are not displayed, but there
is a little icon somewhere to bring the frame back into view (some
window managers refer to this state as "minimized" rather than
"iconified", but from Emacs' point of view they are the same thing).  If
a frame is invisible, it is not displayed at all.

   The concept of visibility is strongly related to that of (un-)mapped
frames.  A frame (or, more precisely, its window-system window) is and
becomes "mapped" when it is displayed for the first time and whenever it
changes its state of visibility from 'iconified' or 'invisible' to
'visible'.  Conversely, a frame is and becomes "unmapped" whenever it
changes its status from 'visible' to 'iconified' or 'invisible'.

   Visibility is meaningless on text terminals, since only the selected
frame is actually displayed in any case.

 -- Function: frame-visible-p frame
     This function returns the visibility status of frame FRAME.  The
     value is 't' if FRAME is visible, 'nil' if it is invisible, and
     'icon' if it is iconified.

     On a text terminal, all frames are considered visible for the
     purposes of this function, even though only one frame is displayed.
     *Note Raising and Lowering::.

 -- Command: iconify-frame &optional frame
     This function iconifies frame FRAME.  If you omit FRAME, it
     iconifies the selected frame.  This usually makes all child frames
     of FRAME (and their descendants) invisible (*note Child Frames::).

 -- Command: make-frame-visible &optional frame
     This function makes frame FRAME visible.  If you omit FRAME, it
     makes the selected frame visible.  This does not raise the frame,
     but you can do that with 'raise-frame' if you wish (*note Raising
     and Lowering::).

     Making a frame visible usually makes all its child frames (and
     their descendants) visible as well (*note Child Frames::).

 -- Command: make-frame-invisible &optional frame force
     This function makes frame FRAME invisible.  If you omit FRAME, it
     makes the selected frame invisible.  Usually, this makes all child
     frames of FRAME (and their descendants) invisible too (*note Child
     Frames::).

     Unless FORCE is non-'nil', this function refuses to make FRAME
     invisible if all other frames are invisible.

   The visibility status of a frame is also available as a frame
parameter.  You can read or change it as such.  *Note Management
Parameters::.  The user can also iconify and deiconify frames with the
window manager.  This happens below the level at which Emacs can exert
any control, but Emacs does provide events that you can use to keep
track of such changes.  *Note Misc Events::.

 -- Function: x-double-buffered-p &optional frame
     This function returns non-'nil' if FRAME is currently being
     rendered with double buffering.  FRAME defaults to the selected
     frame.

==============================================================================
File: elisp.info,  Node: |Raising_and_Lowering|,  Next: |Frame_Configurations|,  Prev: |Visibility_of_Frames|,  Up: |Frames|
==============================================================================

                                                          *Raising_and_Lowering*

29.12 Raising, Lowering and Restacking Frames
---------------------------------------------

Most window systems use a desktop metaphor.  Part of this metaphor is
the idea that system-level windows (representing, e.g., Emacs frames)
are stacked in a notional third dimension perpendicular to the screen
surface.  The order induced by stacking is total and usually referred to
as stacking (or Z-) order.  Where the areas of two windows overlap, the
one higher up in that order will (partially) cover the one underneath.

   You can "raise" a frame to the top of that order or "lower" a frame
to its bottom by using the functions 'raise-frame' and 'lower-frame'.
You can "restack" a frame directly above or below another frame using
the function 'frame-restack'.

   Note that all functions described below will respect the adherence of
frames (and all other window-system windows) to their respective z-group
(*note Position Parameters::).  For example, you usually cannot lower a
frame below that of the desktop window and you cannot raise a frame
whose 'z-group' parameter is 'nil' above the window-system's taskbar or
tooltip window.

 -- Command: raise-frame &optional frame
     This function raises frame FRAME (default, the selected frame)
     above all other frames belonging to the same or a lower z-group as
     FRAME.  If FRAME is invisible or iconified, this makes it visible.
     If FRAME is a child frame (*note Child Frames::), this raises FRAME
     above all other child frames of its parent.

 -- Command: lower-frame &optional frame
     This function lowers frame FRAME (default, the selected frame)
     below all other frames belonging to the same or a higher z-group as
     FRAME.  If FRAME is a child frame (*note Child Frames::), this
     lowers FRAME below all other child frames of its parent.

 -- Function: frame-restack frame1 frame2 &optional above
     This function restacks FRAME1 below FRAME2.  This implies that if
     both frames are visible and their display areas overlap, FRAME2
     will (partially) obscure FRAME1.  If the optional third argument
     ABOVE is non-'nil', this function restacks FRAME1 above FRAME2.
     This means that if both frames are visible and their display areas
     overlap, FRAME1 will (partially) obscure FRAME2.

     Technically, this function may be thought of as an atomic action
     performed in two steps: The first step removes FRAME1's
     window-system window from the display.  The second step reinserts
     FRAME1's window into the display below (above if ABOVE is true)
     that of FRAME2.  Hence the position of FRAME2 in its display's Z
     (stacking) order relative to all other frames excluding FRAME1
     remains unaltered.

     Some window managers may refuse to restack windows.

   Note that the effect of restacking will only hold as long as neither
of the involved frames is iconified or made invisible.  You can use the
'z-group' (*note Position Parameters::) frame parameter to add a frame
to a group of frames permanently shown above or below other frames.  As
long as a frame belongs to one of these groups, restacking it will only
affect its relative stacking position within that group.  The effect of
restacking frames belonging to different z-groups is undefined.  You can
list frames in their current stacking order with the function
'frame-list-z-order' (*note Finding All Frames::).

 -- User Option: minibuffer-auto-raise
     If this is non-'nil', activation of the minibuffer raises the frame
     that the minibuffer window is in.

   On window systems, you can also enable auto-raising (on frame
selection) or auto-lowering (on frame deselection) using frame
parameters.  *Note Management Parameters::.

   The concept of raising and lowering frames also applies to text
terminal frames.  On each text terminal, only the top frame is displayed
at any one time.

 -- Function: tty-top-frame &optional terminal
     This function returns the top frame on TERMINAL.  TERMINAL should
     be a terminal object, a frame (meaning that frame's terminal), or
     'nil' (meaning the selected frame's terminal).  If it does not
     refer to a text terminal, the return value is 'nil'.

==============================================================================
File: elisp.info,  Node: |Frame_Configurations|,  Next: |Child_Frames|,  Prev: |Raising_and_Lowering|,  Up: |Frames|
==============================================================================

                                                          *Frame_Configurations*

29.13 Frame Configurations
--------------------------

A "frame configuration" records the current arrangement of frames, all
their properties, and the window configuration of each one.  (*Note
Window Configurations::.)

 -- Function: current-frame-configuration
     This function returns a frame configuration list that describes the
     current arrangement of frames and their contents.

 -- Function: set-frame-configuration configuration &optional nodelete
     This function restores the state of frames described in
     CONFIGURATION.  However, this function does not restore deleted
     frames.

     Ordinarily, this function deletes all existing frames not listed in
     CONFIGURATION.  But if NODELETE is non-'nil', the unwanted frames
     are iconified instead.

==============================================================================
File: elisp.info,  Node: |Child_Frames|,  Next: |Mouse_Tracking|,  Prev: |Frame_Configurations|,  Up: |Frames|
==============================================================================

                                                                  *Child_Frames*

29.14 Child Frames
------------------

Child frames are objects halfway between windows (*note Windows::) and
"normal" frames.  Like windows, they are attached to an owning frame.
Unlike windows, they may overlap each other--changing the size or
position of one child frame does not change the size or position of any
of its sibling child frames.

   By design, operations to make or modify child frames are implemented
with the help of frame parameters (*note Frame Parameters::) without any
specialized functions or customizable variables.  Note that child frames
are meaningful on graphical terminals only.

   To create a new child frame or to convert a normal frame into a child
frame, set that frame's 'parent-frame' parameter (*note Frame
Interaction Parameters::) to that of an already existing frame.  The
frame specified by that parameter will then be the frame's parent frame
as long as the parameter is not changed or reset.  Technically, this
makes the child frame's window-system window a child window of the
parent frame's window-system window.

   The 'parent-frame' parameter can be changed at any time.  Setting it
to another frame "reparents" the child frame.  Setting it to another
child frame makes the frame a "nested" child frame.  Setting it to 'nil'
restores the frame's status as a top-level frame--a frame whose
window-system window is a child of its display's root window.

   Since child frames can be arbitrarily nested, a frame can be both a
child and a parent frame.  Also, the relative roles of child and parent
frame may be reversed at any time (though it's usually a good idea to
keep the size of a child frame sufficiently smaller than that of its
parent).  An error will be signaled for the attempt to make a frame an
ancestor of itself.

   Most window-systems clip a child frame at the native edges (*note
Frame Geometry::) of its parent frame--everything outside these edges is
usually invisible.  A child frame's 'left' and 'top' parameters specify
a position relative to the top-left corner of its parent's native frame.
When the parent frame is resized, this position remains conceptually
unaltered.

   NS builds do not clip child frames at the parent frame's edges,
allowing them to be positioned so they do not obscure the parent frame
while still being visible themselves.

   Usually, moving a parent frame moves along all its child frames and
their descendants as well, keeping their relative positions unaltered.
Note that the hook 'move-frame-functions' (*note Frame Position::) is
run for a child frame only when the position of the child frame relative
to its parent frame changes.

   When a parent frame is resized, its child frames conceptually retain
their previous sizes and their positions relative to the left upper
corner of the parent.  This means that a child frame may become
(partially) invisible when its parent frame shrinks.  The parameter
'keep-ratio' (*note Frame Interaction Parameters::) can be used to
resize and reposition a child frame proportionally whenever its parent
frame is resized.  This may avoid obscuring parts of a frame when its
parent frame is shrunk.

   A visible child frame always appears on top of its parent frame thus
obscuring parts of it, except on NS builds where it may be positioned
beneath the parent.  This is comparable to the window-system window of a
top-level frame which also always appears on top of its parent
window--the desktop's root window.  When a parent frame is iconified or
made invisible (*note Visibility of Frames::), its child frames are made
invisible.  When a parent frame is deiconified or made visible, its
child frames are made visible.

   When a parent frame is about to be deleted (*note Deleting Frames::),
its child frames are recursively deleted before it.  There is one
exception to this rule: When the child frame serves as a surrogate
minibuffer frame (*note Minibuffers and Frames::) for another frame, it
is retained until the parent frame has been deleted.  If, at this time,
no remaining frame uses the child frame as its minibuffer frame, Emacs
will try to delete the child frame too.  If that deletion fails for
whatever reason, the child frame is made a top-level frame.

   Whether a child frame can have a menu or tool bar is window-system or
window manager dependent.  Most window-systems explicitly disallow menu
bars for child frames.  It seems advisable to disable both, menu and
tool bars, via the frame's initial parameters settings.

   Usually, child frames do not exhibit window manager decorations like
a title bar or external borders (*note Frame Geometry::).  When the
child frame does not show a menu or tool bar, any other of the frame's
borders (*note Layout Parameters::) can be used instead of the external
borders.

   In particular, under X (but not when building with GTK+), the frame's
outer border can be used.  On MS-Windows, specifying a non-zero outer
border width will show a one-pixel wide external border.  Under all
window-systems, the internal border can be used.  In either case, it's
advisable to disable a child frame's window manager decorations with the
'undecorated' frame parameter (*note Management Parameters::).

   To resize or move an undecorated child frame with the mouse, special
frame parameters (*note Mouse Dragging Parameters::) have to be used.
The internal border of a child frame, if present, can be used to resize
the frame with the mouse, provided that frame has a non-'nil'
'drag-internal-border' parameter.  If set, the 'snap-width' parameter
indicates the number of pixels where the frame "snaps" at the respective
edge or corner of its parent frame.

   There are two ways to drag an entire child frame with the mouse: The
'drag-with-mode-line' parameter, if non-'nil', allows to drag a frame
without minibuffer window (*note Minibuffer Windows::) via the mode line
area of its bottommost window.  The 'drag-with-header-line' parameter,
if non-'nil', allows to drag the frame via the header line area of its
topmost window.

   In order to give a child frame a draggable header or mode line, the
window parameters 'mode-line-format' and 'header-line-format' are handy
(*note Window Parameters::).  These allow to remove an unwanted mode
line (when 'drag-with-header-line' is chosen) and to remove
mouse-sensitive areas which might interfere with frame dragging.

   To avoid that dragging moves a frame completely out of its parent's
native frame, something which might happen when the mouse cursor
overshoots and makes the frame difficult to retrieve once the mouse
button has been released, it is advisable to set the frame's
'top-visible' or 'bottom-visible' parameter correspondingly.

   The 'top-visible' parameter specifies the number of pixels at the top
of the frame that always remain visible within the parent's native frame
during dragging and should be set when specifying a non-'nil'
'drag-with-header-line' parameter.  The 'bottom-visible' parameter
specifies the number of pixels at the bottom of the frame that always
remain visible within the parent's native frame during dragging and
should be preferred when specifying a non-'nil' 'drag-with-mode-line'
parameter.

   When a child frame is used for displaying a buffer via
'display-buffer-in-child-frame' (*note Buffer Display Action
Functions::), the frame's 'auto-hide-function' parameter (*note Frame
Interaction Parameters::) can be set to a function, in order to
appropriately deal with the frame when the window displaying the buffer
shall be quit.

   When a child frame is used during minibuffer interaction, for
example, to display completions in a separate window, the
'minibuffer-exit' parameter (*note Frame Interaction Parameters::) is
useful in order to deal with the frame when the minibuffer is exited.

   The behavior of child frames deviates from that of top-level frames
in a number of other ways as well.  Here we sketch a few of them:

   * The semantics of maximizing and iconifying child frames is highly
     window-system dependent.  As a rule, applications should never
     invoke these operations on child frames.  By default, invoking
     'iconify-frame' on a child frame will try to iconify the top-level
     frame corresponding to that child frame instead.  To obtain a
     different behavior, users may customize the option
     'iconify-child-frame' described below.

   * Raising, lowering and restacking child frames (*note Raising and
     Lowering::) or changing the 'z-group' (*note Position Parameters::)
     of a child frame changes only the stacking order of child frames
     with the same parent.

   * Many window-systems are not able to change the opacity (*note Font
     and Color Parameters::) of child frames.

   * Transferring focus from a child frame to an ancestor that is not
     its parent by clicking with the mouse in a visible part of that
     ancestor's window may fail with some window-systems.  You may have
     to click into the direct parent's window-system window first.

   * Window managers might not bother to extend their focus follows
     mouse policy to child frames.  Customizing
     'mouse-autoselect-window' can help in this regard (*note Mouse
     Window Auto-selection::).

   * Dropping (*note Drag and Drop::) on child frames is not guaranteed
     to work on all window-systems.  Some will drop the object on the
     parent frame or on some ancestor instead.

   The following two functions can be useful when working with child and
parent frames:

 -- Function: frame-parent &optional frame
     This function returns the parent frame of FRAME.  The parent frame
     of FRAME is the Emacs frame whose window-system window is the
     parent window of FRAME's window-system window.  If such a frame
     exists, FRAME is considered a child frame of that frame.

     This function returns 'nil' if FRAME has no parent frame.

 -- Function: frame-ancestor-p ancestor descendant
     This functions returns non-'nil' if ANCESTOR is an ancestor of
     DESCENDANT.  ANCESTOR is an ancestor of DESCENDANT when it is
     either DESCENDANT's parent frame or it is an ancestor of
     DESCENDANT's parent frame.  Both, ANCESTOR and DESCENDANT must
     specify live frames.

   Note also the function 'window-largest-empty-rectangle' (*note
Coordinates and Windows::) which can be used to inscribe a child frame
in the largest empty area of an existing window.  This can be useful to
avoid that a child frame obscures any text shown in that window.

   Customizing the following option can be useful to tweak the behavior
of 'iconify-frame' for child frames.

 -- User Option: iconify-child-frame
     This option tells Emacs how to proceed when it is asked to iconify
     a child frame.  If it is 'nil', 'iconify-frame' will do nothing
     when invoked on a child frame.  If it is 'iconify-top-level', Emacs
     will try to iconify the top-level frame that is the ancestor of
     this child frame instead.  If it is 'make-invisible', Emacs will
     try to make this child frame invisible instead of iconifying it.

     Any other value means to try iconifying the child frame.  Since
     such an attempt may not be honored by all window managers and can
     even lead to making the child frame unresponsive to user actions,
     the default is to iconify the top level frame instead.

==============================================================================
File: elisp.info,  Node: |Mouse_Tracking|,  Next: |Mouse_Position|,  Prev: |Child_Frames|,  Up: |Frames|
==============================================================================

                                                                *Mouse_Tracking*

29.15 Mouse Tracking
--------------------

Sometimes it is useful to "track" the mouse, which means to display
something to indicate where the mouse is and move the indicator as the
mouse moves.  For efficient mouse tracking, you need a way to wait until
the mouse actually moves.

   The convenient way to track the mouse is to ask for events to
represent mouse motion.  Then you can wait for motion by waiting for an
event.  In addition, you can easily handle any other sorts of events
that may occur.  That is useful, because normally you don't want to
track the mouse forever--only until some other event, such as the release
of a button.

 -- Macro: track-mouse body...
     This macro executes BODY, with generation of mouse motion events
     enabled.  Typically, BODY would use 'read-event' to read the motion
     events and modify the display accordingly.  *Note Motion Events::,
     for the format of mouse motion events.

     The value of 'track-mouse' is that of the last form in BODY.  You
     should design BODY to return when it sees the up-event that
     indicates the release of the button, or whatever kind of event
     means it is time to stop tracking.

     The 'track-mouse' form causes Emacs to generate mouse motion events
     by binding the variable 'track-mouse' to a non-'nil' value.  If
     that variable has the special value 'dragging', it additionally
     instructs the display engine to refrain from changing the shape of
     the mouse pointer.  This is desirable in Lisp programs that require
     mouse dragging across large portions of Emacs display, which might
     otherwise cause the mouse pointer to change its shape according to
     the display portion it hovers on (*note Pointer Shape::).
     Therefore, Lisp programs that need the mouse pointer to retain its
     original shape during dragging should bind 'track-mouse' to the
     value 'dragging' at the beginning of their BODY.

   The usual purpose of tracking mouse motion is to indicate on the
screen the consequences of pushing or releasing a button at the current
position.

   In many cases, you can avoid the need to track the mouse by using the
'mouse-face' text property (*note Special Properties::).  That works at
a much lower level and runs more smoothly than Lisp-level mouse
tracking.

==============================================================================
File: elisp.info,  Node: |Mouse_Position|,  Next: |Pop_Up_Menus|,  Prev: |Mouse_Tracking|,  Up: |Frames|
==============================================================================

                                                                *Mouse_Position*

29.16 Mouse Position
--------------------

The functions 'mouse-position' and 'set-mouse-position' give access to
the current position of the mouse.

 -- Function: mouse-position
     This function returns a description of the position of the mouse.
     The value looks like '(FRAME X . Y)', where X and Y are integers
     giving the (possibly rounded) position in multiples of the default
     character size of FRAME (*note Frame Font::) relative to the native
     position of FRAME (*note Frame Geometry::).
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
