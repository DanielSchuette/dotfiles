          (cumulative_args_t CA, tree TYPE)
     This target hook warns about the change in empty class parameter
     passing ABI.

==============================================================================
File: gccint.info,  Node: |Caller_Saves|,  Next: |Function_Entry|,  Prev: |Aggregate_Return|,  Up: |Stack_and_Calling|
==============================================================================

                                                                  *Caller_Saves*

18.9.10 Caller-Saves Register Allocation
----------------------------------------

If you enable it, GCC can save registers around function calls.  This
makes it possible to use call-clobbered registers to hold variables that
must live across calls.

 -- Macro: HARD_REGNO_CALLER_SAVE_MODE (REGNO, NREGS)
     A C expression specifying which mode is required for saving NREGS
     of a pseudo-register in call-clobbered hard register REGNO.  If
     REGNO is unsuitable for caller save, 'VOIDmode' should be returned.
     For most machines this macro need not be defined since GCC will
     select the smallest suitable mode.

==============================================================================
File: gccint.info,  Node: |Function_Entry|,  Next: |Profiling|,  Prev: |Caller_Saves|,  Up: |Stack_and_Calling|
==============================================================================

                                                                *Function_Entry*

18.9.11 Function Entry and Exit
-------------------------------

This section describes the macros that output function entry
("prologue") and exit ("epilogue") code.

 -- Target Hook: void TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY (FILE
          *FILE, unsigned HOST_WIDE_INT PATCH_AREA_SIZE, bool RECORD_P)
     Generate a patchable area at the function start, consisting of
     PATCH_AREA_SIZE NOP instructions.  If the target supports named
     sections and if RECORD_P is true, insert a pointer to the current
     location in the table of patchable functions.  The default
     implementation of the hook places the table of pointers in the
     special section named '__patchable_function_entries'.

 -- Target Hook: void TARGET_ASM_FUNCTION_PROLOGUE (FILE *FILE)
     If defined, a function that outputs the assembler code for entry to
     a function.  The prologue is responsible for setting up the stack
     frame, initializing the frame pointer register, saving registers
     that must be saved, and allocating SIZE additional bytes of storage
     for the local variables.  FILE is a stdio stream to which the
     assembler code should be output.

     The label for the beginning of the function need not be output by
     this macro.  That has already been done when the macro is run.

     To determine which registers to save, the macro can refer to the
     array 'regs_ever_live': element R is nonzero if hard register R is
     used anywhere within the function.  This implies the function
     prologue should save register R, provided it is not one of the
     call-used registers.  ('TARGET_ASM_FUNCTION_EPILOGUE' must likewise
     use 'regs_ever_live'.)

     On machines that have "register windows", the function entry code
     does not save on the stack the registers that are in the windows,
     even if they are supposed to be preserved by function calls;
     instead it takes appropriate steps to "push" the register stack, if
     any non-call-used registers are used in the function.

     On machines where functions may or may not have frame-pointers, the
     function entry code must vary accordingly; it must set up the frame
     pointer if one is wanted, and not otherwise.  To determine whether
     a frame pointer is in wanted, the macro can refer to the variable
     'frame_pointer_needed'.  The variable's value will be 1 at run time
     in a function that needs a frame pointer.  *Note Elimination::.

     The function entry code is responsible for allocating any stack
     space required for the function.  This stack space consists of the
     regions listed below.  In most cases, these regions are allocated
     in the order listed, with the last listed region closest to the top
     of the stack (the lowest address if 'STACK_GROWS_DOWNWARD' is
     defined, and the highest address if it is not defined).  You can
     use a different order for a machine if doing so is more convenient
     or required for compatibility reasons.  Except in cases where
     required by standard or by a debugger, there is no reason why the
     stack layout used by GCC need agree with that used by other
     compilers for a machine.

 -- Target Hook: void TARGET_ASM_FUNCTION_END_PROLOGUE (FILE *FILE)
     If defined, a function that outputs assembler code at the end of a
     prologue.  This should be used when the function prologue is being
     emitted as RTL, and you have some extra assembler that needs to be
     emitted.  *Note prologue instruction pattern::.

 -- Target Hook: void TARGET_ASM_FUNCTION_BEGIN_EPILOGUE (FILE *FILE)
     If defined, a function that outputs assembler code at the start of
     an epilogue.  This should be used when the function epilogue is
     being emitted as RTL, and you have some extra assembler that needs
     to be emitted.  *Note epilogue instruction pattern::.

 -- Target Hook: void TARGET_ASM_FUNCTION_EPILOGUE (FILE *FILE)
     If defined, a function that outputs the assembler code for exit
     from a function.  The epilogue is responsible for restoring the
     saved registers and stack pointer to their values when the function
     was called, and returning control to the caller.  This macro takes
     the same argument as the macro 'TARGET_ASM_FUNCTION_PROLOGUE', and
     the registers to restore are determined from 'regs_ever_live' and
     'CALL_USED_REGISTERS' in the same way.

     On some machines, there is a single instruction that does all the
     work of returning from the function.  On these machines, give that
     instruction the name 'return' and do not define the macro
     'TARGET_ASM_FUNCTION_EPILOGUE' at all.

     Do not define a pattern named 'return' if you want the
     'TARGET_ASM_FUNCTION_EPILOGUE' to be used.  If you want the target
     switches to control whether return instructions or epilogues are
     used, define a 'return' pattern with a validity condition that
     tests the target switches appropriately.  If the 'return' pattern's
     validity condition is false, epilogues will be used.

     On machines where functions may or may not have frame-pointers, the
     function exit code must vary accordingly.  Sometimes the code for
     these two cases is completely different.  To determine whether a
     frame pointer is wanted, the macro can refer to the variable
     'frame_pointer_needed'.  The variable's value will be 1 when
     compiling a function that needs a frame pointer.

     Normally, 'TARGET_ASM_FUNCTION_PROLOGUE' and
     'TARGET_ASM_FUNCTION_EPILOGUE' must treat leaf functions specially.
     The C variable 'current_function_is_leaf' is nonzero for such a
     function.  *Note Leaf Functions::.

     On some machines, some functions pop their arguments on exit while
     others leave that for the caller to do.  For example, the 68020
     when given '-mrtd' pops arguments in functions that take a fixed
     number of arguments.

     Your definition of the macro 'RETURN_POPS_ARGS' decides which
     functions pop their own arguments.  'TARGET_ASM_FUNCTION_EPILOGUE'
     needs to know what was decided.  The number of bytes of the current
     function's arguments that this function should pop is available in
     'crtl->args.pops_args'.  *Note Scalar Return::.

   * A region of 'crtl->args.pretend_args_size' bytes of uninitialized
     space just underneath the first argument arriving on the stack.
     (This may not be at the very start of the allocated stack region if
     the calling sequence has pushed anything else since pushing the
     stack arguments.  But usually, on such machines, nothing else has
     been pushed yet, because the function prologue itself does all the
     pushing.)  This region is used on machines where an argument may be
     passed partly in registers and partly in memory, and, in some cases
     to support the features in '<stdarg.h>'.

   * An area of memory used to save certain registers used by the
     function.  The size of this area, which may also include space for
     such things as the return address and pointers to previous stack
     frames, is machine-specific and usually depends on which registers
     have been used in the function.  Machines with register windows
     often do not require a save area.

   * A region of at least SIZE bytes, possibly rounded up to an
     allocation boundary, to contain the local variables of the
     function.  On some machines, this region and the save area may
     occur in the opposite order, with the save area closer to the top
     of the stack.

   * Optionally, when 'ACCUMULATE_OUTGOING_ARGS' is defined, a region of
     'crtl->outgoing_args_size' bytes to be used for outgoing argument
     lists of the function.  *Note Stack Arguments::.

 -- Macro: EXIT_IGNORE_STACK
     Define this macro as a C expression that is nonzero if the return
     instruction or the function epilogue ignores the value of the stack
     pointer; in other words, if it is safe to delete an instruction to
     adjust the stack pointer before a return from the function.  The
     default is 0.

     Note that this macro's value is relevant only for functions for
     which frame pointers are maintained.  It is never safe to delete a
     final stack adjustment in a function that has no frame pointer, and
     the compiler knows this regardless of 'EXIT_IGNORE_STACK'.

 -- Macro: EPILOGUE_USES (REGNO)
     Define this macro as a C expression that is nonzero for registers
     that are used by the epilogue or the 'return' pattern.  The stack
     and frame pointer registers are already assumed to be used as
     needed.

 -- Macro: EH_USES (REGNO)
     Define this macro as a C expression that is nonzero for registers
     that are used by the exception handling mechanism, and so should be
     considered live on entry to an exception edge.

 -- Target Hook: void TARGET_ASM_OUTPUT_MI_THUNK (FILE *FILE, tree
          THUNK_FNDECL, HOST_WIDE_INT DELTA, HOST_WIDE_INT VCALL_OFFSET,
          tree FUNCTION)
     A function that outputs the assembler code for a thunk function,
     used to implement C++ virtual function calls with multiple
     inheritance.  The thunk acts as a wrapper around a virtual
     function, adjusting the implicit object parameter before handing
     control off to the real function.

     First, emit code to add the integer DELTA to the location that
     contains the incoming first argument.  Assume that this argument
     contains a pointer, and is the one used to pass the 'this' pointer
     in C++.  This is the incoming argument _before_ the function
     prologue, e.g. '%o0' on a sparc.  The addition must preserve the
     values of all other incoming arguments.

     Then, if VCALL_OFFSET is nonzero, an additional adjustment should
     be made after adding 'delta'.  In particular, if P is the adjusted
     pointer, the following adjustment should be made:

          p += (*((ptrdiff_t **)p))[vcall_offset/sizeof(ptrdiff_t)]

     After the additions, emit code to jump to FUNCTION, which is a
     'FUNCTION_DECL'.  This is a direct pure jump, not a call, and does
     not touch the return address.  Hence returning from FUNCTION will
     return to whoever called the current 'thunk'.

     The effect must be as if FUNCTION had been called directly with the
     adjusted first argument.  This macro is responsible for emitting
     all of the code for a thunk function;
     'TARGET_ASM_FUNCTION_PROLOGUE' and 'TARGET_ASM_FUNCTION_EPILOGUE'
     are not invoked.

     The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already
     been extracted from it.)  It might possibly be useful on some
     targets, but probably not.

     If you do not define this macro, the target-independent code in the
     C++ front end will generate a less efficient heavyweight thunk that
     calls FUNCTION instead of jumping to it.  The generic approach does
     not support varargs.

 -- Target Hook: bool TARGET_ASM_CAN_OUTPUT_MI_THUNK (const_tree
          THUNK_FNDECL, HOST_WIDE_INT DELTA, HOST_WIDE_INT VCALL_OFFSET,
          const_tree FUNCTION)
     A function that returns true if TARGET_ASM_OUTPUT_MI_THUNK would be
     able to output the assembler code for the thunk function specified
     by the arguments it is passed, and false otherwise.  In the latter
     case, the generic approach will be used by the C++ front end, with
     the limitations previously exposed.

==============================================================================
File: gccint.info,  Node: |Profiling|,  Next: |Tail_Calls|,  Prev: |Function_Entry|,  Up: |Stack_and_Calling|
==============================================================================

                                                                     *Profiling*

18.9.12 Generating Code for Profiling
-------------------------------------

These macros will help you generate code for profiling.

 -- Macro: FUNCTION_PROFILER (FILE, LABELNO)
     A C statement or compound statement to output to FILE some
     assembler code to call the profiling subroutine 'mcount'.

     The details of how 'mcount' expects to be called are determined by
     your operating system environment, not by GCC.  To figure them out,
     compile a small program for profiling using the system's installed
     C compiler and look at the assembler code that results.

     Older implementations of 'mcount' expect the address of a counter
     variable to be loaded into some register.  The name of this
     variable is 'LP' followed by the number LABELNO, so you would
     generate the name using 'LP%d' in a 'fprintf'.

 -- Macro: PROFILE_HOOK
     A C statement or compound statement to output to FILE some assembly
     code to call the profiling subroutine 'mcount' even the target does
     not support profiling.

 -- Macro: NO_PROFILE_COUNTERS
     Define this macro to be an expression with a nonzero value if the
     'mcount' subroutine on your system does not need a counter variable
     allocated for each function.  This is true for almost all modern
     implementations.  If you define this macro, you must not use the
     LABELNO argument to 'FUNCTION_PROFILER'.

 -- Macro: PROFILE_BEFORE_PROLOGUE
     Define this macro if the code for function profiling should come
     before the function prologue.  Normally, the profiling code comes
     after.

 -- Target Hook: bool TARGET_KEEP_LEAF_WHEN_PROFILED (void)
     This target hook returns true if the target wants the leaf flag for
     the current function to stay true even if it calls mcount.  This
     might make sense for targets using the leaf flag only to determine
     whether a stack frame needs to be generated or not and for which
     the call to mcount is generated before the function prologue.

==============================================================================
File: gccint.info,  Node: |Tail_Calls|,  Next: |Shrink_wrapping_separate_components|,  Prev: |Profiling|,  Up: |Stack_and_Calling|
==============================================================================

                                                                    *Tail_Calls*

18.9.13 Permitting tail calls
-----------------------------

 -- Target Hook: bool TARGET_FUNCTION_OK_FOR_SIBCALL (tree DECL, tree
          EXP)
     True if it is OK to do sibling call optimization for the specified
     call expression EXP.  DECL will be the called function, or 'NULL'
     if this is an indirect call.

     It is not uncommon for limitations of calling conventions to
     prevent tail calls to functions outside the current unit of
     translation, or during PIC compilation.  The hook is used to
     enforce these restrictions, as the 'sibcall' md pattern cannot
     fail, or fall over to a "normal" call.  The criteria for successful
     sibling call optimization may vary greatly between different
     architectures.

 -- Target Hook: void TARGET_EXTRA_LIVE_ON_ENTRY (bitmap REGS)
     Add any hard registers to REGS that are live on entry to the
     function.  This hook only needs to be defined to provide registers
     that cannot be found by examination of FUNCTION_ARG_REGNO_P, the
     callee saved registers, STATIC_CHAIN_INCOMING_REGNUM,
     STATIC_CHAIN_REGNUM, TARGET_STRUCT_VALUE_RTX, FRAME_POINTER_REGNUM,
     EH_USES, FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM, and the
     PIC_OFFSET_TABLE_REGNUM.

 -- Target Hook: void TARGET_SET_UP_BY_PROLOGUE (struct
          hard_reg_set_container *)
     This hook should add additional registers that are computed by the
     prologue to the hard regset for shrink-wrapping optimization
     purposes.

 -- Target Hook: bool TARGET_WARN_FUNC_RETURN (tree)
     True if a function's return statements should be checked for
     matching the function's return type.  This includes checking for
     falling off the end of a non-void function.  Return false if no
     such check should be made.

==============================================================================
File: gccint.info,  Node: |Shrink_wrapping_separate_components|,  Next: |Stack_Smashing_Protection|,  Prev: |Tail_Calls|,  Up: |Stack_and_Calling|
==============================================================================

                                           *Shrink_wrapping_separate_components*

18.9.14 Shrink-wrapping separate components
-------------------------------------------

The prologue may perform a variety of target dependent tasks such as
saving callee-saved registers, saving the return address, aligning the
stack, creating a stack frame, initializing the PIC register, setting up
the static chain, etc.

 On some targets some of these tasks may be independent of others and
thus may be shrink-wrapped separately.  These independent tasks are
referred to as components and are handled generically by the target
independent parts of GCC.

 Using the following hooks those prologue or epilogue components can be
shrink-wrapped separately, so that the initialization (and possibly
teardown) those components do is not done as frequently on execution
paths where this would unnecessary.

 What exactly those components are is up to the target code; the generic
code treats them abstractly, as a bit in an 'sbitmap'.  These 'sbitmap's
are allocated by the 'shrink_wrap.get_separate_components' and
'shrink_wrap.components_for_bb' hooks, and deallocated by the generic
code.

 -- Target Hook: sbitmap TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS
          (void)
     This hook should return an 'sbitmap' with the bits set for those
     components that can be separately shrink-wrapped in the current
     function.  Return 'NULL' if the current function should not get any
     separate shrink-wrapping.  Don't define this hook if it would
     always return 'NULL'.  If it is defined, the other hooks in this
     group have to be defined as well.

 -- Target Hook: sbitmap TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB
          (basic_block)
     This hook should return an 'sbitmap' with the bits set for those
     components where either the prologue component has to be executed
     before the 'basic_block', or the epilogue component after it, or
     both.

 -- Target Hook: void TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS (sbitmap
          COMPONENTS, edge E, sbitmap EDGE_COMPONENTS, bool IS_PROLOGUE)
     This hook should clear the bits in the COMPONENTS bitmap for those
     components in EDGE_COMPONENTS that the target cannot handle on edge
     E, where IS_PROLOGUE says if this is for a prologue or an epilogue
     instead.

 -- Target Hook: void TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS
          (sbitmap)
     Emit prologue insns for the components indicated by the parameter.

 -- Target Hook: void TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS
          (sbitmap)
     Emit epilogue insns for the components indicated by the parameter.

 -- Target Hook: void TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS
          (sbitmap)
     Mark the components in the parameter as handled, so that the
     'prologue' and 'epilogue' named patterns know to ignore those
     components.  The target code should not hang on to the 'sbitmap',
     it will be deleted after this call.

==============================================================================
File: gccint.info,  Node: |Stack_Smashing_Protection|,  Next: |Miscellaneous_Register_Hooks|,  Prev: |Shrink_wrapping_separate_components|,  Up: |Stack_and_Calling|
==============================================================================

                                                     *Stack_Smashing_Protection*

18.9.15 Stack smashing protection
---------------------------------

 -- Target Hook: tree TARGET_STACK_PROTECT_GUARD (void)
     This hook returns a 'DECL' node for the external variable to use
     for the stack protection guard.  This variable is initialized by
     the runtime to some random value and is used to initialize the
     guard value that is placed at the top of the local stack frame.
     The type of this variable must be 'ptr_type_node'.

     The default version of this hook creates a variable called
     '__stack_chk_guard', which is normally defined in 'libgcc2.c'.

 -- Target Hook: tree TARGET_STACK_PROTECT_FAIL (void)
     This hook returns a 'CALL_EXPR' that alerts the runtime that the
     stack protect guard variable has been modified.  This expression
     should involve a call to a 'noreturn' function.

     The default version of this hook invokes a function called
     '__stack_chk_fail', taking no arguments.  This function is normally
     defined in 'libgcc2.c'.

 -- Target Hook: bool TARGET_STACK_PROTECT_RUNTIME_ENABLED_P (void)
     Returns true if the target wants GCC's default stack protect
     runtime support, otherwise return false.  The default
     implementation always returns true.

 -- Common Target Hook: bool TARGET_SUPPORTS_SPLIT_STACK (bool REPORT,
          struct gcc_options *OPTS)
     Whether this target supports splitting the stack when the options
     described in OPTS have been passed.  This is called after options
     have been parsed, so the target may reject splitting the stack in
     some configurations.  The default version of this hook returns
     false.  If REPORT is true, this function may issue a warning or
     error; if REPORT is false, it must simply return a value

 -- Common Target Hook: vec<const char *> TARGET_GET_VALID_OPTION_VALUES
          (int OPTION_CODE, const char *PREFIX)
     The hook is used for options that have a non-trivial list of
     possible option values.  OPTION_CODE is option code of opt_code
     enum type.  PREFIX is used for bash completion and allows an
     implementation to return more specific completion based on the
     prefix.  All string values should be allocated from heap memory and
     consumers should release them.  The result will be pruned to cases
     with PREFIX if not NULL.

==============================================================================
File: gccint.info,  Node: |Miscellaneous_Register_Hooks|,  Prev: |Stack_Smashing_Protection|,  Up: |Stack_and_Calling|
==============================================================================

                                                  *Miscellaneous_Register_Hooks*

18.9.16 Miscellaneous register hooks
------------------------------------

 -- Target Hook: bool TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS
     Set to true if each call that binds to a local definition
     explicitly clobbers or sets all non-fixed registers modified by
     performing the call.  That is, by the call pattern itself, or by
     code that might be inserted by the linker (e.g. stubs, veneers,
     branch islands), but not including those modifiable by the callee.
     The affected registers may be mentioned explicitly in the call
     pattern, or included as clobbers in CALL_INSN_FUNCTION_USAGE. The
     default version of this hook is set to false.  The purpose of this
     hook is to enable the fipa-ra optimization.

==============================================================================
File: gccint.info,  Node: |Varargs|,  Next: |Trampolines|,  Prev: |Stack_and_Calling|,  Up: |Target_Macros|
==============================================================================

                                                                       *Varargs*

18.10 Implementing the Varargs Macros
==========---------------------------

GCC comes with an implementation of '<varargs.h>' and '<stdarg.h>' that
work without change on machines that pass arguments on the stack.  Other
machines require their own implementations of varargs, and the two
machine independent header files must have conditionals to include it.

 ISO '<stdarg.h>' differs from traditional '<varargs.h>' mainly in the
calling convention for 'va_start'.  The traditional implementation takes
just one argument, which is the variable in which to store the argument
pointer.  The ISO implementation of 'va_start' takes an additional
second argument.  The user is supposed to write the last named argument
of the function here.

 However, 'va_start' should not use this argument.  The way to find the
end of the named arguments is with the built-in functions described
below.

 -- Macro: __builtin_saveregs ()
     Use this built-in function to save the argument registers in memory
     so that the varargs mechanism can access them.  Both ISO and
     traditional versions of 'va_start' must use '__builtin_saveregs',
     unless you use 'TARGET_SETUP_INCOMING_VARARGS' (see below) instead.

     On some machines, '__builtin_saveregs' is open-coded under the
     control of the target hook 'TARGET_EXPAND_BUILTIN_SAVEREGS'.  On
     other machines, it calls a routine written in assembler language,
     found in 'libgcc2.c'.

     Code generated for the call to '__builtin_saveregs' appears at the
     beginning of the function, as opposed to where the call to
     '__builtin_saveregs' is written, regardless of what the code is.
     This is because the registers must be saved before the function
     starts to use them for its own purposes.

 -- Macro: __builtin_next_arg (LASTARG)
     This builtin returns the address of the first anonymous stack
     argument, as type 'void *'.  If 'ARGS_GROW_DOWNWARD', it returns
     the address of the location above the first anonymous stack
     argument.  Use it in 'va_start' to initialize the pointer for
     fetching arguments from the stack.  Also use it in 'va_start' to
     verify that the second parameter LASTARG is the last named argument
     of the current function.

 -- Macro: __builtin_classify_type (OBJECT)
     Since each machine has its own conventions for which data types are
     passed in which kind of register, your implementation of 'va_arg'
     has to embody these conventions.  The easiest way to categorize the
     specified data type is to use '__builtin_classify_type' together
     with 'sizeof' and '__alignof__'.

     '__builtin_classify_type' ignores the value of OBJECT, considering
     only its data type.  It returns an integer describing what kind of
     type that is--integer, floating, pointer, structure, and so on.

     The file 'typeclass.h' defines an enumeration that you can use to
     interpret the values of '__builtin_classify_type'.

 These machine description macros help implement varargs:

 -- Target Hook: rtx TARGET_EXPAND_BUILTIN_SAVEREGS (void)
     If defined, this hook produces the machine-specific code for a call
     to '__builtin_saveregs'.  This code will be moved to the very
     beginning of the function, before any parameter access are made.
     The return value of this function should be an RTX that contains
     the value to use as the return of '__builtin_saveregs'.

 -- Target Hook: void TARGET_SETUP_INCOMING_VARARGS (cumulative_args_t
          ARGS_SO_FAR, const function_arg_info &ARG, int
          *PRETEND_ARGS_SIZE, int SECOND_TIME)
     This target hook offers an alternative to using
     '__builtin_saveregs' and defining the hook
     'TARGET_EXPAND_BUILTIN_SAVEREGS'.  Use it to store the anonymous
     register arguments into the stack so that all the arguments appear
     to have been passed consecutively on the stack.  Once this is done,
     you can use the standard implementation of varargs that works for
     machines that pass all their arguments on the stack.

     The argument ARGS_SO_FAR points to the 'CUMULATIVE_ARGS' data
     structure, containing the values that are obtained after processing
     the named arguments.  The argument ARG describes the last of these
     named arguments.

     The target hook should do two things: first, push onto the stack
     all the argument registers _not_ used for the named arguments, and
     second, store the size of the data thus pushed into the
     'int'-valued variable pointed to by PRETEND_ARGS_SIZE.  The value
     that you store here will serve as additional offset for setting up
     the stack frame.

     Because you must generate code to push the anonymous arguments at
     compile time without knowing their data types,
     'TARGET_SETUP_INCOMING_VARARGS' is only useful on machines that
     have just a single category of argument register and use it
     uniformly for all data types.

     If the argument SECOND_TIME is nonzero, it means that the arguments
     of the function are being analyzed for the second time.  This
     happens for an inline function, which is not actually compiled
     until the end of the source file.  The hook
     'TARGET_SETUP_INCOMING_VARARGS' should not generate any
     instructions in this case.

 -- Target Hook: bool TARGET_STRICT_ARGUMENT_NAMING (cumulative_args_t
          CA)
     Define this hook to return 'true' if the location where a function
     argument is passed depends on whether or not it is a named
     argument.

     This hook controls how the NAMED argument to 'TARGET_FUNCTION_ARG'
     is set for varargs and stdarg functions.  If this hook returns
     'true', the NAMED argument is always true for named arguments, and
     false for unnamed arguments.  If it returns 'false', but
     'TARGET_PRETEND_OUTGOING_VARARGS_NAMED' returns 'true', then all
     arguments are treated as named.  Otherwise, all named arguments
     except the last are treated as named.

     You need not define this hook if it always returns 'false'.

 -- Target Hook: void TARGET_CALL_ARGS (rtx, TREE)
     While generating RTL for a function call, this target hook is
     invoked once for each argument passed to the function, either a
     register returned by 'TARGET_FUNCTION_ARG' or a memory location.
     It is called just before the point where argument registers are
     stored.  The type of the function to be called is also passed as
     the second argument; it is 'NULL_TREE' for libcalls.  The
     'TARGET_END_CALL_ARGS' hook is invoked just after the code to copy
     the return reg has been emitted.  This functionality can be used to
     perform special setup of call argument registers if a target needs
     it.  For functions without arguments, the hook is called once with
     'pc_rtx' passed instead of an argument register.  Most ports do not
     need to implement anything for this hook.

 -- Target Hook: void TARGET_END_CALL_ARGS (void)
     This target hook is invoked while generating RTL for a function
     call, just after the point where the return reg is copied into a
     pseudo.  It signals that all the call argument and return registers
     for the just emitted call are now no longer in use.  Most ports do
     not need to implement anything for this hook.

 -- Target Hook: bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED
          (cumulative_args_t CA)
     If you need to conditionally change ABIs so that one works with
     'TARGET_SETUP_INCOMING_VARARGS', but the other works like neither
     'TARGET_SETUP_INCOMING_VARARGS' nor 'TARGET_STRICT_ARGUMENT_NAMING'
     was defined, then define this hook to return 'true' if
     'TARGET_SETUP_INCOMING_VARARGS' is used, 'false' otherwise.
     Otherwise, you should not define this hook.

 -- Target Hook: rtx TARGET_LOAD_BOUNDS_FOR_ARG (rtx SLOT, rtx ARG, rtx
          SLOT_NO)
     This hook is used by expand pass to emit insn to load bounds of ARG
     passed in SLOT.  Expand pass uses this hook in case bounds of ARG
     are not passed in register.  If SLOT is a memory, then bounds are
     loaded as for regular pointer loaded from memory.  If SLOT is not a
     memory then SLOT_NO is an integer constant holding number of the
     target dependent special slot which should be used to obtain
     bounds.  Hook returns RTX holding loaded bounds.

 -- Target Hook: void TARGET_STORE_BOUNDS_FOR_ARG (rtx ARG, rtx SLOT,
          rtx BOUNDS, rtx SLOT_NO)
     This hook is used by expand pass to emit insns to store BOUNDS of
     ARG passed in SLOT.  Expand pass uses this hook in case BOUNDS of
     ARG are not passed in register.  If SLOT is a memory, then BOUNDS
     are stored as for regular pointer stored in memory.  If SLOT is not
     a memory then SLOT_NO is an integer constant holding number of the
     target dependent special slot which should be used to store BOUNDS.

 -- Target Hook: rtx TARGET_LOAD_RETURNED_BOUNDS (rtx SLOT)
     This hook is used by expand pass to emit insn to load bounds
     returned by function call in SLOT.  Hook returns RTX holding loaded
     bounds.

 -- Target Hook: void TARGET_STORE_RETURNED_BOUNDS (rtx SLOT, rtx
          BOUNDS)
     This hook is used by expand pass to emit insn to store BOUNDS
     returned by function call into SLOT.

==============================================================================
File: gccint.info,  Node: |Trampolines|,  Next: |Library_Calls|,  Prev: |Varargs|,  Up: |Target_Macros|
==============================================================================

                                                                   *Trampolines*

18.11 Support for Nested Functions
==========------------------------

Taking the address of a nested function requires special compiler
handling to ensure that the static chain register is loaded when the
function is invoked via an indirect call.

 GCC has traditionally supported nested functions by creating an
executable "trampoline" at run time when the address of a nested
function is taken.  This is a small piece of code which normally resides
on the stack, in the stack frame of the containing function.  The
trampoline loads the static chain register and then jumps to the real
address of the nested function.

 The use of trampolines requires an executable stack, which is a
security risk.  To avoid this problem, GCC also supports another
strategy: using descriptors for nested functions.  Under this model,
taking the address of a nested function results in a pointer to a
non-executable function descriptor object.  Initializing the static
chain from the descriptor is handled at indirect call sites.

 On some targets, including HPPA and IA-64, function descriptors may be
mandated by the ABI or be otherwise handled in a target-specific way by
the back end in its code generation strategy for indirect calls.  GCC
also provides its own generic descriptor implementation to support the
'-fno-trampolines' option.  In this case runtime detection of function
descriptors at indirect call sites relies on descriptor pointers being
tagged with a bit that is never set in bare function addresses.  Since
GCC's generic function descriptors are not ABI-compliant, this option is
typically used only on a per-language basis (notably by Ada) or when it
can otherwise be applied to the whole program.

 Define the following hook if your backend either implements
ABI-specified descriptor support, or can use GCC's generic descriptor
implementation for nested functions.

 -- Target Hook: int TARGET_CUSTOM_FUNCTION_DESCRIPTORS
     If the target can use GCC's generic descriptor mechanism for nested
     functions, define this hook to a power of 2 representing an unused
     bit in function pointers which can be used to differentiate
     descriptors at run time.  This value gives the number of bytes by
     which descriptor pointers are misaligned compared to function
     pointers.  For example, on targets that require functions to be
     aligned to a 4-byte boundary, a value of either 1 or 2 is
     appropriate unless the architecture already reserves the bit for
     another purpose, such as on ARM.

     Define this hook to 0 if the target implements ABI support for
     function descriptors in its standard calling sequence, like for
     example HPPA or IA-64.

     Using descriptors for nested functions eliminates the need for
     trampolines that reside on the stack and require it to be made
     executable.

 The following macros tell GCC how to generate code to allocate and
initialize an executable trampoline.  You can also use this interface if
your back end needs to create ABI-specified non-executable descriptors;
in this case the "trampoline" created is the descriptor containing data
only.

 The instructions in an executable trampoline must do two things: load a
constant address into the static chain register, and jump to the real
address of the nested function.  On CISC machines such as the m68k, this
requires two instructions, a move immediate and a jump.  Then the two
addresses exist in the trampoline as word-long immediate operands.  On
RISC machines, it is often necessary to load each address into a
register in two parts.  Then pieces of each address form separate
immediate operands.

 The code generated to initialize the trampoline must store the variable
parts--the static chain value and the function address--into the
immediate operands of the instructions.  On a CISC machine, this is
simply a matter of copying each address to a memory reference at the
proper offset from the start of the trampoline.  On a RISC machine, it
may be necessary to take out pieces of the address and store them
separately.

 -- Target Hook: void TARGET_ASM_TRAMPOLINE_TEMPLATE (FILE *F)
     This hook is called by 'assemble_trampoline_template' to output, on
     the stream F, assembler code for a block of data that contains the
     constant parts of a trampoline.  This code should not include a
     label--the label is taken care of automatically.

     If you do not define this hook, it means no template is needed for
     the target.  Do not define this hook on systems where the block
     move code to copy the trampoline into place would be larger than
     the code to generate it on the spot.

 -- Macro: TRAMPOLINE_SECTION
     Return the section into which the trampoline template is to be
     placed (*note Sections::).  The default value is
     'readonly_data_section'.

 -- Macro: TRAMPOLINE_SIZE
     A C expression for the size in bytes of the trampoline, as an
     integer.

 -- Macro: TRAMPOLINE_ALIGNMENT
     Alignment required for trampolines, in bits.

     If you don't define this macro, the value of 'FUNCTION_ALIGNMENT'
     is used for aligning trampolines.

 -- Target Hook: void TARGET_TRAMPOLINE_INIT (rtx M_TRAMP, tree FNDECL,
          rtx STATIC_CHAIN)
     This hook is called to initialize a trampoline.  M_TRAMP is an RTX
     for the memory block for the trampoline; FNDECL is the
     'FUNCTION_DECL' for the nested function; STATIC_CHAIN is an RTX for
     the static chain value that should be passed to the function when
     it is called.

     If the target defines 'TARGET_ASM_TRAMPOLINE_TEMPLATE', then the
     first thing this hook should do is emit a block move into M_TRAMP
     from the memory block returned by 'assemble_trampoline_template'.
     Note that the block move need only cover the constant parts of the
     trampoline.  If the target isolates the variable parts of the
     trampoline to the end, not all 'TRAMPOLINE_SIZE' bytes need be
     copied.

     If the target requires any other actions, such as flushing caches
     or enabling stack execution, these actions should be performed
     after initializing the trampoline proper.

 -- Target Hook: rtx TARGET_TRAMPOLINE_ADJUST_ADDRESS (rtx ADDR)
     This hook should perform any machine-specific adjustment in the
     address of the trampoline.  Its argument contains the address of
     the memory block that was passed to 'TARGET_TRAMPOLINE_INIT'.  In
     case the address to be used for a function call should be different
     from the address at which the template was stored, the different
     address should be returned; otherwise ADDR should be returned
     unchanged.  If this hook is not defined, ADDR will be used for
     function calls.

 Implementing trampolines is difficult on many machines because they
have separate instruction and data caches.  Writing into a stack
location fails to clear the memory in the instruction cache, so when the
program jumps to that location, it executes the old contents.

 Here are two possible solutions.  One is to clear the relevant parts of
the instruction cache whenever a trampoline is set up.  The other is to
make all trampolines identical, by having them jump to a standard
subroutine.  The former technique makes trampoline execution faster; the
latter makes initialization faster.

 To clear the instruction cache when a trampoline is initialized, define
the following macro.

 -- Macro: CLEAR_INSN_CACHE (BEG, END)
     If defined, expands to a C expression clearing the _instruction
     cache_ in the specified interval.  The definition of this macro
     would typically be a series of 'asm' statements.  Both BEG and END
     are both pointer expressions.

 To use a standard subroutine, define the following macro.  In addition,
you must make sure that the instructions in a trampoline fill an entire
cache line with identical instructions, or else ensure that the
beginning of the trampoline code is always aligned at the same point in
its cache line.  Look in 'm68k.h' as a guide.

 -- Macro: TRANSFER_FROM_TRAMPOLINE
     Define this macro if trampolines need a special subroutine to do
     their work.  The macro should expand to a series of 'asm'
     statements which will be compiled with GCC.  They go in a library
     function named '__transfer_from_trampoline'.

     If you need to avoid executing the ordinary prologue code of a
     compiled C function when you jump to the subroutine, you can do so
     by placing a special label of your own in the assembler code.  Use
     one 'asm' statement to generate an assembler label, and another to
     make the label global.  Then trampolines can use that label to jump
     directly to your special assembler code.

==============================================================================
File: gccint.info,  Node: |Library_Calls|,  Next: |Addressing_Modes|,  Prev: |Trampolines|,  Up: |Target_Macros|
==============================================================================

                                                                 *Library_Calls*

18.12 Implicit Calls to Library Routines
==========------------------------------

Here is an explanation of implicit calls to library routines.

 -- Macro: DECLARE_LIBRARY_RENAMES
     This macro, if defined, should expand to a piece of C code that
     will get expanded when compiling functions for libgcc.a.  It can be
     used to provide alternate names for GCC's internal library
     functions if there are ABI-mandated names that the compiler should
     provide.

 -- Target Hook: void TARGET_INIT_LIBFUNCS (void)
     This hook should declare additional library routines or rename
     existing ones, using the functions 'set_optab_libfunc' and
     'init_one_libfunc' defined in 'optabs.c'.  'init_optabs' calls this
     macro after initializing all the normal library routines.

     The default is to do nothing.  Most ports don't need to define this
     hook.

 -- Target Hook: bool TARGET_LIBFUNC_GNU_PREFIX
     If false (the default), internal library routines start with two
     underscores.  If set to true, these routines start with '__gnu_'
     instead.  E.g., '__muldi3' changes to '__gnu_muldi3'.  This
     currently only affects functions defined in 'libgcc2.c'.  If this
     is set to true, the 'tm.h' file must also '#define
     LIBGCC2_GNU_PREFIX'.

 -- Macro: FLOAT_LIB_COMPARE_RETURNS_BOOL (MODE, COMPARISON)
     This macro should return 'true' if the library routine that
     implements the floating point comparison operator COMPARISON in
     mode MODE will return a boolean, and FALSE if it will return a
     tristate.

     GCC's own floating point libraries return tristates from the
     comparison operators, so the default returns false always.  Most
     ports don't need to define this macro.

 -- Macro: TARGET_LIB_INT_CMP_BIASED
     This macro should evaluate to 'true' if the integer comparison
     functions (like '__cmpdi2') return 0 to indicate that the first
     operand is smaller than the second, 1 to indicate that they are
     equal, and 2 to indicate that the first operand is greater than the
     second.  If this macro evaluates to 'false' the comparison
     functions return -1, 0, and 1 instead of 0, 1, and 2.  If the
     target uses the routines in 'libgcc.a', you do not need to define
     this macro.

 -- Macro: TARGET_HAS_NO_HW_DIVIDE
     This macro should be defined if the target has no hardware divide
     instructions.  If this macro is defined, GCC will use an algorithm
     which make use of simple logical and arithmetic operations for
     64-bit division.  If the macro is not defined, GCC will use an
     algorithm which make use of a 64-bit by 32-bit divide primitive.

 -- Macro: TARGET_EDOM
     The value of 'EDOM' on the target machine, as a C integer constant
     expression.  If you don't define this macro, GCC does not attempt
     to deposit the value of 'EDOM' into 'errno' directly.  Look in
     '/usr/include/errno.h' to find the value of 'EDOM' on your system.

     If you do not define 'TARGET_EDOM', then compiled code reports
     domain errors by calling the library function and letting it report
     the error.  If mathematical functions on your system use 'matherr'
     when there is an error, then you should leave 'TARGET_EDOM'
     undefined so that 'matherr' is used normally.

 -- Macro: GEN_ERRNO_RTX
     Define this macro as a C expression to create an rtl expression
     that refers to the global "variable" 'errno'.  (On certain systems,
     'errno' may not actually be a variable.)  If you don't define this
     macro, a reasonable default is used.

 -- Target Hook: bool TARGET_LIBC_HAS_FUNCTION (enum function_class
          FN_CLASS)
     This hook determines whether a function from a class of functions
     FN_CLASS is present in the target C library.

 -- Target Hook: bool TARGET_LIBC_HAS_FAST_FUNCTION (int FCODE)
     This hook determines whether a function from a class of functions
     '(enum function_class)'FCODE has a fast implementation.

 -- Macro: NEXT_OBJC_RUNTIME
     Set this macro to 1 to use the "NeXT" Objective-C message sending
     conventions by default.  This calling convention involves passing
     the object, the selector and the method arguments all at once to
     the method-lookup library function.  This is the usual setting when
     targeting Darwin/Mac OS X systems, which have the NeXT runtime
     installed.

     If the macro is set to 0, the "GNU" Objective-C message sending
     convention will be used by default.  This convention passes just
     the object and the selector to the method-lookup function, which
     returns a pointer to the method.

     In either case, it remains possible to select code-generation for
     the alternate scheme, by means of compiler command line switches.

==============================================================================
File: gccint.info,  Node: |Addressing_Modes|,  Next: |Anchored_Addresses|,  Prev: |Library_Calls|,  Up: |Target_Macros|
==============================================================================

                                                              *Addressing_Modes*

18.13 Addressing Modes
==========------------

This is about addressing modes.

 -- Macro: HAVE_PRE_INCREMENT
 -- Macro: HAVE_PRE_DECREMENT
 -- Macro: HAVE_POST_INCREMENT
 -- Macro: HAVE_POST_DECREMENT
     A C expression that is nonzero if the machine supports
     pre-increment, pre-decrement, post-increment, or post-decrement
     addressing respectively.

 -- Macro: HAVE_PRE_MODIFY_DISP
 -- Macro: HAVE_POST_MODIFY_DISP
     A C expression that is nonzero if the machine supports pre- or
     post-address side-effect generation involving constants other than
     the size of the memory operand.

 -- Macro: HAVE_PRE_MODIFY_REG
 -- Macro: HAVE_POST_MODIFY_REG
     A C expression that is nonzero if the machine supports pre- or
     post-address side-effect generation involving a register
     displacement.

 -- Macro: CONSTANT_ADDRESS_P (X)
     A C expression that is 1 if the RTX X is a constant which is a
     valid address.  On most machines the default definition of
     '(CONSTANT_P (X) && GET_CODE (X) != CONST_DOUBLE)' is acceptable,
     but a few machines are more restrictive as to which constant
     addresses are supported.

 -- Macro: CONSTANT_P (X)
     'CONSTANT_P', which is defined by target-independent code, accepts
     integer-values expressions whose values are not explicitly known,
     such as 'symbol_ref', 'label_ref', and 'high' expressions and
     'const' arithmetic expressions, in addition to 'const_int' and
     'const_double' expressions.

 -- Macro: MAX_REGS_PER_ADDRESS
     A number, the maximum number of registers that can appear in a
     valid memory address.  Note that it is up to you to specify a value
     equal to the maximum number that 'TARGET_LEGITIMATE_ADDRESS_P'
     would ever accept.

 -- Target Hook: bool TARGET_LEGITIMATE_ADDRESS_P (machine_mode MODE,
          rtx X, bool STRICT)
     A function that returns whether X (an RTX) is a legitimate memory
     address on the target machine for a memory operand of mode MODE.

     Legitimate addresses are defined in two variants: a strict variant
     and a non-strict one.  The STRICT parameter chooses which variant
     is desired by the caller.

     The strict variant is used in the reload pass.  It must be defined
     so that any pseudo-register that has not been allocated a hard
     register is considered a memory reference.  This is because in
     contexts where some kind of register is required, a pseudo-register
     with no hard register must be rejected.  For non-hard registers,
     the strict variant should look up the 'reg_renumber' array; it
     should then proceed using the hard register number in the array, or
     treat the pseudo as a memory reference if the array holds '-1'.

     The non-strict variant is used in other passes.  It must be defined
     to accept all pseudo-registers in every context where some kind of
     register is required.

     Normally, constant addresses which are the sum of a 'symbol_ref'
     and an integer are stored inside a 'const' RTX to mark them as
     constant.  Therefore, there is no need to recognize such sums
     specifically as legitimate addresses.  Normally you would simply
     recognize any 'const' as legitimate.

     Usually 'PRINT_OPERAND_ADDRESS' is not prepared to handle constant
     sums that are not marked with 'const'.  It assumes that a naked
     'plus' indicates indexing.  If so, then you _must_ reject such
     naked constant sums as illegitimate addresses, so that none of them
     will be given to 'PRINT_OPERAND_ADDRESS'.

     On some machines, whether a symbolic address is legitimate depends
     on the section that the address refers to.  On these machines,
     define the target hook 'TARGET_ENCODE_SECTION_INFO' to store the
     information into the 'symbol_ref', and then check for it here.
     When you see a 'const', you will have to look inside it to find the
     'symbol_ref' in order to determine the section.  *Note Assembler
     Format::.

     Some ports are still using a deprecated legacy substitute for this
     hook, the 'GO_IF_LEGITIMATE_ADDRESS' macro.  This macro has this
     syntax:

          #define GO_IF_LEGITIMATE_ADDRESS (MODE, X, LABEL)

     and should 'goto LABEL' if the address X is a valid address on the
     target machine for a memory operand of mode MODE.

     Compiler source files that want to use the strict variant of this
     macro define the macro 'REG_OK_STRICT'.  You should use an '#ifdef
     REG_OK_STRICT' conditional to define the strict variant in that
     case and the non-strict variant otherwise.

     Using the hook is usually simpler because it limits the number of
     files that are recompiled when changes are made.

 -- Macro: TARGET_MEM_CONSTRAINT
     A single character to be used instead of the default ''m''
     character for general memory addresses.  This defines the
     constraint letter which matches the memory addresses accepted by
     'TARGET_LEGITIMATE_ADDRESS_P'.  Define this macro if you want to
     support new address formats in your back end without changing the
     semantics of the ''m'' constraint.  This is necessary in order to
     preserve functionality of inline assembly constructs using the
     ''m'' constraint.

 -- Macro: FIND_BASE_TERM (X)
     A C expression to determine the base term of address X, or to
     provide a simplified version of X from which 'alias.c' can easily
     find the base term.  This macro is used in only two places:
     'find_base_value' and 'find_base_term' in 'alias.c'.

     It is always safe for this macro to not be defined.  It exists so
     that alias analysis can understand machine-dependent addresses.

     The typical use of this macro is to handle addresses containing a
     label_ref or symbol_ref within an UNSPEC.

 -- Target Hook: rtx TARGET_LEGITIMIZE_ADDRESS (rtx X, rtx OLDX,
          machine_mode MODE)
     This hook is given an invalid memory address X for an operand of
     mode MODE and should try to return a valid memory address.

     X will always be the result of a call to 'break_out_memory_refs',
     and OLDX will be the operand that was given to that function to
     produce X.

     The code of the hook should not alter the substructure of X.  If it
     transforms X into a more legitimate form, it should return the new
     X.

     It is not necessary for this hook to come up with a legitimate
     address, with the exception of native TLS addresses (*note Emulated
     TLS::).  The compiler has standard ways of doing so in all cases.
     In fact, if the target supports only emulated TLS, it is safe to
     omit this hook or make it return X if it cannot find a valid way to
     legitimize the address.  But often a machine-dependent strategy can
     generate better code.

 -- Macro: LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS,
          WIN)
     A C compound statement that attempts to replace X, which is an
     address that needs reloading, with a valid memory address for an
     operand of mode MODE.  WIN will be a C statement label elsewhere in
     the code.  It is not necessary to define this macro, but it might
     be useful for performance reasons.

     For example, on the i386, it is sometimes possible to use a single
     reload register instead of two by reloading a sum of two pseudo
     registers into a register.  On the other hand, for number of RISC
     processors offsets are limited so that often an intermediate
     address needs to be generated in order to address a stack slot.  By
     defining 'LEGITIMIZE_RELOAD_ADDRESS' appropriately, the
     intermediate addresses generated for adjacent some stack slots can
     be made identical, and thus be shared.

     _Note_: This macro should be used with caution.  It is necessary to
     know something of how reload works in order to effectively use
     this, and it is quite easy to produce macros that build in too much
     knowledge of reload internals.

     _Note_: This macro must be able to reload an address created by a
     previous invocation of this macro.  If it fails to handle such
     addresses then the compiler may generate incorrect code or abort.

     The macro definition should use 'push_reload' to indicate parts
     that need reloading; OPNUM, TYPE and IND_LEVELS are usually
     suitable to be passed unaltered to 'push_reload'.

     The code generated by this macro must not alter the substructure of
     X.  If it transforms X into a more legitimate form, it should
     assign X (which will always be a C variable) a new value.  This
     also applies to parts that you change indirectly by calling
     'push_reload'.

     The macro definition may use 'strict_memory_address_p' to test if
     the address has become legitimate.

     If you want to change only a part of X, one standard way of doing
     this is to use 'copy_rtx'.  Note, however, that it unshares only a
     single level of rtl.  Thus, if the part to be changed is not at the
     top level, you'll need to replace first the top level.  It is not
     necessary for this macro to come up with a legitimate address; but
     often a machine-dependent strategy can generate better code.

 -- Target Hook: bool TARGET_MODE_DEPENDENT_ADDRESS_P (const_rtx ADDR,
          addr_space_t ADDRSPACE)
     This hook returns 'true' if memory address ADDR in address space
     ADDRSPACE can have different meanings depending on the machine mode
     of the memory reference it is used for or if the address is valid
     for some modes but not others.

     Autoincrement and autodecrement addresses typically have
     mode-dependent effects because the amount of the increment or
     decrement is the size of the operand being addressed.  Some
     machines have other mode-dependent addresses.  Many RISC machines
     have no mode-dependent addresses.

     You may assume that ADDR is a valid address for the machine.

     The default version of this hook returns 'false'.

 -- Target Hook: bool TARGET_LEGITIMATE_CONSTANT_P (machine_mode MODE,
          rtx X)
     This hook returns true if X is a legitimate constant for a
     MODE-mode immediate operand on the target machine.  You can assume
     that X satisfies 'CONSTANT_P', so you need not check this.

     The default definition returns true.

 -- Target Hook: rtx TARGET_DELEGITIMIZE_ADDRESS (rtx X)
     This hook is used to undo the possibly obfuscating effects of the
     'LEGITIMIZE_ADDRESS' and 'LEGITIMIZE_RELOAD_ADDRESS' target macros.
     Some backend implementations of these macros wrap symbol references
     inside an 'UNSPEC' rtx to represent PIC or similar addressing
     modes.  This target hook allows GCC's optimizers to understand the
     semantics of these opaque 'UNSPEC's by converting them back into
     their original form.

 -- Target Hook: bool TARGET_CONST_NOT_OK_FOR_DEBUG_P (rtx X)
     This hook should return true if X should not be emitted into debug
     sections.

 -- Target Hook: bool TARGET_CANNOT_FORCE_CONST_MEM (machine_mode MODE,
          rtx X)
     This hook should return true if X is of a form that cannot (or
     should not) be spilled to the constant pool.  MODE is the mode of
     X.

     The default version of this hook returns false.

     The primary reason to define this hook is to prevent reload from
     deciding that a non-legitimate constant would be better reloaded
     from the constant pool instead of spilling and reloading a register
     holding the constant.  This restriction is often true of addresses
     of TLS symbols for various targets.

 -- Target Hook: bool TARGET_USE_BLOCKS_FOR_CONSTANT_P (machine_mode
          MODE, const_rtx X)
     This hook should return true if pool entries for constant X can be
     placed in an 'object_block' structure.  MODE is the mode of X.

     The default version returns false for all constants.

 -- Target Hook: bool TARGET_USE_BLOCKS_FOR_DECL_P (const_tree DECL)
     This hook should return true if pool entries for DECL should be
     placed in an 'object_block' structure.

     The default version returns true for all decls.

 -- Target Hook: tree TARGET_BUILTIN_RECIPROCAL (tree FNDECL)
     This hook should return the DECL of a function that implements the
     reciprocal of the machine-specific builtin function FNDECL, or
     'NULL_TREE' if such a function is not available.

 -- Target Hook: tree TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD (void)
     This hook should return the DECL of a function F that given an
     address ADDR as an argument returns a mask M that can be used to
     extract from two vectors the relevant data that resides in ADDR in
     case ADDR is not properly aligned.

     The autovectorizer, when vectorizing a load operation from an
     address ADDR that may be unaligned, will generate two vector loads
     from the two aligned addresses around ADDR.  It then generates a
     'REALIGN_LOAD' operation to extract the relevant data from the two
     loaded vectors.  The first two arguments to 'REALIGN_LOAD', V1 and
     V2, are the two vectors, each of size VS, and the third argument,
     OFF, defines how the data will be extracted from these two vectors:
     if OFF is 0, then the returned vector is V2; otherwise, the
     returned vector is composed from the last VS-OFF elements of V1
     concatenated to the first OFF elements of V2.

     If this hook is defined, the autovectorizer will generate a call to
     F (using the DECL tree that this hook returns) and will use the
     return value of F as the argument OFF to 'REALIGN_LOAD'.
     Therefore, the mask M returned by F should comply with the
     semantics expected by 'REALIGN_LOAD' described above.  If this hook
     is not defined, then ADDR will be used as the argument OFF to
     'REALIGN_LOAD', in which case the low log2(VS) - 1 bits of ADDR
     will be considered.

 -- Target Hook: int TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST (enum
          vect_cost_for_stmt TYPE_OF_COST, tree VECTYPE, int MISALIGN)
     Returns cost of different scalar or vector statements for
     vectorization cost model.  For vector memory operations the cost
     may depend on type (VECTYPE) and misalignment value (MISALIGN).

 -- Target Hook: poly_uint64 TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT
          (const_tree TYPE)
     This hook returns the preferred alignment in bits for accesses to
     vectors of type TYPE in vectorized code.  This might be less than
     or greater than the ABI-defined value returned by
     'TARGET_VECTOR_ALIGNMENT'.  It can be equal to the alignment of a
     single element, in which case the vectorizer will not try to
     optimize for alignment.

     The default hook returns 'TYPE_ALIGN (TYPE)', which is correct for
     most targets.

 -- Target Hook: bool TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE
          (const_tree TYPE, bool IS_PACKED)
     Return true if vector alignment is reachable (by peeling N
     iterations) for the given scalar type TYPE.  IS_PACKED is false if
     the scalar access using TYPE is known to be naturally aligned.

 -- Target Hook: bool TARGET_VECTORIZE_VEC_PERM_CONST (machine_mode
          MODE, rtx OUTPUT, rtx IN0, rtx IN1, const vec_perm_indices
          &SEL)
     This hook is used to test whether the target can permute up to two
     vectors of mode MODE using the permutation vector 'sel', and also
     to emit such a permutation.  In the former case IN0, IN1 and OUT
     are all null.  In the latter case IN0 and IN1 are the source
     vectors and OUT is the destination vector; all three are registers
     of mode MODE.  IN1 is the same as IN0 if SEL describes a
     permutation on one vector instead of two.

     Return true if the operation is possible, emitting instructions for
     it if rtxes are provided.

     If the hook returns false for a mode with multibyte elements, GCC
     will try the equivalent byte operation.  If that also fails, it
     will try forcing the selector into a register and using the
     VEC_PERMMODE instruction pattern.  There is no need for the hook to
     handle these two implementation approaches itself.

 -- Target Hook: tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION
          (unsigned CODE, tree VEC_TYPE_OUT, tree VEC_TYPE_IN)
     This hook should return the decl of a function that implements the
     vectorized variant of the function with the 'combined_fn' code CODE
     or 'NULL_TREE' if such a function is not available.  The return
     type of the vectorized function shall be of vector type
     VEC_TYPE_OUT and the argument types should be VEC_TYPE_IN.

 -- Target Hook: tree TARGET_VECTORIZE_BUILTIN_MD_VECTORIZED_FUNCTION
          (tree FNDECL, tree VEC_TYPE_OUT, tree VEC_TYPE_IN)
     This hook should return the decl of a function that implements the
     vectorized variant of target built-in function 'fndecl'.  The
     return type of the vectorized function shall be of vector type
     VEC_TYPE_OUT and the argument types should be VEC_TYPE_IN.

 -- Target Hook: bool TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT
          (machine_mode MODE, const_tree TYPE, int MISALIGNMENT, bool
          IS_PACKED)
     This hook should return true if the target supports misaligned
     vector store/load of a specific factor denoted in the MISALIGNMENT
     parameter.  The vector store/load should be of machine mode MODE
     and the elements in the vectors should be of type TYPE.  IS_PACKED
     parameter is true if the memory access is defined in a packed
     struct.

 -- Target Hook: machine_mode TARGET_VECTORIZE_PREFERRED_SIMD_MODE
          (scalar_mode MODE)
     This hook should return the preferred mode for vectorizing scalar
     mode MODE.  The default is equal to 'word_mode', because the
     vectorizer can do some transformations even in absence of
     specialized SIMD hardware.

 -- Target Hook: machine_mode TARGET_VECTORIZE_SPLIT_REDUCTION
          (machine_mode)
     This hook should return the preferred mode to split the final
     reduction step on MODE to.  The reduction is then carried out
     reducing upper against lower halves of vectors recursively until
     the specified mode is reached.  The default is MODE which means no
     splitting.

 -- Target Hook: unsigned int
          TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES (vector_modes
          *MODES, bool ALL)
     If using the mode returned by
     'TARGET_VECTORIZE_PREFERRED_SIMD_MODE' is not the only approach
     worth considering, this hook should add one mode to MODES for each
     useful alternative approach.  These modes are then passed to
     'TARGET_VECTORIZE_RELATED_MODE' to obtain the vector mode for a
     given element mode.

     The modes returned in MODES should use the smallest element mode
     possible for the vectorization approach that they represent,
     preferring integer modes over floating-poing modes in the event of
     a tie.  The first mode should be the
     'TARGET_VECTORIZE_PREFERRED_SIMD_MODE' for its element mode.

     If ALL is true, add suitable vector modes even when they are
     generally not expected to be worthwhile.

     The hook returns a bitmask of flags that control how the modes in
     MODES are used.  The flags are:
     'VECT_COMPARE_COSTS'
          Tells the loop vectorizer to try all the provided modes and
          pick the one with the lowest cost.  By default the vectorizer
          will choose the first mode that works.

     The hook does not need to do anything if the vector returned by
     'TARGET_VECTORIZE_PREFERRED_SIMD_MODE' is the only one relevant for
     autovectorization.  The default implementation adds no modes and
     returns 0.

 -- Target Hook: opt_machine_mode TARGET_VECTORIZE_RELATED_MODE
          (machine_mode VECTOR_MODE, scalar_mode ELEMENT_MODE,
          poly_uint64 NUNITS)
     If a piece of code is using vector mode VECTOR_MODE and also wants
     to operate on elements of mode ELEMENT_MODE, return the vector mode
     it should use for those elements.  If NUNITS is nonzero, ensure
     that the mode has exactly NUNITS elements, otherwise pick whichever
     vector size pairs the most naturally with VECTOR_MODE.  Return an
     empty 'opt_machine_mode' if there is no supported vector mode with
     the required properties.

     There is no prescribed way of handling the case in which NUNITS is
     zero.  One common choice is to pick a vector mode with the same
     size as VECTOR_MODE; this is the natural choice if the target has a
     fixed vector size.  Another option is to choose a vector mode with
     the same number of elements as VECTOR_MODE; this is the natural
     choice if the target has a fixed number of elements.
     Alternatively, the hook might choose a middle ground, such as
     trying to keep the number of elements as similar as possible while
     applying maximum and minimum vector sizes.

     The default implementation uses 'mode_for_vector' to find the
     requested mode, returning a mode with the same size as VECTOR_MODE
     when NUNITS is zero.  This is the correct behavior for most
     targets.

 -- Target Hook: opt_machine_mode TARGET_VECTORIZE_GET_MASK_MODE
          (machine_mode MODE)
     Return the mode to use for a vector mask that holds one boolean
     result for each element of vector mode MODE.  The returned mask
     mode can be a vector of integers (class 'MODE_VECTOR_INT'), a
     vector of booleans (class 'MODE_VECTOR_BOOL') or a scalar integer
     (class 'MODE_INT').  Return an empty 'opt_machine_mode' if no such
     mask mode exists.

     The default implementation returns a 'MODE_VECTOR_INT' with the
     same size and number of elements as MODE, if such a mode exists.

 -- Target Hook: bool TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE (unsigned
          IFN)
     This hook returns true if masked internal function IFN (really of
     type 'internal_fn') should be considered expensive when the mask is
     all zeros.  GCC can then try to branch around the instruction
     instead.

 -- Target Hook: void * TARGET_VECTORIZE_INIT_COST (class loop
          *LOOP_INFO)
     This hook should initialize target-specific data structures in
     preparation for modeling the costs of vectorizing a loop or basic
     block.  The default allocates three unsigned integers for
     accumulating costs for the prologue, body, and epilogue of the loop
     or basic block.  If LOOP_INFO is non-NULL, it identifies the loop
     being vectorized; otherwise a single block is being vectorized.

 -- Target Hook: unsigned TARGET_VECTORIZE_ADD_STMT_COST (void *DATA,
          int COUNT, enum vect_cost_for_stmt KIND, class _stmt_vec_info
          *STMT_INFO, int MISALIGN, enum vect_cost_model_location WHERE)
     This hook should update the target-specific DATA in response to
     adding COUNT copies of the given KIND of statement to a loop or
     basic block.  The default adds the builtin vectorizer cost for the
     copies of the statement to the accumulator specified by WHERE, (the
     prologue, body, or epilogue) and returns the amount added.  The
     return value should be viewed as a tentative cost that may later be
     revised.

 -- Target Hook: void TARGET_VECTORIZE_FINISH_COST (void *DATA, unsigned
          *PROLOGUE_COST, unsigned *BODY_COST, unsigned *EPILOGUE_COST)
     This hook should complete calculations of the cost of vectorizing a
     loop or basic block based on DATA, and return the prologue, body,
     and epilogue costs as unsigned integers.  The default returns the
     value of the three accumulators.

 -- Target Hook: void TARGET_VECTORIZE_DESTROY_COST_DATA (void *DATA)
     This hook should release DATA and any related data structures
     allocated by TARGET_VECTORIZE_INIT_COST. The default releases the
     accumulator.

 -- Target Hook: tree TARGET_VECTORIZE_BUILTIN_GATHER (const_tree
          MEM_VECTYPE, const_tree INDEX_TYPE, int SCALE)
     Target builtin that implements vector gather operation.
     MEM_VECTYPE is the vector type of the load and INDEX_TYPE is scalar
     type of the index, scaled by SCALE.  The default is 'NULL_TREE'
     which means to not vectorize gather loads.

 -- Target Hook: tree TARGET_VECTORIZE_BUILTIN_SCATTER (const_tree
          VECTYPE, const_tree INDEX_TYPE, int SCALE)
     Target builtin that implements vector scatter operation.  VECTYPE
     is the vector type of the store and INDEX_TYPE is scalar type of
     the index, scaled by SCALE.  The default is 'NULL_TREE' which means
     to not vectorize scatter stores.

 -- Target Hook: int TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN
          (struct cgraph_node *, struct cgraph_simd_clone *, TREE, INT)
     This hook should set VECSIZE_MANGLE, VECSIZE_INT, VECSIZE_FLOAT
     fields in SIMD_CLONE structure pointed by CLONE_INFO argument and
     also SIMDLEN field if it was previously 0.  The hook should return
     0 if SIMD clones shouldn't be emitted, or number of VECSIZE_MANGLE
     variants that should be emitted.

 -- Target Hook: void TARGET_SIMD_CLONE_ADJUST (struct cgraph_node *)
     This hook should add implicit 'attribute(target("..."))' attribute
     to SIMD clone NODE if needed.

 -- Target Hook: int TARGET_SIMD_CLONE_USABLE (struct cgraph_node *)
     This hook should return -1 if SIMD clone NODE shouldn't be used in
     vectorized loops in current function, or non-negative number if it
     is usable.  In that case, the smaller the number is, the more
     desirable it is to use it.

 -- Target Hook: int TARGET_SIMT_VF (void)
     Return number of threads in SIMT thread group on the target.

 -- Target Hook: int TARGET_OMP_DEVICE_KIND_ARCH_ISA (enum
          omp_device_kind_arch_isa TRAIT, const char *NAME)
     Return 1 if TRAIT NAME is present in the OpenMP context's device
     trait set, return 0 if not present in any OpenMP context in the
     whole translation unit, or -1 if not present in the current OpenMP
     context but might be present in another OpenMP context in the same
     TU.

 -- Target Hook: bool TARGET_GOACC_VALIDATE_DIMS (tree DECL, int *DIMS,
          int FN_LEVEL, unsigned USED)
     This hook should check the launch dimensions provided for an
     OpenACC compute region, or routine.  Defaulted values are
     represented as -1 and non-constant values as 0.  The FN_LEVEL is
     negative for the function corresponding to the compute region.  For
     a routine it is the outermost level at which partitioned execution
     may be spawned.  The hook should verify non-default values.  If
     DECL is NULL, global defaults are being validated and unspecified
     defaults should be filled in.  Diagnostics should be issued as
     appropriate.  Return true, if changes have been made.  You must
     override this hook to provide dimensions larger than 1.

 -- Target Hook: int TARGET_GOACC_DIM_LIMIT (int AXIS)
     This hook should return the maximum size of a particular dimension,
     or zero if unbounded.

 -- Target Hook: bool TARGET_GOACC_FORK_JOIN (gcall *CALL, const int
          *DIMS, bool IS_FORK)
     This hook can be used to convert IFN_GOACC_FORK and IFN_GOACC_JOIN
     function calls to target-specific gimple, or indicate whether they
     should be retained.  It is executed during the oacc_device_lower
     pass.  It should return true, if the call should be retained.  It
     should return false, if it is to be deleted (either because
     target-specific gimple has been inserted before it, or there is no
     need for it).  The default hook returns false, if there are no RTL
     expanders for them.

 -- Target Hook: void TARGET_GOACC_REDUCTION (gcall *CALL)
     This hook is used by the oacc_transform pass to expand calls to the
     GOACC_REDUCTION internal function, into a sequence of gimple
     instructions.  CALL is gimple statement containing the call to the
     function.  This hook removes statement CALL after the expanded
     sequence has been inserted.  This hook is also responsible for
     allocating any storage for reductions when necessary.

 -- Target Hook: tree TARGET_PREFERRED_ELSE_VALUE (unsigned IFN, tree
          TYPE, unsigned NOPS, tree *OPS)
     This hook returns the target's preferred final argument for a call
     to conditional internal function IFN (really of type
     'internal_fn').  TYPE specifies the return type of the function and
     OPS are the operands to the conditional operation, of which there
     are NOPS.

     For example, if IFN is 'IFN_COND_ADD', the hook returns a value of
     type TYPE that should be used when 'OPS[0]' and 'OPS[1]' are
     conditionally added together.

     This hook is only relevant if the target supports conditional
     patterns like 'cond_addM'.  The default implementation returns a
     zero constant of type TYPE.

==============================================================================
File: gccint.info,  Node: |Anchored_Addresses|,  Next: |Condition_Code|,  Prev: |Addressing_Modes|,  Up: |Target_Macros|
==============================================================================

                                                            *Anchored_Addresses*

18.14 Anchored Addresses
==========--------------

GCC usually addresses every static object as a separate entity.  For
example, if we have:

     static int a, b, c;
     int foo (void) { return a + b + c; }

 the code for 'foo' will usually calculate three separate symbolic
addresses: those of 'a', 'b' and 'c'.  On some targets, it would be
better to calculate just one symbolic address and access the three
variables relative to it.  The equivalent pseudocode would be something
like:

     int foo (void)
     {
       register int *xr = &x;
       return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];
     }

 (which isn't valid C). We refer to shared addresses like 'x' as
"section anchors".  Their use is controlled by '-fsection-anchors'.

 The hooks below describe the target properties that GCC needs to know
in order to make effective use of section anchors.  It won't use section
anchors at all unless either 'TARGET_MIN_ANCHOR_OFFSET' or
'TARGET_MAX_ANCHOR_OFFSET' is set to a nonzero value.

 -- Target Hook: HOST_WIDE_INT TARGET_MIN_ANCHOR_OFFSET
     The minimum offset that should be applied to a section anchor.  On
     most targets, it should be the smallest offset that can be applied
     to a base register while still giving a legitimate address for
     every mode.  The default value is 0.

 -- Target Hook: HOST_WIDE_INT TARGET_MAX_ANCHOR_OFFSET
     Like 'TARGET_MIN_ANCHOR_OFFSET', but the maximum (inclusive) offset
     that should be applied to section anchors.  The default value is 0.

 -- Target Hook: void TARGET_ASM_OUTPUT_ANCHOR (rtx X)
     Write the assembly code to define section anchor X, which is a
     'SYMBOL_REF' for which 'SYMBOL_REF_ANCHOR_P (X)' is true.  The hook
     is called with the assembly output position set to the beginning of
     'SYMBOL_REF_BLOCK (X)'.

     If 'ASM_OUTPUT_DEF' is available, the hook's default definition
     uses it to define the symbol as '. + SYMBOL_REF_BLOCK_OFFSET (X)'.
     If 'ASM_OUTPUT_DEF' is not available, the hook's default definition
     is 'NULL', which disables the use of section anchors altogether.

 -- Target Hook: bool TARGET_USE_ANCHORS_FOR_SYMBOL_P (const_rtx X)
     Return true if GCC should attempt to use anchors to access
     'SYMBOL_REF' X.  You can assume 'SYMBOL_REF_HAS_BLOCK_INFO_P (X)'
     and '!SYMBOL_REF_ANCHOR_P (X)'.

     The default version is correct for most targets, but you might need
     to intercept this hook to handle things like target-specific
     attributes or target-specific sections.

==============================================================================
File: gccint.info,  Node: |Condition_Code|,  Next: |Costs|,  Prev: |Anchored_Addresses|,  Up: |Target_Macros|
==============================================================================

                                                                *Condition_Code*

18.15 Condition Code Status
==========-----------------

The macros in this section can be split in two families, according to
the two ways of representing condition codes in GCC.

 The first representation is the so called '(cc0)' representation (*note
Jump Patterns::), where all instructions can have an implicit clobber of
the condition codes.  The second is the condition code register
representation, which provides better schedulability for architectures
that do have a condition code register, but on which most instructions
do not affect it.  The latter category includes most RISC machines.

 The implicit clobbering poses a strong restriction on the placement of
the definition and use of the condition code.  In the past the
definition and use were always adjacent.  However, recent changes to
support trapping arithmatic may result in the definition and user being
in different blocks.  Thus, there may be a 'NOTE_INSN_BASIC_BLOCK'
between them.  Additionally, the definition may be the source of
exception handling edges.

 These restrictions can prevent important optimizations on some
machines.  For example, on the IBM RS/6000, there is a delay for taken
branches unless the condition code register is set three instructions
earlier than the conditional branch.  The instruction scheduler cannot
perform this optimization if it is not permitted to separate the
definition and use of the condition code register.

 For this reason, it is possible and suggested to use a register to
represent the condition code for new ports.  If there is a specific
condition code register in the machine, use a hard register.  If the
condition code or comparison result can be placed in any general
register, or if there are multiple condition registers, use a pseudo
register.  Registers used to store the condition code value will usually
have a mode that is in class 'MODE_CC'.

 Alternatively, you can use 'BImode' if the comparison operator is
specified already in the compare instruction.  In this case, you are not
interested in most macros in this section.

MENU

* |CC0_Condition_Codes|::      Old style representation of condition codes.
* |MODE_CC_Condition_Codes|::  Modern representation of condition codes.

==============================================================================
File: gccint.info,  Node: |CC0_Condition_Codes|,  Next: |MODE_CC_Condition_Codes|,  Up: |Condition_Code|
==============================================================================

                                                           *CC0_Condition_Codes*

18.15.1 Representation of condition codes using '(cc0)'
-------------------------------------------------------

The file 'conditions.h' defines a variable 'cc_status' to describe how
the condition code was computed (in case the interpretation of the
condition code depends on the instruction that it was set by).  This
variable contains the RTL expressions on which the condition code is
currently based, and several standard flags.

 Sometimes additional machine-specific flags must be defined in the
machine description header file.  It can also add additional
machine-specific information by defining 'CC_STATUS_MDEP'.

 -- Macro: CC_STATUS_MDEP
     C code for a data type which is used for declaring the 'mdep'
     component of 'cc_status'.  It defaults to 'int'.

     This macro is not used on machines that do not use 'cc0'.

 -- Macro: CC_STATUS_MDEP_INIT
     A C expression to initialize the 'mdep' field to "empty".  The
     default definition does nothing, since most machines don't use the
     field anyway.  If you want to use the field, you should probably
     define this macro to initialize it.

     This macro is not used on machines that do not use 'cc0'.

 -- Macro: NOTICE_UPDATE_CC (EXP, INSN)
     A C compound statement to set the components of 'cc_status'
     appropriately for an insn INSN whose body is EXP.  It is this
     macro's responsibility to recognize insns that set the condition
     code as a byproduct of other activity as well as those that
     explicitly set '(cc0)'.

     This macro is not used on machines that do not use 'cc0'.

     If there are insns that do not set the condition code but do alter
     other machine registers, this macro must check to see whether they
     invalidate the expressions that the condition code is recorded as
     reflecting.  For example, on the 68000, insns that store in address
     registers do not set the condition code, which means that usually
     'NOTICE_UPDATE_CC' can leave 'cc_status' unaltered for such insns.
     But suppose that the previous insn set the condition code based on
     location 'a4@(102)' and the current insn stores a new value in
     'a4'.  Although the condition code is not changed by this, it will
     no longer be true that it reflects the contents of 'a4@(102)'.
     Therefore, 'NOTICE_UPDATE_CC' must alter 'cc_status' in this case
     to say that nothing is known about the condition code value.

     The definition of 'NOTICE_UPDATE_CC' must be prepared to deal with
     the results of peephole optimization: insns whose patterns are
     'parallel' RTXs containing various 'reg', 'mem' or constants which
     are just the operands.  The RTL structure of these insns is not
     sufficient to indicate what the insns actually do.  What
     'NOTICE_UPDATE_CC' should do when it sees one is just to run
     'CC_STATUS_INIT'.

     A possible definition of 'NOTICE_UPDATE_CC' is to call a function
     that looks at an attribute (*note Insn Attributes::) named, for
     example, 'cc'.  This avoids having detailed information about
     patterns in two places, the 'md' file and in 'NOTICE_UPDATE_CC'.

==============================================================================
File: gccint.info,  Node: |MODE_CC_Condition_Codes|,  Prev: |CC0_Condition_Codes|,  Up: |Condition_Code|
==============================================================================

                                                       *MODE_CC_Condition_Codes*

18.15.2 Representation of condition codes using registers
---------------------------------------------------------

 -- Macro: SELECT_CC_MODE (OP, X, Y)
     On many machines, the condition code may be produced by other
     instructions than compares, for example the branch can use directly
     the condition code set by a subtract instruction.  However, on some
     machines when the condition code is set this way some bits (such as
     the overflow bit) are not set in the same way as a test
     instruction, so that a different branch instruction must be used
     for some conditional branches.  When this happens, use the machine
     mode of the condition code register to record different formats of
     the condition code register.  Modes can also be used to record
     which compare instruction (e.g. a signed or an unsigned comparison)
     produced the condition codes.

     If other modes than 'CCmode' are required, add them to
     'MACHINE-modes.def' and define 'SELECT_CC_MODE' to choose a mode
     given an operand of a compare.  This is needed because the modes
     have to be chosen not only during RTL generation but also, for
     example, by instruction combination.  The result of
     'SELECT_CC_MODE' should be consistent with the mode used in the
     patterns; for example to support the case of the add on the SPARC
     discussed above, we have the pattern

          (define_insn ""
            [(set (reg:CCNZ 0)
                  (compare:CCNZ
                    (plus:SI (match_operand:SI 0 "register_operand" "%r")
                             (match_operand:SI 1 "arith_operand" "rI"))
                    (const_int 0)))]
            ""
            "...")

     together with a 'SELECT_CC_MODE' that returns 'CCNZmode' for
     comparisons whose argument is a 'plus':

          #define SELECT_CC_MODE(OP,X,Y) \
            (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT           \
             ? ((OP == LT || OP == LE || OP == GT || OP == GE)     \
                ? CCFPEmode : CCFPmode)                            \
             : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS     \
                 || GET_CODE (X) == NEG || GET_CODE (x) == ASHIFT) \
                ? CCNZmode : CCmode))

     Another reason to use modes is to retain information on which
     operands were used by the comparison; see 'REVERSIBLE_CC_MODE'
     later in this section.

     You should define this macro if and only if you define extra CC
     modes in 'MACHINE-modes.def'.

 -- Target Hook: void TARGET_CANONICALIZE_COMPARISON (int *CODE, rtx
          *OP0, rtx *OP1, bool OP0_PRESERVE_VALUE)
     On some machines not all possible comparisons are defined, but you
     can convert an invalid comparison into a valid one.  For example,
     the Alpha does not have a 'GT' comparison, but you can use an 'LT'
     comparison instead and swap the order of the operands.

     On such machines, implement this hook to do any required
     conversions.  CODE is the initial comparison code and OP0 and OP1
     are the left and right operands of the comparison, respectively.
     If OP0_PRESERVE_VALUE is 'true' the implementation is not allowed
     to change the value of OP0 since the value might be used in RTXs
     which aren't comparisons.  E.g.  the implementation is not allowed
     to swap operands in that case.

     GCC will not assume that the comparison resulting from this macro
     is valid but will see if the resulting insn matches a pattern in
     the 'md' file.

     You need not to implement this hook if it would never change the
     comparison code or operands.

 -- Macro: REVERSIBLE_CC_MODE (MODE)
     A C expression whose value is one if it is always safe to reverse a
     comparison whose mode is MODE.  If 'SELECT_CC_MODE' can ever return
     MODE for a floating-point inequality comparison, then
     'REVERSIBLE_CC_MODE (MODE)' must be zero.

     You need not define this macro if it would always returns zero or
     if the floating-point format is anything other than
     'IEEE_FLOAT_FORMAT'.  For example, here is the definition used on
     the SPARC, where floating-point inequality comparisons are given
     either 'CCFPEmode' or 'CCFPmode':

          #define REVERSIBLE_CC_MODE(MODE) \
             ((MODE) != CCFPEmode && (MODE) != CCFPmode)

 -- Macro: REVERSE_CONDITION (CODE, MODE)
     A C expression whose value is reversed condition code of the CODE
     for comparison done in CC_MODE MODE.  The macro is used only in
     case 'REVERSIBLE_CC_MODE (MODE)' is nonzero.  Define this macro in
     case machine has some non-standard way how to reverse certain
     conditionals.  For instance in case all floating point conditions
     are non-trapping, compiler may freely convert unordered compares to
     ordered ones.  Then definition may look like:

          #define REVERSE_CONDITION(CODE, MODE) \
             ((MODE) != CCFPmode ? reverse_condition (CODE) \
              : reverse_condition_maybe_unordered (CODE))

 -- Target Hook: bool TARGET_FIXED_CONDITION_CODE_REGS (unsigned int
          *P1, unsigned int *P2)
     On targets which do not use '(cc0)', and which use a hard register
     rather than a pseudo-register to hold condition codes, the regular
     CSE passes are often not able to identify cases in which the hard
     register is set to a common value.  Use this hook to enable a small
     pass which optimizes such cases.  This hook should return true to
     enable this pass, and it should set the integers to which its
     arguments point to the hard register numbers used for condition
     codes.  When there is only one such register, as is true on most
     systems, the integer pointed to by P2 should be set to
     'INVALID_REGNUM'.

     The default version of this hook returns false.

 -- Target Hook: machine_mode TARGET_CC_MODES_COMPATIBLE (machine_mode
          M1, machine_mode M2)
     On targets which use multiple condition code modes in class
     'MODE_CC', it is sometimes the case that a comparison can be
     validly done in more than one mode.  On such a system, define this
     target hook to take two mode arguments and to return a mode in
     which both comparisons may be validly done.  If there is no such
     mode, return 'VOIDmode'.

     The default version of this hook checks whether the modes are the
     same.  If they are, it returns that mode.  If they are different,
     it returns 'VOIDmode'.

 -- Target Hook: unsigned int TARGET_FLAGS_REGNUM
     If the target has a dedicated flags register, and it needs to use
     the post-reload comparison elimination pass, or the delay slot
     filler pass, then this value should be set appropriately.

==============================================================================
File: gccint.info,  Node: |Costs|,  Next: |Scheduling|,  Prev: |Condition_Code|,  Up: |Target_Macros|
==============================================================================

                                                                         *Costs*

18.16 Describing Relative Costs of Operations
==========-----------------------------------

These macros let you describe the relative speed of various operations
on the target machine.

 -- Macro: REGISTER_MOVE_COST (MODE, FROM, TO)
     A C expression for the cost of moving data of mode MODE from a
     register in class FROM to one in class TO.  The classes are
     expressed using the enumeration values such as 'GENERAL_REGS'.  A
     value of 2 is the default; other values are interpreted relative to
     that.

     It is not required that the cost always equal 2 when FROM is the
     same as TO; on some machines it is expensive to move between
     registers if they are not general registers.

     If reload sees an insn consisting of a single 'set' between two
     hard registers, and if 'REGISTER_MOVE_COST' applied to their
     classes returns a value of 2, reload does not check to ensure that
     the constraints of the insn are met.  Setting a cost of other than
     2 will allow reload to verify that the constraints are met.  You
     should do this if the 'movM' pattern's constraints do not allow
     such copying.

     These macros are obsolete, new ports should use the target hook
     'TARGET_REGISTER_MOVE_COST' instead.

 -- Target Hook: int TARGET_REGISTER_MOVE_COST (machine_mode MODE,
          reg_class_t FROM, reg_class_t TO)
     This target hook should return the cost of moving data of mode MODE
     from a register in class FROM to one in class TO.  The classes are
     expressed using the enumeration values such as 'GENERAL_REGS'.  A
     value of 2 is the default; other values are interpreted relative to
     that.

     It is not required that the cost always equal 2 when FROM is the
     same as TO; on some machines it is expensive to move between
     registers if they are not general registers.

     If reload sees an insn consisting of a single 'set' between two
     hard registers, and if 'TARGET_REGISTER_MOVE_COST' applied to their
     classes returns a value of 2, reload does not check to ensure that
     the constraints of the insn are met.  Setting a cost of other than
     2 will allow reload to verify that the constraints are met.  You
     should do this if the 'movM' pattern's constraints do not allow
     such copying.

     The default version of this function returns 2.

 -- Macro: MEMORY_MOVE_COST (MODE, CLASS, IN)
     A C expression for the cost of moving data of mode MODE between a
     register of class CLASS and memory; IN is zero if the value is to
     be written to memory, nonzero if it is to be read in.  This cost is
     relative to those in 'REGISTER_MOVE_COST'.  If moving between
     registers and memory is more expensive than between two registers,
     you should define this macro to express the relative cost.

     If you do not define this macro, GCC uses a default cost of 4 plus
     the cost of copying via a secondary reload register, if one is
     needed.  If your machine requires a secondary reload register to
     copy between memory and a register of CLASS but the reload
     mechanism is more complex than copying via an intermediate, define
     this macro to reflect the actual cost of the move.

     GCC defines the function 'memory_move_secondary_cost' if secondary
     reloads are needed.  It computes the costs due to copying via a
     secondary register.  If your machine copies from memory using a
     secondary register in the conventional way but the default base
     value of 4 is not correct for your machine, define this macro to
     add some other value to the result of that function.  The arguments
     to that function are the same as to this macro.

     These macros are obsolete, new ports should use the target hook
     'TARGET_MEMORY_MOVE_COST' instead.

 -- Target Hook: int TARGET_MEMORY_MOVE_COST (machine_mode MODE,
          reg_class_t RCLASS, bool IN)
     This target hook should return the cost of moving data of mode MODE
     between a register of class RCLASS and memory; IN is 'false' if the
     value is to be written to memory, 'true' if it is to be read in.
     This cost is relative to those in 'TARGET_REGISTER_MOVE_COST'.  If
     moving between registers and memory is more expensive than between
     two registers, you should add this target hook to express the
     relative cost.

     If you do not add this target hook, GCC uses a default cost of 4
     plus the cost of copying via a secondary reload register, if one is
     needed.  If your machine requires a secondary reload register to
     copy between memory and a register of RCLASS but the reload
     mechanism is more complex than copying via an intermediate, use
     this target hook to reflect the actual cost of the move.

     GCC defines the function 'memory_move_secondary_cost' if secondary
     reloads are needed.  It computes the costs due to copying via a
     secondary register.  If your machine copies from memory using a
     secondary register in the conventional way but the default base
     value of 4 is not correct for your machine, use this target hook to
     add some other value to the result of that function.  The arguments
     to that function are the same as to this target hook.

 -- Macro: BRANCH_COST (SPEED_P, PREDICTABLE_P)
     A C expression for the cost of a branch instruction.  A value of 1
     is the default; other values are interpreted relative to that.
     Parameter SPEED_P is true when the branch in question should be
     optimized for speed.  When it is false, 'BRANCH_COST' should return
     a value optimal for code size rather than performance.
     PREDICTABLE_P is true for well-predicted branches.  On many
     architectures the 'BRANCH_COST' can be reduced then.

 Here are additional macros which do not specify precise relative costs,
but only that certain actions are more expensive than GCC would
ordinarily expect.

 -- Macro: SLOW_BYTE_ACCESS
     Define this macro as a C expression which is nonzero if accessing
     less than a word of memory (i.e. a 'char' or a 'short') is no
     faster than accessing a word of memory, i.e., if such access
     require more than one instruction or if there is no difference in
     cost between byte and (aligned) word loads.

     When this macro is not defined, the compiler will access a field by
     finding the smallest containing object; when it is defined, a
     fullword load will be used if alignment permits.  Unless bytes
     accesses are faster than word accesses, using word accesses is
     preferable since it may eliminate subsequent memory access if
     subsequent accesses occur to other fields in the same word of the
     structure, but to different bytes.

 -- Target Hook: bool TARGET_SLOW_UNALIGNED_ACCESS (machine_mode MODE,
          unsigned int ALIGN)
     This hook returns true if memory accesses described by the MODE and
     ALIGNMENT parameters have a cost many times greater than aligned
     accesses, for example if they are emulated in a trap handler.  This
     hook is invoked only for unaligned accesses, i.e. when 'ALIGNMENT <
     GET_MODE_ALIGNMENT (MODE)'.

     When this hook returns true, the compiler will act as if
     'STRICT_ALIGNMENT' were true when generating code for block moves.
     This can cause significantly more instructions to be produced.
     Therefore, do not make this hook return true if unaligned accesses
     only add a cycle or two to the time for a memory access.

     The hook must return true whenever 'STRICT_ALIGNMENT' is true.  The
     default implementation returns 'STRICT_ALIGNMENT'.

 -- Macro: MOVE_RATIO (SPEED)
     The threshold of number of scalar memory-to-memory move insns,
     _below_ which a sequence of insns should be generated instead of a
     string move insn or a library call.  Increasing the value will
     always make code faster, but eventually incurs high cost in
     increased code size.

     Note that on machines where the corresponding move insn is a
     'define_expand' that emits a sequence of insns, this macro counts
     the number of such sequences.

     The parameter SPEED is true if the code is currently being
     optimized for speed rather than size.

     If you don't define this, a reasonable default is used.

 -- Target Hook: bool TARGET_USE_BY_PIECES_INFRASTRUCTURE_P (unsigned
          HOST_WIDE_INT SIZE, unsigned int ALIGNMENT, enum
          by_pieces_operation OP, bool SPEED_P)
     GCC will attempt several strategies when asked to copy between two
     areas of memory, or to set, clear or store to memory, for example
     when copying a 'struct'.  The 'by_pieces' infrastructure implements
     such memory operations as a sequence of load, store or move insns.
     Alternate strategies are to expand the 'cpymem' or 'setmem' optabs,
     to emit a library call, or to emit unit-by-unit, loop-based
     operations.

     This target hook should return true if, for a memory operation with
     a given SIZE and ALIGNMENT, using the 'by_pieces' infrastructure is
     expected to result in better code generation.  Both SIZE and
     ALIGNMENT are measured in terms of storage units.

     The parameter OP is one of: 'CLEAR_BY_PIECES', 'MOVE_BY_PIECES',
     'SET_BY_PIECES', 'STORE_BY_PIECES' or 'COMPARE_BY_PIECES'.  These
     describe the type of memory operation under consideration.

     The parameter SPEED_P is true if the code is currently being
     optimized for speed rather than size.

     Returning true for higher values of SIZE can improve code
     generation for speed if the target does not provide an
     implementation of the 'cpymem' or 'setmem' standard names, if the
     'cpymem' or 'setmem' implementation would be more expensive than a
     sequence of insns, or if the overhead of a library call would
     dominate that of the body of the memory operation.

     Returning true for higher values of 'size' may also cause an
     increase in code size, for example where the number of insns
     emitted to perform a move would be greater than that of a library
     call.

 -- Target Hook: int TARGET_COMPARE_BY_PIECES_BRANCH_RATIO (machine_mode
          MODE)
     When expanding a block comparison in MODE, gcc can try to reduce
     the number of branches at the expense of more memory operations.
     This hook allows the target to override the default choice.  It
     should return the factor by which branches should be reduced over
     the plain expansion with one comparison per MODE-sized piece.  A
     port can also prevent a particular mode from being used for block
     comparisons by returning a negative number from this hook.

 -- Macro: MOVE_MAX_PIECES
     A C expression used by 'move_by_pieces' to determine the largest
     unit a load or store used to copy memory is.  Defaults to
     'MOVE_MAX'.

 -- Macro: STORE_MAX_PIECES
     A C expression used by 'store_by_pieces' to determine the largest
     unit a store used to memory is.  Defaults to 'MOVE_MAX_PIECES', or
     two times the size of 'HOST_WIDE_INT', whichever is smaller.

 -- Macro: COMPARE_MAX_PIECES
     A C expression used by 'compare_by_pieces' to determine the largest
     unit a load or store used to compare memory is.  Defaults to
     'MOVE_MAX_PIECES'.

 -- Macro: CLEAR_RATIO (SPEED)
     The threshold of number of scalar move insns, _below_ which a
     sequence of insns should be generated to clear memory instead of a
     string clear insn or a library call.  Increasing the value will
     always make code faster, but eventually incurs high cost in
     increased code size.

     The parameter SPEED is true if the code is currently being
     optimized for speed rather than size.

     If you don't define this, a reasonable default is used.

 -- Macro: SET_RATIO (SPEED)
     The threshold of number of scalar move insns, _below_ which a
     sequence of insns should be generated to set memory to a constant
     value, instead of a block set insn or a library call.  Increasing
     the value will always make code faster, but eventually incurs high
     cost in increased code size.

     The parameter SPEED is true if the code is currently being
     optimized for speed rather than size.

     If you don't define this, it defaults to the value of 'MOVE_RATIO'.

 -- Macro: USE_LOAD_POST_INCREMENT (MODE)
     A C expression used to determine whether a load postincrement is a
     good thing to use for a given mode.  Defaults to the value of
     'HAVE_POST_INCREMENT'.

 -- Macro: USE_LOAD_POST_DECREMENT (MODE)
     A C expression used to determine whether a load postdecrement is a
     good thing to use for a given mode.  Defaults to the value of
     'HAVE_POST_DECREMENT'.

 -- Macro: USE_LOAD_PRE_INCREMENT (MODE)
     A C expression used to determine whether a load preincrement is a
     good thing to use for a given mode.  Defaults to the value of
     'HAVE_PRE_INCREMENT'.

 -- Macro: USE_LOAD_PRE_DECREMENT (MODE)
     A C expression used to determine whether a load predecrement is a
     good thing to use for a given mode.  Defaults to the value of
     'HAVE_PRE_DECREMENT'.

 -- Macro: USE_STORE_POST_INCREMENT (MODE)
     A C expression used to determine whether a store postincrement is a
     good thing to use for a given mode.  Defaults to the value of
     'HAVE_POST_INCREMENT'.

 -- Macro: USE_STORE_POST_DECREMENT (MODE)
     A C expression used to determine whether a store postdecrement is a
     good thing to use for a given mode.  Defaults to the value of
     'HAVE_POST_DECREMENT'.

 -- Macro: USE_STORE_PRE_INCREMENT (MODE)
     This macro is used to determine whether a store preincrement is a
     good thing to use for a given mode.  Defaults to the value of
     'HAVE_PRE_INCREMENT'.

 -- Macro: USE_STORE_PRE_DECREMENT (MODE)
     This macro is used to determine whether a store predecrement is a
     good thing to use for a given mode.  Defaults to the value of
     'HAVE_PRE_DECREMENT'.

 -- Macro: NO_FUNCTION_CSE
     Define this macro to be true if it is as good or better to call a
     constant function address than to call an address kept in a
     register.

 -- Macro: LOGICAL_OP_NON_SHORT_CIRCUIT
     Define this macro if a non-short-circuit operation produced by
     'fold_range_test ()' is optimal.  This macro defaults to true if
     'BRANCH_COST' is greater than or equal to the value 2.

 -- Target Hook: bool TARGET_OPTAB_SUPPORTED_P (int OP, machine_mode
          MODE1, machine_mode MODE2, optimization_type OPT_TYPE)
     Return true if the optimizers should use optab OP with modes MODE1
     and MODE2 for optimization type OPT_TYPE.  The optab is known to
     have an associated '.md' instruction whose C condition is true.
     MODE2 is only meaningful for conversion optabs; for direct optabs
     it is a copy of MODE1.

     For example, when called with OP equal to 'rint_optab' and MODE1
     equal to 'DFmode', the hook should say whether the optimizers
     should use optab 'rintdf2'.

     The default hook returns true for all inputs.

 -- Target Hook: bool TARGET_RTX_COSTS (rtx X, machine_mode MODE, int
          OUTER_CODE, int OPNO, int *TOTAL, bool SPEED)
     This target hook describes the relative costs of RTL expressions.

     The cost may depend on the precise form of the expression, which is
     available for examination in X, and the fact that X appears as
     operand OPNO of an expression with rtx code OUTER_CODE.  That is,
     the hook can assume that there is some rtx Y such that 'GET_CODE
     (Y) == OUTER_CODE' and such that either (a) 'XEXP (Y, OPNO) == X'
     or (b) 'XVEC (Y, OPNO)' contains X.

     MODE is X's machine mode, or for cases like 'const_int' that do not
     have a mode, the mode in which X is used.

     In implementing this hook, you can use the construct 'COSTS_N_INSNS
     (N)' to specify a cost equal to N fast instructions.

     On entry to the hook, '*TOTAL' contains a default estimate for the
     cost of the expression.  The hook should modify this value as
     necessary.  Traditionally, the default costs are 'COSTS_N_INSNS
     (5)' for multiplications, 'COSTS_N_INSNS (7)' for division and
     modulus operations, and 'COSTS_N_INSNS (1)' for all other
     operations.

     When optimizing for code size, i.e. when 'speed' is false, this
     target hook should be used to estimate the relative size cost of an
     expression, again relative to 'COSTS_N_INSNS'.

     The hook returns true when all subexpressions of X have been
     processed, and false when 'rtx_cost' should recurse.

 -- Target Hook: int TARGET_ADDRESS_COST (rtx ADDRESS, machine_mode
          MODE, addr_space_t AS, bool SPEED)
     This hook computes the cost of an addressing mode that contains
     ADDRESS.  If not defined, the cost is computed from the ADDRESS
     expression and the 'TARGET_RTX_COST' hook.

     For most CISC machines, the default cost is a good approximation of
     the true cost of the addressing mode.  However, on RISC machines,
     all instructions normally have the same length and execution time.
     Hence all addresses will have equal costs.

     In cases where more than one form of an address is known, the form
     with the lowest cost will be used.  If multiple forms have the
     same, lowest, cost, the one that is the most complex will be used.

     For example, suppose an address that is equal to the sum of a
     register and a constant is used twice in the same basic block.
     When this macro is not defined, the address will be computed in a
     register and memory references will be indirect through that
     register.  On machines where the cost of the addressing mode
     containing the sum is no higher than that of a simple indirect
     reference, this will produce an additional instruction and possibly
     require an additional register.  Proper specification of this macro
     eliminates this overhead for such machines.

     This hook is never called with an invalid address.

     On machines where an address involving more than one register is as
     cheap as an address computation involving only one register,
     defining 'TARGET_ADDRESS_COST' to reflect this can cause two
     registers to be live over a region of code where only one would
     have been if 'TARGET_ADDRESS_COST' were not defined in that manner.
     This effect should be considered in the definition of this macro.
     Equivalent costs should probably only be given to addresses with
     different numbers of registers on machines with lots of registers.

 -- Target Hook: int TARGET_INSN_COST (rtx_insn *INSN, bool SPEED)
     This target hook describes the relative costs of RTL instructions.

     In implementing this hook, you can use the construct 'COSTS_N_INSNS
     (N)' to specify a cost equal to N fast instructions.

     When optimizing for code size, i.e. when 'speed' is false, this
     target hook should be used to estimate the relative size cost of an
     expression, again relative to 'COSTS_N_INSNS'.

 -- Target Hook: unsigned int TARGET_MAX_NOCE_IFCVT_SEQ_COST (edge E)
     This hook returns a value in the same units as 'TARGET_RTX_COSTS',
     giving the maximum acceptable cost for a sequence generated by the
     RTL if-conversion pass when conditional execution is not available.
     The RTL if-conversion pass attempts to convert conditional
     operations that would require a branch to a series of unconditional
     operations and 'movMODEcc' insns.  This hook returns the maximum
     cost of the unconditional instructions and the 'movMODEcc' insns.
     RTL if-conversion is cancelled if the cost of the converted
     sequence is greater than the value returned by this hook.

     'e' is the edge between the basic block containing the conditional
     branch to the basic block which would be executed if the condition
     were true.

     The default implementation of this hook uses the
     'max-rtl-if-conversion-[un]predictable' parameters if they are set,
     and uses a multiple of 'BRANCH_COST' otherwise.

 -- Target Hook: bool TARGET_NOCE_CONVERSION_PROFITABLE_P (rtx_insn
          *SEQ, struct noce_if_info *IF_INFO)
     This hook returns true if the instruction sequence 'seq' is a good
     candidate as a replacement for the if-convertible sequence
     described in 'if_info'.

 -- Target Hook: bool TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P (void)
     This predicate controls the use of the eager delay slot filler to
     disallow speculatively executed instructions being placed in delay
     slots.  Targets such as certain MIPS architectures possess both
     branches with and without delay slots.  As the eager delay slot
     filler can decrease performance, disabling it is beneficial when
     ordinary branches are available.  Use of delay slot branches filled
     using the basic filler is often still desirable as the delay slot
     can hide a pipeline bubble.

 -- Target Hook: HOST_WIDE_INT TARGET_ESTIMATED_POLY_VALUE (poly_int64
          VAL)
     Return an estimate of the runtime value of VAL, for use in things
     like cost calculations or profiling frequencies.  The default
     implementation returns the lowest possible value of VAL.

==============================================================================
File: gccint.info,  Node: |Scheduling|,  Next: |Sections|,  Prev: |Costs|,  Up: |Target_Macros|
==============================================================================

                                                                    *Scheduling*

18.17 Adjusting the Instruction Scheduler
==========-------------------------------

The instruction scheduler may need a fair amount of machine-specific
adjustment in order to produce good code.  GCC provides several target
hooks for this purpose.  It is usually enough to define just a few of
them: try the first ones in this list first.

 -- Target Hook: int TARGET_SCHED_ISSUE_RATE (void)
     This hook returns the maximum number of instructions that can ever
     issue at the same time on the target machine.  The default is one.
     Although the insn scheduler can define itself the possibility of
     issue an insn on the same cycle, the value can serve as an
     additional constraint to issue insns on the same simulated
     processor cycle (see hooks 'TARGET_SCHED_REORDER' and
     'TARGET_SCHED_REORDER2').  This value must be constant over the
     entire compilation.  If you need it to vary depending on what the
     instructions are, you must use 'TARGET_SCHED_VARIABLE_ISSUE'.

 -- Target Hook: int TARGET_SCHED_VARIABLE_ISSUE (FILE *FILE, int
          VERBOSE, rtx_insn *INSN, int MORE)
     This hook is executed by the scheduler after it has scheduled an
     insn from the ready list.  It should return the number of insns
     which can still be issued in the current cycle.  The default is
     'MORE - 1' for insns other than 'CLOBBER' and 'USE', which normally
     are not counted against the issue rate.  You should define this
     hook if some insns take more machine resources than others, so that
     fewer insns can follow them in the same cycle.  FILE is either a
     null pointer, or a stdio stream to write any debug output to.
     VERBOSE is the verbose level provided by '-fsched-verbose-N'.  INSN
     is the instruction that was scheduled.

 -- Target Hook: int TARGET_SCHED_ADJUST_COST (rtx_insn *INSN, int
          DEP_TYPE1, rtx_insn *DEP_INSN, int COST, unsigned int DW)
     This function corrects the value of COST based on the relationship
     between INSN and DEP_INSN through a dependence of type dep_type,
     and strength DW.  It should return the new value.  The default is
     to make no adjustment to COST.  This can be used for example to
     specify to the scheduler using the traditional pipeline description
     that an output- or anti-dependence does not incur the same cost as
     a data-dependence.  If the scheduler using the automaton based
     pipeline description, the cost of anti-dependence is zero and the
     cost of output-dependence is maximum of one and the difference of
     latency times of the first and the second insns.  If these values
     are not acceptable, you could use the hook to modify them too.  See
     also *note Processor pipeline description::.

 -- Target Hook: int TARGET_SCHED_ADJUST_PRIORITY (rtx_insn *INSN, int
          PRIORITY)
     This hook adjusts the integer scheduling priority PRIORITY of INSN.
     It should return the new priority.  Increase the priority to
     execute INSN earlier, reduce the priority to execute INSN later.
     Do not define this hook if you do not need to adjust the scheduling
     priorities of insns.

 -- Target Hook: int TARGET_SCHED_REORDER (FILE *FILE, int VERBOSE,
          rtx_insn **READY, int *N_READYP, int CLOCK)
     This hook is executed by the scheduler after it has scheduled the
     ready list, to allow the machine description to reorder it (for
     example to combine two small instructions together on 'VLIW'
     machines).  FILE is either a null pointer, or a stdio stream to
     write any debug output to.  VERBOSE is the verbose level provided
     by '-fsched-verbose-N'.  READY is a pointer to the ready list of
     instructions that are ready to be scheduled.  N_READYP is a pointer
     to the number of elements in the ready list.  The scheduler reads
     the ready list in reverse order, starting with READY[*N_READYP - 1]
     and going to READY[0].  CLOCK is the timer tick of the scheduler.
     You may modify the ready list and the number of ready insns.  The
     return value is the number of insns that can issue this cycle;
     normally this is just 'issue_rate'.  See also
     'TARGET_SCHED_REORDER2'.

 -- Target Hook: int TARGET_SCHED_REORDER2 (FILE *FILE, int VERBOSE,
          rtx_insn **READY, int *N_READYP, int CLOCK)
     Like 'TARGET_SCHED_REORDER', but called at a different time.  That
     function is called whenever the scheduler starts a new cycle.  This
     one is called once per iteration over a cycle, immediately after
     'TARGET_SCHED_VARIABLE_ISSUE'; it can reorder the ready list and
     return the number of insns to be scheduled in the same cycle.
     Defining this hook can be useful if there are frequent situations
     where scheduling one insn causes other insns to become ready in the
     same cycle.  These other insns can then be taken into account
     properly.

 -- Target Hook: bool TARGET_SCHED_MACRO_FUSION_P (void)
     This hook is used to check whether target platform supports macro
     fusion.

 -- Target Hook: bool TARGET_SCHED_MACRO_FUSION_PAIR_P (rtx_insn *PREV,
          rtx_insn *CURR)
     This hook is used to check whether two insns should be macro fused
     for a target microarchitecture.  If this hook returns true for the
     given insn pair (PREV and CURR), the scheduler will put them into a
     sched group, and they will not be scheduled apart.  The two insns
     will be either two SET insns or a compare and a conditional jump
     and this hook should validate any dependencies needed to fuse the
     two insns together.

 -- Target Hook: void TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK
          (rtx_insn *HEAD, rtx_insn *TAIL)
     This hook is called after evaluation forward dependencies of insns
     in chain given by two parameter values (HEAD and TAIL
     correspondingly) but before insns scheduling of the insn chain.
     For example, it can be used for better insn classification if it
     requires analysis of dependencies.  This hook can use backward and
     forward dependencies of the insn scheduler because they are already
     calculated.

 -- Target Hook: void TARGET_SCHED_INIT (FILE *FILE, int VERBOSE, int
          MAX_READY)
     This hook is executed by the scheduler at the beginning of each
     block of instructions that are to be scheduled.  FILE is either a
     null pointer, or a stdio stream to write any debug output to.
     VERBOSE is the verbose level provided by '-fsched-verbose-N'.
     MAX_READY is the maximum number of insns in the current scheduling
     region that can be live at the same time.  This can be used to
     allocate scratch space if it is needed, e.g. by
     'TARGET_SCHED_REORDER'.

 -- Target Hook: void TARGET_SCHED_FINISH (FILE *FILE, int VERBOSE)
     This hook is executed by the scheduler at the end of each block of
     instructions that are to be scheduled.  It can be used to perform
     cleanup of any actions done by the other scheduling hooks.  FILE is
     either a null pointer, or a stdio stream to write any debug output
     to.  VERBOSE is the verbose level provided by '-fsched-verbose-N'.

 -- Target Hook: void TARGET_SCHED_INIT_GLOBAL (FILE *FILE, int VERBOSE,
          int OLD_MAX_UID)
     This hook is executed by the scheduler after function level
     initializations.  FILE is either a null pointer, or a stdio stream
     to write any debug output to.  VERBOSE is the verbose level
     provided by '-fsched-verbose-N'.  OLD_MAX_UID is the maximum insn
     uid when scheduling begins.

 -- Target Hook: void TARGET_SCHED_FINISH_GLOBAL (FILE *FILE, int
          VERBOSE)
     This is the cleanup hook corresponding to
     'TARGET_SCHED_INIT_GLOBAL'.  FILE is either a null pointer, or a
     stdio stream to write any debug output to.  VERBOSE is the verbose
     level provided by '-fsched-verbose-N'.

 -- Target Hook: rtx TARGET_SCHED_DFA_PRE_CYCLE_INSN (void)
     The hook returns an RTL insn.  The automaton state used in the
     pipeline hazard recognizer is changed as if the insn were scheduled
     when the new simulated processor cycle starts.  Usage of the hook
     may simplify the automaton pipeline description for some VLIW
     processors.  If the hook is defined, it is used only for the
     automaton based pipeline description.  The default is not to change
     the state when the new simulated processor cycle starts.

 -- Target Hook: void TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN (void)
     The hook can be used to initialize data used by the previous hook.

 -- Target Hook: rtx_insn * TARGET_SCHED_DFA_POST_CYCLE_INSN (void)
     The hook is analogous to 'TARGET_SCHED_DFA_PRE_CYCLE_INSN' but used
     to changed the state as if the insn were scheduled when the new
     simulated processor cycle finishes.

 -- Target Hook: void TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN (void)
     The hook is analogous to 'TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN' but
     used to initialize data used by the previous hook.

 -- Target Hook: void TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE (void)
     The hook to notify target that the current simulated cycle is about
     to finish.  The hook is analogous to
     'TARGET_SCHED_DFA_PRE_CYCLE_INSN' but used to change the state in
     more complicated situations - e.g., when advancing state on a
     single insn is not enough.

 -- Target Hook: void TARGET_SCHED_DFA_POST_ADVANCE_CYCLE (void)
     The hook to notify target that new simulated cycle has just
     started.  The hook is analogous to
     'TARGET_SCHED_DFA_POST_CYCLE_INSN' but used to change the state in
     more complicated situations - e.g., when advancing state on a
     single insn is not enough.

 -- Target Hook: int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
          (void)
     This hook controls better choosing an insn from the ready insn
     queue for the DFA-based insn scheduler.  Usually the scheduler
     chooses the first insn from the queue.  If the hook returns a
     positive value, an additional scheduler code tries all permutations
     of 'TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()' subsequent
     ready insns to choose an insn whose issue will result in maximal
     number of issued insns on the same cycle.  For the VLIW processor,
     the code could actually solve the problem of packing simple insns
     into the VLIW insn.  Of course, if the rules of VLIW packing are
     described in the automaton.

     This code also could be used for superscalar RISC processors.  Let
     us consider a superscalar RISC processor with 3 pipelines.  Some
     insns can be executed in pipelines A or B, some insns can be
     executed only in pipelines B or C, and one insn can be executed in
     pipeline B.  The processor may issue the 1st insn into A and the
     2nd one into B.  In this case, the 3rd insn will wait for freeing B
     until the next cycle.  If the scheduler issues the 3rd insn the
     first, the processor could issue all 3 insns per cycle.

     Actually this code demonstrates advantages of the automaton based
     pipeline hazard recognizer.  We try quickly and easy many insn
     schedules to choose the best one.

     The default is no multipass scheduling.

 -- Target Hook: int
          TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD
          (rtx_insn *INSN, int READY_INDEX)

     This hook controls what insns from the ready insn queue will be
     considered for the multipass insn scheduling.  If the hook returns
     zero for INSN, the insn will be considered in multipass scheduling.
     Positive return values will remove INSN from consideration on the
     current round of multipass scheduling.  Negative return values will
     remove INSN from consideration for given number of cycles.
     Backends should be careful about returning non-zero for highest
     priority instruction at position 0 in the ready list.  READY_INDEX
     is passed to allow backends make correct judgements.

     The default is that any ready insns can be chosen to be issued.

 -- Target Hook: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN (void
          *DATA, signed char *READY_TRY, int N_READY, bool
          FIRST_CYCLE_INSN_P)
     This hook prepares the target backend for a new round of multipass
     scheduling.

 -- Target Hook: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE (void
          *DATA, signed char *READY_TRY, int N_READY, rtx_insn *INSN,
          const void *PREV_DATA)
     This hook is called when multipass scheduling evaluates instruction
     INSN.

 -- Target Hook: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK
          (const void *DATA, signed char *READY_TRY, int N_READY)
     This is called when multipass scheduling backtracks from evaluation
     of an instruction.

 -- Target Hook: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_END (const void
          *DATA)
     This hook notifies the target about the result of the concluded
     current round of multipass scheduling.

 -- Target Hook: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_INIT (void
          *DATA)
     This hook initializes target-specific data used in multipass
     scheduling.

 -- Target Hook: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_FINI (void
          *DATA)
     This hook finalizes target-specific data used in multipass
     scheduling.

 -- Target Hook: int TARGET_SCHED_DFA_NEW_CYCLE (FILE *DUMP, int
          VERBOSE, rtx_insn *INSN, int LAST_CLOCK, int CLOCK, int
          *SORT_P)
     This hook is called by the insn scheduler before issuing INSN on
     cycle CLOCK.  If the hook returns nonzero, INSN is not issued on
     this processor cycle.  Instead, the processor cycle is advanced.
     If *SORT_P is zero, the insn ready queue is not sorted on the new
     cycle start as usually.  DUMP and VERBOSE specify the file and
     verbosity level to use for debugging output.  LAST_CLOCK and CLOCK
     are, respectively, the processor cycle on which the previous insn
     has been issued, and the current processor cycle.

 -- Target Hook: bool TARGET_SCHED_IS_COSTLY_DEPENDENCE (struct _dep
          *_DEP, int COST, int DISTANCE)
     This hook is used to define which dependences are considered costly
     by the target, so costly that it is not advisable to schedule the
     insns that are involved in the dependence too close to one another.
     The parameters to this hook are as follows: The first parameter
     _DEP is the dependence being evaluated.  The second parameter COST
     is the cost of the dependence as estimated by the scheduler, and
     the third parameter DISTANCE is the distance in cycles between the
     two insns.  The hook returns 'true' if considering the distance
     between the two insns the dependence between them is considered
     costly by the target, and 'false' otherwise.

     Defining this hook can be useful in multiple-issue out-of-order
     machines, where (a) it's practically hopeless to predict the actual
     data/resource delays, however: (b) there's a better chance to
     predict the actual grouping that will be formed, and (c) correctly
     emulating the grouping can be very important.  In such targets one
     may want to allow issuing dependent insns closer to one
     another--i.e., closer than the dependence distance; however, not in
     cases of "costly dependences", which this hooks allows to define.

 -- Target Hook: void TARGET_SCHED_H_I_D_EXTENDED (void)
     This hook is called by the insn scheduler after emitting a new
     instruction to the instruction stream.  The hook notifies a target
     backend to extend its per instruction data structures.

 -- Target Hook: void * TARGET_SCHED_ALLOC_SCHED_CONTEXT (void)
     Return a pointer to a store large enough to hold target scheduling
     context.

 -- Target Hook: void TARGET_SCHED_INIT_SCHED_CONTEXT (void *TC, bool
          CLEAN_P)
     Initialize store pointed to by TC to hold target scheduling
     context.  It CLEAN_P is true then initialize TC as if scheduler is
     at the beginning of the block.  Otherwise, copy the current context
     into TC.

 -- Target Hook: void TARGET_SCHED_SET_SCHED_CONTEXT (void *TC)
     Copy target scheduling context pointed to by TC to the current
     context.

 -- Target Hook: void TARGET_SCHED_CLEAR_SCHED_CONTEXT (void *TC)
     Deallocate internal data in target scheduling context pointed to by
     TC.

 -- Target Hook: void TARGET_SCHED_FREE_SCHED_CONTEXT (void *TC)
     Deallocate a store for target scheduling context pointed to by TC.

 -- Target Hook: int TARGET_SCHED_SPECULATE_INSN (rtx_insn *INSN,
          unsigned int DEP_STATUS, rtx *NEW_PAT)
     This hook is called by the insn scheduler when INSN has only
     speculative dependencies and therefore can be scheduled
     speculatively.  The hook is used to check if the pattern of INSN
     has a speculative version and, in case of successful check, to
     generate that speculative pattern.  The hook should return 1, if
     the instruction has a speculative form, or -1, if it doesn't.
     REQUEST describes the type of requested speculation.  If the return
     value equals 1 then NEW_PAT is assigned the generated speculative
     pattern.

 -- Target Hook: bool TARGET_SCHED_NEEDS_BLOCK_P (unsigned int
          DEP_STATUS)
     This hook is called by the insn scheduler during generation of
     recovery code for INSN.  It should return 'true', if the
     corresponding check instruction should branch to recovery code, or
     'false' otherwise.

 -- Target Hook: rtx TARGET_SCHED_GEN_SPEC_CHECK (rtx_insn *INSN,
          rtx_insn *LABEL, unsigned int DS)
     This hook is called by the insn scheduler to generate a pattern for
     recovery check instruction.  If MUTATE_P is zero, then INSN is a
     speculative instruction for which the check should be generated.
     LABEL is either a label of a basic block, where recovery code
     should be emitted, or a null pointer, when requested check doesn't
     branch to recovery code (a simple check).  If MUTATE_P is nonzero,
     then a pattern for a branchy check corresponding to a simple check
     denoted by INSN should be generated.  In this case LABEL can't be
     null.

 -- Target Hook: void TARGET_SCHED_SET_SCHED_FLAGS (struct spec_info_def
          *SPEC_INFO)
     This hook is used by the insn scheduler to find out what features
     should be enabled/used.  The structure *SPEC_INFO should be filled
     in by the target.  The structure describes speculation types that
     can be used in the scheduler.

 -- Target Hook: bool TARGET_SCHED_CAN_SPECULATE_INSN (rtx_insn *INSN)
     Some instructions should never be speculated by the schedulers,
     usually because the instruction is too expensive to get this wrong.
     Often such instructions have long latency, and often they are not
     fully modeled in the pipeline descriptions.  This hook should
     return 'false' if INSN should not be speculated.

 -- Target Hook: int TARGET_SCHED_SMS_RES_MII (struct ddg *G)
     This hook is called by the swing modulo scheduler to calculate a
     resource-based lower bound which is based on the resources
     available in the machine and the resources required by each
     instruction.  The target backend can use G to calculate such bound.
     A very simple lower bound will be used in case this hook is not
     implemented: the total number of instructions divided by the issue
     rate.

 -- Target Hook: bool TARGET_SCHED_DISPATCH (rtx_insn *INSN, int X)
     This hook is called by Haifa Scheduler.  It returns true if
     dispatch scheduling is supported in hardware and the condition
     specified in the parameter is true.

 -- Target Hook: void TARGET_SCHED_DISPATCH_DO (rtx_insn *INSN, int X)
     This hook is called by Haifa Scheduler.  It performs the operation
     specified in its second parameter.

 -- Target Hook: bool TARGET_SCHED_EXPOSED_PIPELINE
     True if the processor has an exposed pipeline, which means that not
     just the order of instructions is important for correctness when
     scheduling, but also the latencies of operations.

 -- Target Hook: int TARGET_SCHED_REASSOCIATION_WIDTH (unsigned int OPC,
          machine_mode MODE)
     This hook is called by tree reassociator to determine a level of
     parallelism required in output calculations chain.

 -- Target Hook: void TARGET_SCHED_FUSION_PRIORITY (rtx_insn *INSN, int
          MAX_PRI, int *FUSION_PRI, int *PRI)
     This hook is called by scheduling fusion pass.  It calculates
     fusion priorities for each instruction passed in by parameter.  The
     priorities are returned via pointer parameters.

     INSN is the instruction whose priorities need to be calculated.
     MAX_PRI is the maximum priority can be returned in any cases.
     FUSION_PRI is the pointer parameter through which INSN's fusion
     priority should be calculated and returned.  PRI is the pointer
     parameter through which INSN's priority should be calculated and
     returned.

     Same FUSION_PRI should be returned for instructions which should be
     scheduled together.  Different PRI should be returned for
     instructions with same FUSION_PRI.  FUSION_PRI is the major sort
     key, PRI is the minor sort key.  All instructions will be scheduled
     according to the two priorities.  All priorities calculated should
     be between 0 (exclusive) and MAX_PRI (inclusive).  To avoid false
     dependencies, FUSION_PRI of instructions which need to be scheduled
     together should be smaller than FUSION_PRI of irrelevant
     instructions.

     Given below example:

              ldr r10, [r1, 4]
              add r4, r4, r10
              ldr r15, [r2, 8]
              sub r5, r5, r15
              ldr r11, [r1, 0]
              add r4, r4, r11
              ldr r16, [r2, 12]
              sub r5, r5, r16

     On targets like ARM/AArch64, the two pairs of consecutive loads
     should be merged.  Since peephole2 pass can't help in this case
     unless consecutive loads are actually next to each other in
     instruction flow.  That's where this scheduling fusion pass works.
     This hook calculates priority for each instruction based on its
     fustion type, like:

              ldr r10, [r1, 4]  ; fusion_pri=99,  pri=96
              add r4, r4, r10   ; fusion_pri=100, pri=100
              ldr r15, [r2, 8]  ; fusion_pri=98,  pri=92
              sub r5, r5, r15   ; fusion_pri=100, pri=100
              ldr r11, [r1, 0]  ; fusion_pri=99,  pri=100
              add r4, r4, r11   ; fusion_pri=100, pri=100
              ldr r16, [r2, 12] ; fusion_pri=98,  pri=88
              sub r5, r5, r16   ; fusion_pri=100, pri=100

     Scheduling fusion pass then sorts all ready to issue instructions
     according to the priorities.  As a result, instructions of same
     fusion type will be pushed together in instruction flow, like:

              ldr r11, [r1, 0]
              ldr r10, [r1, 4]
              ldr r15, [r2, 8]
              ldr r16, [r2, 12]
              add r4, r4, r10
              sub r5, r5, r15
              add r4, r4, r11
              sub r5, r5, r16

     Now peephole2 pass can simply merge the two pairs of loads.

     Since scheduling fusion pass relies on peephole2 to do real fusion
     work, it is only enabled by default when peephole2 is in effect.

     This is firstly introduced on ARM/AArch64 targets, please refer to
     the hook implementation for how different fusion types are
     supported.

 -- Target Hook: void TARGET_EXPAND_DIVMOD_LIBFUNC (rtx LIBFUNC,
          machine_mode MODE, rtx OP0, rtx OP1, rtx *QUOT, rtx *REM)
     Define this hook for enabling divmod transform if the port does not
     have hardware divmod insn but defines target-specific divmod
     libfuncs.

==============================================================================
File: gccint.info,  Node: |Sections|,  Next: |PIC|,  Prev: |Scheduling|,  Up: |Target_Macros|
==============================================================================

                                                                      *Sections*

18.18 Dividing the Output into Sections (Texts, Data, ...)
==========------------------------------------------------

An object file is divided into sections containing different types of
data.  In the most common case, there are three sections: the "text
section", which holds instructions and read-only data; the "data
section", which holds initialized writable data; and the "bss section",
which holds uninitialized data.  Some systems have other kinds of
sections.

 'varasm.c' provides several well-known sections, such as
'text_section', 'data_section' and 'bss_section'.  The normal way of
controlling a 'FOO_section' variable is to define the associated
'FOO_SECTION_ASM_OP' macro, as described below.  The macros are only
read once, when 'varasm.c' initializes itself, so their values must be
run-time constants.  They may however depend on command-line flags.

 _Note:_ Some run-time files, such 'crtstuff.c', also make use of the
'FOO_SECTION_ASM_OP' macros, and expect them to be string literals.

 Some assemblers require a different string to be written every time a
section is selected.  If your assembler falls into this category, you
should define the 'TARGET_ASM_INIT_SECTIONS' hook and use
'get_unnamed_section' to set up the sections.

 You must always create a 'text_section', either by defining
'TEXT_SECTION_ASM_OP' or by initializing 'text_section' in
'TARGET_ASM_INIT_SECTIONS'.  The same is true of 'data_section' and
'DATA_SECTION_ASM_OP'.  If you do not create a distinct
'readonly_data_section', the default is to reuse 'text_section'.

 All the other 'varasm.c' sections are optional, and are null if the
target does not provide them.

 -- Macro: TEXT_SECTION_ASM_OP
     A C expression whose value is a string, including spacing,
     containing the assembler operation that should precede instructions
     and read-only data.  Normally '"\t.text"' is right.

 -- Macro: HOT_TEXT_SECTION_NAME
     If defined, a C string constant for the name of the section
     containing most frequently executed functions of the program.  If
     not defined, GCC will provide a default definition if the target
     supports named sections.

 -- Macro: UNLIKELY_EXECUTED_TEXT_SECTION_NAME
     If defined, a C string constant for the name of the section
     containing unlikely executed functions in the program.

 -- Macro: DATA_SECTION_ASM_OP
     A C expression whose value is a string, including spacing,
     containing the assembler operation to identify the following data
     as writable initialized data.  Normally '"\t.data"' is right.

 -- Macro: SDATA_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as initialized, writable small data.

 -- Macro: READONLY_DATA_SECTION_ASM_OP
     A C expression whose value is a string, including spacing,
     containing the assembler operation to identify the following data
     as read-only initialized data.

 -- Macro: BSS_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as uninitialized global data.  If not defined, and
     'ASM_OUTPUT_ALIGNED_BSS' not defined, uninitialized global data
     will be output in the data section if '-fno-common' is passed,
     otherwise 'ASM_OUTPUT_COMMON' will be used.

 -- Macro: SBSS_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as uninitialized, writable small data.

 -- Macro: TLS_COMMON_ASM_OP
     If defined, a C expression whose value is a string containing the
     assembler operation to identify the following data as thread-local
     common data.  The default is '".tls_common"'.

 -- Macro: TLS_SECTION_ASM_FLAG
     If defined, a C expression whose value is a character constant
     containing the flag used to mark a section as a TLS section.  The
     default is ''T''.

 -- Macro: INIT_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as initialization code.  If not defined, GCC will
     assume such a section does not exist.  This section has no
     corresponding 'init_section' variable; it is used entirely in
     runtime code.

 -- Macro: FINI_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as finalization code.  If not defined, GCC will
     assume such a section does not exist.  This section has no
     corresponding 'fini_section' variable; it is used entirely in
     runtime code.

 -- Macro: INIT_ARRAY_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as part of the '.init_array' (or equivalent)
     section.  If not defined, GCC will assume such a section does not
     exist.  Do not define both this macro and 'INIT_SECTION_ASM_OP'.

 -- Macro: FINI_ARRAY_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as part of the '.fini_array' (or equivalent)
     section.  If not defined, GCC will assume such a section does not
     exist.  Do not define both this macro and 'FINI_SECTION_ASM_OP'.

 -- Macro: MACH_DEP_SECTION_ASM_FLAG
     If defined, a C expression whose value is a character constant
     containing the flag used to mark a machine-dependent section.  This
     corresponds to the 'SECTION_MACH_DEP' section flag.

 -- Macro: CRT_CALL_STATIC_FUNCTION (SECTION_OP, FUNCTION)
     If defined, an ASM statement that switches to a different section
     via SECTION_OP, calls FUNCTION, and switches back to the text
     section.  This is used in 'crtstuff.c' if 'INIT_SECTION_ASM_OP' or
     'FINI_SECTION_ASM_OP' to calls to initialization and finalization
     functions from the init and fini sections.  By default, this macro
     uses a simple function call.  Some ports need hand-crafted assembly
     code to avoid dependencies on registers initialized in the function
     prologue or to ensure that constant pools don't end up too far way
     in the text section.

 -- Macro: TARGET_LIBGCC_SDATA_SECTION
     If defined, a string which names the section into which small
     variables defined in crtstuff and libgcc should go.  This is useful
     when the target has options for optimizing access to small data,
     and you want the crtstuff and libgcc routines to be conservative in
     what they expect of your application yet liberal in what your
     application expects.  For example, for targets with a '.sdata'
     section (like MIPS), you could compile crtstuff with '-G 0' so that
     it doesn't require small data support from your application, but
     use this macro to put small data into '.sdata' so that your
     application can access these variables whether it uses small data
     or not.

 -- Macro: FORCE_CODE_SECTION_ALIGN
     If defined, an ASM statement that aligns a code section to some
     arbitrary boundary.  This is used to force all fragments of the
     '.init' and '.fini' sections to have to same alignment and thus
     prevent the linker from having to add any padding.

 -- Macro: JUMP_TABLES_IN_TEXT_SECTION
     Define this macro to be an expression with a nonzero value if jump
     tables (for 'tablejump' insns) should be output in the text
     section, along with the assembler instructions.  Otherwise, the
     readonly data section is used.

     This macro is irrelevant if there is no separate readonly data
     section.

 -- Target Hook: void TARGET_ASM_INIT_SECTIONS (void)
     Define this hook if you need to do something special to set up the
     'varasm.c' sections, or if your target has some special sections of
     its own that you need to create.

     GCC calls this hook after processing the command line, but before
     writing any assembly code, and before calling any of the
     section-returning hooks described below.

 -- Target Hook: int TARGET_ASM_RELOC_RW_MASK (void)
     Return a mask describing how relocations should be treated when
     selecting sections.  Bit 1 should be set if global relocations
     should be placed in a read-write section; bit 0 should be set if
     local relocations should be placed in a read-write section.

     The default version of this function returns 3 when '-fpic' is in
     effect, and 0 otherwise.  The hook is typically redefined when the
     target cannot support (some kinds of) dynamic relocations in
     read-only sections even in executables.

 -- Target Hook: bool TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC (void)
     Return true to generate ADDR_DIF_VEC table or false to generate
     ADDR_VEC table for jumps in case of -fPIC.

     The default version of this function returns true if flag_pic
     equals true and false otherwise

 -- Target Hook: section * TARGET_ASM_SELECT_SECTION (tree EXP, int
          RELOC, unsigned HOST_WIDE_INT ALIGN)
     Return the section into which EXP should be placed.  You can assume
     that EXP is either a 'VAR_DECL' node or a constant of some sort.
     RELOC indicates whether the initial value of EXP requires link-time
     relocations.  Bit 0 is set when variable contains local relocations
     only, while bit 1 is set for global relocations.  ALIGN is the
     constant alignment in bits.

     The default version of this function takes care of putting
     read-only variables in 'readonly_data_section'.

     See also USE_SELECT_SECTION_FOR_FUNCTIONS.

 -- Macro: USE_SELECT_SECTION_FOR_FUNCTIONS
     Define this macro if you wish TARGET_ASM_SELECT_SECTION to be
     called for 'FUNCTION_DECL's as well as for variables and constants.

     In the case of a 'FUNCTION_DECL', RELOC will be zero if the
     function has been determined to be likely to be called, and nonzero
     if it is unlikely to be called.

 -- Target Hook: void TARGET_ASM_UNIQUE_SECTION (tree DECL, int RELOC)
     Build up a unique section name, expressed as a 'STRING_CST' node,
     and assign it to 'DECL_SECTION_NAME (DECL)'.  As with
     'TARGET_ASM_SELECT_SECTION', RELOC indicates whether the initial
     value of EXP requires link-time relocations.

     The default version of this function appends the symbol name to the
     ELF section name that would normally be used for the symbol.  For
     example, the function 'foo' would be placed in '.text.foo'.
     Whatever the actual target object format, this is often good
     enough.

 -- Target Hook: section * TARGET_ASM_FUNCTION_RODATA_SECTION (tree
          DECL)
     Return the readonly data section associated with 'DECL_SECTION_NAME
     (DECL)'.  The default version of this function selects
     '.gnu.linkonce.r.name' if the function's section is
     '.gnu.linkonce.t.name', '.rodata.name' if function is in
     '.text.name', and the normal readonly-data section otherwise.

 -- Target Hook: const char * TARGET_ASM_MERGEABLE_RODATA_PREFIX
     Usually, the compiler uses the prefix '".rodata"' to construct
     section names for mergeable constant data.  Define this macro to
     override the string if a different section name should be used.

 -- Target Hook: section * TARGET_ASM_TM_CLONE_TABLE_SECTION (void)
     Return the section that should be used for transactional memory
     clone tables.

 -- Target Hook: section * TARGET_ASM_SELECT_RTX_SECTION (machine_mode
          MODE, rtx X, unsigned HOST_WIDE_INT ALIGN)
     Return the section into which a constant X, of mode MODE, should be
     placed.  You can assume that X is some kind of constant in RTL.
     The argument MODE is redundant except in the case of a 'const_int'
     rtx.  ALIGN is the constant alignment in bits.

     The default version of this function takes care of putting symbolic
     constants in 'flag_pic' mode in 'data_section' and everything else
     in 'readonly_data_section'.

 -- Target Hook: tree TARGET_MANGLE_DECL_ASSEMBLER_NAME (tree DECL, tree
          ID)
     Define this hook if you need to postprocess the assembler name
     generated by target-independent code.  The ID provided to this hook
     will be the computed name (e.g., the macro 'DECL_NAME' of the DECL
     in C, or the mangled name of the DECL in C++).  The return value of
     the hook is an 'IDENTIFIER_NODE' for the appropriate mangled name
     on your target system.  The default implementation of this hook
     just returns the ID provided.

 -- Target Hook: void TARGET_ENCODE_SECTION_INFO (tree DECL, rtx RTL,
          int NEW_DECL_P)
     Define this hook if references to a symbol or a constant must be
     treated differently depending on something about the variable or
     function named by the symbol (such as what section it is in).

     The hook is executed immediately after rtl has been created for
     DECL, which may be a variable or function declaration or an entry
     in the constant pool.  In either case, RTL is the rtl in question.
     Do _not_ use 'DECL_RTL (DECL)' in this hook; that field may not
     have been initialized yet.

     In the case of a constant, it is safe to assume that the rtl is a
     'mem' whose address is a 'symbol_ref'.  Most decls will also have
     this form, but that is not guaranteed.  Global register variables,
     for instance, will have a 'reg' for their rtl.  (Normally the right
     thing to do with such unusual rtl is leave it alone.)

     The NEW_DECL_P argument will be true if this is the first time that
     'TARGET_ENCODE_SECTION_INFO' has been invoked on this decl.  It
     will be false for subsequent invocations, which will happen for
     duplicate declarations.  Whether or not anything must be done for
     the duplicate declaration depends on whether the hook examines
     'DECL_ATTRIBUTES'.  NEW_DECL_P is always true when the hook is
     called for a constant.

     The usual thing for this hook to do is to record flags in the
     'symbol_ref', using 'SYMBOL_REF_FLAG' or 'SYMBOL_REF_FLAGS'.
     Historically, the name string was modified if it was necessary to
     encode more than one bit of information, but this practice is now
     discouraged; use 'SYMBOL_REF_FLAGS'.

     The default definition of this hook, 'default_encode_section_info'
     in 'varasm.c', sets a number of commonly-useful bits in
     'SYMBOL_REF_FLAGS'.  Check whether the default does what you need
     before overriding it.

 -- Target Hook: const char * TARGET_STRIP_NAME_ENCODING (const char
          *NAME)
     Decode NAME and return the real name part, sans the characters that
     'TARGET_ENCODE_SECTION_INFO' may have added.

 -- Target Hook: bool TARGET_IN_SMALL_DATA_P (const_tree EXP)
     Returns true if EXP should be placed into a "small data" section.
     The default version of this hook always returns false.

 -- Target Hook: bool TARGET_HAVE_SRODATA_SECTION
     Contains the value true if the target places read-only "small data"
     into a separate section.  The default value is false.

 -- Target Hook: bool TARGET_PROFILE_BEFORE_PROLOGUE (void)
     It returns true if target wants profile code emitted before
     prologue.

     The default version of this hook use the target macro
     'PROFILE_BEFORE_PROLOGUE'.

 -- Target Hook: bool TARGET_BINDS_LOCAL_P (const_tree EXP)
     Returns true if EXP names an object for which name resolution rules
     must resolve to the current "module" (dynamic shared library or
     executable image).

     The default version of this hook implements the name resolution
     rules for ELF, which has a looser model of global name binding than
     other currently supported object file formats.

 -- Target Hook: bool TARGET_HAVE_TLS
     Contains the value true if the target supports thread-local
     storage.  The default value is false.

==============================================================================
File: gccint.info,  Node: |PIC|,  Next: |Assembler_Format|,  Prev: |Sections|,  Up: |Target_Macros|
==============================================================================

                                                                           *PIC*

18.19 Position Independent Code
==========---------------------

This section describes macros that help implement generation of position
independent code.  Simply defining these macros is not enough to
generate valid PIC; you must also add support to the hook
'TARGET_LEGITIMATE_ADDRESS_P' and to the macro 'PRINT_OPERAND_ADDRESS',
as well as 'LEGITIMIZE_ADDRESS'.  You must modify the definition of
'movsi' to do something appropriate when the source operand contains a
symbolic address.  You may also need to alter the handling of switch
statements so that they use relative addresses.

 -- Macro: PIC_OFFSET_TABLE_REGNUM
     The register number of the register used to address a table of
     static data addresses in memory.  In some cases this register is
     defined by a processor's "application binary interface" (ABI).
     When this macro is defined, RTL is generated for this register
     once, as with the stack pointer and frame pointer registers.  If
     this macro is not defined, it is up to the machine-dependent files
     to allocate such a register (if necessary).  Note that this
     register must be fixed when in use (e.g. when 'flag_pic' is true).

 -- Macro: PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
     A C expression that is nonzero if the register defined by
     'PIC_OFFSET_TABLE_REGNUM' is clobbered by calls.  If not defined,
     the default is zero.  Do not define this macro if
     'PIC_OFFSET_TABLE_REGNUM' is not defined.

 -- Macro: LEGITIMATE_PIC_OPERAND_P (X)
     A C expression that is nonzero if X is a legitimate immediate
     operand on the target machine when generating position independent
     code.  You can assume that X satisfies 'CONSTANT_P', so you need
     not check this.  You can also assume FLAG_PIC is true, so you need
     not check it either.  You need not define this macro if all
     constants (including 'SYMBOL_REF') can be immediate operands when
     generating position independent code.

==============================================================================
File: gccint.info,  Node: |Assembler_Format|,  Next: |Debugging_Info|,  Prev: |PIC|,  Up: |Target_Macros|
==============================================================================

                                                              *Assembler_Format*

18.20 Defining the Output Assembler Language
==========----------------------------------

This section describes macros whose principal purpose is to describe how
to write instructions in assembler language--rather than what the
instructions do.

MENU

* |File_Framework|::       Structural information for the assembler file.
* |Data_Output|::          Output of constants (numbers, strings, addresses).
* |Uninitialized_Data|::   Output of uninitialized variables.
* |Label_Output|::         Output and generation of labels.
* |Initialization|::       General principles of initialization
                         and termination routines.
* |Macros_for_Initialization|::
                         Specific macros that control the handling of
                         initialization and termination routines.
* |Instruction_Output|::   Output of actual instructions.
* |Dispatch_Tables|::      Output of jump tables.
* |Exception_Region_Output|:: Output of exception region code.
* |Alignment_Output|::     Pseudo ops for alignment and skipping data.

==============================================================================
File: gccint.info,  Node: |File_Framework|,  Next: |Data_Output|,  Up: |Assembler_Format|
==============================================================================

                                                                *File_Framework*

18.20.1 The Overall Framework of an Assembler File
--------------------------------------------------

This describes the overall framework of an assembly file.

 -- Target Hook: void TARGET_ASM_FILE_START (void)
     Output to 'asm_out_file' any text which the assembler expects to
     find at the beginning of a file.  The default behavior is
     controlled by two flags, documented below.  Unless your target's
     assembler is quite unusual, if you override the default, you should
     call 'default_file_start' at some point in your target hook.  This
     lets other target files rely on these variables.

 -- Target Hook: bool TARGET_ASM_FILE_START_APP_OFF
     If this flag is true, the text of the macro 'ASM_APP_OFF' will be
     printed as the very first line in the assembly file, unless
     '-fverbose-asm' is in effect.  (If that macro has been defined to
     the empty string, this variable has no effect.)  With the normal
     definition of 'ASM_APP_OFF', the effect is to notify the GNU
     assembler that it need not bother stripping comments or extra
     whitespace from its input.  This allows it to work a bit faster.

     The default is false.  You should not set it to true unless you
     have verified that your port does not generate any extra whitespace
     or comments that will cause GAS to issue errors in NO_APP mode.

 -- Target Hook: bool TARGET_ASM_FILE_START_FILE_DIRECTIVE
     If this flag is true, 'output_file_directive' will be called for
     the primary source file, immediately after printing 'ASM_APP_OFF'
     (if that is enabled).  Most ELF assemblers expect this to be done.
     The default is false.

 -- Target Hook: void TARGET_ASM_FILE_END (void)
     Output to 'asm_out_file' any text which the assembler expects to
     find at the end of a file.  The default is to output nothing.

 -- Function: void file_end_indicate_exec_stack ()
     Some systems use a common convention, the '.note.GNU-stack' special
     section, to indicate whether or not an object file relies on the
     stack being executable.  If your system uses this convention, you
     should define 'TARGET_ASM_FILE_END' to this function.  If you need
     to do other things in that hook, have your hook function call this
     function.

 -- Target Hook: void TARGET_ASM_LTO_START (void)
     Output to 'asm_out_file' any text which the assembler expects to
     find at the start of an LTO section.  The default is to output
     nothing.

 -- Target Hook: void TARGET_ASM_LTO_END (void)
     Output to 'asm_out_file' any text which the assembler expects to
     find at the end of an LTO section.  The default is to output
     nothing.

 -- Target Hook: void TARGET_ASM_CODE_END (void)
     Output to 'asm_out_file' any text which is needed before emitting
     unwind info and debug info at the end of a file.  Some targets emit
     here PIC setup thunks that cannot be emitted at the end of file,
     because they couldn't have unwind info then.  The default is to
     output nothing.

 -- Macro: ASM_COMMENT_START
     A C string constant describing how to begin a comment in the target
     assembler language.  The compiler assumes that the comment will end
     at the end of the line.

 -- Macro: ASM_APP_ON
     A C string constant for text to be output before each 'asm'
     statement or group of consecutive ones.  Normally this is '"#APP"',
     which is a comment that has no effect on most assemblers but tells
     the GNU assembler that it must check the lines that follow for all
     valid assembler constructs.

 -- Macro: ASM_APP_OFF
     A C string constant for text to be output after each 'asm'
     statement or group of consecutive ones.  Normally this is
     '"#NO_APP"', which tells the GNU assembler to resume making the
     time-saving assumptions that are valid for ordinary compiler
     output.

 -- Macro: ASM_OUTPUT_SOURCE_FILENAME (STREAM, NAME)
     A C statement to output COFF information or DWARF debugging
     information which indicates that filename NAME is the current
     source file to the stdio stream STREAM.

     This macro need not be defined if the standard form of output for
     the file format in use is appropriate.

 -- Target Hook: void TARGET_ASM_OUTPUT_SOURCE_FILENAME (FILE *FILE,
          const char *NAME)
     Output DWARF debugging information which indicates that filename
     NAME is the current source file to the stdio stream FILE.

     This target hook need not be defined if the standard form of output
     for the file format in use is appropriate.

 -- Target Hook: void TARGET_ASM_OUTPUT_IDENT (const char *NAME)
     Output a string based on NAME, suitable for the '#ident' directive,
     or the equivalent directive or pragma in non-C-family languages.
     If this hook is not defined, nothing is output for the '#ident'
     directive.

 -- Macro: OUTPUT_QUOTED_STRING (STREAM, STRING)
     A C statement to output the string STRING to the stdio stream
     STREAM.  If you do not call the function 'output_quoted_string' in
     your config files, GCC will only call it to output filenames to the
     assembler source.  So you can use it to canonicalize the format of
     the filename using this macro.

 -- Target Hook: void TARGET_ASM_NAMED_SECTION (const char *NAME,
          unsigned int FLAGS, tree DECL)
     Output assembly directives to switch to section NAME.  The section
     should have attributes as specified by FLAGS, which is a bit mask
     of the 'SECTION_*' flags defined in 'output.h'.  If DECL is
     non-NULL, it is the 'VAR_DECL' or 'FUNCTION_DECL' with which this
     section is associated.

 -- Target Hook: bool TARGET_ASM_ELF_FLAGS_NUMERIC (unsigned int FLAGS,
          unsigned int *NUM)
     This hook can be used to encode ELF section flags for which no
     letter code has been defined in the assembler.  It is called by
     'default_asm_named_section' whenever the section flags need to be
     emitted in the assembler output.  If the hook returns true, then
     the numerical value for ELF section flags should be calculated from
     FLAGS and saved in *NUM; the value is printed out instead of the
     normal sequence of letter codes.  If the hook is not defined, or if
     it returns false, then NUM is ignored and the traditional letter
     sequence is emitted.

 -- Target Hook: section * TARGET_ASM_FUNCTION_SECTION (tree DECL, enum
          node_frequency FREQ, bool STARTUP, bool EXIT)
     Return preferred text (sub)section for function DECL.  Main purpose
     of this function is to separate cold, normal and hot functions.
     STARTUP is true when function is known to be used only at startup
     (from static constructors or it is 'main()').  EXIT is true when
     function is known to be used only at exit (from static
     destructors).  Return NULL if function should go to default text
     section.

 -- Target Hook: void TARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS (FILE
          *FILE, tree DECL, bool NEW_IS_COLD)
     Used by the target to emit any assembler directives or additional
     labels needed when a function is partitioned between different
     sections.  Output should be written to FILE.  The function decl is
     available as DECL and the new section is 'cold' if NEW_IS_COLD is
     'true'.

 -- Common Target Hook: bool TARGET_HAVE_NAMED_SECTIONS
     This flag is true if the target supports
     'TARGET_ASM_NAMED_SECTION'.  It must not be modified by
     command-line option processing.

 -- Target Hook: bool TARGET_HAVE_SWITCHABLE_BSS_SECTIONS
     This flag is true if we can create zeroed data by switching to a
     BSS section and then using 'ASM_OUTPUT_SKIP' to allocate the space.
     This is true on most ELF targets.

 -- Target Hook: unsigned int TARGET_SECTION_TYPE_FLAGS (tree DECL,
          const char *NAME, int RELOC)
     Choose a set of section attributes for use by
     'TARGET_ASM_NAMED_SECTION' based on a variable or function decl, a
     section name, and whether or not the declaration's initializer may
     contain runtime relocations.  DECL may be null, in which case
     read-write data should be assumed.

     The default version of this function handles choosing code vs data,
     read-only vs read-write data, and 'flag_pic'.  You should only need
     to override this if your target has special flags that might be set
     via '__attribute__'.

 -- Target Hook: int TARGET_ASM_RECORD_GCC_SWITCHES (print_switch_type
          TYPE, const char *TEXT)
     Provides the target with the ability to record the gcc command line
     switches that have been passed to the compiler, and options that
     are enabled.  The TYPE argument specifies what is being recorded.
     It can take the following values:

     'SWITCH_TYPE_PASSED'
          TEXT is a command line switch that has been set by the user.

     'SWITCH_TYPE_ENABLED'
          TEXT is an option which has been enabled.  This might be as a
          direct result of a command line switch, or because it is
          enabled by default or because it has been enabled as a side
          effect of a different command line switch.  For example, the
          '-O2' switch enables various different individual optimization
          passes.

     'SWITCH_TYPE_DESCRIPTIVE'
          TEXT is either NULL or some descriptive text which should be
          ignored.  If TEXT is NULL then it is being used to warn the
          target hook that either recording is starting or ending.  The
          first time TYPE is SWITCH_TYPE_DESCRIPTIVE and TEXT is NULL,
          the warning is for start up and the second time the warning is
          for wind down.  This feature is to allow the target hook to
          make any necessary preparations before it starts to record
          switches and to perform any necessary tidying up after it has
          finished recording switches.

     'SWITCH_TYPE_LINE_START'
          This option can be ignored by this target hook.

     'SWITCH_TYPE_LINE_END'
          This option can be ignored by this target hook.

     The hook's return value must be zero.  Other return values may be
     supported in the future.

     By default this hook is set to NULL, but an example implementation
     is provided for ELF based targets.  Called ELF_RECORD_GCC_SWITCHES,
     it records the switches as ASCII text inside a new, string
     mergeable section in the assembler output file.  The name of the
     new section is provided by the
     'TARGET_ASM_RECORD_GCC_SWITCHES_SECTION' target hook.

 -- Target Hook: const char * TARGET_ASM_RECORD_GCC_SWITCHES_SECTION
     This is the name of the section that will be created by the example
     ELF implementation of the 'TARGET_ASM_RECORD_GCC_SWITCHES' target
     hook.

==============================================================================
File: gccint.info,  Node: |Data_Output|,  Next: |Uninitialized_Data|,  Prev: |File_Framework|,  Up: |Assembler_Format|
==============================================================================

                                                                   *Data_Output*

18.20.2 Output of Data
----------------------

 -- Target Hook: const char * TARGET_ASM_BYTE_OP
 -- Target Hook: const char * TARGET_ASM_ALIGNED_HI_OP
 -- Target Hook: const char * TARGET_ASM_ALIGNED_PSI_OP
 -- Target Hook: const char * TARGET_ASM_ALIGNED_SI_OP
 -- Target Hook: const char * TARGET_ASM_ALIGNED_PDI_OP
 -- Target Hook: const char * TARGET_ASM_ALIGNED_DI_OP
 -- Target Hook: const char * TARGET_ASM_ALIGNED_PTI_OP
 -- Target Hook: const char * TARGET_ASM_ALIGNED_TI_OP
 -- Target Hook: const char * TARGET_ASM_UNALIGNED_HI_OP
 -- Target Hook: const char * TARGET_ASM_UNALIGNED_PSI_OP
 -- Target Hook: const char * TARGET_ASM_UNALIGNED_SI_OP
 -- Target Hook: const char * TARGET_ASM_UNALIGNED_PDI_OP
 -- Target Hook: const char * TARGET_ASM_UNALIGNED_DI_OP
 -- Target Hook: const char * TARGET_ASM_UNALIGNED_PTI_OP
 -- Target Hook: const char * TARGET_ASM_UNALIGNED_TI_OP
     These hooks specify assembly directives for creating certain kinds
     of integer object.  The 'TARGET_ASM_BYTE_OP' directive creates a
     byte-sized object, the 'TARGET_ASM_ALIGNED_HI_OP' one creates an
     aligned two-byte object, and so on.  Any of the hooks may be
     'NULL', indicating that no suitable directive is available.

     The compiler will print these strings at the start of a new line,
     followed immediately by the object's initial value.  In most cases,
     the string should contain a tab, a pseudo-op, and then another tab.

 -- Target Hook: bool TARGET_ASM_INTEGER (rtx X, unsigned int SIZE, int
          ALIGNED_P)
     The 'assemble_integer' function uses this hook to output an integer
     object.  X is the object's value, SIZE is its size in bytes and
     ALIGNED_P indicates whether it is aligned.  The function should
     return 'true' if it was able to output the object.  If it returns
     false, 'assemble_integer' will try to split the object into smaller
     parts.

     The default implementation of this hook will use the
     'TARGET_ASM_BYTE_OP' family of strings, returning 'false' when the
     relevant string is 'NULL'.

 -- Target Hook: void TARGET_ASM_DECL_END (void)
     Define this hook if the target assembler requires a special marker
     to terminate an initialized variable declaration.

 -- Target Hook: bool TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA (FILE *FILE,
          rtx X)
     A target hook to recognize RTX patterns that 'output_addr_const'
     can't deal with, and output assembly code to FILE corresponding to
     the pattern X.  This may be used to allow machine-dependent
     'UNSPEC's to appear within constants.

     If target hook fails to recognize a pattern, it must return
     'false', so that a standard error message is printed.  If it prints
     an error message itself, by calling, for example,
     'output_operand_lossage', it may just return 'true'.

 -- Macro: ASM_OUTPUT_ASCII (STREAM, PTR, LEN)
     A C statement to output to the stdio stream STREAM an assembler
     instruction to assemble a string constant containing the LEN bytes
     at PTR.  PTR will be a C expression of type 'char *' and LEN a C
     expression of type 'int'.

     If the assembler has a '.ascii' pseudo-op as found in the Berkeley
     Unix assembler, do not define the macro 'ASM_OUTPUT_ASCII'.

 -- Macro: ASM_OUTPUT_FDESC (STREAM, DECL, N)
     A C statement to output word N of a function descriptor for DECL.
     This must be defined if 'TARGET_VTABLE_USES_DESCRIPTORS' is
     defined, and is otherwise unused.

 -- Macro: CONSTANT_POOL_BEFORE_FUNCTION
     You may define this macro as a C expression.  You should define the
     expression to have a nonzero value if GCC should output the
     constant pool for a function before the code for the function, or a
     zero value if GCC should output the constant pool after the
     function.  If you do not define this macro, the usual case, GCC
     will output the constant pool before the function.

 -- Macro: ASM_OUTPUT_POOL_PROLOGUE (FILE, FUNNAME, FUNDECL, SIZE)
     A C statement to output assembler commands to define the start of
     the constant pool for a function.  FUNNAME is a string giving the
     name of the function.  Should the return type of the function be
     required, it can be obtained via FUNDECL.  SIZE is the size, in
     bytes, of the constant pool that will be written immediately after
     this call.

     If no constant-pool prefix is required, the usual case, this macro
     need not be defined.

 -- Macro: ASM_OUTPUT_SPECIAL_POOL_ENTRY (FILE, X, MODE, ALIGN, LABELNO,
          JUMPTO)
     A C statement (with or without semicolon) to output a constant in
     the constant pool, if it needs special treatment.  (This macro need
     not do anything for RTL expressions that can be output normally.)

     The argument FILE is the standard I/O stream to output the
     assembler code on.  X is the RTL expression for the constant to
     output, and MODE is the machine mode (in case X is a 'const_int').
     ALIGN is the required alignment for the value X; you should output
     an assembler directive to force this much alignment.

     The argument LABELNO is a number to use in an internal label for
     the address of this pool entry.  The definition of this macro is
     responsible for outputting the label definition at the proper
     place.  Here is how to do this:

          (*targetm.asm_out.internal_label) (FILE, "LC", LABELNO);

     When you output a pool entry specially, you should end with a
     'goto' to the label JUMPTO.  This will prevent the same pool entry
     from being output a second time in the usual manner.

     You need not define this macro if it would do nothing.

 -- Macro: ASM_OUTPUT_POOL_EPILOGUE (FILE FUNNAME FUNDECL SIZE)
     A C statement to output assembler commands to at the end of the
     constant pool for a function.  FUNNAME is a string giving the name
     of the function.  Should the return type of the function be
     required, you can obtain it via FUNDECL.  SIZE is the size, in
     bytes, of the constant pool that GCC wrote immediately before this
     call.

     If no constant-pool epilogue is required, the usual case, you need
     not define this macro.

 -- Macro: IS_ASM_LOGICAL_LINE_SEPARATOR (C, STR)
     Define this macro as a C expression which is nonzero if C is used
     as a logical line separator by the assembler.  STR points to the
     position in the string where C was found; this can be used if a
     line separator uses multiple characters.

     If you do not define this macro, the default is that only the
     character ';' is treated as a logical line separator.

 -- Target Hook: const char * TARGET_ASM_OPEN_PAREN
 -- Target Hook: const char * TARGET_ASM_CLOSE_PAREN
     These target hooks are C string constants, describing the syntax in
     the assembler for grouping arithmetic expressions.  If not
     overridden, they default to normal parentheses, which is correct
     for most assemblers.

 These macros are provided by 'real.h' for writing the definitions of
'ASM_OUTPUT_DOUBLE' and the like:

 -- Macro: REAL_VALUE_TO_TARGET_SINGLE (X, L)
 -- Macro: REAL_VALUE_TO_TARGET_DOUBLE (X, L)
 -- Macro: REAL_VALUE_TO_TARGET_LONG_DOUBLE (X, L)
 -- Macro: REAL_VALUE_TO_TARGET_DECIMAL32 (X, L)
 -- Macro: REAL_VALUE_TO_TARGET_DECIMAL64 (X, L)
 -- Macro: REAL_VALUE_TO_TARGET_DECIMAL128 (X, L)
     These translate X, of type 'REAL_VALUE_TYPE', to the target's
     floating point representation, and store its bit pattern in the
     variable L.  For 'REAL_VALUE_TO_TARGET_SINGLE' and
     'REAL_VALUE_TO_TARGET_DECIMAL32', this variable should be a simple
     'long int'.  For the others, it should be an array of 'long int'.
     The number of elements in this array is determined by the size of
     the desired target floating point data type: 32 bits of it go in
     each 'long int' array element.  Each array element holds 32 bits of
     the result, even if 'long int' is wider than 32 bits on the host
     machine.

     The array element values are designed so that you can print them
     out using 'fprintf' in the order they should appear in the target
     machine's memory.

==============================================================================
File: gccint.info,  Node: |Uninitialized_Data|,  Next: |Label_Output|,  Prev: |Data_Output|,  Up: |Assembler_Format|
==============================================================================

                                                            *Uninitialized_Data*

18.20.3 Output of Uninitialized Variables
-----------------------------------------

Each of the macros in this section is used to do the whole job of
outputting a single uninitialized variable.

 -- Macro: ASM_OUTPUT_COMMON (STREAM, NAME, SIZE, ROUNDED)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     the assembler definition of a common-label named NAME whose size is
     SIZE bytes.  The variable ROUNDED is the size rounded up to
     whatever alignment the caller wants.  It is possible that SIZE may
     be zero, for instance if a struct with no other member than a
     zero-length array is defined.  In this case, the backend must
     output a symbol definition that allocates at least one byte, both
     so that the address of the resulting object does not compare equal
     to any other, and because some object formats cannot even express
     the concept of a zero-sized common symbol, as that is how they
     represent an ordinary undefined external.

     Use the expression 'assemble_name (STREAM, NAME)' to output the
     name itself; before and after that, output the additional assembler
     syntax for defining the name, and a newline.

     This macro controls how the assembler definitions of uninitialized
     common global variables are output.

 -- Macro: ASM_OUTPUT_ALIGNED_COMMON (STREAM, NAME, SIZE, ALIGNMENT)
     Like 'ASM_OUTPUT_COMMON' except takes the required alignment as a
     separate, explicit argument.  If you define this macro, it is used
     in place of 'ASM_OUTPUT_COMMON', and gives you more flexibility in
     handling the required alignment of the variable.  The alignment is
     specified as the number of bits.

 -- Macro: ASM_OUTPUT_ALIGNED_DECL_COMMON (STREAM, DECL, NAME, SIZE,
          ALIGNMENT)
     Like 'ASM_OUTPUT_ALIGNED_COMMON' except that DECL of the variable
     to be output, if there is one, or 'NULL_TREE' if there is no
     corresponding variable.  If you define this macro, GCC will use it
     in place of both 'ASM_OUTPUT_COMMON' and
     'ASM_OUTPUT_ALIGNED_COMMON'.  Define this macro when you need to
     see the variable's decl in order to chose what to output.

 -- Macro: ASM_OUTPUT_ALIGNED_BSS (STREAM, DECL, NAME, SIZE, ALIGNMENT)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     the assembler definition of uninitialized global DECL named NAME
     whose size is SIZE bytes.  The variable ALIGNMENT is the alignment
     specified as the number of bits.

     Try to use function 'asm_output_aligned_bss' defined in file
     'varasm.c' when defining this macro.  If unable, use the expression
     'assemble_name (STREAM, NAME)' to output the name itself; before
     and after that, output the additional assembler syntax for defining
     the name, and a newline.

     There are two ways of handling global BSS.  One is to define this
     macro.  The other is to have 'TARGET_ASM_SELECT_SECTION' return a
     switchable BSS section (*note
     TARGET_HAVE_SWITCHABLE_BSS_SECTIONS::).  You do not need to do
     both.

     Some languages do not have 'common' data, and require a non-common
     form of global BSS in order to handle uninitialized globals
     efficiently.  C++ is one example of this.  However, if the target
     does not support global BSS, the front end may choose to make
     globals common in order to save space in the object file.

 -- Macro: ASM_OUTPUT_LOCAL (STREAM, NAME, SIZE, ROUNDED)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     the assembler definition of a local-common-label named NAME whose
     size is SIZE bytes.  The variable ROUNDED is the size rounded up to
     whatever alignment the caller wants.

     Use the expression 'assemble_name (STREAM, NAME)' to output the
     name itself; before and after that, output the additional assembler
     syntax for defining the name, and a newline.

     This macro controls how the assembler definitions of uninitialized
     static variables are output.

 -- Macro: ASM_OUTPUT_ALIGNED_LOCAL (STREAM, NAME, SIZE, ALIGNMENT)
     Like 'ASM_OUTPUT_LOCAL' except takes the required alignment as a
     separate, explicit argument.  If you define this macro, it is used
     in place of 'ASM_OUTPUT_LOCAL', and gives you more flexibility in
     handling the required alignment of the variable.  The alignment is
     specified as the number of bits.

 -- Macro: ASM_OUTPUT_ALIGNED_DECL_LOCAL (STREAM, DECL, NAME, SIZE,
          ALIGNMENT)
     Like 'ASM_OUTPUT_ALIGNED_LOCAL' except that DECL of the variable to
     be output, if there is one, or 'NULL_TREE' if there is no
     corresponding variable.  If you define this macro, GCC will use it
     in place of both 'ASM_OUTPUT_LOCAL' and 'ASM_OUTPUT_ALIGNED_LOCAL'.
     Define this macro when you need to see the variable's decl in order
     to chose what to output.

==============================================================================
File: gccint.info,  Node: |Label_Output|,  Next: |Initialization|,  Prev: |Uninitialized_Data|,  Up: |Assembler_Format|
==============================================================================

                                                                  *Label_Output*

18.20.4 Output and Generation of Labels
---------------------------------------

This is about outputting labels.

 -- Macro: ASM_OUTPUT_LABEL (STREAM, NAME)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     the assembler definition of a label named NAME.  Use the expression
     'assemble_name (STREAM, NAME)' to output the name itself; before
     and after that, output the additional assembler syntax for defining
     the name, and a newline.  A default definition of this macro is
     provided which is correct for most systems.

 -- Macro: ASM_OUTPUT_FUNCTION_LABEL (STREAM, NAME, DECL)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     the assembler definition of a label named NAME of a function.  Use
     the expression 'assemble_name (STREAM, NAME)' to output the name
     itself; before and after that, output the additional assembler
     syntax for defining the name, and a newline.  A default definition
     of this macro is provided which is correct for most systems.

     If this macro is not defined, then the function name is defined in
     the usual manner as a label (by means of 'ASM_OUTPUT_LABEL').

 -- Macro: ASM_OUTPUT_INTERNAL_LABEL (STREAM, NAME)
     Identical to 'ASM_OUTPUT_LABEL', except that NAME is known to refer
     to a compiler-generated label.  The default definition uses
     'assemble_name_raw', which is like 'assemble_name' except that it
     is more efficient.

 -- Macro: SIZE_ASM_OP
     A C string containing the appropriate assembler directive to
     specify the size of a symbol, without any arguments.  On systems
     that use ELF, the default (in 'config/elfos.h') is '"\t.size\t"';
     on other systems, the default is not to define this macro.

     Define this macro only if it is correct to use the default
     definitions of 'ASM_OUTPUT_SIZE_DIRECTIVE' and
     'ASM_OUTPUT_MEASURED_SIZE' for your system.  If you need your own
     custom definitions of those macros, or if you do not need explicit
     symbol sizes at all, do not define this macro.

 -- Macro: ASM_OUTPUT_SIZE_DIRECTIVE (STREAM, NAME, SIZE)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     a directive telling the assembler that the size of the symbol NAME
     is SIZE.  SIZE is a 'HOST_WIDE_INT'.  If you define 'SIZE_ASM_OP',
     a default definition of this macro is provided.

 -- Macro: ASM_OUTPUT_MEASURED_SIZE (STREAM, NAME)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     a directive telling the assembler to calculate the size of the
     symbol NAME by subtracting its address from the current address.

     If you define 'SIZE_ASM_OP', a default definition of this macro is
     provided.  The default assumes that the assembler recognizes a
     special '.' symbol as referring to the current address, and can
     calculate the difference between this and another symbol.  If your
     assembler does not recognize '.' or cannot do calculations with it,
     you will need to redefine 'ASM_OUTPUT_MEASURED_SIZE' to use some
     other technique.

 -- Macro: NO_DOLLAR_IN_LABEL
     Define this macro if the assembler does not accept the character
     '$' in label names.  By default constructors and destructors in G++
     have '$' in the identifiers.  If this macro is defined, '.' is used
     instead.

 -- Macro: NO_DOT_IN_LABEL
     Define this macro if the assembler does not accept the character
     '.' in label names.  By default constructors and destructors in G++
     have names that use '.'.  If this macro is defined, these names are
     rewritten to avoid '.'.

 -- Macro: TYPE_ASM_OP
     A C string containing the appropriate assembler directive to
     specify the type of a symbol, without any arguments.  On systems
     that use ELF, the default (in 'config/elfos.h') is '"\t.type\t"';
     on other systems, the default is not to define this macro.

     Define this macro only if it is correct to use the default
     definition of 'ASM_OUTPUT_TYPE_DIRECTIVE' for your system.  If you
     need your own custom definition of this macro, or if you do not
     need explicit symbol types at all, do not define this macro.

 -- Macro: TYPE_OPERAND_FMT
     A C string which specifies (using 'printf' syntax) the format of
     the second operand to 'TYPE_ASM_OP'.  On systems that use ELF, the
     default (in 'config/elfos.h') is '"@%s"'; on other systems, the
     default is not to define this macro.

     Define this macro only if it is correct to use the default
     definition of 'ASM_OUTPUT_TYPE_DIRECTIVE' for your system.  If you
     need your own custom definition of this macro, or if you do not
     need explicit symbol types at all, do not define this macro.

 -- Macro: ASM_OUTPUT_TYPE_DIRECTIVE (STREAM, TYPE)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     a directive telling the assembler that the type of the symbol NAME
     is TYPE.  TYPE is a C string; currently, that string is always
     either '"function"' or '"object"', but you should not count on
     this.

     If you define 'TYPE_ASM_OP' and 'TYPE_OPERAND_FMT', a default
     definition of this macro is provided.

 -- Macro: ASM_DECLARE_FUNCTION_NAME (STREAM, NAME, DECL)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     any text necessary for declaring the name NAME of a function which
     is being defined.  This macro is responsible for outputting the
     label definition (perhaps using 'ASM_OUTPUT_FUNCTION_LABEL').  The
     argument DECL is the 'FUNCTION_DECL' tree node representing the
     function.

     If this macro is not defined, then the function name is defined in
     the usual manner as a label (by means of
     'ASM_OUTPUT_FUNCTION_LABEL').

     You may wish to use 'ASM_OUTPUT_TYPE_DIRECTIVE' in the definition
     of this macro.

 -- Macro: ASM_DECLARE_FUNCTION_SIZE (STREAM, NAME, DECL)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     any text necessary for declaring the size of a function which is
     being defined.  The argument NAME is the name of the function.  The
     argument DECL is the 'FUNCTION_DECL' tree node representing the
     function.

     If this macro is not defined, then the function size is not
     defined.

     You may wish to use 'ASM_OUTPUT_MEASURED_SIZE' in the definition of
     this macro.

 -- Macro: ASM_DECLARE_COLD_FUNCTION_NAME (STREAM, NAME, DECL)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     any text necessary for declaring the name NAME of a cold function
     partition which is being defined.  This macro is responsible for
     outputting the label definition (perhaps using
     'ASM_OUTPUT_FUNCTION_LABEL').  The argument DECL is the
     'FUNCTION_DECL' tree node representing the function.

     If this macro is not defined, then the cold partition name is
     defined in the usual manner as a label (by means of
     'ASM_OUTPUT_LABEL').

     You may wish to use 'ASM_OUTPUT_TYPE_DIRECTIVE' in the definition
     of this macro.

 -- Macro: ASM_DECLARE_COLD_FUNCTION_SIZE (STREAM, NAME, DECL)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     any text necessary for declaring the size of a cold function
     partition which is being defined.  The argument NAME is the name of
     the cold partition of the function.  The argument DECL is the
     'FUNCTION_DECL' tree node representing the function.

     If this macro is not defined, then the partition size is not
     defined.

     You may wish to use 'ASM_OUTPUT_MEASURED_SIZE' in the definition of
     this macro.

 -- Macro: ASM_DECLARE_OBJECT_NAME (STREAM, NAME, DECL)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     any text necessary for declaring the name NAME of an initialized
     variable which is being defined.  This macro must output the label
     definition (perhaps using 'ASM_OUTPUT_LABEL').  The argument DECL
     is the 'VAR_DECL' tree node representing the variable.

     If this macro is not defined, then the variable name is defined in
     the usual manner as a label (by means of 'ASM_OUTPUT_LABEL').

     You may wish to use 'ASM_OUTPUT_TYPE_DIRECTIVE' and/or
     'ASM_OUTPUT_SIZE_DIRECTIVE' in the definition of this macro.

 -- Target Hook: void TARGET_ASM_DECLARE_CONSTANT_NAME (FILE *FILE,
          const char *NAME, const_tree EXPR, HOST_WIDE_INT SIZE)
     A target hook to output to the stdio stream FILE any text necessary
     for declaring the name NAME of a constant which is being defined.
     This target hook is responsible for outputting the label definition
     (perhaps using 'assemble_label').  The argument EXP is the value of
     the constant, and SIZE is the size of the constant in bytes.  The
     NAME will be an internal label.

     The default version of this target hook, define the NAME in the
     usual manner as a label (by means of 'assemble_label').

     You may wish to use 'ASM_OUTPUT_TYPE_DIRECTIVE' in this target
     hook.

 -- Macro: ASM_DECLARE_REGISTER_GLOBAL (STREAM, DECL, REGNO, NAME)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     any text necessary for claiming a register REGNO for a global
     variable DECL with name NAME.

     If you don't define this macro, that is equivalent to defining it
     to do nothing.

 -- Macro: ASM_FINISH_DECLARE_OBJECT (STREAM, DECL, TOPLEVEL, ATEND)
     A C statement (sans semicolon) to finish up declaring a variable
     name once the compiler has processed its initializer fully and thus
     has had a chance to determine the size of an array when controlled
     by an initializer.  This is used on systems where it's necessary to
     declare something about the size of the object.

     If you don't define this macro, that is equivalent to defining it
     to do nothing.

     You may wish to use 'ASM_OUTPUT_SIZE_DIRECTIVE' and/or
     'ASM_OUTPUT_MEASURED_SIZE' in the definition of this macro.

 -- Target Hook: void TARGET_ASM_GLOBALIZE_LABEL (FILE *STREAM, const
          char *NAME)
     This target hook is a function to output to the stdio stream STREAM
     some commands that will make the label NAME global; that is,
     available for reference from other files.

     The default implementation relies on a proper definition of
     'GLOBAL_ASM_OP'.

 -- Target Hook: void TARGET_ASM_GLOBALIZE_DECL_NAME (FILE *STREAM, tree
          DECL)
     This target hook is a function to output to the stdio stream STREAM
     some commands that will make the name associated with DECL global;
     that is, available for reference from other files.

     The default implementation uses the TARGET_ASM_GLOBALIZE_LABEL
     target hook.

 -- Target Hook: void TARGET_ASM_ASSEMBLE_UNDEFINED_DECL (FILE *STREAM,
          const char *NAME, const_tree DECL)
     This target hook is a function to output to the stdio stream STREAM
     some commands that will declare the name associated with DECL which
     is not defined in the current translation unit.  Most assemblers do
     not require anything to be output in this case.

 -- Macro: ASM_WEAKEN_LABEL (STREAM, NAME)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     some commands that will make the label NAME weak; that is,
     available for reference from other files but only used if no other
     definition is available.  Use the expression 'assemble_name
     (STREAM, NAME)' to output the name itself; before and after that,
     output the additional assembler syntax for making that name weak,
     and a newline.

     If you don't define this macro or 'ASM_WEAKEN_DECL', GCC will not
     support weak symbols and you should not define the 'SUPPORTS_WEAK'
     macro.

 -- Macro: ASM_WEAKEN_DECL (STREAM, DECL, NAME, VALUE)
     Combines (and replaces) the function of 'ASM_WEAKEN_LABEL' and
     'ASM_OUTPUT_WEAK_ALIAS', allowing access to the associated function
     or variable decl.  If VALUE is not 'NULL', this C statement should
     output to the stdio stream STREAM assembler code which defines
     (equates) the weak symbol NAME to have the value VALUE.  If VALUE
     is 'NULL', it should output commands to make NAME weak.

 -- Macro: ASM_OUTPUT_WEAKREF (STREAM, DECL, NAME, VALUE)
     Outputs a directive that enables NAME to be used to refer to symbol
     VALUE with weak-symbol semantics.  'decl' is the declaration of
     'name'.

 -- Macro: SUPPORTS_WEAK
     A preprocessor constant expression which evaluates to true if the
     target supports weak symbols.

     If you don't define this macro, 'defaults.h' provides a default
     definition.  If either 'ASM_WEAKEN_LABEL' or 'ASM_WEAKEN_DECL' is
     defined, the default definition is '1'; otherwise, it is '0'.

 -- Macro: TARGET_SUPPORTS_WEAK
     A C expression which evaluates to true if the target supports weak
     symbols.

     If you don't define this macro, 'defaults.h' provides a default
     definition.  The default definition is '(SUPPORTS_WEAK)'.  Define
     this macro if you want to control weak symbol support with a
     compiler flag such as '-melf'.

 -- Macro: MAKE_DECL_ONE_ONLY (DECL)
     A C statement (sans semicolon) to mark DECL to be emitted as a
     public symbol such that extra copies in multiple translation units
     will be discarded by the linker.  Define this macro if your object
     file format provides support for this concept, such as the 'COMDAT'
     section flags in the Microsoft Windows PE/COFF format, and this
     support requires changes to DECL, such as putting it in a separate
     section.

 -- Macro: SUPPORTS_ONE_ONLY
     A C expression which evaluates to true if the target supports
     one-only semantics.

     If you don't define this macro, 'varasm.c' provides a default
     definition.  If 'MAKE_DECL_ONE_ONLY' is defined, the default
     definition is '1'; otherwise, it is '0'.  Define this macro if you
     want to control one-only symbol support with a compiler flag, or if
     setting the 'DECL_ONE_ONLY' flag is enough to mark a declaration to
     be emitted as one-only.

 -- Target Hook: void TARGET_ASM_ASSEMBLE_VISIBILITY (tree DECL, int
          VISIBILITY)
     This target hook is a function to output to ASM_OUT_FILE some
     commands that will make the symbol(s) associated with DECL have
     hidden, protected or internal visibility as specified by
     VISIBILITY.

 -- Macro: TARGET_WEAK_NOT_IN_ARCHIVE_TOC
     A C expression that evaluates to true if the target's linker
     expects that weak symbols do not appear in a static archive's table
     of contents.  The default is '0'.

     Leaving weak symbols out of an archive's table of contents means
     that, if a symbol will only have a definition in one translation
     unit and will have undefined references from other translation
     units, that symbol should not be weak.  Defining this macro to be
     nonzero will thus have the effect that certain symbols that would
     normally be weak (explicit template instantiations, and vtables for
     polymorphic classes with noninline key methods) will instead be
     nonweak.

     The C++ ABI requires this macro to be zero.  Define this macro for
     targets where full C++ ABI compliance is impossible and where
     linker restrictions require weak symbols to be left out of a static
     archive's table of contents.

 -- Macro: ASM_OUTPUT_EXTERNAL (STREAM, DECL, NAME)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     any text necessary for declaring the name of an external symbol
     named NAME which is referenced in this compilation but not defined.
     The value of DECL is the tree node for the declaration.

     This macro need not be defined if it does not need to output
     anything.  The GNU assembler and most Unix assemblers don't require
     anything.

 -- Target Hook: void TARGET_ASM_EXTERNAL_LIBCALL (rtx SYMREF)
     This target hook is a function to output to ASM_OUT_FILE an
     assembler pseudo-op to declare a library function name external.
     The name of the library function is given by SYMREF, which is a
     'symbol_ref'.

 -- Target Hook: void TARGET_ASM_MARK_DECL_PRESERVED (const char
          *SYMBOL)
     This target hook is a function to output to ASM_OUT_FILE an
     assembler directive to annotate SYMBOL as used.  The Darwin target
     uses the .no_dead_code_strip directive.

 -- Macro: ASM_OUTPUT_LABELREF (STREAM, NAME)
     A C statement (sans semicolon) to output to the stdio stream STREAM
     a reference in assembler syntax to a label named NAME.  This should
     add '_' to the front of the name, if that is customary on your
     operating system, as it is in most Berkeley Unix systems.  This
     macro is used in 'assemble_name'.

 -- Target Hook: tree TARGET_MANGLE_ASSEMBLER_NAME (const char *NAME)
     Given a symbol NAME, perform same mangling as 'varasm.c''s
     'assemble_name', but in memory rather than to a file stream,
     returning result as an 'IDENTIFIER_NODE'.  Required for correct LTO
     symtabs.  The default implementation calls the
     'TARGET_STRIP_NAME_ENCODING' hook and then prepends the
     'USER_LABEL_PREFIX', if any.

 -- Macro: ASM_OUTPUT_SYMBOL_REF (STREAM, SYM)
     A C statement (sans semicolon) to output a reference to
     'SYMBOL_REF' SYM.  If not defined, 'assemble_name' will be used to
     output the name of the symbol.  This macro may be used to modify
     the way a symbol is referenced depending on information encoded by
     'TARGET_ENCODE_SECTION_INFO'.

 -- Macro: ASM_OUTPUT_LABEL_REF (STREAM, BUF)
     A C statement (sans semicolon) to output a reference to BUF, the
     result of 'ASM_GENERATE_INTERNAL_LABEL'.  If not defined,
     'assemble_name' will be used to output the name of the symbol.
     This macro is not used by 'output_asm_label', or the '%l' specifier
     that calls it; the intention is that this macro should be set when
     it is necessary to output a label differently when its address is
     being taken.

 -- Target Hook: void TARGET_ASM_INTERNAL_LABEL (FILE *STREAM, const
          char *PREFIX, unsigned long LABELNO)
     A function to output to the stdio stream STREAM a label whose name
     is made from the string PREFIX and the number LABELNO.

     It is absolutely essential that these labels be distinct from the
     labels used for user-level functions and variables.  Otherwise,
     certain programs will have name conflicts with internal labels.

     It is desirable to exclude internal labels from the symbol table of
     the object file.  Most assemblers have a naming convention for
     labels that should be excluded; on many systems, the letter 'L' at
     the beginning of a label has this effect.  You should find out what
     convention your system uses, and follow it.

     The default version of this function utilizes
     'ASM_GENERATE_INTERNAL_LABEL'.

 -- Macro: ASM_OUTPUT_DEBUG_LABEL (STREAM, PREFIX, NUM)
     A C statement to output to the stdio stream STREAM a debug info
     label whose name is made from the string PREFIX and the number NUM.
     This is useful for VLIW targets, where debug info labels may need
     to be treated differently than branch target labels.  On some
     systems, branch target labels must be at the beginning of
     instruction bundles, but debug info labels can occur in the middle
     of instruction bundles.

     If this macro is not defined, then
     '(*targetm.asm_out.internal_label)' will be used.

 -- Macro: ASM_GENERATE_INTERNAL_LABEL (STRING, PREFIX, NUM)
     A C statement to store into the string STRING a label whose name is
     made from the string PREFIX and the number NUM.

     This string, when output subsequently by 'assemble_name', should
     produce the output that '(*targetm.asm_out.internal_label)' would
     produce with the same PREFIX and NUM.

     If the string begins with '*', then 'assemble_name' will output the
     rest of the string unchanged.  It is often convenient for
     'ASM_GENERATE_INTERNAL_LABEL' to use '*' in this way.  If the
     string doesn't start with '*', then 'ASM_OUTPUT_LABELREF' gets to
     output the string, and may change it.  (Of course,
     'ASM_OUTPUT_LABELREF' is also part of your machine description, so
     you should know what it does on your machine.)

 -- Macro: ASM_FORMAT_PRIVATE_NAME (OUTVAR, NAME, NUMBER)
     A C expression to assign to OUTVAR (which is a variable of type
     'char *') a newly allocated string made from the string NAME and
     the number NUMBER, with some suitable punctuation added.  Use
     'alloca' to get space for the string.

     The string will be used as an argument to 'ASM_OUTPUT_LABELREF' to
     produce an assembler label for an internal static variable whose
     name is NAME.  Therefore, the string must be such as to result in
     valid assembler code.  The argument NUMBER is different each time
     this macro is executed; it prevents conflicts between
     similarly-named internal static variables in different scopes.

     Ideally this string should not be a valid C identifier, to prevent
     any conflict with the user's own symbols.  Most assemblers allow
     periods or percent signs in assembler symbols; putting at least one
     of these between the name and the number will suffice.

     If this macro is not defined, a default definition will be provided
     which is correct for most systems.

 -- Macro: ASM_OUTPUT_DEF (STREAM, NAME, VALUE)
     A C statement to output to the stdio stream STREAM assembler code
     which defines (equates) the symbol NAME to have the value VALUE.

     If 'SET_ASM_OP' is defined, a default definition is provided which
     is correct for most systems.

 -- Macro: ASM_OUTPUT_DEF_FROM_DECLS (STREAM, DECL_OF_NAME,
          DECL_OF_VALUE)
     A C statement to output to the stdio stream STREAM assembler code
     which defines (equates) the symbol whose tree node is DECL_OF_NAME
     to have the value of the tree node DECL_OF_VALUE.  This macro will
     be used in preference to 'ASM_OUTPUT_DEF' if it is defined and if
     the tree nodes are available.

     If 'SET_ASM_OP' is defined, a default definition is provided which
     is correct for most systems.

 -- Macro: TARGET_DEFERRED_OUTPUT_DEFS (DECL_OF_NAME, DECL_OF_VALUE)
     A C statement that evaluates to true if the assembler code which
     defines (equates) the symbol whose tree node is DECL_OF_NAME to
     have the value of the tree node DECL_OF_VALUE should be emitted
     near the end of the current compilation unit.  The default is to
     not defer output of defines.  This macro affects defines output by
     'ASM_OUTPUT_DEF' and 'ASM_OUTPUT_DEF_FROM_DECLS'.

 -- Macro: ASM_OUTPUT_WEAK_ALIAS (STREAM, NAME, VALUE)
     A C statement to output to the stdio stream STREAM assembler code
     which defines (equates) the weak symbol NAME to have the value
     VALUE.  If VALUE is 'NULL', it defines NAME as an undefined weak
     symbol.

     Define this macro if the target only supports weak aliases; define
     'ASM_OUTPUT_DEF' instead if possible.

 -- Macro: OBJC_GEN_METHOD_LABEL (BUF, IS_INST, CLASS_NAME, CAT_NAME,
          SEL_NAME)
     Define this macro to override the default assembler names used for
     Objective-C methods.

     The default name is a unique method number followed by the name of
     the class (e.g. '_1_Foo').  For methods in categories, the name of
     the category is also included in the assembler name (e.g.
     '_1_Foo_Bar').

     These names are safe on most systems, but make debugging difficult
     since the method's selector is not present in the name.  Therefore,
     particular systems define other ways of computing names.

     BUF is an expression of type 'char *' which gives you a buffer in
     which to store the name; its length is as long as CLASS_NAME,
     CAT_NAME and SEL_NAME put together, plus 50 characters extra.

     The argument IS_INST specifies whether the method is an instance
     method or a class method; CLASS_NAME is the name of the class;
     CAT_NAME is the name of the category (or 'NULL' if the method is
     not in a category); and SEL_NAME is the name of the selector.

     On systems where the assembler can handle quoted names, you can use
     this macro to provide more human-readable names.

==============================================================================
File: gccint.info,  Node: |Initialization|,  Next: |Macros_for_Initialization|,  Prev: |Label_Output|,  Up: |Assembler_Format|
==============================================================================

                                                                *Initialization*

18.20.5 How Initialization Functions Are Handled
------------------------------------------------

The compiled code for certain languages includes "constructors" (also
called "initialization routines")--functions to initialize data in the
program when the program is started.  These functions need to be called
before the program is "started"--that is to say, before 'main' is
called.

 Compiling some languages generates "destructors" (also called
"termination routines") that should be called when the program
terminates.

 To make the initialization and termination functions work, the compiler
must output something in the assembler code to cause those functions to
be called at the appropriate time.  When you port the compiler to a new
system, you need to specify how to do this.

 There are two major ways that GCC currently supports the execution of
initialization and termination functions.  Each way has two variants.
Much of the structure is common to all four variations.

 The linker must build two lists of these functions--a list of
initialization functions, called '__CTOR_LIST__', and a list of
termination functions, called '__DTOR_LIST__'.

 Each list always begins with an ignored function pointer (which may
hold 0, -1, or a count of the function pointers after it, depending on
the environment).  This is followed by a series of zero or more function
pointers to constructors (or destructors), followed by a function
pointer containing zero.

 Depending on the operating system and its executable file format,
either 'crtstuff.c' or 'libgcc2.c' traverses these lists at startup time
and exit time.  Constructors are called in reverse order of the list;
destructors in forward order.

 The best way to handle static constructors works only for object file
formats which provide arbitrarily-named sections.  A section is set
aside for a list of constructors, and another for a list of destructors.
Traditionally these are called '.ctors' and '.dtors'.  Each object file
that defines an initialization function also puts a word in the
constructor section to point to that function.  The linker accumulates
all these words into one contiguous '.ctors' section.  Termination
functions are handled similarly.

 This method will be chosen as the default by 'target-def.h' if
'TARGET_ASM_NAMED_SECTION' is defined.  A target that does not support
arbitrary sections, but does support special designated constructor and
destructor sections may define 'CTORS_SECTION_ASM_OP' and
'DTORS_SECTION_ASM_OP' to achieve the same effect.

 When arbitrary sections are available, there are two variants,
depending upon how the code in 'crtstuff.c' is called.  On systems that
support a ".init" section which is executed at program startup, parts of
'crtstuff.c' are compiled into that section.  The program is linked by
the 'gcc' driver like this:

     ld -o OUTPUT_FILE crti.o crtbegin.o ... -lgcc crtend.o crtn.o

 The prologue of a function ('__init') appears in the '.init' section of
'crti.o'; the epilogue appears in 'crtn.o'.  Likewise for the function
'__fini' in the ".fini" section.  Normally these files are provided by
the operating system or by the GNU C library, but are provided by GCC
for a few targets.

 The objects 'crtbegin.o' and 'crtend.o' are (for most targets) compiled
from 'crtstuff.c'.  They contain, among other things, code fragments
within the '.init' and '.fini' sections that branch to routines in the
'.text' section.  The linker will pull all parts of a section together,
which results in a complete '__init' function that invokes the routines
we need at startup.

 To use this variant, you must define the 'INIT_SECTION_ASM_OP' macro
properly.

 If no init section is available, when GCC compiles any function called
'main' (or more accurately, any function designated as a program entry
point by the language front end calling 'expand_main_function'), it
inserts a procedure call to '__main' as the first executable code after
the function prologue.  The '__main' function is defined in 'libgcc2.c'
and runs the global constructors.

 In file formats that don't support arbitrary sections, there are again
two variants.  In the simplest variant, the GNU linker (GNU 'ld') and an
'a.out' format must be used.  In this case, 'TARGET_ASM_CONSTRUCTOR' is
defined to produce a '.stabs' entry of type 'N_SETT', referencing the
name '__CTOR_LIST__', and with the address of the void function
containing the initialization code as its value.  The GNU linker
recognizes this as a request to add the value to a "set"; the values are
accumulated, and are eventually placed in the executable as a vector in
the format described above, with a leading (ignored) count and a
trailing zero element.  'TARGET_ASM_DESTRUCTOR' is handled similarly.
Since no init section is available, the absence of 'INIT_SECTION_ASM_OP'
causes the compilation of 'main' to call '__main' as above, starting the
initialization process.

 The last variant uses neither arbitrary sections nor the GNU linker.
This is preferable when you want to do dynamic linking and when using
file formats which the GNU linker does not support, such as 'ECOFF'.  In
this case, 'TARGET_HAVE_CTORS_DTORS' is false, initialization and
termination functions are recognized simply by their names.  This
requires an extra program in the linkage step, called 'collect2'.  This
program pretends to be the linker, for use with GCC; it does its job by
running the ordinary linker, but also arranges to include the vectors of
initialization and termination functions.  These functions are called
via '__main' as described above.  In order to use this method,
'use_collect2' must be defined in the target in 'config.gcc'.

 The following section describes the specific macros that control and
customize the handling of initialization and termination functions.

==============================================================================
File: gccint.info,  Node: |Macros_for_Initialization|,  Next: |Instruction_Output|,  Prev: |Initialization|,  Up: |Assembler_Format|
==============================================================================

                                                     *Macros_for_Initialization*

18.20.6 Macros Controlling Initialization Routines
--------------------------------------------------

Here are the macros that control how the compiler handles initialization
and termination functions:

 -- Macro: INIT_SECTION_ASM_OP
     If defined, a C string constant, including spacing, for the
     assembler operation to identify the following data as
     initialization code.  If not defined, GCC will assume such a
     section does not exist.  When you are using special sections for
     initialization and termination functions, this macro also controls
     how 'crtstuff.c' and 'libgcc2.c' arrange to run the initialization
     functions.

 -- Macro: HAS_INIT_SECTION
     If defined, 'main' will not call '__main' as described above.  This
     macro should be defined for systems that control start-up code on a
     symbol-by-symbol basis, such as OSF/1, and should not be defined
     explicitly for systems that support 'INIT_SECTION_ASM_OP'.

 -- Macro: LD_INIT_SWITCH
     If defined, a C string constant for a switch that tells the linker
     that the following symbol is an initialization routine.

 -- Macro: LD_FINI_SWITCH
     If defined, a C string constant for a switch that tells the linker
     that the following symbol is a finalization routine.

 -- Macro: COLLECT_SHARED_INIT_FUNC (STREAM, FUNC)
     If defined, a C statement that will write a function that can be
     automatically called when a shared library is loaded.  The function
     should call FUNC, which takes no arguments.  If not defined, and
     the object format requires an explicit initialization function,
     then a function called '_GLOBAL__DI' will be generated.

     This function and the following one are used by collect2 when
     linking a shared library that needs constructors or destructors, or
     has DWARF2 exception tables embedded in the code.

 -- Macro: COLLECT_SHARED_FINI_FUNC (STREAM, FUNC)
     If defined, a C statement that will write a function that can be
     automatically called when a shared library is unloaded.  The
     function should call FUNC, which takes no arguments.  If not
     defined, and the object format requires an explicit finalization
     function, then a function called '_GLOBAL__DD' will be generated.

 -- Macro: INVOKE__main
     If defined, 'main' will call '__main' despite the presence of
     'INIT_SECTION_ASM_OP'.  This macro should be defined for systems
     where the init section is not actually run automatically, but is
     still useful for collecting the lists of constructors and
     destructors.

 -- Macro: SUPPORTS_INIT_PRIORITY
     If nonzero, the C++ 'init_priority' attribute is supported and the
     compiler should emit instructions to control the order of
     initialization of objects.  If zero, the compiler will issue an
     error message upon encountering an 'init_priority' attribute.

 -- Target Hook: bool TARGET_HAVE_CTORS_DTORS
     This value is true if the target supports some "native" method of
     collecting constructors and destructors to be run at startup and
     exit.  It is false if we must use 'collect2'.

 -- Target Hook: void TARGET_ASM_CONSTRUCTOR (rtx SYMBOL, int PRIORITY)
     If defined, a function that outputs assembler code to arrange to
     call the function referenced by SYMBOL at initialization time.

     Assume that SYMBOL is a 'SYMBOL_REF' for a function taking no
     arguments and with no return value.  If the target supports
     initialization priorities, PRIORITY is a value between 0 and
     'MAX_INIT_PRIORITY'; otherwise it must be 'DEFAULT_INIT_PRIORITY'.

     If this macro is not defined by the target, a suitable default will
     be chosen if (1) the target supports arbitrary section names, (2)
     the target defines 'CTORS_SECTION_ASM_OP', or (3) 'USE_COLLECT2' is
     not defined.

 -- Target Hook: void TARGET_ASM_DESTRUCTOR (rtx SYMBOL, int PRIORITY)
     This is like 'TARGET_ASM_CONSTRUCTOR' but used for termination
     functions rather than initialization functions.

 If 'TARGET_HAVE_CTORS_DTORS' is true, the initialization routine
generated for the generated object file will have static linkage.

 If your system uses 'collect2' as the means of processing constructors,
then that program normally uses 'nm' to scan an object file for
constructor functions to be called.

 On certain kinds of systems, you can define this macro to make
'collect2' work faster (and, in some cases, make it work at all):

 -- Macro: OBJECT_FORMAT_COFF
     Define this macro if the system uses COFF (Common Object File
     Format) object files, so that 'collect2' can assume this format and
     scan object files directly for dynamic constructor/destructor
     functions.

     This macro is effective only in a native compiler; 'collect2' as
     part of a cross compiler always uses 'nm' for the target machine.

 -- Macro: REAL_NM_FILE_NAME
     Define this macro as a C string constant containing the file name
     to use to execute 'nm'.  The default is to search the path normally
     for 'nm'.

 -- Macro: NM_FLAGS
     'collect2' calls 'nm' to scan object files for static constructors
     and destructors and LTO info.  By default, '-n' is passed.  Define
     'NM_FLAGS' to a C string constant if other options are needed to
     get the same output format as GNU 'nm -n' produces.

 If your system supports shared libraries and has a program to list the
dynamic dependencies of a given library or executable, you can define
these macros to enable support for running initialization and
termination functions in shared libraries:

 -- Macro: LDD_SUFFIX
     Define this macro to a C string constant containing the name of the
     program which lists dynamic dependencies, like 'ldd' under SunOS 4.

 -- Macro: PARSE_LDD_OUTPUT (PTR)
     Define this macro to be C code that extracts filenames from the
     output of the program denoted by 'LDD_SUFFIX'.  PTR is a variable
     of type 'char *' that points to the beginning of a line of output
     from 'LDD_SUFFIX'.  If the line lists a dynamic dependency, the
     code must advance PTR to the beginning of the filename on that
     line.  Otherwise, it must set PTR to 'NULL'.

 -- Macro: SHLIB_SUFFIX
     Define this macro to a C string constant containing the default
     shared library extension of the target (e.g., '".so"').  'collect2'
     strips version information after this suffix when generating global
     constructor and destructor names.  This define is only needed on
     targets that use 'collect2' to process constructors and
     destructors.

==============================================================================
File: gccint.info,  Node: |Instruction_Output|,  Next: |Dispatch_Tables|,  Prev: |Macros_for_Initialization|,  Up: |Assembler_Format|
==============================================================================

                                                            *Instruction_Output*

18.20.7 Output of Assembler Instructions
----------------------------------------

This describes assembler instruction output.

 -- Macro: REGISTER_NAMES
     A C initializer containing the assembler's names for the machine
     registers, each one as a C string constant.  This is what
     translates register numbers in the compiler into assembler
     language.

 -- Macro: ADDITIONAL_REGISTER_NAMES
     If defined, a C initializer for an array of structures containing a
     name and a register number.  This macro defines additional names
     for hard registers, thus allowing the 'asm' option in declarations
     to refer to registers using alternate names.

 -- Macro: OVERLAPPING_REGISTER_NAMES
     If defined, a C initializer for an array of structures containing a
     name, a register number and a count of the number of consecutive
     machine registers the name overlaps.  This macro defines additional
     names for hard registers, thus allowing the 'asm' option in
     declarations to refer to registers using alternate names.  Unlike
     'ADDITIONAL_REGISTER_NAMES', this macro should be used when the
     register name implies multiple underlying registers.

     This macro should be used when it is important that a clobber in an
     'asm' statement clobbers all the underlying values implied by the
     register name.  For example, on ARM, clobbering the
     double-precision VFP register "d0" implies clobbering both
     single-precision registers "s0" and "s1".

 -- Macro: ASM_OUTPUT_OPCODE (STREAM, PTR)
     Define this macro if you are using an unusual assembler that
     requires different names for the machine instructions.

     The definition is a C statement or statements which output an
     assembler instruction opcode to the stdio stream STREAM.  The
     macro-operand PTR is a variable of type 'char *' which points to
     the opcode name in its "internal" form--the form that is written in
     the machine description.  The definition should output the opcode
     name to STREAM, performing any translation you desire, and
     increment the variable PTR to point at the end of the opcode so
     that it will not be output twice.

     In fact, your macro definition may process less than the entire
     opcode name, or more than the opcode name; but if you want to
     process text that includes '%'-sequences to substitute operands,
     you must take care of the substitution yourself.  Just be sure to
     increment PTR over whatever text should not be output normally.

     If you need to look at the operand values, they can be found as the
     elements of 'recog_data.operand'.

     If the macro definition does nothing, the instruction is output in
     the usual way.

 -- Macro: FINAL_PRESCAN_INSN (INSN, OPVEC, NOPERANDS)
     If defined, a C statement to be executed just prior to the output
     of assembler code for INSN, to modify the extracted operands so
     they will be output differently.

     Here the argument OPVEC is the vector containing the operands
     extracted from INSN, and NOPERANDS is the number of elements of the
     vector which contain meaningful data for this insn.  The contents
     of this vector are what will be used to convert the insn template
     into assembler code, so you can change the assembler output by
     changing the contents of the vector.

     This macro is useful when various assembler syntaxes share a single
     file of instruction patterns; by defining this macro differently,
     you can cause a large class of instructions to be output
     differently (such as with rearranged operands).  Naturally,
     variations in assembler syntax affecting individual insn patterns
     ought to be handled by writing conditional output routines in those
     patterns.

     If this macro is not defined, it is equivalent to a null statement.

 -- Target Hook: void TARGET_ASM_FINAL_POSTSCAN_INSN (FILE *FILE,
          rtx_insn *INSN, rtx *OPVEC, int NOPERANDS)
     If defined, this target hook is a function which is executed just
     after the output of assembler code for INSN, to change the mode of
     the assembler if necessary.

     Here the argument OPVEC is the vector containing the operands
     extracted from INSN, and NOPERANDS is the number of elements of the
     vector which contain meaningful data for this insn.  The contents
     of this vector are what was used to convert the insn template into
     assembler code, so you can change the assembler mode by checking
     the contents of the vector.

 -- Macro: PRINT_OPERAND (STREAM, X, CODE)
     A C compound statement to output to stdio stream STREAM the
     assembler syntax for an instruction operand X.  X is an RTL
     expression.

     CODE is a value that can be used to specify one of several ways of
     printing the operand.  It is used when identical operands must be
     printed differently depending on the context.  CODE comes from the
     '%' specification that was used to request printing of the operand.
     If the specification was just '%DIGIT' then CODE is 0; if the
     specification was '%LTR DIGIT' then CODE is the ASCII code for LTR.

     If X is a register, this macro should print the register's name.
     The names can be found in an array 'reg_names' whose type is 'char
     *[]'.  'reg_names' is initialized from 'REGISTER_NAMES'.

     When the machine description has a specification '%PUNCT' (a '%'
     followed by a punctuation character), this macro is called with a
     null pointer for X and the punctuation character for CODE.

 -- Macro: PRINT_OPERAND_PUNCT_VALID_P (CODE)
     A C expression which evaluates to true if CODE is a valid
     punctuation character for use in the 'PRINT_OPERAND' macro.  If
     'PRINT_OPERAND_PUNCT_VALID_P' is not defined, it means that no
     punctuation characters (except for the standard one, '%') are used
     in this way.

 -- Macro: PRINT_OPERAND_ADDRESS (STREAM, X)
     A C compound statement to output to stdio stream STREAM the
     assembler syntax for an instruction operand that is a memory
     reference whose address is X.  X is an RTL expression.

     On some machines, the syntax for a symbolic address depends on the
     section that the address refers to.  On these machines, define the
     hook 'TARGET_ENCODE_SECTION_INFO' to store the information into the
     'symbol_ref', and then check for it here.  *Note Assembler
     Format::.

 -- Macro: DBR_OUTPUT_SEQEND (FILE)
     A C statement, to be executed after all slot-filler instructions
     have been output.  If necessary, call 'dbr_sequence_length' to
     determine the number of slots filled in a sequence (zero if not
     currently outputting a sequence), to decide how many no-ops to
     output, or whatever.

     Don't define this macro if it has nothing to do, but it is helpful
     in reading assembly output if the extent of the delay sequence is
     made explicit (e.g. with white space).

 Note that output routines for instructions with delay slots must be
prepared to deal with not being output as part of a sequence (i.e. when
the scheduling pass is not run, or when no slot fillers could be found.)
The variable 'final_sequence' is null when not processing a sequence,
otherwise it contains the 'sequence' rtx being output.

 -- Macro: REGISTER_PREFIX
 -- Macro: LOCAL_LABEL_PREFIX
 -- Macro: USER_LABEL_PREFIX
 -- Macro: IMMEDIATE_PREFIX
     If defined, C string expressions to be used for the '%R', '%L',
     '%U', and '%I' options of 'asm_fprintf' (see 'final.c').  These are
     useful when a single 'md' file must support multiple assembler
     formats.  In that case, the various 'tm.h' files can define these
     macros differently.

 -- Macro: ASM_FPRINTF_EXTENSIONS (FILE, ARGPTR, FORMAT)
     If defined this macro should expand to a series of 'case'
     statements which will be parsed inside the 'switch' statement of
     the 'asm_fprintf' function.  This allows targets to define extra
     printf formats which may useful when generating their assembler
     statements.  Note that uppercase letters are reserved for future
     generic extensions to asm_fprintf, and so are not available to
     target specific code.  The output file is given by the parameter
     FILE.  The varargs input pointer is ARGPTR and the rest of the
     format string, starting the character after the one that is being
     switched upon, is pointed to by FORMAT.

 -- Macro: ASSEMBLER_DIALECT
     If your target supports multiple dialects of assembler language
     (such as different opcodes), define this macro as a C expression
     that gives the numeric index of the assembler language dialect to
     use, with zero as the first variant.

     If this macro is defined, you may use constructs of the form
          '{option0|option1|option2...}'
     in the output templates of patterns (*note Output Template::) or in
     the first argument of 'asm_fprintf'.  This construct outputs
     'option0', 'option1', 'option2', etc., if the value of
     'ASSEMBLER_DIALECT' is zero, one, two, etc.  Any special characters
     within these strings retain their usual meaning.  If there are
     fewer alternatives within the braces than the value of
     'ASSEMBLER_DIALECT', the construct outputs nothing.  If it's needed
     to print curly braces or '|' character in assembler output
     directly, '%{', '%}' and '%|' can be used.

     If you do not define this macro, the characters '{', '|' and '}' do
     not have any special meaning when used in templates or operands to
     'asm_fprintf'.

     Define the macros 'REGISTER_PREFIX', 'LOCAL_LABEL_PREFIX',
     'USER_LABEL_PREFIX' and 'IMMEDIATE_PREFIX' if you can express the
     variations in assembler language syntax with that mechanism.
     Define 'ASSEMBLER_DIALECT' and use the '{option0|option1}' syntax
     if the syntax variant are larger and involve such things as
     different opcodes or operand order.

 -- Macro: ASM_OUTPUT_REG_PUSH (STREAM, REGNO)
     A C expression to output to STREAM some assembler code which will
     push hard register number REGNO onto the stack.  The code need not
     be optimal, since this macro is used only when profiling.

 -- Macro: ASM_OUTPUT_REG_POP (STREAM, REGNO)
     A C expression to output to STREAM some assembler code which will
     pop hard register number REGNO off of the stack.  The code need not
     be optimal, since this macro is used only when profiling.

==============================================================================
File: gccint.info,  Node: |Dispatch_Tables|,  Next: |Exception_Region_Output|,  Prev: |Instruction_Output|,  Up: |Assembler_Format|
==============================================================================

                                                               *Dispatch_Tables*

18.20.8 Output of Dispatch Tables
---------------------------------

This concerns dispatch tables.

 -- Macro: ASM_OUTPUT_ADDR_DIFF_ELT (STREAM, BODY, VALUE, REL)
     A C statement to output to the stdio stream STREAM an assembler
     pseudo-instruction to generate a difference between two labels.
     VALUE and REL are the numbers of two internal labels.  The
     definitions of these labels are output using
     '(*targetm.asm_out.internal_label)', and they must be printed in
     the same way here.  For example,

          fprintf (STREAM, "\t.word L%d-L%d\n",
                   VALUE, REL)

     You must provide this macro on machines where the addresses in a
     dispatch table are relative to the table's own address.  If
     defined, GCC will also use this macro on all machines when
     producing PIC.  BODY is the body of the 'ADDR_DIFF_VEC'; it is
     provided so that the mode and flags can be read.

 -- Macro: ASM_OUTPUT_ADDR_VEC_ELT (STREAM, VALUE)
     This macro should be provided on machines where the addresses in a
     dispatch table are absolute.

     The definition should be a C statement to output to the stdio
     stream STREAM an assembler pseudo-instruction to generate a
     reference to a label.  VALUE is the number of an internal label
     whose definition is output using
     '(*targetm.asm_out.internal_label)'.  For example,

          fprintf (STREAM, "\t.word L%d\n", VALUE)

 -- Macro: ASM_OUTPUT_CASE_LABEL (STREAM, PREFIX, NUM, TABLE)
     Define this if the label before a jump-table needs to be output
     specially.  The first three arguments are the same as for
     '(*targetm.asm_out.internal_label)'; the fourth argument is the
     jump-table which follows (a 'jump_table_data' containing an
     'addr_vec' or 'addr_diff_vec').

     This feature is used on system V to output a 'swbeg' statement for
     the table.

     If this macro is not defined, these labels are output with
     '(*targetm.asm_out.internal_label)'.

 -- Macro: ASM_OUTPUT_CASE_END (STREAM, NUM, TABLE)
     Define this if something special must be output at the end of a
     jump-table.  The definition should be a C statement to be executed
     after the assembler code for the table is written.  It should write
     the appropriate code to stdio stream STREAM.  The argument TABLE is
     the jump-table insn, and NUM is the label-number of the preceding
     label.

     If this macro is not defined, nothing special is output at the end
     of the jump-table.

 -- Target Hook: void TARGET_ASM_POST_CFI_STARTPROC (FILE *, TREE)
     This target hook is used to emit assembly strings required by the
     target after the .cfi_startproc directive.  The first argument is
     the file stream to write the strings to and the second argument is
     the function's declaration.  The expected use is to add more .cfi_*
     directives.

     The default is to not output any assembly strings.

 -- Target Hook: void TARGET_ASM_EMIT_UNWIND_LABEL (FILE *STREAM, tree
          DECL, int FOR_EH, int EMPTY)
     This target hook emits a label at the beginning of each FDE.  It
     should be defined on targets where FDEs need special labels, and it
     should write the appropriate label, for the FDE associated with the
     function declaration DECL, to the stdio stream STREAM.  The third
     argument, FOR_EH, is a boolean: true if this is for an exception
     table.  The fourth argument, EMPTY, is a boolean: true if this is a
     placeholder label for an omitted FDE.

     The default is that FDEs are not given nonlocal labels.

 -- Target Hook: void TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL (FILE *STREAM)
     This target hook emits a label at the beginning of the exception
     table.  It should be defined on targets where it is desirable for
     the table to be broken up according to function.

     The default is that no label is emitted.

 -- Target Hook: void TARGET_ASM_EMIT_EXCEPT_PERSONALITY (rtx
          PERSONALITY)
     If the target implements 'TARGET_ASM_UNWIND_EMIT', this hook may be
     used to emit a directive to install a personality hook into the
     unwind info.  This hook should not be used if dwarf2 unwind info is
     used.

 -- Target Hook: void TARGET_ASM_UNWIND_EMIT (FILE *STREAM, rtx_insn
          *INSN)
     This target hook emits assembly directives required to unwind the
     given instruction.  This is only used when
     'TARGET_EXCEPT_UNWIND_INFO' returns 'UI_TARGET'.

 -- Target Hook: bool TARGET_ASM_UNWIND_EMIT_BEFORE_INSN
     True if the 'TARGET_ASM_UNWIND_EMIT' hook should be called before
     the assembly for INSN has been emitted, false if the hook should be
     called afterward.

==============================================================================
File: gccint.info,  Node: |Exception_Region_Output|,  Next: |Alignment_Output|,  Prev: |Dispatch_Tables|,  Up: |Assembler_Format|
==============================================================================

                                                       *Exception_Region_Output*

18.20.9 Assembler Commands for Exception Regions
------------------------------------------------

This describes commands marking the start and the end of an exception
region.

 -- Macro: EH_FRAME_SECTION_NAME
     If defined, a C string constant for the name of the section
     containing exception handling frame unwind information.  If not
     defined, GCC will provide a default definition if the target
     supports named sections.  'crtstuff.c' uses this macro to switch to
     the appropriate section.

     You should define this symbol if your target supports DWARF 2 frame
     unwind information and the default definition does not work.

 -- Macro: EH_FRAME_THROUGH_COLLECT2
     If defined, DWARF 2 frame unwind information will identified by
     specially named labels.  The collect2 process will locate these
     labels and generate code to register the frames.

     This might be necessary, for instance, if the system linker will
     not place the eh_frames in-between the sentinals from 'crtstuff.c',
     or if the system linker does garbage collection and sections cannot
     be marked as not to be collected.

 -- Macro: EH_TABLES_CAN_BE_READ_ONLY
     Define this macro to 1 if your target is such that no frame unwind
     information encoding used with non-PIC code will ever require a
     runtime relocation, but the linker may not support merging
     read-only and read-write sections into a single read-write section.

 -- Macro: MASK_RETURN_ADDR
     An rtx used to mask the return address found via 'RETURN_ADDR_RTX',
     so that it does not contain any extraneous set bits in it.

 -- Macro: DWARF2_UNWIND_INFO
     Define this macro to 0 if your target supports DWARF 2 frame unwind
     information, but it does not yet work with exception handling.
     Otherwise, if your target supports this information (if it defines
     'INCOMING_RETURN_ADDR_RTX' and 'OBJECT_FORMAT_ELF'), GCC will
     provide a default definition of 1.

 -- Common Target Hook: enum unwind_info_type TARGET_EXCEPT_UNWIND_INFO
          (struct gcc_options *OPTS)
     This hook defines the mechanism that will be used for exception
     handling by the target.  If the target has ABI specified unwind
     tables, the hook should return 'UI_TARGET'.  If the target is to
     use the 'setjmp'/'longjmp'-based exception handling scheme, the
     hook should return 'UI_SJLJ'.  If the target supports DWARF 2 frame
     unwind information, the hook should return 'UI_DWARF2'.

     A target may, if exceptions are disabled, choose to return
     'UI_NONE'.  This may end up simplifying other parts of
     target-specific code.  The default implementation of this hook
     never returns 'UI_NONE'.

     Note that the value returned by this hook should be constant.  It
     should not depend on anything except the command-line switches
     described by OPTS.  In particular, the setting 'UI_SJLJ' must be
     fixed at compiler start-up as C pre-processor macros and builtin
     functions related to exception handling are set up depending on
     this setting.

     The default implementation of the hook first honors the
     '--enable-sjlj-exceptions' configure option, then
     'DWARF2_UNWIND_INFO', and finally defaults to 'UI_SJLJ'.  If
     'DWARF2_UNWIND_INFO' depends on command-line options, the target
     must define this hook so that OPTS is used correctly.

 -- Common Target Hook: bool TARGET_UNWIND_TABLES_DEFAULT
     This variable should be set to 'true' if the target ABI requires
     unwinding tables even when exceptions are not used.  It must not be
     modified by command-line option processing.

 -- Macro: DONT_USE_BUILTIN_SETJMP
     Define this macro to 1 if the 'setjmp'/'longjmp'-based scheme
     should use the 'setjmp'/'longjmp' functions from the C library
     instead of the '__builtin_setjmp'/'__builtin_longjmp' machinery.

 -- Macro: JMP_BUF_SIZE
     This macro has no effect unless 'DONT_USE_BUILTIN_SETJMP' is also
     defined.  Define this macro if the default size of 'jmp_buf' buffer
     for the 'setjmp'/'longjmp'-based exception handling mechanism is
     not large enough, or if it is much too large.  The default size is
     'FIRST_PSEUDO_REGISTER * sizeof(void *)'.

 -- Macro: DWARF_CIE_DATA_ALIGNMENT
     This macro need only be defined if the target might save registers
     in the function prologue at an offset to the stack pointer that is
     not aligned to 'UNITS_PER_WORD'.  The definition should be the
     negative minimum alignment if 'STACK_GROWS_DOWNWARD' is true, and
     the positive minimum alignment otherwise.  *Note DWARF::.  Only
     applicable if the target supports DWARF 2 frame unwind information.

 -- Target Hook: bool TARGET_TERMINATE_DW2_EH_FRAME_INFO
     Contains the value true if the target should add a zero word onto
     the end of a Dwarf-2 frame info section when used for exception
     handling.  Default value is false if 'EH_FRAME_SECTION_NAME' is
     defined, and true otherwise.

 -- Target Hook: rtx TARGET_DWARF_REGISTER_SPAN (rtx REG)
     Given a register, this hook should return a parallel of registers
     to represent where to find the register pieces.  Define this hook
     if the register and its mode are represented in Dwarf in
     non-contiguous locations, or if the register should be represented
     in more than one register in Dwarf.  Otherwise, this hook should
     return 'NULL_RTX'.  If not defined, the default is to return
     'NULL_RTX'.

 -- Target Hook: machine_mode TARGET_DWARF_FRAME_REG_MODE (int REGNO)
     Given a register, this hook should return the mode which the
     corresponding Dwarf frame register should have.  This is normally
     used to return a smaller mode than the raw mode to prevent call
     clobbered parts of a register altering the frame register size

 -- Target Hook: void TARGET_INIT_DWARF_REG_SIZES_EXTRA (tree ADDRESS)
     If some registers are represented in Dwarf-2 unwind information in
     multiple pieces, define this hook to fill in information about the
     sizes of those pieces in the table used by the unwinder at runtime.
     It will be called by 'expand_builtin_init_dwarf_reg_sizes' after
     filling in a single size corresponding to each hard register;
     ADDRESS is the address of the table.

 -- Target Hook: bool TARGET_ASM_TTYPE (rtx SYM)
     This hook is used to output a reference from a frame unwinding
     table to the type_info object identified by SYM.  It should return
     'true' if the reference was output.  Returning 'false' will cause
     the reference to be output using the normal Dwarf2 routines.

 -- Target Hook: bool TARGET_ARM_EABI_UNWINDER
     This flag should be set to 'true' on targets that use an ARM EABI
     based unwinding library, and 'false' on other targets.  This
     effects the format of unwinding tables, and how the unwinder in
     entered after running a cleanup.  The default is 'false'.

==============================================================================
File: gccint.info,  Node: |Alignment_Output|,  Prev: |Exception_Region_Output|,  Up: |Assembler_Format|
==============================================================================

                                                              *Alignment_Output*

18.20.10 Assembler Commands for Alignment
-----------------------------------------

This describes commands for alignment.

 -- Macro: JUMP_ALIGN (LABEL)
     The alignment (log base 2) to put in front of LABEL, which is a
     common destination of jumps and has no fallthru incoming edge.

     This macro need not be defined if you don't want any special
     alignment to be done at such a time.  Most machine descriptions do
     not currently define the macro.

     Unless it's necessary to inspect the LABEL parameter, it is better
     to set the variable ALIGN_JUMPS in the target's
     'TARGET_OPTION_OVERRIDE'.  Otherwise, you should try to honor the
     user's selection in ALIGN_JUMPS in a 'JUMP_ALIGN' implementation.

 -- Macro: LABEL_ALIGN_AFTER_BARRIER (LABEL)
     The alignment (log base 2) to put in front of LABEL, which follows
     a 'BARRIER'.

     This macro need not be defined if you don't want any special
     alignment to be done at such a time.  Most machine descriptions do
     not currently define the macro.

 -- Macro: LOOP_ALIGN (LABEL)
     The alignment (log base 2) to put in front of LABEL that heads a
     frequently executed basic block (usually the header of a loop).

     This macro need not be defined if you don't want any special
     alignment to be done at such a time.  Most machine descriptions do
     not currently define the macro.

     Unless it's necessary to inspect the LABEL parameter, it is better
     to set the variable 'align_loops' in the target's
     'TARGET_OPTION_OVERRIDE'.  Otherwise, you should try to honor the
     user's selection in 'align_loops' in a 'LOOP_ALIGN' implementation.

 -- Macro: LABEL_ALIGN (LABEL)
     The alignment (log base 2) to put in front of LABEL.  If
     'LABEL_ALIGN_AFTER_BARRIER' / 'LOOP_ALIGN' specify a different
     alignment, the maximum of the specified values is used.

     Unless it's necessary to inspect the LABEL parameter, it is better
     to set the variable 'align_labels' in the target's
     'TARGET_OPTION_OVERRIDE'.  Otherwise, you should try to honor the
     user's selection in 'align_labels' in a 'LABEL_ALIGN'
     implementation.

 -- Macro: ASM_OUTPUT_SKIP (STREAM, NBYTES)
     A C statement to output to the stdio stream STREAM an assembler
     instruction to advance the location counter by NBYTES bytes.  Those
     bytes should be zero when loaded.  NBYTES will be a C expression of
     type 'unsigned HOST_WIDE_INT'.

 -- Macro: ASM_NO_SKIP_IN_TEXT
     Define this macro if 'ASM_OUTPUT_SKIP' should not be used in the
     text section because it fails to put zeros in the bytes that are
     skipped.  This is true on many Unix systems, where the pseudo-op to
     skip bytes produces no-op instructions rather than zeros when used
     in the text section.

 -- Macro: ASM_OUTPUT_ALIGN (STREAM, POWER)
     A C statement to output to the stdio stream STREAM an assembler
     command to advance the location counter to a multiple of 2 to the
     POWER bytes.  POWER will be a C expression of type 'int'.

 -- Macro: ASM_OUTPUT_ALIGN_WITH_NOP (STREAM, POWER)
     Like 'ASM_OUTPUT_ALIGN', except that the "nop" instruction is used
     for padding, if necessary.

 -- Macro: ASM_OUTPUT_MAX_SKIP_ALIGN (STREAM, POWER, MAX_SKIP)
     A C statement to output to the stdio stream STREAM an assembler
     command to advance the location counter to a multiple of 2 to the
     POWER bytes, but only if MAX_SKIP or fewer bytes are needed to
     satisfy the alignment request.  POWER and MAX_SKIP will be a C
     expression of type 'int'.

==============================================================================
File: gccint.info,  Node: |Debugging_Info|,  Next: |Floating_Point|,  Prev: |Assembler_Format|,  Up: |Target_Macros|
==============================================================================

                                                                *Debugging_Info*

18.21 Controlling Debugging Information Format
==========------------------------------------

This describes how to specify debugging information.

MENU

* |All_Debuggers|::      Macros that affect all debugging formats uniformly.
* |DBX_Options|::        Macros enabling specific options in DBX format.
* |DBX_Hooks|::          Hook macros for varying DBX format.
* |File_Names_and_DBX|:: Macros controlling output of file names in DBX format.
* |DWARF|::              Macros for DWARF format.
* |VMS_Debug|::          Macros for VMS debug format.

==============================================================================
File: gccint.info,  Node: |All_Debuggers|,  Next: |DBX_Options|,  Up: |Debugging_Info|
==============================================================================

                                                                 *All_Debuggers*

18.21.1 Macros Affecting All Debugging Formats
----------------------------------------------

These macros affect all debugging formats.

 -- Macro: DBX_REGISTER_NUMBER (REGNO)
     A C expression that returns the DBX register number for the
     compiler register number REGNO.  In the default macro provided, the
     value of this expression will be REGNO itself.  But sometimes there
     are some registers that the compiler knows about and DBX does not,
     or vice versa.  In such cases, some register may need to have one
     number in the compiler and another for DBX.

     If two registers have consecutive numbers inside GCC, and they can
     be used as a pair to hold a multiword value, then they _must_ have
     consecutive numbers after renumbering with 'DBX_REGISTER_NUMBER'.
     Otherwise, debuggers will be unable to access such a pair, because
     they expect register pairs to be consecutive in their own numbering
     scheme.

     If you find yourself defining 'DBX_REGISTER_NUMBER' in way that
     does not preserve register pairs, then what you must do instead is
     redefine the actual register numbering scheme.

 -- Macro: DEBUGGER_AUTO_OFFSET (X)
     A C expression that returns the integer offset value for an
     automatic variable having address X (an RTL expression).  The
     default computation assumes that X is based on the frame-pointer
     and gives the offset from the frame-pointer.  This is required for
     targets that produce debugging output for DBX and allow the
     frame-pointer to be eliminated when the '-g' option is used.

 -- Macro: DEBUGGER_ARG_OFFSET (OFFSET, X)
     A C expression that returns the integer offset value for an
     argument having address X (an RTL expression).  The nominal offset
     is OFFSET.

 -- Macro: PREFERRED_DEBUGGING_TYPE
     A C expression that returns the type of debugging output GCC should
     produce when the user specifies just '-g'.  Define this if you have
     arranged for GCC to support more than one format of debugging
     output.  Currently, the allowable values are 'DBX_DEBUG',
     'DWARF2_DEBUG', 'XCOFF_DEBUG', 'VMS_DEBUG', and
     'VMS_AND_DWARF2_DEBUG'.

     When the user specifies '-ggdb', GCC normally also uses the value
     of this macro to select the debugging output format, but with two
     exceptions.  If 'DWARF2_DEBUGGING_INFO' is defined, GCC uses the
     value 'DWARF2_DEBUG'.  Otherwise, if 'DBX_DEBUGGING_INFO' is
     defined, GCC uses 'DBX_DEBUG'.

     The value of this macro only affects the default debugging output;
     the user can always get a specific type of output by using
     '-gstabs', '-gdwarf-2', '-gxcoff', or '-gvms'.

==============================================================================
File: gccint.info,  Node: |DBX_Options|,  Next: |DBX_Hooks|,  Prev: |All_Debuggers|,  Up: |Debugging_Info|
==============================================================================

                                                                   *DBX_Options*

18.21.2 Specific Options for DBX Output
---------------------------------------

These are specific options for DBX output.

 -- Macro: DBX_DEBUGGING_INFO
     Define this macro if GCC should produce debugging output for DBX in
     response to the '-g' option.

 -- Macro: XCOFF_DEBUGGING_INFO
     Define this macro if GCC should produce XCOFF format debugging
     output in response to the '-g' option.  This is a variant of DBX
     format.

 -- Macro: DEFAULT_GDB_EXTENSIONS
     Define this macro to control whether GCC should by default generate
     GDB's extended version of DBX debugging information (assuming
     DBX-format debugging information is enabled at all).  If you don't
     define the macro, the default is 1: always generate the extended
     information if there is any occasion to.

 -- Macro: DEBUG_SYMS_TEXT
     Define this macro if all '.stabs' commands should be output while
     in the text section.

 -- Macro: ASM_STABS_OP
     A C string constant, including spacing, naming the assembler pseudo
     op to use instead of '"\t.stabs\t"' to define an ordinary debugging
     symbol.  If you don't define this macro, '"\t.stabs\t"' is used.
     This macro applies only to DBX debugging information format.

 -- Macro: ASM_STABD_OP
     A C string constant, including spacing, naming the assembler pseudo
     op to use instead of '"\t.stabd\t"' to define a debugging symbol
     whose value is the current location.  If you don't define this
     macro, '"\t.stabd\t"' is used.  This macro applies only to DBX
     debugging information format.

 -- Macro: ASM_STABN_OP
     A C string constant, including spacing, naming the assembler pseudo
     op to use instead of '"\t.stabn\t"' to define a debugging symbol
     with no name.  If you don't define this macro, '"\t.stabn\t"' is
     used.  This macro applies only to DBX debugging information format.

 -- Macro: DBX_NO_XREFS
     Define this macro if DBX on your system does not support the
     construct 'xsTAGNAME'.  On some systems, this construct is used to
     describe a forward reference to a structure named TAGNAME.  On
     other systems, this construct is not supported at all.

 -- Macro: DBX_CONTIN_LENGTH
     A symbol name in DBX-format debugging information is normally
     continued (split into two separate '.stabs' directives) when it
     exceeds a certain length (by default, 80 characters).  On some
     operating systems, DBX requires this splitting; on others,
     splitting must not be done.  You can inhibit splitting by defining
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
