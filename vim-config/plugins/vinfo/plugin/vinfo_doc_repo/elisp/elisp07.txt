 -- Command: smie-close-block
     This command closes the most recently opened (and not yet closed)
     block.

 -- Command: smie-down-list &optional arg
     This command is like 'down-list' but it also pays attention to
     nesting of tokens other than parentheses, such as 'begin...end'.

==============================================================================
File: elisp.info,  Node: |Operator_Precedence_Grammars|,  Next: |SMIE_Grammar|,  Prev: |SMIE_setup|,  Up: |SMIE|
==============================================================================

                                                  *Operator_Precedence_Grammars*

23.7.1.2 Operator Precedence Grammars
.------------------------------------

SMIE's precedence grammars simply give to each token a pair of
precedences: the left-precedence and the right-precedence.  We say 'T1 <
T2' if the right-precedence of token 'T1' is less than the
left-precedence of token 'T2'.  A good way to read this '<' is as a kind
of parenthesis: if we find '... T1 something T2 ...' then that should be
parsed as '... T1 (something T2 ...' rather than as '... T1 something)
T2 ...'.  The latter interpretation would be the case if we had 'T1 >
T2'.  If we have 'T1 = T2', it means that token T2 follows token T1 in
the same syntactic construction, so typically we have '"begin" = "end"'.
Such pairs of precedences are sufficient to express left-associativity
or right-associativity of infix operators, nesting of tokens like
parentheses and many other cases.

 -- Function: smie-prec2->grammar table
     This function takes a _prec2_ grammar TABLE and returns an alist
     suitable for use in 'smie-setup'.  The _prec2_ TABLE is itself
     meant to be built by one of the functions below.

 -- Function: smie-merge-prec2s &rest tables
     This function takes several _prec2_ TABLES and merges them into a
     new _prec2_ table.

 -- Function: smie-precs->prec2 precs
     This function builds a _prec2_ table from a table of precedences
     PRECS.  PRECS should be a list, sorted by precedence (for example
     '"+"' will come before '"*"'), of elements of the form '(ASSOC OP
     ...)', where each OP is a token that acts as an operator; ASSOC is
     their associativity, which can be either 'left', 'right', 'assoc',
     or 'nonassoc'.  All operators in a given element share the same
     precedence level and associativity.

 -- Function: smie-bnf->prec2 bnf &rest resolvers
     This function lets you specify the grammar using a BNF notation.
     It accepts a BNF description of the grammar along with a set of
     conflict resolution rules RESOLVERS, and returns a _prec2_ table.

     BNF is a list of nonterminal definitions of the form '(NONTERM RHS1
     RHS2 ...)' where each RHS is a (non-empty) list of terminals (aka
     tokens) or non-terminals.

     Not all grammars are accepted:
        * An RHS cannot be an empty list (an empty list is never needed,
          since SMIE allows all non-terminals to match the empty string
          anyway).
        * An RHS cannot have 2 consecutive non-terminals: each pair of
          non-terminals needs to be separated by a terminal (aka token).
          This is a fundamental limitation of operator precedence
          grammars.

     Additionally, conflicts can occur:
        * The returned _prec2_ table holds constraints between pairs of
          tokens, and for any given pair only one constraint can be
          present: T1 < T2, T1 = T2, or T1 > T2.
        * A token can be an 'opener' (something similar to an
          open-paren), a 'closer' (like a close-paren), or 'neither' of
          the two (e.g., an infix operator, or an inner token like
          '"else"').

     Precedence conflicts can be resolved via RESOLVERS, which is a list
     of _precs_ tables (see 'smie-precs->prec2'): for each precedence
     conflict, if those 'precs' tables specify a particular constraint,
     then the conflict is resolved by using this constraint instead,
     else a conflict is reported and one of the conflicting constraints
     is picked arbitrarily and the others are simply ignored.

==============================================================================
File: elisp.info,  Node: |SMIE_Grammar|,  Next: |SMIE_Lexer|,  Prev: |Operator_Precedence_Grammars|,  Up: |SMIE|
==============================================================================

                                                                  *SMIE_Grammar*

23.7.1.3 Defining the Grammar of a Language
.------------------------------------------

The usual way to define the SMIE grammar of a language is by defining a
new global variable that holds the precedence table by giving a set of
BNF rules.  For example, the grammar definition for a small Pascal-like
language could look like:
     (require 'smie)
     (defvar sample-smie-grammar
       (smie-prec2->grammar
        (smie-bnf->prec2
         '((id)
           (inst ("begin" insts "end")
                 ("if" exp "then" inst "else" inst)
                 (id ":=" exp)
                 (exp))
           (insts (insts ";" insts) (inst))
           (exp (exp "+" exp)
                (exp "*" exp)
                ("(" exps ")"))
           (exps (exps "," exps) (exp)))
         '((assoc ";"))
         '((assoc ","))
         '((assoc "+") (assoc "*")))))

A few things to note:

   * The above grammar does not explicitly mention the syntax of
     function calls: SMIE will automatically allow any sequence of
     sexps, such as identifiers, balanced parentheses, or 'begin ...
     end' blocks to appear anywhere anyway.
   * The grammar category 'id' has no right hand side: this does not
     mean that it can match only the empty string, since as mentioned
     any sequence of sexps can appear anywhere anyway.
   * Because non terminals cannot appear consecutively in the BNF
     grammar, it is difficult to correctly handle tokens that act as
     terminators, so the above grammar treats '";"' as a statement
     _separator_ instead, which SMIE can handle very well.
   * Separators used in sequences (such as '","' and '";"' above) are
     best defined with BNF rules such as '(foo (foo "separator" foo)
     ...)' which generate precedence conflicts which are then resolved
     by giving them an explicit '(assoc "separator")'.
   * The '("(" exps ")")' rule was not needed to pair up parens, since
     SMIE will pair up any characters that are marked as having paren
     syntax in the syntax table.  What this rule does instead (together
     with the definition of 'exps') is to make it clear that '","'
     should not appear outside of parentheses.
   * Rather than have a single _precs_ table to resolve conflicts, it is
     preferable to have several tables, so as to let the BNF part of the
     grammar specify relative precedences where possible.
   * Unless there is a very good reason to prefer 'left' or 'right', it
     is usually preferable to mark operators as associative, using
     'assoc'.  For that reason '"+"' and '"*"' are defined above as
     'assoc', although the language defines them formally as left
     associative.

==============================================================================
File: elisp.info,  Node: |SMIE_Lexer|,  Next: |SMIE_Tricks|,  Prev: |SMIE_Grammar|,  Up: |SMIE|
==============================================================================

                                                                    *SMIE_Lexer*

23.7.1.4 Defining Tokens
.-----------------------

SMIE comes with a predefined lexical analyzer which uses syntax tables
in the following way: any sequence of characters that have word or
symbol syntax is considered a token, and so is any sequence of
characters that have punctuation syntax.  This default lexer is often a
good starting point but is rarely actually correct for any given
language.  For example, it will consider '"2,+3"' to be composed of 3
tokens: '"2"', '",+"', and '"3"'.

   To describe the lexing rules of your language to SMIE, you need 2
functions, one to fetch the next token, and another to fetch the
previous token.  Those functions will usually first skip whitespace and
comments and then look at the next chunk of text to see if it is a
special token.  If so it should skip the token and return a description
of this token.  Usually this is simply the string extracted from the
buffer, but it can be anything you want.  For example:
     (defvar sample-keywords-regexp
       (regexp-opt '("+" "*" "," ";" ">" ">=" "<" "<=" ":=" "=")))
     (defun sample-smie-forward-token ()
       (forward-comment (point-max))
       (cond
        ((looking-at sample-keywords-regexp)
         (goto-char (match-end 0))
         (match-string-no-properties 0))
        (t (buffer-substring-no-properties
            (point)
            (progn (skip-syntax-forward "w_")
                   (point))))))
     (defun sample-smie-backward-token ()
       (forward-comment (- (point)))
       (cond
        ((looking-back sample-keywords-regexp (- (point) 2) t)
         (goto-char (match-beginning 0))
         (match-string-no-properties 0))
        (t (buffer-substring-no-properties
            (point)
            (progn (skip-syntax-backward "w_")
                   (point))))))

   Notice how those lexers return the empty string when in front of
parentheses.  This is because SMIE automatically takes care of the
parentheses defined in the syntax table.  More specifically if the lexer
returns 'nil' or an empty string, SMIE tries to handle the corresponding
text as a sexp according to syntax tables.

==============================================================================
File: elisp.info,  Node: |SMIE_Tricks|,  Next: |SMIE_Indentation|,  Prev: |SMIE_Lexer|,  Up: |SMIE|
==============================================================================

                                                                   *SMIE_Tricks*

23.7.1.5 Living With a Weak Parser
.---------------------------------

The parsing technique used by SMIE does not allow tokens to behave
differently in different contexts.  For most programming languages, this
manifests itself by precedence conflicts when converting the BNF
grammar.

   Sometimes, those conflicts can be worked around by expressing the
grammar slightly differently.  For example, for Modula-2 it might seem
natural to have a BNF grammar that looks like this:

       ...
       (inst ("IF" exp "THEN" insts "ELSE" insts "END")
             ("CASE" exp "OF" cases "END")
             ...)
       (cases (cases "|" cases)
              (caselabel ":" insts)
              ("ELSE" insts))
       ...

   But this will create conflicts for '"ELSE"': on the one hand, the IF
rule implies (among many other things) that '"ELSE" = "END"'; but on the
other hand, since '"ELSE"' appears within 'cases', which appears left of
'"END"', we also have '"ELSE" > "END"'.  We can solve the conflict
either by using:
       ...
       (inst ("IF" exp "THEN" insts "ELSE" insts "END")
             ("CASE" exp "OF" cases "END")
             ("CASE" exp "OF" cases "ELSE" insts "END")
             ...)
       (cases (cases "|" cases) (caselabel ":" insts))
       ...
   or
       ...
       (inst ("IF" exp "THEN" else "END")
             ("CASE" exp "OF" cases "END")
             ...)
       (else (insts "ELSE" insts))
       (cases (cases "|" cases) (caselabel ":" insts) (else))
       ...

   Reworking the grammar to try and solve conflicts has its downsides,
tho, because SMIE assumes that the grammar reflects the logical
structure of the code, so it is preferable to keep the BNF closer to the
intended abstract syntax tree.

   Other times, after careful consideration you may conclude that those
conflicts are not serious and simply resolve them via the RESOLVERS
argument of 'smie-bnf->prec2'.  Usually this is because the grammar is
simply ambiguous: the conflict does not affect the set of programs
described by the grammar, but only the way those programs are parsed.
This is typically the case for separators and associative infix
operators, where you want to add a resolver like ''((assoc "|"))'.
Another case where this can happen is for the classic _dangling else_
problem, where you will use ''((assoc "else" "then"))'.  It can also
happen for cases where the conflict is real and cannot really be
resolved, but it is unlikely to pose a problem in practice.

   Finally, in many cases some conflicts will remain despite all efforts
to restructure the grammar.  Do not despair: while the parser cannot be
made more clever, you can make the lexer as smart as you want.  So, the
solution is then to look at the tokens involved in the conflict and to
split one of those tokens into 2 (or more) different tokens.  E.g., if
the grammar needs to distinguish between two incompatible uses of the
token '"begin"', make the lexer return different tokens (say
'"begin-fun"' and '"begin-plain"') depending on which kind of '"begin"'
it finds.  This pushes the work of distinguishing the different cases to
the lexer, which will thus have to look at the surrounding text to find
ad-hoc clues.

==============================================================================
File: elisp.info,  Node: |SMIE_Indentation|,  Next: |SMIE_Indentation_Helpers|,  Prev: |SMIE_Tricks|,  Up: |SMIE|
==============================================================================

                                                              *SMIE_Indentation*

23.7.1.6 Specifying Indentation Rules
.------------------------------------

Based on the provided grammar, SMIE will be able to provide automatic
indentation without any extra effort.  But in practice, this default
indentation style will probably not be good enough.  You will want to
tweak it in many different cases.

   SMIE indentation is based on the idea that indentation rules should
be as local as possible.  To this end, it relies on the idea of
_virtual_ indentation, which is the indentation that a particular
program point would have if it were at the beginning of a line.  Of
course, if that program point is indeed at the beginning of a line, its
virtual indentation is its current indentation.  But if not, then SMIE
uses the indentation algorithm to compute the virtual indentation of
that point.  Now in practice, the virtual indentation of a program point
does not have to be identical to the indentation it would have if we
inserted a newline before it.  To see how this works, the SMIE rule for
indentation after a '{' in C does not care whether the '{' is standing
on a line of its own or is at the end of the preceding line.  Instead,
these different cases are handled in the indentation rule that decides
how to indent before a '{'.

   Another important concept is the notion of _parent_: The _parent_ of
a token, is the head token of the nearest enclosing syntactic construct.
For example, the parent of an 'else' is the 'if' to which it belongs,
and the parent of an 'if', in turn, is the lead token of the surrounding
construct.  The command 'backward-sexp' jumps from a token to its
parent, but there are some caveats: for _openers_ (tokens which start a
construct, like 'if'), you need to start with point before the token,
while for others you need to start with point after the token.
'backward-sexp' stops with point before the parent token if that is the
_opener_ of the token of interest, and otherwise it stops with point
after the parent token.

   SMIE indentation rules are specified using a function that takes two
arguments METHOD and ARG where the meaning of ARG and the expected
return value depend on METHOD.

   METHOD can be:
   * ':after', in which case ARG is a token and the function should
     return the OFFSET to use for indentation after ARG.
   * ':before', in which case ARG is a token and the function should
     return the OFFSET to use to indent ARG itself.
   * ':elem', in which case the function should return either the offset
     to use to indent function arguments (if ARG is the symbol 'arg') or
     the basic indentation step (if ARG is the symbol 'basic').
   * ':list-intro', in which case ARG is a token and the function should
     return non-'nil' if the token is followed by a list of expressions
     (not separated by any token) rather than an expression.

   When ARG is a token, the function is called with point just before
that token.  A return value of 'nil' always means to fallback on the
default behavior, so the function should return 'nil' for arguments it
does not expect.

   OFFSET can be:
   * 'nil': use the default indentation rule.
   * '(column . COLUMN)': indent to column COLUMN.
   * NUMBER: offset by NUMBER, relative to a base token which is the
     current token for ':after' and its parent for ':before'.

==============================================================================
File: elisp.info,  Node: |SMIE_Indentation_Helpers|,  Next: |SMIE_Indentation_Example|,  Prev: |SMIE_Indentation|,  Up: |SMIE|
==============================================================================

                                                      *SMIE_Indentation_Helpers*

23.7.1.7 Helper Functions for Indentation Rules
.----------------------------------------------

SMIE provides various functions designed specifically for use in the
indentation rules function (several of those functions break if used in
another context).  These functions all start with the prefix
'smie-rule-'.

 -- Function: smie-rule-bolp
     Return non-'nil' if the current token is the first on the line.

 -- Function: smie-rule-hanging-p
     Return non-'nil' if the current token is _hanging_.  A token is
     _hanging_ if it is the last token on the line and if it is preceded
     by other tokens: a lone token on a line is not hanging.

 -- Function: smie-rule-next-p &rest tokens
     Return non-'nil' if the next token is among TOKENS.

 -- Function: smie-rule-prev-p &rest tokens
     Return non-'nil' if the previous token is among TOKENS.

 -- Function: smie-rule-parent-p &rest parents
     Return non-'nil' if the current token's parent is among PARENTS.

 -- Function: smie-rule-sibling-p
     Return non-'nil' if the current token's parent is actually a
     sibling.  This is the case for example when the parent of a '","'
     is just the previous '","'.

 -- Function: smie-rule-parent &optional offset
     Return the proper offset to align the current token with the
     parent.  If non-'nil', OFFSET should be an integer giving an
     additional offset to apply.

 -- Function: smie-rule-separator method
     Indent current token as a _separator_.

     By _separator_, we mean here a token whose sole purpose is to
     separate various elements within some enclosing syntactic
     construct, and which does not have any semantic significance in
     itself (i.e., it would typically not exist as a node in an abstract
     syntax tree).

     Such a token is expected to have an associative syntax and be
     closely tied to its syntactic parent.  Typical examples are '","'
     in lists of arguments (enclosed inside parentheses), or '";"' in
     sequences of instructions (enclosed in a '{...}' or 'begin...end'
     block).

     METHOD should be the method name that was passed to
     'smie-rules-function'.

==============================================================================
File: elisp.info,  Node: |SMIE_Indentation_Example|,  Next: |SMIE_Customization|,  Prev: |SMIE_Indentation_Helpers|,  Up: |SMIE|
==============================================================================

                                                      *SMIE_Indentation_Example*

23.7.1.8 Sample Indentation Rules
.--------------------------------

Here is an example of an indentation function:

     (defun sample-smie-rules (kind token)
       (pcase (cons kind token)
         (`(:elem . basic) sample-indent-basic)
         (`(,_ . ",") (smie-rule-separator kind))
         (`(:after . ":=") sample-indent-basic)
         (`(:before . ,(or `"begin" `"(" `"{")))
          (if (smie-rule-hanging-p) (smie-rule-parent)))
         (`(:before . "if")
          (and (not (smie-rule-bolp)) (smie-rule-prev-p "else")
               (smie-rule-parent)))))

A few things to note:

   * The first case indicates the basic indentation increment to use.
     If 'sample-indent-basic' is 'nil', then SMIE uses the global
     setting 'smie-indent-basic'.  The major mode could have set
     'smie-indent-basic' buffer-locally instead, but that is
     discouraged.

   * The rule for the token '","' make SMIE try to be more clever when
     the comma separator is placed at the beginning of lines.  It tries
     to outdent the separator so as to align the code after the comma;
     for example:

          x = longfunctionname (
                  arg1
                , arg2
              );

   * The rule for indentation after '":="' exists because otherwise SMIE
     would treat '":="' as an infix operator and would align the right
     argument with the left one.

   * The rule for indentation before '"begin"' is an example of the use
     of virtual indentation: This rule is used only when '"begin"' is
     hanging, which can happen only when '"begin"' is not at the
     beginning of a line.  So this is not used when indenting '"begin"'
     itself but only when indenting something relative to this
     '"begin"'.  Concretely, this rule changes the indentation from:

              if x > 0 then begin
                      dosomething(x);
                  end
     to
              if x > 0 then begin
                  dosomething(x);
              end

   * The rule for indentation before '"if"' is similar to the one for
     '"begin"', but where the purpose is to treat '"else if"' as a
     single unit, so as to align a sequence of tests rather than indent
     each test further to the right.  This function does this only in
     the case where the '"if"' is not placed on a separate line, hence
     the 'smie-rule-bolp' test.

     If we know that the '"else"' is always aligned with its '"if"' and
     is always at the beginning of a line, we can use a more efficient
     rule:
          ((equal token "if")
           (and (not (smie-rule-bolp))
                (smie-rule-prev-p "else")
                (save-excursion
                  (sample-smie-backward-token)
                  (cons 'column (current-column)))))

     The advantage of this formulation is that it reuses the indentation
     of the previous '"else"', rather than going all the way back to the
     first '"if"' of the sequence.

==============================================================================
File: elisp.info,  Node: |SMIE_Customization|,  Prev: |SMIE_Indentation_Example|,  Up: |SMIE|
==============================================================================

                                                            *SMIE_Customization*

23.7.1.9 Customizing Indentation
.-------------------------------

If you are using a mode whose indentation is provided by SMIE, you can
customize the indentation to suit your preferences.  You can do this on
a per-mode basis (using the option 'smie-config'), or a per-file basis
(using the function 'smie-config-local' in a file-local variable
specification).

 -- User Option: smie-config
     This option lets you customize indentation on a per-mode basis.  It
     is an alist with elements of the form '(MODE . RULES)'.  For the
     precise form of rules, see the variable's documentation; but you
     may find it easier to use the command 'smie-config-guess'.

 -- Command: smie-config-guess
     This command tries to work out appropriate settings to produce your
     preferred style of indentation.  Simply call the command while
     visiting a file that is indented with your style.

 -- Command: smie-config-save
     Call this command after using 'smie-config-guess', to save your
     settings for future sessions.

 -- Command: smie-config-show-indent &optional move
     This command displays the rules that are used to indent the current
     line.

 -- Command: smie-config-set-indent
     This command adds a local rule to adjust the indentation of the
     current line.

 -- Function: smie-config-local rules
     This function adds RULES as indentation rules for the current
     buffer.  These add to any mode-specific rules defined by the
     'smie-config' option.  To specify custom indentation rules for a
     specific file, add an entry to the file's local variables of the
     form: 'eval: (smie-config-local '(RULES))'.

==============================================================================
File: elisp.info,  Node: |Desktop_Save_Mode|,  Prev: Auto-Indentation,  Up: |Modes|
==============================================================================

                                                             *Desktop_Save_Mode*

23.8 Desktop Save Mode
=---------------------

"Desktop Save Mode" is a feature to save the state of Emacs from one
session to another.  The user-level commands for using Desktop Save Mode
are described in the GNU Emacs Manual (*note (emacs)Saving Emacs
Sessions::).  Modes whose buffers visit a file, don't have to do
anything to use this feature.

   For buffers not visiting a file to have their state saved, the major
mode must bind the buffer local variable 'desktop-save-buffer' to a
non-'nil' value.

 -- Variable: desktop-save-buffer
     If this buffer-local variable is non-'nil', the buffer will have
     its state saved in the desktop file at desktop save.  If the value
     is a function, it is called at desktop save with argument
     DESKTOP-DIRNAME, and its value is saved in the desktop file along
     with the state of the buffer for which it was called.  When file
     names are returned as part of the auxiliary information, they
     should be formatted using the call

          (desktop-file-name FILE-NAME DESKTOP-DIRNAME)

   For buffers not visiting a file to be restored, the major mode must
define a function to do the job, and that function must be listed in the
alist 'desktop-buffer-mode-handlers'.

 -- Variable: desktop-buffer-mode-handlers
     Alist with elements

          (MAJOR-MODE . RESTORE-BUFFER-FUNCTION)

     The function RESTORE-BUFFER-FUNCTION will be called with argument
     list

          (BUFFER-FILE-NAME BUFFER-NAME DESKTOP-BUFFER-MISC)

     and it should return the restored buffer.  Here DESKTOP-BUFFER-MISC
     is the value returned by the function optionally bound to
     'desktop-save-buffer'.

==============================================================================
File: elisp.info,  Node: |Documentation|,  Next: |Files|,  Prev: |Modes|,  Up: |Top|
==============================================================================

                                                                 *Documentation*

24 Documentation
*===============

GNU Emacs has convenient built-in help facilities, most of which derive
their information from documentation strings associated with functions
and variables.  This chapter describes how to access documentation
strings in Lisp programs.

   The contents of a documentation string should follow certain
conventions.  In particular, its first line should be a complete
sentence (or two complete sentences) that briefly describes what the
function or variable does.  *Note Documentation Tips::, for how to write
good documentation strings.

   Note that the documentation strings for Emacs are not the same thing
as the Emacs manual.  Manuals have their own source files, written in
the Texinfo language; documentation strings are specified in the
definitions of the functions and variables they apply to.  A collection
of documentation strings is not sufficient as a manual because a good
manual is not organized in that fashion; it is organized in terms of
topics of discussion.

   For commands to display documentation strings, see *note Help:
(emacs)Help.

MENU

* |Documentation_Basics|::      Where doc strings are defined and stored.
* |Accessing_Documentation|::   How Lisp programs can access doc strings.
* |Keys_in_Documentation|::     Substituting current key bindings.
* |Text_Quoting_Style|::        Quotation marks in doc strings and messages.
* |Describing_Characters|::     Making printable descriptions of
                                non-printing characters and key sequences.
* |Help_Functions|::            Subroutines used by Emacs help facilities.

==============================================================================
File: elisp.info,  Node: |Documentation_Basics|,  Next: |Accessing_Documentation|,  Up: |Documentation|
==============================================================================

                                                          *Documentation_Basics*

24.1 Documentation Basics
=------------------------

A documentation string is written using the Lisp syntax for strings,
with double-quote characters surrounding the text.  It is, in fact, an
actual Lisp string.  When the string appears in the proper place in a
function or variable definition, it serves as the function's or
variable's documentation.

   In a function definition (a 'lambda' or 'defun' form), the
documentation string is specified after the argument list, and is
normally stored directly in the function object.  *Note Function
Documentation::.  You can also put function documentation in the
'function-documentation' property of a function name (*note Accessing
Documentation::).

   In a variable definition (a 'defvar' form), the documentation string
is specified after the initial value.  *Note Defining Variables::.  The
string is stored in the variable's 'variable-documentation' property.

   Sometimes, Emacs does not keep documentation strings in memory.
There are two such circumstances.  Firstly, to save memory, the
documentation for preloaded functions and variables (including
primitives) is kept in a file named 'DOC', in the directory specified by
'doc-directory' (*note Accessing Documentation::).  Secondly, when a
function or variable is loaded from a byte-compiled file, Emacs avoids
loading its documentation string (*note Docs and Compilation::).  In
both cases, Emacs looks up the documentation string from the file only
when needed, such as when the user calls 'C-h f' ('describe-function')
for a function.

   Documentation strings can contain special "key substitution
sequences", referring to key bindings which are looked up only when the
user views the documentation.  This allows the help commands to display
the correct keys even if a user rearranges the default key bindings.
*Note Keys in Documentation::.

   In the documentation string of an autoloaded command (*note
Autoload::), these key-substitution sequences have an additional special
effect: they cause 'C-h f' on the command to trigger autoloading.  (This
is needed for correctly setting up the hyperlinks in the 'Help'
buffer.)

==============================================================================
File: elisp.info,  Node: |Accessing_Documentation|,  Next: |Keys_in_Documentation|,  Prev: |Documentation_Basics|,  Up: |Documentation|
==============================================================================

                                                       *Accessing_Documentation*

24.2 Access to Documentation Strings
=-----------------------------------

 -- Function: documentation-property symbol property &optional verbatim
     This function returns the documentation string recorded in SYMBOL's
     property list under property PROPERTY.  It is most often used to
     look up the documentation strings of variables, for which PROPERTY
     is 'variable-documentation'.  However, it can also be used to look
     up other kinds of documentation, such as for customization groups
     (but for function documentation, use the 'documentation' function,
     below).

     If the property value refers to a documentation string stored in
     the 'DOC' file or a byte-compiled file, this function looks up that
     string and returns it.

     If the property value isn't 'nil', isn't a string, and doesn't
     refer to text in a file, then it is evaluated as a Lisp expression
     to obtain a string.

     Finally, this function passes the string through
     'substitute-command-keys' to substitute key bindings (*note Keys in
     Documentation::).  It skips this step if VERBATIM is non-'nil'.

          (documentation-property 'command-line-processed
             'variable-documentation)
               => "Non-nil once command line has been processed"
          (symbol-plist 'command-line-processed)
               => (variable-documentation 188902)
          (documentation-property 'emacs 'group-documentation)
               => "Customization of the One True Editor."

 -- Function: documentation function &optional verbatim
     This function returns the documentation string of FUNCTION.  It
     handles macros, named keyboard macros, and special forms, as well
     as ordinary functions.

     If FUNCTION is a symbol, this function first looks for the
     'function-documentation' property of that symbol; if that has a
     non-'nil' value, the documentation comes from that value (if the
     value is not a string, it is evaluated).

     If FUNCTION is not a symbol, or if it has no
     'function-documentation' property, then 'documentation' extracts
     the documentation string from the actual function definition,
     reading it from a file if called for.

     Finally, unless VERBATIM is non-'nil', this function calls
     'substitute-command-keys'.  The result is the documentation string
     to return.

     The 'documentation' function signals a 'void-function' error if
     FUNCTION has no function definition.  However, it is OK if the
     function definition has no documentation string.  In that case,
     'documentation' returns 'nil'.

 -- Function: face-documentation face
     This function returns the documentation string of FACE as a face.

   Here is an example of using the two functions, 'documentation' and
'documentation-property', to display the documentation strings for
several symbols in a 'Help' buffer.

     (defun describe-symbols (pattern)
       "Describe the Emacs Lisp symbols matching PATTERN.
     All symbols that have PATTERN in their name are described
     in the Help buffer."
       (interactive "sDescribe symbols matching: ")
       (let ((describe-func
              (lambda (s)
                ;; Print description of symbol.
                (if (fboundp s)             ; It is a function.
                    (princ
                     (format "%s\t%s\n%s\n\n" s
                       (if (commandp s)
                           (let ((keys (where-is-internal s)))
                             (if keys
                                 (concat
                                  "Keys: "
                                  (mapconcat 'key-description
                                             keys " "))
                               "Keys: none"))
                         "Function")
                       (or (documentation s)
                           "not documented"))))

                (if (boundp s)              ; It is a variable.
                    (princ
                     (format "%s\t%s\n%s\n\n" s
                       (if (custom-variable-p s)
                           "Option " "Variable")
                       (or (documentation-property
                             s 'variable-documentation)
                           "not documented"))))))
             sym-list)

         ;; Build a list of symbols that match pattern.
         (mapatoms (lambda (sym)
                     (if (string-match pattern (symbol-name sym))
                         (setq sym-list (cons sym sym-list)))))

         ;; Display the data.
         (help-setup-xref (list 'describe-symbols pattern) (interactive-p))
         (with-help-window (help-buffer)
           (mapcar describe-func (sort sym-list 'string<)))))

   The 'describe-symbols' function works like 'apropos', but provides
more information.

     (describe-symbols "goal")

     ---------- Buffer: Help ----------
     goal-column     Option
     Semipermanent goal column for vertical motion, as set by ...

     minibuffer-temporary-goal-position      Variable
     not documented

     set-goal-column Keys: C-x C-n
     Set the current horizontal position as a goal for C-n and C-p.
     Those commands will move to this position in the line moved to
     rather than trying to keep the same horizontal position.
     With a non-nil argument ARG, clears out the goal column
     so that C-n and C-p resume vertical motion.
     The goal column is stored in the variable 'goal-column'.

     (fn ARG)

     temporary-goal-column   Variable
     Current goal column for vertical motion.
     It is the column where point was at the start of the current run
     of vertical motion commands.

     When moving by visual lines via the function 'line-move-visual', it is a cons
     cell (COL . HSCROLL), where COL is the x-position, in pixels,
     divided by the default column width, and HSCROLL is the number of
     columns by which window is scrolled from left margin.

     When the 'track-eol' feature is doing its job, the value is
     'most-positive-fixnum'.
     ---------- Buffer: Help ----------

 -- Function: Snarf-documentation filename
     This function is used when building Emacs, just before the runnable
     Emacs is dumped.  It finds the positions of the documentation
     strings stored in the file FILENAME, and records those positions
     into memory in the function definitions and variable property
     lists.  *Note Building Emacs::.

     Emacs reads the file FILENAME from the 'emacs/etc' directory.  When
     the dumped Emacs is later executed, the same file will be looked
     for in the directory 'doc-directory'.  Usually FILENAME is '"DOC"'.

 -- Variable: doc-directory
     This variable holds the name of the directory which should contain
     the file '"DOC"' that contains documentation strings for built-in
     and preloaded functions and variables.

     In most cases, this is the same as 'data-directory'.  They may be
     different when you run Emacs from the directory where you built it,
     without actually installing it.  *Note Definition of
     data-directory::.

==============================================================================
File: elisp.info,  Node: |Keys_in_Documentation|,  Next: |Text_Quoting_Style|,  Prev: |Accessing_Documentation|,  Up: |Documentation|
==============================================================================

                                                         *Keys_in_Documentation*

24.3 Substituting Key Bindings in Documentation
=----------------------------------------------

When documentation strings refer to key sequences, they should use the
current, actual key bindings.  They can do so using certain special text
sequences described below.  Accessing documentation strings in the usual
way substitutes current key binding information for these special
sequences.  This works by calling 'substitute-command-keys'.  You can
also call that function yourself.

   Here is a list of the special sequences and what they mean:

'\[COMMAND]'
     stands for a key sequence that will invoke COMMAND, or 'M-x
     COMMAND' if COMMAND has no key bindings.

'\{MAPVAR}'
     stands for a summary of the keymap which is the value of the
     variable MAPVAR.  The summary is made using 'describe-bindings'.

'\<MAPVAR>'
     stands for no text itself.  It is used only for a side effect: it
     specifies MAPVAR's value as the keymap for any following
     '\[COMMAND]' sequences in this documentation string.

'`'
     (grave accent) stands for a left quote.  This generates a left
     single quotation mark, an apostrophe, or a grave accent depending
     on the value of 'text-quoting-style'.  *Note Text Quoting Style::.

'''
     (apostrophe) stands for a right quote.  This generates a right
     single quotation mark or an apostrophe depending on the value of
     'text-quoting-style'.

'\='
     quotes the following character and is discarded; thus, '\=`' puts
     '`' into the output, '\=\[' puts '\[' into the output, and '\=\='
     puts '\=' into the output.

   *Please note:* Each '\' must be doubled when written in a string in
Emacs Lisp.

 -- User Option: text-quoting-style
     The value of this variable is a symbol that specifies the style
     Emacs should use for single quotes in the wording of help and
     messages.  If the variable's value is 'curve', the style is 'like
     this' with curved single quotes.  If the value is 'straight', the
     style is 'like this' with straight apostrophes.  If the value is
     'grave', quotes are not translated and the style is `like this'
     with grave accent and apostrophe, the standard style before Emacs
     version 25.  The default value 'nil' acts like 'curve' if curved
     single quotes seem to be displayable, and like 'grave' otherwise.

     This option is useful on platforms that have problems with curved
     quotes.  You can customize it freely according to your personal
     preference.

 -- Function: substitute-command-keys string
     This function scans STRING for the above special sequences and
     replaces them by what they stand for, returning the result as a
     string.  This permits display of documentation that refers
     accurately to the user's own customized key bindings.

     If a command has multiple bindings, this function normally uses the
     first one it finds.  You can specify one particular key binding by
     assigning an ':advertised-binding' symbol property to the command,
     like this:

          (put 'undo :advertised-binding [?\C-/])

     The ':advertised-binding' property also affects the binding shown
     in menu items (*note Menu Bar::).  The property is ignored if it
     specifies a key binding that the command does not actually have.

   Here are examples of the special sequences:

     (substitute-command-keys
        "To abort recursive edit, type `\\[abort-recursive-edit]'.")
     => "To abort recursive edit, type 'C-]'."

     (substitute-command-keys
        "The keys that are defined for the minibuffer here are:
       \\{minibuffer-local-must-match-map}")
     => "The keys that are defined for the minibuffer here are:

     ?               minibuffer-completion-help
     SPC             minibuffer-complete-word
     TAB             minibuffer-complete
     C-j             minibuffer-complete-and-exit
     RET             minibuffer-complete-and-exit
     C-g             abort-recursive-edit
     "

     (substitute-command-keys
        "To abort a recursive edit from the minibuffer, type \
     `\\<minibuffer-local-must-match-map>\\[abort-recursive-edit]'.")
     => "To abort a recursive edit from the minibuffer, type 'C-g'."

   There are other special conventions for the text in documentation
strings--for instance, you can refer to functions, variables, and
sections of this manual.  *Note Documentation Tips::, for details.

==============================================================================
File: elisp.info,  Node: |Text_Quoting_Style|,  Next: |Describing_Characters|,  Prev: |Keys_in_Documentation|,  Up: |Documentation|
==============================================================================

                                                            *Text_Quoting_Style*

24.4 Text Quoting Style
=----------------------

Typically, grave accents and apostrophes are treated specially in
documentation strings and diagnostic messages, and translate to matching
single quotation marks (also called "curved quotes").  For example, the
documentation string "Alias for `foo'." and the function call '(message
"Alias for `foo'.")' both translate to "Alias for 'foo'.".  Less
commonly, Emacs displays grave accents and apostrophes as themselves, or
as apostrophes only (e.g., "Alias for 'foo'.").  Documentation strings
and message formats should be written so that they display well with any
of these styles.  For example, the documentation string "Alias for
'foo'." is probably not what you want, as it can display as "Alias for
'foo'.", an unusual style in English.

   Sometimes you may need to display a grave accent or apostrophe
without translation, regardless of text quoting style.  In a
documentation string, you can do this with escapes.  For example, in the
documentation string "\\=`(a ,(sin 0)) ==> (a 0.0)" the grave accent is
intended to denote Lisp code, so it is escaped and displays as itself
regardless of quoting style.  In a call to 'message' or 'error', you can
avoid translation by using a format "%s" with an argument that is a call
to 'format'.  For example, '(message "%s" (format "`(a ,(sin %S)) ==> (a
%S)" x (sin x)))' displays a message that starts with grave accent
regardless of text quoting style.

 -- User Option: text-quoting-style
     The value of this user option is a symbol that specifies the style
     Emacs should use for single quotes in the wording of help and
     messages.  If the option's value is 'curve', the style is 'like
     this' with curved single quotes.  If the value is 'straight', the
     style is 'like this' with straight apostrophes.  If the value is
     'grave', quotes are not translated and the style is `like this'
     with grave accent and apostrophe, the standard style before Emacs
     version 25.  The default value 'nil' acts like 'curve' if curved
     single quotes seem to be displayable, and like 'grave' otherwise.

     This option is useful on platforms that have problems with curved
     quotes.  You can customize it freely according to your personal
     preference.

==============================================================================
File: elisp.info,  Node: |Describing_Characters|,  Next: |Help_Functions|,  Prev: |Text_Quoting_Style|,  Up: |Documentation|
==============================================================================

                                                         *Describing_Characters*

24.5 Describing Characters for Help Messages
=-------------------------------------------

These functions convert events, key sequences, or characters to textual
descriptions.  These descriptions are useful for including arbitrary
text characters or key sequences in messages, because they convert
non-printing and whitespace characters to sequences of printing
characters.  The description of a non-whitespace printing character is
the character itself.

 -- Function: key-description sequence &optional prefix
     This function returns a string containing the Emacs standard
     notation for the input events in SEQUENCE.  If PREFIX is non-'nil',
     it is a sequence of input events leading up to SEQUENCE and is
     included in the return value.  Both arguments may be strings,
     vectors or lists.  *Note Input Events::, for more information about
     valid events.

          (key-description [?\M-3 delete])
               => "M-3 <delete>"
          (key-description [delete] "\M-3")
               => "M-3 <delete>"

     See also the examples for 'single-key-description', below.

 -- Function: single-key-description event &optional no-angles
     This function returns a string describing EVENT in the standard
     Emacs notation for keyboard input.  A normal printing character
     appears as itself, but a control character turns into a string
     starting with 'C-', a meta character turns into a string starting
     with 'M-', and space, tab, etc., appear as 'SPC', 'TAB', etc.  A
     function key symbol appears inside angle brackets '<...>'.  An
     event that is a list appears as the name of the symbol in the CAR
     of the list, inside angle brackets.

     If the optional argument NO-ANGLES is non-'nil', the angle brackets
     around function keys and event symbols are omitted; this is for
     compatibility with old versions of Emacs which didn't use the
     brackets.

          (single-key-description ?\C-x)
               => "C-x"
          (key-description "\C-x \M-y \n \t \r \f123")
               => "C-x SPC M-y SPC C-j SPC TAB SPC RET SPC C-l 1 2 3"
          (single-key-description 'delete)
               => "<delete>"
          (single-key-description 'C-mouse-1)
               => "<C-mouse-1>"
          (single-key-description 'C-mouse-1 t)
               => "C-mouse-1"

 -- Function: text-char-description character
     This function returns a string describing CHARACTER in the standard
     Emacs notation for characters that can appear in text--similar to
     'single-key-description', except that the argument must be a valid
     character code that passes a 'characterp' test (*note Character
     Codes::).  The function produces descriptions of control characters
     with a leading caret (which is how Emacs usually displays control
     characters in buffers).  Characters with modifier bits will cause
     this function to signal an error (ASCII characters with the Control
     modifier are an exception, they are represented as control
     characters).

          (text-char-description ?\C-c)
               => "^C"
          (text-char-description ?\M-m)
               error-> Wrong type argument: characterp, 134217837

 -- Command: read-kbd-macro string &optional need-vector
     This function is used mainly for operating on keyboard macros, but
     it can also be used as a rough inverse for 'key-description'.  You
     call it with a string containing key descriptions, separated by
     spaces; it returns a string or vector containing the corresponding
     events.  (This may or may not be a single valid key sequence,
     depending on what events you use; *note Key Sequences::.)  If
     NEED-VECTOR is non-'nil', the return value is always a vector.

==============================================================================
File: elisp.info,  Node: |Help_Functions|,  Prev: |Describing_Characters|,  Up: |Documentation|
==============================================================================

                                                                *Help_Functions*

24.6 Help Functions
=------------------

Emacs provides a variety of built-in help functions, all accessible to
the user as subcommands of the prefix 'C-h'.  For more information about
them, see *note Help: (emacs)Help.  Here we describe some program-level
interfaces to the same information.

 -- Command: apropos pattern &optional do-all
     This function finds all meaningful symbols whose names contain a
     match for the apropos pattern PATTERN.  An apropos pattern is
     either a word to match, a space-separated list of words of which at
     least two must match, or a regular expression (if any special
     regular expression characters occur).  A symbol is meaningful if it
     has a definition as a function, variable, or face, or has
     properties.

     The function returns a list of elements that look like this:

          (SYMBOL SCORE FUNCTION-DOC VARIABLE-DOC
           PLIST-DOC WIDGET-DOC FACE-DOC GROUP-DOC)

     Here, SCORE is an integer measure of how important the symbol seems
     to be as a match.  Each of the remaining elements is a
     documentation string, or 'nil', for SYMBOL as a function, variable,
     etc.

     It also displays the symbols in a buffer named 'Apropos', each
     with a one-line description taken from the beginning of its
     documentation string.

     If DO-ALL is non-'nil', or if the user option 'apropos-do-all' is
     non-'nil', then 'apropos' also shows key bindings for the functions
     that are found; it also shows _all_ interned symbols, not just
     meaningful ones (and it lists them in the return value as well).

 -- Variable: help-map
     The value of this variable is a local keymap for characters
     following the Help key, 'C-h'.

 -- Prefix Command: help-command
     This symbol is not a function; its function definition cell holds
     the keymap known as 'help-map'.  It is defined in 'help.el' as
     follows:

          (define-key global-map (string help-char) 'help-command)
          (fset 'help-command help-map)

 -- User Option: help-char
     The value of this variable is the help character--the character that
     Emacs recognizes as meaning Help.  By default, its value is 8,
     which stands for 'C-h'.  When Emacs reads this character, if
     'help-form' is a non-'nil' Lisp expression, it evaluates that
     expression, and displays the result in a window if it is a string.

     Usually the value of 'help-form' is 'nil'.  Then the help character
     has no special meaning at the level of command input, and it
     becomes part of a key sequence in the normal way.  The standard key
     binding of 'C-h' is a prefix key for several general-purpose help
     features.

     The help character is special after prefix keys, too.  If it has no
     binding as a subcommand of the prefix key, it runs
     'describe-prefix-bindings', which displays a list of all the
     subcommands of the prefix key.

 -- User Option: help-event-list
     The value of this variable is a list of event types that serve as
     alternative help characters.  These events are handled just like
     the event specified by 'help-char'.

 -- Variable: help-form
     If this variable is non-'nil', its value is a form to evaluate
     whenever the character 'help-char' is read.  If evaluating the form
     produces a string, that string is displayed.

     A command that calls 'read-event', 'read-char-choice', or
     'read-char' probably should bind 'help-form' to a non-'nil'
     expression while it does input.  (The time when you should not do
     this is when 'C-h' has some other meaning.)  Evaluating this
     expression should result in a string that explains what the input
     is for and how to enter it properly.

     Entry to the minibuffer binds this variable to the value of
     'minibuffer-help-form' (*note Definition of
     minibuffer-help-form::).

 -- Variable: prefix-help-command
     This variable holds a function to print help for a prefix key.  The
     function is called when the user types a prefix key followed by the
     help character, and the help character has no binding after that
     prefix.  The variable's default value is
     'describe-prefix-bindings'.

 -- Command: describe-prefix-bindings
     This function calls 'describe-bindings' to display a list of all
     the subcommands of the prefix key of the most recent key sequence.
     The prefix described consists of all but the last event of that key
     sequence.  (The last event is, presumably, the help character.)

   The following two functions are meant for modes that want to provide
help without relinquishing control, such as the electric modes.  Their
names begin with 'Helper' to distinguish them from the ordinary help
functions.

 -- Command: Helper-describe-bindings
     This command pops up a window displaying a help buffer containing a
     listing of all of the key bindings from both the local and global
     keymaps.  It works by calling 'describe-bindings'.

 -- Command: Helper-help
     This command provides help for the current mode.  It prompts the
     user in the minibuffer with the message 'Help (Type ? for further
     options)', and then provides assistance in finding out what the key
     bindings are, and what the mode is intended for.  It returns 'nil'.

     This can be customized by changing the map 'Helper-help-map'.

 -- Variable: data-directory
     This variable holds the name of the directory in which Emacs finds
     certain documentation and text files that come with Emacs.

 -- Function: help-buffer
     This function returns the name of the help buffer, which is
     normally 'Help'; if such a buffer does not exist, it is first
     created.

 -- Macro: with-help-window buffer-or-name body...
     This macro evaluates BODY like 'with-output-to-temp-buffer' (*note
     Temporary Displays::), inserting any output produced by its forms
     into a buffer specified by BUFFER-OR-NAME, which can be a buffer or
     the name of a buffer.  (Frequently, BUFFER-OR-NAME is the value
     returned by the function 'help-buffer'.)  This macro puts the
     specified buffer into Help mode and displays a message telling the
     user how to quit and scroll the help window.  It selects the help
     window if the current value of the user option 'help-window-select'
     has been set accordingly.  It returns the last value in BODY.

 -- Function: help-setup-xref item interactive-p
     This function updates the cross reference data in the 'Help'
     buffer, which is used to regenerate the help information when the
     user clicks on the 'Back' or 'Forward' buttons.  Most commands that
     use the 'Help' buffer should invoke this function before clearing
     the buffer.  The ITEM argument should have the form '(FUNCTION .
     ARGS)', where FUNCTION is a function to call, with argument list
     ARGS, to regenerate the help buffer.  The INTERACTIVE-P argument is
     non-'nil' if the calling command was invoked interactively; in that
     case, the stack of items for the 'Help' buffer's 'Back' buttons
     is cleared.

   *Note describe-symbols example::, for an example of using
'help-buffer', 'with-help-window', and 'help-setup-xref'.

 -- Macro: make-help-screen fname help-line help-text help-map
     This macro defines a help command named FNAME that acts like a
     prefix key that shows a list of the subcommands it offers.

     When invoked, FNAME displays HELP-TEXT in a window, then reads and
     executes a key sequence according to HELP-MAP.  The string
     HELP-TEXT should describe the bindings available in HELP-MAP.

     The command FNAME is defined to handle a few events itself, by
     scrolling the display of HELP-TEXT.  When FNAME reads one of those
     special events, it does the scrolling and then reads another event.
     When it reads an event that is not one of those few, and which has
     a binding in HELP-MAP, it executes that key's binding and then
     returns.

     The argument HELP-LINE should be a single-line summary of the
     alternatives in HELP-MAP.  In the current version of Emacs, this
     argument is used only if you set the option 'three-step-help' to
     't'.

     This macro is used in the command 'help-for-help' which is the
     binding of 'C-h C-h'.

 -- User Option: three-step-help
     If this variable is non-'nil', commands defined with
     'make-help-screen' display their HELP-LINE strings in the echo area
     at first, and display the longer HELP-TEXT strings only if the user
     types the help character again.

==============================================================================
File: elisp.info,  Node: |Files|,  Next: |Backups_and_Auto_Saving|,  Prev: |Documentation|,  Up: |Top|
==============================================================================

                                                                         *Files*

25 Files
*=======

This chapter describes the Emacs Lisp functions and variables to find,
create, view, save, and otherwise work with files and directories.  A
few other file-related functions are described in *note Buffers::, and
those related to backups and auto-saving are described in *note Backups
and Auto-Saving::.

   Many of the file functions take one or more arguments that are file
names.  A file name is a string.  Most of these functions expand file
name arguments using the function 'expand-file-name', so that '~' is
handled correctly, as are relative file names (including '../' and the
empty string).  *Note File Name Expansion::.

   In addition, certain "magic" file names are handled specially.  For
example, when a remote file name is specified, Emacs accesses the file
over the network via an appropriate protocol.  *Note Remote Files:
(emacs)Remote Files.  This handling is done at a very low level, so you
may assume that all the functions described in this chapter accept magic
file names as file name arguments, except where noted.  *Note Magic File
Names::, for details.

   When file I/O functions signal Lisp errors, they usually use the
condition 'file-error' (*note Handling Errors::).  The error message is
in most cases obtained from the operating system, according to locale
'system-messages-locale', and decoded using coding system
'locale-coding-system' (*note Locales::).

MENU

* |Visiting_Files|::           Reading files into Emacs buffers for editing.
* |Saving_Buffers|::           Writing changed buffers back into files.
* |Reading_from_Files|::       Reading files into buffers without visiting.
* |Writing_to_Files|::         Writing new files from parts of buffers.
* |File_Locks|::               Locking and unlocking files, to prevent
                               simultaneous editing by two people.
* |Information_about_Files|::  Testing existence, accessibility, size of files.
* |Changing_Files|::           Renaming files, changing permissions, etc.
* |Files_and_Storage|::        Surviving power and media failures
* |File_Names|::               Decomposing and expanding file names.
* |Contents_of_Directories|::  Getting a list of the files in a directory.
* |Create/Delete_Dirs|::       Creating and Deleting Directories.
* |Magic_File_Names|::         Special handling for certain file names.
* |Format_Conversion|::        Conversion to and from various file formats.

==============================================================================
File: elisp.info,  Node: |Visiting_Files|,  Next: |Saving_Buffers|,  Up: |Files|
==============================================================================

                                                                *Visiting_Files*

25.1 Visiting Files
=------------------

Visiting a file means reading a file into a buffer.  Once this is done,
we say that the buffer is "visiting" that file, and call the file "the
visited file" of the buffer.

   A file and a buffer are two different things.  A file is information
recorded permanently in the computer (unless you delete it).  A buffer,
on the other hand, is information inside of Emacs that will vanish at
the end of the editing session (or when you kill the buffer).  When a
buffer is visiting a file, it contains information copied from the file.
The copy in the buffer is what you modify with editing commands.
Changes to the buffer do not change the file; to make the changes
permanent, you must "save" the buffer, which means copying the altered
buffer contents back into the file.

   Despite the distinction between files and buffers, people often refer
to a file when they mean a buffer and vice-versa.  Indeed, we say, "I am
editing a file", rather than, "I am editing a buffer that I will soon
save as a file of the same name".  Humans do not usually need to make
the distinction explicit.  When dealing with a computer program,
however, it is good to keep the distinction in mind.

MENU

* |Visiting_Functions|::         The usual interface functions for visiting.
* |Subroutines_of_Visiting|::    Lower-level subroutines that they use.

==============================================================================
File: elisp.info,  Node: |Visiting_Functions|,  Next: |Subroutines_of_Visiting|,  Up: Visiting Files
==============================================================================

                                                            *Visiting_Functions*

25.1.1 Functions for Visiting Files
-----------------------------------

This section describes the functions normally used to visit files.  For
historical reasons, these functions have names starting with 'find-'
rather than 'visit-'.  *Note Buffer File Name::, for functions and
variables that access the visited file name of a buffer or that find an
existing buffer by its visited file name.

   In a Lisp program, if you want to look at the contents of a file but
not alter it, the fastest way is to use 'insert-file-contents' in a
temporary buffer.  Visiting the file is not necessary and takes longer.
*Note Reading from Files::.

 -- Command: find-file filename &optional wildcards
     This command selects a buffer visiting the file FILENAME, using an
     existing buffer if there is one, and otherwise creating a new
     buffer and reading the file into it.  It also returns that buffer.

     Aside from some technical details, the body of the 'find-file'
     function is basically equivalent to:

          (switch-to-buffer (find-file-noselect filename nil nil wildcards))

     (See 'switch-to-buffer' in *note Switching Buffers::.)

     If WILDCARDS is non-'nil', which is always true in an interactive
     call, then 'find-file' expands wildcard characters in FILENAME and
     visits all the matching files.

     When 'find-file' is called interactively, it prompts for FILENAME
     in the minibuffer.

 -- Command: find-file-literally filename
     This command visits FILENAME, like 'find-file' does, but it does
     not perform any format conversions (*note Format Conversion::),
     character code conversions (*note Coding Systems::), or end-of-line
     conversions (*note End of line conversion: Coding System Basics.).
     The buffer visiting the file is made unibyte, and its major mode is
     Fundamental mode, regardless of the file name.  File local variable
     specifications in the file (*note File Local Variables::) are
     ignored, and automatic decompression and adding a newline at the
     end of the file due to 'require-final-newline' (*note
     require-final-newline: Saving Buffers.) are also disabled.

     Note that if Emacs already has a buffer visiting the same file
     non-literally, it will not visit the same file literally, but
     instead just switch to the existing buffer.  If you want to be sure
     of accessing a file's contents literally, you should create a
     temporary buffer and then read the file contents into it using
     'insert-file-contents-literally' (*note Reading from Files::).

 -- Function: find-file-noselect filename &optional nowarn rawfile
          wildcards
     This function is the guts of all the file-visiting functions.  It
     returns a buffer visiting the file FILENAME.  You may make the
     buffer current or display it in a window if you wish, but this
     function does not do so.

     The function returns an existing buffer if there is one; otherwise
     it creates a new buffer and reads the file into it.  When
     'find-file-noselect' uses an existing buffer, it first verifies
     that the file has not changed since it was last visited or saved in
     that buffer.  If the file has changed, this function asks the user
     whether to reread the changed file.  If the user says 'yes', any
     edits previously made in the buffer are lost.

     Reading the file involves decoding the file's contents (*note
     Coding Systems::), including end-of-line conversion, and format
     conversion (*note Format Conversion::).  If WILDCARDS is non-'nil',
     then 'find-file-noselect' expands wildcard characters in FILENAME
     and visits all the matching files.

     This function displays warning or advisory messages in various
     peculiar cases, unless the optional argument NOWARN is non-'nil'.
     For example, if it needs to create a buffer, and there is no file
     named FILENAME, it displays the message '(New file)' in the echo
     area, and leaves the buffer empty.

     The 'find-file-noselect' function normally calls 'after-find-file'
     after reading the file (*note Subroutines of Visiting::).  That
     function sets the buffer major mode, parses local variables, warns
     the user if there exists an auto-save file more recent than the
     file just visited, and finishes by running the functions in
     'find-file-hook'.

     If the optional argument RAWFILE is non-'nil', then
     'after-find-file' is not called, and the
     'find-file-not-found-functions' are not run in case of failure.
     What's more, a non-'nil' RAWFILE value suppresses coding system
     conversion and format conversion.

     The 'find-file-noselect' function usually returns the buffer that
     is visiting the file FILENAME.  But, if wildcards are actually used
     and expanded, it returns a list of buffers that are visiting the
     various files.

          (find-file-noselect "/etc/fstab")
               => #<buffer fstab>

 -- Command: find-file-other-window filename &optional wildcards
     This command selects a buffer visiting the file FILENAME, but does
     so in a window other than the selected window.  It may use another
     existing window or split a window; see *note Switching Buffers::.

     When this command is called interactively, it prompts for FILENAME.

 -- Command: find-file-read-only filename &optional wildcards
     This command selects a buffer visiting the file FILENAME, like
     'find-file', but it marks the buffer as read-only.  *Note Read Only
     Buffers::, for related functions and variables.

     When this command is called interactively, it prompts for FILENAME.

 -- User Option: find-file-wildcards
     If this variable is non-'nil', then the various 'find-file'
     commands check for wildcard characters and visit all the files that
     match them (when invoked interactively or when their WILDCARDS
     argument is non-'nil').  If this option is 'nil', then the
     'find-file' commands ignore their WILDCARDS argument and never
     treat wildcard characters specially.

 -- User Option: find-file-hook
     The value of this variable is a list of functions to be called
     after a file is visited.  The file's local-variables specification
     (if any) will have been processed before the hooks are run.  The
     buffer visiting the file is current when the hook functions are
     run.

     This variable is a normal hook.  *Note Hooks::.

 -- Variable: find-file-not-found-functions
     The value of this variable is a list of functions to be called when
     'find-file' or 'find-file-noselect' is passed a nonexistent file
     name.  'find-file-noselect' calls these functions as soon as it
     detects a nonexistent file.  It calls them in the order of the
     list, until one of them returns non-'nil'.  'buffer-file-name' is
     already set up.

     This is not a normal hook because the values of the functions are
     used, and in many cases only some of the functions are called.

 -- Variable: find-file-literally
     This buffer-local variable, if set to a non-'nil' value, makes
     'save-buffer' behave as if the buffer were visiting its file
     literally, i.e., without conversions of any kind.  The command
     'find-file-literally' sets this variable's local value, but other
     equivalent functions and commands can do that as well, e.g., to
     avoid automatic addition of a newline at the end of the file.  This
     variable is permanent local, so it is unaffected by changes of
     major modes.

==============================================================================
File: elisp.info,  Node: |Subroutines_of_Visiting|,  Prev: |Visiting_Functions|,  Up: |Visiting_Files|
==============================================================================

                                                       *Subroutines_of_Visiting*

25.1.2 Subroutines of Visiting
------------------------------

The 'find-file-noselect' function uses two important subroutines which
are sometimes useful in user Lisp code: 'create-file-buffer' and
'after-find-file'.  This section explains how to use them.

 -- Function: create-file-buffer filename
     This function creates a suitably named buffer for visiting
     FILENAME, and returns it.  It uses FILENAME (sans directory) as the
     name if that name is free; otherwise, it appends a string such as
     '<2>' to get an unused name.  See also *note Creating Buffers::.
     Note that the 'uniquify' library affects the result of this
     function.  *Note (emacs)Uniquify::.

     *Please note:* 'create-file-buffer' does _not_ associate the new
     buffer with a file and does not select the buffer.  It also does
     not use the default major mode.

          (create-file-buffer "foo")
               => #<buffer foo>
          (create-file-buffer "foo")
               => #<buffer foo<2>>
          (create-file-buffer "foo")
               => #<buffer foo<3>>

     This function is used by 'find-file-noselect'.  It uses
     'generate-new-buffer' (*note Creating Buffers::).

 -- Function: after-find-file &optional error warn noauto
          after-find-file-from-revert-buffer nomodes
     This function sets the buffer major mode, and parses local
     variables (*note Auto Major Mode::).  It is called by
     'find-file-noselect' and by the default revert function (*note
     Reverting::).

     If reading the file got an error because the file does not exist,
     but its directory does exist, the caller should pass a non-'nil'
     value for ERROR.  In that case, 'after-find-file' issues a warning:
     '(New file)'.  For more serious errors, the caller should usually
     not call 'after-find-file'.

     If WARN is non-'nil', then this function issues a warning if an
     auto-save file exists and is more recent than the visited file.

     If NOAUTO is non-'nil', that says not to enable or disable
     Auto-Save mode.  The mode remains enabled if it was enabled before.

     If AFTER-FIND-FILE-FROM-REVERT-BUFFER is non-'nil', that means this
     call was from 'revert-buffer'.  This has no direct effect, but some
     mode functions and hook functions check the value of this variable.

     If NOMODES is non-'nil', that means don't alter the buffer's major
     mode, don't process local variables specifications in the file, and
     don't run 'find-file-hook'.  This feature is used by
     'revert-buffer' in some cases.

     The last thing 'after-find-file' does is call all the functions in
     the list 'find-file-hook'.

==============================================================================
File: elisp.info,  Node: |Saving_Buffers|,  Next: |Reading_from_Files|,  Prev: |Visiting_Files|,  Up: |Files|
==============================================================================

                                                                *Saving_Buffers*

25.2 Saving Buffers
=------------------

When you edit a file in Emacs, you are actually working on a buffer that
is visiting that file--that is, the contents of the file are copied into
the buffer and the copy is what you edit.  Changes to the buffer do not
change the file until you "save" the buffer, which means copying the
contents of the buffer into the file.  Buffers which are not visiting a
file can still be "saved", in a sense, using functions in the
buffer-local 'write-contents-functions' hook.

 -- Command: save-buffer &optional backup-option
     This function saves the contents of the current buffer in its
     visited file if the buffer has been modified since it was last
     visited or saved.  Otherwise it does nothing.

     'save-buffer' is responsible for making backup files.  Normally,
     BACKUP-OPTION is 'nil', and 'save-buffer' makes a backup file only
     if this is the first save since visiting the file.  Other values
     for BACKUP-OPTION request the making of backup files in other
     circumstances:

        * With an argument of 4 or 64, reflecting 1 or 3 'C-u''s, the
          'save-buffer' function marks this version of the file to be
          backed up when the buffer is next saved.

        * With an argument of 16 or 64, reflecting 2 or 3 'C-u''s, the
          'save-buffer' function unconditionally backs up the previous
          version of the file before saving it.

        * With an argument of 0, unconditionally do _not_ make any
          backup file.

 -- Command: save-some-buffers &optional save-silently-p pred
     This command saves some modified file-visiting buffers.  Normally
     it asks the user about each buffer.  But if SAVE-SILENTLY-P is
     non-'nil', it saves all the file-visiting buffers without querying
     the user.

     The optional PRED argument provides a predicate that controls which
     buffers to ask about (or to save silently if SAVE-SILENTLY-P is
     non-'nil').  If PRED is 'nil', that means to use the value of
     'save-some-buffers-default-predicate' instead of PRED.  If the
     result is 'nil', it means ask only about file-visiting buffers.  If
     it is 't', that means also offer to save certain other non-file
     buffers--those that have a non-'nil' buffer-local value of
     'buffer-offer-save' (*note Killing Buffers::).  A user who says
     'yes' to saving a non-file buffer is asked to specify the file name
     to use.  The 'save-buffers-kill-emacs' function passes the value
     't' for PRED.

     If the predicate is neither 't' nor 'nil', then it should be a
     function of no arguments.  It will be called in each buffer to
     decide whether to offer to save that buffer.  If it returns a
     non-'nil' value in a certain buffer, that means do offer to save
     that buffer.

 -- Command: write-file filename &optional confirm
     This function writes the current buffer into file FILENAME, makes
     the buffer visit that file, and marks it not modified.  Then it
     renames the buffer based on FILENAME, appending a string like '<2>'
     if necessary to make a unique buffer name.  It does most of this
     work by calling 'set-visited-file-name' (*note Buffer File Name::)
     and 'save-buffer'.

     If CONFIRM is non-'nil', that means to ask for confirmation before
     overwriting an existing file.  Interactively, confirmation is
     required, unless the user supplies a prefix argument.

     If FILENAME is a directory name (*note Directory Names::),
     'write-file' uses the name of the visited file, in directory
     FILENAME.  If the buffer is not visiting a file, it uses the buffer
     name instead.

   Saving a buffer runs several hooks.  It also performs format
conversion (*note Format Conversion::).  Note that these hooks,
described below, are only run by 'save-buffer', they are not run by
other primitives and functions that write buffer text to files, and in
particular auto-saving (*note Auto-Saving::) doesn't run these hooks.

 -- Variable: write-file-functions
     The value of this variable is a list of functions to be called
     before writing out a buffer to its visited file.  If one of them
     returns non-'nil', the file is considered already written and the
     rest of the functions are not called, nor is the usual code for
     writing the file executed.

     If a function in 'write-file-functions' returns non-'nil', it is
     responsible for making a backup file (if that is appropriate).  To
     do so, execute the following code:

          (or buffer-backed-up (backup-buffer))

     You might wish to save the file modes value returned by
     'backup-buffer' and use that (if non-'nil') to set the mode bits of
     the file that you write.  This is what 'save-buffer' normally does.
     *Note Making Backup Files: Making Backups.

     The hook functions in 'write-file-functions' are also responsible
     for encoding the data (if desired): they must choose a suitable
     coding system and end-of-line conversion (*note Lisp and Coding
     Systems::), perform the encoding (*note Explicit Encoding::), and
     set 'last-coding-system-used' to the coding system that was used
     (*note Encoding and I/O::).

     If you set this hook locally in a buffer, it is assumed to be
     associated with the file or the way the contents of the buffer were
     obtained.  Thus the variable is marked as a permanent local, so
     that changing the major mode does not alter a buffer-local value.
     On the other hand, calling 'set-visited-file-name' will reset it.
     If this is not what you want, you might like to use
     'write-contents-functions' instead.

     Even though this is not a normal hook, you can use 'add-hook' and
     'remove-hook' to manipulate the list.  *Note Hooks::.

 -- Variable: write-contents-functions
     This works just like 'write-file-functions', but it is intended for
     hooks that pertain to the buffer's contents, not to the particular
     visited file or its location, and can be used to create arbitrary
     save processes for buffers that aren't visiting files at all.  Such
     hooks are usually set up by major modes, as buffer-local bindings
     for this variable.  This variable automatically becomes
     buffer-local whenever it is set; switching to a new major mode
     always resets this variable, but calling 'set-visited-file-name'
     does not.

     If any of the functions in this hook returns non-'nil', the file is
     considered already written and the rest are not called and neither
     are the functions in 'write-file-functions'.

     When using this hook to save buffers that are not visiting files
     (for instance, special-mode buffers), keep in mind that, if the
     function fails to save correctly and returns a 'nil' value,
     'save-buffer' will go on to prompt the user for a file to save the
     buffer in.  If this is undesirable, consider having the function
     fail by raising an error.

 -- User Option: before-save-hook
     This normal hook runs before a buffer is saved in its visited file,
     regardless of whether that is done normally or by one of the hooks
     described above.  For instance, the 'copyright.el' program uses
     this hook to make sure the file you are saving has the current year
     in its copyright notice.

 -- User Option: after-save-hook
     This normal hook runs after a buffer has been saved in its visited
     file.

 -- User Option: file-precious-flag
     If this variable is non-'nil', then 'save-buffer' protects against
     I/O errors while saving by writing the new file to a temporary name
     instead of the name it is supposed to have, and then renaming it to
     the intended name after it is clear there are no errors.  This
     procedure prevents problems such as a lack of disk space from
     resulting in an invalid file.

     As a side effect, backups are necessarily made by copying.  *Note
     Rename or Copy::.  Yet, at the same time, saving a precious file
     always breaks all hard links between the file you save and other
     file names.

     Some modes give this variable a non-'nil' buffer-local value in
     particular buffers.

 -- User Option: require-final-newline
     This variable determines whether files may be written out that do
     _not_ end with a newline.  If the value of the variable is 't',
     then 'save-buffer' silently adds a newline at the end of the buffer
     whenever it does not already end in one.  If the value is 'visit',
     Emacs adds a missing newline just after it visits the file.  If the
     value is 'visit-save', Emacs adds a missing newline both on
     visiting and on saving.  For any other non-'nil' value,
     'save-buffer' asks the user whether to add a newline each time the
     case arises.

     If the value of the variable is 'nil', then 'save-buffer' doesn't
     add newlines at all.  'nil' is the default value, but a few major
     modes set it to 't' in particular buffers.

   See also the function 'set-visited-file-name' (*note Buffer File
Name::).

==============================================================================
File: elisp.info,  Node: |Reading_from_Files|,  Next: |Writing_to_Files|,  Prev: |Saving_Buffers|,  Up: |Files|
==============================================================================

                                                            *Reading_from_Files*

25.3 Reading from Files
=----------------------

To copy the contents of a file into a buffer, use the function
'insert-file-contents'.  (Don't use the command 'insert-file' in a Lisp
program, as that sets the mark.)

 -- Function: insert-file-contents filename &optional visit beg end
          replace
     This function inserts the contents of file FILENAME into the
     current buffer after point.  It returns a list of the absolute file
     name and the length of the data inserted.  An error is signaled if
     FILENAME is not the name of a file that can be read.

     This function checks the file contents against the defined file
     formats, and converts the file contents if appropriate and also
     calls the functions in the list 'after-insert-file-functions'.
     *Note Format Conversion::.  Normally, one of the functions in the
     'after-insert-file-functions' list determines the coding system
     (*note Coding Systems::) used for decoding the file's contents,
     including end-of-line conversion.  However, if the file contains
     null bytes, it is by default visited without any code conversions.
     *Note inhibit-nul-byte-detection: Lisp and Coding Systems.

     If VISIT is non-'nil', this function additionally marks the buffer
     as unmodified and sets up various fields in the buffer so that it
     is visiting the file FILENAME: these include the buffer's visited
     file name and its last save file modtime.  This feature is used by
     'find-file-noselect' and you probably should not use it yourself.

     If BEG and END are non-'nil', they should be numbers that are byte
     offsets specifying the portion of the file to insert.  In this
     case, VISIT must be 'nil'.  For example,

          (insert-file-contents filename nil 0 500)

     inserts the first 500 characters of a file.

     If the argument REPLACE is non-'nil', it means to replace the
     contents of the buffer (actually, just the accessible portion) with
     the contents of the file.  This is better than simply deleting the
     buffer contents and inserting the whole file, because (1) it
     preserves some marker positions and (2) it puts less data in the
     undo list.

     It is possible to read a special file (such as a FIFO or an I/O
     device) with 'insert-file-contents', as long as REPLACE and VISIT
     are 'nil'.

 -- Function: insert-file-contents-literally filename &optional visit
          beg end replace
     This function works like 'insert-file-contents' except that it does
     not run 'after-insert-file-functions', and does not do format
     decoding, character code conversion, automatic uncompression, and
     so on.

   If you want to pass a file name to another process so that another
program can read the file, use the function 'file-local-copy'; see *note
Magic File Names::.

==============================================================================
File: elisp.info,  Node: |Writing_to_Files|,  Next: |File_Locks|,  Prev: |Reading_from_Files|,  Up: |Files|
==============================================================================

                                                              *Writing_to_Files*

25.4 Writing to Files
=--------------------

You can write the contents of a buffer, or part of a buffer, directly to
a file on disk using the 'append-to-file' and 'write-region' functions.
Don't use these functions to write to files that are being visited; that
could cause confusion in the mechanisms for visiting.

 -- Command: append-to-file start end filename
     This function appends the contents of the region delimited by START
     and END in the current buffer to the end of file FILENAME.  If that
     file does not exist, it is created.  This function returns 'nil'.

     An error is signaled if you cannot write or create FILENAME.

     When called from Lisp, this function is completely equivalent to:

          (write-region start end filename t)

 -- Command: write-region start end filename &optional append visit
          lockname mustbenew
     This function writes the region delimited by START and END in the
     current buffer into the file specified by FILENAME.

     If START is 'nil', then the command writes the entire buffer
     contents (_not_ just the accessible portion) to the file and
     ignores END.

     If START is a string, then 'write-region' writes or appends that
     string, rather than text from the buffer.  END is ignored in this
     case.

     If APPEND is non-'nil', then the specified text is appended to the
     existing file contents (if any).  If APPEND is a number,
     'write-region' seeks to that byte offset from the start of the file
     and writes the data from there.

     If MUSTBENEW is non-'nil', then 'write-region' asks for
     confirmation if FILENAME names an existing file.  If MUSTBENEW is
     the symbol 'excl', then 'write-region' does not ask for
     confirmation, but instead it signals an error 'file-already-exists'
     if the file already exists.  Although 'write-region' normally
     follows a symbolic link and creates the pointed-to file if the
     symbolic link is dangling, it does not follow symbolic links if
     MUSTBENEW is 'excl'.

     The test for an existing file, when MUSTBENEW is 'excl', uses a
     special system feature.  At least for files on a local disk, there
     is no chance that some other program could create a file of the
     same name before Emacs does, without Emacs's noticing.

     If VISIT is 't', then Emacs establishes an association between the
     buffer and the file: the buffer is then visiting that file.  It
     also sets the last file modification time for the current buffer to
     FILENAME's modtime, and marks the buffer as not modified.  This
     feature is used by 'save-buffer', but you probably should not use
     it yourself.

     If VISIT is a string, it specifies the file name to visit.  This
     way, you can write the data to one file (FILENAME) while recording
     the buffer as visiting another file (VISIT).  The argument VISIT is
     used in the echo area message and also for file locking; VISIT is
     stored in 'buffer-file-name'.  This feature is used to implement
     'file-precious-flag'; don't use it yourself unless you really know
     what you're doing.

     The optional argument LOCKNAME, if non-'nil', specifies the file
     name to use for purposes of locking and unlocking, overriding
     FILENAME and VISIT for that purpose.

     The function 'write-region' converts the data which it writes to
     the appropriate file formats specified by 'buffer-file-format' and
     also calls the functions in the list
     'write-region-annotate-functions'.  *Note Format Conversion::.

     Normally, 'write-region' displays the message 'Wrote FILENAME' in
     the echo area.  This message is inhibited if VISIT is neither 't'
     nor 'nil' nor a string, or if Emacs is operating in batch mode
     (*note Batch Mode::).  This feature is useful for programs that use
     files for internal purposes, files that the user does not need to
     know about.

 -- Variable: write-region-inhibit-fsync
     If this variable's value is 'nil', 'write-region' uses the 'fsync'
     system call after writing a file.  Although this slows Emacs down,
     it lessens the risk of data loss after power failure.  If the value
     is 't', Emacs does not use 'fsync'.  The default value is 'nil'
     when Emacs is interactive, and 't' when Emacs runs in batch mode.
     *Note Files and Storage::.

 -- Macro: with-temp-file file body...
     The 'with-temp-file' macro evaluates the BODY forms with a
     temporary buffer as the current buffer; then, at the end, it writes
     the buffer contents into file FILE.  It kills the temporary buffer
     when finished, restoring the buffer that was current before the
     'with-temp-file' form.  Then it returns the value of the last form
     in BODY.

     The current buffer is restored even in case of an abnormal exit via
     'throw' or error (*note Nonlocal Exits::).

     See also 'with-temp-buffer' in *note The Current Buffer: Definition
     of with-temp-buffer.

==============================================================================
File: elisp.info,  Node: |File_Locks|,  Next: |Information_about_Files|,  Prev: |Writing_to_Files|,  Up: |Files|
==============================================================================

                                                                    *File_Locks*

25.5 File Locks
=--------------

When two users edit the same file at the same time, they are likely to
interfere with each other.  Emacs tries to prevent this situation from
arising by recording a "file lock" when a file is being modified.  Emacs
can then detect the first attempt to modify a buffer visiting a file
that is locked by another Emacs job, and ask the user what to do.  The
file lock is really a file, a symbolic link with a special name, stored
in the same directory as the file you are editing.  The name is
constructed by prepending '.#' to the filename of the buffer.  The
target of the symbolic link will be of the form 'USER@HOST.PID:BOOT',
where USER is replaced with the current username (from
'user-login-name'), HOST with the name of the host where Emacs is
running (from 'system-name'), PID with Emacs's process id, and BOOT with
the time since the last reboot.  ':BOOT' is omitted if the boot time is
unavailable.  (On file systems that do not support symbolic links, a
regular file is used instead, with contents of the form
'USER@HOST.PID:BOOT'.)

   When you access files using NFS, there may be a small probability
that you and another user will both lock the same file simultaneously.
If this happens, it is possible for the two users to make changes
simultaneously, but Emacs will still warn the user who saves second.
Also, the detection of modification of a buffer visiting a file changed
on disk catches some cases of simultaneous editing; see *note
Modification Time::.

 -- Function: file-locked-p filename
     This function returns 'nil' if the file FILENAME is not locked.  It
     returns 't' if it is locked by this Emacs process, and it returns
     the name of the user who has locked it if it is locked by some
     other job.

          (file-locked-p "foo")
               => nil

 -- Function: lock-buffer &optional filename
     This function locks the file FILENAME, if the current buffer is
     modified.  The argument FILENAME defaults to the current buffer's
     visited file.  Nothing is done if the current buffer is not
     visiting a file, or is not modified, or if the option
     'create-lockfiles' is 'nil'.

 -- Function: unlock-buffer
     This function unlocks the file being visited in the current buffer,
     if the buffer is modified.  If the buffer is not modified, then the
     file should not be locked, so this function does nothing.  It also
     does nothing if the current buffer is not visiting a file, or is
     not locked.

 -- User Option: create-lockfiles
     If this variable is 'nil', Emacs does not lock files.

 -- Function: ask-user-about-lock file other-user
     This function is called when the user tries to modify FILE, but it
     is locked by another user named OTHER-USER.  The default definition
     of this function asks the user to say what to do.  The value this
     function returns determines what Emacs does next:

        * A value of 't' says to grab the lock on the file.  Then this
          user may edit the file and OTHER-USER loses the lock.

        * A value of 'nil' says to ignore the lock and let this user
          edit the file anyway.

        * This function may instead signal a 'file-locked' error, in
          which case the change that the user was about to make does not
          take place.

          The error message for this error looks like this:

               error-> File is locked: FILE OTHER-USER

          where 'file' is the name of the file and OTHER-USER is the
          name of the user who has locked the file.

     If you wish, you can replace the 'ask-user-about-lock' function
     with your own version that makes the decision in another way.

==============================================================================
File: elisp.info,  Node: |Information_about_Files|,  Next: |Changing_Files|,  Prev: |File_Locks|,  Up: |Files|
==============================================================================

                                                       *Information_about_Files*

25.6 Information about Files
=---------------------------

This section describes the functions for retrieving various types of
information about files (or directories or symbolic links), such as
whether a file is readable or writable, and its size.  These functions
all take arguments which are file names.  Except where noted, these
arguments need to specify existing files, or an error is signaled.

   Be careful with file names that end in spaces.  On some filesystems
(notably, MS-Windows), trailing whitespace characters in file names are
silently and automatically ignored.

MENU

* |Testing_Accessibility|::   Is a given file readable?  Writable?
* |Kinds_of_Files|::          Is it a directory?  A symbolic link?
* |Truenames|::               Eliminating symbolic links from a file name.
* |File_Attributes|::         File sizes, modification times, etc.
* |Extended_Attributes|::     Extended file attributes for access control.
* |Locating_Files|::          How to find a file in standard places.

==============================================================================
File: elisp.info,  Node: |Testing_Accessibility|,  Next: |Kinds_of_Files|,  Up: |Information_about_Files|
==============================================================================

                                                         *Testing_Accessibility*

25.6.1 Testing Accessibility
----------------------------

These functions test for permission to access a file for reading,
writing, or execution.  Unless explicitly stated otherwise, they follow
symbolic links.  *Note Kinds of Files::.

   On some operating systems, more complex sets of access permissions
can be specified, via mechanisms such as Access Control Lists (ACLs).
*Note Extended Attributes::, for how to query and set those permissions.

 -- Function: file-exists-p filename
     This function returns 't' if a file named FILENAME appears to
     exist.  This does not mean you can necessarily read the file, only
     that you can probably find out its attributes.  (On GNU and other
     POSIX-like systems, this is true if the file exists and you have
     execute permission on the containing directories, regardless of the
     permissions of the file itself.)

     If the file does not exist, or if there was trouble determining
     whether the file exists, this function returns 'nil'.

     Directories are files, so 'file-exists-p' can return 't' when given
     a directory.  However, because 'file-exists-p' follows symbolic
     links, it returns 't' for a symbolic link name only if the target
     file exists.

 -- Function: file-readable-p filename
     This function returns 't' if a file named FILENAME exists and you
     can read it.  It returns 'nil' otherwise.

 -- Function: file-executable-p filename
     This function returns 't' if a file named FILENAME exists and you
     can execute it.  It returns 'nil' otherwise.  On GNU and other
     POSIX-like systems, if the file is a directory, execute permission
     means you can check the existence and attributes of files inside
     the directory, and open those files if their modes permit.

 -- Function: file-writable-p filename
     This function returns 't' if the file FILENAME can be written or
     created by you, and 'nil' otherwise.  A file is writable if the
     file exists and you can write it.  It is creatable if it does not
     exist, but its parent directory does exist and you can write in
     that directory.

     In the example below, 'foo' is not writable because the parent
     directory does not exist, even though the user could create such a
     directory.

          (file-writable-p "~/no-such-dir/foo")
               => nil

 -- Function: file-accessible-directory-p dirname
     This function returns 't' if you have permission to open existing
     files in the directory whose name as a file is DIRNAME; otherwise
     (e.g., if there is no such directory), it returns 'nil'.  The value
     of DIRNAME may be either a directory name (such as '/foo/') or the
     file name of a file which is a directory (such as '/foo', without
     the final slash).

     For example, from the following we deduce that any attempt to read
     a file in '/foo/' will give an error:

          (file-accessible-directory-p "/foo")
               => nil

 -- Function: access-file filename string
     If you can read FILENAME this function returns 'nil'; otherwise it
     signals an error using STRING as the error message text.

 -- Function: file-ownership-preserved-p filename &optional group
     This function returns 't' if deleting the file FILENAME and then
     creating it anew would keep the file's owner unchanged.  It also
     returns 't' for nonexistent files.

     If the optional argument GROUP is non-'nil', this function also
     checks that the file's group would be unchanged.

     This function does not follow symbolic links.

 -- Function: file-modes filename
     This function returns the "mode bits" of FILENAME--an integer
     summarizing its read, write, and execution permissions.  This
     function follows symbolic links.  If the file does not exist, the
     return value is 'nil'.

     *Note (coreutils)File permissions::, for a description of mode
     bits.  For example, if the low-order bit is 1, the file is
     executable by all users; if the second-lowest-order bit is 1, the
     file is writable by all users; etc.  The highest possible value is
     4095 (7777 octal), meaning that everyone has read, write, and
     execute permission, the SUID bit is set for both others and group,
     and the sticky bit is set.

     *Note Changing Files::, for the 'set-file-modes' function, which
     can be used to set these permissions.

          (file-modes "~/junk/diffs")
               => 492               ; Decimal integer.
          (format "%o" 492)
               => "754"             ; Convert to octal.

          (set-file-modes "~/junk/diffs" #o666)
               => nil

          $ ls -l diffs
          -rw-rw-rw- 1 lewis lewis 3063 Oct 30 16:00 diffs

     *MS-DOS note:* On MS-DOS, there is no such thing as an executable
     file mode bit.  So 'file-modes' considers a file executable if its
     name ends in one of the standard executable extensions, such as
     '.com', '.bat', '.exe', and some others.  Files that begin with the
     POSIX-standard '#!' signature, such as shell and Perl scripts, are
     also considered executable.  Directories are also reported as
     executable, for compatibility with POSIX.  These conventions are
     also followed by 'file-attributes' (*note File Attributes::).

==============================================================================
File: elisp.info,  Node: |Kinds_of_Files|,  Next: |Truenames|,  Prev: |Testing_Accessibility|,  Up: |Information_about_Files|
==============================================================================

                                                                *Kinds_of_Files*

25.6.2 Distinguishing Kinds of Files
------------------------------------

This section describes how to distinguish various kinds of files, such
as directories, symbolic links, and ordinary files.

   Symbolic links are ordinarily followed wherever they appear.  For
example, to interpret the file name 'a/b/c', any of 'a', 'a/b', and
'a/b/c' can be symbolic links that are followed, possibly recursively if
the link targets are themselves symbolic links.  However, a few
functions do not follow symbolic links at the end of a file name
('a/b/c' in this example).  Such a function is said to "not follow
symbolic links".

 -- Function: file-symlink-p filename
     If the file FILENAME is a symbolic link, this function does not
     follow it and instead returns its link target as a string.  (The
     link target string is not necessarily the full absolute file name
     of the target; determining the full file name that the link points
     to is nontrivial, see below.)

     If the file FILENAME is not a symbolic link, or does not exist, or
     if there is trouble determining whether it is a symbolic link,
     'file-symlink-p' returns 'nil'.

     Here are a few examples of using this function:

          (file-symlink-p "not-a-symlink")
               => nil
          (file-symlink-p "sym-link")
               => "not-a-symlink"
          (file-symlink-p "sym-link2")
               => "sym-link"
          (file-symlink-p "/bin")
               => "/pub/bin"

     Note that in the third example, the function returned 'sym-link',
     but did not proceed to resolve it, although that file is itself a
     symbolic link.  That is because this function does not follow
     symbolic links--the process of following the symbolic links does not
     apply to the last component of the file name.

     The string that this function returns is what is recorded in the
     symbolic link; it may or may not include any leading directories.
     This function does _not_ expand the link target to produce a
     fully-qualified file name, and in particular does not use the
     leading directories, if any, of the FILENAME argument if the link
     target is not an absolute file name.  Here's an example:

          (file-symlink-p "/foo/bar/baz")
               => "some-file"

     Here, although '/foo/bar/baz' was given as a fully-qualified file
     name, the result is not, and in fact does not have any leading
     directories at all.  And since 'some-file' might itself be a
     symbolic link, you cannot simply prepend leading directories to it,
     nor even naively use 'expand-file-name' (*note File Name
     Expansion::) to produce its absolute file name.

     For this reason, this function is seldom useful if you need to
     determine more than just the fact that a file is or isn't a
     symbolic link.  If you actually need the file name of the link
     target, use 'file-chase-links' or 'file-truename', described in
     *note Truenames::.

 -- Function: file-directory-p filename
     This function returns 't' if FILENAME is the name of an existing
     directory.  It returns 'nil' if FILENAME does not name a directory,
     or if there is trouble determining whether it is a directory.  This
     function follows symbolic links.

          (file-directory-p "~rms")
               => t
          (file-directory-p "~rms/lewis/files.texi")
               => nil
          (file-directory-p "~rms/lewis/no-such-file")
               => nil
          (file-directory-p "$HOME")
               => nil
          (file-directory-p
           (substitute-in-file-name "$HOME"))
               => t

 -- Function: file-regular-p filename
     This function returns 't' if the file FILENAME exists and is a
     regular file (not a directory, named pipe, terminal, or other I/O
     device).  It returns 'nil' if FILENAME does not exist or is not a
     regular file, or if there is trouble determining whether it is a
     regular file.  This function follows symbolic links.

==============================================================================
File: elisp.info,  Node: |Truenames|,  Next: |File_Attributes|,  Prev: |Kinds_of_Files|,  Up: |Information_about_Files|
==============================================================================

                                                                     *Truenames*

25.6.3 Truenames
----------------

The "truename" of a file is the name that you get by following symbolic
links at all levels until none remain, then simplifying away '.' and
'..' appearing as name components.  This results in a sort of canonical
name for the file.  A file does not always have a unique truename; the
number of distinct truenames a file has is equal to the number of hard
links to the file.  However, truenames are useful because they eliminate
symbolic links as a cause of name variation.

 -- Function: file-truename filename
     This function returns the truename of the file FILENAME.  If the
     argument is not an absolute file name, this function first expands
     it against 'default-directory'.

     This function does not expand environment variables.  Only
     'substitute-in-file-name' does that.  *Note Definition of
     substitute-in-file-name::.

     If you may need to follow symbolic links preceding '..' appearing
     as a name component, call 'file-truename' without prior direct or
     indirect calls to 'expand-file-name'.  Otherwise, the file name
     component immediately preceding '..' will be simplified away before
     'file-truename' is called.  To eliminate the need for a call to
     'expand-file-name', 'file-truename' handles '~' in the same way
     that 'expand-file-name' does.

     If the target of a symbolic links has remote file name syntax,
     'file-truename' returns it quoted.  *Note Functions that Expand
     Filenames: File Name Expansion.

 -- Function: file-chase-links filename &optional limit
     This function follows symbolic links, starting with FILENAME, until
     it finds a file name which is not the name of a symbolic link.
     Then it returns that file name.  This function does _not_ follow
     symbolic links at the level of parent directories.

     If you specify a number for LIMIT, then after chasing through that
     many links, the function just returns what it has even if that is
     still a symbolic link.

   To illustrate the difference between 'file-chase-links' and
'file-truename', suppose that '/usr/foo' is a symbolic link to the
directory '/home/foo', and '/home/foo/hello' is an ordinary file (or at
least, not a symbolic link) or nonexistent.  Then we would have:

     (file-chase-links "/usr/foo/hello")
          ;; This does not follow the links in the parent directories.
          => "/usr/foo/hello"
     (file-truename "/usr/foo/hello")
          ;; Assuming that '/home' is not a symbolic link.
          => "/home/foo/hello"

 -- Function: file-equal-p file1 file2
     This function returns 't' if the files FILE1 and FILE2 name the
     same file.  This is similar to comparing their truenames, except
     that remote file names are also handled in an appropriate manner.
     If FILE1 or FILE2 does not exist, the return value is unspecified.

 -- Function: file-name-case-insensitive-p filename
     Sometimes file names or their parts need to be compared as strings,
     in which case it's important to know whether the underlying
     filesystem is case-insensitive.  This function returns 't' if file
     FILENAME is on a case-insensitive filesystem.  It always returns
     't' on MS-DOS and MS-Windows.  On Cygwin and macOS, filesystems may
     or may not be case-insensitive, and the function tries to determine
     case-sensitivity by a runtime test.  If the test is inconclusive,
     the function returns 't' on Cygwin and 'nil' on macOS.

     Currently this function always returns 'nil' on platforms other
     than MS-DOS, MS-Windows, Cygwin, and macOS.  It does not detect
     case-insensitivity of mounted filesystems, such as Samba shares or
     NFS-mounted Windows volumes.  On remote hosts, it assumes 't' for
     the 'smb' method.  For all other connection methods, runtime tests
     are performed.

 -- Function: file-in-directory-p file dir
     This function returns 't' if FILE is a file in directory DIR, or in
     a subdirectory of DIR.  It also returns 't' if FILE and DIR are the
     same directory.  It compares the truenames of the two directories.
     If DIR does not name an existing directory, the return value is
     'nil'.

 -- Function: vc-responsible-backend file
     This function determines the responsible VC backend of the given
     FILE.  For example, if 'emacs.c' is a file tracked by Git,
     '(vc-responsible-backend "emacs.c")' returns 'Git'.  Note that if
     FILE is a symbolic link, 'vc-responsible-backend' will not resolve
     it--the backend of the symbolic link file itself is reported.  To
     get the backend VC of the file to which FILE refers, wrap FILE with
     a symbolic link resolving function such as 'file-chase-links':

          (vc-responsible-backend (file-chase-links "emacs.c"))

==============================================================================
File: elisp.info,  Node: |File_Attributes|,  Next: |Extended_Attributes|,  Prev: |Truenames|,  Up: |Information_about_Files|
==============================================================================

                                                               *File_Attributes*

25.6.4 File Attributes
----------------------

This section describes the functions for getting detailed information
about a file, including the owner and group numbers, the number of
names, the inode number, the size, and the times of access and
modification.

 -- Function: file-newer-than-file-p filename1 filename2
     This function returns 't' if the file FILENAME1 is newer than file
     FILENAME2.  If FILENAME1 does not exist, it returns 'nil'.  If
     FILENAME1 does exist, but FILENAME2 does not, it returns 't'.

     In the following example, assume that the file 'aug-19' was written
     on the 19th, 'aug-20' was written on the 20th, and the file
     'no-file' doesn't exist at all.

          (file-newer-than-file-p "aug-19" "aug-20")
               => nil
          (file-newer-than-file-p "aug-20" "aug-19")
               => t
          (file-newer-than-file-p "aug-19" "no-file")
               => t
          (file-newer-than-file-p "no-file" "aug-19")
               => nil

 -- Function: file-attributes filename &optional id-format
     This function returns a list of attributes of file FILENAME.  If
     the specified file does not exist, it returns 'nil'.  This function
     does not follow symbolic links.  The optional parameter ID-FORMAT
     specifies the preferred format of attributes UID and GID (see
     below)--the valid values are ''string' and ''integer'.  The latter
     is the default, but we plan to change that, so you should specify a
     non-'nil' value for ID-FORMAT if you use the returned UID or GID.

     On GNU platforms when operating on a local file, this function is
     atomic: if the filesystem is simultaneously being changed by some
     other process, this function returns the file's attributes either
     before or after the change.  Otherwise this function is not atomic,
     and might return 'nil' if it detects the race condition, or might
     return a hodgepodge of the previous and current file attributes.

     Accessor functions are provided to access the elements in this
     list.  The accessors are mentioned along with the descriptions of
     the elements below.

     The elements of the list, in order, are:

       0. 't' for a directory, a string for a symbolic link (the name
          linked to), or 'nil' for a text file ('file-attribute-type').

       1. The number of names the file has
          ('file-attribute-link-number').  Alternate names, also known
          as hard links, can be created by using the 'add-name-to-file'
          function (*note Changing Files::).

       2. The file's UID, normally as a string
          ('file-attribute-user-id').  However, if it does not
          correspond to a named user, the value is an integer.

       3. The file's GID, likewise ('file-attribute-group-id').

       4. The time of last access as a Lisp timestamp
          ('file-attribute-access-time').  The timestamp is in the style
          of 'current-time' (*note Time of Day::) and is truncated to
          that of the filesystem's timestamp resolution; for example, on
          some FAT-based filesystems, only the date of last access is
          recorded, so this time will always hold the midnight of the
          day of the last access.

       5. The time of last modification as a Lisp timestamp
          ('file-attribute-modification-time').  This is the last time
          when the file's contents were modified.

       6. The time of last status change as a Lisp timestamp
          ('file-attribute-status-change-time').  This is the time of
          the last change to the file's access mode bits, its owner and
          group, and other information recorded in the filesystem for
          the file, beyond the file's contents.

       7. The size of the file in bytes ('file-attribute-size').

       8. The file's modes, as a string of ten letters or dashes, as in
          'ls -l' ('file-attribute-modes').

       9. An unspecified value, present for backward compatibility.

       10. The file's inode number ('file-attribute-inode-number'), a
          nonnegative integer.

       11. The filesystem number of the device that the file is on
          'file-attribute-device-number'), an integer.  This element and
          the file's inode number together give enough information to
          distinguish any two files on the system--no two files can have
          the same values for both of these numbers.

     For example, here are the file attributes for 'files.texi':

          (file-attributes "files.texi" 'string)
               =>  (nil 1 "lh" "users"
                    (20614 64019 50040 152000)
                    (20000 23 0 0)
                    (20614 64555 902289 872000)
                    122295 "-rw-rw-rw-"
                    t 6473924464520138
                    1014478468)

     and here is how the result is interpreted:

     'nil'
          is neither a directory nor a symbolic link.

     '1'
          has only one name (the name 'files.texi' in the current
          default directory).

     '"lh"'
          is owned by the user with name 'lh'.

     '"users"'
          is in the group with name 'users'.

     '(20614 64019 50040 152000)'
          was last accessed on October 23, 2012, at 20:12:03.050040152
          UTC.

     '(20000 23 0 0)'
          was last modified on July 15, 2001, at 08:53:43 UTC.

     '(20614 64555 902289 872000)'
          last had its status changed on October 23, 2012, at
          20:20:59.902289872 UTC.

     '122295'
          is 122295 bytes long.  (It may not contain 122295 characters,
          though, if some of the bytes belong to multibyte sequences,
          and also if the end-of-line format is CR-LF.)

     '"-rw-rw-rw-"'
          has a mode of read and write access for the owner, group, and
          world.

     't'
          is merely a placeholder; it carries no information.

     '6473924464520138'
          has an inode number of 6473924464520138.

     '1014478468'
          is on the file-system device whose number is 1014478468.

 -- Function: file-nlinks filename
     This function returns the number of names (i.e., hard links) that
     file FILENAME has.  If the file does not exist, this function
     returns 'nil'.  Note that symbolic links have no effect on this
     function, because they are not considered to be names of the files
     they link to.  This function does not follow symbolic links.

          $ ls -l foo*
          -rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo
          -rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo1

          (file-nlinks "foo")
               => 2
          (file-nlinks "doesnt-exist")
               => nil

==============================================================================
File: elisp.info,  Node: |Extended_Attributes|,  Next: |Locating_Files|,  Prev: |File_Attributes|,  Up: |Information_about_Files|
==============================================================================

                                                           *Extended_Attributes*

25.6.5 Extended File Attributes
-------------------------------

On some operating systems, each file can be associated with arbitrary
"extended file attributes".  At present, Emacs supports querying and
setting two specific sets of extended file attributes: Access Control
Lists (ACLs) and SELinux contexts.  These extended file attributes are
used, on some systems, to impose more sophisticated file access controls
than the basic Unix-style permissions discussed in the previous
sections.

   A detailed explanation of ACLs and SELinux is beyond the scope of
this manual.  For our purposes, each file can be associated with an
"ACL", which specifies its properties under an ACL-based file control
system, and/or an "SELinux context", which specifies its properties
under the SELinux system.

 -- Function: file-acl filename
     This function returns the ACL for the file FILENAME.  The exact
     Lisp representation of the ACL is unspecified (and may change in
     future Emacs versions), but it is the same as what 'set-file-acl'
     takes for its ACL argument (*note Changing Files::).

     The underlying ACL implementation is platform-specific; on
     GNU/Linux and BSD, Emacs uses the POSIX ACL interface, while on
     MS-Windows Emacs emulates the POSIX ACL interface with native file
     security APIs.

     If ACLs are not supported or the file does not exist, then the
     return value is 'nil'.

 -- Function: file-selinux-context filename
     This function returns the SELinux context of the file FILENAME, as
     a list of the form '(USER ROLE TYPE RANGE)'.  The list elements are
     the context's user, role, type, and range respectively, as Lisp
     strings; see the SELinux documentation for details about what these
     actually mean.  The return value has the same form as what
     'set-file-selinux-context' takes for its CONTEXT argument (*note
     Changing Files::).

     If SELinux is not supported or the file does not exist, then the
     return value is '(nil nil nil nil)'.

 -- Function: file-extended-attributes filename
     This function returns an alist of the Emacs-recognized extended
     attributes of file FILENAME.  Currently, it serves as a convenient
     way to retrieve both the ACL and SELinux context; you can then call
     the function 'set-file-extended-attributes', with the returned
     alist as its second argument, to apply the same file access
     attributes to another file (*note Changing Files::).

     One of the elements is '(acl . ACL)', where ACL has the same form
     returned by 'file-acl'.

     Another element is '(selinux-context . CONTEXT)', where CONTEXT is
     the SELinux context, in the same form returned by
     'file-selinux-context'.

==============================================================================
File: elisp.info,  Node: |Locating_Files|,  Prev: |Extended_Attributes|,  Up: |Information_about_Files|
==============================================================================

                                                                *Locating_Files*

25.6.6 Locating Files in Standard Places
----------------------------------------

This section explains how to search for a file in a list of directories
(a "path"), or for an executable file in the standard list of executable
file directories.

   To search for a user-specific configuration file, *Note Standard File
Names::, for the 'locate-user-emacs-file' function.

 -- Function: locate-file filename path &optional suffixes predicate
     This function searches for a file whose name is FILENAME in a list
     of directories given by PATH, trying the suffixes in SUFFIXES.  If
     it finds such a file, it returns the file's absolute file name
     (*note Relative File Names::); otherwise it returns 'nil'.

     The optional argument SUFFIXES gives the list of file-name suffixes
     to append to FILENAME when searching.  'locate-file' tries each
     possible directory with each of these suffixes.  If SUFFIXES is
     'nil', or '("")', then there are no suffixes, and FILENAME is used
     only as-is.  Typical values of SUFFIXES are 'exec-suffixes' (*note
     Subprocess Creation::), 'load-suffixes', 'load-file-rep-suffixes'
     and the return value of the function 'get-load-suffixes' (*note
     Load Suffixes::).

     Typical values for PATH are 'exec-path' (*note Subprocess
     Creation::) when looking for executable programs, or 'load-path'
     (*note Library Search::) when looking for Lisp files.  If FILENAME
     is absolute, PATH has no effect, but the suffixes in SUFFIXES are
     still tried.

     The optional argument PREDICATE, if non-'nil', specifies a
     predicate function for testing whether a candidate file is
     suitable.  The predicate is passed the candidate file name as its
     single argument.  If PREDICATE is 'nil' or omitted, 'locate-file'
     uses 'file-readable-p' as the predicate.  *Note Kinds of Files::,
     for other useful predicates, e.g., 'file-executable-p' and
     'file-directory-p'.

     This function will normally skip directories, so if you want it to
     find directories, make sure the PREDICATE function returns 'dir-ok'
     for them.  For example:

          (locate-file "html" '("/var/www" "/srv") nil
                       (lambda (f) (if (file-directory-p f) 'dir-ok)))

     For compatibility, PREDICATE can also be one of the symbols
     'executable', 'readable', 'writable', 'exists', or a list of one or
     more of these symbols.

 -- Function: executable-find program &optional remote
     This function searches for the executable file of the named PROGRAM
     and returns the absolute file name of the executable, including its
     file-name extensions, if any.  It returns 'nil' if the file is not
     found.  The function searches in all the directories in
     'exec-path', and tries all the file-name extensions in
     'exec-suffixes' (*note Subprocess Creation::).

     If REMOTE is non-'nil', and 'default-directory' is a remote
     directory, PROGRAM is searched on the respective remote host.

==============================================================================
File: elisp.info,  Node: |Changing_Files|,  Next: |Files_and_Storage|,  Prev: |Information_about_Files|,  Up: |Files|
==============================================================================

                                                                *Changing_Files*

25.7 Changing File Names and Attributes
=--------------------------------------

The functions in this section rename, copy, delete, link, and set the
modes (permissions) of files.  Typically, they signal a 'file-error'
error if they fail to perform their function, reporting the
system-dependent error message that describes the reason for the
failure.  If they fail because a file is missing, they signal a
'file-missing' error instead.

   For performance, the operating system may cache or alias changes made
by these functions instead of writing them immediately to secondary
storage.  *Note Files and Storage::.

   In the functions that have an argument NEWNAME, if this argument is a
directory name it is treated as if the nondirectory part of the source
name were appended.  Typically, a directory name is one that ends in '/'
(*note Directory Names::).  For example, if the old name is 'a/b/c', the
NEWNAME 'd/e/f/' is treated as if it were 'd/e/f/c'.  This special
treatment does not apply if NEWNAME is not a directory name but names a
file that is a directory; for example, the NEWNAME 'd/e/f' is left as-is
even if 'd/e/f' happens to be a directory.

   In the functions that have an argument NEWNAME, if a file by the name
of NEWNAME already exists, the actions taken depend on the value of the
argument OK-IF-ALREADY-EXISTS:

   * Signal a 'file-already-exists' error if OK-IF-ALREADY-EXISTS is
     'nil'.

   * Request confirmation if OK-IF-ALREADY-EXISTS is a number.

   * Replace the old file without confirmation if OK-IF-ALREADY-EXISTS
     is any other value.

 -- Command: add-name-to-file oldname newname &optional
          ok-if-already-exists
     This function gives the file named OLDNAME the additional name
     NEWNAME.  This means that NEWNAME becomes a new hard link to
     OLDNAME.

     If NEWNAME is a symbolic link, its directory entry is replaced, not
     the directory entry it points to.  If OLDNAME is a symbolic link,
     this function might or might not follow the link; it does not
     follow the link on GNU platforms.  If OLDNAME is a directory, this
     function typically fails, although for the superuser on a few
     old-fashioned non-GNU platforms it can succeed and create a
     filesystem that is not tree-structured.

     In the first part of the following example, we list two files,
     'foo' and 'foo3'.

          $ ls -li fo*
          81908 -rw-rw-rw- 1 rms rms 29 Aug 18 20:32 foo
          84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3

     Now we create a hard link, by calling 'add-name-to-file', then list
     the files again.  This shows two names for one file, 'foo' and
     'foo2'.

          (add-name-to-file "foo" "foo2")
               => nil

          $ ls -li fo*
          81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo
          81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo2
          84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3

     Finally, we evaluate the following:

          (add-name-to-file "foo" "foo3" t)

     and list the files again.  Now there are three names for one file:
     'foo', 'foo2', and 'foo3'.  The old contents of 'foo3' are lost.

          (add-name-to-file "foo1" "foo3")
               => nil

          $ ls -li fo*
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo2
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo3

     This function is meaningless on operating systems where multiple
     names for one file are not allowed.  Some systems implement
     multiple names by copying the file instead.

     See also 'file-nlinks' in *note File Attributes::.

 -- Command: rename-file filename newname &optional ok-if-already-exists
     This command renames the file FILENAME as NEWNAME.

     If FILENAME has additional names aside from FILENAME, it continues
     to have those names.  In fact, adding the name NEWNAME with
     'add-name-to-file' and then deleting FILENAME has the same effect
     as renaming, aside from momentary intermediate states and treatment
     of errors, directories and symbolic links.

     This command does not follow symbolic links.  If FILENAME is a
     symbolic link, this command renames the symbolic link, not the file
     it points to.  If NEWNAME is a symbolic link, its directory entry
     is replaced, not the directory entry it points to.

     This command does nothing if FILENAME and NEWNAME are the same
     directory entry, i.e., if they refer to the same parent directory
     and give the same name within that directory.  Otherwise, if
     FILENAME and NEWNAME name the same file, this command does nothing
     on POSIX-conforming systems, and removes FILENAME on some non-POSIX
     systems.

     If NEWNAME exists, then it must be an empty directory if OLDNAME is
     a directory and a non-directory otherwise.

 -- Command: copy-file oldname newname &optional ok-if-already-exists
          time preserve-uid-gid preserve-extended-attributes
     This command copies the file OLDNAME to NEWNAME.  An error is
     signaled if OLDNAME is not a regular file.  If NEWNAME names a
     directory, it copies OLDNAME into that directory, preserving its
     final name component.

     This function follows symbolic links, except that it does not
     follow a dangling symbolic link to create NEWNAME.

     If TIME is non-'nil', then this function gives the new file the
     same last-modified time that the old one has.  (This works on only
     some operating systems.)  If setting the time gets an error,
     'copy-file' signals a 'file-date-error' error.  In an interactive
     call, a prefix argument specifies a non-'nil' value for TIME.

     If argument PRESERVE-UID-GID is 'nil', we let the operating system
     decide the user and group ownership of the new file (this is
     usually set to the user running Emacs).  If PRESERVE-UID-GID is
     non-'nil', we attempt to copy the user and group ownership of the
     file.  This works only on some operating systems, and only if you
     have the correct permissions to do so.

     If the optional argument PRESERVE-PERMISSIONS is non-'nil', this
     function copies the file modes (or "permissions") of OLDNAME to
     NEWNAME, as well as the Access Control List and SELinux context (if
     any).  *Note Information about Files::.

     Otherwise, the file modes of NEWNAME are left unchanged if it is an
     existing file, and set to those of OLDNAME, masked by the default
     file permissions (see 'set-default-file-modes' below), if NEWNAME
     is to be newly created.  The Access Control List or SELinux context
     are not copied over in either case.

 -- Command: make-symbolic-link target linkname &optional
          ok-if-already-exists
     This command makes a symbolic link to TARGET, named LINKNAME.  This
     is like the shell command 'ln -s TARGET LINKNAME'.  The TARGET
     argument is treated only as a string; it need not name an existing
     file.  If OK-IF-ALREADY-EXISTS is an integer, indicating
     interactive use, then leading '~' is expanded and leading '/:' is
     stripped in the TARGET string.

     If TARGET is a relative file name, the resulting symbolic link is
     interpreted relative to the directory containing the symbolic link.
     *Note Relative File Names::.

     If both TARGET and LINKNAME have remote file name syntax, and if
     both remote identifications are equal, the symbolic link points to
     the local file name part of TARGET.

     This function is not available on systems that don't support
     symbolic links.

 -- Command: delete-file filename &optional trash
     This command deletes the file FILENAME.  If the file has multiple
     names, it continues to exist under the other names.  If FILENAME is
     a symbolic link, 'delete-file' deletes only the symbolic link and
     not its target.

     A suitable kind of 'file-error' error is signaled if the file does
     not exist, or is not deletable.  (On GNU and other POSIX-like
     systems, a file is deletable if its directory is writable.)

     If the optional argument TRASH is non-'nil' and the variable
     'delete-by-moving-to-trash' is non-'nil', this command moves the
     file into the system Trash instead of deleting it.  *Note
     Miscellaneous File Operations: (emacs)Misc File Ops.  When called
     interactively, TRASH is 't' if no prefix argument is given, and
     'nil' otherwise.

     See also 'delete-directory' in *note Create/Delete Dirs::.

 -- Command: set-file-modes filename mode
     This function sets the "file mode" (or "permissions") of FILENAME
     to MODE.  This function follows symbolic links.

     If called non-interactively, MODE must be an integer.  Only the
     lowest 12 bits of the integer are used; on most systems, only the
     lowest 9 bits are meaningful.  You can use the Lisp construct for
     octal numbers to enter MODE.  For example,

          (set-file-modes #o644)

     specifies that the file should be readable and writable for its
     owner, readable for group members, and readable for all other
     users.  *Note (coreutils)File permissions::, for a description of
     mode bit specifications.

     Interactively, MODE is read from the minibuffer using
     'read-file-modes' (see below), which lets the user type in either
     an integer or a string representing the permissions symbolically.

     *Note File Attributes::, for the function 'file-modes', which
     returns the permissions of a file.

 -- Function: set-default-file-modes mode
     This function sets the default permissions for new files created by
     Emacs and its subprocesses.  Every file created with Emacs
     initially has these permissions, or a subset of them
     ('write-region' will not grant execute permissions even if the
     default file permissions allow execution).  On GNU and other
     POSIX-like systems, the default permissions are given by the
     bitwise complement of the 'umask' value, i.e. each bit that is set
     in the argument MODE will be _reset_ in the default permissions
     with which Emacs creates files.

     The argument MODE should be an integer which specifies the
     permissions, similar to 'set-file-modes' above.  Only the lowest 9
     bits are meaningful.

     The default file permissions have no effect when you save a
     modified version of an existing file; saving a file preserves its
     existing permissions.

 -- Macro: with-file-modes mode body...
     This macro evaluates the BODY forms with the default permissions
     for new files temporarily set to MODES (whose value is as for
     'set-file-modes' above).  When finished, it restores the original
     default file permissions, and returns the value of the last form in
     BODY.

     This is useful for creating private files, for example.

 -- Function: default-file-modes
     This function returns the default file permissions, as an integer.

 -- Function: read-file-modes &optional prompt base-file
     This function reads a set of file mode bits from the minibuffer.
     The first optional argument PROMPT specifies a non-default prompt.
     Second second optional argument BASE-FILE is the name of a file on
     whose permissions to base the mode bits that this function returns,
     if what the user types specifies mode bits relative to permissions
     of an existing file.

     If user input represents an octal number, this function returns
     that number.  If it is a complete symbolic specification of mode
     bits, as in '"u=rwx"', the function converts it to the equivalent
     numeric value using 'file-modes-symbolic-to-number' and returns the
     result.  If the specification is relative, as in '"o+g"', then the
     permissions on which the specification is based are taken from the
     mode bits of BASE-FILE.  If BASE-FILE is omitted or 'nil', the
     function uses '0' as the base mode bits.  The complete and relative
     specifications can be combined, as in '"u+r,g+rx,o+r,g-w"'.  *Note
     (coreutils)File permissions::, for a description of file mode
     specifications.

 -- Function: file-modes-symbolic-to-number modes &optional base-modes
     This function converts a symbolic file mode specification in MODES
     into the equivalent integer.  If the symbolic specification is
     based on an existing file, that file's mode bits are taken from the
     optional argument BASE-MODES; if that argument is omitted or 'nil',
     it defaults to 0, i.e., no access rights at all.

 -- Function: set-file-times filename &optional time
     This function sets the access and modification times of FILENAME to
     TIME.  The return value is 't' if the times are successfully set,
     otherwise it is 'nil'.  TIME defaults to the current time and must
     be a time value (*note Time of Day::).

 -- Function: set-file-extended-attributes filename attribute-alist
     This function sets the Emacs-recognized extended file attributes
     for 'filename'.  The second argument ATTRIBUTE-ALIST should be an
     alist of the same form returned by 'file-extended-attributes'.  The
     return value is 't' if the attributes are successfully set,
     otherwise it is 'nil'.  *Note Extended Attributes::.

 -- Function: set-file-selinux-context filename context
     This function sets the SELinux security context for FILENAME to
     CONTEXT.  The CONTEXT argument should be a list '(USER ROLE TYPE
     RANGE)', where each element is a string.  *Note Extended
     Attributes::.

     The function returns 't' if it succeeds in setting the SELinux
     context of FILENAME.  It returns 'nil' if the context was not set
     (e.g., if SELinux is disabled, or if Emacs was compiled without
     SELinux support).

 -- Function: set-file-acl filename acl
     This function sets the Access Control List for FILENAME to ACL.
     The ACL argument should have the same form returned by the function
     'file-acl'.  *Note Extended Attributes::.

     The function returns 't' if it successfully sets the ACL of
     FILENAME, 'nil' otherwise.

==============================================================================
File: elisp.info,  Node: |Files_and_Storage|,  Next: |File_Names|,  Prev: |Changing_Files|,  Up: |Files|
==============================================================================

                                                             *Files_and_Storage*

25.8 Files and Secondary Storage
=-------------------------------

After Emacs changes a file, there are two reasons the changes might not
survive later failures of power or media, both having to do with
efficiency.  First, the operating system might alias written data with
data already stored elsewhere on secondary storage until one file or the
other is later modified; this will lose both files if the only copy on
secondary storage is lost due to media failure.  Second, the operating
system might not write data to secondary storage immediately, which will
lose the data if power is lost.

   Although both sorts of failures can largely be avoided by a suitably
configured file system, such systems are typically more expensive or
less efficient.  In more-typical systems, to survive media failure you
can copy the file to a different device, and to survive a power failure
you can use the 'write-region' function with the
'write-region-inhibit-fsync' variable set to 'nil'.  *Note Writing to
Files::.

==============================================================================
File: elisp.info,  Node: |File_Names|,  Next: |Contents_of_Directories|,  Prev: |Files_and_Storage|,  Up: |Files|
==============================================================================

                                                                    *File_Names*

25.9 File Names
=--------------

Files are generally referred to by their names, in Emacs as elsewhere.
File names in Emacs are represented as strings.  The functions that
operate on a file all expect a file name argument.

   In addition to operating on files themselves, Emacs Lisp programs
often need to operate on file names; i.e., to take them apart and to use
part of a name to construct related file names.  This section describes
how to manipulate file names.

   The functions in this section do not actually access files, so they
can operate on file names that do not refer to an existing file or
directory.

   On MS-DOS and MS-Windows, these functions (like the function that
actually operate on files) accept MS-DOS or MS-Windows file-name syntax,
where backslashes separate the components, as well as POSIX syntax; but
they always return POSIX syntax.  This enables Lisp programs to specify
file names in POSIX syntax and work properly on all systems without
change.(1)

MENU

* |File_Name_Components|::  The directory part of a file name, and the rest.
* |Relative_File_Names|::   Some file names are relative to a current directory.
* |Directory_Names|::       A directory's name as a directory
                            is different from its name as a file.
* |File_Name_Expansion|::   Converting relative file names to absolute ones.
* |Unique_File_Names|::     Generating names for temporary files.
* |File_Name_Completion|::  Finding the completions for a given file name.
* |Standard_File_Names|::   If your package uses a fixed file name,
                            how to handle various operating systems simply.

   ---------- Footnotes ----------

   (1) In MS-Windows versions of Emacs compiled for the Cygwin
environment, you can use the functions
'cygwin-convert-file-name-to-windows' and
'cygwin-convert-file-name-from-windows' to convert between the two
file-name syntaxes.

==============================================================================
File: elisp.info,  Node: |File_Name_Components|,  Next: |Relative_File_Names|,  Up: |File_Names|
==============================================================================

                                                          *File_Name_Components*

25.9.1 File Name Components
---------------------------

The operating system groups files into directories.  To specify a file,
you must specify the directory and the file's name within that
directory.  Therefore, Emacs considers a file name as having two main
parts: the "directory name" part, and the "nondirectory" part (or "file
name within the directory").  Either part may be empty.  Concatenating
these two parts reproduces the original file name.

   On most systems, the directory part is everything up to and including
the last slash (backslash is also allowed in input on MS-DOS or
MS-Windows); the nondirectory part is the rest.

   For some purposes, the nondirectory part is further subdivided into
the name proper and the "version number".  On most systems, only backup
files have version numbers in their names.

 -- Function: file-name-directory filename
     This function returns the directory part of FILENAME, as a
     directory name (*note Directory Names::), or 'nil' if FILENAME does
     not include a directory part.

     On GNU and other POSIX-like systems, a string returned by this
     function always ends in a slash.  On MS-DOS it can also end in a
     colon.

          (file-name-directory "lewis/foo")  ; GNU example
               => "lewis/"
          (file-name-directory "foo")        ; GNU example
               => nil

 -- Function: file-name-nondirectory filename
     This function returns the nondirectory part of FILENAME.

          (file-name-nondirectory "lewis/foo")
               => "foo"
          (file-name-nondirectory "foo")
               => "foo"
          (file-name-nondirectory "lewis/")
               => ""

 -- Function: file-name-sans-versions filename &optional
          keep-backup-version
     This function returns FILENAME with any file version numbers,
     backup version numbers, or trailing tildes discarded.

     If KEEP-BACKUP-VERSION is non-'nil', then true file version numbers
     understood as such by the file system are discarded from the return
     value, but backup version numbers are kept.

          (file-name-sans-versions "~rms/foo.~1~")
               => "~rms/foo"
          (file-name-sans-versions "~rms/foo~")
               => "~rms/foo"
          (file-name-sans-versions "~rms/foo")
               => "~rms/foo"

 -- Function: file-name-extension filename &optional period
     This function returns FILENAME's final extension, if any, after
     applying 'file-name-sans-versions' to remove any version/backup
     part.  The extension, in a file name, is the part that follows the
     last '.' in the last name component (minus any version/backup
     part).

     This function returns 'nil' for extensionless file names such as
     'foo'.  It returns '""' for null extensions, as in 'foo.'.  If the
     last component of a file name begins with a '.', that '.' doesn't
     count as the beginning of an extension.  Thus, '.emacs''s extension
     is 'nil', not '.emacs'.

     If PERIOD is non-'nil', then the returned value includes the period
     that delimits the extension, and if FILENAME has no extension, the
     value is '""'.

 -- Function: file-name-sans-extension filename
     This function returns FILENAME minus its extension, if any.  The
     version/backup part, if present, is only removed if the file has an
     extension.  For example,

          (file-name-sans-extension "foo.lose.c")
               => "foo.lose"
          (file-name-sans-extension "big.hack/foo")
               => "big.hack/foo"
          (file-name-sans-extension "/my/home/.emacs")
               => "/my/home/.emacs"
          (file-name-sans-extension "/my/home/.emacs.el")
               => "/my/home/.emacs"
          (file-name-sans-extension "~/foo.el.~3~")
               => "~/foo"
          (file-name-sans-extension "~/foo.~3~")
               => "~/foo.~3~"

     Note that the '.~3~' in the two last examples is the backup part,
     not an extension.

 -- Function: file-name-base filename
     This function is the composition of 'file-name-sans-extension' and
     'file-name-nondirectory'.  For example,

          (file-name-base "/my/home/foo.c")
              => "foo"

==============================================================================
File: elisp.info,  Node: |Relative_File_Names|,  Next: |Directory_Names|,  Prev: |File_Name_Components|,  Up: |File_Names|
==============================================================================

                                                           *Relative_File_Names*

25.9.2 Absolute and Relative File Names
---------------------------------------

All the directories in the file system form a tree starting at the root
directory.  A file name can specify all the directory names starting
from the root of the tree; then it is called an "absolute" file name.
Or it can specify the position of the file in the tree relative to a
default directory; then it is called a "relative" file name.  On GNU and
other POSIX-like systems, after any leading '~' has been expanded, an
absolute file name starts with a '/' (*note abbreviate-file-name::), and
a relative one does not.  On MS-DOS and MS-Windows, an absolute file
name starts with a slash or a backslash, or with a drive specification
'X:/', where X is the "drive letter".

 -- Function: file-name-absolute-p filename
     This function returns 't' if file FILENAME is an absolute file
     name, 'nil' otherwise.  A file name is considered to be absolute if
     its first component is '~', or is '~USER' where USER is a valid
     login name.  In the following examples, assume that there is a user
     named 'rms' but no user named 'nosuchuser'.

          (file-name-absolute-p "~rms/foo")
               => t
          (file-name-absolute-p "~nosuchuser/foo")
               => nil
          (file-name-absolute-p "rms/foo")
               => nil
          (file-name-absolute-p "/user/rms/foo")
               => t

   Given a possibly relative file name, you can expand any leading '~'
and convert the result to an absolute name using 'expand-file-name'
(*note File Name Expansion::).  This function converts absolute file
names to relative names:

 -- Function: file-relative-name filename &optional directory
     This function tries to return a relative name that is equivalent to
     FILENAME, assuming the result will be interpreted relative to
     DIRECTORY (an absolute directory name or directory file name).  If
     DIRECTORY is omitted or 'nil', it defaults to the current buffer's
     default directory.

     On some operating systems, an absolute file name begins with a
     device name.  On such systems, FILENAME has no relative equivalent
     based on DIRECTORY if they start with two different device names.
     In this case, 'file-relative-name' returns FILENAME in absolute
     form.

          (file-relative-name "/foo/bar" "/foo/")
               => "bar"
          (file-relative-name "/foo/bar" "/hack/")
               => "../foo/bar"

==============================================================================
File: elisp.info,  Node: |Directory_Names|,  Next: |File_Name_Expansion|,  Prev: |Relative_File_Names|,  Up: |File_Names|
==============================================================================

                                                               *Directory_Names*

25.9.3 Directory Names
----------------------

A "directory name" is a string that must name a directory if it names
any file at all.  A directory is actually a kind of file, and it has a
file name (called the "directory file name", which is related to the
directory name but is typically not identical.  (This is not quite the
same as the usual POSIX terminology.)  These two names for the same
entity are related by a syntactic transformation.  On GNU and other
POSIX-like systems, this is simple: to obtain a directory name, append a
'/' to a directory file name that does not already end in '/'.  On
MS-DOS the relationship is more complicated.

   The difference between a directory name and a directory file name is
subtle but crucial.  When an Emacs variable or function argument is
described as being a directory name, a directory file name is not
acceptable.  When 'file-name-directory' returns a string, that is always
a directory name.

   The following two functions convert between directory names and
directory file names.  They do nothing special with environment variable
substitutions such as '$HOME', and the constructs '~', '.' and '..'.

 -- Function: file-name-as-directory filename
     This function returns a string representing FILENAME in a form that
     the operating system will interpret as the name of a directory (a
     directory name).  On most systems, this means appending a slash to
     the string (if it does not already end in one).

          (file-name-as-directory "~rms/lewis")
               => "~rms/lewis/"

 -- Function: directory-name-p filename
     This function returns non-'nil' if FILENAME ends with a directory
     separator character.  This is the forward slash '/' on GNU and
     other POSIX-like systems; MS-Windows and MS-DOS recognize both the
     forward slash and the backslash '\' as directory separators.

 -- Function: directory-file-name dirname
     This function returns a string representing DIRNAME in a form that
     the operating system will interpret as the name of a file (a
     directory file name).  On most systems, this means removing the
     final directory separators from the string, unless the string
     consists entirely of directory separators.

          (directory-file-name "~lewis/")
               => "~lewis"

   Given a directory name, you can combine it with a relative file name
using 'concat':

     (concat DIRNAME RELFILE)

Be sure to verify that the file name is relative before doing that.  If
you use an absolute file name, the results could be syntactically
invalid or refer to the wrong file.

   If you want to use a directory file name in making such a
combination, you must first convert it to a directory name using
'file-name-as-directory':

     (concat (file-name-as-directory DIRFILE) RELFILE)

Don't try concatenating a slash by hand, as in

     ;;; Wrong!
     (concat DIRFILE "/" RELFILE)

because this is not portable.  Always use 'file-name-as-directory'.

   To avoid the issues mentioned above, or if the DIRNAME value might be
'nil' (for example, from an element of 'load-path'), use:

     (expand-file-name RELFILE DIRNAME)

   However, 'expand-file-name' expands leading '~' in RELFILE, which may
not be what you want.  *Note File Name Expansion::.

   To convert a directory name to its abbreviation, use this function:

 -- Function: abbreviate-file-name filename
     This function returns an abbreviated form of FILENAME.  It applies
     the abbreviations specified in 'directory-abbrev-alist' (*note File
     Aliases: (emacs)File Aliases.), then substitutes '~' for the user's
     home directory if the argument names a file in the home directory
     or one of its subdirectories.  If the home directory is a root
     directory, it is not replaced with '~', because this does not make
     the result shorter on many systems.

     You can use this function for directory names and for file names,
     because it recognizes abbreviations even as part of the name.

==============================================================================
File: elisp.info,  Node: |File_Name_Expansion|,  Next: |Unique_File_Names|,  Prev: |Directory_Names|,  Up: |File_Names|
==============================================================================

                                                           *File_Name_Expansion*

25.9.4 Functions that Expand Filenames
--------------------------------------

"Expanding" a file name means converting a relative file name to an
absolute one.  Since this is done relative to a default directory, you
must specify the default directory as well as the file name to be
expanded.  It also involves expanding abbreviations like '~/' (*note
abbreviate-file-name::), and eliminating redundancies like './' and
'NAME/../'.

 -- Function: expand-file-name filename &optional directory
     This function converts FILENAME to an absolute file name.  If
     DIRECTORY is supplied, it is the default directory to start with if
     FILENAME is relative and does not start with '~'.  (The value of
     DIRECTORY should itself be an absolute directory name or directory
     file name; it may start with '~'.)  Otherwise, the current buffer's
     value of 'default-directory' is used.  For example:

          (expand-file-name "foo")
               => "/xcssun/users/rms/lewis/foo"
          (expand-file-name "../foo")
               => "/xcssun/users/rms/foo"
          (expand-file-name "foo" "/usr/spool/")
               => "/usr/spool/foo"

     If the part of FILENAME before the first slash is '~', it expands
     to your home directory, which is typically specified by the value
     of the 'HOME' environment variable (*note (emacs)General
     Variables::).  If the part before the first slash is '~USER' and if
     USER is a valid login name, it expands to USER's home directory.
     If you do not want this expansion for a relative FILENAME that
     might begin with a literal '~', you can use '(concat
     (file-name-as-directory directory) filename)' instead of
     '(expand-file-name filename directory)'.

     Filenames containing '.' or '..' are simplified to their canonical
     form:

          (expand-file-name "bar/../foo")
               => "/xcssun/users/rms/lewis/foo"

     In some cases, a leading '..' component can remain in the output:

          (expand-file-name "../home" "/")
               => "/../home"

     This is for the sake of filesystems that have the concept of a
     superroot above the root directory '/'.  On other filesystems,
     '/../' is interpreted exactly the same as '/'.

     Expanding '.' or the empty string returns the default directory:

          (expand-file-name "." "/usr/spool/")
               => "/usr/spool"
          (expand-file-name "" "/usr/spool/")
               => "/usr/spool"

     Note that 'expand-file-name' does _not_ expand environment
     variables; only 'substitute-in-file-name' does that:

          (expand-file-name "$HOME/foo")
               => "/xcssun/users/rms/lewis/$HOME/foo"

     Note also that 'expand-file-name' does not follow symbolic links at
     any level.  This results in a difference between the way
     'file-truename' and 'expand-file-name' treat '..'.  Assuming that
     '/tmp/bar' is a symbolic link to the directory '/tmp/foo/bar' we
     get:

          (file-truename "/tmp/bar/../myfile")
               => "/tmp/foo/myfile"
          (expand-file-name "/tmp/bar/../myfile")
               => "/tmp/myfile"

     If you may need to follow symbolic links preceding '..', you should
     make sure to call 'file-truename' without prior direct or indirect
     calls to 'expand-file-name'.  *Note Truenames::.

 -- Variable: default-directory
     The value of this buffer-local variable is the default directory
     for the current buffer.  It should be an absolute directory name;
     it may start with '~'.  This variable is buffer-local in every
     buffer.

     'expand-file-name' uses the default directory when its second
     argument is 'nil'.

     The value is always a string ending with a slash.

          default-directory
               => "/user/lewis/manual/"

 -- Function: substitute-in-file-name filename
     This function replaces environment variable references in FILENAME
     with the environment variable values.  Following standard Unix
     shell syntax, '$' is the prefix to substitute an environment
     variable value.  If the input contains '$$', that is converted to
     '$'; this gives the user a way to quote a '$'.

     The environment variable name is the series of alphanumeric
     characters (including underscores) that follow the '$'.  If the
     character following the '$' is a '{', then the variable name is
     everything up to the matching '}'.

     Calling 'substitute-in-file-name' on output produced by
     'substitute-in-file-name' tends to give incorrect results.  For
     instance, use of '$$' to quote a single '$' won't work properly,
     and '$' in an environment variable's value could lead to repeated
     substitution.  Therefore, programs that call this function and put
     the output where it will be passed to this function need to double
     all '$' characters to prevent subsequent incorrect results.

     Here we assume that the environment variable 'HOME', which holds
     the user's home directory, has value '/xcssun/users/rms'.

          (substitute-in-file-name "$HOME/foo")
               => "/xcssun/users/rms/foo"

     After substitution, if a '~' or a '/' appears immediately after
     another '/', the function discards everything before it (up through
     the immediately preceding '/').

          (substitute-in-file-name "bar/~/foo")
               => "~/foo"
          (substitute-in-file-name "/usr/local/$HOME/foo")
               => "/xcssun/users/rms/foo"
               ;; '/usr/local/' has been discarded.

   Sometimes, it is not desired to expand file names.  In such cases,
the file name can be quoted to suppress the expansion, and to handle the
file name literally.  Quoting happens by prefixing the file name with
'/:'.

 -- Macro: file-name-quote name
     This macro adds the quotation prefix '/:' to the file NAME.  For a
     local file NAME, it prefixes NAME with '/:'.  If NAME is a remote
     file name, the local part of NAME (*note Magic File Names::) is
     quoted.  If NAME is already a quoted file name, NAME is returned
     unchanged.

          (substitute-in-file-name (file-name-quote "bar/~/foo"))
               => "/:bar/~/foo"

          (substitute-in-file-name (file-name-quote "/ssh:host:bar/~/foo"))
               => "/ssh:host:/:bar/~/foo"

     The macro cannot be used to suppress file name handlers from magic
     file names (*note Magic File Names::).

 -- Macro: file-name-unquote name
     This macro removes the quotation prefix '/:' from the file NAME, if
     any.  If NAME is a remote file name, the local part of NAME is
     unquoted.

 -- Macro: file-name-quoted-p name
     This macro returns non-'nil', when NAME is quoted with the prefix
     '/:'.  If NAME is a remote file name, the local part of NAME is
     checked.

==============================================================================
File: elisp.info,  Node: |Unique_File_Names|,  Next: |File_Name_Completion|,  Prev: |File_Name_Expansion|,  Up: |File_Names|
==============================================================================

                                                             *Unique_File_Names*

25.9.5 Generating Unique File Names
-----------------------------------

Some programs need to write temporary files.  Here is the usual way to
construct a name for such a file:

     (make-temp-file NAME-OF-APPLICATION)

The job of 'make-temp-file' is to prevent two different users or two
different jobs from trying to use the exact same file name.

 -- Function: make-temp-file prefix &optional dir-flag suffix text
     This function creates a temporary file and returns its name.  Emacs
     creates the temporary file's name by adding to PREFIX some random
     characters that are different in each Emacs job.  The result is
     guaranteed to be a newly created file, containing TEXT if that's
     given as a string and empty otherwise.  On MS-DOS, this function
     can truncate PREFIX to fit into the 8+3 file-name limits.  If
     PREFIX is a relative file name, it is expanded against
     'temporary-file-directory'.

          (make-temp-file "foo")
               => "/tmp/foo232J6v"

     When 'make-temp-file' returns, the file has been created and is
     empty.  At that point, you should write the intended contents into
     the file.

     If DIR-FLAG is non-'nil', 'make-temp-file' creates an empty
     directory instead of an empty file.  It returns the file name, not
     the directory name, of that directory.  *Note Directory Names::.

     If SUFFIX is non-'nil', 'make-temp-file' adds it at the end of the
     file name.

     If TEXT is a string, 'make-temp-file' inserts it in the file.

     To prevent conflicts among different libraries running in the same
     Emacs, each Lisp program that uses 'make-temp-file' should have its
     own PREFIX.  The number added to the end of PREFIX distinguishes
     between the same application running in different Emacs jobs.
     Additional added characters permit a large number of distinct names
     even in one Emacs job.

   The default directory for temporary files is controlled by the
variable 'temporary-file-directory'.  This variable gives the user a
uniform way to specify the directory for all temporary files.  Some
programs use 'small-temporary-file-directory' instead, if that is
non-'nil'.  To use it, you should expand the prefix against the proper
directory before calling 'make-temp-file'.

 -- User Option: temporary-file-directory
     This variable specifies the directory name for creating temporary
     files.  Its value should be a directory name (*note Directory
     Names::), but it is good for Lisp programs to cope if the value is
     a directory's file name instead.  Using the value as the second
     argument to 'expand-file-name' is a good way to achieve that.

     The default value is determined in a reasonable way for your
     operating system; it is based on the 'TMPDIR', 'TMP' and 'TEMP'
     environment variables, with a fall-back to a system-dependent name
     if none of these variables is defined.

     Even if you do not use 'make-temp-file' to create the temporary
     file, you should still use this variable to decide which directory
     to put the file in.  However, if you expect the file to be small,
     you should use 'small-temporary-file-directory' first if that is
     non-'nil'.

 -- User Option: small-temporary-file-directory
     This variable specifies the directory name for creating certain
     temporary files, which are likely to be small.

     If you want to write a temporary file which is likely to be small,
     you should compute the directory like this:

          (make-temp-file
            (expand-file-name PREFIX
                              (or small-temporary-file-directory
                                  temporary-file-directory)))

 -- Function: make-temp-name base-name
     This function generates a string that might be a unique file name.
     The name starts with BASE-NAME, and has several random characters
     appended to it, which are different in each Emacs job.  It is like
     'make-temp-file' except that (i) it just constructs a name and does
     not create a file, (ii) BASE-NAME should be an absolute file name
     that is not magic, and (iii) if the returned file name is magic, it
     might name an existing file.  *Note Magic File Names::.

     Warning: In most cases, you should not use this function; use
     'make-temp-file' instead!  This function is susceptible to a race
     condition, between the 'make-temp-name' call and the creation of
     the file, which in some cases may cause a security hole.

   Sometimes, it is necessary to create a temporary file on a remote
host or a mounted directory.  The following two functions support this.

 -- Function: make-nearby-temp-file prefix &optional dir-flag suffix
     This function is similar to 'make-temp-file', but it creates a
     temporary file as close as possible to 'default-directory'.  If
     PREFIX is a relative file name, and 'default-directory' is a remote
     file name or located on a mounted file systems, the temporary file
     is created in the directory returned by the function
     'temporary-file-directory'.  Otherwise, the function
     'make-temp-file' is used.  PREFIX, DIR-FLAG and SUFFIX have the
     same meaning as in 'make-temp-file'.

          (let ((default-directory "/ssh:remotehost:"))
            (make-nearby-temp-file "foo"))
               => "/ssh:remotehost:/tmp/foo232J6v"

 -- Function: temporary-file-directory
     The directory for writing temporary files via
     'make-nearby-temp-file'.  In case of a remote 'default-directory',
     this is a directory for temporary files on that remote host.  If
     such a directory does not exist, or 'default-directory' ought to be
     located on a mounted file system (see 'mounted-file-systems'), the
     function returns 'default-directory'.  For a non-remote and
     non-mounted 'default-directory', the value of the variable
     'temporary-file-directory' is returned.

   In order to extract the local part of the file's name of a temporary
file, use 'file-local-name' (*note Magic File Names::).

==============================================================================
File: elisp.info,  Node: |File_Name_Completion|,  Next: |Standard_File_Names|,  Prev: |Unique_File_Names|,  Up: |File_Names|
==============================================================================

                                                          *File_Name_Completion*

25.9.6 File Name Completion
---------------------------

This section describes low-level subroutines for completing a file name.
For higher level functions, see *note Reading File Names::.

 -- Function: file-name-all-completions partial-filename directory
     This function returns a list of all possible completions for a file
     whose name starts with PARTIAL-FILENAME in directory DIRECTORY.
     The order of the completions is the order of the files in the
     directory, which is unpredictable and conveys no useful
     information.

     The argument PARTIAL-FILENAME must be a file name containing no
     directory part and no slash (or backslash on some systems).  The
     current buffer's default directory is prepended to DIRECTORY, if
     DIRECTORY is not absolute.

     In the following example, suppose that '~rms/lewis' is the current
     default directory, and has five files whose names begin with 'f':
     'foo', 'file~', 'file.c', 'file.c.~1~', and 'file.c.~2~'.

          (file-name-all-completions "f" "")
               => ("foo" "file~" "file.c.~2~"
                          "file.c.~1~" "file.c")

          (file-name-all-completions "fo" "")
               => ("foo")

 -- Function: file-name-completion filename directory &optional
          predicate
     This function completes the file name FILENAME in directory
     DIRECTORY.  It returns the longest prefix common to all file names
     in directory DIRECTORY that start with FILENAME.  If PREDICATE is
     non-'nil' then it ignores possible completions that don't satisfy
     PREDICATE, after calling that function with one argument, the
     expanded absolute file name.

     If only one match exists and FILENAME matches it exactly, the
     function returns 't'.  The function returns 'nil' if directory
     DIRECTORY contains no name starting with FILENAME.

     In the following example, suppose that the current default
     directory has five files whose names begin with 'f': 'foo',
     'file~', 'file.c', 'file.c.~1~', and 'file.c.~2~'.

          (file-name-completion "fi" "")
               => "file"

          (file-name-completion "file.c.~1" "")
               => "file.c.~1~"

          (file-name-completion "file.c.~1~" "")
               => t

          (file-name-completion "file.c.~3" "")
               => nil

 -- User Option: completion-ignored-extensions
     'file-name-completion' usually ignores file names that end in any
     string in this list.  It does not ignore them when all the possible
     completions end in one of these suffixes.  This variable has no
     effect on 'file-name-all-completions'.

     A typical value might look like this:

          completion-ignored-extensions
               => (".o" ".elc" "~" ".dvi")

     If an element of 'completion-ignored-extensions' ends in a slash
     '/', it signals a directory.  The elements which do _not_ end in a
     slash will never match a directory; thus, the above value will not
     filter out a directory named 'foo.elc'.

==============================================================================
File: elisp.info,  Node: |Standard_File_Names|,  Prev: |File_Name_Completion|,  Up: |File_Names|
==============================================================================

                                                           *Standard_File_Names*

25.9.7 Standard File Names
--------------------------

Sometimes, an Emacs Lisp program needs to specify a standard file name
for a particular use--typically, to hold configuration data specified by
the current user.  Usually, such files should be located in the
directory specified by 'user-emacs-directory', which is typically
'~/.config/emacs/' or '~/.emacs.d/' by default (*note How Emacs Finds
Your Init File: (emacs)Find Init.).  For example, abbrev definitions are
stored by default in '~/.config/emacs/abbrev_defs' or
'~/.emacs.d/abbrev_defs'.  The easiest way to specify such a file name
is to use the function 'locate-user-emacs-file'.

 -- Function: locate-user-emacs-file base-name &optional old-name
     This function returns an absolute file name for an Emacs-specific
     configuration or data file.  The argument 'base-name' should be a
     relative file name.  The return value is the absolute name of a
     file in the directory specified by 'user-emacs-directory'; if that
     directory does not exist, this function creates it.

     If the optional argument OLD-NAME is non-'nil', it specifies a file
     in the user's home directory, '~/OLD-NAME'.  If such a file exists,
     the return value is the absolute name of that file, instead of the
     file specified by BASE-NAME.  This argument is intended to be used
     by Emacs packages to provide backward compatibility.  For instance,
     prior to the introduction of 'user-emacs-directory', the abbrev
     file was located in '~/.abbrev_defs'.  Here is the definition of
     'abbrev-file-name':

          (defcustom abbrev-file-name
            (locate-user-emacs-file "abbrev_defs" ".abbrev_defs")
            "Default name of file from which to read abbrevs."
            ...
            :type 'file)

   A lower-level function for standardizing file names, which
'locate-user-emacs-file' uses as a subroutine, is
'convert-standard-filename'.

 -- Function: convert-standard-filename filename
     This function returns a file name based on FILENAME, which fits the
     conventions of the current operating system.

     On GNU and other POSIX-like systems, this simply returns FILENAME.
     On other operating systems, it may enforce system-specific file
     name conventions; for example, on MS-DOS this function performs a
     variety of changes to enforce MS-DOS file name limitations,
     including converting any leading '.' to '_' and truncating to three
     characters after the '.'.

     The recommended way to use this function is to specify a name which
     fits the conventions of GNU and Unix systems, and pass it to
     'convert-standard-filename'.

==============================================================================
File: elisp.info,  Node: |Contents_of_Directories|,  Next: |Create/Delete_Dirs|,  Prev: |File_Names|,  Up: |Files|
==============================================================================

                                                       *Contents_of_Directories*

25.10 Contents of Directories
=----------------------------

A directory is a kind of file that contains other files entered under
various names.  Directories are a feature of the file system.

   Emacs can list the names of the files in a directory as a Lisp list,
or display the names in a buffer using the 'ls' shell command.  In the
latter case, it can optionally display information about each file,
depending on the options passed to the 'ls' command.

 -- Function: directory-files directory &optional full-name match-regexp
          nosort
     This function returns a list of the names of the files in the
     directory DIRECTORY.  By default, the list is in alphabetical
     order.

     If FULL-NAME is non-'nil', the function returns the files' absolute
     file names.  Otherwise, it returns the names relative to the
     specified directory.

     If MATCH-REGEXP is non-'nil', this function returns only those file
     names that contain a match for that regular expression--the other
     file names are excluded from the list.  On case-insensitive
     filesystems, the regular expression matching is case-insensitive.

     If NOSORT is non-'nil', 'directory-files' does not sort the list,
     so you get the file names in no particular order.  Use this if you
     want the utmost possible speed and don't care what order the files
     are processed in.  If the order of processing is visible to the
     user, then the user will probably be happier if you do sort the
     names.

          (directory-files "~lewis")
               => ("#foo#" "#foo.el#" "." ".."
                   "dired-mods.el" "files.texi"
                   "files.texi.~1~")

     An error is signaled if DIRECTORY is not the name of a directory
     that can be read.

 -- Function: directory-files-recursively directory regexp &optional
          include-directories predicate follow-symlinks
     Return all files under DIRECTORY whose names match REGEXP.  This
     function searches the specified DIRECTORY and its sub-directories,
     recursively, for files whose basenames (i.e., without the leading
     directories) match the specified REGEXP, and returns a list of the
     absolute file names of the matching files (*note absolute file
     names: Relative File Names.).  The file names are returned in
     depth-first order, meaning that files in some sub-directory are
     returned before the files in its parent directory.  In addition,
     matching files found in each subdirectory are sorted alphabetically
     by their basenames.  By default, directories whose names match
     REGEXP are omitted from the list, but if the optional argument
     INCLUDE-DIRECTORIES is non-'nil', they are included.

     By default, all subdirectories are descended into.  If PREDICATE is
     't', errors when trying to descend into a subdirectory (for
     instance, if it's not readable by this user) are ignored.  If it's
     neither 'nil' nor 't', it should be a function that takes one
     parameter (the subdirectory name) and should return non-'nil' if
     the directory is to be descended into.

     Symbolic links to subdirectories are not followed by default, but
     if FOLLOW-SYMLINKS is non-'nil', they are followed.

 -- Function: locate-dominating-file file name
     Starting at FILE, go up the directory tree hierarchy looking for
     the first directory where NAME, a string, exists, and return that
     directory.  If FILE is a file, its directory will serve as the
     starting point for the search; otherwise FILE should be a directory
     from which to start.  The function looks in the starting directory,
     then in its parent, then in its parent's parent, etc., until it
     either finds a directory with NAME or reaches the root directory of
     the filesystem without finding NAME - in the latter case the
     function returns 'nil'.

     The argument 'name' can also be a predicate function.  The
     predicate is called for every directory examined by the function,
     starting from FILE (even if FILE is not a directory).  It is called
     with one argument (the file or directory) and should return
     non-'nil' if that directory is the one it is looking for.

 -- Function: directory-files-and-attributes directory &optional
          full-name match-regexp nosort id-format
     This is similar to 'directory-files' in deciding which files to
     report on and how to report their names.  However, instead of
     returning a list of file names, it returns for each file a list
     '(FILENAME . ATTRIBUTES)', where ATTRIBUTES is what
     'file-attributes' returns for that file.  The optional argument
     ID-FORMAT has the same meaning as the corresponding argument to
     'file-attributes' (*note Definition of file-attributes::).

 -- Function: file-expand-wildcards pattern &optional full
     This function expands the wildcard pattern PATTERN, returning a
     list of file names that match it.

     If PATTERN is written as an absolute file name, the values are
     absolute also.

     If PATTERN is written as a relative file name, it is interpreted
     relative to the current default directory.  The file names returned
     are normally also relative to the current default directory.
     However, if FULL is non-'nil', they are absolute.

 -- Function: insert-directory file switches &optional wildcard
          full-directory-p
     This function inserts (in the current buffer) a directory listing
     for directory FILE, formatted with 'ls' according to SWITCHES.  It
     leaves point after the inserted text.  SWITCHES may be a string of
     options, or a list of strings representing individual options.

     The argument FILE may be either a directory or a file specification
     including wildcard characters.  If WILDCARD is non-'nil', that
     means treat FILE as a file specification with wildcards.

     If FULL-DIRECTORY-P is non-'nil', that means the directory listing
     is expected to show the full contents of a directory.  You should
     specify 't' when FILE is a directory and switches do not contain
     '-d'.  (The '-d' option to 'ls' says to describe a directory itself
     as a file, rather than showing its contents.)

     On most systems, this function works by running a directory listing
     program whose name is in the variable 'insert-directory-program'.
     If WILDCARD is non-'nil', it also runs the shell specified by
     'shell-file-name', to expand the wildcards.

     MS-DOS and MS-Windows systems usually lack the standard Unix
     program 'ls', so this function emulates the standard Unix program
     'ls' with Lisp code.

     As a technical detail, when SWITCHES contains the long '--dired'
     option, 'insert-directory' treats it specially, for the sake of
     dired.  However, the normally equivalent short '-D' option is just
     passed on to 'insert-directory-program', as any other option.

 -- Variable: insert-directory-program
     This variable's value is the program to run to generate a directory
     listing for the function 'insert-directory'.  It is ignored on
     systems which generate the listing with Lisp code.

==============================================================================
File: elisp.info,  Node: |Create/Delete_Dirs|,  Next: |Magic_File_Names|,  Prev: |Contents_of_Directories|,  Up: |Files|
==============================================================================

                                                            *Create/Delete_Dirs*

25.11 Creating, Copying and Deleting Directories
=-----------------------------------------------

Most Emacs Lisp file-manipulation functions get errors when used on
files that are directories.  For example, you cannot delete a directory
with 'delete-file'.  These special functions exist to create and delete
directories.

 -- Command: make-directory dirname &optional parents
     This command creates a directory named DIRNAME.  If PARENTS is
     non-'nil', as is always the case in an interactive call, that means
     to create the parent directories first, if they don't already
     exist.  'mkdir' is an alias for this.

 -- Command: make-empty-file filename &optional parents
     This command creates an empty file named FILENAME.  As
     'make-directory', this command creates parent directories if
     PARENTS is non-'nil'.  If FILENAME already exists, this command
     signals an error.

 -- Command: copy-directory dirname newname &optional keep-time parents
          copy-contents
     This command copies the directory named DIRNAME to NEWNAME.  If
     NEWNAME is a directory name, DIRNAME will be copied to a
     subdirectory there.  *Note Directory Names::.

     It always sets the file modes of the copied files to match the
     corresponding original file.

     The third argument KEEP-TIME non-'nil' means to preserve the
     modification time of the copied files.  A prefix arg makes
     KEEP-TIME non-'nil'.

     The fourth argument PARENTS says whether to create parent
     directories if they don't exist.  Interactively, this happens by
     default.

     The fifth argument COPY-CONTENTS, if non-'nil', means to copy the
     contents of DIRNAME directly into NEWNAME if the latter is a
     directory name, instead of copying DIRNAME into it as a
     subdirectory.

 -- Command: delete-directory dirname &optional recursive trash
     This command deletes the directory named DIRNAME.  The function
     'delete-file' does not work for files that are directories; you
     must use 'delete-directory' for them.  If RECURSIVE is 'nil', and
     the directory contains any files, 'delete-directory' signals an
     error.  If recursive is non-'nil', there is no error merely because
     the directory or its files are deleted by some other process before
     'delete-directory' gets to them.

     'delete-directory' only follows symbolic links at the level of
     parent directories.

     If the optional argument TRASH is non-'nil' and the variable
     'delete-by-moving-to-trash' is non-'nil', this command moves the
     file into the system Trash instead of deleting it.  *Note
     Miscellaneous File Operations: (emacs)Misc File Ops.  When called
     interactively, TRASH is 't' if no prefix argument is given, and
     'nil' otherwise.

==============================================================================
File: elisp.info,  Node: |Magic_File_Names|,  Next: |Format_Conversion|,  Prev: |Create/Delete_Dirs|,  Up: |Files|
==============================================================================

                                                              *Magic_File_Names*

25.12 Making Certain File Names "Magic"
=--------------------------------------

You can implement special handling for certain file names.  This is
called making those names "magic".  The principal use for this feature
is in implementing access to remote files (*note Remote Files:
(emacs)Remote Files.).

   To define a kind of magic file name, you must supply a regular
expression to define the class of names (all those that match the
regular expression), plus a handler that implements all the primitive
Emacs file operations for file names that match.

   The variable 'file-name-handler-alist' holds a list of handlers,
together with regular expressions that determine when to apply each
handler.  Each element has this form:

     (REGEXP . HANDLER)

All the Emacs primitives for file access and file name transformation
check the given file name against 'file-name-handler-alist'.  If the
file name matches REGEXP, the primitives handle that file by calling
HANDLER.

   The first argument given to HANDLER is the name of the primitive, as
a symbol; the remaining arguments are the arguments that were passed to
that primitive.  (The first of these arguments is most often the file
name itself.)  For example, if you do this:

     (file-exists-p FILENAME)

and FILENAME has handler HANDLER, then HANDLER is called like this:

     (funcall HANDLER 'file-exists-p FILENAME)

   When a function takes two or more arguments that must be file names,
it checks each of those names for a handler.  For example, if you do
this:

     (expand-file-name FILENAME DIRNAME)

then it checks for a handler for FILENAME and then for a handler for
DIRNAME.  In either case, the HANDLER is called like this:

     (funcall HANDLER 'expand-file-name FILENAME DIRNAME)

The HANDLER then needs to figure out whether to handle FILENAME or
DIRNAME.

   If the specified file name matches more than one handler, the one
whose match starts last in the file name gets precedence.  This rule is
chosen so that handlers for jobs such as uncompression are handled
first, before handlers for jobs such as remote file access.

   Here are the operations that a magic file name handler gets to
handle:

'access-file', 'add-name-to-file', 'byte-compiler-base-file-name',
'copy-directory', 'copy-file', 'delete-directory', 'delete-file',
'diff-latest-backup-file', 'directory-file-name', 'directory-files',
'directory-files-and-attributes', 'dired-compress-file',
'dired-uncache', 'exec-path', 'expand-file-name',
'file-accessible-directory-p', 'file-acl', 'file-attributes',
'file-directory-p', 'file-equal-p', 'file-executable-p',
'file-exists-p', 'file-in-directory-p', 'file-local-copy', 'file-modes',
'file-name-all-completions', 'file-name-as-directory',
'file-name-case-insensitive-p', 'file-name-completion',
'file-name-directory', 'file-name-nondirectory',
'file-name-sans-versions', 'file-newer-than-file-p',
'file-notify-add-watch', 'file-notify-rm-watch', 'file-notify-valid-p',
'file-ownership-preserved-p', 'file-readable-p', 'file-regular-p',
'file-remote-p', 'file-selinux-context', 'file-symlink-p',
'file-system-info', 'file-truename', 'file-writable-p',
'find-backup-file-name',
'get-file-buffer', 'insert-directory', 'insert-file-contents',
'load', 'make-auto-save-file-name', 'make-directory',
'make-directory-internal', 'make-nearby-temp-file', 'make-process',
'make-symbolic-link',
'process-file', 'rename-file', 'set-file-acl', 'set-file-modes',
'set-file-selinux-context', 'set-file-times',
'set-visited-file-modtime', 'shell-command', 'start-file-process',
'substitute-in-file-name',
'temporary-file-directory', 'unhandled-file-name-directory',
'vc-registered', 'verify-visited-file-modtime',
'write-region'.

   Handlers for 'insert-file-contents' typically need to clear the
buffer's modified flag, with '(set-buffer-modified-p nil)', if the VISIT
argument is non-'nil'.  This also has the effect of unlocking the buffer
if it is locked.

   The handler function must handle all of the above operations, and
possibly others to be added in the future.  It need not implement all
these operations itself--when it has nothing special to do for a certain
operation, it can reinvoke the primitive, to handle the operation in the
usual way.  It should always reinvoke the primitive for an operation it
does not recognize.  Here's one way to do this:

     (defun my-file-handler (operation &rest args)
       ;; First check for the specific operations
       ;; that we have special handling for.
       (cond ((eq operation 'insert-file-contents) ...)
             ((eq operation 'write-region) ...)
             ...
             ;; Handle any operation we don't know about.
             (t (let ((inhibit-file-name-handlers
                       (cons 'my-file-handler
                             (and (eq inhibit-file-name-operation operation)
                                  inhibit-file-name-handlers)))
                      (inhibit-file-name-operation operation))
                  (apply operation args)))))

   When a handler function decides to call the ordinary Emacs primitive
for the operation at hand, it needs to prevent the primitive from
calling the same handler once again, thus leading to an infinite
recursion.  The example above shows how to do this, with the variables
'inhibit-file-name-handlers' and 'inhibit-file-name-operation'.  Be
careful to use them exactly as shown above; the details are crucial for
proper behavior in the case of multiple handlers, and for operations
that have two file names that may each have handlers.

   Handlers that don't really do anything special for actual access to
the file--such as the ones that implement completion of host names for
remote file names--should have a non-'nil' 'safe-magic' property.  For
instance, Emacs normally protects directory names it finds in 'PATH'
from becoming magic, if they look like magic file names, by prefixing
them with '/:'.  But if the handler that would be used for them has a
non-'nil' 'safe-magic' property, the '/:' is not added.

   A file name handler can have an 'operations' property to declare
which operations it handles in a nontrivial way.  If this property has a
non-'nil' value, it should be a list of operations; then only those
operations will call the handler.  This avoids inefficiency, but its
main purpose is for autoloaded handler functions, so that they won't be
loaded except when they have real work to do.

   Simply deferring all operations to the usual primitives does not
work.  For instance, if the file name handler applies to
'file-exists-p', then it must handle 'load' itself, because the usual
'load' code won't work properly in that case.  However, if the handler
uses the 'operations' property to say it doesn't handle 'file-exists-p',
then it need not handle 'load' nontrivially.

 -- Variable: inhibit-file-name-handlers
     This variable holds a list of handlers whose use is presently
     inhibited for a certain operation.

 -- Variable: inhibit-file-name-operation
     The operation for which certain handlers are presently inhibited.

 -- Function: find-file-name-handler file operation
     This function returns the handler function for file name FILE, or
     'nil' if there is none.  The argument OPERATION should be the
     operation to be performed on the file--the value you will pass to
     the handler as its first argument when you call it.  If OPERATION
     equals 'inhibit-file-name-operation', or if it is not found in the
     'operations' property of the handler, this function returns 'nil'.

 -- Function: file-local-copy filename
     This function copies file FILENAME to an ordinary non-magic file on
     the local machine, if it isn't on the local machine already.  Magic
     file names should handle the 'file-local-copy' operation if they
     refer to files on other machines.  A magic file name that is used
     for other purposes than remote file access should not handle
     'file-local-copy'; then this function will treat the file as local.

     If FILENAME is local, whether magic or not, this function does
     nothing and returns 'nil'.  Otherwise it returns the file name of
     the local copy file.

 -- Function: file-remote-p filename &optional identification connected
     This function tests whether FILENAME is a remote file.  If FILENAME
     is local (not remote), the return value is 'nil'.  If FILENAME is
     indeed remote, the return value is a string that identifies the
     remote system.

     This identifier string can include a host name and a user name, as
     well as characters designating the method used to access the remote
     system.  For example, the remote identifier string for the filename
     '/sudo::/some/file' is '/sudo:root@localhost:'.

     If 'file-remote-p' returns the same identifier for two different
     filenames, that means they are stored on the same file system and
     can be accessed locally with respect to each other.  This means,
     for example, that it is possible to start a remote process
     accessing both files at the same time.  Implementers of file name
     handlers need to ensure this principle is valid.

     IDENTIFICATION specifies which part of the identifier shall be
     returned as string.  IDENTIFICATION can be the symbol 'method',
     'user' or 'host'; any other value is handled like 'nil' and means
     to return the complete identifier string.  In the example above,
     the remote 'user' identifier string would be 'root'.

     If CONNECTED is non-'nil', this function returns 'nil' even if
     FILENAME is remote, if Emacs has no network connection to its host.
     This is useful when you want to avoid the delay of making
     connections when they don't exist.

 -- Function: unhandled-file-name-directory filename
     This function returns the name of a directory that is not magic.
     For a non-magic FILENAME it returns the corresponding directory
     name (*note Directory Names::).  For a magic FILENAME, it invokes
     the file name handler, which therefore decides what value to
     return.  If FILENAME is not accessible from a local process, then
     the file name handler should indicate that by returning 'nil'.

     This is useful for running a subprocess; every subprocess must have
     a non-magic directory to serve as its current directory, and this
     function is a good way to come up with one.

 -- Function: file-local-name filename
     This function returns the "local part" of FILENAME.  This is the
     part of the file's name that identifies it on the remote host, and
     is typically obtained by removing from the remote file name the
     parts that specify the remote host and the method of accessing it.
     For example:

          (file-local-name "/ssh:USER@HOST:/foo/bar")
               => "/foo/bar"

     For a remote FILENAME, this function returns a file name which
     could be used directly as an argument of a remote process (*note
     Asynchronous Processes::, and *note Synchronous Processes::), and
     as the program to run on the remote host.  If FILENAME is local,
     this function returns it unchanged.

 -- User Option: remote-file-name-inhibit-cache
     The attributes of remote files can be cached for better
     performance.  If they are changed outside of Emacs's control, the
     cached values become invalid, and must be reread.

     When this variable is set to 'nil', cached values are never
     expired.  Use this setting with caution, only if you are sure
     nothing other than Emacs ever changes the remote files.  If it is
     set to 't', cached values are never used.  This is the safest
     value, but could result in performance degradation.

     A compromise is to set it to a positive number.  This means that
     cached values are used for that amount of seconds since they were
     cached.  If a remote file is checked regularly, it might be a good
     idea to let-bind this variable to a value less than the time period
     between consecutive checks.  For example:

          (defun display-time-file-nonempty-p (file)
            (let ((remote-file-name-inhibit-cache
                   (- display-time-interval 5)))
              (and (file-exists-p file)
                   (< 0 (file-attribute-size
                         (file-attributes
                          (file-chase-links file)))))))

==============================================================================
File: elisp.info,  Node: |Format_Conversion|,  Prev: |Magic_File_Names|,  Up: |Files|
==============================================================================

                                                             *Format_Conversion*

25.13 File Format Conversion
=---------------------------

Emacs performs several steps to convert the data in a buffer (text, text
properties, and possibly other information) to and from a representation
suitable for storing into a file.  This section describes the
fundamental functions that perform this "format conversion", namely
'insert-file-contents' for reading a file into a buffer, and
'write-region' for writing a buffer into a file.

MENU

* Overview: Format Conversion Overview.     'insert-file-contents' and 'write-region'.
* Round-Trip: Format Conversion Round-Trip. Using 'format-alist'.
* Piecemeal: Format Conversion Piecemeal.   Specifying non-paired conversion.

==============================================================================
File: elisp.info,  Node: |Format_Conversion_Overview|,  Next: |Format_Conversion_Round_Trip|,  Up: |Format_Conversion|
==============================================================================

                                                    *Format_Conversion_Overview*

25.13.1 Overview
----------------

The function 'insert-file-contents':

   * initially, inserts bytes from the file into the buffer;
   * decodes bytes to characters as appropriate;
   * processes formats as defined by entries in 'format-alist'; and
   * calls functions in 'after-insert-file-functions'.

The function 'write-region':

   * initially, calls functions in 'write-region-annotate-functions';
   * processes formats as defined by entries in 'format-alist';
   * encodes characters to bytes as appropriate; and
   * modifies the file with the bytes.

   This shows the symmetry of the lowest-level operations; reading and
writing handle things in opposite order.  The rest of this section
describes the two facilities surrounding the three variables named
above, as well as some related functions.  *note Coding Systems::, for
details on character encoding and decoding.

==============================================================================
File: elisp.info,  Node: |Format_Conversion_Round_Trip|,  Next: |Format_Conversion_Piecemeal|,  Prev: |Format_Conversion_Overview|,  Up: |Format_Conversion|
==============================================================================

                                                  *Format_Conversion_Round_Trip*

25.13.2 Round-Trip Specification
--------------------------------

The most general of the two facilities is controlled by the variable
'format-alist', a list of "file format" specifications, which describe
textual representations used in files for the data in an Emacs buffer.
The descriptions for reading and writing are paired, which is why we
call this "round-trip" specification (*note Format Conversion
Piecemeal::, for non-paired specification).

 -- Variable: format-alist
     This list contains one format definition for each defined file
     format.  Each format definition is a list of this form:

          (NAME DOC-STRING REGEXP FROM-FN TO-FN MODIFY MODE-FN PRESERVE)

Here is what the elements in a format definition mean:

NAME
     The name of this format.

DOC-STRING
     A documentation string for the format.

REGEXP
     A regular expression which is used to recognize files represented
     in this format.  If 'nil', the format is never applied
     automatically.

FROM-FN
     A shell command or function to decode data in this format (to
     convert file data into the usual Emacs data representation).

     A shell command is represented as a string; Emacs runs the command
     as a filter to perform the conversion.

     If FROM-FN is a function, it is called with two arguments, BEGIN
     and END, which specify the part of the buffer it should convert.
     It should convert the text by editing it in place.  Since this can
     change the length of the text, FROM-FN should return the modified
     end position.

     One responsibility of FROM-FN is to make sure that the beginning of
     the file no longer matches REGEXP.  Otherwise it is likely to get
     called again.  Also, FROM-FN must not involve buffers or files
     other than the one being decoded, otherwise the internal buffer
     used for formatting might be overwritten.

TO-FN
     A shell command or function to encode data in this format--that is,
     to convert the usual Emacs data representation into this format.

     If TO-FN is a string, it is a shell command; Emacs runs the command
     as a filter to perform the conversion.

     If TO-FN is a function, it is called with three arguments: BEGIN
     and END, which specify the part of the buffer it should convert,
     and BUFFER, which specifies which buffer.  There are two ways it
     can do the conversion:

        * By editing the buffer in place.  In this case, TO-FN should
          return the end-position of the range of text, as modified.

        * By returning a list of annotations.  This is a list of
          elements of the form '(POSITION . STRING)', where POSITION is
          an integer specifying the relative position in the text to be
          written, and STRING is the annotation to add there.  The list
          must be sorted in order of position when TO-FN returns it.

          When 'write-region' actually writes the text from the buffer
          to the file, it intermixes the specified annotations at the
          corresponding positions.  All this takes place without
          modifying the buffer.

     TO-FN must not involve buffers or files other than the one being
     encoded, otherwise the internal buffer used for formatting might be
     overwritten.

MODIFY
     A flag, 't' if the encoding function modifies the buffer, and 'nil'
     if it works by returning a list of annotations.

MODE-FN
     A minor-mode function to call after visiting a file converted from
     this format.  The function is called with one argument, the integer
     1; that tells a minor-mode function to enable the mode.

PRESERVE
     A flag, 't' if 'format-write-file' should not remove this format
     from 'buffer-file-format'.

   The function 'insert-file-contents' automatically recognizes file
formats when it reads the specified file.  It checks the text of the
beginning of the file against the regular expressions of the format
definitions, and if it finds a match, it calls the decoding function for
that format.  Then it checks all the known formats over again.  It keeps
checking them until none of them is applicable.

   Visiting a file, with 'find-file-noselect' or the commands that use
it, performs conversion likewise (because it calls
'insert-file-contents'); it also calls the mode function for each format
that it decodes.  It stores a list of the format names in the
buffer-local variable 'buffer-file-format'.

 -- Variable: buffer-file-format
     This variable states the format of the visited file.  More
     precisely, this is a list of the file format names that were
     decoded in the course of visiting the current buffer's file.  It is
     always buffer-local in all buffers.

   When 'write-region' writes data into a file, it first calls the
encoding functions for the formats listed in 'buffer-file-format', in
the order of appearance in the list.

 -- Command: format-write-file file format &optional confirm
     This command writes the current buffer contents into the file FILE
     in a format based on FORMAT, which is a list of format names.  It
     constructs the actual format starting from FORMAT, then appending
     any elements from the value of 'buffer-file-format' with a
     non-'nil' PRESERVE flag (see above), if they are not already
     present in FORMAT.  It then updates 'buffer-file-format' with this
     format, making it the default for future saves.  Except for the
     FORMAT argument, this command is similar to 'write-file'.  In
     particular, CONFIRM has the same meaning and interactive treatment
     as the corresponding argument to 'write-file'.  *Note Definition of
     write-file::.

 -- Command: format-find-file file format
     This command finds the file FILE, converting it according to format
     FORMAT.  It also makes FORMAT the default if the buffer is saved
     later.

     The argument FORMAT is a list of format names.  If FORMAT is 'nil',
     no conversion takes place.  Interactively, typing just <RET> for
     FORMAT specifies 'nil'.

 -- Command: format-insert-file file format &optional beg end
     This command inserts the contents of file FILE, converting it
     according to format FORMAT.  If BEG and END are non-'nil', they
     specify which part of the file to read, as in
     'insert-file-contents' (*note Reading from Files::).

     The return value is like what 'insert-file-contents' returns: a
     list of the absolute file name and the length of the data inserted
     (after conversion).

     The argument FORMAT is a list of format names.  If FORMAT is 'nil',
     no conversion takes place.  Interactively, typing just <RET> for
     FORMAT specifies 'nil'.

 -- Variable: buffer-auto-save-file-format
     This variable specifies the format to use for auto-saving.  Its
     value is a list of format names, just like the value of
     'buffer-file-format'; however, it is used instead of
     'buffer-file-format' for writing auto-save files.  If the value is
     't', the default, auto-saving uses the same format as a regular
     save in the same buffer.  This variable is always buffer-local in
     all buffers.

==============================================================================
File: elisp.info,  Node: |Format_Conversion_Piecemeal|,  Prev: |Format_Conversion_Round_Trip|,  Up: |Format_Conversion|
==============================================================================

                                                   *Format_Conversion_Piecemeal*

25.13.3 Piecemeal Specification
-------------------------------

In contrast to the round-trip specification described in the previous
subsection (*note Format Conversion Round-Trip::), you can use the
variables 'after-insert-file-functions' and
'write-region-annotate-functions' to separately control the respective
reading and writing conversions.

   Conversion starts with one representation and produces another
representation.  When there is only one conversion to do, there is no
conflict about what to start with.  However, when there are multiple
conversions involved, conflict may arise when two conversions need to
start with the same data.

   This situation is best understood in the context of converting text
properties during 'write-region'.  For example, the character at
position 42 in a buffer is 'X' with a text property 'foo'.  If the
conversion for 'foo' is done by inserting into the buffer, say, 'FOO:',
then that changes the character at position 42 from 'X' to 'F'.  The
next conversion will start with the wrong data straight away.

   To avoid conflict, cooperative conversions do not modify the buffer,
but instead specify "annotations", a list of elements of the form
'(POSITION . STRING)', sorted in order of increasing POSITION.

   If there is more than one conversion, 'write-region' merges their
annotations destructively into one sorted list.  Later, when the text
from the buffer is actually written to the file, it intermixes the
specified annotations at the corresponding positions.  All this takes
place without modifying the buffer.

   In contrast, when reading, the annotations intermixed with the text
are handled immediately.  'insert-file-contents' sets point to the
beginning of some text to be converted, then calls the conversion
functions with the length of that text.  These functions should always
return with point at the beginning of the inserted text.  This approach
makes sense for reading because annotations removed by the first
converter can't be mistakenly processed by a later converter.  Each
conversion function should scan for the annotations it recognizes,
remove the annotation, modify the buffer text (to set a text property,
for example), and return the updated length of the text, as it stands
after those changes.  The value returned by one function becomes the
argument to the next function.

 -- Variable: write-region-annotate-functions
     A list of functions for 'write-region' to call.  Each function in
     the list is called with two arguments: the start and end of the
     region to be written.  These functions should not alter the
     contents of the buffer.  Instead, they should return annotations.

     As a special case, a function may return with a different buffer
     current.  Emacs takes this to mean that the current buffer contains
     altered text to be output.  It therefore changes the START and END
     arguments of the 'write-region' call, giving them the values of
     'point-min' and 'point-max' in the new buffer, respectively.  It
     also discards all previous annotations, because they should have
     been dealt with by this function.

 -- Variable: write-region-post-annotation-function
     The value of this variable, if non-'nil', should be a function.
     This function is called, with no arguments, after 'write-region'
     has completed.

     If any function in 'write-region-annotate-functions' returns with a
     different buffer current, Emacs calls
     'write-region-post-annotation-function' more than once.  Emacs
     calls it with the last buffer that was current, and again with the
     buffer before that, and so on back to the original buffer.

     Thus, a function in 'write-region-annotate-functions' can create a
     buffer, give this variable the local value of 'kill-buffer' in that
     buffer, set up the buffer with altered text, and make the buffer
     current.  The buffer will be killed after 'write-region' is done.

 -- Variable: after-insert-file-functions
     Each function in this list is called by 'insert-file-contents' with
     one argument, the number of characters inserted, and with point at
     the beginning of the inserted text.  Each function should leave
     point unchanged, and return the new character count describing the
     inserted text as modified by the function.

   We invite users to write Lisp programs to store and retrieve text
properties in files, using these hooks, and thus to experiment with
various data formats and find good ones.  Eventually we hope users will
produce good, general extensions we can install in Emacs.

   We suggest not trying to handle arbitrary Lisp objects as text
property names or values--because a program that general is probably
difficult to write, and slow.  Instead, choose a set of possible data
types that are reasonably flexible, and not too hard to encode.

==============================================================================
File: elisp.info,  Node: |Backups_and_Auto_Saving|,  Next: |Buffers|,  Prev: |Files|,  Up: |Top|
==============================================================================

                                                       *Backups_and_Auto_Saving*

26 Backups and Auto-Saving
*=========================

Backup files and auto-save files are two methods by which Emacs tries to
protect the user from the consequences of crashes or of the user's own
errors.  Auto-saving preserves the text from earlier in the current
editing session; backup files preserve file contents prior to the
current session.

MENU

* |Backup_Files|::   How backup files are made; how their names are chosen.
* |Auto_Saving|::    How auto-save files are made; how their names are chosen.
* |Reverting|::      'revert-buffer', and how to customize what it does.

==============================================================================
File: elisp.info,  Node: |Backup_Files|,  Next: |Auto_Saving|,  Up: |Backups_and_Auto_Saving|
==============================================================================

                                                                  *Backup_Files*

26.1 Backup Files
=----------------

A "backup file" is a copy of the old contents of a file you are editing.
Emacs makes a backup file the first time you save a buffer into its
visited file.  Thus, normally, the backup file contains the contents of
the file as it was before the current editing session.  The contents of
the backup file normally remain unchanged once it exists.

   Backups are usually made by renaming the visited file to a new name.
Optionally, you can specify that backup files should be made by copying
the visited file.  This choice makes a difference for files with
multiple names; it also can affect whether the edited file remains owned
by the original owner or becomes owned by the user editing it.

   By default, Emacs makes a single backup file for each file edited.
You can alternatively request numbered backups; then each new backup
file gets a new name.  You can delete old numbered backups when you
don't want them any more, or Emacs can delete them automatically.

   For performance, the operating system may not write the backup file's
contents to secondary storage immediately, or may alias the backup data
with the original until one or the other is later modified.  *Note Files
and Storage::.

MENU

* |Making_Backups|::     How Emacs makes backup files, and when.
* |Rename_or_Copy|::     Two alternatives: renaming the old file or copying it.
* |Numbered_Backups|::   Keeping multiple backups for each source file.
* |Backup_Names|::       How backup file names are computed; customization.

==============================================================================
File: elisp.info,  Node: |Making_Backups|,  Next: |Rename_or_Copy|,  Up: Backup Files
==============================================================================

                                                                *Making_Backups*

26.1.1 Making Backup Files
--------------------------

 -- Function: backup-buffer
     This function makes a backup of the file visited by the current
     buffer, if appropriate.  It is called by 'save-buffer' before
     saving the buffer the first time.

     If a backup was made by renaming, the return value is a cons cell
     of the form (MODES EXTRA-ALIST BACKUPNAME), where MODES are the
     mode bits of the original file, as returned by 'file-modes' (*note
     Testing Accessibility::), EXTRA-ALIST is an alist describing the
     original file's extended attributes, as returned by
     'file-extended-attributes' (*note Extended Attributes::), and
     BACKUPNAME is the name of the backup.

     In all other cases (i.e., if a backup was made by copying or if no
     backup was made), this function returns 'nil'.

 -- Variable: buffer-backed-up
     This buffer-local variable says whether this buffer's file has been
     backed up on account of this buffer.  If it is non-'nil', the
     backup file has been written.  Otherwise, the file should be backed
     up when it is next saved (if backups are enabled).  This is a
     permanent local; 'kill-all-local-variables' does not alter it.

 -- User Option: make-backup-files
     This variable determines whether or not to make backup files.  If
     it is non-'nil', then Emacs creates a backup of each file when it
     is saved for the first time--provided that 'backup-inhibited' is
     'nil' (see below).

     The following example shows how to change the 'make-backup-files'
     variable only in the Rmail buffers and not elsewhere.  Setting it
     'nil' stops Emacs from making backups of these files, which may
     save disk space.  (You would put this code in your init file.)

          (add-hook 'rmail-mode-hook
                    (lambda () (setq-local make-backup-files nil)))

 -- Variable: backup-enable-predicate
     This variable's value is a function to be called on certain
     occasions to decide whether a file should have backup files.  The
     function receives one argument, an absolute file name to consider.
     If the function returns 'nil', backups are disabled for that file.
     Otherwise, the other variables in this section say whether and how
     to make backups.

     The default value is 'normal-backup-enable-predicate', which checks
     for files in 'temporary-file-directory' and
     'small-temporary-file-directory'.

 -- Variable: backup-inhibited
     If this variable is non-'nil', backups are inhibited.  It records
     the result of testing 'backup-enable-predicate' on the visited file
     name.  It can also coherently be used by other mechanisms that
     inhibit backups based on which file is visited.  For example, VC
     sets this variable non-'nil' to prevent making backups for files
     managed with a version control system.

     This is a permanent local, so that changing the major mode does not
     lose its value.  Major modes should not set this variable--they
     should set 'make-backup-files' instead.

 -- User Option: backup-directory-alist
     This variable's value is an alist of filename patterns and backup
     directories.  Each element looks like
          (REGEXP . DIRECTORY)

     Backups of files with names matching REGEXP will be made in
     DIRECTORY.  DIRECTORY may be relative or absolute.  If it is
     absolute, so that all matching files are backed up into the same
     directory, the file names in this directory will be the full name
     of the file backed up with all directory separators changed to '!'
     to prevent clashes.  This will not work correctly if your
     filesystem truncates the resulting name.

     For the common case of all backups going into one directory, the
     alist should contain a single element pairing '"."' with the
     appropriate directory.

     If this variable is 'nil' (the default), or it fails to match a
     filename, the backup is made in the original file's directory.

     On MS-DOS filesystems without long names this variable is always
     ignored.

 -- User Option: make-backup-file-name-function
     This variable's value is a function to use for making backup file
     names.  The function 'make-backup-file-name' calls it.  *Note
     Naming Backup Files: Backup Names.

     This could be buffer-local to do something special for specific
     files.  If you change it, you may need to change
     'backup-file-name-p' and 'file-name-sans-versions' too.

==============================================================================
File: elisp.info,  Node: |Rename_or_Copy|,  Next: |Numbered_Backups|,  Prev: |Making_Backups|,  Up: |Backup_Files|
==============================================================================

                                                                *Rename_or_Copy*

26.1.2 Backup by Renaming or by Copying?
----------------------------------------

There are two ways that Emacs can make a backup file:

   * Emacs can rename the original file so that it becomes a backup
     file, and then write the buffer being saved into a new file.  After
     this procedure, any other names (i.e., hard links) of the original
     file now refer to the backup file.  The new file is owned by the
     user doing the editing, and its group is the default for new files
     written by the user in that directory.

   * Emacs can copy the original file into a backup file, and then
     overwrite the original file with new contents.  After this
     procedure, any other names (i.e., hard links) of the original file
     continue to refer to the current (updated) version of the file.
     The file's owner and group will be unchanged.

   The first method, renaming, is the default.

   The variable 'backup-by-copying', if non-'nil', says to use the
second method, which is to copy the original file and overwrite it with
the new buffer contents.  The variable 'file-precious-flag', if
non-'nil', also has this effect (as a sideline of its main
significance).  *Note Saving Buffers::.

 -- User Option: backup-by-copying
     If this variable is non-'nil', Emacs always makes backup files by
     copying.  The default is 'nil'.

   The following three variables, when non-'nil', cause the second
method to be used in certain special cases.  They have no effect on the
treatment of files that don't fall into the special cases.

 -- User Option: backup-by-copying-when-linked
     If this variable is non-'nil', Emacs makes backups by copying for
     files with multiple names (hard links).  The default is 'nil'.

     This variable is significant only if 'backup-by-copying' is 'nil',
     since copying is always used when that variable is non-'nil'.

 -- User Option: backup-by-copying-when-mismatch
     If this variable is non-'nil' (the default), Emacs makes backups by
     copying in cases where renaming would change either the owner or
     the group of the file.

     The value has no effect when renaming would not alter the owner or
     group of the file; that is, for files which are owned by the user
     and whose group matches the default for a new file created there by
     the user.

     This variable is significant only if 'backup-by-copying' is 'nil',
     since copying is always used when that variable is non-'nil'.

 -- User Option: backup-by-copying-when-privileged-mismatch
     This variable, if non-'nil', specifies the same behavior as
     'backup-by-copying-when-mismatch', but only for certain user-id and
     group-id values: namely, those less than or equal to a certain
     number.  You set this variable to that number.

     Thus, if you set 'backup-by-copying-when-privileged-mismatch' to 0,
     backup by copying is done for the superuser and group 0 only, when
     necessary to prevent a change in the owner of the file.

     The default is 200.

==============================================================================
File: elisp.info,  Node: |Numbered_Backups|,  Next: |Backup_Names|,  Prev: |Rename_or_Copy|,  Up: |Backup_Files|
==============================================================================

                                                              *Numbered_Backups*

26.1.3 Making and Deleting Numbered Backup Files
------------------------------------------------

If a file's name is 'foo', the names of its numbered backup versions are
'foo.~V~', for various integers V, like this: 'foo.~1~', 'foo.~2~',
'foo.~3~', ..., 'foo.~259~', and so on.

 -- User Option: version-control
     This variable controls whether to make a single non-numbered backup
     file or multiple numbered backups.

     'nil'
          Make numbered backups if the visited file already has numbered
          backups; otherwise, do not.  This is the default.

     'never'
          Do not make numbered backups.

     ANYTHING ELSE
          Make numbered backups.

   The use of numbered backups ultimately leads to a large number of
backup versions, which must then be deleted.  Emacs can do this
automatically or it can ask the user whether to delete them.

 -- User Option: kept-new-versions
     The value of this variable is the number of newest versions to keep
     when a new numbered backup is made.  The newly made backup is
     included in the count.  The default value is 2.

 -- User Option: kept-old-versions
     The value of this variable is the number of oldest versions to keep
     when a new numbered backup is made.  The default value is 2.

   If there are backups numbered 1, 2, 3, 5, and 7, and both of these
variables have the value 2, then the backups numbered 1 and 2 are kept
as old versions and those numbered 5 and 7 are kept as new versions;
backup version 3 is excess.  The function 'find-backup-file-name' (*note
Backup Names::) is responsible for determining which backup versions to
delete, but does not delete them itself.

 -- User Option: delete-old-versions
     If this variable is 't', then saving a file deletes excess backup
     versions silently.  If it is 'nil', that means to ask for
     confirmation before deleting excess backups.  Otherwise, they are
     not deleted at all.

 -- User Option: dired-kept-versions
     This variable specifies how many of the newest backup versions to
     keep in the Dired command '.' ('dired-clean-directory').  That's
     the same thing 'kept-new-versions' specifies when you make a new
     backup file.  The default is 2.

==============================================================================
File: elisp.info,  Node: |Backup_Names|,  Prev: |Numbered_Backups|,  Up: |Backup_Files|
==============================================================================

                                                                  *Backup_Names*

26.1.4 Naming Backup Files
--------------------------

The functions in this section are documented mainly because you can
customize the naming conventions for backup files by redefining them.
If you change one, you probably need to change the rest.

 -- Function: backup-file-name-p filename
     This function returns a non-'nil' value if FILENAME is a possible
     name for a backup file.  It just checks the name, not whether a
     file with the name FILENAME exists.

          (backup-file-name-p "foo")
               => nil
          (backup-file-name-p "foo~")
               => 3

     The standard definition of this function is as follows:

          (defun backup-file-name-p (file)
            "Return non-nil if FILE is a backup file \
          name (numeric or not)..."
            (string-match "~\\'" file))

     Thus, the function returns a non-'nil' value if the file name ends
     with a '~'.  (We use a backslash to split the documentation
     string's first line into two lines in the text, but produce just
     one line in the string itself.)

     This simple expression is placed in a separate function to make it
     easy to redefine for customization.

 -- Function: make-backup-file-name filename
     This function returns a string that is the name to use for a
     non-numbered backup file for file FILENAME.  On Unix, this is just
     FILENAME with a tilde appended.

     The standard definition of this function, on most operating
     systems, is as follows:

          (defun make-backup-file-name (file)
            "Create the non-numeric backup file name for FILE..."
            (concat file "~"))

     You can change the backup-file naming convention by redefining this
     function.  The following example redefines 'make-backup-file-name'
     to prepend a '.' in addition to appending a tilde:

          (defun make-backup-file-name (filename)
            (expand-file-name
              (concat "." (file-name-nondirectory filename) "~")
              (file-name-directory filename)))

          (make-backup-file-name "backups.texi")
               => ".backups.texi~"

     Some parts of Emacs, including some Dired commands, assume that
     backup file names end with '~'.  If you do not follow that
     convention, it will not cause serious problems, but these commands
     may give less-than-desirable results.

 -- Function: find-backup-file-name filename
     This function computes the file name for a new backup file for
     FILENAME.  It may also propose certain existing backup files for
     deletion.  'find-backup-file-name' returns a list whose CAR is the
     name for the new backup file and whose CDR is a list of backup
     files whose deletion is proposed.  The value can also be 'nil',
     which means not to make a backup.

     Two variables, 'kept-old-versions' and 'kept-new-versions',
     determine which backup versions should be kept.  This function
     keeps those versions by excluding them from the CDR of the value.
     *Note Numbered Backups::.

     In this example, the value says that '~rms/foo.~5~' is the name to
     use for the new backup file, and '~rms/foo.~3~' is an excess
     version that the caller should consider deleting now.

          (find-backup-file-name "~rms/foo")
               => ("~rms/foo.~5~" "~rms/foo.~3~")

 -- Function: file-newest-backup filename
     This function returns the name of the most recent backup file for
     FILENAME, or 'nil' if that file has no backup files.

     Some file comparison commands use this function so that they can
     automatically compare a file with its most recent backup.

==============================================================================
File: elisp.info,  Node: |Auto_Saving|,  Next: |Reverting|,  Prev: |Backup_Files|,  Up: |Backups_and_Auto_Saving|
==============================================================================

                                                                   *Auto_Saving*

26.2 Auto-Saving
=---------------

Emacs periodically saves all files that you are visiting; this is called
"auto-saving".  Auto-saving prevents you from losing more than a limited
amount of work if the system crashes.  By default, auto-saves happen
every 300 keystrokes, or after around 30 seconds of idle time.  *Note
Auto Save: (emacs)Auto Save, for information on auto-save for users.
Here we describe the functions used to implement auto-saving and the
variables that control them.

 -- Variable: buffer-auto-save-file-name
     This buffer-local variable is the name of the file used for
     auto-saving the current buffer.  It is 'nil' if the buffer should
     not be auto-saved.

          buffer-auto-save-file-name
               => "/xcssun/users/rms/lewis/#backups.texi#"

 -- Command: auto-save-mode arg
     This is the mode command for Auto Save mode, a buffer-local minor
     mode.  When Auto Save mode is enabled, auto-saving is enabled in
     the buffer.  The calling convention is the same as for other minor
     mode commands (*note Minor Mode Conventions::).

     Unlike most minor modes, there is no 'auto-save-mode' variable.
     Auto Save mode is enabled if 'buffer-auto-save-file-name' is
     non-'nil' and 'buffer-saved-size' (see below) is non-zero.

 -- Function: auto-save-file-name-p filename
     This function returns a non-'nil' value if FILENAME is a string
     that could be the name of an auto-save file.  It assumes the usual
     naming convention for auto-save files: a name that begins and ends
     with hash marks ('#') is a possible auto-save file name.  The
     argument FILENAME should not contain a directory part.

          (make-auto-save-file-name)
               => "/xcssun/users/rms/lewis/#backups.texi#"
          (auto-save-file-name-p "#backups.texi#")
               => 0
          (auto-save-file-name-p "backups.texi")
               => nil

     The standard definition of this function is as follows:

          (defun auto-save-file-name-p (filename)
            "Return non-nil if FILENAME can be yielded by..."
            (string-match "^#.*#$" filename))

     This function exists so that you can customize it if you wish to
     change the naming convention for auto-save files.  If you redefine
     it, be sure to redefine the function 'make-auto-save-file-name'
     correspondingly.

 -- Function: make-auto-save-file-name
     This function returns the file name to use for auto-saving the
     current buffer.  This is just the file name with hash marks ('#')
     prepended and appended to it.  This function does not look at the
     variable 'auto-save-visited-file-name' (described below); callers
     of this function should check that variable first.

          (make-auto-save-file-name)
               => "/xcssun/users/rms/lewis/#backups.texi#"

     Here is a simplified version of the standard definition of this
     function:

          (defun make-auto-save-file-name ()
            "Return file name to use for auto-saves \
          of current buffer.."
            (if buffer-file-name
                (concat
                 (file-name-directory buffer-file-name)
                 "#"
                 (file-name-nondirectory buffer-file-name)
                 "#")
              (expand-file-name
               (concat "#%" (buffer-name) "#"))))

     This exists as a separate function so that you can redefine it to
     customize the naming convention for auto-save files.  Be sure to
     change 'auto-save-file-name-p' in a corresponding way.

 -- User Option: auto-save-visited-file-name
     If this variable is non-'nil', Emacs auto-saves buffers in the
     files they are visiting.  That is, the auto-save is done in the
     same file that you are editing.  Normally, this variable is 'nil',
     so auto-save files have distinct names that are created by
     'make-auto-save-file-name'.

     When you change the value of this variable, the new value does not
     take effect in an existing buffer until the next time auto-save
     mode is reenabled in it.  If auto-save mode is already enabled,
     auto-saves continue to go in the same file name until
     'auto-save-mode' is called again.

     Note that setting this variable to a non-'nil' value does not
     change the fact that auto-saving is different from saving the
     buffer; e.g., the hooks described in *note Saving Buffers:: are
     _not_ run when a buffer is auto-saved.

 -- Function: recent-auto-save-p
     This function returns 't' if the current buffer has been auto-saved
     since the last time it was read in or saved.

 -- Function: set-buffer-auto-saved
     This function marks the current buffer as auto-saved.  The buffer
     will not be auto-saved again until the buffer text is changed
     again.  The function returns 'nil'.

 -- User Option: auto-save-interval
     The value of this variable specifies how often to do auto-saving,
     in terms of number of input events.  Each time this many additional
     input events are read, Emacs does auto-saving for all buffers in
     which that is enabled.  Setting this to zero disables autosaving
     based on the number of characters typed.

 -- User Option: auto-save-timeout
     The value of this variable is the number of seconds of idle time
     that should cause auto-saving.  Each time the user pauses for this
     long, Emacs does auto-saving for all buffers in which that is
     enabled.  (If the current buffer is large, the specified timeout is
     multiplied by a factor that increases as the size increases; for a
     million-byte buffer, the factor is almost 4.)

     If the value is zero or 'nil', then auto-saving is not done as a
     result of idleness, only after a certain number of input events as
     specified by 'auto-save-interval'.

 -- Variable: auto-save-hook
     This normal hook is run whenever an auto-save is about to happen.

 -- User Option: auto-save-default
     If this variable is non-'nil', buffers that are visiting files have
     auto-saving enabled by default.  Otherwise, they do not.

 -- Command: do-auto-save &optional no-message current-only
     This function auto-saves all buffers that need to be auto-saved.
     It saves all buffers for which auto-saving is enabled and that have
     been changed since the previous auto-save.

     If any buffers are auto-saved, 'do-auto-save' normally displays a
     message saying 'Auto-saving...' in the echo area while auto-saving
     is going on.  However, if NO-MESSAGE is non-'nil', the message is
     inhibited.

     If CURRENT-ONLY is non-'nil', only the current buffer is
     auto-saved.

 -- Function: delete-auto-save-file-if-necessary &optional force
     This function deletes the current buffer's auto-save file if
     'delete-auto-save-files' is non-'nil'.  It is called every time a
     buffer is saved.

     Unless FORCE is non-'nil', this function only deletes the file if
     it was written by the current Emacs session since the last true
     save.

 -- User Option: delete-auto-save-files
     This variable is used by the function
     'delete-auto-save-file-if-necessary'.  If it is non-'nil', Emacs
     deletes auto-save files when a true save is done (in the visited
     file).  This saves disk space and unclutters your directory.

 -- Function: rename-auto-save-file
     This function adjusts the current buffer's auto-save file name if
     the visited file name has changed.  It also renames an existing
     auto-save file, if it was made in the current Emacs session.  If
     the visited file name has not changed, this function does nothing.

 -- Variable: buffer-saved-size
     The value of this buffer-local variable is the length of the
     current buffer, when it was last read in, saved, or auto-saved.
     This is used to detect a substantial decrease in size, and turn off
     auto-saving in response.

     If it is -1, that means auto-saving is temporarily shut off in this
     buffer due to a substantial decrease in size.  Explicitly saving
     the buffer stores a positive value in this variable, thus
     reenabling auto-saving.  Turning auto-save mode off or on also
     updates this variable, so that the substantial decrease in size is
     forgotten.

     If it is -2, that means this buffer should disregard changes in
     buffer size; in particular, it should not shut off auto-saving
     temporarily due to changes in buffer size.

 -- Variable: auto-save-list-file-name
     This variable (if non-'nil') specifies a file for recording the
     names of all the auto-save files.  Each time Emacs does
     auto-saving, it writes two lines into this file for each buffer
     that has auto-saving enabled.  The first line gives the name of the
     visited file (it's empty if the buffer has none), and the second
     gives the name of the auto-save file.

     When Emacs exits normally, it deletes this file; if Emacs crashes,
     you can look in the file to find all the auto-save files that might
     contain work that was otherwise lost.  The 'recover-session'
     command uses this file to find them.

     The default name for this file specifies your home directory and
     starts with '.saves-'.  It also contains the Emacs process ID and
     the host name.

 -- User Option: auto-save-list-file-prefix
     After Emacs reads your init file, it initializes
     'auto-save-list-file-name' (if you have not already set it
     non-'nil') based on this prefix, adding the host name and process
     ID.  If you set this to 'nil' in your init file, then Emacs does
     not initialize 'auto-save-list-file-name'.

==============================================================================
File: elisp.info,  Node: |Reverting|,  Prev: Auto-Saving,  Up: Backups and Auto-Saving
==============================================================================

                                                                     *Reverting*

26.3 Reverting
=-------------

If you have made extensive changes to a file and then change your mind
about them, you can get rid of them by reading in the previous version
of the file with the 'revert-buffer' command.  *Note Reverting a Buffer:
(emacs)Reverting.

 -- Command: revert-buffer &optional ignore-auto noconfirm
          preserve-modes
     This command replaces the buffer text with the text of the visited
     file on disk.  This action undoes all changes since the file was
     visited or saved.

     By default, if the latest auto-save file is more recent than the
     visited file, and the argument IGNORE-AUTO is 'nil',
     'revert-buffer' asks the user whether to use that auto-save
     instead.  When you invoke this command interactively, IGNORE-AUTO
     is 't' if there is no numeric prefix argument; thus, the
     interactive default is not to check the auto-save file.

     Normally, 'revert-buffer' asks for confirmation before it changes
     the buffer; but if the argument NOCONFIRM is non-'nil',
     'revert-buffer' does not ask for confirmation.

     Normally, this command reinitializes the buffer's major and minor
     modes using 'normal-mode'.  But if PRESERVE-MODES is non-'nil', the
     modes remain unchanged.

     Reverting tries to preserve marker positions in the buffer by using
     the replacement feature of 'insert-file-contents'.  If the buffer
     contents and the file contents are identical before the revert
     operation, reverting preserves all the markers.  If they are not
     identical, reverting does change the buffer; in that case, it
     preserves the markers in the unchanged text (if any) at the
     beginning and end of the buffer.  Preserving any additional markers
     would be problematical.

 -- Variable: revert-buffer-in-progress-p
     'revert-buffer' binds this variable to a non-'nil' value while it
     is working.

   You can customize how 'revert-buffer' does its work by setting the
variables described in the rest of this section.

 -- User Option: revert-without-query
     This variable holds a list of files that should be reverted without
     query.  The value is a list of regular expressions.  If the visited
     file name matches one of these regular expressions, and the file
     has changed on disk but the buffer is not modified, then
     'revert-buffer' reverts the file without asking the user for
     confirmation.

   Some major modes customize 'revert-buffer' by making buffer-local
bindings for these variables:

 -- Variable: revert-buffer-function
     The value of this variable is the function to use to revert this
     buffer.  It should be a function with two optional arguments to do
     the work of reverting.  The two optional arguments, IGNORE-AUTO and
     NOCONFIRM, are the arguments that 'revert-buffer' received.

     Modes such as Dired mode, in which the text being edited does not
     consist of a file's contents but can be regenerated in some other
     fashion, can give this variable a buffer-local value that is a
     special function to regenerate the contents.

 -- Variable: revert-buffer-insert-file-contents-function
     The value of this variable specifies the function to use to insert
     the updated contents when reverting this buffer.  The function
     receives two arguments: first the file name to use; second, 't' if
     the user has asked to read the auto-save file.

vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
