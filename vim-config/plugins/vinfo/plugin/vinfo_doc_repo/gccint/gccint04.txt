==============================================================================
File: gccint.info,  Node: |Loop_representation|,  Next: |Loop_querying|,  Up: |Loop_Analysis_and_Representation|
==============================================================================

                                                           *Loop_representation*

16.1 Loop representation
------------------------

This chapter describes the representation of loops in GCC, and functions
that can be used to build, modify and analyze this representation.  Most
of the interfaces and data structures are declared in 'cfgloop.h'.  Loop
structures are analyzed and this information disposed or updated at the
discretion of individual passes.  Still most of the generic CFG
manipulation routines are aware of loop structures and try to keep them
up-to-date.  By this means an increasing part of the compilation
pipeline is setup to maintain loop structure across passes to allow
attaching meta information to individual loops for consumption by later
passes.

 In general, a natural loop has one entry block (header) and possibly
several back edges (latches) leading to the header from the inside of
the loop.  Loops with several latches may appear if several loops share
a single header, or if there is a branching in the middle of the loop.
The representation of loops in GCC however allows only loops with a
single latch.  During loop analysis, headers of such loops are split and
forwarder blocks are created in order to disambiguate their structures.
Heuristic based on profile information and structure of the induction
variables in the loops is used to determine whether the latches
correspond to sub-loops or to control flow in a single loop.  This means
that the analysis sometimes changes the CFG, and if you run it in the
middle of an optimization pass, you must be able to deal with the new
blocks.  You may avoid CFG changes by passing
'LOOPS_MAY_HAVE_MULTIPLE_LATCHES' flag to the loop discovery, note
however that most other loop manipulation functions will not work
correctly for loops with multiple latch edges (the functions that only
query membership of blocks to loops and subloop relationships, or
enumerate and test loop exits, can be expected to work).

 Body of the loop is the set of blocks that are dominated by its header,
and reachable from its latch against the direction of edges in CFG.  The
loops are organized in a containment hierarchy (tree) such that all the
loops immediately contained inside loop L are the children of L in the
tree.  This tree is represented by the 'struct loops' structure.  The
root of this tree is a fake loop that contains all blocks in the
function.  Each of the loops is represented in a 'struct loop'
structure.  Each loop is assigned an index ('num' field of the 'struct
loop' structure), and the pointer to the loop is stored in the
corresponding field of the 'larray' vector in the loops structure.  The
indices do not have to be continuous, there may be empty ('NULL')
entries in the 'larray' created by deleting loops.  Also, there is no
guarantee on the relative order of a loop and its subloops in the
numbering.  The index of a loop never changes.

 The entries of the 'larray' field should not be accessed directly.  The
function 'get_loop' returns the loop description for a loop with the
given index.  'number_of_loops' function returns number of loops in the
function.  To traverse all loops, use 'FOR_EACH_LOOP' macro.  The
'flags' argument of the macro is used to determine the direction of
traversal and the set of loops visited.  Each loop is guaranteed to be
visited exactly once, regardless of the changes to the loop tree, and
the loops may be removed during the traversal.  The newly created loops
are never traversed, if they need to be visited, this must be done
separately after their creation.

 Each basic block contains the reference to the innermost loop it
belongs to ('loop_father').  For this reason, it is only possible to
have one 'struct loops' structure initialized at the same time for each
CFG.  The global variable 'current_loops' contains the 'struct loops'
structure.  Many of the loop manipulation functions assume that
dominance information is up-to-date.

 The loops are analyzed through 'loop_optimizer_init' function.  The
argument of this function is a set of flags represented in an integer
bitmask.  These flags specify what other properties of the loop
structures should be calculated/enforced and preserved later:

   * 'LOOPS_MAY_HAVE_MULTIPLE_LATCHES': If this flag is set, no changes
     to CFG will be performed in the loop analysis, in particular, loops
     with multiple latch edges will not be disambiguated.  If a loop has
     multiple latches, its latch block is set to NULL.  Most of the loop
     manipulation functions will not work for loops in this shape.  No
     other flags that require CFG changes can be passed to
     loop_optimizer_init.
   * 'LOOPS_HAVE_PREHEADERS': Forwarder blocks are created in such a way
     that each loop has only one entry edge, and additionally, the
     source block of this entry edge has only one successor.  This
     creates a natural place where the code can be moved out of the
     loop, and ensures that the entry edge of the loop leads from its
     immediate super-loop.
   * 'LOOPS_HAVE_SIMPLE_LATCHES': Forwarder blocks are created to force
     the latch block of each loop to have only one successor.  This
     ensures that the latch of the loop does not belong to any of its
     sub-loops, and makes manipulation with the loops significantly
     easier.  Most of the loop manipulation functions assume that the
     loops are in this shape.  Note that with this flag, the "normal"
     loop without any control flow inside and with one exit consists of
     two basic blocks.
   * 'LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS': Basic blocks and edges in
     the strongly connected components that are not natural loops (have
     more than one entry block) are marked with 'BB_IRREDUCIBLE_LOOP'
     and 'EDGE_IRREDUCIBLE_LOOP' flags.  The flag is not set for blocks
     and edges that belong to natural loops that are in such an
     irreducible region (but it is set for the entry and exit edges of
     such a loop, if they lead to/from this region).
   * 'LOOPS_HAVE_RECORDED_EXITS': The lists of exits are recorded and
     updated for each loop.  This makes some functions (e.g.,
     'get_loop_exit_edges') more efficient.  Some functions (e.g.,
     'single_exit') can be used only if the lists of exits are recorded.

 These properties may also be computed/enforced later, using functions
'create_preheaders', 'force_single_succ_latches',
'mark_irreducible_loops' and 'record_loop_exits'.  The properties can be
queried using 'loops_state_satisfies_p'.

 The memory occupied by the loops structures should be freed with
'loop_optimizer_finalize' function.  When loop structures are setup to
be preserved across passes this function reduces the information to be
kept up-to-date to a minimum (only 'LOOPS_MAY_HAVE_MULTIPLE_LATCHES'
set).

 The CFG manipulation functions in general do not update loop
structures.  Specialized versions that additionally do so are provided
for the most common tasks.  On GIMPLE, 'cleanup_tree_cfg_loop' function
can be used to cleanup CFG while updating the loops structures if
'current_loops' is set.

 At the moment loop structure is preserved from the start of GIMPLE loop
optimizations until the end of RTL loop optimizations.  During this time
a loop can be tracked by its 'struct loop' and number.

==============================================================================
File: gccint.info,  Node: |Loop_querying|,  Next: |Loop_manipulation|,  Prev: |Loop_representation|,  Up: |Loop_Analysis_and_Representation|
==============================================================================

                                                                 *Loop_querying*

16.2 Loop querying
------------------

The functions to query the information about loops are declared in
'cfgloop.h'.  Some of the information can be taken directly from the
structures.  'loop_father' field of each basic block contains the
innermost loop to that the block belongs.  The most useful fields of
loop structure (that are kept up-to-date at all times) are:

   * 'header', 'latch': Header and latch basic blocks of the loop.
   * 'num_nodes': Number of basic blocks in the loop (including the
     basic blocks of the sub-loops).
   * 'outer', 'inner', 'next': The super-loop, the first sub-loop, and
     the sibling of the loop in the loops tree.

 There are other fields in the loop structures, many of them used only
by some of the passes, or not updated during CFG changes; in general,
they should not be accessed directly.

 The most important functions to query loop structures are:

   * 'loop_depth': The depth of the loop in the loops tree, i.e., the
     number of super-loops of the loop.
   * 'flow_loops_dump': Dumps the information about loops to a file.
   * 'verify_loop_structure': Checks consistency of the loop structures.
   * 'loop_latch_edge': Returns the latch edge of a loop.
   * 'loop_preheader_edge': If loops have preheaders, returns the
     preheader edge of a loop.
   * 'flow_loop_nested_p': Tests whether loop is a sub-loop of another
     loop.
   * 'flow_bb_inside_loop_p': Tests whether a basic block belongs to a
     loop (including its sub-loops).
   * 'find_common_loop': Finds the common super-loop of two loops.
   * 'superloop_at_depth': Returns the super-loop of a loop with the
     given depth.
   * 'tree_num_loop_insns', 'num_loop_insns': Estimates the number of
     insns in the loop, on GIMPLE and on RTL.
   * 'loop_exit_edge_p': Tests whether edge is an exit from a loop.
   * 'mark_loop_exit_edges': Marks all exit edges of all loops with
     'EDGE_LOOP_EXIT' flag.
   * 'get_loop_body', 'get_loop_body_in_dom_order',
     'get_loop_body_in_bfs_order': Enumerates the basic blocks in the
     loop in depth-first search order in reversed CFG, ordered by
     dominance relation, and breath-first search order, respectively.
   * 'single_exit': Returns the single exit edge of the loop, or 'NULL'
     if the loop has more than one exit.  You can only use this function
     if LOOPS_HAVE_MARKED_SINGLE_EXITS property is used.
   * 'get_loop_exit_edges': Enumerates the exit edges of a loop.
   * 'just_once_each_iteration_p': Returns true if the basic block is
     executed exactly once during each iteration of a loop (that is, it
     does not belong to a sub-loop, and it dominates the latch of the
     loop).

==============================================================================
File: gccint.info,  Node: |Loop_manipulation|,  Next: |LCSSA|,  Prev: |Loop_querying|,  Up: |Loop_Analysis_and_Representation|
==============================================================================

                                                             *Loop_manipulation*

16.3 Loop manipulation
----------------------

The loops tree can be manipulated using the following functions:

   * 'flow_loop_tree_node_add': Adds a node to the tree.
   * 'flow_loop_tree_node_remove': Removes a node from the tree.
   * 'add_bb_to_loop': Adds a basic block to a loop.
   * 'remove_bb_from_loops': Removes a basic block from loops.

 Most low-level CFG functions update loops automatically.  The following
functions handle some more complicated cases of CFG manipulations:

   * 'remove_path': Removes an edge and all blocks it dominates.
   * 'split_loop_exit_edge': Splits exit edge of the loop, ensuring that
     PHI node arguments remain in the loop (this ensures that
     loop-closed SSA form is preserved).  Only useful on GIMPLE.

 Finally, there are some higher-level loop transformations implemented.
While some of them are written so that they should work on non-innermost
loops, they are mostly untested in that case, and at the moment, they
are only reliable for the innermost loops:

   * 'create_iv': Creates a new induction variable.  Only works on
     GIMPLE.  'standard_iv_increment_position' can be used to find a
     suitable place for the iv increment.
   * 'duplicate_loop_to_header_edge',
     'tree_duplicate_loop_to_header_edge': These functions (on RTL and
     on GIMPLE) duplicate the body of the loop prescribed number of
     times on one of the edges entering loop header, thus performing
     either loop unrolling or loop peeling.  'can_duplicate_loop_p'
     ('can_unroll_loop_p' on GIMPLE) must be true for the duplicated
     loop.
   * 'loop_version': This function creates a copy of a loop, and a
     branch before them that selects one of them depending on the
     prescribed condition.  This is useful for optimizations that need
     to verify some assumptions in runtime (one of the copies of the
     loop is usually left unchanged, while the other one is transformed
     in some way).
   * 'tree_unroll_loop': Unrolls the loop, including peeling the extra
     iterations to make the number of iterations divisible by unroll
     factor, updating the exit condition, and removing the exits that
     now cannot be taken.  Works only on GIMPLE.

==============================================================================
File: gccint.info,  Node: |LCSSA|,  Next: |Scalar_evolutions|,  Prev: |Loop_manipulation|,  Up: |Loop_Analysis_and_Representation|
==============================================================================

                                                                         *LCSSA*

16.4 Loop-closed SSA form
-------------------------

Throughout the loop optimizations on tree level, one extra condition is
enforced on the SSA form: No SSA name is used outside of the loop in
that it is defined.  The SSA form satisfying this condition is called
"loop-closed SSA form" - LCSSA.  To enforce LCSSA, PHI nodes must be
created at the exits of the loops for the SSA names that are used
outside of them.  Only the real operands (not virtual SSA names) are
held in LCSSA, in order to save memory.

 There are various benefits of LCSSA:

   * Many optimizations (value range analysis, final value replacement)
     are interested in the values that are defined in the loop and used
     outside of it, i.e., exactly those for that we create new PHI
     nodes.
   * In induction variable analysis, it is not necessary to specify the
     loop in that the analysis should be performed - the scalar
     evolution analysis always returns the results with respect to the
     loop in that the SSA name is defined.
   * It makes updating of SSA form during loop transformations simpler.
     Without LCSSA, operations like loop unrolling may force creation of
     PHI nodes arbitrarily far from the loop, while in LCSSA, the SSA
     form can be updated locally.  However, since we only keep real
     operands in LCSSA, we cannot use this advantage (we could have
     local updating of real operands, but it is not much more efficient
     than to use generic SSA form updating for it as well; the amount of
     changes to SSA is the same).

 However, it also means LCSSA must be updated.  This is usually
straightforward, unless you create a new value in loop and use it
outside, or unless you manipulate loop exit edges (functions are
provided to make these manipulations simple).
'rewrite_into_loop_closed_ssa' is used to rewrite SSA form to LCSSA, and
'verify_loop_closed_ssa' to check that the invariant of LCSSA is
preserved.

==============================================================================
File: gccint.info,  Node: |Scalar_evolutions|,  Next: |loop_iv|,  Prev: |LCSSA|,  Up: |Loop_Analysis_and_Representation|
==============================================================================

                                                             *Scalar_evolutions*

16.5 Scalar evolutions
----------------------

Scalar evolutions (SCEV) are used to represent results of induction
variable analysis on GIMPLE.  They enable us to represent variables with
complicated behavior in a simple and consistent way (we only use it to
express values of polynomial induction variables, but it is possible to
extend it).  The interfaces to SCEV analysis are declared in
'tree-scalar-evolution.h'.  To use scalar evolutions analysis,
'scev_initialize' must be used.  To stop using SCEV, 'scev_finalize'
should be used.  SCEV analysis caches results in order to save time and
memory.  This cache however is made invalid by most of the loop
transformations, including removal of code.  If such a transformation is
performed, 'scev_reset' must be called to clean the caches.

 Given an SSA name, its behavior in loops can be analyzed using the
'analyze_scalar_evolution' function.  The returned SCEV however does not
have to be fully analyzed and it may contain references to other SSA
names defined in the loop.  To resolve these (potentially recursive)
references, 'instantiate_parameters' or 'resolve_mixers' functions must
be used.  'instantiate_parameters' is useful when you use the results of
SCEV only for some analysis, and when you work with whole nest of loops
at once.  It will try replacing all SSA names by their SCEV in all
loops, including the super-loops of the current loop, thus providing a
complete information about the behavior of the variable in the loop
nest.  'resolve_mixers' is useful if you work with only one loop at a
time, and if you possibly need to create code based on the value of the
induction variable.  It will only resolve the SSA names defined in the
current loop, leaving the SSA names defined outside unchanged, even if
their evolution in the outer loops is known.

 The SCEV is a normal tree expression, except for the fact that it may
contain several special tree nodes.  One of them is 'SCEV_NOT_KNOWN',
used for SSA names whose value cannot be expressed.  The other one is
'POLYNOMIAL_CHREC'.  Polynomial chrec has three arguments - base, step
and loop (both base and step may contain further polynomial chrecs).
Type of the expression and of base and step must be the same.  A
variable has evolution 'POLYNOMIAL_CHREC(base, step, loop)' if it is (in
the specified loop) equivalent to 'x_1' in the following example

     while (...)
       {
         x_1 = phi (base, x_2);
         x_2 = x_1 + step;
       }

 Note that this includes the language restrictions on the operations.
For example, if we compile C code and 'x' has signed type, then the
overflow in addition would cause undefined behavior, and we may assume
that this does not happen.  Hence, the value with this SCEV cannot
overflow (which restricts the number of iterations of such a loop).

 In many cases, one wants to restrict the attention just to affine
induction variables.  In this case, the extra expressive power of SCEV
is not useful, and may complicate the optimizations.  In this case,
'simple_iv' function may be used to analyze a value - the result is a
loop-invariant base and step.

==============================================================================
File: gccint.info,  Node: |loop_iv|,  Next: |Number_of_iterations|,  Prev: |Scalar_evolutions|,  Up: |Loop_Analysis_and_Representation|
==============================================================================

                                                                       *loop_iv*

16.6 IV analysis on RTL
-----------------------

The induction variable on RTL is simple and only allows analysis of
affine induction variables, and only in one loop at once.  The interface
is declared in 'cfgloop.h'.  Before analyzing induction variables in a
loop L, 'iv_analysis_loop_init' function must be called on L. After the
analysis (possibly calling 'iv_analysis_loop_init' for several loops) is
finished, 'iv_analysis_done' should be called.  The following functions
can be used to access the results of the analysis:

   * 'iv_analyze': Analyzes a single register used in the given insn.
     If no use of the register in this insn is found, the following
     insns are scanned, so that this function can be called on the insn
     returned by get_condition.
   * 'iv_analyze_result': Analyzes result of the assignment in the given
     insn.
   * 'iv_analyze_expr': Analyzes a more complicated expression.  All its
     operands are analyzed by 'iv_analyze', and hence they must be used
     in the specified insn or one of the following insns.

 The description of the induction variable is provided in 'struct
rtx_iv'.  In order to handle subregs, the representation is a bit
complicated; if the value of the 'extend' field is not 'UNKNOWN', the
value of the induction variable in the i-th iteration is

     delta + mult * extend_{extend_mode} (subreg_{mode} (base + i * step)),

 with the following exception: if 'first_special' is true, then the
value in the first iteration (when 'i' is zero) is 'delta + mult *
base'.  However, if 'extend' is equal to 'UNKNOWN', then 'first_special'
must be false, 'delta' 0, 'mult' 1 and the value in the i-th iteration
is

     subreg_{mode} (base + i * step)

 The function 'get_iv_value' can be used to perform these calculations.

==============================================================================
File: gccint.info,  Node: |Number_of_iterations|,  Next: |Dependency_analysis|,  Prev: |loop_iv|,  Up: |Loop_Analysis_and_Representation|
==============================================================================

                                                          *Number_of_iterations*

16.7 Number of iterations analysis
----------------------------------

Both on GIMPLE and on RTL, there are functions available to determine
the number of iterations of a loop, with a similar interface.  The
number of iterations of a loop in GCC is defined as the number of
executions of the loop latch.  In many cases, it is not possible to
determine the number of iterations unconditionally - the determined
number is correct only if some assumptions are satisfied.  The analysis
tries to verify these conditions using the information contained in the
program; if it fails, the conditions are returned together with the
result.  The following information and conditions are provided by the
analysis:

   * 'assumptions': If this condition is false, the rest of the
     information is invalid.
   * 'noloop_assumptions' on RTL, 'may_be_zero' on GIMPLE: If this
     condition is true, the loop exits in the first iteration.
   * 'infinite': If this condition is true, the loop is infinite.  This
     condition is only available on RTL.  On GIMPLE, conditions for
     finiteness of the loop are included in 'assumptions'.
   * 'niter_expr' on RTL, 'niter' on GIMPLE: The expression that gives
     number of iterations.  The number of iterations is defined as the
     number of executions of the loop latch.

 Both on GIMPLE and on RTL, it necessary for the induction variable
analysis framework to be initialized (SCEV on GIMPLE, loop-iv on RTL).
On GIMPLE, the results are stored to 'struct tree_niter_desc' structure.
Number of iterations before the loop is exited through a given exit can
be determined using 'number_of_iterations_exit' function.  On RTL, the
results are returned in 'struct niter_desc' structure.  The
corresponding function is named 'check_simple_exit'.  There are also
functions that pass through all the exits of a loop and try to find one
with easy to determine number of iterations - 'find_loop_niter' on
GIMPLE and 'find_simple_exit' on RTL.  Finally, there are functions that
provide the same information, but additionally cache it, so that
repeated calls to number of iterations are not so costly -
'number_of_latch_executions' on GIMPLE and 'get_simple_loop_desc' on
RTL.

 Note that some of these functions may behave slightly differently than
others - some of them return only the expression for the number of
iterations, and fail if there are some assumptions.  The function
'number_of_latch_executions' works only for single-exit loops.  The
function 'number_of_cond_exit_executions' can be used to determine
number of executions of the exit condition of a single-exit loop (i.e.,
the 'number_of_latch_executions' increased by one).

 On GIMPLE, below constraint flags affect semantics of some APIs of
number of iterations analyzer:

   * 'LOOP_C_INFINITE': If this constraint flag is set, the loop is
     known to be infinite.  APIs like 'number_of_iterations_exit' can
     return false directly without doing any analysis.
   * 'LOOP_C_FINITE': If this constraint flag is set, the loop is known
     to be finite, in other words, loop's number of iterations can be
     computed with 'assumptions' be true.

 Generally, the constraint flags are set/cleared by consumers which are
loop optimizers.  It's also the consumers' responsibility to set/clear
constraints correctly.  Failing to do that might result in hard to track
down bugs in scev/niter consumers.  One typical use case is vectorizer:
it drives number of iterations analyzer by setting 'LOOP_C_FINITE' and
vectorizes possibly infinite loop by versioning loop with analysis
result.  In return, constraints set by consumers can also help number of
iterations analyzer in following optimizers.  For example, 'niter' of a
loop versioned under 'assumptions' is valid unconditionally.

 Other constraints may be added in the future, for example, a constraint
indicating that loops' latch must roll thus 'may_be_zero' would be false
unconditionally.

==============================================================================
File: gccint.info,  Node: |Dependency_analysis|,  Prev: |Number_of_iterations|,  Up: |Loop_Analysis_and_Representation|
==============================================================================

                                                           *Dependency_analysis*

16.8 Data Dependency Analysis
-----------------------------

The code for the data dependence analysis can be found in
'tree-data-ref.c' and its interface and data structures are described in
'tree-data-ref.h'.  The function that computes the data dependences for
all the array and pointer references for a given loop is
'compute_data_dependences_for_loop'.  This function is currently used by
the linear loop transform and the vectorization passes.  Before calling
this function, one has to allocate two vectors: a first vector will
contain the set of data references that are contained in the analyzed
loop body, and the second vector will contain the dependence relations
between the data references.  Thus if the vector of data references is
of size 'n', the vector containing the dependence relations will contain
'n*n' elements.  However if the analyzed loop contains side effects,
such as calls that potentially can interfere with the data references in
the current analyzed loop, the analysis stops while scanning the loop
body for data references, and inserts a single 'chrec_dont_know' in the
dependence relation array.

 The data references are discovered in a particular order during the
scanning of the loop body: the loop body is analyzed in execution order,
and the data references of each statement are pushed at the end of the
data reference array.  Two data references syntactically occur in the
program in the same order as in the array of data references.  This
syntactic order is important in some classical data dependence tests,
and mapping this order to the elements of this array avoids costly
queries to the loop body representation.

 Three types of data references are currently handled: ARRAY_REF,
INDIRECT_REF and COMPONENT_REF.  The data structure for the data
reference is 'data_reference', where 'data_reference_p' is a name of a
pointer to the data reference structure.  The structure contains the
following elements:

   * 'base_object_info': Provides information about the base object of
     the data reference and its access functions.  These access
     functions represent the evolution of the data reference in the loop
     relative to its base, in keeping with the classical meaning of the
     data reference access function for the support of arrays.  For
     example, for a reference 'a.b[i][j]', the base object is 'a.b' and
     the access functions, one for each array subscript, are: '{i_init,
     + i_step}_1, {j_init, +, j_step}_2'.

   * 'first_location_in_loop': Provides information about the first
     location accessed by the data reference in the loop and about the
     access function used to represent evolution relative to this
     location.  This data is used to support pointers, and is not used
     for arrays (for which we have base objects).  Pointer accesses are
     represented as a one-dimensional access that starts from the first
     location accessed in the loop.  For example:

                for1 i
                   for2 j
                    *((int *)p + i + j) = a[i][j];

     The access function of the pointer access is '{0, + 4B}_for2'
     relative to 'p + i'.  The access functions of the array are
     '{i_init, + i_step}_for1' and '{j_init, +, j_step}_for2' relative
     to 'a'.

     Usually, the object the pointer refers to is either unknown, or we
     cannot prove that the access is confined to the boundaries of a
     certain object.

     Two data references can be compared only if at least one of these
     two representations has all its fields filled for both data
     references.

     The current strategy for data dependence tests is as follows: If
     both 'a' and 'b' are represented as arrays, compare 'a.base_object'
     and 'b.base_object'; if they are equal, apply dependence tests (use
     access functions based on base_objects).  Else if both 'a' and 'b'
     are represented as pointers, compare 'a.first_location' and
     'b.first_location'; if they are equal, apply dependence tests (use
     access functions based on first location).  However, if 'a' and 'b'
     are represented differently, only try to prove that the bases are
     definitely different.

   * Aliasing information.
   * Alignment information.

 The structure describing the relation between two data references is
'data_dependence_relation' and the shorter name for a pointer to such a
structure is 'ddr_p'.  This structure contains:

   * a pointer to each data reference,
   * a tree node 'are_dependent' that is set to 'chrec_known' if the
     analysis has proved that there is no dependence between these two
     data references, 'chrec_dont_know' if the analysis was not able to
     determine any useful result and potentially there could exist a
     dependence between these data references, and 'are_dependent' is
     set to 'NULL_TREE' if there exist a dependence relation between the
     data references, and the description of this dependence relation is
     given in the 'subscripts', 'dir_vects', and 'dist_vects' arrays,
   * a boolean that determines whether the dependence relation can be
     represented by a classical distance vector,
   * an array 'subscripts' that contains a description of each subscript
     of the data references.  Given two array accesses a subscript is
     the tuple composed of the access functions for a given dimension.
     For example, given 'A[f1][f2][f3]' and 'B[g1][g2][g3]', there are
     three subscripts: '(f1, g1), (f2, g2), (f3, g3)'.
   * two arrays 'dir_vects' and 'dist_vects' that contain classical
     representations of the data dependences under the form of direction
     and distance dependence vectors,
   * an array of loops 'loop_nest' that contains the loops to which the
     distance and direction vectors refer to.

 Several functions for pretty printing the information extracted by the
data dependence analysis are available: 'dump_ddrs' prints with a
maximum verbosity the details of a data dependence relations array,
'dump_dist_dir_vectors' prints only the classical distance and direction
vectors for a data dependence relations array, and
'dump_data_references' prints the details of the data references
contained in a data reference array.

==============================================================================
File: gccint.info,  Node: |Machine_Desc|,  Next: |Target_Macros|,  Prev: |Loop_Analysis_and_Representation|,  Up: |Top|
==============================================================================

                                                                  *Machine_Desc*

17 Machine Descriptions
=======================

A machine description has two parts: a file of instruction patterns
('.md' file) and a C header file of macro definitions.

 The '.md' file for a target machine contains a pattern for each
instruction that the target machine supports (or at least each
instruction that is worth telling the compiler about).  It may also
contain comments.  A semicolon causes the rest of the line to be a
comment, unless the semicolon is inside a quoted string.

 See the next chapter for information on the C header file.

MENU

* |Overview|::            How the machine description is used.
* |Patterns|::            How to write instruction patterns.
* |Example|::             An explained example of a 'define_insn' pattern.
* |RTL_Template|::        The RTL template defines what insns match a pattern.
* |Output_Template|::     The output template says how to make assembler code
                        from such an insn.
* |Output_Statement|::    For more generality, write C code to output
                        the assembler code.
* |Predicates|::          Controlling what kinds of operands can be used
                        for an insn.
* |Constraints|::         Fine-tuning operand selection.
* |Standard_Names|::      Names mark patterns to use for code generation.
* |Pattern_Ordering|::    When the order of patterns makes a difference.
* |Dependent_Patterns|::  Having one pattern may make you need another.
* |Jump_Patterns|::       Special considerations for patterns for jump insns.
* |Looping_Patterns|::    How to define patterns for special looping insns.
* |Insn_Canonicalizations|::Canonicalization of Instructions
* |Expander_Definitions|::Generating a sequence of several RTL insns
                        for a standard operation.
* |Insn_Splitting|::      Splitting Instructions into Multiple Instructions.
* |Including_Patterns|::  Including Patterns in Machine Descriptions.
* |Peephole_Definitions|::Defining machine-specific peephole optimizations.
* |Insn_Attributes|::     Specifying the value of attributes for generated insns.
* |Conditional_Execution|::Generating 'define_insn' patterns for
                         predication.
* |Define_Subst|::	Generating 'define_insn' and 'define_expand'
			patterns from other patterns.
* |Constant_Definitions|::Defining symbolic constants that can be used in the
                        md file.
* |Iterators|::           Using iterators to generate patterns from a template.

==============================================================================
File: gccint.info,  Node: |Overview|,  Next: |Patterns|,  Up: |Machine_Desc|
==============================================================================

                                                                      *Overview*

17.1 Overview of How the Machine Description is Used
----------------------------------------------------

There are three main conversions that happen in the compiler:

  1. The front end reads the source code and builds a parse tree.

  2. The parse tree is used to generate an RTL insn list based on named
     instruction patterns.

  3. The insn list is matched against the RTL templates to produce
     assembler code.

 For the generate pass, only the names of the insns matter, from either
a named 'define_insn' or a 'define_expand'.  The compiler will choose
the pattern with the right name and apply the operands according to the
documentation later in this chapter, without regard for the RTL template
or operand constraints.  Note that the names the compiler looks for are
hard-coded in the compiler--it will ignore unnamed patterns and patterns
with names it doesn't know about, but if you don't provide a named
pattern it needs, it will abort.

 If a 'define_insn' is used, the template given is inserted into the
insn list.  If a 'define_expand' is used, one of three things happens,
based on the condition logic.  The condition logic may manually create
new insns for the insn list, say via 'emit_insn()', and invoke 'DONE'.
For certain named patterns, it may invoke 'FAIL' to tell the compiler to
use an alternate way of performing that task.  If it invokes neither
'DONE' nor 'FAIL', the template given in the pattern is inserted, as if
the 'define_expand' were a 'define_insn'.

 Once the insn list is generated, various optimization passes convert,
replace, and rearrange the insns in the insn list.  This is where the
'define_split' and 'define_peephole' patterns get used, for example.

 Finally, the insn list's RTL is matched up with the RTL templates in
the 'define_insn' patterns, and those patterns are used to emit the
final assembly code.  For this purpose, each named 'define_insn' acts
like it's unnamed, since the names are ignored.

==============================================================================
File: gccint.info,  Node: |Patterns|,  Next: |Example|,  Prev: |Overview|,  Up: |Machine_Desc|
==============================================================================

                                                                      *Patterns*

17.2 Everything about Instruction Patterns
------------------------------------------

A 'define_insn' expression is used to define instruction patterns to
which insns may be matched.  A 'define_insn' expression contains an
incomplete RTL expression, with pieces to be filled in later, operand
constraints that restrict how the pieces can be filled in, and an output
template or C code to generate the assembler output.

 A 'define_insn' is an RTL expression containing four or five operands:

  1. An optional name N.  When a name is present, the compiler
     automically generates a C++ function 'gen_N' that takes the
     operands of the instruction as arguments and returns the
     instruction's rtx pattern.  The compiler also assigns the
     instruction a unique code 'CODE_FOR_N', with all such codes
     belonging to an enum called 'insn_code'.

     These names serve one of two purposes.  The first is to indicate
     that the instruction performs a certain standard job for the
     RTL-generation pass of the compiler, such as a move, an addition,
     or a conditional jump.  The second is to help the target generate
     certain target-specific operations, such as when implementing
     target-specific intrinsic functions.

     It is better to prefix target-specific names with the name of the
     target, to avoid any clash with current or future standard names.

     The absence of a name is indicated by writing an empty string where
     the name should go.  Nameless instruction patterns are never used
     for generating RTL code, but they may permit several simpler insns
     to be combined later on.

     For the purpose of debugging the compiler, you may also specify a
     name beginning with the '*' character.  Such a name is used only
     for identifying the instruction in RTL dumps; it is equivalent to
     having a nameless pattern for all other purposes.  Names beginning
     with the '*' character are not required to be unique.

     The name may also have the form '@N'.  This has the same effect as
     a name 'N', but in addition tells the compiler to generate further
     helper functions; see *note Parameterized Names:: for details.

  2. The "RTL template": This is a vector of incomplete RTL expressions
     which describe the semantics of the instruction (*note RTL
     Template::).  It is incomplete because it may contain
     'match_operand', 'match_operator', and 'match_dup' expressions that
     stand for operands of the instruction.

     If the vector has multiple elements, the RTL template is treated as
     a 'parallel' expression.

  3. The condition: This is a string which contains a C expression.
     When the compiler attempts to match RTL against a pattern, the
     condition is evaluated.  If the condition evaluates to 'true', the
     match is permitted.  The condition may be an empty string, which is
     treated as always 'true'.

     For a named pattern, the condition may not depend on the data in
     the insn being matched, but only the target-machine-type flags.
     The compiler needs to test these conditions during initialization
     in order to learn exactly which named instructions are available in
     a particular run.

     For nameless patterns, the condition is applied only when matching
     an individual insn, and only after the insn has matched the
     pattern's recognition template.  The insn's operands may be found
     in the vector 'operands'.

     An instruction condition cannot become more restrictive as
     compilation progresses.  If the condition accepts a particular RTL
     instruction at one stage of compilation, it must continue to accept
     that instruction until the final pass.  For example,
     '!reload_completed' and 'can_create_pseudo_p ()' are both invalid
     instruction conditions, because they are true during the earlier
     RTL passes and false during the later ones.  For the same reason,
     if a condition accepts an instruction before register allocation,
     it cannot later try to control register allocation by excluding
     certain register or value combinations.

     Although a condition cannot become more restrictive as compilation
     progresses, the condition for a nameless pattern _can_ become more
     permissive.  For example, a nameless instruction can require
     'reload_completed' to be true, in which case it only matches after
     register allocation.

  4. The "output template" or "output statement": This is either a
     string, or a fragment of C code which returns a string.

     When simple substitution isn't general enough, you can specify a
     piece of C code to compute the output.  *Note Output Statement::.

  5. The "insn attributes": This is an optional vector containing the
     values of attributes for insns matching this pattern (*note Insn
     Attributes::).

==============================================================================
File: gccint.info,  Node: |Example|,  Next: |RTL_Template|,  Prev: |Patterns|,  Up: |Machine_Desc|
==============================================================================

                                                                       *Example*

17.3 Example of 'define_insn'
-----------------------------

Here is an example of an instruction pattern, taken from the machine
description for the 68000/68020.

     (define_insn "tstsi"
       [(set (cc0)
             (match_operand:SI 0 "general_operand" "rm"))]
       ""
       "*
     {
       if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
         return \"tstl %0\";
       return \"cmpl #0,%0\";
     }")

This can also be written using braced strings:

     (define_insn "tstsi"
       [(set (cc0)
             (match_operand:SI 0 "general_operand" "rm"))]
       ""
     {
       if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
         return "tstl %0";
       return "cmpl #0,%0";
     })

 This describes an instruction which sets the condition codes based on
the value of a general operand.  It has no condition, so any insn with
an RTL description of the form shown may be matched to this pattern.
The name 'tstsi' means "test a 'SImode' value" and tells the RTL
generation pass that, when it is necessary to test such a value, an insn
to do so can be constructed using this pattern.

 The output control string is a piece of C code which chooses which
output template to return based on the kind of operand and the specific
type of CPU for which code is being generated.

 '"rm"' is an operand constraint.  Its meaning is explained below.

==============================================================================
File: gccint.info,  Node: |RTL_Template|,  Next: |Output_Template|,  Prev: |Example|,  Up: |Machine_Desc|
==============================================================================

                                                                  *RTL_Template*

17.4 RTL Template
-----------------

The RTL template is used to define which insns match the particular
pattern and how to find their operands.  For named patterns, the RTL
template also says how to construct an insn from specified operands.

 Construction involves substituting specified operands into a copy of
the template.  Matching involves determining the values that serve as
the operands in the insn being matched.  Both of these activities are
controlled by special expression types that direct matching and
substitution of the operands.

'(match_operand:M N PREDICATE CONSTRAINT)'
     This expression is a placeholder for operand number N of the insn.
     When constructing an insn, operand number N will be substituted at
     this point.  When matching an insn, whatever appears at this
     position in the insn will be taken as operand number N; but it must
     satisfy PREDICATE or this instruction pattern will not match at
     all.

     Operand numbers must be chosen consecutively counting from zero in
     each instruction pattern.  There may be only one 'match_operand'
     expression in the pattern for each operand number.  Usually
     operands are numbered in the order of appearance in 'match_operand'
     expressions.  In the case of a 'define_expand', any operand numbers
     used only in 'match_dup' expressions have higher values than all
     other operand numbers.

     PREDICATE is a string that is the name of a function that accepts
     two arguments, an expression and a machine mode.  *Note
     Predicates::.  During matching, the function will be called with
     the putative operand as the expression and M as the mode argument
     (if M is not specified, 'VOIDmode' will be used, which normally
     causes PREDICATE to accept any mode).  If it returns zero, this
     instruction pattern fails to match.  PREDICATE may be an empty
     string; then it means no test is to be done on the operand, so
     anything which occurs in this position is valid.

     Most of the time, PREDICATE will reject modes other than M--but not
     always.  For example, the predicate 'address_operand' uses M as the
     mode of memory ref that the address should be valid for.  Many
     predicates accept 'const_int' nodes even though their mode is
     'VOIDmode'.

     CONSTRAINT controls reloading and the choice of the best register
     class to use for a value, as explained later (*note Constraints::).
     If the constraint would be an empty string, it can be omitted.

     People are often unclear on the difference between the constraint
     and the predicate.  The predicate helps decide whether a given insn
     matches the pattern.  The constraint plays no role in this
     decision; instead, it controls various decisions in the case of an
     insn which does match.

'(match_scratch:M N CONSTRAINT)'
     This expression is also a placeholder for operand number N and
     indicates that operand must be a 'scratch' or 'reg' expression.

     When matching patterns, this is equivalent to

          (match_operand:M N "scratch_operand" CONSTRAINT)

     but, when generating RTL, it produces a ('scratch':M) expression.

     If the last few expressions in a 'parallel' are 'clobber'
     expressions whose operands are either a hard register or
     'match_scratch', the combiner can add or delete them when
     necessary.  *Note Side Effects::.

'(match_dup N)'
     This expression is also a placeholder for operand number N.  It is
     used when the operand needs to appear more than once in the insn.

     In construction, 'match_dup' acts just like 'match_operand': the
     operand is substituted into the insn being constructed.  But in
     matching, 'match_dup' behaves differently.  It assumes that operand
     number N has already been determined by a 'match_operand' appearing
     earlier in the recognition template, and it matches only an
     identical-looking expression.

     Note that 'match_dup' should not be used to tell the compiler that
     a particular register is being used for two operands (example:
     'add' that adds one register to another; the second register is
     both an input operand and the output operand).  Use a matching
     constraint (*note Simple Constraints::) for those.  'match_dup' is
     for the cases where one operand is used in two places in the
     template, such as an instruction that computes both a quotient and
     a remainder, where the opcode takes two input operands but the RTL
     template has to refer to each of those twice; once for the quotient
     pattern and once for the remainder pattern.

'(match_operator:M N PREDICATE [OPERANDS...])'
     This pattern is a kind of placeholder for a variable RTL expression
     code.

     When constructing an insn, it stands for an RTL expression whose
     expression code is taken from that of operand N, and whose operands
     are constructed from the patterns OPERANDS.

     When matching an expression, it matches an expression if the
     function PREDICATE returns nonzero on that expression _and_ the
     patterns OPERANDS match the operands of the expression.

     Suppose that the function 'commutative_operator' is defined as
     follows, to match any expression whose operator is one of the
     commutative arithmetic operators of RTL and whose mode is MODE:

          int
          commutative_integer_operator (x, mode)
               rtx x;
               machine_mode mode;
          {
            enum rtx_code code = GET_CODE (x);
            if (GET_MODE (x) != mode)
              return 0;
            return (GET_RTX_CLASS (code) == RTX_COMM_ARITH
                    || code == EQ || code == NE);
          }

     Then the following pattern will match any RTL expression consisting
     of a commutative operator applied to two general operands:

          (match_operator:SI 3 "commutative_operator"
            [(match_operand:SI 1 "general_operand" "g")
             (match_operand:SI 2 "general_operand" "g")])

     Here the vector '[OPERANDS...]' contains two patterns because the
     expressions to be matched all contain two operands.

     When this pattern does match, the two operands of the commutative
     operator are recorded as operands 1 and 2 of the insn.  (This is
     done by the two instances of 'match_operand'.)  Operand 3 of the
     insn will be the entire commutative expression: use 'GET_CODE
     (operands[3])' to see which commutative operator was used.

     The machine mode M of 'match_operator' works like that of
     'match_operand': it is passed as the second argument to the
     predicate function, and that function is solely responsible for
     deciding whether the expression to be matched "has" that mode.

     When constructing an insn, argument 3 of the gen-function will
     specify the operation (i.e. the expression code) for the expression
     to be made.  It should be an RTL expression, whose expression code
     is copied into a new expression whose operands are arguments 1 and
     2 of the gen-function.  The subexpressions of argument 3 are not
     used; only its expression code matters.

     When 'match_operator' is used in a pattern for matching an insn, it
     usually best if the operand number of the 'match_operator' is
     higher than that of the actual operands of the insn.  This improves
     register allocation because the register allocator often looks at
     operands 1 and 2 of insns to see if it can do register tying.

     There is no way to specify constraints in 'match_operator'.  The
     operand of the insn which corresponds to the 'match_operator' never
     has any constraints because it is never reloaded as a whole.
     However, if parts of its OPERANDS are matched by 'match_operand'
     patterns, those parts may have constraints of their own.

'(match_op_dup:M N[OPERANDS...])'
     Like 'match_dup', except that it applies to operators instead of
     operands.  When constructing an insn, operand number N will be
     substituted at this point.  But in matching, 'match_op_dup' behaves
     differently.  It assumes that operand number N has already been
     determined by a 'match_operator' appearing earlier in the
     recognition template, and it matches only an identical-looking
     expression.

'(match_parallel N PREDICATE [SUBPAT...])'
     This pattern is a placeholder for an insn that consists of a
     'parallel' expression with a variable number of elements.  This
     expression should only appear at the top level of an insn pattern.

     When constructing an insn, operand number N will be substituted at
     this point.  When matching an insn, it matches if the body of the
     insn is a 'parallel' expression with at least as many elements as
     the vector of SUBPAT expressions in the 'match_parallel', if each
     SUBPAT matches the corresponding element of the 'parallel', _and_
     the function PREDICATE returns nonzero on the 'parallel' that is
     the body of the insn.  It is the responsibility of the predicate to
     validate elements of the 'parallel' beyond those listed in the
     'match_parallel'.

     A typical use of 'match_parallel' is to match load and store
     multiple expressions, which can contain a variable number of
     elements in a 'parallel'.  For example,

          (define_insn ""
            [(match_parallel 0 "load_multiple_operation"
               [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
                     (match_operand:SI 2 "memory_operand" "m"))
                (use (reg:SI 179))
                (clobber (reg:SI 179))])]
            ""
            "loadm 0,0,%1,%2")

     This example comes from 'a29k.md'.  The function
     'load_multiple_operation' is defined in 'a29k.c' and checks that
     subsequent elements in the 'parallel' are the same as the 'set' in
     the pattern, except that they are referencing subsequent registers
     and memory locations.

     An insn that matches this pattern might look like:

          (parallel
           [(set (reg:SI 20) (mem:SI (reg:SI 100)))
            (use (reg:SI 179))
            (clobber (reg:SI 179))
            (set (reg:SI 21)
                 (mem:SI (plus:SI (reg:SI 100)
                                  (const_int 4))))
            (set (reg:SI 22)
                 (mem:SI (plus:SI (reg:SI 100)
                                  (const_int 8))))])

'(match_par_dup N [SUBPAT...])'
     Like 'match_op_dup', but for 'match_parallel' instead of
     'match_operator'.

==============================================================================
File: gccint.info,  Node: |Output_Template|,  Next: |Output_Statement|,  Prev: |RTL_Template|,  Up: |Machine_Desc|
==============================================================================

                                                               *Output_Template*

17.5 Output Templates and Operand Substitution
----------------------------------------------

The "output template" is a string which specifies how to output the
assembler code for an instruction pattern.  Most of the template is a
fixed string which is output literally.  The character '%' is used to
specify where to substitute an operand; it can also be used to identify
places where different variants of the assembler require different
syntax.

 In the simplest case, a '%' followed by a digit N says to output
operand N at that point in the string.

 '%' followed by a letter and a digit says to output an operand in an
alternate fashion.  Four letters have standard, built-in meanings
described below.  The machine description macro 'PRINT_OPERAND' can
define additional letters with nonstandard meanings.

 '%cDIGIT' can be used to substitute an operand that is a constant value
without the syntax that normally indicates an immediate operand.

 '%nDIGIT' is like '%cDIGIT' except that the value of the constant is
negated before printing.

 '%aDIGIT' can be used to substitute an operand as if it were a memory
reference, with the actual operand treated as the address.  This may be
useful when outputting a "load address" instruction, because often the
assembler syntax for such an instruction requires you to write the
operand as if it were a memory reference.

 '%lDIGIT' is used to substitute a 'label_ref' into a jump instruction.

 '%=' outputs a number which is unique to each instruction in the entire
compilation.  This is useful for making local labels to be referred to
more than once in a single template that generates multiple assembler
instructions.

 '%' followed by a punctuation character specifies a substitution that
does not use an operand.  Only one case is standard: '%%' outputs a '%'
into the assembler code.  Other nonstandard cases can be defined in the
'PRINT_OPERAND' macro.  You must also define which punctuation
characters are valid with the 'PRINT_OPERAND_PUNCT_VALID_P' macro.

 The template may generate multiple assembler instructions.  Write the
text for the instructions, with '\;' between them.

 When the RTL contains two operands which are required by constraint to
match each other, the output template must refer only to the
lower-numbered operand.  Matching operands are not always identical, and
the rest of the compiler arranges to put the proper RTL expression for
printing into the lower-numbered operand.

 One use of nonstandard letters or punctuation following '%' is to
distinguish between different assembler languages for the same machine;
for example, Motorola syntax versus MIT syntax for the 68000.  Motorola
syntax requires periods in most opcode names, while MIT syntax does not.
For example, the opcode 'movel' in MIT syntax is 'move.l' in Motorola
syntax.  The same file of patterns is used for both kinds of output
syntax, but the character sequence '%.' is used in each place where
Motorola syntax wants a period.  The 'PRINT_OPERAND' macro for Motorola
syntax defines the sequence to output a period; the macro for MIT syntax
defines it to do nothing.

 As a special case, a template consisting of the single character '#'
instructs the compiler to first split the insn, and then output the
resulting instructions separately.  This helps eliminate redundancy in
the output templates.  If you have a 'define_insn' that needs to emit
multiple assembler instructions, and there is a matching 'define_split'
already defined, then you can simply use '#' as the output template
instead of writing an output template that emits the multiple assembler
instructions.

 Note that '#' only has an effect while generating assembly code; it
does not affect whether a split occurs earlier.  An associated
'define_split' must exist and it must be suitable for use after register
allocation.

 If the macro 'ASSEMBLER_DIALECT' is defined, you can use construct of
the form '{option0|option1|option2}' in the templates.  These describe
multiple variants of assembler language syntax.  *Note Instruction
Output::.

==============================================================================
File: gccint.info,  Node: |Output_Statement|,  Next: |Predicates|,  Prev: |Output_Template|,  Up: |Machine_Desc|
==============================================================================

                                                              *Output_Statement*

17.6 C Statements for Assembler Output
--------------------------------------

Often a single fixed template string cannot produce correct and
efficient assembler code for all the cases that are recognized by a
single instruction pattern.  For example, the opcodes may depend on the
kinds of operands; or some unfortunate combinations of operands may
require extra machine instructions.

 If the output control string starts with a '@', then it is actually a
series of templates, each on a separate line.  (Blank lines and leading
spaces and tabs are ignored.)  The templates correspond to the pattern's
constraint alternatives (*note Multi-Alternative::).  For example, if a
target machine has a two-address add instruction 'addr' to add into a
register and another 'addm' to add a register to memory, you might write
this pattern:

     (define_insn "addsi3"
       [(set (match_operand:SI 0 "general_operand" "=r,m")
             (plus:SI (match_operand:SI 1 "general_operand" "0,0")
                      (match_operand:SI 2 "general_operand" "g,r")))]
       ""
       "@
        addr %2,%0
        addm %2,%0")

 If the output control string starts with a '*', then it is not an
output template but rather a piece of C program that should compute a
template.  It should execute a 'return' statement to return the
template-string you want.  Most such templates use C string literals,
which require doublequote characters to delimit them.  To include these
doublequote characters in the string, prefix each one with '\'.

 If the output control string is written as a brace block instead of a
double-quoted string, it is automatically assumed to be C code.  In that
case, it is not necessary to put in a leading asterisk, or to escape the
doublequotes surrounding C string literals.

 The operands may be found in the array 'operands', whose C data type is
'rtx []'.

 It is very common to select different ways of generating assembler code
based on whether an immediate operand is within a certain range.  Be
careful when doing this, because the result of 'INTVAL' is an integer on
the host machine.  If the host machine has more bits in an 'int' than
the target machine has in the mode in which the constant will be used,
then some of the bits you get from 'INTVAL' will be superfluous.  For
proper results, you must carefully disregard the values of those bits.

 It is possible to output an assembler instruction and then go on to
output or compute more of them, using the subroutine 'output_asm_insn'.
This receives two arguments: a template-string and a vector of operands.
The vector may be 'operands', or it may be another array of 'rtx' that
you declare locally and initialize yourself.

 When an insn pattern has multiple alternatives in its constraints,
often the appearance of the assembler code is determined mostly by which
alternative was matched.  When this is so, the C code can test the
variable 'which_alternative', which is the ordinal number of the
alternative that was actually satisfied (0 for the first, 1 for the
second alternative, etc.).

 For example, suppose there are two opcodes for storing zero, 'clrreg'
for registers and 'clrmem' for memory locations.  Here is how a pattern
could use 'which_alternative' to choose between them:

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r,m")
             (const_int 0))]
       ""
       {
       return (which_alternative == 0
               ? "clrreg %0" : "clrmem %0");
       })

 The example above, where the assembler code to generate was _solely_
determined by the alternative, could also have been specified as
follows, having the output control string start with a '@':

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r,m")
             (const_int 0))]
       ""
       "@
        clrreg %0
        clrmem %0")

 If you just need a little bit of C code in one (or a few) alternatives,
you can use '*' inside of a '@' multi-alternative template:

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r,<,m")
             (const_int 0))]
       ""
       "@
        clrreg %0
        * return stack_mem_p (operands[0]) ? \"push 0\" : \"clrmem %0\";
        clrmem %0")

==============================================================================
File: gccint.info,  Node: |Predicates|,  Next: |Constraints|,  Prev: |Output_Statement|,  Up: |Machine_Desc|
==============================================================================

                                                                    *Predicates*

17.7 Predicates
---------------

A predicate determines whether a 'match_operand' or 'match_operator'
expression matches, and therefore whether the surrounding instruction
pattern will be used for that combination of operands.  GCC has a number
of machine-independent predicates, and you can define machine-specific
predicates as needed.  By convention, predicates used with
'match_operand' have names that end in '_operand', and those used with
'match_operator' have names that end in '_operator'.

 All predicates are boolean functions (in the mathematical sense) of two
arguments: the RTL expression that is being considered at that position
in the instruction pattern, and the machine mode that the
'match_operand' or 'match_operator' specifies.  In this section, the
first argument is called OP and the second argument MODE.  Predicates
can be called from C as ordinary two-argument functions; this can be
useful in output templates or other machine-specific code.

 Operand predicates can allow operands that are not actually acceptable
to the hardware, as long as the constraints give reload the ability to
fix them up (*note Constraints::).  However, GCC will usually generate
better code if the predicates specify the requirements of the machine
instructions as closely as possible.  Reload cannot fix up operands that
must be constants ("immediate operands"); you must use a predicate that
allows only constants, or else enforce the requirement in the extra
condition.

 Most predicates handle their MODE argument in a uniform manner.  If
MODE is 'VOIDmode' (unspecified), then OP can have any mode.  If MODE is
anything else, then OP must have the same mode, unless OP is a
'CONST_INT' or integer 'CONST_DOUBLE'.  These RTL expressions always
have 'VOIDmode', so it would be counterproductive to check that their
mode matches.  Instead, predicates that accept 'CONST_INT' and/or
integer 'CONST_DOUBLE' check that the value stored in the constant will
fit in the requested mode.

 Predicates with this behavior are called "normal".  'genrecog' can
optimize the instruction recognizer based on knowledge of how normal
predicates treat modes.  It can also diagnose certain kinds of common
errors in the use of normal predicates; for instance, it is almost
always an error to use a normal predicate without specifying a mode.

 Predicates that do something different with their MODE argument are
called "special".  The generic predicates 'address_operand' and
'pmode_register_operand' are special predicates.  'genrecog' does not do
any optimizations or diagnosis when special predicates are used.

MENU

* |Machine_Independent_Predicates|::  Predicates available to all back ends.
* |Defining_Predicates|::             How to write machine-specific predicate
                                    functions.

==============================================================================
File: gccint.info,  Node: |Machine_Independent_Predicates|,  Next: |Defining_Predicates|,  Up: |Predicates|
==============================================================================

                                                *Machine_Independent_Predicates*

17.7.1 Machine-Independent Predicates
-------------------------------------

These are the generic predicates available to all back ends.  They are
defined in 'recog.c'.  The first category of predicates allow only
constant, or "immediate", operands.

 -- Function: immediate_operand
     This predicate allows any sort of constant that fits in MODE.  It
     is an appropriate choice for instructions that take operands that
     must be constant.

 -- Function: const_int_operand
     This predicate allows any 'CONST_INT' expression that fits in MODE.
     It is an appropriate choice for an immediate operand that does not
     allow a symbol or label.

 -- Function: const_double_operand
     This predicate accepts any 'CONST_DOUBLE' expression that has
     exactly MODE.  If MODE is 'VOIDmode', it will also accept
     'CONST_INT'.  It is intended for immediate floating point
     constants.

The second category of predicates allow only some kind of machine
register.

 -- Function: register_operand
     This predicate allows any 'REG' or 'SUBREG' expression that is
     valid for MODE.  It is often suitable for arithmetic instruction
     operands on a RISC machine.

 -- Function: pmode_register_operand
     This is a slight variant on 'register_operand' which works around a
     limitation in the machine-description reader.

          (match_operand N "pmode_register_operand" CONSTRAINT)

     means exactly what

          (match_operand:P N "register_operand" CONSTRAINT)

     would mean, if the machine-description reader accepted ':P' mode
     suffixes.  Unfortunately, it cannot, because 'Pmode' is an alias
     for some other mode, and might vary with machine-specific options.
     *Note Misc::.

 -- Function: scratch_operand
     This predicate allows hard registers and 'SCRATCH' expressions, but
     not pseudo-registers.  It is used internally by 'match_scratch'; it
     should not be used directly.

The third category of predicates allow only some kind of memory
reference.

 -- Function: memory_operand
     This predicate allows any valid reference to a quantity of mode
     MODE in memory, as determined by the weak form of
     'GO_IF_LEGITIMATE_ADDRESS' (*note Addressing Modes::).

 -- Function: address_operand
     This predicate is a little unusual; it allows any operand that is a
     valid expression for the _address_ of a quantity of mode MODE,
     again determined by the weak form of 'GO_IF_LEGITIMATE_ADDRESS'.
     To first order, if '(mem:MODE (EXP))' is acceptable to
     'memory_operand', then EXP is acceptable to 'address_operand'.
     Note that EXP does not necessarily have the mode MODE.

 -- Function: indirect_operand
     This is a stricter form of 'memory_operand' which allows only
     memory references with a 'general_operand' as the address
     expression.  New uses of this predicate are discouraged, because
     'general_operand' is very permissive, so it's hard to tell what an
     'indirect_operand' does or does not allow.  If a target has
     different requirements for memory operands for different
     instructions, it is better to define target-specific predicates
     which enforce the hardware's requirements explicitly.

 -- Function: push_operand
     This predicate allows a memory reference suitable for pushing a
     value onto the stack.  This will be a 'MEM' which refers to
     'stack_pointer_rtx', with a side effect in its address expression
     (*note Incdec::); which one is determined by the 'STACK_PUSH_CODE'
     macro (*note Frame Layout::).

 -- Function: pop_operand
     This predicate allows a memory reference suitable for popping a
     value off the stack.  Again, this will be a 'MEM' referring to
     'stack_pointer_rtx', with a side effect in its address expression.
     However, this time 'STACK_POP_CODE' is expected.

The fourth category of predicates allow some combination of the above
operands.

 -- Function: nonmemory_operand
     This predicate allows any immediate or register operand valid for
     MODE.

 -- Function: nonimmediate_operand
     This predicate allows any register or memory operand valid for
     MODE.

 -- Function: general_operand
     This predicate allows any immediate, register, or memory operand
     valid for MODE.

Finally, there are two generic operator predicates.

 -- Function: comparison_operator
     This predicate matches any expression which performs an arithmetic
     comparison in MODE; that is, 'COMPARISON_P' is true for the
     expression code.

 -- Function: ordered_comparison_operator
     This predicate matches any expression which performs an arithmetic
     comparison in MODE and whose expression code is valid for integer
     modes; that is, the expression code will be one of 'eq', 'ne',
     'lt', 'ltu', 'le', 'leu', 'gt', 'gtu', 'ge', 'geu'.

==============================================================================
File: gccint.info,  Node: |Defining_Predicates|,  Prev: |Machine_Independent_Predicates|,  Up: |Predicates|
==============================================================================

                                                           *Defining_Predicates*

17.7.2 Defining Machine-Specific Predicates
-------------------------------------------

Many machines have requirements for their operands that cannot be
expressed precisely using the generic predicates.  You can define
additional predicates using 'define_predicate' and
'define_special_predicate' expressions.  These expressions have three
operands:

   * The name of the predicate, as it will be referred to in
     'match_operand' or 'match_operator' expressions.

   * An RTL expression which evaluates to true if the predicate allows
     the operand OP, false if it does not.  This expression can only use
     the following RTL codes:

     'MATCH_OPERAND'
          When written inside a predicate expression, a 'MATCH_OPERAND'
          expression evaluates to true if the predicate it names would
          allow OP.  The operand number and constraint are ignored.  Due
          to limitations in 'genrecog', you can only refer to generic
          predicates and predicates that have already been defined.

     'MATCH_CODE'
          This expression evaluates to true if OP or a specified
          subexpression of OP has one of a given list of RTX codes.

          The first operand of this expression is a string constant
          containing a comma-separated list of RTX code names (in lower
          case).  These are the codes for which the 'MATCH_CODE' will be
          true.

          The second operand is a string constant which indicates what
          subexpression of OP to examine.  If it is absent or the empty
          string, OP itself is examined.  Otherwise, the string constant
          must be a sequence of digits and/or lowercase letters.  Each
          character indicates a subexpression to extract from the
          current expression; for the first character this is OP, for
          the second and subsequent characters it is the result of the
          previous character.  A digit N extracts 'XEXP (E, N)'; a
          letter L extracts 'XVECEXP (E, 0, N)' where N is the
          alphabetic ordinal of L (0 for 'a', 1 for 'b', and so on).
          The 'MATCH_CODE' then examines the RTX code of the
          subexpression extracted by the complete string.  It is not
          possible to extract components of an 'rtvec' that is not at
          position 0 within its RTX object.

     'MATCH_TEST'
          This expression has one operand, a string constant containing
          a C expression.  The predicate's arguments, OP and MODE, are
          available with those names in the C expression.  The
          'MATCH_TEST' evaluates to true if the C expression evaluates
          to a nonzero value.  'MATCH_TEST' expressions must not have
          side effects.

     'AND'
     'IOR'
     'NOT'
     'IF_THEN_ELSE'
          The basic 'MATCH_' expressions can be combined using these
          logical operators, which have the semantics of the C operators
          '&&', '||', '!', and '? :' respectively.  As in Common Lisp,
          you may give an 'AND' or 'IOR' expression an arbitrary number
          of arguments; this has exactly the same effect as writing a
          chain of two-argument 'AND' or 'IOR' expressions.

   * An optional block of C code, which should execute 'return true' if
     the predicate is found to match and 'return false' if it does not.
     It must not have any side effects.  The predicate arguments, OP and
     MODE, are available with those names.

     If a code block is present in a predicate definition, then the RTL
     expression must evaluate to true _and_ the code block must execute
     'return true' for the predicate to allow the operand.  The RTL
     expression is evaluated first; do not re-check anything in the code
     block that was checked in the RTL expression.

 The program 'genrecog' scans 'define_predicate' and
'define_special_predicate' expressions to determine which RTX codes are
possibly allowed.  You should always make this explicit in the RTL
predicate expression, using 'MATCH_OPERAND' and 'MATCH_CODE'.

 Here is an example of a simple predicate definition, from the IA64
machine description:

     ;; True if OP is a 'SYMBOL_REF' which refers to the sdata section.
     (define_predicate "small_addr_symbolic_operand"
       (and (match_code "symbol_ref")
            (match_test "SYMBOL_REF_SMALL_ADDR_P (op)")))

And here is another, showing the use of the C block.

     ;; True if OP is a register operand that is (or could be) a GR reg.
     (define_predicate "gr_register_operand"
       (match_operand 0 "register_operand")
     {
       unsigned int regno;
       if (GET_CODE (op) == SUBREG)
         op = SUBREG_REG (op);

       regno = REGNO (op);
       return (regno >= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));
     })

 Predicates written with 'define_predicate' automatically include a test
that MODE is 'VOIDmode', or OP has the same mode as MODE, or OP is a
'CONST_INT' or 'CONST_DOUBLE'.  They do _not_ check specifically for
integer 'CONST_DOUBLE', nor do they test that the value of either kind
of constant fits in the requested mode.  This is because target-specific
predicates that take constants usually have to do more stringent value
checks anyway.  If you need the exact same treatment of 'CONST_INT' or
'CONST_DOUBLE' that the generic predicates provide, use a
'MATCH_OPERAND' subexpression to call 'const_int_operand',
'const_double_operand', or 'immediate_operand'.

 Predicates written with 'define_special_predicate' do not get any
automatic mode checks, and are treated as having special mode handling
by 'genrecog'.

 The program 'genpreds' is responsible for generating code to test
predicates.  It also writes a header file containing function
declarations for all machine-specific predicates.  It is not necessary
to declare these predicates in 'CPU-protos.h'.

==============================================================================
File: gccint.info,  Node: |Constraints|,  Next: |Standard_Names|,  Prev: |Predicates|,  Up: |Machine_Desc|
==============================================================================

                                                                   *Constraints*

17.8 Operand Constraints
------------------------

Each 'match_operand' in an instruction pattern can specify constraints
for the operands allowed.  The constraints allow you to fine-tune
matching within the set of operands allowed by the predicate.

 Constraints can say whether an operand may be in a register, and which
kinds of register; whether the operand can be a memory reference, and
which kinds of address; whether the operand may be an immediate
constant, and which possible values it may have.  Constraints can also
require two operands to match.  Side-effects aren't allowed in operands
of inline 'asm', unless '<' or '>' constraints are used, because there
is no guarantee that the side effects will happen exactly once in an
instruction that can update the addressing register.

MENU

* |Simple_Constraints|::  Basic use of constraints.
* |Multi_Alternative|::   When an insn has two alternative constraint-patterns.
* |Class_Preferences|::   Constraints guide which hard register to put things in.
* |Modifiers|::           More precise control over effects of constraints.
* |Machine_Constraints|:: Existing constraints for some particular machines.
* |Disable_Insn_Alternatives|:: Disable insn alternatives using attributes.
* |Define_Constraints|::  How to define machine-specific constraints.
* |C_Constraint_Interface|:: How to test constraints from C code.

==============================================================================
File: gccint.info,  Node: |Simple_Constraints|,  Next: |Multi_Alternative|,  Up: |Constraints|
==============================================================================

                                                            *Simple_Constraints*

17.8.1 Simple Constraints
-------------------------

The simplest kind of constraint is a string full of letters, each of
which describes one kind of operand that is permitted.  Here are the
letters that are allowed:

whitespace
     Whitespace characters are ignored and can be inserted at any
     position except the first.  This enables each alternative for
     different operands to be visually aligned in the machine
     description even if they have different number of constraints and
     modifiers.

'm'
     A memory operand is allowed, with any kind of address that the
     machine supports in general.  Note that the letter used for the
     general memory constraint can be re-defined by a back end using the
     'TARGET_MEM_CONSTRAINT' macro.

'o'
     A memory operand is allowed, but only if the address is
     "offsettable".  This means that adding a small integer (actually,
     the width in bytes of the operand, as determined by its machine
     mode) may be added to the address and the result is also a valid
     memory address.

     For example, an address which is constant is offsettable; so is an
     address that is the sum of a register and a constant (as long as a
     slightly larger constant is also within the range of
     address-offsets supported by the machine); but an autoincrement or
     autodecrement address is not offsettable.  More complicated
     indirect/indexed addresses may or may not be offsettable depending
     on the other addressing modes that the machine supports.

     Note that in an output operand which can be matched by another
     operand, the constraint letter 'o' is valid only when accompanied
     by both '<' (if the target machine has predecrement addressing) and
     '>' (if the target machine has preincrement addressing).

'V'
     A memory operand that is not offsettable.  In other words, anything
     that would fit the 'm' constraint but not the 'o' constraint.

'<'
     A memory operand with autodecrement addressing (either predecrement
     or postdecrement) is allowed.  In inline 'asm' this constraint is
     only allowed if the operand is used exactly once in an instruction
     that can handle the side effects.  Not using an operand with '<' in
     constraint string in the inline 'asm' pattern at all or using it in
     multiple instructions isn't valid, because the side effects
     wouldn't be performed or would be performed more than once.
     Furthermore, on some targets the operand with '<' in constraint
     string must be accompanied by special instruction suffixes like
     '%U0' instruction suffix on PowerPC or '%P0' on IA-64.

'>'
     A memory operand with autoincrement addressing (either preincrement
     or postincrement) is allowed.  In inline 'asm' the same
     restrictions as for '<' apply.

'r'
     A register operand is allowed provided that it is in a general
     register.

'i'
     An immediate integer operand (one with constant value) is allowed.
     This includes symbolic constants whose values will be known only at
     assembly time or later.

'n'
     An immediate integer operand with a known numeric value is allowed.
     Many systems cannot support assembly-time constants for operands
     less than a word wide.  Constraints for these operands should use
     'n' rather than 'i'.

'I', 'J', 'K', ... 'P'
     Other letters in the range 'I' through 'P' may be defined in a
     machine-dependent fashion to permit immediate integer operands with
     explicit integer values in specified ranges.  For example, on the
     68000, 'I' is defined to stand for the range of values 1 to 8.
     This is the range permitted as a shift count in the shift
     instructions.

'E'
     An immediate floating operand (expression code 'const_double') is
     allowed, but only if the target floating point format is the same
     as that of the host machine (on which the compiler is running).

'F'
     An immediate floating operand (expression code 'const_double' or
     'const_vector') is allowed.

'G', 'H'
     'G' and 'H' may be defined in a machine-dependent fashion to permit
     immediate floating operands in particular ranges of values.

's'
     An immediate integer operand whose value is not an explicit integer
     is allowed.

     This might appear strange; if an insn allows a constant operand
     with a value not known at compile time, it certainly must allow any
     known value.  So why use 's' instead of 'i'?  Sometimes it allows
     better code to be generated.

     For example, on the 68000 in a fullword instruction it is possible
     to use an immediate operand; but if the immediate value is between
     -128 and 127, better code results from loading the value into a
     register and using the register.  This is because the load into the
     register can be done with a 'moveq' instruction.  We arrange for
     this to happen by defining the letter 'K' to mean "any integer
     outside the range -128 to 127", and then specifying 'Ks' in the
     operand constraints.

'g'
     Any register, memory or immediate integer operand is allowed,
     except for registers that are not general registers.

'X'
     Any operand whatsoever is allowed, even if it does not satisfy
     'general_operand'.  This is normally used in the constraint of a
     'match_scratch' when certain alternatives will not actually require
     a scratch register.

'0', '1', '2', ... '9'
     An operand that matches the specified operand number is allowed.
     If a digit is used together with letters within the same
     alternative, the digit should come last.

     This number is allowed to be more than a single digit.  If multiple
     digits are encountered consecutively, they are interpreted as a
     single decimal integer.  There is scant chance for ambiguity, since
     to-date it has never been desirable that '10' be interpreted as
     matching either operand 1 _or_ operand 0.  Should this be desired,
     one can use multiple alternatives instead.

     This is called a "matching constraint" and what it really means is
     that the assembler has only a single operand that fills two roles
     considered separate in the RTL insn.  For example, an add insn has
     two input operands and one output operand in the RTL, but on most
     CISC machines an add instruction really has only two operands, one
     of them an input-output operand:

          addl #35,r12

     Matching constraints are used in these circumstances.  More
     precisely, the two operands that match must include one input-only
     operand and one output-only operand.  Moreover, the digit must be a
     smaller number than the number of the operand that uses it in the
     constraint.

     For operands to match in a particular case usually means that they
     are identical-looking RTL expressions.  But in a few special cases
     specific kinds of dissimilarity are allowed.  For example, '*x' as
     an input operand will match '*x++' as an output operand.  For
     proper results in such cases, the output template should always use
     the output-operand's number when printing the operand.

'p'
     An operand that is a valid memory address is allowed.  This is for
     "load address" and "push address" instructions.

     'p' in the constraint must be accompanied by 'address_operand' as
     the predicate in the 'match_operand'.  This predicate interprets
     the mode specified in the 'match_operand' as the mode of the memory
     reference for which the address would be valid.

OTHER-LETTERS
     Other letters can be defined in machine-dependent fashion to stand
     for particular classes of registers or other arbitrary operand
     types.  'd', 'a' and 'f' are defined on the 68000/68020 to stand
     for data, address and floating point registers.

 In order to have valid assembler code, each operand must satisfy its
constraint.  But a failure to do so does not prevent the pattern from
applying to an insn.  Instead, it directs the compiler to modify the
code so that the constraint will be satisfied.  Usually this is done by
copying an operand into a register.

 Contrast, therefore, the two instruction patterns that follow:

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r")
             (plus:SI (match_dup 0)
                      (match_operand:SI 1 "general_operand" "r")))]
       ""
       "...")

which has two operands, one of which must appear in two places, and

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r")
             (plus:SI (match_operand:SI 1 "general_operand" "0")
                      (match_operand:SI 2 "general_operand" "r")))]
       ""
       "...")

which has three operands, two of which are required by a constraint to
be identical.  If we are considering an insn of the form

     (insn N PREV NEXT
       (set (reg:SI 3)
            (plus:SI (reg:SI 6) (reg:SI 109)))
       ...)

the first pattern would not apply at all, because this insn does not
contain two identical subexpressions in the right place.  The pattern
would say, "That does not look like an add instruction; try other
patterns".  The second pattern would say, "Yes, that's an add
instruction, but there is something wrong with it".  It would direct the
reload pass of the compiler to generate additional insns to make the
constraint true.  The results might look like this:

     (insn N2 PREV N
       (set (reg:SI 3) (reg:SI 6))
       ...)

     (insn N N2 NEXT
       (set (reg:SI 3)
            (plus:SI (reg:SI 3) (reg:SI 109)))
       ...)

 It is up to you to make sure that each operand, in each pattern, has
constraints that can handle any RTL expression that could be present for
that operand.  (When multiple alternatives are in use, each pattern
must, for each possible combination of operand expressions, have at
least one alternative which can handle that combination of operands.)
The constraints don't need to _allow_ any possible operand--when this is
the case, they do not constrain--but they must at least point the way to
reloading any possible operand so that it will fit.

   * If the constraint accepts whatever operands the predicate permits,
     there is no problem: reloading is never necessary for this operand.

     For example, an operand whose constraints permit everything except
     registers is safe provided its predicate rejects registers.

     An operand whose predicate accepts only constant values is safe
     provided its constraints include the letter 'i'.  If any possible
     constant value is accepted, then nothing less than 'i' will do; if
     the predicate is more selective, then the constraints may also be
     more selective.

   * Any operand expression can be reloaded by copying it into a
     register.  So if an operand's constraints allow some kind of
     register, it is certain to be safe.  It need not permit all classes
     of registers; the compiler knows how to copy a register into
     another register of the proper class in order to make an
     instruction valid.

   * A nonoffsettable memory reference can be reloaded by copying the
     address into a register.  So if the constraint uses the letter 'o',
     all memory references are taken care of.

   * A constant operand can be reloaded by allocating space in memory to
     hold it as preinitialized data.  Then the memory reference can be
     used in place of the constant.  So if the constraint uses the
     letters 'o' or 'm', constant operands are not a problem.

   * If the constraint permits a constant and a pseudo register used in
     an insn was not allocated to a hard register and is equivalent to a
     constant, the register will be replaced with the constant.  If the
     predicate does not permit a constant and the insn is re-recognized
     for some reason, the compiler will crash.  Thus the predicate must
     always recognize any objects allowed by the constraint.

 If the operand's predicate can recognize registers, but the constraint
does not permit them, it can make the compiler crash.  When this operand
happens to be a register, the reload pass will be stymied, because it
does not know how to copy a register temporarily into memory.

 If the predicate accepts a unary operator, the constraint applies to
the operand.  For example, the MIPS processor at ISA level 3 supports an
instruction which adds two registers in 'SImode' to produce a 'DImode'
result, but only if the registers are correctly sign extended.  This
predicate for the input operands accepts a 'sign_extend' of an 'SImode'
register.  Write the constraint to indicate the type of register that is
required for the operand of the 'sign_extend'.

==============================================================================
File: gccint.info,  Node: |Multi_Alternative|,  Next: |Class_Preferences|,  Prev: |Simple_Constraints|,  Up: |Constraints|
==============================================================================

                                                             *Multi_Alternative*

17.8.2 Multiple Alternative Constraints
---------------------------------------

Sometimes a single instruction has multiple alternative sets of possible
operands.  For example, on the 68000, a logical-or instruction can
combine register or an immediate value into memory, or it can combine
any kind of operand into a register; but it cannot combine one memory
location into another.

 These constraints are represented as multiple alternatives.  An
alternative can be described by a series of letters for each operand.
The overall constraint for an operand is made from the letters for this
operand from the first alternative, a comma, the letters for this
operand from the second alternative, a comma, and so on until the last
alternative.  All operands for a single instruction must have the same
number of alternatives.  Here is how it is done for fullword logical-or
on the 68000:

     (define_insn "iorsi3"
       [(set (match_operand:SI 0 "general_operand" "=m,d")
             (ior:SI (match_operand:SI 1 "general_operand" "%0,0")
                     (match_operand:SI 2 "general_operand" "dKs,dmKs")))]
       ...)

 The first alternative has 'm' (memory) for operand 0, '0' for operand 1
(meaning it must match operand 0), and 'dKs' for operand 2.  The second
alternative has 'd' (data register) for operand 0, '0' for operand 1,
and 'dmKs' for operand 2.  The '=' and '%' in the constraints apply to
all the alternatives; their meaning is explained in the next section
(*note Class Preferences::).

 If all the operands fit any one alternative, the instruction is valid.
Otherwise, for each alternative, the compiler counts how many
instructions must be added to copy the operands so that that alternative
applies.  The alternative requiring the least copying is chosen.  If two
alternatives need the same amount of copying, the one that comes first
is chosen.  These choices can be altered with the '?' and '!'
characters:

'?'
     Disparage slightly the alternative that the '?' appears in, as a
     choice when no alternative applies exactly.  The compiler regards
     this alternative as one unit more costly for each '?' that appears
     in it.

'!'
     Disparage severely the alternative that the '!' appears in.  This
     alternative can still be used if it fits without reloading, but if
     reloading is needed, some other alternative will be used.

'^'
     This constraint is analogous to '?' but it disparages slightly the
     alternative only if the operand with the '^' needs a reload.

'$'
     This constraint is analogous to '!' but it disparages severely the
     alternative only if the operand with the '$' needs a reload.

 When an insn pattern has multiple alternatives in its constraints,
often the appearance of the assembler code is determined mostly by which
alternative was matched.  When this is so, the C code for writing the
assembler code can use the variable 'which_alternative', which is the
ordinal number of the alternative that was actually satisfied (0 for the
first, 1 for the second alternative, etc.).  *Note Output Statement::.

==============================================================================
File: gccint.info,  Node: |Class_Preferences|,  Next: |Modifiers|,  Prev: |Multi_Alternative|,  Up: |Constraints|
==============================================================================

                                                             *Class_Preferences*

17.8.3 Register Class Preferences
---------------------------------

The operand constraints have another function: they enable the compiler
to decide which kind of hardware register a pseudo register is best
allocated to.  The compiler examines the constraints that apply to the
insns that use the pseudo register, looking for the machine-dependent
letters such as 'd' and 'a' that specify classes of registers.  The
pseudo register is put in whichever class gets the most "votes".  The
constraint letters 'g' and 'r' also vote: they vote in favor of a
general register.  The machine description says which registers are
considered general.

 Of course, on some machines all registers are equivalent, and no
register classes are defined.  Then none of this complexity is relevant.

==============================================================================
File: gccint.info,  Node: |Modifiers|,  Next: |Machine_Constraints|,  Prev: |Class_Preferences|,  Up: |Constraints|
==============================================================================

                                                                     *Modifiers*

17.8.4 Constraint Modifier Characters
-------------------------------------

Here are constraint modifier characters.

'='
     Means that this operand is written to by this instruction: the
     previous value is discarded and replaced by new data.

'+'
     Means that this operand is both read and written by the
     instruction.

     When the compiler fixes up the operands to satisfy the constraints,
     it needs to know which operands are read by the instruction and
     which are written by it.  '=' identifies an operand which is only
     written; '+' identifies an operand that is both read and written;
     all other operands are assumed to only be read.

     If you specify '=' or '+' in a constraint, you put it in the first
     character of the constraint string.

'&'
     Means (in a particular alternative) that this operand is an
     "earlyclobber" operand, which is written before the instruction is
     finished using the input operands.  Therefore, this operand may not
     lie in a register that is read by the instruction or as part of any
     memory address.

     '&' applies only to the alternative in which it is written.  In
     constraints with multiple alternatives, sometimes one alternative
     requires '&' while others do not.  See, for example, the 'movdf'
     insn of the 68000.

     A operand which is read by the instruction can be tied to an
     earlyclobber operand if its only use as an input occurs before the
     early result is written.  Adding alternatives of this form often
     allows GCC to produce better code when only some of the read
     operands can be affected by the earlyclobber.  See, for example,
     the 'mulsi3' insn of the ARM.

     Furthermore, if the "earlyclobber" operand is also a read/write
     operand, then that operand is written only after it's used.

     '&' does not obviate the need to write '=' or '+'.  As
     "earlyclobber" operands are always written, a read-only
     "earlyclobber" operand is ill-formed and will be rejected by the
     compiler.

'%'
     Declares the instruction to be commutative for this operand and the
     following operand.  This means that the compiler may interchange
     the two operands if that is the cheapest way to make all operands
     fit the constraints.  '%' applies to all alternatives and must
     appear as the first character in the constraint.  Only read-only
     operands can use '%'.

     This is often used in patterns for addition instructions that
     really have only two operands: the result must go in one of the
     arguments.  Here for example, is how the 68000 halfword-add
     instruction is defined:

          (define_insn "addhi3"
            [(set (match_operand:HI 0 "general_operand" "=m,r")
               (plus:HI (match_operand:HI 1 "general_operand" "%0,0")
                        (match_operand:HI 2 "general_operand" "di,g")))]
            ...)
     GCC can only handle one commutative pair in an asm; if you use
     more, the compiler may fail.  Note that you need not use the
     modifier if the two alternatives are strictly identical; this would
     only waste time in the reload pass.  The modifier is not
     operational after register allocation, so the result of
     'define_peephole2' and 'define_split's performed after reload
     cannot rely on '%' to make the intended insn match.

'#'
     Says that all following characters, up to the next comma, are to be
     ignored as a constraint.  They are significant only for choosing
     register preferences.

'*'
     Says that the following character should be ignored when choosing
     register preferences.  '*' has no effect on the meaning of the
     constraint as a constraint, and no effect on reloading.  For LRA
     '*' additionally disparages slightly the alternative if the
     following character matches the operand.

     Here is an example: the 68000 has an instruction to sign-extend a
     halfword in a data register, and can also sign-extend a value by
     copying it into an address register.  While either kind of register
     is acceptable, the constraints on an address-register destination
     are less strict, so it is best if register allocation makes an
     address register its goal.  Therefore, '*' is used so that the 'd'
     constraint letter (for data register) is ignored when computing
     register preferences.

          (define_insn "extendhisi2"
            [(set (match_operand:SI 0 "general_operand" "=*d,a")
                  (sign_extend:SI
                   (match_operand:HI 1 "general_operand" "0,g")))]
            ...)

==============================================================================
File: gccint.info,  Node: |Machine_Constraints|,  Next: |Disable_Insn_Alternatives|,  Prev: |Modifiers|,  Up: |Constraints|
==============================================================================

                                                           *Machine_Constraints*

17.8.5 Constraints for Particular Machines
------------------------------------------

Whenever possible, you should use the general-purpose constraint letters
in 'asm' arguments, since they will convey meaning more readily to
people reading your code.  Failing that, use the constraint letters that
usually have very similar meanings across architectures.  The most
commonly used constraints are 'm' and 'r' (for memory and
general-purpose registers respectively; *note Simple Constraints::), and
'I', usually the letter indicating the most common immediate-constant
format.

 Each architecture defines additional constraints.  These constraints
are used by the compiler itself for instruction generation, as well as
for 'asm' statements; therefore, some of the constraints are not
particularly useful for 'asm'.  Here is a summary of some of the
machine-dependent constraints available on some particular machines; it
includes both constraints that are useful for 'asm' and constraints that
aren't.  The compiler source file mentioned in the table heading for
each architecture is the definitive reference for the meanings of that
architecture's constraints.

_AArch64 family--'config/aarch64/constraints.md'_
     'k'
          The stack pointer register ('SP')

     'w'
          Floating point register, Advanced SIMD vector register or SVE
          vector register

     'x'
          Like 'w', but restricted to registers 0 to 15 inclusive.

     'y'
          Like 'w', but restricted to registers 0 to 7 inclusive.

     'Upl'
          One of the low eight SVE predicate registers ('P0' to 'P7')

     'Upa'
          Any of the SVE predicate registers ('P0' to 'P15')

     'I'
          Integer constant that is valid as an immediate operand in an
          'ADD' instruction

     'J'
          Integer constant that is valid as an immediate operand in a
          'SUB' instruction (once negated)

     'K'
          Integer constant that can be used with a 32-bit logical
          instruction

     'L'
          Integer constant that can be used with a 64-bit logical
          instruction

     'M'
          Integer constant that is valid as an immediate operand in a
          32-bit 'MOV' pseudo instruction.  The 'MOV' may be assembled
          to one of several different machine instructions depending on
          the value

     'N'
          Integer constant that is valid as an immediate operand in a
          64-bit 'MOV' pseudo instruction

     'S'
          An absolute symbolic address or a label reference

     'Y'
          Floating point constant zero

     'Z'
          Integer constant zero

     'Ush'
          The high part (bits 12 and upwards) of the pc-relative address
          of a symbol within 4GB of the instruction

     'Q'
          A memory address which uses a single base register with no
          offset

     'Ump'
          A memory address suitable for a load/store pair instruction in
          SI, DI, SF and DF modes

_AMD GCN --'config/gcn/constraints.md'_
     'I'
          Immediate integer in the range -16 to 64

     'J'
          Immediate 16-bit signed integer

     'Kf'
          Immediate constant -1

     'L'
          Immediate 15-bit unsigned integer

     'A'
          Immediate constant that can be inlined in an instruction
          encoding: integer -16..64, or float 0.0, +/-0.5, +/-1.0,
          +/-2.0, +/-4.0, 1.0/(2.0*PI)

     'B'
          Immediate 32-bit signed integer that can be attached to an
          instruction encoding

     'C'
          Immediate 32-bit integer in range -16..4294967295 (i.e.
          32-bit unsigned integer or 'A' constraint)

     'DA'
          Immediate 64-bit constant that can be split into two 'A'
          constants

     'DB'
          Immediate 64-bit constant that can be split into two 'B'
          constants

     'U'
          Any 'unspec'

     'Y'
          Any 'symbol_ref' or 'label_ref'

     'v'
          VGPR register

     'Sg'
          SGPR register

     'SD'
          SGPR registers valid for instruction destinations, including
          VCC, M0 and EXEC

     'SS'
          SGPR registers valid for instruction sources, including VCC,
          M0, EXEC and SCC

     'Sm'
          SGPR registers valid as a source for scalar memory
          instructions (excludes M0 and EXEC)

     'Sv'
          SGPR registers valid as a source or destination for vector
          instructions (excludes EXEC)

     'ca'
          All condition registers: SCC, VCCZ, EXECZ

     'cs'
          Scalar condition register: SCC

     'cV'
          Vector condition register: VCC, VCC_LO, VCC_HI

     'e'
          EXEC register (EXEC_LO and EXEC_HI)

     'RB'
          Memory operand with address space suitable for 'buffer_*'
          instructions

     'RF'
          Memory operand with address space suitable for 'flat_*'
          instructions

     'RS'
          Memory operand with address space suitable for 's_*'
          instructions

     'RL'
          Memory operand with address space suitable for 'ds_*' LDS
          instructions

     'RG'
          Memory operand with address space suitable for 'ds_*' GDS
          instructions

     'RD'
          Memory operand with address space suitable for any 'ds_*'
          instructions

     'RM'
          Memory operand with address space suitable for 'global_*'
          instructions

_ARC --'config/arc/constraints.md'_
     'q'
          Registers usable in ARCompact 16-bit instructions: 'r0'-'r3',
          'r12'-'r15'.  This constraint can only match when the '-mq'
          option is in effect.

     'e'
          Registers usable as base-regs of memory addresses in ARCompact
          16-bit memory instructions: 'r0'-'r3', 'r12'-'r15', 'sp'.
          This constraint can only match when the '-mq' option is in
          effect.
     'D'
          ARC FPX (dpfp) 64-bit registers.  'D0', 'D1'.

     'I'
          A signed 12-bit integer constant.

     'Cal'
          constant for arithmetic/logical operations.  This might be any
          constant that can be put into a long immediate by the assmbler
          or linker without involving a PIC relocation.

     'K'
          A 3-bit unsigned integer constant.

     'L'
          A 6-bit unsigned integer constant.

     'CnL'
          One's complement of a 6-bit unsigned integer constant.

     'CmL'
          Two's complement of a 6-bit unsigned integer constant.

     'M'
          A 5-bit unsigned integer constant.

     'O'
          A 7-bit unsigned integer constant.

     'P'
          A 8-bit unsigned integer constant.

     'H'
          Any const_double value.

_ARM family--'config/arm/constraints.md'_

     'h'
          In Thumb state, the core registers 'r8'-'r15'.

     'k'
          The stack pointer register.

     'l'
          In Thumb State the core registers 'r0'-'r7'.  In ARM state
          this is an alias for the 'r' constraint.

     't'
          VFP floating-point registers 's0'-'s31'.  Used for 32 bit
          values.

     'w'
          VFP floating-point registers 'd0'-'d31' and the appropriate
          subset 'd0'-'d15' based on command line options.  Used for 64
          bit values only.  Not valid for Thumb1.

     'y'
          The iWMMX co-processor registers.

     'z'
          The iWMMX GR registers.

     'G'
          The floating-point constant 0.0

     'I'
          Integer that is valid as an immediate operand in a data
          processing instruction.  That is, an integer in the range 0 to
          255 rotated by a multiple of 2

     'J'
          Integer in the range -4095 to 4095

     'K'
          Integer that satisfies constraint 'I' when inverted (ones
          complement)

     'L'
          Integer that satisfies constraint 'I' when negated (twos
          complement)

     'M'
          Integer in the range 0 to 32

     'Q'
          A memory reference where the exact address is in a single
          register (''m'' is preferable for 'asm' statements)

     'R'
          An item in the constant pool

     'S'
          A symbol in the text segment of the current file

     'Uv'
          A memory reference suitable for VFP load/store insns
          (reg+constant offset)

     'Uy'
          A memory reference suitable for iWMMXt load/store
          instructions.

     'Uq'
          A memory reference suitable for the ARMv4 ldrsb instruction.

_AVR family--'config/avr/constraints.md'_
     'l'
          Registers from r0 to r15

     'a'
          Registers from r16 to r23

     'd'
          Registers from r16 to r31

     'w'
          Registers from r24 to r31.  These registers can be used in
          'adiw' command

     'e'
          Pointer register (r26-r31)

     'b'
          Base pointer register (r28-r31)

     'q'
          Stack pointer register (SPH:SPL)

     't'
          Temporary register r0

     'x'
          Register pair X (r27:r26)

     'y'
          Register pair Y (r29:r28)

     'z'
          Register pair Z (r31:r30)

     'I'
          Constant greater than -1, less than 64

     'J'
          Constant greater than -64, less than 1

     'K'
          Constant integer 2

     'L'
          Constant integer 0

     'M'
          Constant that fits in 8 bits

     'N'
          Constant integer -1

     'O'
          Constant integer 8, 16, or 24

     'P'
          Constant integer 1

     'G'
          A floating point constant 0.0

     'Q'
          A memory address based on Y or Z pointer with displacement.

_Blackfin family--'config/bfin/constraints.md'_
     'a'
          P register

     'd'
          D register

     'z'
          A call clobbered P register.

     'qN'
          A single register.  If N is in the range 0 to 7, the
          corresponding D register.  If it is 'A', then the register P0.

     'D'
          Even-numbered D register

     'W'
          Odd-numbered D register

     'e'
          Accumulator register.

     'A'
          Even-numbered accumulator register.

     'B'
          Odd-numbered accumulator register.

     'b'
          I register

     'v'
          B register

     'f'
          M register

     'c'
          Registers used for circular buffering, i.e. I, B, or L
          registers.

     'C'
          The CC register.

     't'
          LT0 or LT1.

     'k'
          LC0 or LC1.

     'u'
          LB0 or LB1.

     'x'
          Any D, P, B, M, I or L register.

     'y'
          Additional registers typically used only in prologues and
          epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and
          USP.

     'w'
          Any register except accumulators or CC.

     'Ksh'
          Signed 16 bit integer (in the range -32768 to 32767)

     'Kuh'
          Unsigned 16 bit integer (in the range 0 to 65535)

     'Ks7'
          Signed 7 bit integer (in the range -64 to 63)

     'Ku7'
          Unsigned 7 bit integer (in the range 0 to 127)

     'Ku5'
          Unsigned 5 bit integer (in the range 0 to 31)

     'Ks4'
          Signed 4 bit integer (in the range -8 to 7)

     'Ks3'
          Signed 3 bit integer (in the range -3 to 4)

     'Ku3'
          Unsigned 3 bit integer (in the range 0 to 7)

     'PN'
          Constant N, where N is a single-digit constant in the range 0
          to 4.

     'PA'
          An integer equal to one of the MACFLAG_XXX constants that is
          suitable for use with either accumulator.

     'PB'
          An integer equal to one of the MACFLAG_XXX constants that is
          suitable for use only with accumulator A1.

     'M1'
          Constant 255.

     'M2'
          Constant 65535.

     'J'
          An integer constant with exactly a single bit set.

     'L'
          An integer constant with all bits set except exactly one.

     'H'

     'Q'
          Any SYMBOL_REF.

_CR16 Architecture--'config/cr16/cr16.h'_

     'b'
          Registers from r0 to r14 (registers without stack pointer)

     't'
          Register from r0 to r11 (all 16-bit registers)

     'p'
          Register from r12 to r15 (all 32-bit registers)

     'I'
          Signed constant that fits in 4 bits

     'J'
          Signed constant that fits in 5 bits

     'K'
          Signed constant that fits in 6 bits

     'L'
          Unsigned constant that fits in 4 bits

     'M'
          Signed constant that fits in 32 bits

     'N'
          Check for 64 bits wide constants for add/sub instructions

     'G'
          Floating point constant that is legal for store immediate

_C-SKY--'config/csky/constraints.md'_

     'a'
          The mini registers r0 - r7.

     'b'
          The low registers r0 - r15.

     'c'
          C register.

     'y'
          HI and LO registers.

     'l'
          LO register.

     'h'
          HI register.

     'v'
          Vector registers.

     'z'
          Stack pointer register (SP).

     The C-SKY back end supports a large set of additional constraints
     that are only useful for instruction selection or splitting rather
     than inline asm, such as constraints representing constant integer
     ranges accepted by particular instruction encodings.  Refer to the
     source code for details.

_Epiphany--'config/epiphany/constraints.md'_
     'U16'
          An unsigned 16-bit constant.

     'K'
          An unsigned 5-bit constant.

     'L'
          A signed 11-bit constant.

     'Cm1'
          A signed 11-bit constant added to -1.  Can only match when the
          '-m1reg-REG' option is active.

     'Cl1'
          Left-shift of -1, i.e., a bit mask with a block of leading
          ones, the rest being a block of trailing zeroes.  Can only
          match when the '-m1reg-REG' option is active.

     'Cr1'
          Right-shift of -1, i.e., a bit mask with a trailing block of
          ones, the rest being zeroes.  Or to put it another way, one
          less than a power of two.  Can only match when the
          '-m1reg-REG' option is active.

     'Cal'
          Constant for arithmetic/logical operations.  This is like 'i',
          except that for position independent code, no symbols /
          expressions needing relocations are allowed.

     'Csy'
          Symbolic constant for call/jump instruction.

     'Rcs'
          The register class usable in short insns.  This is a register
          class constraint, and can thus drive register allocation.
          This constraint won't match unless '-mprefer-short-insn-regs'
          is in effect.

     'Rsc'
          The the register class of registers that can be used to hold a
          sibcall call address.  I.e., a caller-saved register.

     'Rct'
          Core control register class.

     'Rgs'
          The register group usable in short insns.  This constraint
          does not use a register class, so that it only passively
          matches suitable registers, and doesn't drive register
          allocation.

     'Car'
          Constant suitable for the addsi3_r pattern.  This is a valid
          offset For byte, halfword, or word addressing.

     'Rra'
          Matches the return address if it can be replaced with the link
          register.

     'Rcc'
          Matches the integer condition code register.

     'Sra'
          Matches the return address if it is in a stack slot.

     'Cfm'
          Matches control register values to switch fp mode, which are
          encapsulated in 'UNSPEC_FP_MODE'.

_FRV--'config/frv/frv.h'_
     'a'
          Register in the class 'ACC_REGS' ('acc0' to 'acc7').

     'b'
          Register in the class 'EVEN_ACC_REGS' ('acc0' to 'acc7').

     'c'
          Register in the class 'CC_REGS' ('fcc0' to 'fcc3' and 'icc0'
          to 'icc3').

     'd'
          Register in the class 'GPR_REGS' ('gr0' to 'gr63').

     'e'
          Register in the class 'EVEN_REGS' ('gr0' to 'gr63').  Odd
          registers are excluded not in the class but through the use of
          a machine mode larger than 4 bytes.

     'f'
          Register in the class 'FPR_REGS' ('fr0' to 'fr63').

     'h'
          Register in the class 'FEVEN_REGS' ('fr0' to 'fr63').  Odd
          registers are excluded not in the class but through the use of
          a machine mode larger than 4 bytes.

     'l'
          Register in the class 'LR_REG' (the 'lr' register).

     'q'
          Register in the class 'QUAD_REGS' ('gr2' to 'gr63').  Register
          numbers not divisible by 4 are excluded not in the class but
          through the use of a machine mode larger than 8 bytes.

     't'
          Register in the class 'ICC_REGS' ('icc0' to 'icc3').

     'u'
          Register in the class 'FCC_REGS' ('fcc0' to 'fcc3').

     'v'
          Register in the class 'ICR_REGS' ('cc4' to 'cc7').

     'w'
          Register in the class 'FCR_REGS' ('cc0' to 'cc3').

     'x'
          Register in the class 'QUAD_FPR_REGS' ('fr0' to 'fr63').
          Register numbers not divisible by 4 are excluded not in the
          class but through the use of a machine mode larger than 8
          bytes.

     'z'
          Register in the class 'SPR_REGS' ('lcr' and 'lr').

     'A'
          Register in the class 'QUAD_ACC_REGS' ('acc0' to 'acc7').

     'B'
          Register in the class 'ACCG_REGS' ('accg0' to 'accg7').

     'C'
          Register in the class 'CR_REGS' ('cc0' to 'cc7').

     'G'
          Floating point constant zero

     'I'
          6-bit signed integer constant

     'J'
          10-bit signed integer constant

     'L'
          16-bit signed integer constant

     'M'
          16-bit unsigned integer constant

     'N'
          12-bit signed integer constant that is negative--i.e. in the
          range of -2048 to -1

     'O'
          Constant zero

     'P'
          12-bit signed integer constant that is greater than zero--i.e.
          in the range of 1 to 2047.

_FT32--'config/ft32/constraints.md'_
     'A'
          An absolute address

     'B'
          An offset address

     'W'
          A register indirect memory operand

     'e'
          An offset address.

     'f'
          An offset address.

     'O'
          The constant zero or one

     'I'
          A 16-bit signed constant (-32768 ... 32767)

     'w'
          A bitfield mask suitable for bext or bins

     'x'
          An inverted bitfield mask suitable for bext or bins

     'L'
          A 16-bit unsigned constant, multiple of 4 (0 ... 65532)

     'S'
          A 20-bit signed constant (-524288 ... 524287)

     'b'
          A constant for a bitfield width (1 ... 16)

     'KA'
          A 10-bit signed constant (-512 ... 511)

_Hewlett-Packard PA-RISC--'config/pa/pa.h'_
     'a'
          General register 1

     'f'
          Floating point register

     'q'
          Shift amount register

     'x'
          Floating point register (deprecated)

     'y'
          Upper floating point register (32-bit), floating point
          register (64-bit)

     'Z'
          Any register

     'I'
          Signed 11-bit integer constant

     'J'
          Signed 14-bit integer constant

     'K'
          Integer constant that can be deposited with a 'zdepi'
          instruction

     'L'
          Signed 5-bit integer constant

     'M'
          Integer constant 0

     'N'
          Integer constant that can be loaded with a 'ldil' instruction

     'O'
          Integer constant whose value plus one is a power of 2

     'P'
          Integer constant that can be used for 'and' operations in
          'depi' and 'extru' instructions

     'S'
          Integer constant 31

     'U'
          Integer constant 63

     'G'
          Floating-point constant 0.0

     'A'
          A 'lo_sum' data-linkage-table memory operand

     'Q'
          A memory operand that can be used as the destination operand
          of an integer store instruction

     'R'
          A scaled or unscaled indexed memory operand

     'T'
          A memory operand for floating-point loads and stores

     'W'
          A register indirect memory operand

_Intel IA-64--'config/ia64/ia64.h'_
     'a'
          General register 'r0' to 'r3' for 'addl' instruction

     'b'
          Branch register

     'c'
          Predicate register ('c' as in "conditional")

     'd'
          Application register residing in M-unit

     'e'
          Application register residing in I-unit

     'f'
          Floating-point register

     'm'
          Memory operand.  If used together with '<' or '>', the operand
          can have postincrement and postdecrement which require
          printing with '%Pn' on IA-64.

     'G'
          Floating-point constant 0.0 or 1.0

     'I'
          14-bit signed integer constant

     'J'
          22-bit signed integer constant

     'K'
          8-bit signed integer constant for logical instructions

     'L'
          8-bit adjusted signed integer constant for compare pseudo-ops

     'M'
          6-bit unsigned integer constant for shift counts

     'N'
          9-bit signed integer constant for load and store
          postincrements

     'O'
          The constant zero

     'P'
          0 or -1 for 'dep' instruction

     'Q'
          Non-volatile memory for floating-point loads and stores

     'R'
          Integer constant in the range 1 to 4 for 'shladd' instruction

     'S'
          Memory operand except postincrement and postdecrement.  This
          is now roughly the same as 'm' when not used together with '<'
          or '>'.

_M32C--'config/m32c/m32c.c'_
     'Rsp'
     'Rfb'
     'Rsb'
          '$sp', '$fb', '$sb'.

     'Rcr'
          Any control register, when they're 16 bits wide (nothing if
          control registers are 24 bits wide)

     'Rcl'
          Any control register, when they're 24 bits wide.

     'R0w'
     'R1w'
     'R2w'
     'R3w'
          $r0, $r1, $r2, $r3.

     'R02'
          $r0 or $r2, or $r2r0 for 32 bit values.

     'R13'
          $r1 or $r3, or $r3r1 for 32 bit values.

     'Rdi'
          A register that can hold a 64 bit value.

     'Rhl'
          $r0 or $r1 (registers with addressable high/low bytes)

     'R23'
          $r2 or $r3

     'Raa'
          Address registers

     'Raw'
          Address registers when they're 16 bits wide.

     'Ral'
          Address registers when they're 24 bits wide.

     'Rqi'
          Registers that can hold QI values.

     'Rad'
          Registers that can be used with displacements ($a0, $a1, $sb).

     'Rsi'
          Registers that can hold 32 bit values.

     'Rhi'
          Registers that can hold 16 bit values.

     'Rhc'
          Registers chat can hold 16 bit values, including all control
          registers.

     'Rra'
          $r0 through R1, plus $a0 and $a1.

     'Rfl'
          The flags register.

     'Rmm'
          The memory-based pseudo-registers $mem0 through $mem15.

     'Rpi'
          Registers that can hold pointers (16 bit registers for r8c,
          m16c; 24 bit registers for m32cm, m32c).

     'Rpa'
          Matches multiple registers in a PARALLEL to form a larger
          register.  Used to match function return values.

     'Is3'
          -8 ... 7

     'IS1'
          -128 ... 127

     'IS2'
          -32768 ... 32767

     'IU2'
          0 ... 65535

     'In4'
          -8 ... -1 or 1 ... 8

     'In5'
          -16 ... -1 or 1 ... 16

     'In6'
          -32 ... -1 or 1 ... 32

     'IM2'
          -65536 ... -1

     'Ilb'
          An 8 bit value with exactly one bit set.

     'Ilw'
          A 16 bit value with exactly one bit set.

     'Sd'
          The common src/dest memory addressing modes.

     'Sa'
          Memory addressed using $a0 or $a1.

     'Si'
          Memory addressed with immediate addresses.

     'Ss'
          Memory addressed using the stack pointer ($sp).

     'Sf'
          Memory addressed using the frame base register ($fb).

     'Ss'
          Memory addressed using the small base register ($sb).

     'S1'
          $r1h

_MicroBlaze--'config/microblaze/constraints.md'_
     'd'
          A general register ('r0' to 'r31').

     'z'
          A status register ('rmsr', '$fcc1' to '$fcc7').

_MIPS--'config/mips/constraints.md'_
     'd'
          A general-purpose register.  This is equivalent to 'r' unless
          generating MIPS16 code, in which case the MIPS16 register set
          is used.

     'f'
          A floating-point register (if available).

     'h'
          Formerly the 'hi' register.  This constraint is no longer
          supported.

     'l'
          The 'lo' register.  Use this register to store values that are
          no bigger than a word.

     'x'
          The concatenated 'hi' and 'lo' registers.  Use this register
          to store doubleword values.

     'c'
          A register suitable for use in an indirect jump.  This will
          always be '$25' for '-mabicalls'.

     'v'
          Register '$3'.  Do not use this constraint in new code; it is
          retained only for compatibility with glibc.

     'y'
          Equivalent to 'r'; retained for backwards compatibility.

     'z'
          A floating-point condition code register.

     'I'
          A signed 16-bit constant (for arithmetic instructions).

     'J'
          Integer zero.

     'K'
          An unsigned 16-bit constant (for logic instructions).

     'L'
          A signed 32-bit constant in which the lower 16 bits are zero.
          Such constants can be loaded using 'lui'.

     'M'
          A constant that cannot be loaded using 'lui', 'addiu' or
          'ori'.

     'N'
          A constant in the range -65535 to -1 (inclusive).

     'O'
          A signed 15-bit constant.

     'P'
          A constant in the range 1 to 65535 (inclusive).

     'G'
          Floating-point zero.

     'R'
          An address that can be used in a non-macro load or store.

     'ZC'
          A memory operand whose address is formed by a base register
          and offset that is suitable for use in instructions with the
          same addressing mode as 'll' and 'sc'.

     'ZD'
          An address suitable for a 'prefetch' instruction, or for any
          other instruction with the same addressing mode as 'prefetch'.

_Motorola 680x0--'config/m68k/constraints.md'_
     'a'
          Address register

     'd'
          Data register

     'f'
          68881 floating-point register, if available

     'I'
          Integer in the range 1 to 8

     'J'
          16-bit signed number

     'K'
          Signed number whose magnitude is greater than 0x80

     'L'
          Integer in the range -8 to -1

     'M'
          Signed number whose magnitude is greater than 0x100

     'N'
          Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate

     'O'
          16 (for rotate using swap)

     'P'
          Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate

     'R'
          Numbers that mov3q can handle

     'G'
          Floating point constant that is not a 68881 constant

     'S'
          Operands that satisfy 'm' when -mpcrel is in effect

     'T'
          Operands that satisfy 's' when -mpcrel is not in effect

     'Q'
          Address register indirect addressing mode

     'U'
          Register offset addressing

     'W'
          const_call_operand

     'Cs'
          symbol_ref or const

     'Ci'
          const_int

     'C0'
          const_int 0

     'Cj'
          Range of signed numbers that don't fit in 16 bits

     'Cmvq'
          Integers valid for mvq

     'Capsw'
          Integers valid for a moveq followed by a swap

     'Cmvz'
          Integers valid for mvz

     'Cmvs'
          Integers valid for mvs

     'Ap'
          push_operand

     'Ac'
          Non-register operands allowed in clr

_Moxie--'config/moxie/constraints.md'_
     'A'
          An absolute address

     'B'
          An offset address

     'W'
          A register indirect memory operand

     'I'
          A constant in the range of 0 to 255.

     'N'
          A constant in the range of 0 to -255.

_MSP430-'config/msp430/constraints.md'_

     'R12'
          Register R12.

     'R13'
          Register R13.

     'K'
          Integer constant 1.

     'L'
          Integer constant -1^20..1^19.

     'M'
          Integer constant 1-4.

     'Ya'
          Memory references which do not require an extended MOVX
          instruction.

     'Yl'
          Memory reference, labels only.

     'Ys'
          Memory reference, stack only.

_NDS32--'config/nds32/constraints.md'_
     'w'
          LOW register class $r0 to $r7 constraint for V3/V3M ISA.
     'l'
          LOW register class $r0 to $r7.
     'd'
          MIDDLE register class $r0 to $r11, $r16 to $r19.
     'h'
          HIGH register class $r12 to $r14, $r20 to $r31.
     't'
          Temporary assist register $ta (i.e. $r15).
     'k'
          Stack register $sp.
     'Iu03'
          Unsigned immediate 3-bit value.
     'In03'
          Negative immediate 3-bit value in the range of -7-0.
     'Iu04'
          Unsigned immediate 4-bit value.
     'Is05'
          Signed immediate 5-bit value.
     'Iu05'
          Unsigned immediate 5-bit value.
     'In05'
          Negative immediate 5-bit value in the range of -31-0.
     'Ip05'
          Unsigned immediate 5-bit value for movpi45 instruction with
          range 16-47.
     'Iu06'
          Unsigned immediate 6-bit value constraint for addri36.sp
          instruction.
     'Iu08'
          Unsigned immediate 8-bit value.
     'Iu09'
          Unsigned immediate 9-bit value.
     'Is10'
          Signed immediate 10-bit value.
     'Is11'
          Signed immediate 11-bit value.
     'Is15'
          Signed immediate 15-bit value.
     'Iu15'
          Unsigned immediate 15-bit value.
     'Ic15'
          A constant which is not in the range of imm15u but ok for bclr
          instruction.
     'Ie15'
          A constant which is not in the range of imm15u but ok for bset
          instruction.
     'It15'
          A constant which is not in the range of imm15u but ok for btgl
          instruction.
     'Ii15'
          A constant whose compliment value is in the range of imm15u
          and ok for bitci instruction.
     'Is16'
          Signed immediate 16-bit value.
     'Is17'
          Signed immediate 17-bit value.
     'Is19'
          Signed immediate 19-bit value.
     'Is20'
          Signed immediate 20-bit value.
     'Ihig'
          The immediate value that can be simply set high 20-bit.
     'Izeb'
          The immediate value 0xff.
     'Izeh'
          The immediate value 0xffff.
     'Ixls'
          The immediate value 0x01.
     'Ix11'
          The immediate value 0x7ff.
     'Ibms'
          The immediate value with power of 2.
     'Ifex'
          The immediate value with power of 2 minus 1.
     'U33'
          Memory constraint for 333 format.
     'U45'
          Memory constraint for 45 format.
     'U37'
          Memory constraint for 37 format.

_Nios II family--'config/nios2/constraints.md'_

     'I'
          Integer that is valid as an immediate operand in an
          instruction taking a signed 16-bit number.  Range -32768 to
          32767.

     'J'
          Integer that is valid as an immediate operand in an
          instruction taking an unsigned 16-bit number.  Range 0 to
          65535.

     'K'
          Integer that is valid as an immediate operand in an
          instruction taking only the upper 16-bits of a 32-bit number.
          Range 32-bit numbers with the lower 16-bits being 0.

     'L'
          Integer that is valid as an immediate operand for a shift
          instruction.  Range 0 to 31.

     'M'
          Integer that is valid as an immediate operand for only the
          value 0.  Can be used in conjunction with the format modifier
          'z' to use 'r0' instead of '0' in the assembly output.

     'N'
          Integer that is valid as an immediate operand for a custom
          instruction opcode.  Range 0 to 255.

     'P'
          An immediate operand for R2 andchi/andci instructions.

     'S'
          Matches immediates which are addresses in the small data
          section and therefore can be added to 'gp' as a 16-bit
          immediate to re-create their 32-bit value.

     'U'
          Matches constants suitable as an operand for the rdprs and
          cache instructions.

     'v'
          A memory operand suitable for Nios II R2 load/store exclusive
          instructions.

     'w'
          A memory operand suitable for load/store IO and cache
          instructions.

     'T'
          A 'const' wrapped 'UNSPEC' expression, representing a
          supported PIC or TLS relocation.

_OpenRISC--'config/or1k/constraints.md'_
     'I'
          Integer that is valid as an immediate operand in an
          instruction taking a signed 16-bit number.  Range -32768 to
          32767.

     'K'
          Integer that is valid as an immediate operand in an
          instruction taking an unsigned 16-bit number.  Range 0 to
          65535.

     'M'
          Signed 16-bit constant shifted left 16 bits.  (Used with
          'l.movhi')

     'O'
          Zero

     'c'
          Register usable for sibcalls.

_PDP-11--'config/pdp11/constraints.md'_
     'a'
          Floating point registers AC0 through AC3.  These can be loaded
          from/to memory with a single instruction.

     'd'
          Odd numbered general registers (R1, R3, R5).  These are used
          for 16-bit multiply operations.

     'D'
          A memory reference that is encoded within the opcode, but not
          auto-increment or auto-decrement.

     'f'
          Any of the floating point registers (AC0 through AC5).

     'G'
          Floating point constant 0.

     'h'
          Floating point registers AC4 and AC5.  These cannot be loaded
          from/to memory with a single instruction.

     'I'
          An integer constant that fits in 16 bits.

     'J'
          An integer constant whose low order 16 bits are zero.

     'K'
          An integer constant that does not meet the constraints for
          codes 'I' or 'J'.

     'L'
          The integer constant 1.

     'M'
          The integer constant -1.

     'N'
          The integer constant 0.

     'O'
          Integer constants 0 through 3; shifts by these amounts are
          handled as multiple single-bit shifts rather than a single
          variable-length shift.

     'Q'
          A memory reference which requires an additional word (address
          or offset) after the opcode.

     'R'
          A memory reference that is encoded within the opcode.

_PowerPC and IBM RS6000--'config/rs6000/constraints.md'_
     'r'
          A general purpose register (GPR), 'r0'...'r31'.

     'b'
          A base register.  Like 'r', but 'r0' is not allowed, so
          'r1'...'r31'.

     'f'
          A floating point register (FPR), 'f0'...'f31'.

     'd'
          A floating point register.  This is the same as 'f' nowadays;
          historically 'f' was for single-precision and 'd' was for
          double-precision floating point.

     'v'
          An Altivec vector register (VR), 'v0'...'v31'.

     'wa'
          A VSX register (VSR), 'vs0'...'vs63'.  This is either an FPR
          ('vs0'...'vs31' are 'f0'...'f31') or a VR ('vs32'...'vs63' are
          'v0'...'v31').

          When using 'wa', you should use the '%x' output modifier, so
          that the correct register number is printed.  For example:

               asm ("xvadddp %x0,%x1,%x2"
                    : "=wa" (v1)
                    : "wa" (v2), "wa" (v3));

          You should not use '%x' for 'v' operands:

               asm ("xsaddqp %0,%1,%2"
                    : "=v" (v1)
                    : "v" (v2), "v" (v3));

     'h'
          A special register ('vrsave', 'ctr', or 'lr').

     'c'
          The count register, 'ctr'.

     'l'
          The link register, 'lr'.

     'x'
          Condition register field 0, 'cr0'.

     'y'
          Any condition register field, 'cr0'...'cr7'.

     'z'
          The carry bit, 'XER[CA]'.

     'we'
          Like 'wa', if '-mpower9-vector' and '-m64' are used;
          otherwise, 'NO_REGS'.

     'wn'
          No register ('NO_REGS').

     'wr'
          Like 'r', if '-mpowerpc64' is used; otherwise, 'NO_REGS'.

     'wx'
          Like 'd', if '-mpowerpc-gfxopt' is used; otherwise, 'NO_REGS'.

     'wA'
          Like 'b', if '-mpowerpc64' is used; otherwise, 'NO_REGS'.

     'wB'
          Signed 5-bit constant integer that can be loaded into an
          Altivec register.

     'wD'
          Int constant that is the element number of the 64-bit scalar
          in a vector.

     'wE'
          Vector constant that can be loaded with the XXSPLTIB
          instruction.

     'wF'
          Memory operand suitable for power8 GPR load fusion.

     'wL'
          Int constant that is the element number mfvsrld accesses in a
          vector.

     'wM'
          Match vector constant with all 1's if the XXLORC instruction
          is available.

     'wO'
          Memory operand suitable for the ISA 3.0 vector d-form
          instructions.

     'wQ'
          Memory operand suitable for the load/store quad instructions.

     'wS'
          Vector constant that can be loaded with XXSPLTIB & sign
          extension.

     'wY'
          A memory operand for a DS-form instruction.

     'wZ'
          An indexed or indirect memory operand, ignoring the bottom 4
          bits.

     'I'
          A signed 16-bit constant.

     'J'
          An unsigned 16-bit constant shifted left 16 bits (use 'L'
          instead for 'SImode' constants).

     'K'
          An unsigned 16-bit constant.

     'L'
          A signed 16-bit constant shifted left 16 bits.

     'M'
          An integer constant greater than 31.

     'N'
          An exact power of 2.

     'O'
          The integer constant zero.

     'P'
          A constant whose negation is a signed 16-bit constant.

     'eI'
          A signed 34-bit integer constant if prefixed instructions are
          supported.

     'G'
          A floating point constant that can be loaded into a register
          with one instruction per word.

     'H'
          A floating point constant that can be loaded into a register
          using three instructions.

     'm'
          A memory operand.  Normally, 'm' does not allow addresses that
          update the base register.  If the '<' or '>' constraint is
          also used, they are allowed and therefore on PowerPC targets
          in that case it is only safe to use 'm<>' in an 'asm'
          statement if that 'asm' statement accesses the operand exactly
          once.  The 'asm' statement must also use '%U<OPNO>' as a
          placeholder for the "update" flag in the corresponding load or
          store instruction.  For example:

               asm ("st%U0 %1,%0" : "=m<>" (mem) : "r" (val));

          is correct but:

               asm ("st %1,%0" : "=m<>" (mem) : "r" (val));

          is not.

     'es'
          A "stable" memory operand; that is, one which does not include
          any automodification of the base register.  This used to be
          useful when 'm' allowed automodification of the base register,
          but as those are now only allowed when '<' or '>' is used,
          'es' is basically the same as 'm' without '<' and '>'.

     'Q'
          A memory operand addressed by just a base register.

     'Y'
          A memory operand for a DQ-form instruction.

     'Z'
          A memory operand accessed with indexed or indirect addressing.

     'R'
          An AIX TOC entry.

     'a'
          An indexed or indirect address.

     'U'
          A V.4 small data reference.

     'W'
          A vector constant that does not require memory.

     'j'
          The zero vector constant.

_PRU--'config/pru/constraints.md'_
     'I'
          An unsigned 8-bit integer constant.

     'J'
          An unsigned 16-bit integer constant.

     'L'
          An unsigned 5-bit integer constant (for shift counts).

     'T'
          A text segment (program memory) constant label.

     'Z'
          Integer constant zero.

_RL78--'config/rl78/constraints.md'_

     'Int3'
          An integer constant in the range 1 ... 7.
     'Int8'
          An integer constant in the range 0 ... 255.
     'J'
          An integer constant in the range -255 ... 0
     'K'
          The integer constant 1.
     'L'
          The integer constant -1.
     'M'
          The integer constant 0.
     'N'
          The integer constant 2.
     'O'
          The integer constant -2.
     'P'
          An integer constant in the range 1 ... 15.
     'Qbi'
          The built-in compare types-eq, ne, gtu, ltu, geu, and leu.
     'Qsc'
          The synthetic compare types-gt, lt, ge, and le.
     'Wab'
          A memory reference with an absolute address.
     'Wbc'
          A memory reference using 'BC' as a base register, with an
          optional offset.
     'Wca'
          A memory reference using 'AX', 'BC', 'DE', or 'HL' for the
          address, for calls.
     'Wcv'
          A memory reference using any 16-bit register pair for the
          address, for calls.
     'Wd2'
          A memory reference using 'DE' as a base register, with an
          optional offset.
     'Wde'
          A memory reference using 'DE' as a base register, without any
          offset.
     'Wfr'
          Any memory reference to an address in the far address space.
     'Wh1'
          A memory reference using 'HL' as a base register, with an
          optional one-byte offset.
     'Whb'
          A memory reference using 'HL' as a base register, with 'B' or
          'C' as the index register.
     'Whl'
          A memory reference using 'HL' as a base register, without any
          offset.
     'Ws1'
          A memory reference using 'SP' as a base register, with an
          optional one-byte offset.
     'Y'
          Any memory reference to an address in the near address space.
     'A'
          The 'AX' register.
     'B'
          The 'BC' register.
     'D'
          The 'DE' register.
     'R'
          'A' through 'L' registers.
     'S'
          The 'SP' register.
     'T'
          The 'HL' register.
     'Z08W'
          The 16-bit 'R8' register.
     'Z10W'
          The 16-bit 'R10' register.
     'Zint'
          The registers reserved for interrupts ('R24' to 'R31').
     'a'
          The 'A' register.
     'b'
          The 'B' register.
     'c'
          The 'C' register.
     'd'
          The 'D' register.
     'e'
          The 'E' register.
     'h'
          The 'H' register.
     'l'
          The 'L' register.
     'v'
          The virtual registers.
     'w'
          The 'PSW' register.
     'x'
          The 'X' register.

_RISC-V--'config/riscv/constraints.md'_

     'f'
          A floating-point register (if available).

     'I'
          An I-type 12-bit signed immediate.

     'J'
          Integer zero.

     'K'
          A 5-bit unsigned immediate for CSR access instructions.

     'A'
          An address that is held in a general-purpose register.

_RX--'config/rx/constraints.md'_
     'Q'
          An address which does not involve register indirect addressing
          or pre/post increment/decrement addressing.

     'Symbol'
          A symbol reference.

     'Int08'
          A constant in the range -256 to 255, inclusive.

     'Sint08'
          A constant in the range -128 to 127, inclusive.

     'Sint16'
          A constant in the range -32768 to 32767, inclusive.

     'Sint24'
          A constant in the range -8388608 to 8388607, inclusive.

     'Uint04'
          A constant in the range 0 to 15, inclusive.

_S/390 and zSeries--'config/s390/s390.h'_
     'a'
          Address register (general purpose register except r0)

     'c'
          Condition code register

     'd'
          Data register (arbitrary general purpose register)

     'f'
          Floating-point register

     'I'
          Unsigned 8-bit constant (0-255)

     'J'
          Unsigned 12-bit constant (0-4095)

     'K'
          Signed 16-bit constant (-32768-32767)

     'L'
          Value appropriate as displacement.
          '(0..4095)'
               for short displacement
          '(-524288..524287)'
               for long displacement

     'M'
          Constant integer with a value of 0x7fffffff.

     'N'
          Multiple letter constraint followed by 4 parameter letters.
          '0..9:'
               number of the part counting from most to least
               significant
          'H,Q:'
               mode of the part
          'D,S,H:'
               mode of the containing operand
          '0,F:'
               value of the other parts (F--all bits set)
          The constraint matches if the specified part of a constant has
          a value different from its other parts.

     'Q'
          Memory reference without index register and with short
          displacement.

     'R'
          Memory reference with index register and short displacement.

     'S'
          Memory reference without index register but with long
          displacement.

     'T'
          Memory reference with index register and long displacement.

     'U'
          Pointer with short displacement.

     'W'
          Pointer with long displacement.

     'Y'
          Shift count operand.

_SPARC--'config/sparc/sparc.h'_
     'f'
          Floating-point register on the SPARC-V8 architecture and lower
          floating-point register on the SPARC-V9 architecture.

     'e'
          Floating-point register.  It is equivalent to 'f' on the
          SPARC-V8 architecture and contains both lower and upper
          floating-point registers on the SPARC-V9 architecture.

     'c'
          Floating-point condition code register.

     'd'
          Lower floating-point register.  It is only valid on the
          SPARC-V9 architecture when the Visual Instruction Set is
          available.

     'b'
          Floating-point register.  It is only valid on the SPARC-V9
          architecture when the Visual Instruction Set is available.

     'h'
          64-bit global or out register for the SPARC-V8+ architecture.

     'C'
          The constant all-ones, for floating-point.

     'A'
          Signed 5-bit constant

     'D'
          A vector constant

     'I'
          Signed 13-bit constant

     'J'
          Zero

     'K'
          32-bit constant with the low 12 bits clear (a constant that
          can be loaded with the 'sethi' instruction)

     'L'
          A constant in the range supported by 'movcc' instructions
          (11-bit signed immediate)

     'M'
          A constant in the range supported by 'movrcc' instructions
          (10-bit signed immediate)

     'N'
          Same as 'K', except that it verifies that bits that are not in
          the lower 32-bit range are all zero.  Must be used instead of
          'K' for modes wider than 'SImode'

     'O'
          The constant 4096

     'G'
          Floating-point zero

     'H'
          Signed 13-bit constant, sign-extended to 32 or 64 bits

     'P'
          The constant -1

     'Q'
          Floating-point constant whose integral representation can be
          moved into an integer register using a single sethi
          instruction

     'R'
          Floating-point constant whose integral representation can be
          moved into an integer register using a single mov instruction

     'S'
          Floating-point constant whose integral representation can be
          moved into an integer register using a high/lo_sum instruction
          sequence

     'T'
          Memory address aligned to an 8-byte boundary

     'U'
          Even register

     'W'
          Memory address for 'e' constraint registers

     'w'
          Memory address with only a base register

     'Y'
          Vector zero

_TI C6X family--'config/c6x/constraints.md'_
     'a'
          Register file A (A0-A31).

     'b'
          Register file B (B0-B31).

     'A'
          Predicate registers in register file A (A0-A2 on C64X and
          higher, A1 and A2 otherwise).

     'B'
          Predicate registers in register file B (B0-B2).

     'C'
          A call-used register in register file B (B0-B9, B16-B31).

     'Da'
          Register file A, excluding predicate registers (A3-A31, plus
          A0 if not C64X or higher).

     'Db'
          Register file B, excluding predicate registers (B3-B31).

     'Iu4'
          Integer constant in the range 0 ... 15.

     'Iu5'
          Integer constant in the range 0 ... 31.

     'In5'
          Integer constant in the range -31 ... 0.

     'Is5'
          Integer constant in the range -16 ... 15.

     'I5x'
          Integer constant that can be the operand of an ADDA or a SUBA
          insn.

     'IuB'
          Integer constant in the range 0 ... 65535.

     'IsB'
          Integer constant in the range -32768 ... 32767.

     'IsC'
          Integer constant in the range -2^{20} ... 2^{20} - 1.

     'Jc'
          Integer constant that is a valid mask for the clr instruction.

     'Js'
          Integer constant that is a valid mask for the set instruction.

     'Q'
          Memory location with A base register.

     'R'
          Memory location with B base register.

     'S0'
          On C64x+ targets, a GP-relative small data reference.

     'S1'
          Any kind of 'SYMBOL_REF', for use in a call address.

     'Si'
          Any kind of immediate operand, unless it matches the S0
          constraint.

     'T'
          Memory location with B base register, but not using a long
          offset.

     'W'
          A memory operand with an address that cannot be used in an
          unaligned access.

     'Z'
          Register B14 (aka DP).

_TILE-Gx--'config/tilegx/constraints.md'_
     'R00'
     'R01'
     'R02'
     'R03'
     'R04'
     'R05'
     'R06'
     'R07'
     'R08'
     'R09'
     'R10'
          Each of these represents a register constraint for an
          individual register, from r0 to r10.

     'I'
          Signed 8-bit integer constant.

     'J'
          Signed 16-bit integer constant.

     'K'
          Unsigned 16-bit integer constant.

     'L'
          Integer constant that fits in one signed byte when incremented
          by one (-129 ... 126).

     'm'
          Memory operand.  If used together with '<' or '>', the operand
          can have postincrement which requires printing with '%In' and
          '%in' on TILE-Gx.  For example:

               asm ("st_add %I0,%1,%i0" : "=m<>" (*mem) : "r" (val));

     'M'
          A bit mask suitable for the BFINS instruction.

     'N'
          Integer constant that is a byte tiled out eight times.

     'O'
          The integer zero constant.

     'P'
          Integer constant that is a sign-extended byte tiled out as
          four shorts.

     'Q'
          Integer constant that fits in one signed byte when incremented
          (-129 ... 126), but excluding -1.

     'S'
          Integer constant that has all 1 bits consecutive and starting
          at bit 0.

     'T'
          A 16-bit fragment of a got, tls, or pc-relative reference.

     'U'
          Memory operand except postincrement.  This is roughly the same
          as 'm' when not used together with '<' or '>'.

     'W'
          An 8-element vector constant with identical elements.

     'Y'
          A 4-element vector constant with identical elements.

     'Z0'
          The integer constant 0xffffffff.

     'Z1'
          The integer constant 0xffffffff00000000.

_TILEPro--'config/tilepro/constraints.md'_
     'R00'
     'R01'
     'R02'
     'R03'
     'R04'
     'R05'
     'R06'
     'R07'
     'R08'
     'R09'
     'R10'
          Each of these represents a register constraint for an
          individual register, from r0 to r10.

     'I'
          Signed 8-bit integer constant.

     'J'
          Signed 16-bit integer constant.

     'K'
          Nonzero integer constant with low 16 bits zero.

     'L'
          Integer constant that fits in one signed byte when incremented
          by one (-129 ... 126).

     'm'
          Memory operand.  If used together with '<' or '>', the operand
          can have postincrement which requires printing with '%In' and
          '%in' on TILEPro.  For example:

               asm ("swadd %I0,%1,%i0" : "=m<>" (mem) : "r" (val));

     'M'
          A bit mask suitable for the MM instruction.

     'N'
          Integer constant that is a byte tiled out four times.

     'O'
          The integer zero constant.

     'P'
          Integer constant that is a sign-extended byte tiled out as two
          shorts.

     'Q'
          Integer constant that fits in one signed byte when incremented
          (-129 ... 126), but excluding -1.

     'T'
          A symbolic operand, or a 16-bit fragment of a got, tls, or
          pc-relative reference.

     'U'
          Memory operand except postincrement.  This is roughly the same
          as 'm' when not used together with '<' or '>'.

     'W'
          A 4-element vector constant with identical elements.

     'Y'
          A 2-element vector constant with identical elements.

_Visium--'config/visium/constraints.md'_
     'b'
          EAM register 'mdb'

     'c'
          EAM register 'mdc'

     'f'
          Floating point register

     'k'
          Register for sibcall optimization

     'l'
          General register, but not 'r29', 'r30' and 'r31'

     't'
          Register 'r1'

     'u'
          Register 'r2'

     'v'
          Register 'r3'

     'G'
          Floating-point constant 0.0

     'J'
          Integer constant in the range 0 ..  65535 (16-bit immediate)

     'K'
          Integer constant in the range 1 ..  31 (5-bit immediate)

     'L'
          Integer constant in the range -65535 ..  -1 (16-bit negative
          immediate)

     'M'
          Integer constant -1

     'O'
          Integer constant 0

     'P'
          Integer constant 32

_x86 family--'config/i386/constraints.md'_
     'R'
          Legacy register--the eight integer registers available on all
          i386 processors ('a', 'b', 'c', 'd', 'si', 'di', 'bp', 'sp').

     'q'
          Any register accessible as 'Rl'.  In 32-bit mode, 'a', 'b',
          'c', and 'd'; in 64-bit mode, any integer register.

     'Q'
          Any register accessible as 'Rh': 'a', 'b', 'c', and 'd'.

     'l'
          Any register that can be used as the index in a base+index
          memory access: that is, any general register except the stack
          pointer.

     'a'
          The 'a' register.

     'b'
          The 'b' register.

     'c'
          The 'c' register.

     'd'
          The 'd' register.

     'S'
          The 'si' register.

     'D'
          The 'di' register.

     'A'
          The 'a' and 'd' registers.  This class is used for
          instructions that return double word results in the 'ax:dx'
          register pair.  Single word values will be allocated either in
          'ax' or 'dx'.  For example on i386 the following implements
          'rdtsc':

               unsigned long long rdtsc (void)
               {
                 unsigned long long tick;
                 __asm__ __volatile__("rdtsc":"=A"(tick));
                 return tick;
               }

          This is not correct on x86-64 as it would allocate tick in
          either 'ax' or 'dx'.  You have to use the following variant
          instead:

               unsigned long long rdtsc (void)
               {
                 unsigned int tickl, tickh;
                 __asm__ __volatile__("rdtsc":"=a"(tickl),"=d"(tickh));
                 return ((unsigned long long)tickh << 32)|tickl;
               }

     'U'
          The call-clobbered integer registers.

     'f'
          Any 80387 floating-point (stack) register.

     't'
          Top of 80387 floating-point stack ('%st(0)').

     'u'
          Second from top of 80387 floating-point stack ('%st(1)').

     'Yk'
          Any mask register that can be used as a predicate, i.e.
          'k1-k7'.

     'k'
          Any mask register.

     'y'
          Any MMX register.

     'x'
          Any SSE register.

     'v'
          Any EVEX encodable SSE register ('%xmm0-%xmm31').

     'w'
          Any bound register.

     'Yz'
          First SSE register ('%xmm0').

     'Yi'
          Any SSE register, when SSE2 and inter-unit moves are enabled.

     'Yj'
          Any SSE register, when SSE2 and inter-unit moves from vector
          registers are enabled.

     'Ym'
          Any MMX register, when inter-unit moves are enabled.

     'Yn'
          Any MMX register, when inter-unit moves from vector registers
          are enabled.

     'Yp'
          Any integer register when 'TARGET_PARTIAL_REG_STALL' is
          disabled.

     'Ya'
          Any integer register when zero extensions with 'AND' are
          disabled.

     'Yb'
          Any register that can be used as the GOT base when calling
          '___tls_get_addr': that is, any general register except 'a'
          and 'sp' registers, for '-fno-plt' if linker supports it.
          Otherwise, 'b' register.

     'Yf'
          Any x87 register when 80387 floating-point arithmetic is
          enabled.

     'Yr'
          Lower SSE register when avoiding REX prefix and all SSE
          registers otherwise.

     'Yv'
          For AVX512VL, any EVEX-encodable SSE register
          ('%xmm0-%xmm31'), otherwise any SSE register.

     'Yh'
          Any EVEX-encodable SSE register, that has number factor of
          four.

     'Bf'
          Flags register operand.

     'Bg'
          GOT memory operand.

     'Bm'
          Vector memory operand.

     'Bc'
          Constant memory operand.

     'Bn'
          Memory operand without REX prefix.

     'Bs'
          Sibcall memory operand.

     'Bw'
          Call memory operand.

     'Bz'
          Constant call address operand.

     'BC'
          SSE constant -1 operand.

     'I'
          Integer constant in the range 0 ... 31, for 32-bit shifts.

     'J'
          Integer constant in the range 0 ... 63, for 64-bit shifts.

     'K'
          Signed 8-bit integer constant.

     'L'
          '0xFF' or '0xFFFF', for andsi as a zero-extending move.

     'M'
          0, 1, 2, or 3 (shifts for the 'lea' instruction).

     'N'
          Unsigned 8-bit integer constant (for 'in' and 'out'
          instructions).

     'O'
          Integer constant in the range 0 ... 127, for 128-bit shifts.

     'G'
          Standard 80387 floating point constant.

     'C'
          SSE constant zero operand.

     'e'
          32-bit signed integer constant, or a symbolic reference known
          to fit that range (for immediate operands in sign-extending
          x86-64 instructions).

     'We'
          32-bit signed integer constant, or a symbolic reference known
          to fit that range (for sign-extending conversion operations
          that require non-'VOIDmode' immediate operands).

     'Wz'
          32-bit unsigned integer constant, or a symbolic reference
          known to fit that range (for zero-extending conversion
          operations that require non-'VOIDmode' immediate operands).

     'Wd'
          128-bit integer constant where both the high and low 64-bit
          word satisfy the 'e' constraint.

     'Z'
          32-bit unsigned integer constant, or a symbolic reference
          known to fit that range (for immediate operands in
          zero-extending x86-64 instructions).

     'Tv'
          VSIB address operand.

     'Ts'
          Address operand without segment register.

_Xstormy16--'config/stormy16/stormy16.h'_
     'a'
          Register r0.

     'b'
          Register r1.

     'c'
          Register r2.

     'd'
          Register r8.

     'e'
          Registers r0 through r7.

     't'
          Registers r0 and r1.

     'y'
          The carry register.

     'z'
          Registers r8 and r9.

     'I'
          A constant between 0 and 3 inclusive.

     'J'
          A constant that has exactly one bit set.

     'K'
          A constant that has exactly one bit clear.

     'L'
          A constant between 0 and 255 inclusive.

     'M'
          A constant between -255 and 0 inclusive.

     'N'
          A constant between -3 and 0 inclusive.

     'O'
          A constant between 1 and 4 inclusive.

     'P'
          A constant between -4 and -1 inclusive.

     'Q'
          A memory reference that is a stack push.

     'R'
          A memory reference that is a stack pop.

     'S'
          A memory reference that refers to a constant address of known
          value.

     'T'
          The register indicated by Rx (not implemented yet).

     'U'
          A constant that is not between 2 and 15 inclusive.

     'Z'
          The constant 0.

_Xtensa--'config/xtensa/constraints.md'_
     'a'
          General-purpose 32-bit register

     'b'
          One-bit boolean register

     'A'
          MAC16 40-bit accumulator register

     'I'
          Signed 12-bit integer constant, for use in MOVI instructions

     'J'
          Signed 8-bit integer constant, for use in ADDI instructions

     'K'
          Integer constant valid for BccI instructions

     'L'
          Unsigned constant valid for BccUI instructions

==============================================================================
File: gccint.info,  Node: |Disable_Insn_Alternatives|,  Next: |Define_Constraints|,  Prev: |Machine_Constraints|,  Up: |Constraints|
==============================================================================

                                                     *Disable_Insn_Alternatives*

17.8.6 Disable insn alternatives using the 'enabled' attribute
--------------------------------------------------------------

There are three insn attributes that may be used to selectively disable
instruction alternatives:

'enabled'
     Says whether an alternative is available on the current subtarget.

'preferred_for_size'
     Says whether an enabled alternative should be used in code that is
     optimized for size.

'preferred_for_speed'
     Says whether an enabled alternative should be used in code that is
     optimized for speed.

 All these attributes should use '(const_int 1)' to allow an alternative
or '(const_int 0)' to disallow it.  The attributes must be a static
property of the subtarget; they cannot for example depend on the current
operands, on the current optimization level, on the location of the insn
within the body of a loop, on whether register allocation has finished,
or on the current compiler pass.

 The 'enabled' attribute is a correctness property.  It tells GCC to act
as though the disabled alternatives were never defined in the first
place.  This is useful when adding new instructions to an existing
pattern in cases where the new instructions are only available for
certain cpu architecture levels (typically mapped to the '-march='
command-line option).

 In contrast, the 'preferred_for_size' and 'preferred_for_speed'
attributes are strong optimization hints rather than correctness
properties.  'preferred_for_size' tells GCC which alternatives to
consider when adding or modifying an instruction that GCC wants to
optimize for size.  'preferred_for_speed' does the same thing for speed.
Note that things like code motion can lead to cases where code optimized
for size uses alternatives that are not preferred for size, and
similarly for speed.

 Although 'define_insn's can in principle specify the 'enabled'
attribute directly, it is often clearer to have subsiduary attributes
for each architectural feature of interest.  The 'define_insn's can then
use these subsiduary attributes to say which alternatives require which
features.  The example below does this for 'cpu_facility'.

 E.g.  the following two patterns could easily be merged using the
'enabled' attribute:


     (define_insn "*movdi_old"
       [(set (match_operand:DI 0 "register_operand" "=d")
             (match_operand:DI 1 "register_operand" " d"))]
       "!TARGET_NEW"
       "lgr %0,%1")

     (define_insn "*movdi_new"
       [(set (match_operand:DI 0 "register_operand" "=d,f,d")
             (match_operand:DI 1 "register_operand" " d,d,f"))]
       "TARGET_NEW"
       "@
        lgr  %0,%1
        ldgr %0,%1
        lgdr %0,%1")


 to:


     (define_insn "*movdi_combined"
       [(set (match_operand:DI 0 "register_operand" "=d,f,d")
             (match_operand:DI 1 "register_operand" " d,d,f"))]
       ""
       "@
        lgr  %0,%1
        ldgr %0,%1
        lgdr %0,%1"
       [(set_attr "cpu_facility" "*,new,new")])


 with the 'enabled' attribute defined like this:


     (define_attr "cpu_facility" "standard,new" (const_string "standard"))

     (define_attr "enabled" ""
       (cond [(eq_attr "cpu_facility" "standard") (const_int 1)
              (and (eq_attr "cpu_facility" "new")
                   (ne (symbol_ref "TARGET_NEW") (const_int 0)))
              (const_int 1)]
             (const_int 0)))


==============================================================================
File: gccint.info,  Node: |Define_Constraints|,  Next: |C_Constraint_Interface|,  Prev: |Disable_Insn_Alternatives|,  Up: |Constraints|
==============================================================================

                                                            *Define_Constraints*

17.8.7 Defining Machine-Specific Constraints
--------------------------------------------

Machine-specific constraints fall into two categories: register and
non-register constraints.  Within the latter category, constraints which
allow subsets of all possible memory or address operands should be
specially marked, to give 'reload' more information.

 Machine-specific constraints can be given names of arbitrary length,
but they must be entirely composed of letters, digits, underscores
('_'), and angle brackets ('< >').  Like C identifiers, they must begin
with a letter or underscore.

 In order to avoid ambiguity in operand constraint strings, no
constraint can have a name that begins with any other constraint's name.
For example, if 'x' is defined as a constraint name, 'xy' may not be,
and vice versa.  As a consequence of this rule, no constraint may begin
with one of the generic constraint letters: 'E F V X g i m n o p r s'.

 Register constraints correspond directly to register classes.  *Note
Register Classes::.  There is thus not much flexibility in their
definitions.

 -- MD Expression: define_register_constraint name regclass docstring
     All three arguments are string constants.  NAME is the name of the
     constraint, as it will appear in 'match_operand' expressions.  If
     NAME is a multi-letter constraint its length shall be the same for
     all constraints starting with the same letter.  REGCLASS can be
     either the name of the corresponding register class (*note Register
     Classes::), or a C expression which evaluates to the appropriate
     register class.  If it is an expression, it must have no side
     effects, and it cannot look at the operand.  The usual use of
     expressions is to map some register constraints to 'NO_REGS' when
     the register class is not available on a given subarchitecture.

     DOCSTRING is a sentence documenting the meaning of the constraint.
     Docstrings are explained further below.

 Non-register constraints are more like predicates: the constraint
definition gives a boolean expression which indicates whether the
constraint matches.

 -- MD Expression: define_constraint name docstring exp
     The NAME and DOCSTRING arguments are the same as for
     'define_register_constraint', but note that the docstring comes
     immediately after the name for these expressions.  EXP is an RTL
     expression, obeying the same rules as the RTL expressions in
     predicate definitions.  *Note Defining Predicates::, for details.
     If it evaluates true, the constraint matches; if it evaluates
     false, it doesn't.  Constraint expressions should indicate which
     RTL codes they might match, just like predicate expressions.

     'match_test' C expressions have access to the following variables:

     OP
          The RTL object defining the operand.
     MODE
          The machine mode of OP.
     IVAL
          'INTVAL (OP)', if OP is a 'const_int'.
     HVAL
          'CONST_DOUBLE_HIGH (OP)', if OP is an integer 'const_double'.
     LVAL
          'CONST_DOUBLE_LOW (OP)', if OP is an integer 'const_double'.
     RVAL
          'CONST_DOUBLE_REAL_VALUE (OP)', if OP is a floating-point
          'const_double'.

     The *VAL variables should only be used once another piece of the
     expression has verified that OP is the appropriate kind of RTL
     object.

 Most non-register constraints should be defined with
'define_constraint'.  The remaining two definition expressions are only
appropriate for constraints that should be handled specially by 'reload'
if they fail to match.

 -- MD Expression: define_memory_constraint name docstring exp
     Use this expression for constraints that match a subset of all
     memory operands: that is, 'reload' can make them match by
     converting the operand to the form '(mem (reg X))', where X is a
     base register (from the register class specified by
     'BASE_REG_CLASS', *note Register Classes::).

     For example, on the S/390, some instructions do not accept
     arbitrary memory references, but only those that do not make use of
     an index register.  The constraint letter 'Q' is defined to
     represent a memory address of this type.  If 'Q' is defined with
     'define_memory_constraint', a 'Q' constraint can handle any memory
     operand, because 'reload' knows it can simply copy the memory
     address into a base register if required.  This is analogous to the
     way an 'o' constraint can handle any memory operand.

     The syntax and semantics are otherwise identical to
     'define_constraint'.

 -- MD Expression: define_special_memory_constraint name docstring exp
     Use this expression for constraints that match a subset of all
     memory operands: that is, 'reload' cannot make them match by
     reloading the address as it is described for
     'define_memory_constraint' or such address reload is undesirable
     with the performance point of view.

     For example, 'define_special_memory_constraint' can be useful if
     specifically aligned memory is necessary or desirable for some insn
     operand.

     The syntax and semantics are otherwise identical to
     'define_constraint'.

 -- MD Expression: define_address_constraint name docstring exp
     Use this expression for constraints that match a subset of all
     address operands: that is, 'reload' can make the constraint match
     by converting the operand to the form '(reg X)', again with X a
     base register.

     Constraints defined with 'define_address_constraint' can only be
     used with the 'address_operand' predicate, or machine-specific
     predicates that work the same way.  They are treated analogously to
     the generic 'p' constraint.

     The syntax and semantics are otherwise identical to
     'define_constraint'.

 For historical reasons, names beginning with the letters 'G H' are
reserved for constraints that match only 'const_double's, and names
beginning with the letters 'I J K L M N O P' are reserved for
constraints that match only 'const_int's.  This may change in the
future.  For the time being, constraints with these names must be
written in a stylized form, so that 'genpreds' can tell you did it
correctly:

     (define_constraint "[GHIJKLMNOP]..."
       "DOC..."
       (and (match_code "const_int")  ; 'const_double' for G/H
            CONDITION...))            ; usually a 'match_test'

 It is fine to use names beginning with other letters for constraints
that match 'const_double's or 'const_int's.

 Each docstring in a constraint definition should be one or more
complete sentences, marked up in Texinfo format.  _They are currently
unused._  In the future they will be copied into the GCC manual, in
*note Machine Constraints::, replacing the hand-maintained tables
currently found in that section.  Also, in the future the compiler may
use this to give more helpful diagnostics when poor choice of 'asm'
constraints causes a reload failure.

 If you put the pseudo-Texinfo directive '@internal' at the beginning of
a docstring, then (in the future) it will appear only in the internals
manual's version of the machine-specific constraint tables.  Use this
for constraints that should not appear in 'asm' statements.

==============================================================================
File: gccint.info,  Node: |C_Constraint_Interface|,  Prev: |Define_Constraints|,  Up: |Constraints|
==============================================================================

                                                        *C_Constraint_Interface*

17.8.8 Testing constraints from C
---------------------------------

It is occasionally useful to test a constraint from C code rather than
implicitly via the constraint string in a 'match_operand'.  The
generated file 'tm_p.h' declares a few interfaces for working with
constraints.  At present these are defined for all constraints except
'g' (which is equivalent to 'general_operand').

 Some valid constraint names are not valid C identifiers, so there is a
mangling scheme for referring to them from C.  Constraint names that do
not contain angle brackets or underscores are left unchanged.
Underscores are doubled, each '<' is replaced with '_l', and each '>'
with '_g'.  Here are some examples:

     Original *Mangled*
     x          x
     P42x       P42x
     P4_x       P4__x
     P4>x       P4_gx
     P4>>       P4_g_g
     P4_g>      P4__g_g

 Throughout this section, the variable C is either a constraint in the
abstract sense, or a constant from 'enum constraint_num'; the variable M
is a mangled constraint name (usually as part of a larger identifier).

 -- Enum: constraint_num
     For each constraint except 'g', there is a corresponding
     enumeration constant: 'CONSTRAINT_' plus the mangled name of the
     constraint.  Functions that take an 'enum constraint_num' as an
     argument expect one of these constants.

 -- Function: inline bool satisfies_constraint_M (rtx EXP)
     For each non-register constraint M except 'g', there is one of
     these functions; it returns 'true' if EXP satisfies the constraint.
     These functions are only visible if 'rtl.h' was included before
     'tm_p.h'.

 -- Function: bool constraint_satisfied_p (rtx EXP, enum constraint_num
          C)
     Like the 'satisfies_constraint_M' functions, but the constraint to
     test is given as an argument, C.  If C specifies a register
     constraint, this function will always return 'false'.

 -- Function: enum reg_class reg_class_for_constraint (enum
          constraint_num C)
     Returns the register class associated with C.  If C is not a
     register constraint, or those registers are not available for the
     currently selected subtarget, returns 'NO_REGS'.

 Here is an example use of 'satisfies_constraint_M'.  In peephole
optimizations (*note Peephole Definitions::), operand constraint strings
are ignored, so if there are relevant constraints, they must be tested
in the C condition.  In the example, the optimization is applied if
operand 2 does _not_ satisfy the 'K' constraint.  (This is a simplified
version of a peephole definition from the i386 machine description.)

     (define_peephole2
       [(match_scratch:SI 3 "r")
        (set (match_operand:SI 0 "register_operand" "")
             (mult:SI (match_operand:SI 1 "memory_operand" "")
                      (match_operand:SI 2 "immediate_operand" "")))]

       "!satisfies_constraint_K (operands[2])"

       [(set (match_dup 3) (match_dup 1))
        (set (match_dup 0) (mult:SI (match_dup 3) (match_dup 2)))]

       "")

==============================================================================
File: gccint.info,  Node: |Standard_Names|,  Next: |Pattern_Ordering|,  Prev: |Constraints|,  Up: |Machine_Desc|
==============================================================================

                                                                *Standard_Names*

17.9 Standard Pattern Names For Generation
------------------------------------------

Here is a table of the instruction names that are meaningful in the RTL
generation pass of the compiler.  Giving one of these names to an
instruction pattern tells the RTL generation pass that it can use the
pattern to accomplish a certain task.

'movM'
     Here M stands for a two-letter machine mode name, in lowercase.
     This instruction pattern moves data with that machine mode from
     operand 1 to operand 0.  For example, 'movsi' moves full-word data.

     If operand 0 is a 'subreg' with mode M of a register whose own mode
     is wider than M, the effect of this instruction is to store the
     specified value in the part of the register that corresponds to
     mode M.  Bits outside of M, but which are within the same target
     word as the 'subreg' are undefined.  Bits which are outside the
     target word are left unchanged.

     This class of patterns is special in several ways.  First of all,
     each of these names up to and including full word size _must_ be
     defined, because there is no other way to copy a datum from one
     place to another.  If there are patterns accepting operands in
     larger modes, 'movM' must be defined for integer modes of those
     sizes.

     Second, these patterns are not used solely in the RTL generation
     pass.  Even the reload pass can generate move insns to copy values
     from stack slots into temporary registers.  When it does so, one of
     the operands is a hard register and the other is an operand that
     can need to be reloaded into a register.

     Therefore, when given such a pair of operands, the pattern must
     generate RTL which needs no reloading and needs no temporary
     registers--no registers other than the operands.  For example, if
     you support the pattern with a 'define_expand', then in such a case
     the 'define_expand' mustn't call 'force_reg' or any other such
     function which might generate new pseudo registers.

     This requirement exists even for subword modes on a RISC machine
     where fetching those modes from memory normally requires several
     insns and some temporary registers.

     During reload a memory reference with an invalid address may be
     passed as an operand.  Such an address will be replaced with a
     valid address later in the reload pass.  In this case, nothing may
     be done with the address except to use it as it stands.  If it is
     copied, it will not be replaced with a valid address.  No attempt
     should be made to make such an address into a valid address and no
     routine (such as 'change_address') that will do so may be called.
     Note that 'general_operand' will fail when applied to such an
     address.

     The global variable 'reload_in_progress' (which must be explicitly
     declared if required) can be used to determine whether such special
     handling is required.

     The variety of operands that have reloads depends on the rest of
     the machine description, but typically on a RISC machine these can
     only be pseudo registers that did not get hard registers, while on
     other machines explicit memory references will get optional
     reloads.

     If a scratch register is required to move an object to or from
     memory, it can be allocated using 'gen_reg_rtx' prior to life
     analysis.

     If there are cases which need scratch registers during or after
     reload, you must provide an appropriate secondary_reload target
     hook.

     The macro 'can_create_pseudo_p' can be used to determine if it is
     unsafe to create new pseudo registers.  If this variable is
     nonzero, then it is unsafe to call 'gen_reg_rtx' to allocate a new
     pseudo.

     The constraints on a 'movM' must permit moving any hard register to
     any other hard register provided that 'TARGET_HARD_REGNO_MODE_OK'
     permits mode M in both registers and 'TARGET_REGISTER_MOVE_COST'
     applied to their classes returns a value of 2.

     It is obligatory to support floating point 'movM' instructions into
     and out of any registers that can hold fixed point values, because
     unions and structures (which have modes 'SImode' or 'DImode') can
     be in those registers and they may have floating point members.

     There may also be a need to support fixed point 'movM' instructions
     in and out of floating point registers.  Unfortunately, I have
     forgotten why this was so, and I don't know whether it is still
     true.  If 'TARGET_HARD_REGNO_MODE_OK' rejects fixed point values in
     floating point registers, then the constraints of the fixed point
     'movM' instructions must be designed to avoid ever trying to reload
     into a floating point register.

'reload_inM'
'reload_outM'
     These named patterns have been obsoleted by the target hook
     'secondary_reload'.

     Like 'movM', but used when a scratch register is required to move
     between operand 0 and operand 1.  Operand 2 describes the scratch
     register.  See the discussion of the 'SECONDARY_RELOAD_CLASS' macro
     in *note Register Classes::.

     There are special restrictions on the form of the 'match_operand's
     used in these patterns.  First, only the predicate for the reload
     operand is examined, i.e., 'reload_in' examines operand 1, but not
     the predicates for operand 0 or 2.  Second, there may be only one
     alternative in the constraints.  Third, only a single register
     class letter may be used for the constraint; subsequent constraint
     letters are ignored.  As a special exception, an empty constraint
     string matches the 'ALL_REGS' register class.  This may relieve
     ports of the burden of defining an 'ALL_REGS' constraint letter
     just for these patterns.

'movstrictM'
     Like 'movM' except that if operand 0 is a 'subreg' with mode M of a
     register whose natural mode is wider, the 'movstrictM' instruction
     is guaranteed not to alter any of the register except the part
     which belongs to mode M.

'movmisalignM'
     This variant of a move pattern is designed to load or store a value
     from a memory address that is not naturally aligned for its mode.
     For a store, the memory will be in operand 0; for a load, the
     memory will be in operand 1.  The other operand is guaranteed not
     to be a memory, so that it's easy to tell whether this is a load or
     store.

     This pattern is used by the autovectorizer, and when expanding a
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
