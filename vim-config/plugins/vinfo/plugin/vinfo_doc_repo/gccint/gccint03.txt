of optimization, we need to distinguish between references to local
scalar variables and references to globals, statics, structures, arrays,
aliased variables, etc.  The reason is simple, the compiler can gather
complete data flow information for a local scalar.  On the other hand, a
global variable may be modified by a function call, it may not be
possible to keep track of all the elements of an array or the fields of
a structure, etc.

 The operand scanner gathers two kinds of operands: "real" and
"virtual".  An operand for which 'is_gimple_reg' returns true is
considered real, otherwise it is a virtual operand.  We also distinguish
between uses and definitions.  An operand is used if its value is loaded
by the statement (e.g., the operand at the RHS of an assignment).  If
the statement assigns a new value to the operand, the operand is
considered a definition (e.g., the operand at the LHS of an assignment).

 Virtual and real operands also have very different data flow
properties.  Real operands are unambiguous references to the full object
that they represent.  For instance, given

     {
       int a, b;
       a = b
     }

 Since 'a' and 'b' are non-aliased locals, the statement 'a = b' will
have one real definition and one real use because variable 'a' is
completely modified with the contents of variable 'b'.  Real definition
are also known as "killing definitions".  Similarly, the use of 'b'
reads all its bits.

 In contrast, virtual operands are used with variables that can have a
partial or ambiguous reference.  This includes structures, arrays,
globals, and aliased variables.  In these cases, we have two types of
definitions.  For globals, structures, and arrays, we can determine from
a statement whether a variable of these types has a killing definition.
If the variable does, then the statement is marked as having a "must
definition" of that variable.  However, if a statement is only defining
a part of the variable (i.e. a field in a structure), or if we know that
a statement might define the variable but we cannot say for sure, then
we mark that statement as having a "may definition".  For instance,
given

     {
       int a, b, *p;

       if (...)
         p = &a;
       else
         p = &b;
       *p = 5;
       return *p;
     }

 The assignment '*p = 5' may be a definition of 'a' or 'b'.  If we
cannot determine statically where 'p' is pointing to at the time of the
store operation, we create virtual definitions to mark that statement as
a potential definition site for 'a' and 'b'.  Memory loads are similarly
marked with virtual use operands.  Virtual operands are shown in tree
dumps right before the statement that contains them.  To request a tree
dump with virtual operands, use the '-vops' option to '-fdump-tree':

     {
       int a, b, *p;

       if (...)
         p = &a;
       else
         p = &b;
       # a = VDEF <a>
       # b = VDEF <b>
       *p = 5;

       # VUSE <a>
       # VUSE <b>
       return *p;
     }

 Notice that 'VDEF' operands have two copies of the referenced variable.
This indicates that this is not a killing definition of that variable.
In this case we refer to it as a "may definition" or "aliased store".
The presence of the second copy of the variable in the 'VDEF' operand
will become important when the function is converted into SSA form.
This will be used to link all the non-killing definitions to prevent
optimizations from making incorrect assumptions about them.

 Operands are updated as soon as the statement is finished via a call to
'update_stmt'.  If statement elements are changed via 'SET_USE' or
'SET_DEF', then no further action is required (i.e., those macros take
care of updating the statement).  If changes are made by manipulating
the statement's tree directly, then a call must be made to 'update_stmt'
when complete.  Calling one of the 'bsi_insert' routines or
'bsi_replace' performs an implicit call to 'update_stmt'.

13.2.1 Operand Iterators And Access Routines
--------------------------------------------

Operands are collected by 'tree-ssa-operands.c'.  They are stored inside
each statement's annotation and can be accessed through either the
operand iterators or an access routine.

 The following access routines are available for examining operands:

  1. 'SINGLE_SSA_{USE,DEF,TREE}_OPERAND': These accessors will return
     NULL unless there is exactly one operand matching the specified
     flags.  If there is exactly one operand, the operand is returned as
     either a 'tree', 'def_operand_p', or 'use_operand_p'.

          tree t = SINGLE_SSA_TREE_OPERAND (stmt, flags);
          use_operand_p u = SINGLE_SSA_USE_OPERAND (stmt, SSA_ALL_VIRTUAL_USES);
          def_operand_p d = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_ALL_DEFS);

  2. 'ZERO_SSA_OPERANDS': This macro returns true if there are no
     operands matching the specified flags.

          if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))
            return;

  3. 'NUM_SSA_OPERANDS': This macro Returns the number of operands
     matching 'flags'.  This actually executes a loop to perform the
     count, so only use this if it is really needed.

          int count = NUM_SSA_OPERANDS (stmt, flags)

 If you wish to iterate over some or all operands, use the
'FOR_EACH_SSA_{USE,DEF,TREE}_OPERAND' iterator.  For example, to print
all the operands for a statement:

     void
     print_ops (tree stmt)
     {
       ssa_op_iter;
       tree var;

       FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_OPERANDS)
         print_generic_expr (stderr, var, TDF_SLIM);
     }

 How to choose the appropriate iterator:

  1. Determine whether you are need to see the operand pointers, or just
     the trees, and choose the appropriate macro:

          Need            Macro:
          ----            -------
          use_operand_p   FOR_EACH_SSA_USE_OPERAND
          def_operand_p   FOR_EACH_SSA_DEF_OPERAND
          tree            FOR_EACH_SSA_TREE_OPERAND

  2. You need to declare a variable of the type you are interested in,
     and an ssa_op_iter structure which serves as the loop controlling
     variable.

  3. Determine which operands you wish to use, and specify the flags of
     those you are interested in.  They are documented in
     'tree-ssa-operands.h':

          #define SSA_OP_USE              0x01    /* Real USE operands.  */
          #define SSA_OP_DEF              0x02    /* Real DEF operands.  */
          #define SSA_OP_VUSE             0x04    /* VUSE operands.  */
          #define SSA_OP_VDEF             0x08    /* VDEF operands.  */

          /* These are commonly grouped operand flags.  */
          #define SSA_OP_VIRTUAL_USES	(SSA_OP_VUSE)
          #define SSA_OP_VIRTUAL_DEFS	(SSA_OP_VDEF)
          #define SSA_OP_ALL_VIRTUALS     (SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_DEFS)
          #define SSA_OP_ALL_USES		(SSA_OP_VIRTUAL_USES | SSA_OP_USE)
          #define SSA_OP_ALL_DEFS		(SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)
          #define SSA_OP_ALL_OPERANDS	(SSA_OP_ALL_USES | SSA_OP_ALL_DEFS)

 So if you want to look at the use pointers for all the 'USE' and 'VUSE'
operands, you would do something like:

       use_operand_p use_p;
       ssa_op_iter iter;

       FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, (SSA_OP_USE | SSA_OP_VUSE))
         {
           process_use_ptr (use_p);
         }

 The 'TREE' macro is basically the same as the 'USE' and 'DEF' macros,
only with the use or def dereferenced via 'USE_FROM_PTR (use_p)' and
'DEF_FROM_PTR (def_p)'.  Since we aren't using operand pointers, use and
defs flags can be mixed.

       tree var;
       ssa_op_iter iter;

       FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_VUSE)
         {
            print_generic_expr (stderr, var, TDF_SLIM);
         }

 'VDEF's are broken into two flags, one for the 'DEF' portion
('SSA_OP_VDEF') and one for the USE portion ('SSA_OP_VUSE').

 There are many examples in the code, in addition to the documentation
in 'tree-ssa-operands.h' and 'ssa-iterators.h'.

 There are also a couple of variants on the stmt iterators regarding PHI
nodes.

 'FOR_EACH_PHI_ARG' Works exactly like 'FOR_EACH_SSA_USE_OPERAND',
except it works over 'PHI' arguments instead of statement operands.

     /* Look at every virtual PHI use.  */
     FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_VIRTUAL_USES)
     {
        my_code;
     }

     /* Look at every real PHI use.  */
     FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_USES)
       my_code;

     /* Look at every PHI use.  */
     FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_ALL_USES)
       my_code;

 'FOR_EACH_PHI_OR_STMT_{USE,DEF}' works exactly like
'FOR_EACH_SSA_{USE,DEF}_OPERAND', except it will function on either a
statement or a 'PHI' node.  These should be used when it is appropriate
but they are not quite as efficient as the individual 'FOR_EACH_PHI' and
'FOR_EACH_SSA' routines.

     FOR_EACH_PHI_OR_STMT_USE (use_operand_p, stmt, iter, flags)
       {
          my_code;
       }

     FOR_EACH_PHI_OR_STMT_DEF (def_operand_p, phi, iter, flags)
       {
          my_code;
       }

13.2.2 Immediate Uses
---------------------

Immediate use information is now always available.  Using the immediate
use iterators, you may examine every use of any 'SSA_NAME'.  For
instance, to change each use of 'ssa_var' to 'ssa_var2' and call
fold_stmt on each stmt after that is done:

       use_operand_p imm_use_p;
       imm_use_iterator iterator;
       tree ssa_var, stmt;


       FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)
         {
           FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
             SET_USE (imm_use_p, ssa_var_2);
           fold_stmt (stmt);
         }

 There are 2 iterators which can be used.  'FOR_EACH_IMM_USE_FAST' is
used when the immediate uses are not changed, i.e., you are looking at
the uses, but not setting them.

 If they do get changed, then care must be taken that things are not
changed under the iterators, so use the 'FOR_EACH_IMM_USE_STMT' and
'FOR_EACH_IMM_USE_ON_STMT' iterators.  They attempt to preserve the
sanity of the use list by moving all the uses for a statement into a
controlled position, and then iterating over those uses.  Then the
optimization can manipulate the stmt when all the uses have been
processed.  This is a little slower than the FAST version since it adds
a placeholder element and must sort through the list a bit for each
statement.  This placeholder element must be also be removed if the loop
is terminated early.  The macro 'BREAK_FROM_IMM_USE_STMT' is provided to
do this :

       FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)
         {
           if (stmt == last_stmt)
             BREAK_FROM_IMM_USE_STMT (iterator);

           FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
             SET_USE (imm_use_p, ssa_var_2);
           fold_stmt (stmt);
         }

 There are checks in 'verify_ssa' which verify that the immediate use
list is up to date, as well as checking that an optimization didn't
break from the loop without using this macro.  It is safe to simply
'break'; from a 'FOR_EACH_IMM_USE_FAST' traverse.

 Some useful functions and macros:
  1. 'has_zero_uses (ssa_var)' : Returns true if there are no uses of
     'ssa_var'.
  2. 'has_single_use (ssa_var)' : Returns true if there is only a single
     use of 'ssa_var'.
  3. 'single_imm_use (ssa_var, use_operand_p *ptr, tree *stmt)' :
     Returns true if there is only a single use of 'ssa_var', and also
     returns the use pointer and statement it occurs in, in the second
     and third parameters.
  4. 'num_imm_uses (ssa_var)' : Returns the number of immediate uses of
     'ssa_var'.  It is better not to use this if possible since it
     simply utilizes a loop to count the uses.
  5. 'PHI_ARG_INDEX_FROM_USE (use_p)' : Given a use within a 'PHI' node,
     return the index number for the use.  An assert is triggered if the
     use isn't located in a 'PHI' node.
  6. 'USE_STMT (use_p)' : Return the statement a use occurs in.

 Note that uses are not put into an immediate use list until their
statement is actually inserted into the instruction stream via a 'bsi_*'
routine.

 It is also still possible to utilize lazy updating of statements, but
this should be used only when absolutely required.  Both alias analysis
and the dominator optimizations currently do this.

 When lazy updating is being used, the immediate use information is out
of date and cannot be used reliably.  Lazy updating is achieved by
simply marking statements modified via calls to 'gimple_set_modified'
instead of 'update_stmt'.  When lazy updating is no longer required, all
the modified statements must have 'update_stmt' called in order to bring
them up to date.  This must be done before the optimization is finished,
or 'verify_ssa' will trigger an abort.

 This is done with a simple loop over the instruction stream:
       block_stmt_iterator bsi;
       basic_block bb;
       FOR_EACH_BB (bb)
         {
           for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))
             update_stmt_if_modified (bsi_stmt (bsi));
         }

==============================================================================
File: gccint.info,  Node: |SSA|,  Next: |Alias_analysis|,  Prev: |SSA_Operands|,  Up: |Tree_SSA|
==============================================================================

                                                                           *SSA*

13.3 Static Single Assignment
-----------------------------

Most of the tree optimizers rely on the data flow information provided
by the Static Single Assignment (SSA) form.  We implement the SSA form
as described in 'R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and K.
Zadeck. Efficiently Computing Static Single Assignment Form and the
Control Dependence Graph. ACM Transactions on Programming Languages and
Systems, 13(4):451-490, October 1991'.

 The SSA form is based on the premise that program variables are
assigned in exactly one location in the program.  Multiple assignments
to the same variable create new versions of that variable.  Naturally,
actual programs are seldom in SSA form initially because variables tend
to be assigned multiple times.  The compiler modifies the program
representation so that every time a variable is assigned in the code, a
new version of the variable is created.  Different versions of the same
variable are distinguished by subscripting the variable name with its
version number.  Variables used in the right-hand side of expressions
are renamed so that their version number matches that of the most recent
assignment.

 We represent variable versions using 'SSA_NAME' nodes.  The renaming
process in 'tree-ssa.c' wraps every real and virtual operand with an
'SSA_NAME' node which contains the version number and the statement that
created the 'SSA_NAME'.  Only definitions and virtual definitions may
create new 'SSA_NAME' nodes.

 Sometimes, flow of control makes it impossible to determine the most
recent version of a variable.  In these cases, the compiler inserts an
artificial definition for that variable called "PHI function" or "PHI
node".  This new definition merges all the incoming versions of the
variable to create a new name for it.  For instance,

     if (...)
       a_1 = 5;
     else if (...)
       a_2 = 2;
     else
       a_3 = 13;

     # a_4 = PHI <a_1, a_2, a_3>
     return a_4;

 Since it is not possible to determine which of the three branches will
be taken at runtime, we don't know which of 'a_1', 'a_2' or 'a_3' to use
at the return statement.  So, the SSA renamer creates a new version
'a_4' which is assigned the result of "merging" 'a_1', 'a_2' and 'a_3'.
Hence, PHI nodes mean "one of these operands.  I don't know which".

 The following functions can be used to examine PHI nodes

 -- Function: gimple_phi_result (PHI)
     Returns the 'SSA_NAME' created by PHI node PHI (i.e., PHI's LHS).

 -- Function: gimple_phi_num_args (PHI)
     Returns the number of arguments in PHI.  This number is exactly the
     number of incoming edges to the basic block holding PHI.

 -- Function: gimple_phi_arg (PHI, I)
     Returns Ith argument of PHI.

 -- Function: gimple_phi_arg_edge (PHI, I)
     Returns the incoming edge for the Ith argument of PHI.

 -- Function: gimple_phi_arg_def (PHI, I)
     Returns the 'SSA_NAME' for the Ith argument of PHI.

13.3.1 Preserving the SSA form
------------------------------

Some optimization passes make changes to the function that invalidate
the SSA property.  This can happen when a pass has added new symbols or
changed the program so that variables that were previously aliased
aren't anymore.  Whenever something like this happens, the affected
symbols must be renamed into SSA form again.  Transformations that emit
new code or replicate existing statements will also need to update the
SSA form.

 Since GCC implements two different SSA forms for register and virtual
variables, keeping the SSA form up to date depends on whether you are
updating register or virtual names.  In both cases, the general idea
behind incremental SSA updates is similar: when new SSA names are
created, they typically are meant to replace other existing names in the
program.

 For instance, given the following code:

          1  L0:
          2  x_1 = PHI (0, x_5)
          3  if (x_1 < 10)
          4    if (x_1 > 7)
          5      y_2 = 0
          6    else
          7      y_3 = x_1 + x_7
          8    endif
          9    x_5 = x_1 + 1
          10   goto L0;
          11 endif

 Suppose that we insert new names 'x_10' and 'x_11' (lines '4' and '8').

          1  L0:
          2  x_1 = PHI (0, x_5)
          3  if (x_1 < 10)
          4    x_10 = ...
          5    if (x_1 > 7)
          6      y_2 = 0
          7    else
          8      x_11 = ...
          9      y_3 = x_1 + x_7
          10   endif
          11   x_5 = x_1 + 1
          12   goto L0;
          13 endif

 We want to replace all the uses of 'x_1' with the new definitions of
'x_10' and 'x_11'.  Note that the only uses that should be replaced are
those at lines '5', '9' and '11'.  Also, the use of 'x_7' at line '9'
should _not_ be replaced (this is why we cannot just mark symbol 'x' for
renaming).

 Additionally, we may need to insert a PHI node at line '11' because
that is a merge point for 'x_10' and 'x_11'.  So the use of 'x_1' at
line '11' will be replaced with the new PHI node.  The insertion of PHI
nodes is optional.  They are not strictly necessary to preserve the SSA
form, and depending on what the caller inserted, they may not even be
useful for the optimizers.

 Updating the SSA form is a two step process.  First, the pass has to
identify which names need to be updated and/or which symbols need to be
renamed into SSA form for the first time.  When new names are introduced
to replace existing names in the program, the mapping between the old
and the new names are registered by calling 'register_new_name_mapping'
(note that if your pass creates new code by duplicating basic blocks,
the call to 'tree_duplicate_bb' will set up the necessary mappings
automatically).

 After the replacement mappings have been registered and new symbols
marked for renaming, a call to 'update_ssa' makes the registered
changes.  This can be done with an explicit call or by creating 'TODO'
flags in the 'tree_opt_pass' structure for your pass.  There are several
'TODO' flags that control the behavior of 'update_ssa':

   * 'TODO_update_ssa'.  Update the SSA form inserting PHI nodes for
     newly exposed symbols and virtual names marked for updating.  When
     updating real names, only insert PHI nodes for a real name 'O_j' in
     blocks reached by all the new and old definitions for 'O_j'.  If
     the iterated dominance frontier for 'O_j' is not pruned, we may end
     up inserting PHI nodes in blocks that have one or more edges with
     no incoming definition for 'O_j'.  This would lead to uninitialized
     warnings for 'O_j''s symbol.

   * 'TODO_update_ssa_no_phi'.  Update the SSA form without inserting
     any new PHI nodes at all.  This is used by passes that have either
     inserted all the PHI nodes themselves or passes that need only to
     patch use-def and def-def chains for virtuals (e.g., DCE).

   * 'TODO_update_ssa_full_phi'.  Insert PHI nodes everywhere they are
     needed.  No pruning of the IDF is done.  This is used by passes
     that need the PHI nodes for 'O_j' even if it means that some
     arguments will come from the default definition of 'O_j''s symbol
     (e.g., 'pass_linear_transform').

     WARNING: If you need to use this flag, chances are that your pass
     may be doing something wrong.  Inserting PHI nodes for an old name
     where not all edges carry a new replacement may lead to silent
     codegen errors or spurious uninitialized warnings.

   * 'TODO_update_ssa_only_virtuals'.  Passes that update the SSA form
     on their own may want to delegate the updating of virtual names to
     the generic updater.  Since FUD chains are easier to maintain, this
     simplifies the work they need to do.  NOTE: If this flag is used,
     any OLD->NEW mappings for real names are explicitly destroyed and
     only the symbols marked for renaming are processed.

13.3.2 Examining 'SSA_NAME' nodes
---------------------------------

The following macros can be used to examine 'SSA_NAME' nodes

 -- Macro: SSA_NAME_DEF_STMT (VAR)
     Returns the statement S that creates the 'SSA_NAME' VAR.  If S is
     an empty statement (i.e., 'IS_EMPTY_STMT (S)' returns 'true'), it
     means that the first reference to this variable is a USE or a VUSE.

 -- Macro: SSA_NAME_VERSION (VAR)
     Returns the version number of the 'SSA_NAME' object VAR.

13.3.3 Walking the dominator tree
---------------------------------

 -- Tree SSA function: void walk_dominator_tree (WALK_DATA, BB)

     This function walks the dominator tree for the current CFG calling
     a set of callback functions defined in STRUCT DOM_WALK_DATA in
     'domwalk.h'.  The call back functions you need to define give you
     hooks to execute custom code at various points during traversal:

       1. Once to initialize any local data needed while processing BB
          and its children.  This local data is pushed into an internal
          stack which is automatically pushed and popped as the walker
          traverses the dominator tree.

       2. Once before traversing all the statements in the BB.

       3. Once for every statement inside BB.

       4. Once after traversing all the statements and before recursing
          into BB's dominator children.

       5. It then recurses into all the dominator children of BB.

       6. After recursing into all the dominator children of BB it can,
          optionally, traverse every statement in BB again (i.e.,
          repeating steps 2 and 3).

       7. Once after walking the statements in BB and BB's dominator
          children.  At this stage, the block local data stack is
          popped.

==============================================================================
File: gccint.info,  Node: |Alias_analysis|,  Next: |Memory_model|,  Prev: |SSA|,  Up: |Tree_SSA|
==============================================================================

                                                                *Alias_analysis*

13.4 Alias analysis
-------------------

Alias analysis in GIMPLE SSA form consists of two pieces.  First the
virtual SSA web ties conflicting memory accesses and provides a SSA
use-def chain and SSA immediate-use chains for walking possibly
dependent memory accesses.  Second an alias-oracle can be queried to
disambiguate explicit and implicit memory references.

  1. Memory SSA form.

     All statements that may use memory have exactly one accompanied use
     of a virtual SSA name that represents the state of memory at the
     given point in the IL.

     All statements that may define memory have exactly one accompanied
     definition of a virtual SSA name using the previous state of memory
     and defining the new state of memory after the given point in the
     IL.

          int i;
          int foo (void)
          {
            # .MEM_3 = VDEF <.MEM_2(D)>
            i = 1;
            # VUSE <.MEM_3>
            return i;
          }

     The virtual SSA names in this case are '.MEM_2(D)' and '.MEM_3'.
     The store to the global variable 'i' defines '.MEM_3' invalidating
     '.MEM_2(D)'.  The load from 'i' uses that new state '.MEM_3'.

     The virtual SSA web serves as constraints to SSA optimizers
     preventing illegitimate code-motion and optimization.  It also
     provides a way to walk related memory statements.

  2. Points-to and escape analysis.

     Points-to analysis builds a set of constraints from the GIMPLE SSA
     IL representing all pointer operations and facts we do or do not
     know about pointers.  Solving this set of constraints yields a
     conservatively correct solution for each pointer variable in the
     program (though we are only interested in SSA name pointers) as to
     what it may possibly point to.

     This points-to solution for a given SSA name pointer is stored in
     the 'pt_solution' sub-structure of the 'SSA_NAME_PTR_INFO' record.
     The following accessor functions are available:

        * 'pt_solution_includes'
        * 'pt_solutions_intersect'

     Points-to analysis also computes the solution for two special set
     of pointers, 'ESCAPED' and 'CALLUSED'.  Those represent all memory
     that has escaped the scope of analysis or that is used by pure or
     nested const calls.

  3. Type-based alias analysis

     Type-based alias analysis is frontend dependent though generic
     support is provided by the middle-end in 'alias.c'.  TBAA code is
     used by both tree optimizers and RTL optimizers.

     Every language that wishes to perform language-specific alias
     analysis should define a function that computes, given a 'tree'
     node, an alias set for the node.  Nodes in different alias sets are
     not allowed to alias.  For an example, see the C front-end function
     'c_get_alias_set'.

  4. Tree alias-oracle

     The tree alias-oracle provides means to disambiguate two memory
     references and memory references against statements.  The following
     queries are available:

        * 'refs_may_alias_p'
        * 'ref_maybe_used_by_stmt_p'
        * 'stmt_may_clobber_ref_p'

     In addition to those two kind of statement walkers are available
     walking statements related to a reference ref.
     'walk_non_aliased_vuses' walks over dominating memory defining
     statements and calls back if the statement does not clobber ref
     providing the non-aliased VUSE. The walk stops at the first
     clobbering statement or if asked to.  'walk_aliased_vdefs' walks
     over dominating memory defining statements and calls back on each
     statement clobbering ref providing its aliasing VDEF. The walk
     stops if asked to.

==============================================================================
File: gccint.info,  Node: |Memory_model|,  Prev: |Alias_analysis|,  Up: |Tree_SSA|
==============================================================================

                                                                  *Memory_model*

13.5 Memory model
-----------------

The memory model used by the middle-end models that of the C/C++
languages.  The middle-end has the notion of an effective type of a
memory region which is used for type-based alias analysis.

 The following is a refinement of ISO C99 6.5/6, clarifying the block
copy case to follow common sense and extending the concept of a dynamic
effective type to objects with a declared type as required for C++.

     The effective type of an object for an access to its stored value is
     the declared type of the object or the effective type determined by
     a previous store to it.  If a value is stored into an object through
     an lvalue having a type that is not a character type, then the
     type of the lvalue becomes the effective type of the object for that
     access and for subsequent accesses that do not modify the stored value.
     If a value is copied into an object using memcpy or memmove,
     or is copied as an array of character type, then the effective type
     of the modified object for that access and for subsequent accesses that
     do not modify the value is undetermined.  For all other accesses to an
     object, the effective type of the object is simply the type of the
     lvalue used for the access.

==============================================================================
File: gccint.info,  Node: |RTL|,  Next: |Control_Flow|,  Prev: |Tree_SSA|,  Up: |Top|
==============================================================================

                                                                           *RTL*

14 RTL Representation
=====================

The last part of the compiler work is done on a low-level intermediate
representation called Register Transfer Language.  In this language, the
instructions to be output are described, pretty much one by one, in an
algebraic form that describes what the instruction does.

 RTL is inspired by Lisp lists.  It has both an internal form, made up
of structures that point at other structures, and a textual form that is
used in the machine description and in printed debugging dumps.  The
textual form uses nested parentheses to indicate the pointers in the
internal form.

MENU

* |RTL_Objects|::       Expressions vs vectors vs strings vs integers.
* |RTL_Classes|::       Categories of RTL expression objects, and their structure.
* |Accessors|::         Macros to access expression operands or vector elts.
* |Special_Accessors|:: Macros to access specific annotations on RTL.
* |Flags|::             Other flags in an RTL expression.
* |Machine_Modes|::     Describing the size and format of a datum.
* |Constants|::         Expressions with constant values.
* |Regs_and_Memory|::   Expressions representing register contents or memory.
* |Arithmetic|::        Expressions representing arithmetic on other expressions.
* |Comparisons|::       Expressions representing comparison of expressions.
* |Bit_Fields|::        Expressions representing bit-fields in memory or reg.
* |Vector_Operations|:: Expressions involving vector datatypes.
* |Conversions|::       Extending, truncating, floating or fixing.
* |RTL_Declarations|::  Declaring volatility, constancy, etc.
* |Side_Effects|::      Expressions for storing in registers, etc.
* |Incdec|::            Embedded side-effects for autoincrement addressing.
* |Assembler|::         Representing 'asm' with operands.
* |Debug_Information|:: Expressions representing debugging information.
* |Insns|::             Expression types for entire insns.
* |Calls|::             RTL representation of function call insns.
* |Sharing|::           Some expressions are unique; others must be copied.
* |Reading_RTL|::       Reading textual RTL from a file.

==============================================================================
File: gccint.info,  Node: |RTL_Objects|,  Next: |RTL_Classes|,  Up: |RTL|
==============================================================================

                                                                   *RTL_Objects*

14.1 RTL Object Types
---------------------

RTL uses five kinds of objects: expressions, integers, wide integers,
strings and vectors.  Expressions are the most important ones.  An RTL
expression ("RTX", for short) is a C structure, but it is usually
referred to with a pointer; a type that is given the typedef name 'rtx'.

 An integer is simply an 'int'; their written form uses decimal digits.
A wide integer is an integral object whose type is 'HOST_WIDE_INT';
their written form uses decimal digits.

 A string is a sequence of characters.  In core it is represented as a
'char *' in usual C fashion, and it is written in C syntax as well.
However, strings in RTL may never be null.  If you write an empty string
in a machine description, it is represented in core as a null pointer
rather than as a pointer to a null character.  In certain contexts,
these null pointers instead of strings are valid.  Within RTL code,
strings are most commonly found inside 'symbol_ref' expressions, but
they appear in other contexts in the RTL expressions that make up
machine descriptions.

 In a machine description, strings are normally written with double
quotes, as you would in C.  However, strings in machine descriptions may
extend over many lines, which is invalid C, and adjacent string
constants are not concatenated as they are in C.  Any string constant
may be surrounded with a single set of parentheses.  Sometimes this
makes the machine description easier to read.

 There is also a special syntax for strings, which can be useful when C
code is embedded in a machine description.  Wherever a string can
appear, it is also valid to write a C-style brace block.  The entire
brace block, including the outermost pair of braces, is considered to be
the string constant.  Double quote characters inside the braces are not
special.  Therefore, if you write string constants in the C code, you
need not escape each quote character with a backslash.

 A vector contains an arbitrary number of pointers to expressions.  The
number of elements in the vector is explicitly present in the vector.
The written form of a vector consists of square brackets ('[...]')
surrounding the elements, in sequence and with whitespace separating
them.  Vectors of length zero are not created; null pointers are used
instead.

 Expressions are classified by "expression codes" (also called RTX
codes).  The expression code is a name defined in 'rtl.def', which is
also (in uppercase) a C enumeration constant.  The possible expression
codes and their meanings are machine-independent.  The code of an RTX
can be extracted with the macro 'GET_CODE (X)' and altered with
'PUT_CODE (X, NEWCODE)'.

 The expression code determines how many operands the expression
contains, and what kinds of objects they are.  In RTL, unlike Lisp, you
cannot tell by looking at an operand what kind of object it is.
Instead, you must know from its context--from the expression code of the
containing expression.  For example, in an expression of code 'subreg',
the first operand is to be regarded as an expression and the second
operand as a polynomial integer.  In an expression of code 'plus', there
are two operands, both of which are to be regarded as expressions.  In a
'symbol_ref' expression, there is one operand, which is to be regarded
as a string.

 Expressions are written as parentheses containing the name of the
expression type, its flags and machine mode if any, and then the
operands of the expression (separated by spaces).

 Expression code names in the 'md' file are written in lowercase, but
when they appear in C code they are written in uppercase.  In this
manual, they are shown as follows: 'const_int'.

 In a few contexts a null pointer is valid where an expression is
normally wanted.  The written form of this is '(nil)'.

==============================================================================
File: gccint.info,  Node: |RTL_Classes|,  Next: |Accessors|,  Prev: |RTL_Objects|,  Up: |RTL|
==============================================================================

                                                                   *RTL_Classes*

14.2 RTL Classes and Formats
----------------------------

The various expression codes are divided into several "classes", which
are represented by single characters.  You can determine the class of an
RTX code with the macro 'GET_RTX_CLASS (CODE)'.  Currently, 'rtl.def'
defines these classes:

'RTX_OBJ'
     An RTX code that represents an actual object, such as a register
     ('REG') or a memory location ('MEM', 'SYMBOL_REF').  'LO_SUM') is
     also included; instead, 'SUBREG' and 'STRICT_LOW_PART' are not in
     this class, but in class 'RTX_EXTRA'.

'RTX_CONST_OBJ'
     An RTX code that represents a constant object.  'HIGH' is also
     included in this class.

'RTX_COMPARE'
     An RTX code for a non-symmetric comparison, such as 'GEU' or 'LT'.

'RTX_COMM_COMPARE'
     An RTX code for a symmetric (commutative) comparison, such as 'EQ'
     or 'ORDERED'.

'RTX_UNARY'
     An RTX code for a unary arithmetic operation, such as 'NEG', 'NOT',
     or 'ABS'.  This category also includes value extension (sign or
     zero) and conversions between integer and floating point.

'RTX_COMM_ARITH'
     An RTX code for a commutative binary operation, such as 'PLUS' or
     'AND'.  'NE' and 'EQ' are comparisons, so they have class
     'RTX_COMM_COMPARE'.

'RTX_BIN_ARITH'
     An RTX code for a non-commutative binary operation, such as
     'MINUS', 'DIV', or 'ASHIFTRT'.

'RTX_BITFIELD_OPS'
     An RTX code for a bit-field operation.  Currently only
     'ZERO_EXTRACT' and 'SIGN_EXTRACT'.  These have three inputs and are
     lvalues (so they can be used for insertion as well).  *Note
     Bit-Fields::.

'RTX_TERNARY'
     An RTX code for other three input operations.  Currently only
     'IF_THEN_ELSE', 'VEC_MERGE', 'SIGN_EXTRACT', 'ZERO_EXTRACT', and
     'FMA'.

'RTX_INSN'
     An RTX code for an entire instruction: 'INSN', 'JUMP_INSN', and
     'CALL_INSN'.  *Note Insns::.

'RTX_MATCH'
     An RTX code for something that matches in insns, such as
     'MATCH_DUP'.  These only occur in machine descriptions.

'RTX_AUTOINC'
     An RTX code for an auto-increment addressing mode, such as
     'POST_INC'.  'XEXP (X, 0)' gives the auto-modified register.

'RTX_EXTRA'
     All other RTX codes.  This category includes the remaining codes
     used only in machine descriptions ('DEFINE_*', etc.).  It also
     includes all the codes describing side effects ('SET', 'USE',
     'CLOBBER', etc.)  and the non-insns that may appear on an insn
     chain, such as 'NOTE', 'BARRIER', and 'CODE_LABEL'.  'SUBREG' is
     also part of this class.

 For each expression code, 'rtl.def' specifies the number of contained
objects and their kinds using a sequence of characters called the
"format" of the expression code.  For example, the format of 'subreg' is
'ep'.

 These are the most commonly used format characters:

'e'
     An expression (actually a pointer to an expression).

'i'
     An integer.

'w'
     A wide integer.

's'
     A string.

'E'
     A vector of expressions.

 A few other format characters are used occasionally:

'u'
     'u' is equivalent to 'e' except that it is printed differently in
     debugging dumps.  It is used for pointers to insns.

'n'
     'n' is equivalent to 'i' except that it is printed differently in
     debugging dumps.  It is used for the line number or code number of
     a 'note' insn.

'S'
     'S' indicates a string which is optional.  In the RTL objects in
     core, 'S' is equivalent to 's', but when the object is read, from
     an 'md' file, the string value of this operand may be omitted.  An
     omitted string is taken to be the null string.

'V'
     'V' indicates a vector which is optional.  In the RTL objects in
     core, 'V' is equivalent to 'E', but when the object is read from an
     'md' file, the vector value of this operand may be omitted.  An
     omitted vector is effectively the same as a vector of no elements.

'B'
     'B' indicates a pointer to basic block structure.

'p'
     A polynomial integer.  At present this is used only for
     'SUBREG_BYTE'.

'0'
     '0' means a slot whose contents do not fit any normal category.
     '0' slots are not printed at all in dumps, and are often used in
     special ways by small parts of the compiler.

 There are macros to get the number of operands and the format of an
expression code:

'GET_RTX_LENGTH (CODE)'
     Number of operands of an RTX of code CODE.

'GET_RTX_FORMAT (CODE)'
     The format of an RTX of code CODE, as a C string.

 Some classes of RTX codes always have the same format.  For example, it
is safe to assume that all comparison operations have format 'ee'.

'RTX_UNARY'
     All codes of this class have format 'e'.

'RTX_BIN_ARITH'
'RTX_COMM_ARITH'
'RTX_COMM_COMPARE'
'RTX_COMPARE'
     All codes of these classes have format 'ee'.

'RTX_BITFIELD_OPS'
'RTX_TERNARY'
     All codes of these classes have format 'eee'.

'RTX_INSN'
     All codes of this class have formats that begin with 'iuueiee'.
     *Note Insns::.  Note that not all RTL objects linked onto an insn
     chain are of class 'RTX_INSN'.

'RTX_CONST_OBJ'
'RTX_OBJ'
'RTX_MATCH'
'RTX_EXTRA'
     You can make no assumptions about the format of these codes.

==============================================================================
File: gccint.info,  Node: |Accessors|,  Next: |Special_Accessors|,  Prev: |RTL_Classes|,  Up: |RTL|
==============================================================================

                                                                     *Accessors*

14.3 Access to Operands
-----------------------

Operands of expressions are accessed using the macros 'XEXP', 'XINT',
'XWINT' and 'XSTR'.  Each of these macros takes two arguments: an
expression-pointer (RTX) and an operand number (counting from zero).
Thus,

     XEXP (X, 2)

accesses operand 2 of expression X, as an expression.

     XINT (X, 2)

accesses the same operand as an integer.  'XSTR', used in the same
fashion, would access it as a string.

 Any operand can be accessed as an integer, as an expression or as a
string.  You must choose the correct method of access for the kind of
value actually stored in the operand.  You would do this based on the
expression code of the containing expression.  That is also how you
would know how many operands there are.

 For example, if X is an 'int_list' expression, you know that it has two
operands which can be correctly accessed as 'XINT (X, 0)' and 'XEXP (X,
1)'.  Incorrect accesses like 'XEXP (X, 0)' and 'XINT (X, 1)' would
compile, but would trigger an internal compiler error when rtl checking
is enabled.  Nothing stops you from writing 'XEXP (X, 28)' either, but
this will access memory past the end of the expression with
unpredictable results.

 Access to operands which are vectors is more complicated.  You can use
the macro 'XVEC' to get the vector-pointer itself, or the macros
'XVECEXP' and 'XVECLEN' to access the elements and length of a vector.

'XVEC (EXP, IDX)'
     Access the vector-pointer which is operand number IDX in EXP.

'XVECLEN (EXP, IDX)'
     Access the length (number of elements) in the vector which is in
     operand number IDX in EXP.  This value is an 'int'.

'XVECEXP (EXP, IDX, ELTNUM)'
     Access element number ELTNUM in the vector which is in operand
     number IDX in EXP.  This value is an RTX.

     It is up to you to make sure that ELTNUM is not negative and is
     less than 'XVECLEN (EXP, IDX)'.

 All the macros defined in this section expand into lvalues and
therefore can be used to assign the operands, lengths and vector
elements as well as to access them.

==============================================================================
File: gccint.info,  Node: |Special_Accessors|,  Next: |Flags|,  Prev: |Accessors|,  Up: |RTL|
==============================================================================

                                                             *Special_Accessors*

14.4 Access to Special Operands
-------------------------------

Some RTL nodes have special annotations associated with them.

'MEM'
     'MEM_ALIAS_SET (X)'
          If 0, X is not in any alias set, and may alias anything.
          Otherwise, X can only alias 'MEM's in a conflicting alias set.
          This value is set in a language-dependent manner in the
          front-end, and should not be altered in the back-end.  In some
          front-ends, these numbers may correspond in some way to types,
          or other language-level entities, but they need not, and the
          back-end makes no such assumptions.  These set numbers are
          tested with 'alias_sets_conflict_p'.

     'MEM_EXPR (X)'
          If this register is known to hold the value of some user-level
          declaration, this is that tree node.  It may also be a
          'COMPONENT_REF', in which case this is some field reference,
          and 'TREE_OPERAND (X, 0)' contains the declaration, or another
          'COMPONENT_REF', or null if there is no compile-time object
          associated with the reference.

     'MEM_OFFSET_KNOWN_P (X)'
          True if the offset of the memory reference from 'MEM_EXPR' is
          known.  'MEM_OFFSET (X)' provides the offset if so.

     'MEM_OFFSET (X)'
          The offset from the start of 'MEM_EXPR'.  The value is only
          valid if 'MEM_OFFSET_KNOWN_P (X)' is true.

     'MEM_SIZE_KNOWN_P (X)'
          True if the size of the memory reference is known.  'MEM_SIZE
          (X)' provides its size if so.

     'MEM_SIZE (X)'
          The size in bytes of the memory reference.  This is mostly
          relevant for 'BLKmode' references as otherwise the size is
          implied by the mode.  The value is only valid if
          'MEM_SIZE_KNOWN_P (X)' is true.

     'MEM_ALIGN (X)'
          The known alignment in bits of the memory reference.

     'MEM_ADDR_SPACE (X)'
          The address space of the memory reference.  This will commonly
          be zero for the generic address space.

'REG'
     'ORIGINAL_REGNO (X)'
          This field holds the number the register "originally" had; for
          a pseudo register turned into a hard reg this will hold the
          old pseudo register number.

     'REG_EXPR (X)'
          If this register is known to hold the value of some user-level
          declaration, this is that tree node.

     'REG_OFFSET (X)'
          If this register is known to hold the value of some user-level
          declaration, this is the offset into that logical storage.

'SYMBOL_REF'
     'SYMBOL_REF_DECL (X)'
          If the 'symbol_ref' X was created for a 'VAR_DECL' or a
          'FUNCTION_DECL', that tree is recorded here.  If this value is
          null, then X was created by back end code generation routines,
          and there is no associated front end symbol table entry.

          'SYMBOL_REF_DECL' may also point to a tree of class ''c'',
          that is, some sort of constant.  In this case, the
          'symbol_ref' is an entry in the per-file constant pool; again,
          there is no associated front end symbol table entry.

     'SYMBOL_REF_CONSTANT (X)'
          If 'CONSTANT_POOL_ADDRESS_P (X)' is true, this is the constant
          pool entry for X.  It is null otherwise.

     'SYMBOL_REF_DATA (X)'
          A field of opaque type used to store 'SYMBOL_REF_DECL' or
          'SYMBOL_REF_CONSTANT'.

     'SYMBOL_REF_FLAGS (X)'
          In a 'symbol_ref', this is used to communicate various
          predicates about the symbol.  Some of these are common enough
          to be computed by common code, some are specific to the
          target.  The common bits are:

          'SYMBOL_FLAG_FUNCTION'
               Set if the symbol refers to a function.

          'SYMBOL_FLAG_LOCAL'
               Set if the symbol is local to this "module".  See
               'TARGET_BINDS_LOCAL_P'.

          'SYMBOL_FLAG_EXTERNAL'
               Set if this symbol is not defined in this translation
               unit.  Note that this is not the inverse of
               'SYMBOL_FLAG_LOCAL'.

          'SYMBOL_FLAG_SMALL'
               Set if the symbol is located in the small data section.
               See 'TARGET_IN_SMALL_DATA_P'.

          'SYMBOL_REF_TLS_MODEL (X)'
               This is a multi-bit field accessor that returns the
               'tls_model' to be used for a thread-local storage symbol.
               It returns zero for non-thread-local symbols.

          'SYMBOL_FLAG_HAS_BLOCK_INFO'
               Set if the symbol has 'SYMBOL_REF_BLOCK' and
               'SYMBOL_REF_BLOCK_OFFSET' fields.

          'SYMBOL_FLAG_ANCHOR'
               Set if the symbol is used as a section anchor.  "Section
               anchors" are symbols that have a known position within an
               'object_block' and that can be used to access nearby
               members of that block.  They are used to implement
               '-fsection-anchors'.

               If this flag is set, then 'SYMBOL_FLAG_HAS_BLOCK_INFO'
               will be too.

          Bits beginning with 'SYMBOL_FLAG_MACH_DEP' are available for
          the target's use.

'SYMBOL_REF_BLOCK (X)'
     If 'SYMBOL_REF_HAS_BLOCK_INFO_P (X)', this is the 'object_block'
     structure to which the symbol belongs, or 'NULL' if it has not been
     assigned a block.

'SYMBOL_REF_BLOCK_OFFSET (X)'
     If 'SYMBOL_REF_HAS_BLOCK_INFO_P (X)', this is the offset of X from
     the first object in 'SYMBOL_REF_BLOCK (X)'.  The value is negative
     if X has not yet been assigned to a block, or it has not been given
     an offset within that block.

==============================================================================
File: gccint.info,  Node: |Flags|,  Next: |Machine_Modes|,  Prev: |Special_Accessors|,  Up: |RTL|
==============================================================================

                                                                         *Flags*

14.5 Flags in an RTL Expression
-------------------------------

RTL expressions contain several flags (one-bit bit-fields) that are used
in certain types of expression.  Most often they are accessed with the
following macros, which expand into lvalues.

'CROSSING_JUMP_P (X)'
     Nonzero in a 'jump_insn' if it crosses between hot and cold
     sections, which could potentially be very far apart in the
     executable.  The presence of this flag indicates to other
     optimizations that this branching instruction should not be
     "collapsed" into a simpler branching construct.  It is used when
     the optimization to partition basic blocks into hot and cold
     sections is turned on.

'CONSTANT_POOL_ADDRESS_P (X)'
     Nonzero in a 'symbol_ref' if it refers to part of the current
     function's constant pool.  For most targets these addresses are in
     a '.rodata' section entirely separate from the function, but for
     some targets the addresses are close to the beginning of the
     function.  In either case GCC assumes these addresses can be
     addressed directly, perhaps with the help of base registers.
     Stored in the 'unchanging' field and printed as '/u'.

'INSN_ANNULLED_BRANCH_P (X)'
     In a 'jump_insn', 'call_insn', or 'insn' indicates that the branch
     is an annulling one.  See the discussion under 'sequence' below.
     Stored in the 'unchanging' field and printed as '/u'.

'INSN_DELETED_P (X)'
     In an 'insn', 'call_insn', 'jump_insn', 'code_label',
     'jump_table_data', 'barrier', or 'note', nonzero if the insn has
     been deleted.  Stored in the 'volatil' field and printed as '/v'.

'INSN_FROM_TARGET_P (X)'
     In an 'insn' or 'jump_insn' or 'call_insn' in a delay slot of a
     branch, indicates that the insn is from the target of the branch.
     If the branch insn has 'INSN_ANNULLED_BRANCH_P' set, this insn will
     only be executed if the branch is taken.  For annulled branches
     with 'INSN_FROM_TARGET_P' clear, the insn will be executed only if
     the branch is not taken.  When 'INSN_ANNULLED_BRANCH_P' is not set,
     this insn will always be executed.  Stored in the 'in_struct' field
     and printed as '/s'.

'LABEL_PRESERVE_P (X)'
     In a 'code_label' or 'note', indicates that the label is referenced
     by code or data not visible to the RTL of a given function.  Labels
     referenced by a non-local goto will have this bit set.  Stored in
     the 'in_struct' field and printed as '/s'.

'LABEL_REF_NONLOCAL_P (X)'
     In 'label_ref' and 'reg_label' expressions, nonzero if this is a
     reference to a non-local label.  Stored in the 'volatil' field and
     printed as '/v'.

'MEM_KEEP_ALIAS_SET_P (X)'
     In 'mem' expressions, 1 if we should keep the alias set for this
     mem unchanged when we access a component.  Set to 1, for example,
     when we are already in a non-addressable component of an aggregate.
     Stored in the 'jump' field and printed as '/j'.

'MEM_VOLATILE_P (X)'
     In 'mem', 'asm_operands', and 'asm_input' expressions, nonzero for
     volatile memory references.  Stored in the 'volatil' field and
     printed as '/v'.

'MEM_NOTRAP_P (X)'
     In 'mem', nonzero for memory references that will not trap.  Stored
     in the 'call' field and printed as '/c'.

'MEM_POINTER (X)'
     Nonzero in a 'mem' if the memory reference holds a pointer.  Stored
     in the 'frame_related' field and printed as '/f'.

'MEM_READONLY_P (X)'
     Nonzero in a 'mem', if the memory is statically allocated and
     read-only.

     Read-only in this context means never modified during the lifetime
     of the program, not necessarily in ROM or in write-disabled pages.
     A common example of the later is a shared library's global offset
     table.  This table is initialized by the runtime loader, so the
     memory is technically writable, but after control is transferred
     from the runtime loader to the application, this memory will never
     be subsequently modified.

     Stored in the 'unchanging' field and printed as '/u'.

'PREFETCH_SCHEDULE_BARRIER_P (X)'
     In a 'prefetch', indicates that the prefetch is a scheduling
     barrier.  No other INSNs will be moved over it.  Stored in the
     'volatil' field and printed as '/v'.

'REG_FUNCTION_VALUE_P (X)'
     Nonzero in a 'reg' if it is the place in which this function's
     value is going to be returned.  (This happens only in a hard
     register.)  Stored in the 'return_val' field and printed as '/i'.

'REG_POINTER (X)'
     Nonzero in a 'reg' if the register holds a pointer.  Stored in the
     'frame_related' field and printed as '/f'.

'REG_USERVAR_P (X)'
     In a 'reg', nonzero if it corresponds to a variable present in the
     user's source code.  Zero for temporaries generated internally by
     the compiler.  Stored in the 'volatil' field and printed as '/v'.

     The same hard register may be used also for collecting the values
     of functions called by this one, but 'REG_FUNCTION_VALUE_P' is zero
     in this kind of use.

'RTL_CONST_CALL_P (X)'
     In a 'call_insn' indicates that the insn represents a call to a
     const function.  Stored in the 'unchanging' field and printed as
     '/u'.

'RTL_PURE_CALL_P (X)'
     In a 'call_insn' indicates that the insn represents a call to a
     pure function.  Stored in the 'return_val' field and printed as
     '/i'.

'RTL_CONST_OR_PURE_CALL_P (X)'
     In a 'call_insn', true if 'RTL_CONST_CALL_P' or 'RTL_PURE_CALL_P'
     is true.

'RTL_LOOPING_CONST_OR_PURE_CALL_P (X)'
     In a 'call_insn' indicates that the insn represents a possibly
     infinite looping call to a const or pure function.  Stored in the
     'call' field and printed as '/c'.  Only true if one of
     'RTL_CONST_CALL_P' or 'RTL_PURE_CALL_P' is true.

'RTX_FRAME_RELATED_P (X)'
     Nonzero in an 'insn', 'call_insn', 'jump_insn', 'barrier', or 'set'
     which is part of a function prologue and sets the stack pointer,
     sets the frame pointer, or saves a register.  This flag should also
     be set on an instruction that sets up a temporary register to use
     in place of the frame pointer.  Stored in the 'frame_related' field
     and printed as '/f'.

     In particular, on RISC targets where there are limits on the sizes
     of immediate constants, it is sometimes impossible to reach the
     register save area directly from the stack pointer.  In that case,
     a temporary register is used that is near enough to the register
     save area, and the Canonical Frame Address, i.e., DWARF2's logical
     frame pointer, register must (temporarily) be changed to be this
     temporary register.  So, the instruction that sets this temporary
     register must be marked as 'RTX_FRAME_RELATED_P'.

     If the marked instruction is overly complex (defined in terms of
     what 'dwarf2out_frame_debug_expr' can handle), you will also have
     to create a 'REG_FRAME_RELATED_EXPR' note and attach it to the
     instruction.  This note should contain a simple expression of the
     computation performed by this instruction, i.e., one that
     'dwarf2out_frame_debug_expr' can handle.

     This flag is required for exception handling support on targets
     with RTL prologues.

'SCHED_GROUP_P (X)'
     During instruction scheduling, in an 'insn', 'call_insn',
     'jump_insn' or 'jump_table_data', indicates that the previous insn
     must be scheduled together with this insn.  This is used to ensure
     that certain groups of instructions will not be split up by the
     instruction scheduling pass, for example, 'use' insns before a
     'call_insn' may not be separated from the 'call_insn'.  Stored in
     the 'in_struct' field and printed as '/s'.

'SET_IS_RETURN_P (X)'
     For a 'set', nonzero if it is for a return.  Stored in the 'jump'
     field and printed as '/j'.

'SIBLING_CALL_P (X)'
     For a 'call_insn', nonzero if the insn is a sibling call.  Stored
     in the 'jump' field and printed as '/j'.

'STRING_POOL_ADDRESS_P (X)'
     For a 'symbol_ref' expression, nonzero if it addresses this
     function's string constant pool.  Stored in the 'frame_related'
     field and printed as '/f'.

'SUBREG_PROMOTED_UNSIGNED_P (X)'
     Returns a value greater then zero for a 'subreg' that has
     'SUBREG_PROMOTED_VAR_P' nonzero if the object being referenced is
     kept zero-extended, zero if it is kept sign-extended, and less then
     zero if it is extended some other way via the 'ptr_extend'
     instruction.  Stored in the 'unchanging' field and 'volatil' field,
     printed as '/u' and '/v'.  This macro may only be used to get the
     value it may not be used to change the value.  Use
     'SUBREG_PROMOTED_UNSIGNED_SET' to change the value.

'SUBREG_PROMOTED_UNSIGNED_SET (X)'
     Set the 'unchanging' and 'volatil' fields in a 'subreg' to reflect
     zero, sign, or other extension.  If 'volatil' is zero, then
     'unchanging' as nonzero means zero extension and as zero means sign
     extension.  If 'volatil' is nonzero then some other type of
     extension was done via the 'ptr_extend' instruction.

'SUBREG_PROMOTED_VAR_P (X)'
     Nonzero in a 'subreg' if it was made when accessing an object that
     was promoted to a wider mode in accord with the 'PROMOTED_MODE'
     machine description macro (*note Storage Layout::).  In this case,
     the mode of the 'subreg' is the declared mode of the object and the
     mode of 'SUBREG_REG' is the mode of the register that holds the
     object.  Promoted variables are always either sign- or
     zero-extended to the wider mode on every assignment.  Stored in the
     'in_struct' field and printed as '/s'.

'SYMBOL_REF_USED (X)'
     In a 'symbol_ref', indicates that X has been used.  This is
     normally only used to ensure that X is only declared external once.
     Stored in the 'used' field.

'SYMBOL_REF_WEAK (X)'
     In a 'symbol_ref', indicates that X has been declared weak.  Stored
     in the 'return_val' field and printed as '/i'.

'SYMBOL_REF_FLAG (X)'
     In a 'symbol_ref', this is used as a flag for machine-specific
     purposes.  Stored in the 'volatil' field and printed as '/v'.

     Most uses of 'SYMBOL_REF_FLAG' are historic and may be subsumed by
     'SYMBOL_REF_FLAGS'.  Certainly use of 'SYMBOL_REF_FLAGS' is
     mandatory if the target requires more than one bit of storage.

 These are the fields to which the above macros refer:

'call'
     In a 'mem', 1 means that the memory reference will not trap.

     In a 'call', 1 means that this pure or const call may possibly
     infinite loop.

     In an RTL dump, this flag is represented as '/c'.

'frame_related'
     In an 'insn' or 'set' expression, 1 means that it is part of a
     function prologue and sets the stack pointer, sets the frame
     pointer, saves a register, or sets up a temporary register to use
     in place of the frame pointer.

     In 'reg' expressions, 1 means that the register holds a pointer.

     In 'mem' expressions, 1 means that the memory reference holds a
     pointer.

     In 'symbol_ref' expressions, 1 means that the reference addresses
     this function's string constant pool.

     In an RTL dump, this flag is represented as '/f'.

'in_struct'
     In 'reg' expressions, it is 1 if the register has its entire life
     contained within the test expression of some loop.

     In 'subreg' expressions, 1 means that the 'subreg' is accessing an
     object that has had its mode promoted from a wider mode.

     In 'label_ref' expressions, 1 means that the referenced label is
     outside the innermost loop containing the insn in which the
     'label_ref' was found.

     In 'code_label' expressions, it is 1 if the label may never be
     deleted.  This is used for labels which are the target of non-local
     gotos.  Such a label that would have been deleted is replaced with
     a 'note' of type 'NOTE_INSN_DELETED_LABEL'.

     In an 'insn' during dead-code elimination, 1 means that the insn is
     dead code.

     In an 'insn' or 'jump_insn' during reorg for an insn in the delay
     slot of a branch, 1 means that this insn is from the target of the
     branch.

     In an 'insn' during instruction scheduling, 1 means that this insn
     must be scheduled as part of a group together with the previous
     insn.

     In an RTL dump, this flag is represented as '/s'.

'return_val'
     In 'reg' expressions, 1 means the register contains the value to be
     returned by the current function.  On machines that pass parameters
     in registers, the same register number may be used for parameters
     as well, but this flag is not set on such uses.

     In 'symbol_ref' expressions, 1 means the referenced symbol is weak.

     In 'call' expressions, 1 means the call is pure.

     In an RTL dump, this flag is represented as '/i'.

'jump'
     In a 'mem' expression, 1 means we should keep the alias set for
     this mem unchanged when we access a component.

     In a 'set', 1 means it is for a return.

     In a 'call_insn', 1 means it is a sibling call.

     In a 'jump_insn', 1 means it is a crossing jump.

     In an RTL dump, this flag is represented as '/j'.

'unchanging'
     In 'reg' and 'mem' expressions, 1 means that the value of the
     expression never changes.

     In 'subreg' expressions, it is 1 if the 'subreg' references an
     unsigned object whose mode has been promoted to a wider mode.

     In an 'insn' or 'jump_insn' in the delay slot of a branch
     instruction, 1 means an annulling branch should be used.

     In a 'symbol_ref' expression, 1 means that this symbol addresses
     something in the per-function constant pool.

     In a 'call_insn' 1 means that this instruction is a call to a const
     function.

     In an RTL dump, this flag is represented as '/u'.

'used'
     This flag is used directly (without an access macro) at the end of
     RTL generation for a function, to count the number of times an
     expression appears in insns.  Expressions that appear more than
     once are copied, according to the rules for shared structure (*note
     Sharing::).

     For a 'reg', it is used directly (without an access macro) by the
     leaf register renumbering code to ensure that each register is only
     renumbered once.

     In a 'symbol_ref', it indicates that an external declaration for
     the symbol has already been written.

'volatil'
     In a 'mem', 'asm_operands', or 'asm_input' expression, it is 1 if
     the memory reference is volatile.  Volatile memory references may
     not be deleted, reordered or combined.

     In a 'symbol_ref' expression, it is used for machine-specific
     purposes.

     In a 'reg' expression, it is 1 if the value is a user-level
     variable.  0 indicates an internal compiler temporary.

     In an 'insn', 1 means the insn has been deleted.

     In 'label_ref' and 'reg_label' expressions, 1 means a reference to
     a non-local label.

     In 'prefetch' expressions, 1 means that the containing insn is a
     scheduling barrier.

     In an RTL dump, this flag is represented as '/v'.

==============================================================================
File: gccint.info,  Node: |Machine_Modes|,  Next: |Constants|,  Prev: |Flags|,  Up: |RTL|
==============================================================================

                                                                 *Machine_Modes*

14.6 Machine Modes
------------------

A machine mode describes a size of data object and the representation
used for it.  In the C code, machine modes are represented by an
enumeration type, 'machine_mode', defined in 'machmode.def'.  Each RTL
expression has room for a machine mode and so do certain kinds of tree
expressions (declarations and types, to be precise).

 In debugging dumps and machine descriptions, the machine mode of an RTL
expression is written after the expression code with a colon to separate
them.  The letters 'mode' which appear at the end of each machine mode
name are omitted.  For example, '(reg:SI 38)' is a 'reg' expression with
machine mode 'SImode'.  If the mode is 'VOIDmode', it is not written at
all.

 Here is a table of machine modes.  The term "byte" below refers to an
object of 'BITS_PER_UNIT' bits (*note Storage Layout::).

'BImode'
     "Bit" mode represents a single bit, for predicate registers.

'QImode'
     "Quarter-Integer" mode represents a single byte treated as an
     integer.

'HImode'
     "Half-Integer" mode represents a two-byte integer.

'PSImode'
     "Partial Single Integer" mode represents an integer which occupies
     four bytes but which doesn't really use all four.  On some
     machines, this is the right mode to use for pointers.

'SImode'
     "Single Integer" mode represents a four-byte integer.

'PDImode'
     "Partial Double Integer" mode represents an integer which occupies
     eight bytes but which doesn't really use all eight.  On some
     machines, this is the right mode to use for certain pointers.

'DImode'
     "Double Integer" mode represents an eight-byte integer.

'TImode'
     "Tetra Integer" (?)  mode represents a sixteen-byte integer.

'OImode'
     "Octa Integer" (?)  mode represents a thirty-two-byte integer.

'XImode'
     "Hexadeca Integer" (?)  mode represents a sixty-four-byte integer.

'QFmode'
     "Quarter-Floating" mode represents a quarter-precision (single
     byte) floating point number.

'HFmode'
     "Half-Floating" mode represents a half-precision (two byte)
     floating point number.

'TQFmode'
     "Three-Quarter-Floating" (?)  mode represents a
     three-quarter-precision (three byte) floating point number.

'SFmode'
     "Single Floating" mode represents a four byte floating point
     number.  In the common case, of a processor with IEEE arithmetic
     and 8-bit bytes, this is a single-precision IEEE floating point
     number; it can also be used for double-precision (on processors
     with 16-bit bytes) and single-precision VAX and IBM types.

'DFmode'
     "Double Floating" mode represents an eight byte floating point
     number.  In the common case, of a processor with IEEE arithmetic
     and 8-bit bytes, this is a double-precision IEEE floating point
     number.

'XFmode'
     "Extended Floating" mode represents an IEEE extended floating point
     number.  This mode only has 80 meaningful bits (ten bytes).  Some
     processors require such numbers to be padded to twelve bytes,
     others to sixteen; this mode is used for either.

'SDmode'
     "Single Decimal Floating" mode represents a four byte decimal
     floating point number (as distinct from conventional binary
     floating point).

'DDmode'
     "Double Decimal Floating" mode represents an eight byte decimal
     floating point number.

'TDmode'
     "Tetra Decimal Floating" mode represents a sixteen byte decimal
     floating point number all 128 of whose bits are meaningful.

'TFmode'
     "Tetra Floating" mode represents a sixteen byte floating point
     number all 128 of whose bits are meaningful.  One common use is the
     IEEE quad-precision format.

'QQmode'
     "Quarter-Fractional" mode represents a single byte treated as a
     signed fractional number.  The default format is "s.7".

'HQmode'
     "Half-Fractional" mode represents a two-byte signed fractional
     number.  The default format is "s.15".

'SQmode'
     "Single Fractional" mode represents a four-byte signed fractional
     number.  The default format is "s.31".

'DQmode'
     "Double Fractional" mode represents an eight-byte signed fractional
     number.  The default format is "s.63".

'TQmode'
     "Tetra Fractional" mode represents a sixteen-byte signed fractional
     number.  The default format is "s.127".

'UQQmode'
     "Unsigned Quarter-Fractional" mode represents a single byte treated
     as an unsigned fractional number.  The default format is ".8".

'UHQmode'
     "Unsigned Half-Fractional" mode represents a two-byte unsigned
     fractional number.  The default format is ".16".

'USQmode'
     "Unsigned Single Fractional" mode represents a four-byte unsigned
     fractional number.  The default format is ".32".

'UDQmode'
     "Unsigned Double Fractional" mode represents an eight-byte unsigned
     fractional number.  The default format is ".64".

'UTQmode'
     "Unsigned Tetra Fractional" mode represents a sixteen-byte unsigned
     fractional number.  The default format is ".128".

'HAmode'
     "Half-Accumulator" mode represents a two-byte signed accumulator.
     The default format is "s8.7".

'SAmode'
     "Single Accumulator" mode represents a four-byte signed
     accumulator.  The default format is "s16.15".

'DAmode'
     "Double Accumulator" mode represents an eight-byte signed
     accumulator.  The default format is "s32.31".

'TAmode'
     "Tetra Accumulator" mode represents a sixteen-byte signed
     accumulator.  The default format is "s64.63".

'UHAmode'
     "Unsigned Half-Accumulator" mode represents a two-byte unsigned
     accumulator.  The default format is "8.8".

'USAmode'
     "Unsigned Single Accumulator" mode represents a four-byte unsigned
     accumulator.  The default format is "16.16".

'UDAmode'
     "Unsigned Double Accumulator" mode represents an eight-byte
     unsigned accumulator.  The default format is "32.32".

'UTAmode'
     "Unsigned Tetra Accumulator" mode represents a sixteen-byte
     unsigned accumulator.  The default format is "64.64".

'CCmode'
     "Condition Code" mode represents the value of a condition code,
     which is a machine-specific set of bits used to represent the
     result of a comparison operation.  Other machine-specific modes may
     also be used for the condition code.  These modes are not used on
     machines that use 'cc0' (*note Condition Code::).

'BLKmode'
     "Block" mode represents values that are aggregates to which none of
     the other modes apply.  In RTL, only memory references can have
     this mode, and only if they appear in string-move or vector
     instructions.  On machines which have no such instructions,
     'BLKmode' will not appear in RTL.

'VOIDmode'
     Void mode means the absence of a mode or an unspecified mode.  For
     example, RTL expressions of code 'const_int' have mode 'VOIDmode'
     because they can be taken to have whatever mode the context
     requires.  In debugging dumps of RTL, 'VOIDmode' is expressed by
     the absence of any mode.

'QCmode, HCmode, SCmode, DCmode, XCmode, TCmode'
     These modes stand for a complex number represented as a pair of
     floating point values.  The floating point values are in 'QFmode',
     'HFmode', 'SFmode', 'DFmode', 'XFmode', and 'TFmode', respectively.

'CQImode, CHImode, CSImode, CDImode, CTImode, COImode, CPSImode'
     These modes stand for a complex number represented as a pair of
     integer values.  The integer values are in 'QImode', 'HImode',
     'SImode', 'DImode', 'TImode', 'OImode', and 'PSImode',
     respectively.

'BND32mode BND64mode'
     These modes stand for bounds for pointer of 32 and 64 bit size
     respectively.  Mode size is double pointer mode size.

 The machine description defines 'Pmode' as a C macro which expands into
the machine mode used for addresses.  Normally this is the mode whose
size is 'BITS_PER_WORD', 'SImode' on 32-bit machines.

 The only modes which a machine description must support are 'QImode',
and the modes corresponding to 'BITS_PER_WORD', 'FLOAT_TYPE_SIZE' and
'DOUBLE_TYPE_SIZE'.  The compiler will attempt to use 'DImode' for
8-byte structures and unions, but this can be prevented by overriding
the definition of 'MAX_FIXED_MODE_SIZE'.  Alternatively, you can have
the compiler use 'TImode' for 16-byte structures and unions.  Likewise,
you can arrange for the C type 'short int' to avoid using 'HImode'.

 Very few explicit references to machine modes remain in the compiler
and these few references will soon be removed.  Instead, the machine
modes are divided into mode classes.  These are represented by the
enumeration type 'enum mode_class' defined in 'machmode.h'.  The
possible mode classes are:

'MODE_INT'
     Integer modes.  By default these are 'BImode', 'QImode', 'HImode',
     'SImode', 'DImode', 'TImode', and 'OImode'.

'MODE_PARTIAL_INT'
     The "partial integer" modes, 'PQImode', 'PHImode', 'PSImode' and
     'PDImode'.

'MODE_FLOAT'
     Floating point modes.  By default these are 'QFmode', 'HFmode',
     'TQFmode', 'SFmode', 'DFmode', 'XFmode' and 'TFmode'.

'MODE_DECIMAL_FLOAT'
     Decimal floating point modes.  By default these are 'SDmode',
     'DDmode' and 'TDmode'.

'MODE_FRACT'
     Signed fractional modes.  By default these are 'QQmode', 'HQmode',
     'SQmode', 'DQmode' and 'TQmode'.

'MODE_UFRACT'
     Unsigned fractional modes.  By default these are 'UQQmode',
     'UHQmode', 'USQmode', 'UDQmode' and 'UTQmode'.

'MODE_ACCUM'
     Signed accumulator modes.  By default these are 'HAmode', 'SAmode',
     'DAmode' and 'TAmode'.

'MODE_UACCUM'
     Unsigned accumulator modes.  By default these are 'UHAmode',
     'USAmode', 'UDAmode' and 'UTAmode'.

'MODE_COMPLEX_INT'
     Complex integer modes.  (These are not currently implemented).

'MODE_COMPLEX_FLOAT'
     Complex floating point modes.  By default these are 'QCmode',
     'HCmode', 'SCmode', 'DCmode', 'XCmode', and 'TCmode'.

'MODE_CC'
     Modes representing condition code values.  These are 'CCmode' plus
     any 'CC_MODE' modes listed in the 'MACHINE-modes.def'.  *Note Jump
     Patterns::, also see *note Condition Code::.

'MODE_POINTER_BOUNDS'
     Pointer bounds modes.  Used to represent values of pointer bounds
     type.  Operations in these modes may be executed as NOPs depending
     on hardware features and environment setup.

'MODE_RANDOM'
     This is a catchall mode class for modes which don't fit into the
     above classes.  Currently 'VOIDmode' and 'BLKmode' are in
     'MODE_RANDOM'.

 'machmode.h' also defines various wrapper classes that combine a
'machine_mode' with a static assertion that a particular condition
holds.  The classes are:

'scalar_int_mode'
     A mode that has class 'MODE_INT' or 'MODE_PARTIAL_INT'.

'scalar_float_mode'
     A mode that has class 'MODE_FLOAT' or 'MODE_DECIMAL_FLOAT'.

'scalar_mode'
     A mode that holds a single numerical value.  In practice this means
     that the mode is a 'scalar_int_mode', is a 'scalar_float_mode', or
     has class 'MODE_FRACT', 'MODE_UFRACT', 'MODE_ACCUM', 'MODE_UACCUM'
     or 'MODE_POINTER_BOUNDS'.

'complex_mode'
     A mode that has class 'MODE_COMPLEX_INT' or 'MODE_COMPLEX_FLOAT'.

'fixed_size_mode'
     A mode whose size is known at compile time.

 Named modes use the most constrained of the available wrapper classes,
if one exists, otherwise they use 'machine_mode'.  For example, 'QImode'
is a 'scalar_int_mode', 'SFmode' is a 'scalar_float_mode' and 'BLKmode'
is a plain 'machine_mode'.  It is possible to refer to any mode as a raw
'machine_mode' by adding the 'E_' prefix, where 'E' stands for
"enumeration".  For example, the raw 'machine_mode' names of the modes
just mentioned are 'E_QImode', 'E_SFmode' and 'E_BLKmode' respectively.

 The wrapper classes implicitly convert to 'machine_mode' and to any
wrapper class that represents a more general condition; for example
'scalar_int_mode' and 'scalar_float_mode' both convert to 'scalar_mode'
and all three convert to 'fixed_size_mode'.  The classes act like
'machine_mode's that accept only certain named modes.

 'machmode.h' also defines a template class 'opt_mode<T>' that holds a
'T' or nothing, where 'T' can be either 'machine_mode' or one of the
wrapper classes above.  The main operations on an 'opt_mode<T>' X are as
follows:

'X.exists ()'
     Return true if X holds a mode rather than nothing.

'X.exists (&Y)'
     Return true if X holds a mode rather than nothing, storing the mode
     in Y if so.  Y must be assignment-compatible with T.

'X.require ()'
     Assert that X holds a mode rather than nothing and return that
     mode.

'X = Y'
     Set X to Y, where Y is a T or implicitly converts to a T.

 The default constructor sets an 'opt_mode<T>' to nothing.  There is
also a constructor that takes an initial value of type T.

 It is possible to use the 'is-a.h' accessors on a 'machine_mode' or
machine mode wrapper X:

'is_a <T> (X)'
     Return true if X meets the conditions for wrapper class T.

'is_a <T> (X, &Y)'
     Return true if X meets the conditions for wrapper class T, storing
     it in Y if so.  Y must be assignment-compatible with T.

'as_a <T> (X)'
     Assert that X meets the conditions for wrapper class T and return
     it as a T.

'dyn_cast <T> (X)'
     Return an 'opt_mode<T>' that holds X if X meets the conditions for
     wrapper class T and that holds nothing otherwise.

 The purpose of these wrapper classes is to give stronger static type
checking.  For example, if a function takes a 'scalar_int_mode', a
caller that has a general 'machine_mode' must either check or assert
that the code is indeed a scalar integer first, using one of the
functions above.

 The wrapper classes are normal C++ classes, with user-defined
constructors.  Sometimes it is useful to have a POD version of the same
type, particularly if the type appears in a 'union'.  The template class
'pod_mode<T>' provides a POD version of wrapper class T.  It is
assignment-compatible with T and implicitly converts to both
'machine_mode' and T.

 Here are some C macros that relate to machine modes:

'GET_MODE (X)'
     Returns the machine mode of the RTX X.

'PUT_MODE (X, NEWMODE)'
     Alters the machine mode of the RTX X to be NEWMODE.

'NUM_MACHINE_MODES'
     Stands for the number of machine modes available on the target
     machine.  This is one greater than the largest numeric value of any
     machine mode.

'GET_MODE_NAME (M)'
     Returns the name of mode M as a string.

'GET_MODE_CLASS (M)'
     Returns the mode class of mode M.

'GET_MODE_WIDER_MODE (M)'
     Returns the next wider natural mode.  For example, the expression
     'GET_MODE_WIDER_MODE (QImode)' returns 'HImode'.

'GET_MODE_SIZE (M)'
     Returns the size in bytes of a datum of mode M.

'GET_MODE_BITSIZE (M)'
     Returns the size in bits of a datum of mode M.

'GET_MODE_IBIT (M)'
     Returns the number of integral bits of a datum of fixed-point mode
     M.

'GET_MODE_FBIT (M)'
     Returns the number of fractional bits of a datum of fixed-point
     mode M.

'GET_MODE_MASK (M)'
     Returns a bitmask containing 1 for all bits in a word that fit
     within mode M.  This macro can only be used for modes whose bitsize
     is less than or equal to 'HOST_BITS_PER_INT'.

'GET_MODE_ALIGNMENT (M)'
     Return the required alignment, in bits, for an object of mode M.

'GET_MODE_UNIT_SIZE (M)'
     Returns the size in bytes of the subunits of a datum of mode M.
     This is the same as 'GET_MODE_SIZE' except in the case of complex
     modes.  For them, the unit size is the size of the real or
     imaginary part.

'GET_MODE_NUNITS (M)'
     Returns the number of units contained in a mode, i.e.,
     'GET_MODE_SIZE' divided by 'GET_MODE_UNIT_SIZE'.

'GET_CLASS_NARROWEST_MODE (C)'
     Returns the narrowest mode in mode class C.

 The following 3 variables are defined on every target.  They can be
used to allocate buffers that are guaranteed to be large enough to hold
any value that can be represented on the target.  The first two can be
overridden by defining them in the target's mode.def file, however, the
value must be a constant that can determined very early in the
compilation process.  The third symbol cannot be overridden.

'BITS_PER_UNIT'
     The number of bits in an addressable storage unit (byte).  If you
     do not define this, the default is 8.

'MAX_BITSIZE_MODE_ANY_INT'
     The maximum bitsize of any mode that is used in integer math.  This
     should be overridden by the target if it uses large integers as
     containers for larger vectors but otherwise never uses the contents
     to compute integer values.

'MAX_BITSIZE_MODE_ANY_MODE'
     The bitsize of the largest mode on the target.  The default value
     is the largest mode size given in the mode definition file, which
     is always correct for targets whose modes have a fixed size.
     Targets that might increase the size of a mode beyond this default
     should define 'MAX_BITSIZE_MODE_ANY_MODE' to the actual upper limit
     in 'MACHINE-modes.def'.

 The global variables 'byte_mode' and 'word_mode' contain modes whose
classes are 'MODE_INT' and whose bitsizes are either 'BITS_PER_UNIT' or
'BITS_PER_WORD', respectively.  On 32-bit machines, these are 'QImode'
and 'SImode', respectively.

==============================================================================
File: gccint.info,  Node: |Constants|,  Next: |Regs_and_Memory|,  Prev: |Machine_Modes|,  Up: |RTL|
==============================================================================

                                                                     *Constants*

14.7 Constant Expression Types
------------------------------

The simplest RTL expressions are those that represent constant values.

'(const_int I)'
     This type of expression represents the integer value I.  I is
     customarily accessed with the macro 'INTVAL' as in 'INTVAL (EXP)',
     which is equivalent to 'XWINT (EXP, 0)'.

     Constants generated for modes with fewer bits than in
     'HOST_WIDE_INT' must be sign extended to full width (e.g., with
     'gen_int_mode').  For constants for modes with more bits than in
     'HOST_WIDE_INT' the implied high order bits of that constant are
     copies of the top bit.  Note however that values are neither
     inherently signed nor inherently unsigned; where necessary,
     signedness is determined by the rtl operation instead.

     There is only one expression object for the integer value zero; it
     is the value of the variable 'const0_rtx'.  Likewise, the only
     expression for integer value one is found in 'const1_rtx', the only
     expression for integer value two is found in 'const2_rtx', and the
     only expression for integer value negative one is found in
     'constm1_rtx'.  Any attempt to create an expression of code
     'const_int' and value zero, one, two or negative one will return
     'const0_rtx', 'const1_rtx', 'const2_rtx' or 'constm1_rtx' as
     appropriate.

     Similarly, there is only one object for the integer whose value is
     'STORE_FLAG_VALUE'.  It is found in 'const_true_rtx'.  If
     'STORE_FLAG_VALUE' is one, 'const_true_rtx' and 'const1_rtx' will
     point to the same object.  If 'STORE_FLAG_VALUE' is -1,
     'const_true_rtx' and 'constm1_rtx' will point to the same object.

'(const_double:M I0 I1 ...)'
     This represents either a floating-point constant of mode M or (on
     older ports that do not define 'TARGET_SUPPORTS_WIDE_INT') an
     integer constant too large to fit into 'HOST_BITS_PER_WIDE_INT'
     bits but small enough to fit within twice that number of bits.  In
     the latter case, M will be 'VOIDmode'.  For integral values
     constants for modes with more bits than twice the number in
     'HOST_WIDE_INT' the implied high order bits of that constant are
     copies of the top bit of 'CONST_DOUBLE_HIGH'.  Note however that
     integral values are neither inherently signed nor inherently
     unsigned; where necessary, signedness is determined by the rtl
     operation instead.

     On more modern ports, 'CONST_DOUBLE' only represents floating point
     values.  New ports define 'TARGET_SUPPORTS_WIDE_INT' to make this
     designation.

     If M is 'VOIDmode', the bits of the value are stored in I0 and I1.
     I0 is customarily accessed with the macro 'CONST_DOUBLE_LOW' and I1
     with 'CONST_DOUBLE_HIGH'.

     If the constant is floating point (regardless of its precision),
     then the number of integers used to store the value depends on the
     size of 'REAL_VALUE_TYPE' (*note Floating Point::).  The integers
     represent a floating point number, but not precisely in the target
     machine's or host machine's floating point format.  To convert them
     to the precise bit pattern used by the target machine, use the
     macro 'REAL_VALUE_TO_TARGET_DOUBLE' and friends (*note Data
     Output::).

'(const_wide_int:M NUNITS ELT0 ...)'
     This contains an array of 'HOST_WIDE_INT's that is large enough to
     hold any constant that can be represented on the target.  This form
     of rtl is only used on targets that define
     'TARGET_SUPPORTS_WIDE_INT' to be nonzero and then 'CONST_DOUBLE's
     are only used to hold floating-point values.  If the target leaves
     'TARGET_SUPPORTS_WIDE_INT' defined as 0, 'CONST_WIDE_INT's are not
     used and 'CONST_DOUBLE's are as they were before.

     The values are stored in a compressed format.  The higher-order 0s
     or -1s are not represented if they are just the logical sign
     extension of the number that is represented.

'CONST_WIDE_INT_VEC (CODE)'
     Returns the entire array of 'HOST_WIDE_INT's that are used to store
     the value.  This macro should be rarely used.

'CONST_WIDE_INT_NUNITS (CODE)'
     The number of 'HOST_WIDE_INT's used to represent the number.  Note
     that this generally is smaller than the number of 'HOST_WIDE_INT's
     implied by the mode size.

'CONST_WIDE_INT_ELT (CODE,I)'
     Returns the 'i'th element of the array.  Element 0 is contains the
     low order bits of the constant.

'(const_fixed:M ...)'
     Represents a fixed-point constant of mode M.  The operand is a data
     structure of type 'struct fixed_value' and is accessed with the
     macro 'CONST_FIXED_VALUE'.  The high part of data is accessed with
     'CONST_FIXED_VALUE_HIGH'; the low part is accessed with
     'CONST_FIXED_VALUE_LOW'.

'(const_poly_int:M [C0 C1 ...])'
     Represents a 'poly_int'-style polynomial integer with coefficients
     C0, C1, ....  The coefficients are 'wide_int'-based integers rather
     than rtxes.  'CONST_POLY_INT_COEFFS' gives the values of individual
     coefficients (which is mostly only useful in low-level routines)
     and 'const_poly_int_value' gives the full 'poly_int' value.

'(const_vector:M [X0 X1 ...])'
     Represents a vector constant.  The values in square brackets are
     elements of the vector, which are always 'const_int',
     'const_wide_int', 'const_double' or 'const_fixed' expressions.

     Each vector constant V is treated as a specific instance of an
     arbitrary-length sequence that itself contains
     'CONST_VECTOR_NPATTERNS (V)' interleaved patterns.  Each pattern
     has the form:

          { BASE0, BASE1, BASE1 + STEP, BASE1 + STEP * 2, ... }

     The first three elements in each pattern are enough to determine
     the values of the other elements.  However, if all STEPs are zero,
     only the first two elements are needed.  If in addition each BASE1
     is equal to the corresponding BASE0, only the first element in each
     pattern is needed.  The number of determining elements per pattern
     is given by 'CONST_VECTOR_NELTS_PER_PATTERN (V)'.

     For example, the constant:

          { 0, 1, 2, 6, 3, 8, 4, 10, 5, 12, 6, 14, 7, 16, 8, 18 }

     is interpreted as an interleaving of the sequences:

          { 0, 2, 3, 4, 5, 6, 7, 8 }
          { 1, 6, 8, 10, 12, 14, 16, 18 }

     where the sequences are represented by the following patterns:

          BASE0 == 0, BASE1 == 2, STEP == 1
          BASE0 == 1, BASE1 == 6, STEP == 2

     In this case:

          CONST_VECTOR_NPATTERNS (V) == 2
          CONST_VECTOR_NELTS_PER_PATTERN (V) == 3

     Thus the first 6 elements ('{ 0, 1, 2, 6, 3, 8 }') are enough to
     determine the whole sequence; we refer to them as the "encoded"
     elements.  They are the only elements present in the square
     brackets for variable-length 'const_vector's (i.e. for
     'const_vector's whose mode M has a variable number of elements).
     However, as a convenience to code that needs to handle both
     'const_vector's and 'parallel's, all elements are present in the
     square brackets for fixed-length 'const_vector's; the encoding
     scheme simply reduces the amount of work involved in processing
     constants that follow a regular pattern.

     Sometimes this scheme can create two possible encodings of the same
     vector.  For example { 0, 1 } could be seen as two patterns with
     one element each or one pattern with two elements (BASE0 and
     BASE1).  The canonical encoding is always the one with the fewest
     patterns or (if both encodings have the same number of petterns)
     the one with the fewest encoded elements.

     'const_vector_encoding_nelts (V)' gives the total number of encoded
     elements in V, which is 6 in the example above.
     'CONST_VECTOR_ENCODED_ELT (V, I)' accesses the value of encoded
     element I.

     'CONST_VECTOR_DUPLICATE_P (V)' is true if V simply contains
     repeated instances of 'CONST_VECTOR_NPATTERNS (V)' values.  This is
     a shorthand for testing 'CONST_VECTOR_NELTS_PER_PATTERN (V) == 1'.

     'CONST_VECTOR_STEPPED_P (V)' is true if at least one pattern in V
     has a nonzero step.  This is a shorthand for testing
     'CONST_VECTOR_NELTS_PER_PATTERN (V) == 3'.

     'CONST_VECTOR_NUNITS (V)' gives the total number of elements in V;
     it is a shorthand for getting the number of units in 'GET_MODE
     (V)'.

     The utility function 'const_vector_elt' gives the value of an
     arbitrary element as an 'rtx'.  'const_vector_int_elt' gives the
     same value as a 'wide_int'.

'(const_string STR)'
     Represents a constant string with value STR.  Currently this is
     used only for insn attributes (*note Insn Attributes::) since
     constant strings in C are placed in memory.

'(symbol_ref:MODE SYMBOL)'
     Represents the value of an assembler label for data.  SYMBOL is a
     string that describes the name of the assembler label.  If it
     starts with a '*', the label is the rest of SYMBOL not including
     the '*'.  Otherwise, the label is SYMBOL, usually prefixed with
     '_'.

     The 'symbol_ref' contains a mode, which is usually 'Pmode'.
     Usually that is the only mode for which a symbol is directly valid.

'(label_ref:MODE LABEL)'
     Represents the value of an assembler label for code.  It contains
     one operand, an expression, which must be a 'code_label' or a
     'note' of type 'NOTE_INSN_DELETED_LABEL' that appears in the
     instruction sequence to identify the place where the label should
     go.

     The reason for using a distinct expression type for code label
     references is so that jump optimization can distinguish them.

     The 'label_ref' contains a mode, which is usually 'Pmode'.  Usually
     that is the only mode for which a label is directly valid.

'(const:M EXP)'
     Represents a constant that is the result of an assembly-time
     arithmetic computation.  The operand, EXP, contains only
     'const_int', 'symbol_ref', 'label_ref' or 'unspec' expressions,
     combined with 'plus' and 'minus'.  Any such 'unspec's are
     target-specific and typically represent some form of relocation
     operator.  M should be a valid address mode.

'(high:M EXP)'
     Represents the high-order bits of EXP.  The number of bits is
     machine-dependent and is normally the number of bits specified in
     an instruction that initializes the high order bits of a register.
     It is used with 'lo_sum' to represent the typical two-instruction
     sequence used in RISC machines to reference large immediate values
     and/or link-time constants such as global memory addresses.  In the
     latter case, M is 'Pmode' and EXP is usually a constant expression
     involving 'symbol_ref'.

 The macro 'CONST0_RTX (MODE)' refers to an expression with value 0 in
mode MODE.  If mode MODE is of mode class 'MODE_INT', it returns
'const0_rtx'.  If mode MODE is of mode class 'MODE_FLOAT', it returns a
'CONST_DOUBLE' expression in mode MODE.  Otherwise, it returns a
'CONST_VECTOR' expression in mode MODE.  Similarly, the macro
'CONST1_RTX (MODE)' refers to an expression with value 1 in mode MODE
and similarly for 'CONST2_RTX'.  The 'CONST1_RTX' and 'CONST2_RTX'
macros are undefined for vector modes.

==============================================================================
File: gccint.info,  Node: |Regs_and_Memory|,  Next: |Arithmetic|,  Prev: |Constants|,  Up: |RTL|
==============================================================================

                                                               *Regs_and_Memory*

14.8 Registers and Memory
-------------------------

Here are the RTL expression types for describing access to machine
registers and to main memory.

'(reg:M N)'
     For small values of the integer N (those that are less than
     'FIRST_PSEUDO_REGISTER'), this stands for a reference to machine
     register number N: a "hard register".  For larger values of N, it
     stands for a temporary value or "pseudo register".  The compiler's
     strategy is to generate code assuming an unlimited number of such
     pseudo registers, and later convert them into hard registers or
     into memory references.

     M is the machine mode of the reference.  It is necessary because
     machines can generally refer to each register in more than one
     mode.  For example, a register may contain a full word but there
     may be instructions to refer to it as a half word or as a single
     byte, as well as instructions to refer to it as a floating point
     number of various precisions.

     Even for a register that the machine can access in only one mode,
     the mode must always be specified.

     The symbol 'FIRST_PSEUDO_REGISTER' is defined by the machine
     description, since the number of hard registers on the machine is
     an invariant characteristic of the machine.  Note, however, that
     not all of the machine registers must be general registers.  All
     the machine registers that can be used for storage of data are
     given hard register numbers, even those that can be used only in
     certain instructions or can hold only certain types of data.

     A hard register may be accessed in various modes throughout one
     function, but each pseudo register is given a natural mode and is
     accessed only in that mode.  When it is necessary to describe an
     access to a pseudo register using a nonnatural mode, a 'subreg'
     expression is used.

     A 'reg' expression with a machine mode that specifies more than one
     word of data may actually stand for several consecutive registers.
     If in addition the register number specifies a hardware register,
     then it actually represents several consecutive hardware registers
     starting with the specified one.

     Each pseudo register number used in a function's RTL code is
     represented by a unique 'reg' expression.

     Some pseudo register numbers, those within the range of
     'FIRST_VIRTUAL_REGISTER' to 'LAST_VIRTUAL_REGISTER' only appear
     during the RTL generation phase and are eliminated before the
     optimization phases.  These represent locations in the stack frame
     that cannot be determined until RTL generation for the function has
     been completed.  The following virtual register numbers are
     defined:

     'VIRTUAL_INCOMING_ARGS_REGNUM'
          This points to the first word of the incoming arguments passed
          on the stack.  Normally these arguments are placed there by
          the caller, but the callee may have pushed some arguments that
          were previously passed in registers.

          When RTL generation is complete, this virtual register is
          replaced by the sum of the register given by
          'ARG_POINTER_REGNUM' and the value of 'FIRST_PARM_OFFSET'.

     'VIRTUAL_STACK_VARS_REGNUM'
          If 'FRAME_GROWS_DOWNWARD' is defined to a nonzero value, this
          points to immediately above the first variable on the stack.
          Otherwise, it points to the first variable on the stack.

          'VIRTUAL_STACK_VARS_REGNUM' is replaced with the sum of the
          register given by 'FRAME_POINTER_REGNUM' and the value
          'TARGET_STARTING_FRAME_OFFSET'.

     'VIRTUAL_STACK_DYNAMIC_REGNUM'
          This points to the location of dynamically allocated memory on
          the stack immediately after the stack pointer has been
          adjusted by the amount of memory desired.

          This virtual register is replaced by the sum of the register
          given by 'STACK_POINTER_REGNUM' and the value
          'STACK_DYNAMIC_OFFSET'.

     'VIRTUAL_OUTGOING_ARGS_REGNUM'
          This points to the location in the stack at which outgoing
          arguments should be written when the stack is pre-pushed
          (arguments pushed using push insns should always use
          'STACK_POINTER_REGNUM').

          This virtual register is replaced by the sum of the register
          given by 'STACK_POINTER_REGNUM' and the value
          'STACK_POINTER_OFFSET'.

'(subreg:M1 REG:M2 BYTENUM)'

     'subreg' expressions are used to refer to a register in a machine
     mode other than its natural one, or to refer to one register of a
     multi-part 'reg' that actually refers to several registers.

     Each pseudo register has a natural mode.  If it is necessary to
     operate on it in a different mode, the register must be enclosed in
     a 'subreg'.

     There are currently three supported types for the first operand of
     a 'subreg':
        * pseudo registers This is the most common case.  Most 'subreg's
          have pseudo 'reg's as their first operand.

        * mem 'subreg's of 'mem' were common in earlier versions of GCC
          and are still supported.  During the reload pass these are
          replaced by plain 'mem's.  On machines that do not do
          instruction scheduling, use of 'subreg's of 'mem' are still
          used, but this is no longer recommended.  Such 'subreg's are
          considered to be 'register_operand's rather than
          'memory_operand's before and during reload.  Because of this,
          the scheduling passes cannot properly schedule instructions
          with 'subreg's of 'mem', so for machines that do scheduling,
          'subreg's of 'mem' should never be used.  To support this, the
          combine and recog passes have explicit code to inhibit the
          creation of 'subreg's of 'mem' when 'INSN_SCHEDULING' is
          defined.

          The use of 'subreg's of 'mem' after the reload pass is an area
          that is not well understood and should be avoided.  There is
          still some code in the compiler to support this, but this code
          has possibly rotted.  This use of 'subreg's is discouraged and
          will most likely not be supported in the future.

        * hard registers It is seldom necessary to wrap hard registers
          in 'subreg's; such registers would normally reduce to a single
          'reg' rtx.  This use of 'subreg's is discouraged and may not
          be supported in the future.

     'subreg's of 'subreg's are not supported.  Using
     'simplify_gen_subreg' is the recommended way to avoid this problem.

     'subreg's come in two distinct flavors, each having its own usage
     and rules:

     Paradoxical subregs
          When M1 is strictly wider than M2, the 'subreg' expression is
          called "paradoxical".  The canonical test for this class of
          'subreg' is:

               paradoxical_subreg_p (M1, M2)

          Paradoxical 'subreg's can be used as both lvalues and rvalues.
          When used as an lvalue, the low-order bits of the source value
          are stored in REG and the high-order bits are discarded.  When
          used as an rvalue, the low-order bits of the 'subreg' are
          taken from REG while the high-order bits may or may not be
          defined.

          The high-order bits of rvalues are defined in the following
          circumstances:

             * 'subreg's of 'mem' When M2 is smaller than a word, the
               macro 'LOAD_EXTEND_OP', can control how the high-order
               bits are defined.

             * 'subreg' of 'reg's The upper bits are defined when
               'SUBREG_PROMOTED_VAR_P' is true.
               'SUBREG_PROMOTED_UNSIGNED_P' describes what the upper
               bits hold.  Such subregs usually represent local
               variables, register variables and parameter pseudo
               variables that have been promoted to a wider mode.

          BYTENUM is always zero for a paradoxical 'subreg', even on
          big-endian targets.

          For example, the paradoxical 'subreg':

               (set (subreg:SI (reg:HI X) 0) Y)

          stores the lower 2 bytes of Y in X and discards the upper 2
          bytes.  A subsequent:

               (set Z (subreg:SI (reg:HI X) 0))

          would set the lower two bytes of Z to Y and set the upper two
          bytes to an unknown value assuming 'SUBREG_PROMOTED_VAR_P' is
          false.

     Normal subregs
          When M1 is at least as narrow as M2 the 'subreg' expression is
          called "normal".

          Normal 'subreg's restrict consideration to certain bits of
          REG.  For this purpose, REG is divided into
          individually-addressable blocks in which each block has:

               REGMODE_NATURAL_SIZE (M2)

          bytes.  Usually the value is 'UNITS_PER_WORD'; that is, most
          targets usually treat each word of a register as being
          independently addressable.

          There are two types of normal 'subreg'.  If M1 is known to be
          no bigger than a block, the 'subreg' refers to the
          least-significant part (or "lowpart") of one block of REG.  If
          M1 is known to be larger than a block, the 'subreg' refers to
          two or more complete blocks.

          When used as an lvalue, 'subreg' is a block-based accessor.
          Storing to a 'subreg' modifies all the blocks of REG that
          overlap the 'subreg', but it leaves the other blocks of REG
          alone.

          When storing to a normal 'subreg' that is smaller than a
          block, the other bits of the referenced block are usually left
          in an undefined state.  This laxity makes it easier to
          generate efficient code for such instructions.  To represent
          an instruction that preserves all the bits outside of those in
          the 'subreg', use 'strict_low_part' or 'zero_extract' around
          the 'subreg'.

          BYTENUM must identify the offset of the first byte of the
          'subreg' from the start of REG, assuming that REG is laid out
          in memory order.  The memory order of bytes is defined by two
          target macros, 'WORDS_BIG_ENDIAN' and 'BYTES_BIG_ENDIAN':

             * 'WORDS_BIG_ENDIAN', if set to 1, says that byte number
               zero is part of the most significant word; otherwise, it
               is part of the least significant word.

             * 'BYTES_BIG_ENDIAN', if set to 1, says that byte number
               zero is the most significant byte within a word;
               otherwise, it is the least significant byte within a
               word.

          On a few targets, 'FLOAT_WORDS_BIG_ENDIAN' disagrees with
          'WORDS_BIG_ENDIAN'.  However, most parts of the compiler treat
          floating point values as if they had the same endianness as
          integer values.  This works because they handle them solely as
          a collection of integer values, with no particular numerical
          value.  Only real.c and the runtime libraries care about
          'FLOAT_WORDS_BIG_ENDIAN'.

          Thus,

               (subreg:HI (reg:SI X) 2)

          on a 'BYTES_BIG_ENDIAN', 'UNITS_PER_WORD == 4' target is the
          same as

               (subreg:HI (reg:SI X) 0)

          on a little-endian, 'UNITS_PER_WORD == 4' target.  Both
          'subreg's access the lower two bytes of register X.

          Note that the byte offset is a polynomial integer; it may not
          be a compile-time constant on targets with variable-sized
          modes.  However, the restrictions above mean that there are
          only a certain set of acceptable offsets for a given
          combination of M1 and M2.  The compiler can always tell which
          blocks a valid subreg occupies, and whether the subreg is a
          lowpart of a block.

     A 'MODE_PARTIAL_INT' mode behaves as if it were as wide as the
     corresponding 'MODE_INT' mode, except that it has an unknown number
     of undefined bits.  For example:

          (subreg:PSI (reg:SI 0) 0)

     accesses the whole of '(reg:SI 0)', but the exact relationship
     between the 'PSImode' value and the 'SImode' value is not defined.
     If we assume 'REGMODE_NATURAL_SIZE (DImode) <= 4', then the
     following two 'subreg's:

          (subreg:PSI (reg:DI 0) 0)
          (subreg:PSI (reg:DI 0) 4)

     represent independent 4-byte accesses to the two halves of '(reg:DI
     0)'.  Both 'subreg's have an unknown number of undefined bits.

     If 'REGMODE_NATURAL_SIZE (PSImode) <= 2' then these two 'subreg's:

          (subreg:HI (reg:PSI 0) 0)
          (subreg:HI (reg:PSI 0) 2)

     represent independent 2-byte accesses that together span the whole
     of '(reg:PSI 0)'.  Storing to the first 'subreg' does not affect
     the value of the second, and vice versa.  '(reg:PSI 0)' has an
     unknown number of undefined bits, so the assignment:

          (set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))

     does not guarantee that '(subreg:HI (reg:PSI 0) 0)' has the value
     '(reg:HI 4)'.

     The rules above apply to both pseudo REGs and hard REGs.  If the
     semantics are not correct for particular combinations of M1, M2 and
     hard REG, the target-specific code must ensure that those
     combinations are never used.  For example:

          TARGET_CAN_CHANGE_MODE_CLASS (M2, M1, CLASS)

     must be false for every class CLASS that includes REG.

     GCC must be able to determine at compile time whether a subreg is
     paradoxical, whether it occupies a whole number of blocks, or
     whether it is a lowpart of a block.  This means that certain
     combinations of variable-sized mode are not permitted.  For
     example, if M2 holds N 'SI' values, where N is greater than zero,
     it is not possible to form a 'DI' 'subreg' of it; such a 'subreg'
     would be paradoxical when N is 1 but not when N is greater than 1.

     The first operand of a 'subreg' expression is customarily accessed
     with the 'SUBREG_REG' macro and the second operand is customarily
     accessed with the 'SUBREG_BYTE' macro.

     It has been several years since a platform in which
     'BYTES_BIG_ENDIAN' not equal to 'WORDS_BIG_ENDIAN' has been tested.
     Anyone wishing to support such a platform in the future may be
     confronted with code rot.

'(scratch:M)'
     This represents a scratch register that will be required for the
     execution of a single instruction and not used subsequently.  It is
     converted into a 'reg' by either the local register allocator or
     the reload pass.

     'scratch' is usually present inside a 'clobber' operation (*note
     Side Effects::).

'(cc0)'
     This refers to the machine's condition code register.  It has no
     operands and may not have a machine mode.  There are two ways to
     use it:

        * To stand for a complete set of condition code flags.  This is
          best on most machines, where each comparison sets the entire
          series of flags.

          With this technique, '(cc0)' may be validly used in only two
          contexts: as the destination of an assignment (in test and
          compare instructions) and in comparison operators comparing
          against zero ('const_int' with value zero; that is to say,
          'const0_rtx').

        * To stand for a single flag that is the result of a single
          condition.  This is useful on machines that have only a single
          flag bit, and in which comparison instructions must specify
          the condition to test.

          With this technique, '(cc0)' may be validly used in only two
          contexts: as the destination of an assignment (in test and
          compare instructions) where the source is a comparison
          operator, and as the first operand of 'if_then_else' (in a
          conditional branch).

     There is only one expression object of code 'cc0'; it is the value
     of the variable 'cc0_rtx'.  Any attempt to create an expression of
     code 'cc0' will return 'cc0_rtx'.

     Instructions can set the condition code implicitly.  On many
     machines, nearly all instructions set the condition code based on
     the value that they compute or store.  It is not necessary to
     record these actions explicitly in the RTL because the machine
     description includes a prescription for recognizing the
     instructions that do so (by means of the macro 'NOTICE_UPDATE_CC').
     *Note Condition Code::.  Only instructions whose sole purpose is to
     set the condition code, and instructions that use the condition
     code, need mention '(cc0)'.

     On some machines, the condition code register is given a register
     number and a 'reg' is used instead of '(cc0)'.  This is usually the
     preferable approach if only a small subset of instructions modify
     the condition code.  Other machines store condition codes in
     general registers; in such cases a pseudo register should be used.

     Some machines, such as the SPARC and RS/6000, have two sets of
     arithmetic instructions, one that sets and one that does not set
     the condition code.  This is best handled by normally generating
     the instruction that does not set the condition code, and making a
     pattern that both performs the arithmetic and sets the condition
     code register (which would not be '(cc0)' in this case).  For
     examples, search for 'addcc' and 'andcc' in 'sparc.md'.

'(pc)'
     This represents the machine's program counter.  It has no operands
     and may not have a machine mode.  '(pc)' may be validly used only
     in certain specific contexts in jump instructions.

     There is only one expression object of code 'pc'; it is the value
     of the variable 'pc_rtx'.  Any attempt to create an expression of
     code 'pc' will return 'pc_rtx'.

     All instructions that do not jump alter the program counter
     implicitly by incrementing it, but there is no need to mention this
     in the RTL.

'(mem:M ADDR ALIAS)'
     This RTX represents a reference to main memory at an address
     represented by the expression ADDR.  M specifies how large a unit
     of memory is accessed.  ALIAS specifies an alias set for the
     reference.  In general two items are in different alias sets if
     they cannot reference the same memory address.

     The construct '(mem:BLK (scratch))' is considered to alias all
     other memories.  Thus it may be used as a memory barrier in
     epilogue stack deallocation patterns.

'(concatM RTX RTX)'
     This RTX represents the concatenation of two other RTXs.  This is
     used for complex values.  It should only appear in the RTL attached
     to declarations and during RTL generation.  It should not appear in
     the ordinary insn chain.

'(concatnM [RTX ...])'
     This RTX represents the concatenation of all the RTX to make a
     single value.  Like 'concat', this should only appear in
     declarations, and not in the insn chain.

==============================================================================
File: gccint.info,  Node: |Arithmetic|,  Next: |Comparisons|,  Prev: |Regs_and_Memory|,  Up: |RTL|
==============================================================================

                                                                    *Arithmetic*

14.9 RTL Expressions for Arithmetic
-----------------------------------

Unless otherwise specified, all the operands of arithmetic expressions
must be valid for mode M.  An operand is valid for mode M if it has mode
M, or if it is a 'const_int' or 'const_double' and M is a mode of class
'MODE_INT'.

 For commutative binary operations, constants should be placed in the
second operand.

'(plus:M X Y)'
'(ss_plus:M X Y)'
'(us_plus:M X Y)'

     These three expressions all represent the sum of the values
     represented by X and Y carried out in machine mode M.  They differ
     in their behavior on overflow of integer modes.  'plus' wraps round
     modulo the width of M; 'ss_plus' saturates at the maximum signed
     value representable in M; 'us_plus' saturates at the maximum
     unsigned value.

'(lo_sum:M X Y)'

     This expression represents the sum of X and the low-order bits of
     Y.  It is used with 'high' (*note Constants::) to represent the
     typical two-instruction sequence used in RISC machines to reference
     large immediate values and/or link-time constants such as global
     memory addresses.  In the latter case, M is 'Pmode' and Y is
     usually a constant expression involving 'symbol_ref'.

     The number of low order bits is machine-dependent but is normally
     the number of bits in mode M minus the number of bits set by
     'high'.

'(minus:M X Y)'
'(ss_minus:M X Y)'
'(us_minus:M X Y)'

     These three expressions represent the result of subtracting Y from
     X, carried out in mode M.  Behavior on overflow is the same as for
     the three variants of 'plus' (see above).

'(compare:M X Y)'
     Represents the result of subtracting Y from X for purposes of
     comparison.  The result is computed without overflow, as if with
     infinite precision.

     Of course, machines cannot really subtract with infinite precision.
     However, they can pretend to do so when only the sign of the result
     will be used, which is the case when the result is stored in the
     condition code.  And that is the _only_ way this kind of expression
     may validly be used: as a value to be stored in the condition
     codes, either '(cc0)' or a register.  *Note Comparisons::.

     The mode M is not related to the modes of X and Y, but instead is
     the mode of the condition code value.  If '(cc0)' is used, it is
     'VOIDmode'.  Otherwise it is some mode in class 'MODE_CC', often
     'CCmode'.  *Note Condition Code::.  If M is 'VOIDmode' or 'CCmode',
     the operation returns sufficient information (in an unspecified
     format) so that any comparison operator can be applied to the
     result of the 'COMPARE' operation.  For other modes in class
     'MODE_CC', the operation only returns a subset of this information.

     Normally, X and Y must have the same mode.  Otherwise, 'compare' is
     valid only if the mode of X is in class 'MODE_INT' and Y is a
     'const_int' or 'const_double' with mode 'VOIDmode'.  The mode of X
     determines what mode the comparison is to be done in; thus it must
     not be 'VOIDmode'.

     If one of the operands is a constant, it should be placed in the
     second operand and the comparison code adjusted as appropriate.

     A 'compare' specifying two 'VOIDmode' constants is not valid since
     there is no way to know in what mode the comparison is to be
     performed; the comparison must either be folded during the
     compilation or the first operand must be loaded into a register
     while its mode is still known.

'(neg:M X)'
'(ss_neg:M X)'
'(us_neg:M X)'
     These two expressions represent the negation (subtraction from
     zero) of the value represented by X, carried out in mode M.  They
     differ in the behavior on overflow of integer modes.  In the case
     of 'neg', the negation of the operand may be a number not
     representable in mode M, in which case it is truncated to M.
     'ss_neg' and 'us_neg' ensure that an out-of-bounds result saturates
     to the maximum or minimum signed or unsigned value.

'(mult:M X Y)'
'(ss_mult:M X Y)'
'(us_mult:M X Y)'
     Represents the signed product of the values represented by X and Y
     carried out in machine mode M.  'ss_mult' and 'us_mult' ensure that
     an out-of-bounds result saturates to the maximum or minimum signed
     or unsigned value.

     Some machines support a multiplication that generates a product
     wider than the operands.  Write the pattern for this as

          (mult:M (sign_extend:M X) (sign_extend:M Y))

     where M is wider than the modes of X and Y, which need not be the
     same.

     For unsigned widening multiplication, use the same idiom, but with
     'zero_extend' instead of 'sign_extend'.

'(fma:M X Y Z)'
     Represents the 'fma', 'fmaf', and 'fmal' builtin functions, which
     compute 'X * Y + Z' without doing an intermediate rounding step.

'(div:M X Y)'
'(ss_div:M X Y)'
     Represents the quotient in signed division of X by Y, carried out
     in machine mode M.  If M is a floating point mode, it represents
     the exact quotient; otherwise, the integerized quotient.  'ss_div'
     ensures that an out-of-bounds result saturates to the maximum or
     minimum signed value.

     Some machines have division instructions in which the operands and
     quotient widths are not all the same; you should represent such
     instructions using 'truncate' and 'sign_extend' as in,

          (truncate:M1 (div:M2 X (sign_extend:M2 Y)))

'(udiv:M X Y)'
'(us_div:M X Y)'
     Like 'div' but represents unsigned division.  'us_div' ensures that
     an out-of-bounds result saturates to the maximum or minimum
     unsigned value.

'(mod:M X Y)'
'(umod:M X Y)'
     Like 'div' and 'udiv' but represent the remainder instead of the
     quotient.

'(smin:M X Y)'
'(smax:M X Y)'
     Represents the smaller (for 'smin') or larger (for 'smax') of X and
     Y, interpreted as signed values in mode M.  When used with floating
     point, if both operands are zeros, or if either operand is 'NaN',
     then it is unspecified which of the two operands is returned as the
     result.

'(umin:M X Y)'
'(umax:M X Y)'
     Like 'smin' and 'smax', but the values are interpreted as unsigned
     integers.

'(not:M X)'
     Represents the bitwise complement of the value represented by X,
     carried out in mode M, which must be a fixed-point machine mode.

'(and:M X Y)'
     Represents the bitwise logical-and of the values represented by X
     and Y, carried out in machine mode M, which must be a fixed-point
     machine mode.

'(ior:M X Y)'
     Represents the bitwise inclusive-or of the values represented by X
     and Y, carried out in machine mode M, which must be a fixed-point
     mode.

'(xor:M X Y)'
     Represents the bitwise exclusive-or of the values represented by X
     and Y, carried out in machine mode M, which must be a fixed-point
     mode.

'(ashift:M X C)'
'(ss_ashift:M X C)'
'(us_ashift:M X C)'
     These three expressions represent the result of arithmetically
     shifting X left by C places.  They differ in their behavior on
     overflow of integer modes.  An 'ashift' operation is a plain shift
     with no special behavior in case of a change in the sign bit;
     'ss_ashift' and 'us_ashift' saturates to the minimum or maximum
     representable value if any of the bits shifted out differs from the
     final sign bit.

     X have mode M, a fixed-point machine mode.  C be a fixed-point mode
     or be a constant with mode 'VOIDmode'; which mode is determined by
     the mode called for in the machine description entry for the
     left-shift instruction.  For example, on the VAX, the mode of C is
     'QImode' regardless of M.

'(lshiftrt:M X C)'
'(ashiftrt:M X C)'
     Like 'ashift' but for right shift.  Unlike the case for left shift,
     these two operations are distinct.

'(rotate:M X C)'
'(rotatert:M X C)'
     Similar but represent left and right rotate.  If C is a constant,
     use 'rotate'.

'(abs:M X)'
'(ss_abs:M X)'
     Represents the absolute value of X, computed in mode M.  'ss_abs'
     ensures that an out-of-bounds result saturates to the maximum
     signed value.

'(sqrt:M X)'
     Represents the square root of X, computed in mode M.  Most often M
     will be a floating point mode.

'(ffs:M X)'
     Represents one plus the index of the least significant 1-bit in X,
     represented as an integer of mode M.  (The value is zero if X is
     zero.)  The mode of X must be M or 'VOIDmode'.

'(clrsb:M X)'
     Represents the number of redundant leading sign bits in X,
     represented as an integer of mode M, starting at the most
     significant bit position.  This is one less than the number of
     leading sign bits (either 0 or 1), with no special cases.  The mode
     of X must be M or 'VOIDmode'.

'(clz:M X)'
     Represents the number of leading 0-bits in X, represented as an
     integer of mode M, starting at the most significant bit position.
     If X is zero, the value is determined by
     'CLZ_DEFINED_VALUE_AT_ZERO' (*note Misc::).  Note that this is one
     of the few expressions that is not invariant under widening.  The
     mode of X must be M or 'VOIDmode'.

'(ctz:M X)'
     Represents the number of trailing 0-bits in X, represented as an
     integer of mode M, starting at the least significant bit position.
     If X is zero, the value is determined by
     'CTZ_DEFINED_VALUE_AT_ZERO' (*note Misc::).  Except for this case,
     'ctz(x)' is equivalent to 'ffs(X) - 1'.  The mode of X must be M or
     'VOIDmode'.

'(popcount:M X)'
     Represents the number of 1-bits in X, represented as an integer of
     mode M.  The mode of X must be M or 'VOIDmode'.

'(parity:M X)'
     Represents the number of 1-bits modulo 2 in X, represented as an
     integer of mode M.  The mode of X must be M or 'VOIDmode'.

'(bswap:M X)'
     Represents the value X with the order of bytes reversed, carried
     out in mode M, which must be a fixed-point machine mode.  The mode
     of X must be M or 'VOIDmode'.

==============================================================================
File: gccint.info,  Node: |Comparisons|,  Next: |Bit_Fields|,  Prev: |Arithmetic|,  Up: |RTL|
==============================================================================

                                                                   *Comparisons*

14.10 Comparison Operations
---------------------------

Comparison operators test a relation on two operands and are considered
to represent a machine-dependent nonzero value described by, but not
necessarily equal to, 'STORE_FLAG_VALUE' (*note Misc::) if the relation
holds, or zero if it does not, for comparison operators whose results
have a 'MODE_INT' mode, 'FLOAT_STORE_FLAG_VALUE' (*note Misc::) if the
relation holds, or zero if it does not, for comparison operators that
return floating-point values, and a vector of either
'VECTOR_STORE_FLAG_VALUE' (*note Misc::) if the relation holds, or of
zeros if it does not, for comparison operators that return vector
results.  The mode of the comparison operation is independent of the
mode of the data being compared.  If the comparison operation is being
tested (e.g., the first operand of an 'if_then_else'), the mode must be
'VOIDmode'.

 There are two ways that comparison operations may be used.  The
comparison operators may be used to compare the condition codes '(cc0)'
against zero, as in '(eq (cc0) (const_int 0))'.  Such a construct
actually refers to the result of the preceding instruction in which the
condition codes were set.  The instruction setting the condition code
must be adjacent to the instruction using the condition code; only
'note' insns may separate them.

 Alternatively, a comparison operation may directly compare two data
objects.  The mode of the comparison is determined by the operands; they
must both be valid for a common machine mode.  A comparison with both
operands constant would be invalid as the machine mode could not be
deduced from it, but such a comparison should never exist in RTL due to
constant folding.

 In the example above, if '(cc0)' were last set to '(compare X Y)', the
comparison operation is identical to '(eq X Y)'.  Usually only one style
of comparisons is supported on a particular machine, but the combine
pass will try to merge the operations to produce the 'eq' shown in case
it exists in the context of the particular insn involved.

 Inequality comparisons come in two flavors, signed and unsigned.  Thus,
there are distinct expression codes 'gt' and 'gtu' for signed and
unsigned greater-than.  These can produce different results for the same
pair of integer values: for example, 1 is signed greater-than -1 but not
unsigned greater-than, because -1 when regarded as unsigned is actually
'0xffffffff' which is greater than 1.

 The signed comparisons are also used for floating point values.
Floating point comparisons are distinguished by the machine modes of the
operands.

'(eq:M X Y)'
     'STORE_FLAG_VALUE' if the values represented by X and Y are equal,
     otherwise 0.

'(ne:M X Y)'
     'STORE_FLAG_VALUE' if the values represented by X and Y are not
     equal, otherwise 0.

'(gt:M X Y)'
     'STORE_FLAG_VALUE' if the X is greater than Y.  If they are
     fixed-point, the comparison is done in a signed sense.

'(gtu:M X Y)'
     Like 'gt' but does unsigned comparison, on fixed-point numbers
     only.

'(lt:M X Y)'
'(ltu:M X Y)'
     Like 'gt' and 'gtu' but test for "less than".

'(ge:M X Y)'
'(geu:M X Y)'
     Like 'gt' and 'gtu' but test for "greater than or equal".

'(le:M X Y)'
'(leu:M X Y)'
     Like 'gt' and 'gtu' but test for "less than or equal".

'(if_then_else COND THEN ELSE)'
     This is not a comparison operation but is listed here because it is
     always used in conjunction with a comparison operation.  To be
     precise, COND is a comparison expression.  This expression
     represents a choice, according to COND, between the value
     represented by THEN and the one represented by ELSE.

     On most machines, 'if_then_else' expressions are valid only to
     express conditional jumps.

'(cond [TEST1 VALUE1 TEST2 VALUE2 ...] DEFAULT)'
     Similar to 'if_then_else', but more general.  Each of TEST1, TEST2,
     ... is performed in turn.  The result of this expression is the
     VALUE corresponding to the first nonzero test, or DEFAULT if none
     of the tests are nonzero expressions.

     This is currently not valid for instruction patterns and is
     supported only for insn attributes.  *Note Insn Attributes::.

==============================================================================
File: gccint.info,  Node: |Bit_Fields|,  Next: |Vector_Operations|,  Prev: |Comparisons|,  Up: |RTL|
==============================================================================

                                                                    *Bit_Fields*

14.11 Bit-Fields
----------------

Special expression codes exist to represent bit-field instructions.

'(sign_extract:M LOC SIZE POS)'
     This represents a reference to a sign-extended bit-field contained
     or starting in LOC (a memory or register reference).  The bit-field
     is SIZE bits wide and starts at bit POS.  The compilation option
     'BITS_BIG_ENDIAN' says which end of the memory unit POS counts
     from.

     If LOC is in memory, its mode must be a single-byte integer mode.
     If LOC is in a register, the mode to use is specified by the
     operand of the 'insv' or 'extv' pattern (*note Standard Names::)
     and is usually a full-word integer mode, which is the default if
     none is specified.

     The mode of POS is machine-specific and is also specified in the
     'insv' or 'extv' pattern.

     The mode M is the same as the mode that would be used for LOC if it
     were a register.

     A 'sign_extract' cannot appear as an lvalue, or part thereof, in
     RTL.

'(zero_extract:M LOC SIZE POS)'
     Like 'sign_extract' but refers to an unsigned or zero-extended
     bit-field.  The same sequence of bits are extracted, but they are
     filled to an entire word with zeros instead of by sign-extension.

     Unlike 'sign_extract', this type of expressions can be lvalues in
     RTL; they may appear on the left side of an assignment, indicating
     insertion of a value into the specified bit-field.

==============================================================================
File: gccint.info,  Node: |Vector_Operations|,  Next: |Conversions|,  Prev: |Bit_Fields|,  Up: |RTL|
==============================================================================

                                                             *Vector_Operations*

14.12 Vector Operations
-----------------------

All normal RTL expressions can be used with vector modes; they are
interpreted as operating on each part of the vector independently.
Additionally, there are a few new expressions to describe specific
vector operations.

'(vec_merge:M VEC1 VEC2 ITEMS)'
     This describes a merge operation between two vectors.  The result
     is a vector of mode M; its elements are selected from either VEC1
     or VEC2.  Which elements are selected is described by ITEMS, which
     is a bit mask represented by a 'const_int'; a zero bit indicates
     the corresponding element in the result vector is taken from VEC2
     while a set bit indicates it is taken from VEC1.

'(vec_select:M VEC1 SELECTION)'
     This describes an operation that selects parts of a vector.  VEC1
     is the source vector, and SELECTION is a 'parallel' that contains a
     'const_int' (or another expression, if the selection can be made at
     runtime) for each of the subparts of the result vector, giving the
     number of the source subpart that should be stored into it.  The
     result mode M is either the submode for a single element of VEC1
     (if only one subpart is selected), or another vector mode with that
     element submode (if multiple subparts are selected).

'(vec_concat:M X1 X2)'
     Describes a vector concat operation.  The result is a concatenation
     of the vectors or scalars X1 and X2; its length is the sum of the
     lengths of the two inputs.

'(vec_duplicate:M X)'
     This operation converts a scalar into a vector or a small vector
     into a larger one by duplicating the input values.  The output
     vector mode must have the same submodes as the input vector mode or
     the scalar modes, and the number of output parts must be an integer
     multiple of the number of input parts.

'(vec_series:M BASE STEP)'
     This operation creates a vector in which element I is equal to
     'BASE + I*STEP'.  M must be a vector integer mode.

==============================================================================
File: gccint.info,  Node: |Conversions|,  Next: |RTL_Declarations|,  Prev: |Vector_Operations|,  Up: |RTL|
==============================================================================

                                                                   *Conversions*

14.13 Conversions
-----------------

All conversions between machine modes must be represented by explicit
conversion operations.  For example, an expression which is the sum of a
byte and a full word cannot be written as '(plus:SI (reg:QI 34) (reg:SI
80))' because the 'plus' operation requires two operands of the same
machine mode.  Therefore, the byte-sized operand is enclosed in a
conversion operation, as in

     (plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))

 The conversion operation is not a mere placeholder, because there may
be more than one way of converting from a given starting mode to the
desired final mode.  The conversion operation code says how to do it.

 For all conversion operations, X must not be 'VOIDmode' because the
mode in which to do the conversion would not be known.  The conversion
must either be done at compile-time or X must be placed into a register.

'(sign_extend:M X)'
     Represents the result of sign-extending the value X to machine mode
     M.  M must be a fixed-point mode and X a fixed-point value of a
     mode narrower than M.

'(zero_extend:M X)'
     Represents the result of zero-extending the value X to machine mode
     M.  M must be a fixed-point mode and X a fixed-point value of a
     mode narrower than M.

'(float_extend:M X)'
     Represents the result of extending the value X to machine mode M.
     M must be a floating point mode and X a floating point value of a
     mode narrower than M.

'(truncate:M X)'
     Represents the result of truncating the value X to machine mode M.
     M must be a fixed-point mode and X a fixed-point value of a mode
     wider than M.

'(ss_truncate:M X)'
     Represents the result of truncating the value X to machine mode M,
     using signed saturation in the case of overflow.  Both M and the
     mode of X must be fixed-point modes.

'(us_truncate:M X)'
     Represents the result of truncating the value X to machine mode M,
     using unsigned saturation in the case of overflow.  Both M and the
     mode of X must be fixed-point modes.

'(float_truncate:M X)'
     Represents the result of truncating the value X to machine mode M.
     M must be a floating point mode and X a floating point value of a
     mode wider than M.

'(float:M X)'
     Represents the result of converting fixed point value X, regarded
     as signed, to floating point mode M.

'(unsigned_float:M X)'
     Represents the result of converting fixed point value X, regarded
     as unsigned, to floating point mode M.

'(fix:M X)'
     When M is a floating-point mode, represents the result of
     converting floating point value X (valid for mode M) to an integer,
     still represented in floating point mode M, by rounding towards
     zero.

     When M is a fixed-point mode, represents the result of converting
     floating point value X to mode M, regarded as signed.  How rounding
     is done is not specified, so this operation may be used validly in
     compiling C code only for integer-valued operands.

'(unsigned_fix:M X)'
     Represents the result of converting floating point value X to fixed
     point mode M, regarded as unsigned.  How rounding is done is not
     specified.

'(fract_convert:M X)'
     Represents the result of converting fixed-point value X to
     fixed-point mode M, signed integer value X to fixed-point mode M,
     floating-point value X to fixed-point mode M, fixed-point value X
     to integer mode M regarded as signed, or fixed-point value X to
     floating-point mode M.  When overflows or underflows happen, the
     results are undefined.

'(sat_fract:M X)'
     Represents the result of converting fixed-point value X to
     fixed-point mode M, signed integer value X to fixed-point mode M,
     or floating-point value X to fixed-point mode M.  When overflows or
     underflows happen, the results are saturated to the maximum or the
     minimum.

'(unsigned_fract_convert:M X)'
     Represents the result of converting fixed-point value X to integer
     mode M regarded as unsigned, or unsigned integer value X to
     fixed-point mode M.  When overflows or underflows happen, the
     results are undefined.

'(unsigned_sat_fract:M X)'
     Represents the result of converting unsigned integer value X to
     fixed-point mode M.  When overflows or underflows happen, the
     results are saturated to the maximum or the minimum.

==============================================================================
File: gccint.info,  Node: |RTL_Declarations|,  Next: |Side_Effects|,  Prev: |Conversions|,  Up: |RTL|
==============================================================================

                                                              *RTL_Declarations*

14.14 Declarations
------------------

Declaration expression codes do not represent arithmetic operations but
rather state assertions about their operands.

'(strict_low_part (subreg:M (reg:N R) 0))'
     This expression code is used in only one context: as the
     destination operand of a 'set' expression.  In addition, the
     operand of this expression must be a non-paradoxical 'subreg'
     expression.

     The presence of 'strict_low_part' says that the part of the
     register which is meaningful in mode N, but is not part of mode M,
     is not to be altered.  Normally, an assignment to such a subreg is
     allowed to have undefined effects on the rest of the register when
     M is smaller than 'REGMODE_NATURAL_SIZE (N)'.

==============================================================================
File: gccint.info,  Node: |Side_Effects|,  Next: |Incdec|,  Prev: |RTL_Declarations|,  Up: |RTL|
==============================================================================

                                                                  *Side_Effects*

14.15 Side Effect Expressions
-----------------------------

The expression codes described so far represent values, not actions.
But machine instructions never produce values; they are meaningful only
for their side effects on the state of the machine.  Special expression
codes are used to represent side effects.

 The body of an instruction is always one of these side effect codes;
the codes described above, which represent values, appear only as the
operands of these.

'(set LVAL X)'
     Represents the action of storing the value of X into the place
     represented by LVAL.  LVAL must be an expression representing a
     place that can be stored in: 'reg' (or 'subreg', 'strict_low_part'
     or 'zero_extract'), 'mem', 'pc', 'parallel', or 'cc0'.

     If LVAL is a 'reg', 'subreg' or 'mem', it has a machine mode; then
     X must be valid for that mode.

     If LVAL is a 'reg' whose machine mode is less than the full width
     of the register, then it means that the part of the register
     specified by the machine mode is given the specified value and the
     rest of the register receives an undefined value.  Likewise, if
     LVAL is a 'subreg' whose machine mode is narrower than the mode of
     the register, the rest of the register can be changed in an
     undefined way.

     If LVAL is a 'strict_low_part' of a subreg, then the part of the
     register specified by the machine mode of the 'subreg' is given the
     value X and the rest of the register is not changed.

     If LVAL is a 'zero_extract', then the referenced part of the
     bit-field (a memory or register reference) specified by the
     'zero_extract' is given the value X and the rest of the bit-field
     is not changed.  Note that 'sign_extract' cannot appear in LVAL.

     If LVAL is '(cc0)', it has no machine mode, and X may be either a
     'compare' expression or a value that may have any mode.  The latter
     case represents a "test" instruction.  The expression '(set (cc0)
     (reg:M N))' is equivalent to '(set (cc0) (compare (reg:M N)
     (const_int 0)))'.  Use the former expression to save space during
     the compilation.

     If LVAL is a 'parallel', it is used to represent the case of a
     function returning a structure in multiple registers.  Each element
     of the 'parallel' is an 'expr_list' whose first operand is a 'reg'
     and whose second operand is a 'const_int' representing the offset
     (in bytes) into the structure at which the data in that register
     corresponds.  The first element may be null to indicate that the
     structure is also passed partly in memory.

     If LVAL is '(pc)', we have a jump instruction, and the
     possibilities for X are very limited.  It may be a 'label_ref'
     expression (unconditional jump).  It may be an 'if_then_else'
     (conditional jump), in which case either the second or the third
     operand must be '(pc)' (for the case which does not jump) and the
     other of the two must be a 'label_ref' (for the case which does
     jump).  X may also be a 'mem' or '(plus:SI (pc) Y)', where Y may be
     a 'reg' or a 'mem'; these unusual patterns are used to represent
     jumps through branch tables.

     If LVAL is neither '(cc0)' nor '(pc)', the mode of LVAL must not be
     'VOIDmode' and the mode of X must be valid for the mode of LVAL.

     LVAL is customarily accessed with the 'SET_DEST' macro and X with
     the 'SET_SRC' macro.

'(return)'
     As the sole expression in a pattern, represents a return from the
     current function, on machines where this can be done with one
     instruction, such as VAXen.  On machines where a multi-instruction
     "epilogue" must be executed in order to return from the function,
     returning is done by jumping to a label which precedes the
     epilogue, and the 'return' expression code is never used.

     Inside an 'if_then_else' expression, represents the value to be
     placed in 'pc' to return to the caller.

     Note that an insn pattern of '(return)' is logically equivalent to
     '(set (pc) (return))', but the latter form is never used.

'(simple_return)'
     Like '(return)', but truly represents only a function return, while
     '(return)' may represent an insn that also performs other functions
     of the function epilogue.  Like '(return)', this may also occur in
     conditional jumps.

'(call FUNCTION NARGS)'
     Represents a function call.  FUNCTION is a 'mem' expression whose
     address is the address of the function to be called.  NARGS is an
     expression which can be used for two purposes: on some machines it
     represents the number of bytes of stack argument; on others, it
     represents the number of argument registers.

     Each machine has a standard machine mode which FUNCTION must have.
     The machine description defines macro 'FUNCTION_MODE' to expand
     into the requisite mode name.  The purpose of this mode is to
     specify what kind of addressing is allowed, on machines where the
     allowed kinds of addressing depend on the machine mode being
     addressed.

'(clobber X)'
     Represents the storing or possible storing of an unpredictable,
     undescribed value into X, which must be a 'reg', 'scratch',
     'parallel' or 'mem' expression.

     One place this is used is in string instructions that store
     standard values into particular hard registers.  It may not be
     worth the trouble to describe the values that are stored, but it is
     essential to inform the compiler that the registers will be
     altered, lest it attempt to keep data in them across the string
     instruction.

     If X is '(mem:BLK (const_int 0))' or '(mem:BLK (scratch))', it
     means that all memory locations must be presumed clobbered.  If X
     is a 'parallel', it has the same meaning as a 'parallel' in a 'set'
     expression.

     Note that the machine description classifies certain hard registers
     as "call-clobbered".  All function call instructions are assumed by
     default to clobber these registers, so there is no need to use
     'clobber' expressions to indicate this fact.  Also, each function
     call is assumed to have the potential to alter any memory location,
     unless the function is declared 'const'.

     If the last group of expressions in a 'parallel' are each a
     'clobber' expression whose arguments are 'reg' or 'match_scratch'
     (*note RTL Template::) expressions, the combiner phase can add the
     appropriate 'clobber' expressions to an insn it has constructed
     when doing so will cause a pattern to be matched.

     This feature can be used, for example, on a machine that whose
     multiply and add instructions don't use an MQ register but which
     has an add-accumulate instruction that does clobber the MQ
     register.  Similarly, a combined instruction might require a
     temporary register while the constituent instructions might not.

     When a 'clobber' expression for a register appears inside a
     'parallel' with other side effects, the register allocator
     guarantees that the register is unoccupied both before and after
     that insn if it is a hard register clobber.  For pseudo-register
     clobber, the register allocator and the reload pass do not assign
     the same hard register to the clobber and the input operands if
     there is an insn alternative containing the '&' constraint (*note
     Modifiers::) for the clobber and the hard register is in register
     classes of the clobber in the alternative.  You can clobber either
     a specific hard register, a pseudo register, or a 'scratch'
     expression; in the latter two cases, GCC will allocate a hard
     register that is available there for use as a temporary.

     For instructions that require a temporary register, you should use
     'scratch' instead of a pseudo-register because this will allow the
     combiner phase to add the 'clobber' when required.  You do this by
     coding ('clobber' ('match_scratch' ...)).  If you do clobber a
     pseudo register, use one which appears nowhere else--generate a new
     one each time.  Otherwise, you may confuse CSE.

     There is one other known use for clobbering a pseudo register in a
     'parallel': when one of the input operands of the insn is also
     clobbered by the insn.  In this case, using the same pseudo
     register in the clobber and elsewhere in the insn produces the
     expected results.

'(use X)'
     Represents the use of the value of X.  It indicates that the value
     in X at this point in the program is needed, even though it may not
     be apparent why this is so.  Therefore, the compiler will not
     attempt to delete previous instructions whose only effect is to
     store a value in X.  X must be a 'reg' expression.

     In some situations, it may be tempting to add a 'use' of a register
     in a 'parallel' to describe a situation where the value of a
     special register will modify the behavior of the instruction.  A
     hypothetical example might be a pattern for an addition that can
     either wrap around or use saturating addition depending on the
     value of a special control register:

          (parallel [(set (reg:SI 2) (unspec:SI [(reg:SI 3)
                                                 (reg:SI 4)] 0))
                     (use (reg:SI 1))])


     This will not work, several of the optimizers only look at
     expressions locally; it is very likely that if you have multiple
     insns with identical inputs to the 'unspec', they will be optimized
     away even if register 1 changes in between.

     This means that 'use' can _only_ be used to describe that the
     register is live.  You should think twice before adding 'use'
     statements, more often you will want to use 'unspec' instead.  The
     'use' RTX is most commonly useful to describe that a fixed register
     is implicitly used in an insn.  It is also safe to use in patterns
     where the compiler knows for other reasons that the result of the
     whole pattern is variable, such as 'cpymemM' or 'call' patterns.

     During the reload phase, an insn that has a 'use' as pattern can
     carry a reg_equal note.  These 'use' insns will be deleted before
     the reload phase exits.

     During the delayed branch scheduling phase, X may be an insn.  This
     indicates that X previously was located at this place in the code
     and its data dependencies need to be taken into account.  These
     'use' insns will be deleted before the delayed branch scheduling
     phase exits.

'(parallel [X0 X1 ...])'
     Represents several side effects performed in parallel.  The square
     brackets stand for a vector; the operand of 'parallel' is a vector
     of expressions.  X0, X1 and so on are individual side effect
     expressions--expressions of code 'set', 'call', 'return',
     'simple_return', 'clobber' or 'use'.

     "In parallel" means that first all the values used in the
     individual side-effects are computed, and second all the actual
     side-effects are performed.  For example,

          (parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
                     (set (mem:SI (reg:SI 1)) (reg:SI 1))])

     says unambiguously that the values of hard register 1 and the
     memory location addressed by it are interchanged.  In both places
     where '(reg:SI 1)' appears as a memory address it refers to the
     value in register 1 _before_ the execution of the insn.

     It follows that it is _incorrect_ to use 'parallel' and expect the
     result of one 'set' to be available for the next one.  For example,
     people sometimes attempt to represent a jump-if-zero instruction
     this way:

          (parallel [(set (cc0) (reg:SI 34))
                     (set (pc) (if_then_else
                                  (eq (cc0) (const_int 0))
                                  (label_ref ...)
                                  (pc)))])

     But this is incorrect, because it says that the jump condition
     depends on the condition code value _before_ this instruction, not
     on the new value that is set by this instruction.

     Peephole optimization, which takes place together with final
     assembly code output, can produce insns whose patterns consist of a
     'parallel' whose elements are the operands needed to output the
     resulting assembler code--often 'reg', 'mem' or constant
     expressions.  This would not be well-formed RTL at any other stage
     in compilation, but it is OK then because no further optimization
     remains to be done.  However, the definition of the macro
     'NOTICE_UPDATE_CC', if any, must deal with such insns if you define
     any peephole optimizations.

'(cond_exec [COND EXPR])'
     Represents a conditionally executed expression.  The EXPR is
     executed only if the COND is nonzero.  The COND expression must not
     have side-effects, but the EXPR may very well have side-effects.

'(sequence [INSNS ...])'
     Represents a sequence of insns.  If a 'sequence' appears in the
     chain of insns, then each of the INSNS that appears in the sequence
     must be suitable for appearing in the chain of insns, i.e. must
     satisfy the 'INSN_P' predicate.

     After delay-slot scheduling is completed, an insn and all the insns
     that reside in its delay slots are grouped together into a
     'sequence'.  The insn requiring the delay slot is the first insn in
     the vector; subsequent insns are to be placed in the delay slot.

     'INSN_ANNULLED_BRANCH_P' is set on an insn in a delay slot to
     indicate that a branch insn should be used that will conditionally
     annul the effect of the insns in the delay slots.  In such a case,
     'INSN_FROM_TARGET_P' indicates that the insn is from the target of
     the branch and should be executed only if the branch is taken;
     otherwise the insn should be executed only if the branch is not
     taken.  *Note Delay Slots::.

     Some back ends also use 'sequence' objects for purposes other than
     delay-slot groups.  This is not supported in the common parts of
     the compiler, which treat such sequences as delay-slot groups.

     DWARF2 Call Frame Address (CFA) adjustments are sometimes also
     expressed using 'sequence' objects as the value of a
     'RTX_FRAME_RELATED_P' note.  This only happens if the CFA
     adjustments cannot be easily derived from the pattern of the
     instruction to which the note is attached.  In such cases, the
     value of the note is used instead of best-guesing the semantics of
     the instruction.  The back end can attach notes containing a
     'sequence' of 'set' patterns that express the effect of the parent
     instruction.

 These expression codes appear in place of a side effect, as the body of
an insn, though strictly speaking they do not always describe side
effects as such:

'(asm_input S)'
     Represents literal assembler code as described by the string S.

'(unspec [OPERANDS ...] INDEX)'
'(unspec_volatile [OPERANDS ...] INDEX)'
     Represents a machine-specific operation on OPERANDS.  INDEX selects
     between multiple machine-specific operations.  'unspec_volatile' is
     used for volatile operations and operations that may trap; 'unspec'
     is used for other operations.

     These codes may appear inside a 'pattern' of an insn, inside a
     'parallel', or inside an expression.

'(addr_vec:M [LR0 LR1 ...])'
     Represents a table of jump addresses.  The vector elements LR0,
     etc., are 'label_ref' expressions.  The mode M specifies how much
     space is given to each address; normally M would be 'Pmode'.

'(addr_diff_vec:M BASE [LR0 LR1 ...] MIN MAX FLAGS)'
     Represents a table of jump addresses expressed as offsets from
     BASE.  The vector elements LR0, etc., are 'label_ref' expressions
     and so is BASE.  The mode M specifies how much space is given to
     each address-difference.  MIN and MAX are set up by branch
     shortening and hold a label with a minimum and a maximum address,
     respectively.  FLAGS indicates the relative position of BASE, MIN
     and MAX to the containing insn and of MIN and MAX to BASE.  See
     rtl.def for details.

'(prefetch:M ADDR RW LOCALITY)'
     Represents prefetch of memory at address ADDR.  Operand RW is 1 if
     the prefetch is for data to be written, 0 otherwise; targets that
     do not support write prefetches should treat this as a normal
     prefetch.  Operand LOCALITY specifies the amount of temporal
     locality; 0 if there is none or 1, 2, or 3 for increasing levels of
     temporal locality; targets that do not support locality hints
     should ignore this.

     This insn is used to minimize cache-miss latency by moving data
     into a cache before it is accessed.  It should use only
     non-faulting data prefetch instructions.

==============================================================================
File: gccint.info,  Node: |Incdec|,  Next: |Assembler|,  Prev: |Side_Effects|,  Up: |RTL|
==============================================================================

                                                                        *Incdec*

14.16 Embedded Side-Effects on Addresses
----------------------------------------

Six special side-effect expression codes appear as memory addresses.

'(pre_dec:M X)'
     Represents the side effect of decrementing X by a standard amount
     and represents also the value that X has after being decremented.
     X must be a 'reg' or 'mem', but most machines allow only a 'reg'.
     M must be the machine mode for pointers on the machine in use.  The
     amount X is decremented by is the length in bytes of the machine
     mode of the containing memory reference of which this expression
     serves as the address.  Here is an example of its use:

          (mem:DF (pre_dec:SI (reg:SI 39)))

     This says to decrement pseudo register 39 by the length of a
     'DFmode' value and use the result to address a 'DFmode' value.

'(pre_inc:M X)'
     Similar, but specifies incrementing X instead of decrementing it.

'(post_dec:M X)'
     Represents the same side effect as 'pre_dec' but a different value.
     The value represented here is the value X has before being
     decremented.

'(post_inc:M X)'
     Similar, but specifies incrementing X instead of decrementing it.

'(post_modify:M X Y)'

     Represents the side effect of setting X to Y and represents X
     before X is modified.  X must be a 'reg' or 'mem', but most
     machines allow only a 'reg'.  M must be the machine mode for
     pointers on the machine in use.

     The expression Y must be one of three forms: '(plus:M X Z)',
     '(minus:M X Z)', or '(plus:M X I)', where Z is an index register
     and I is a constant.

     Here is an example of its use:

          (mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42)
                                                    (reg:SI 48))))

     This says to modify pseudo register 42 by adding the contents of
     pseudo register 48 to it, after the use of what ever 42 points to.

'(pre_modify:M X EXPR)'
     Similar except side effects happen before the use.

 These embedded side effect expressions must be used with care.
Instruction patterns may not use them.  Until the 'flow' pass of the
compiler, they may occur only to represent pushes onto the stack.  The
'flow' pass finds cases where registers are incremented or decremented
in one instruction and used as an address shortly before or after; these
cases are then transformed to use pre- or post-increment or -decrement.

 If a register used as the operand of these expressions is used in
another address in an insn, the original value of the register is used.
Uses of the register outside of an address are not permitted within the
same insn as a use in an embedded side effect expression because such
insns behave differently on different machines and hence must be treated
as ambiguous and disallowed.

 An instruction that can be represented with an embedded side effect
could also be represented using 'parallel' containing an additional
'set' to describe how the address register is altered.  This is not done
because machines that allow these operations at all typically allow them
wherever a memory address is called for.  Describing them as additional
parallel stores would require doubling the number of entries in the
machine description.

==============================================================================
File: gccint.info,  Node: |Assembler|,  Next: |Debug_Information|,  Prev: |Incdec|,  Up: |RTL|
==============================================================================

                                                                     *Assembler*

14.17 Assembler Instructions as Expressions
-------------------------------------------

The RTX code 'asm_operands' represents a value produced by a
user-specified assembler instruction.  It is used to represent an 'asm'
statement with arguments.  An 'asm' statement with a single output
operand, like this:

     asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));

is represented using a single 'asm_operands' RTX which represents the
value that is stored in 'outputvar':

     (set RTX-FOR-OUTPUTVAR
          (asm_operands "foo %1,%2,%0" "a" 0
                        [RTX-FOR-ADDITION-RESULT RTX-FOR-*Z]
                        [(asm_input:M1 "g")
                         (asm_input:M2 "di")]))

Here the operands of the 'asm_operands' RTX are the assembler template
string, the output-operand's constraint, the index-number of the output
operand among the output operands specified, a vector of input operand
RTX's, and a vector of input-operand modes and constraints.  The mode M1
is the mode of the sum 'x+y'; M2 is that of '*z'.

 When an 'asm' statement has multiple output values, its insn has
several such 'set' RTX's inside of a 'parallel'.  Each 'set' contains an
'asm_operands'; all of these share the same assembler template and
vectors, but each contains the constraint for the respective output
operand.  They are also distinguished by the output-operand index
number, which is 0, 1, ... for successive output operands.

==============================================================================
File: gccint.info,  Node: |Debug_Information|,  Next: |Insns|,  Prev: |Assembler|,  Up: |RTL|
==============================================================================

                                                             *Debug_Information*

14.18 Variable Location Debug Information in RTL
------------------------------------------------

Variable tracking relies on 'MEM_EXPR' and 'REG_EXPR' annotations to
determine what user variables memory and register references refer to.

 Variable tracking at assignments uses these notes only when they refer
to variables that live at fixed locations (e.g., addressable variables,
global non-automatic variables).  For variables whose location may vary,
it relies on the following types of notes.

'(var_location:MODE VAR EXP STAT)'
     Binds variable 'var', a tree, to value EXP, an RTL expression.  It
     appears only in 'NOTE_INSN_VAR_LOCATION' and 'DEBUG_INSN's, with
     slightly different meanings.  MODE, if present, represents the mode
     of EXP, which is useful if it is a modeless expression.  STAT is
     only meaningful in notes, indicating whether the variable is known
     to be initialized or uninitialized.

'(debug_expr:MODE DECL)'
     Stands for the value bound to the 'DEBUG_EXPR_DECL' DECL, that
     points back to it, within value expressions in 'VAR_LOCATION'
     nodes.

'(debug_implicit_ptr:MODE DECL)'
     Stands for the location of a DECL that is no longer addressable.

'(entry_value:MODE DECL)'
     Stands for the value a DECL had at the entry point of the
     containing function.

'(debug_parameter_ref:MODE DECL)'
     Refers to a parameter that was completely optimized out.

'(debug_marker:MODE)'
     Marks a program location.  With 'VOIDmode', it stands for the
     beginning of a statement, a recommended inspection point logically
     after all prior side effects, and before any subsequent side
     effects.  With 'BLKmode', it indicates an inline entry point: the
     lexical block encoded in the 'INSN_LOCATION' is the enclosing block
     that encloses the inlined function.

==============================================================================
File: gccint.info,  Node: |Insns|,  Next: |Calls|,  Prev: |Debug_Information|,  Up: |RTL|
==============================================================================

                                                                         *Insns*

14.19 Insns
-----------

The RTL representation of the code for a function is a doubly-linked
chain of objects called "insns".  Insns are expressions with special
codes that are used for no other purpose.  Some insns are actual
instructions; others represent dispatch tables for 'switch' statements;
others represent labels to jump to or various sorts of declarative
information.

 In addition to its own specific data, each insn must have a unique
id-number that distinguishes it from all other insns in the current
function (after delayed branch scheduling, copies of an insn with the
same id-number may be present in multiple places in a function, but
these copies will always be identical and will only appear inside a
'sequence'), and chain pointers to the preceding and following insns.
These three fields occupy the same position in every insn, independent
of the expression code of the insn.  They could be accessed with 'XEXP'
and 'XINT', but instead three special macros are always used:

'INSN_UID (I)'
     Accesses the unique id of insn I.

'PREV_INSN (I)'
     Accesses the chain pointer to the insn preceding I.  If I is the
     first insn, this is a null pointer.

'NEXT_INSN (I)'
     Accesses the chain pointer to the insn following I.  If I is the
     last insn, this is a null pointer.

 The first insn in the chain is obtained by calling 'get_insns'; the
last insn is the result of calling 'get_last_insn'.  Within the chain
delimited by these insns, the 'NEXT_INSN' and 'PREV_INSN' pointers must
always correspond: if INSN is not the first insn,

     NEXT_INSN (PREV_INSN (INSN)) == INSN

is always true and if INSN is not the last insn,

     PREV_INSN (NEXT_INSN (INSN)) == INSN

is always true.

 After delay slot scheduling, some of the insns in the chain might be
'sequence' expressions, which contain a vector of insns.  The value of
'NEXT_INSN' in all but the last of these insns is the next insn in the
vector; the value of 'NEXT_INSN' of the last insn in the vector is the
same as the value of 'NEXT_INSN' for the 'sequence' in which it is
contained.  Similar rules apply for 'PREV_INSN'.

 This means that the above invariants are not necessarily true for insns
inside 'sequence' expressions.  Specifically, if INSN is the first insn
in a 'sequence', 'NEXT_INSN (PREV_INSN (INSN))' is the insn containing
the 'sequence' expression, as is the value of 'PREV_INSN (NEXT_INSN
(INSN))' if INSN is the last insn in the 'sequence' expression.  You can
use these expressions to find the containing 'sequence' expression.

 Every insn has one of the following expression codes:

'insn'
     The expression code 'insn' is used for instructions that do not
     jump and do not do function calls.  'sequence' expressions are
     always contained in insns with code 'insn' even if one of those
     insns should jump or do function calls.

     Insns with code 'insn' have four additional fields beyond the three
     mandatory ones listed above.  These four are described in a table
     below.

'jump_insn'
     The expression code 'jump_insn' is used for instructions that may
     jump (or, more generally, may contain 'label_ref' expressions to
     which 'pc' can be set in that instruction).  If there is an
     instruction to return from the current function, it is recorded as
     a 'jump_insn'.

     'jump_insn' insns have the same extra fields as 'insn' insns,
     accessed in the same way and in addition contain a field
     'JUMP_LABEL' which is defined once jump optimization has completed.

     For simple conditional and unconditional jumps, this field contains
     the 'code_label' to which this insn will (possibly conditionally)
     branch.  In a more complex jump, 'JUMP_LABEL' records one of the
     labels that the insn refers to; other jump target labels are
     recorded as 'REG_LABEL_TARGET' notes.  The exception is 'addr_vec'
     and 'addr_diff_vec', where 'JUMP_LABEL' is 'NULL_RTX' and the only
     way to find the labels is to scan the entire body of the insn.

     Return insns count as jumps, but their 'JUMP_LABEL' is 'RETURN' or
     'SIMPLE_RETURN'.

'call_insn'
     The expression code 'call_insn' is used for instructions that may
     do function calls.  It is important to distinguish these
     instructions because they imply that certain registers and memory
     locations may be altered unpredictably.

     'call_insn' insns have the same extra fields as 'insn' insns,
     accessed in the same way and in addition contain a field
     'CALL_INSN_FUNCTION_USAGE', which contains a list (chain of
     'expr_list' expressions) containing 'use', 'clobber' and sometimes
     'set' expressions that denote hard registers and 'mem's used or
     clobbered by the called function.

     A 'mem' generally points to a stack slot in which arguments passed
     to the libcall by reference (*note TARGET_PASS_BY_REFERENCE:
     Register Arguments.) are stored.  If the argument is caller-copied
     (*note TARGET_CALLEE_COPIES: Register Arguments.), the stack slot
     will be mentioned in 'clobber' and 'use' entries; if it's
     callee-copied, only a 'use' will appear, and the 'mem' may point to
     addresses that are not stack slots.

     Registers occurring inside a 'clobber' in this list augment
     registers specified in 'CALL_USED_REGISTERS' (*note Register
     Basics::).

     If the list contains a 'set' involving two registers, it indicates
     that the function returns one of its arguments.  Such a 'set' may
     look like a no-op if the same register holds the argument and the
     return value.

'code_label'
     A 'code_label' insn represents a label that a jump insn can jump
     to.  It contains two special fields of data in addition to the
     three standard ones.  'CODE_LABEL_NUMBER' is used to hold the
     "label number", a number that identifies this label uniquely among
     all the labels in the compilation (not just in the current
     function).  Ultimately, the label is represented in the assembler
     output as an assembler label, usually of the form 'LN' where N is
     the label number.

     When a 'code_label' appears in an RTL expression, it normally
     appears within a 'label_ref' which represents the address of the
     label, as a number.

     Besides as a 'code_label', a label can also be represented as a
     'note' of type 'NOTE_INSN_DELETED_LABEL'.

     The field 'LABEL_NUSES' is only defined once the jump optimization
     phase is completed.  It contains the number of times this label is
     referenced in the current function.

     The field 'LABEL_KIND' differentiates four different types of
     labels: 'LABEL_NORMAL', 'LABEL_STATIC_ENTRY', 'LABEL_GLOBAL_ENTRY',
     and 'LABEL_WEAK_ENTRY'.  The only labels that do not have type
     'LABEL_NORMAL' are "alternate entry points" to the current
     function.  These may be static (visible only in the containing
     translation unit), global (exposed to all translation units), or
     weak (global, but can be overridden by another symbol with the same
     name).

     Much of the compiler treats all four kinds of label identically.
     Some of it needs to know whether or not a label is an alternate
     entry point; for this purpose, the macro 'LABEL_ALT_ENTRY_P' is
     provided.  It is equivalent to testing whether 'LABEL_KIND (label)
     == LABEL_NORMAL'.  The only place that cares about the distinction
     between static, global, and weak alternate entry points, besides
     the front-end code that creates them, is the function
     'output_alternate_entry_point', in 'final.c'.

     To set the kind of a label, use the 'SET_LABEL_KIND' macro.

'jump_table_data'
     A 'jump_table_data' insn is a placeholder for the jump-table data
     of a 'casesi' or 'tablejump' insn.  They are placed after a
     'tablejump_p' insn.  A 'jump_table_data' insn is not part o a basic
     blockm but it is associated with the basic block that ends with the
     'tablejump_p' insn.  The 'PATTERN' of a 'jump_table_data' is always
     either an 'addr_vec' or an 'addr_diff_vec', and a 'jump_table_data'
     insn is always preceded by a 'code_label'.  The 'tablejump_p' insn
     refers to that 'code_label' via its 'JUMP_LABEL'.

'barrier'
     Barriers are placed in the instruction stream when control cannot
     flow past them.  They are placed after unconditional jump
     instructions to indicate that the jumps are unconditional and after
     calls to 'volatile' functions, which do not return (e.g., 'exit').
     They contain no information beyond the three standard fields.

'note'
     'note' insns are used to represent additional debugging and
     declarative information.  They contain two nonstandard fields, an
     integer which is accessed with the macro 'NOTE_LINE_NUMBER' and a
     string accessed with 'NOTE_SOURCE_FILE'.

     If 'NOTE_LINE_NUMBER' is positive, the note represents the position
     of a source line and 'NOTE_SOURCE_FILE' is the source file name
     that the line came from.  These notes control generation of line
     number data in the assembler output.

     Otherwise, 'NOTE_LINE_NUMBER' is not really a line number but a
     code with one of the following values (and 'NOTE_SOURCE_FILE' must
     contain a null pointer):

     'NOTE_INSN_DELETED'
          Such a note is completely ignorable.  Some passes of the
          compiler delete insns by altering them into notes of this
          kind.

     'NOTE_INSN_DELETED_LABEL'
          This marks what used to be a 'code_label', but was not used
          for other purposes than taking its address and was transformed
          to mark that no code jumps to it.

     'NOTE_INSN_BLOCK_BEG'
     'NOTE_INSN_BLOCK_END'
          These types of notes indicate the position of the beginning
          and end of a level of scoping of variable names.  They control
          the output of debugging information.

     'NOTE_INSN_EH_REGION_BEG'
     'NOTE_INSN_EH_REGION_END'
          These types of notes indicate the position of the beginning
          and end of a level of scoping for exception handling.
          'NOTE_EH_HANDLER' identifies which region is associated with
          these notes.

     'NOTE_INSN_FUNCTION_BEG'
          Appears at the start of the function body, after the function
          prologue.

     'NOTE_INSN_VAR_LOCATION'
          This note is used to generate variable location debugging
          information.  It indicates that the user variable in its
          'VAR_LOCATION' operand is at the location given in the RTL
          expression, or holds a value that can be computed by
          evaluating the RTL expression from that static point in the
          program up to the next such note for the same user variable.

     'NOTE_INSN_BEGIN_STMT'
          This note is used to generate 'is_stmt' markers in line number
          debuggign information.  It indicates the beginning of a user
          statement.

     'NOTE_INSN_INLINE_ENTRY'
          This note is used to generate 'entry_pc' for inlined
          subroutines in debugging information.  It indicates an
          inspection point at which all arguments for the inlined
          function have been bound, and before its first statement.

     These codes are printed symbolically when they appear in debugging
     dumps.

'debug_insn'
     The expression code 'debug_insn' is used for pseudo-instructions
     that hold debugging information for variable tracking at
     assignments (see '-fvar-tracking-assignments' option).  They are
     the RTL representation of 'GIMPLE_DEBUG' statements (*note
     GIMPLE_DEBUG::), with a 'VAR_LOCATION' operand that binds a user
     variable tree to an RTL representation of the 'value' in the
     corresponding statement.  A 'DEBUG_EXPR' in it stands for the value
     bound to the corresponding 'DEBUG_EXPR_DECL'.

     'GIMPLE_DEBUG_BEGIN_STMT' and 'GIMPLE_DEBUG_INLINE_ENTRY' are
     expanded to RTL as a 'DEBUG_INSN' with a 'DEBUG_MARKER' 'PATTERN';
     the difference is the RTL mode: the former's 'DEBUG_MARKER' is
     'VOIDmode', whereas the latter is 'BLKmode'; information about the
     inlined function can be taken from the lexical block encoded in the
     'INSN_LOCATION'.  These 'DEBUG_INSN's, that do not carry
     'VAR_LOCATION' information, just 'DEBUG_MARKER's, can be detected
     by testing 'DEBUG_MARKER_INSN_P', whereas those that do can be
     recognized as 'DEBUG_BIND_INSN_P'.

     Throughout optimization passes, 'DEBUG_INSN's are not reordered
     with respect to each other, particularly during scheduling.
     Binding information is kept in pseudo-instruction form, so that,
     unlike notes, it gets the same treatment and adjustments that
     regular instructions would.  It is the variable tracking pass that
     turns these pseudo-instructions into 'NOTE_INSN_VAR_LOCATION',
     'NOTE_INSN_BEGIN_STMT' and 'NOTE_INSN_INLINE_ENTRY' notes,
     analyzing control flow, value equivalences and changes to registers
     and memory referenced in value expressions, propagating the values
     of debug temporaries and determining expressions that can be used
     to compute the value of each user variable at as many points
     (ranges, actually) in the program as possible.

     Unlike 'NOTE_INSN_VAR_LOCATION', the value expression in an
     'INSN_VAR_LOCATION' denotes a value at that specific point in the
     program, rather than an expression that can be evaluated at any
     later point before an overriding 'VAR_LOCATION' is encountered.
     E.g., if a user variable is bound to a 'REG' and then a subsequent
     insn modifies the 'REG', the note location would keep mapping the
     user variable to the register across the insn, whereas the insn
     location would keep the variable bound to the value, so that the
     variable tracking pass would emit another location note for the
     variable at the point in which the register is modified.

 The machine mode of an insn is normally 'VOIDmode', but some phases use
the mode for various purposes.

 The common subexpression elimination pass sets the mode of an insn to
'QImode' when it is the first insn in a block that has already been
processed.

 The second Haifa scheduling pass, for targets that can multiple issue,
sets the mode of an insn to 'TImode' when it is believed that the
instruction begins an issue group.  That is, when the instruction cannot
issue simultaneously with the previous.  This may be relied on by later
passes, in particular machine-dependent reorg.

 Here is a table of the extra fields of 'insn', 'jump_insn' and
'call_insn' insns:

'PATTERN (I)'
     An expression for the side effect performed by this insn.  This
     must be one of the following codes: 'set', 'call', 'use',
     'clobber', 'return', 'simple_return', 'asm_input', 'asm_output',
     'addr_vec', 'addr_diff_vec', 'trap_if', 'unspec',
     'unspec_volatile', 'parallel', 'cond_exec', or 'sequence'.  If it
     is a 'parallel', each element of the 'parallel' must be one these
     codes, except that 'parallel' expressions cannot be nested and
     'addr_vec' and 'addr_diff_vec' are not permitted inside a
     'parallel' expression.

'INSN_CODE (I)'
     An integer that says which pattern in the machine description
     matches this insn, or -1 if the matching has not yet been
     attempted.

     Such matching is never attempted and this field remains -1 on an
     insn whose pattern consists of a single 'use', 'clobber',
     'asm_input', 'addr_vec' or 'addr_diff_vec' expression.

     Matching is also never attempted on insns that result from an 'asm'
     statement.  These contain at least one 'asm_operands' expression.
     The function 'asm_noperands' returns a non-negative value for such
     insns.

     In the debugging output, this field is printed as a number followed
     by a symbolic representation that locates the pattern in the 'md'
     file as some small positive or negative offset from a named
     pattern.

'LOG_LINKS (I)'
     A list (chain of 'insn_list' expressions) giving information about
     dependencies between instructions within a basic block.  Neither a
     jump nor a label may come between the related insns.  These are
     only used by the schedulers and by combine.  This is a deprecated
     data structure.  Def-use and use-def chains are now preferred.

'REG_NOTES (I)'
     A list (chain of 'expr_list', 'insn_list' and 'int_list'
     expressions) giving miscellaneous information about the insn.  It
     is often information pertaining to the registers used in this insn.

 The 'LOG_LINKS' field of an insn is a chain of 'insn_list' expressions.
Each of these has two operands: the first is an insn, and the second is
another 'insn_list' expression (the next one in the chain).  The last
'insn_list' in the chain has a null pointer as second operand.  The
significant thing about the chain is which insns appear in it (as first
operands of 'insn_list' expressions).  Their order is not significant.

 This list is originally set up by the flow analysis pass; it is a null
pointer until then.  Flow only adds links for those data dependencies
which can be used for instruction combination.  For each insn, the flow
analysis pass adds a link to insns which store into registers values
that are used for the first time in this insn.

 The 'REG_NOTES' field of an insn is a chain similar to the 'LOG_LINKS'
field but it includes 'expr_list' and 'int_list' expressions in addition
to 'insn_list' expressions.  There are several kinds of register notes,
which are distinguished by the machine mode, which in a register note is
really understood as being an 'enum reg_note'.  The first operand OP of
the note is data whose meaning depends on the kind of note.

 The macro 'REG_NOTE_KIND (X)' returns the kind of register note.  Its
counterpart, the macro 'PUT_REG_NOTE_KIND (X, NEWKIND)' sets the
register note type of X to be NEWKIND.

 Register notes are of three classes: They may say something about an
input to an insn, they may say something about an output of an insn, or
they may create a linkage between two insns.  There are also a set of
values that are only used in 'LOG_LINKS'.

 These register notes annotate inputs to an insn:

'REG_DEAD'
     The value in OP dies in this insn; that is to say, altering the
     value immediately after this insn would not affect the future
     behavior of the program.

     It does not follow that the register OP has no useful value after
     this insn since OP is not necessarily modified by this insn.
     Rather, no subsequent instruction uses the contents of OP.

'REG_UNUSED'
     The register OP being set by this insn will not be used in a
     subsequent insn.  This differs from a 'REG_DEAD' note, which
     indicates that the value in an input will not be used subsequently.
     These two notes are independent; both may be present for the same
     register.

'REG_INC'
     The register OP is incremented (or decremented; at this level there
     is no distinction) by an embedded side effect inside this insn.
     This means it appears in a 'post_inc', 'pre_inc', 'post_dec' or
     'pre_dec' expression.

'REG_NONNEG'
     The register OP is known to have a nonnegative value when this insn
     is reached.  This is used by special looping instructions that
     terminate when the register goes negative.

     The 'REG_NONNEG' note is added only to 'doloop_end' insns, if its
     pattern uses a 'ge' condition.

'REG_LABEL_OPERAND'
     This insn uses OP, a 'code_label' or a 'note' of type
     'NOTE_INSN_DELETED_LABEL', but is not a 'jump_insn', or it is a
     'jump_insn' that refers to the operand as an ordinary operand.  The
     label may still eventually be a jump target, but if so in an
     indirect jump in a subsequent insn.  The presence of this note
     allows jump optimization to be aware that OP is, in fact, being
     used, and flow optimization to build an accurate flow graph.

'REG_LABEL_TARGET'
     This insn is a 'jump_insn' but not an 'addr_vec' or
     'addr_diff_vec'.  It uses OP, a 'code_label' as a direct or
     indirect jump target.  Its purpose is similar to that of
     'REG_LABEL_OPERAND'.  This note is only present if the insn has
     multiple targets; the last label in the insn (in the highest
     numbered insn-field) goes into the 'JUMP_LABEL' field and does not
     have a 'REG_LABEL_TARGET' note.  *Note JUMP_LABEL: Insns.

'REG_SETJMP'
     Appears attached to each 'CALL_INSN' to 'setjmp' or a related
     function.

 The following notes describe attributes of outputs of an insn:

'REG_EQUIV'
'REG_EQUAL'
     This note is only valid on an insn that sets only one register and
     indicates that that register will be equal to OP at run time; the
     scope of this equivalence differs between the two types of notes.
     The value which the insn explicitly copies into the register may
     look different from OP, but they will be equal at run time.  If the
     output of the single 'set' is a 'strict_low_part' or 'zero_extract'
     expression, the note refers to the register that is contained in
     its first operand.

     For 'REG_EQUIV', the register is equivalent to OP throughout the
     entire function, and could validly be replaced in all its
     occurrences by OP.  ("Validly" here refers to the data flow of the
     program; simple replacement may make some insns invalid.)  For
     example, when a constant is loaded into a register that is never
     assigned any other value, this kind of note is used.

     When a parameter is copied into a pseudo-register at entry to a
     function, a note of this kind records that the register is
     equivalent to the stack slot where the parameter was passed.
     Although in this case the register may be set by other insns, it is
     still valid to replace the register by the stack slot throughout
     the function.

     A 'REG_EQUIV' note is also used on an instruction which copies a
     register parameter into a pseudo-register at entry to a function,
     if there is a stack slot where that parameter could be stored.
     Although other insns may set the pseudo-register, it is valid for
     the compiler to replace the pseudo-register by stack slot
     throughout the function, provided the compiler ensures that the
     stack slot is properly initialized by making the replacement in the
     initial copy instruction as well.  This is used on machines for
     which the calling convention allocates stack space for register
     parameters.  See 'REG_PARM_STACK_SPACE' in *note Stack Arguments::.

     In the case of 'REG_EQUAL', the register that is set by this insn
     will be equal to OP at run time at the end of this insn but not
     necessarily elsewhere in the function.  In this case, OP is
     typically an arithmetic expression.  For example, when a sequence
     of insns such as a library call is used to perform an arithmetic
     operation, this kind of note is attached to the insn that produces
     or copies the final value.

     These two notes are used in different ways by the compiler passes.
     'REG_EQUAL' is used by passes prior to register allocation (such as
     common subexpression elimination and loop optimization) to tell
     them how to think of that value.  'REG_EQUIV' notes are used by
     register allocation to indicate that there is an available
     substitute expression (either a constant or a 'mem' expression for
     the location of a parameter on the stack) that may be used in place
     of a register if insufficient registers are available.

     Except for stack homes for parameters, which are indicated by a
     'REG_EQUIV' note and are not useful to the early optimization
     passes and pseudo registers that are equivalent to a memory
     location throughout their entire life, which is not detected until
     later in the compilation, all equivalences are initially indicated
     by an attached 'REG_EQUAL' note.  In the early stages of register
     allocation, a 'REG_EQUAL' note is changed into a 'REG_EQUIV' note
     if OP is a constant and the insn represents the only set of its
     destination register.

     Thus, compiler passes prior to register allocation need only check
     for 'REG_EQUAL' notes and passes subsequent to register allocation
     need only check for 'REG_EQUIV' notes.

 These notes describe linkages between insns.  They occur in pairs: one
insn has one of a pair of notes that points to a second insn, which has
the inverse note pointing back to the first insn.

'REG_CC_SETTER'
'REG_CC_USER'
     On machines that use 'cc0', the insns which set and use 'cc0' set
     and use 'cc0' are adjacent.  However, when branch delay slot
     filling is done, this may no longer be true.  In this case a
     'REG_CC_USER' note will be placed on the insn setting 'cc0' to
     point to the insn using 'cc0' and a 'REG_CC_SETTER' note will be
     placed on the insn using 'cc0' to point to the insn setting 'cc0'.

 These values are only used in the 'LOG_LINKS' field, and indicate the
type of dependency that each link represents.  Links which indicate a
data dependence (a read after write dependence) do not use any code,
they simply have mode 'VOIDmode', and are printed without any
descriptive text.

'REG_DEP_TRUE'
     This indicates a true dependence (a read after write dependence).

'REG_DEP_OUTPUT'
     This indicates an output dependence (a write after write
     dependence).

'REG_DEP_ANTI'
     This indicates an anti dependence (a write after read dependence).

 These notes describe information gathered from gcov profile data.  They
are stored in the 'REG_NOTES' field of an insn.

'REG_BR_PROB'
     This is used to specify the ratio of branches to non-branches of a
     branch insn according to the profile data.  The note is represented
     as an 'int_list' expression whose integer value is an encoding of
     'profile_probability' type.  'profile_probability' provide member
     function 'from_reg_br_prob_note' and 'to_reg_br_prob_note' to
     extract and store the probability into the RTL encoding.

'REG_BR_PRED'
     These notes are found in JUMP insns after delayed branch scheduling
     has taken place.  They indicate both the direction and the
     likelihood of the JUMP.  The format is a bitmask of ATTR_FLAG_*
     values.

'REG_FRAME_RELATED_EXPR'
     This is used on an RTX_FRAME_RELATED_P insn wherein the attached
     expression is used in place of the actual insn pattern.  This is
     done in cases where the pattern is either complex or misleading.

 The note 'REG_CALL_NOCF_CHECK' is used in conjunction with the
'-fcf-protection=branch' option.  The note is set if a 'nocf_check'
attribute is specified for a function type or a pointer to function
type.  The note is stored in the 'REG_NOTES' field of an insn.

'REG_CALL_NOCF_CHECK'
     Users have control through the 'nocf_check' attribute to identify
     which calls to a function should be skipped from control-flow
     instrumentation when the option '-fcf-protection=branch' is
     specified.  The compiler puts a 'REG_CALL_NOCF_CHECK' note on each
     'CALL_INSN' instruction that has a function type marked with a
     'nocf_check' attribute.

 For convenience, the machine mode in an 'insn_list' or 'expr_list' is
printed using these symbolic codes in debugging dumps.

 The only difference between the expression codes 'insn_list' and
'expr_list' is that the first operand of an 'insn_list' is assumed to be
an insn and is printed in debugging dumps as the insn's unique id; the
first operand of an 'expr_list' is printed in the ordinary way as an
expression.

==============================================================================
File: gccint.info,  Node: |Calls|,  Next: |Sharing|,  Prev: |Insns|,  Up: |RTL|
==============================================================================

                                                                         *Calls*

14.20 RTL Representation of Function-Call Insns
-----------------------------------------------

Insns that call subroutines have the RTL expression code 'call_insn'.
These insns must satisfy special rules, and their bodies must use a
special RTL expression code, 'call'.

 A 'call' expression has two operands, as follows:

     (call (mem:FM ADDR) NBYTES)

Here NBYTES is an operand that represents the number of bytes of
argument data being passed to the subroutine, FM is a machine mode
(which must equal as the definition of the 'FUNCTION_MODE' macro in the
machine description) and ADDR represents the address of the subroutine.

 For a subroutine that returns no value, the 'call' expression as shown
above is the entire body of the insn, except that the insn might also
contain 'use' or 'clobber' expressions.

 For a subroutine that returns a value whose mode is not 'BLKmode', the
value is returned in a hard register.  If this register's number is R,
then the body of the call insn looks like this:

     (set (reg:M R)
          (call (mem:FM ADDR) NBYTES))

This RTL expression makes it clear (to the optimizer passes) that the
appropriate register receives a useful value in this insn.

 When a subroutine returns a 'BLKmode' value, it is handled by passing
to the subroutine the address of a place to store the value.  So the
call insn itself does not "return" any value, and it has the same RTL
form as a call that returns nothing.

 On some machines, the call instruction itself clobbers some register,
for example to contain the return address.  'call_insn' insns on these
machines should have a body which is a 'parallel' that contains both the
'call' expression and 'clobber' expressions that indicate which
registers are destroyed.  Similarly, if the call instruction requires
some register other than the stack pointer that is not explicitly
mentioned in its RTL, a 'use' subexpression should mention that
register.

 Functions that are called are assumed to modify all registers listed in
the configuration macro 'CALL_USED_REGISTERS' (*note Register Basics::)
and, with the exception of 'const' functions and library calls, to
modify all of memory.

 Insns containing just 'use' expressions directly precede the
'call_insn' insn to indicate which registers contain inputs to the
function.  Similarly, if registers other than those in
'CALL_USED_REGISTERS' are clobbered by the called function, insns
containing a single 'clobber' follow immediately after the call to
indicate which registers.

==============================================================================
File: gccint.info,  Node: |Sharing|,  Next: |Reading_RTL|,  Prev: |Calls|,  Up: |RTL|
==============================================================================

                                                                       *Sharing*

14.21 Structure Sharing Assumptions
-----------------------------------

The compiler assumes that certain kinds of RTL expressions are unique;
there do not exist two distinct objects representing the same value.  In
other cases, it makes an opposite assumption: that no RTL expression
object of a certain kind appears in more than one place in the
containing structure.

 These assumptions refer to a single function; except for the RTL
objects that describe global variables and external functions, and a few
standard objects such as small integer constants, no RTL objects are
common to two functions.

   * Each pseudo-register has only a single 'reg' object to represent
     it, and therefore only a single machine mode.

   * For any symbolic label, there is only one 'symbol_ref' object
     referring to it.

   * All 'const_int' expressions with equal values are shared.

   * All 'const_poly_int' expressions with equal modes and values are
     shared.

   * There is only one 'pc' expression.

   * There is only one 'cc0' expression.

   * There is only one 'const_double' expression with value 0 for each
     floating point mode.  Likewise for values 1 and 2.

   * There is only one 'const_vector' expression with value 0 for each
     vector mode, be it an integer or a double constant vector.

   * No 'label_ref' or 'scratch' appears in more than one place in the
     RTL structure; in other words, it is safe to do a tree-walk of all
     the insns in the function and assume that each time a 'label_ref'
     or 'scratch' is seen it is distinct from all others that are seen.

   * Only one 'mem' object is normally created for each static variable
     or stack slot, so these objects are frequently shared in all the
     places they appear.  However, separate but equal objects for these
     variables are occasionally made.

   * When a single 'asm' statement has multiple output operands, a
     distinct 'asm_operands' expression is made for each output operand.
     However, these all share the vector which contains the sequence of
     input operands.  This sharing is used later on to test whether two
     'asm_operands' expressions come from the same statement, so all
     optimizations must carefully preserve the sharing if they copy the
     vector at all.

   * No RTL object appears in more than one place in the RTL structure
     except as described above.  Many passes of the compiler rely on
     this by assuming that they can modify RTL objects in place without
     unwanted side-effects on other insns.

   * During initial RTL generation, shared structure is freely
     introduced.  After all the RTL for a function has been generated,
     all shared structure is copied by 'unshare_all_rtl' in
     'emit-rtl.c', after which the above rules are guaranteed to be
     followed.

   * During the combiner pass, shared structure within an insn can exist
     temporarily.  However, the shared structure is copied before the
     combiner is finished with the insn.  This is done by calling
     'copy_rtx_if_shared', which is a subroutine of 'unshare_all_rtl'.

==============================================================================
File: gccint.info,  Node: |Reading_RTL|,  Prev: |Sharing|,  Up: |RTL|
==============================================================================

                                                                   *Reading_RTL*

14.22 Reading RTL
-----------------

To read an RTL object from a file, call 'read_rtx'.  It takes one
argument, a stdio stream, and returns a single RTL object.  This routine
is defined in 'read-rtl.c'.  It is not available in the compiler itself,
only the various programs that generate the compiler back end from the
machine description.

 People frequently have the idea of using RTL stored as text in a file
as an interface between a language front end and the bulk of GCC.  This
idea is not feasible.

 GCC was designed to use RTL internally only.  Correct RTL for a given
program is very dependent on the particular target machine.  And the RTL
does not contain all the information about the program.

 The proper way to interface GCC to a new language front end is with the
"tree" data structure, described in the files 'tree.h' and 'tree.def'.
The documentation for this structure (*note GENERIC::) is incomplete.

==============================================================================
File: gccint.info,  Node: |Control_Flow|,  Next: |Loop_Analysis_and_Representation|,  Prev: |RTL|,  Up: |Top|
==============================================================================

                                                                  *Control_Flow*

15 Control Flow Graph
=====================

A control flow graph (CFG) is a data structure built on top of the
intermediate code representation (the RTL or 'GIMPLE' instruction
stream) abstracting the control flow behavior of a function that is
being compiled.  The CFG is a directed graph where the vertices
represent basic blocks and edges represent possible transfer of control
flow from one basic block to another.  The data structures used to
represent the control flow graph are defined in 'basic-block.h'.

 In GCC, the representation of control flow is maintained throughout the
compilation process, from constructing the CFG early in 'pass_build_cfg'
to 'pass_free_cfg' (see 'passes.def').  The CFG takes various different
modes and may undergo extensive manipulations, but the graph is always
valid between its construction and its release.  This way, transfer of
information such as data flow, a measured profile, or the loop tree, can
be propagated through the passes pipeline, and even from 'GIMPLE' to
'RTL'.

 Often the CFG may be better viewed as integral part of instruction
chain, than structure built on the top of it.  Updating the compiler's
intermediate representation for instructions cannot be easily done
without proper maintenance of the CFG simultaneously.

MENU

* |Basic_Blocks|::           The definition and representation of basic blocks.
* |Edges|::                  Types of edges and their representation.
* |Profile_information|::    Representation of frequencies and probabilities.
* |Maintaining_the_CFG|::    Keeping the control flow graph and up to date.
* |Liveness_information|::   Using and maintaining liveness information.

==============================================================================
File: gccint.info,  Node: |Basic_Blocks|,  Next: |Edges|,  Up: |Control_Flow|
==============================================================================

                                                                  *Basic_Blocks*

15.1 Basic Blocks
-----------------

A basic block is a straight-line sequence of code with only one entry
point and only one exit.  In GCC, basic blocks are represented using the
'basic_block' data type.

 Special basic blocks represent possible entry and exit points of a
function.  These blocks are called 'ENTRY_BLOCK_PTR' and
'EXIT_BLOCK_PTR'.  These blocks do not contain any code.

 The 'BASIC_BLOCK' array contains all basic blocks in an unspecified
order.  Each 'basic_block' structure has a field that holds a unique
integer identifier 'index' that is the index of the block in the
'BASIC_BLOCK' array.  The total number of basic blocks in the function
is 'n_basic_blocks'.  Both the basic block indices and the total number
of basic blocks may vary during the compilation process, as passes
reorder, create, duplicate, and destroy basic blocks.  The index for any
block should never be greater than 'last_basic_block'.  The indices 0
and 1 are special codes reserved for 'ENTRY_BLOCK' and 'EXIT_BLOCK', the
indices of 'ENTRY_BLOCK_PTR' and 'EXIT_BLOCK_PTR'.

 Two pointer members of the 'basic_block' structure are the pointers
'next_bb' and 'prev_bb'.  These are used to keep doubly linked chain of
basic blocks in the same order as the underlying instruction stream.
The chain of basic blocks is updated transparently by the provided API
for manipulating the CFG.  The macro 'FOR_EACH_BB' can be used to visit
all the basic blocks in lexicographical order, except 'ENTRY_BLOCK' and
'EXIT_BLOCK'.  The macro 'FOR_ALL_BB' also visits all basic blocks in
lexicographical order, including 'ENTRY_BLOCK' and 'EXIT_BLOCK'.

 The functions 'post_order_compute' and 'inverted_post_order_compute'
can be used to compute topological orders of the CFG. The orders are
stored as vectors of basic block indices.  The 'BASIC_BLOCK' array can
be used to iterate each basic block by index.  Dominator traversals are
also possible using 'walk_dominator_tree'.  Given two basic blocks A and
B, block A dominates block B if A is _always_ executed before B.

 Each 'basic_block' also contains pointers to the first instruction (the
"head") and the last instruction (the "tail") or "end" of the
instruction stream contained in a basic block.  In fact, since the
'basic_block' data type is used to represent blocks in both major
intermediate representations of GCC ('GIMPLE' and RTL), there are
pointers to the head and end of a basic block for both representations,
stored in intermediate representation specific data in the 'il' field of
'struct basic_block_def'.

 For RTL, these pointers are 'BB_HEAD' and 'BB_END'.

 In the RTL representation of a function, the instruction stream
contains not only the "real" instructions, but also "notes" or "insn
notes" (to distinguish them from "reg notes").  Any function that moves
or duplicates the basic blocks needs to take care of updating of these
notes.  Many of these notes expect that the instruction stream consists
of linear regions, so updating can sometimes be tedious.  All types of
insn notes are defined in 'insn-notes.def'.

 In the RTL function representation, the instructions contained in a
basic block always follow a 'NOTE_INSN_BASIC_BLOCK', but zero or more
'CODE_LABEL' nodes can precede the block note.  A basic block ends with
a control flow instruction or with the last instruction before the next
'CODE_LABEL' or 'NOTE_INSN_BASIC_BLOCK'.  By definition, a 'CODE_LABEL'
cannot appear in the middle of the instruction stream of a basic block.

 In addition to notes, the jump table vectors are also represented as
"pseudo-instructions" inside the insn stream.  These vectors never
appear in the basic block and should always be placed just after the
table jump instructions referencing them.  After removing the table-jump
it is often difficult to eliminate the code computing the address and
referencing the vector, so cleaning up these vectors is postponed until
after liveness analysis.  Thus the jump table vectors may appear in the
insn stream unreferenced and without any purpose.  Before any edge is
made "fall-thru", the existence of such construct in the way needs to be
checked by calling 'can_fallthru' function.

 For the 'GIMPLE' representation, the PHI nodes and statements contained
in a basic block are in a 'gimple_seq' pointed to by the basic block
intermediate language specific pointers.  Abstract containers and
iterators are used to access the PHI nodes and statements in a basic
blocks.  These iterators are called "GIMPLE statement iterators" (GSIs).
Grep for '^gsi' in the various 'gimple-*' and 'tree-*' files.  There is
a 'gimple_stmt_iterator' type for iterating over all kinds of statement,
and a 'gphi_iterator' subclass for iterating over PHI nodes.  The
following snippet will pretty-print all PHI nodes the statements of the
current function in the GIMPLE representation.

     basic_block bb;

     FOR_EACH_BB (bb)
       {
        gphi_iterator pi;
        gimple_stmt_iterator si;

        for (pi = gsi_start_phis (bb); !gsi_end_p (pi); gsi_next (&pi))
          {
            gphi *phi = pi.phi ();
            print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);
          }
        for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))
          {
            gimple stmt = gsi_stmt (si);
            print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);
          }
       }

==============================================================================
File: gccint.info,  Node: |Edges|,  Next: |Profile_information|,  Prev: |Basic_Blocks|,  Up: |Control_Flow|
==============================================================================

                                                                         *Edges*

15.2 Edges
----------

Edges represent possible control flow transfers from the end of some
basic block A to the head of another basic block B.  We say that A is a
predecessor of B, and B is a successor of A.  Edges are represented in
GCC with the 'edge' data type.  Each 'edge' acts as a link between two
basic blocks: The 'src' member of an edge points to the predecessor
basic block of the 'dest' basic block.  The members 'preds' and 'succs'
of the 'basic_block' data type point to type-safe vectors of edges to
the predecessors and successors of the block.

 When walking the edges in an edge vector, "edge iterators" should be
used.  Edge iterators are constructed using the 'edge_iterator' data
structure and several methods are available to operate on them:

'ei_start'
     This function initializes an 'edge_iterator' that points to the
     first edge in a vector of edges.

'ei_last'
     This function initializes an 'edge_iterator' that points to the
     last edge in a vector of edges.

'ei_end_p'
     This predicate is 'true' if an 'edge_iterator' represents the last
     edge in an edge vector.

'ei_one_before_end_p'
     This predicate is 'true' if an 'edge_iterator' represents the
     second last edge in an edge vector.

'ei_next'
     This function takes a pointer to an 'edge_iterator' and makes it
     point to the next edge in the sequence.

'ei_prev'
     This function takes a pointer to an 'edge_iterator' and makes it
     point to the previous edge in the sequence.

'ei_edge'
     This function returns the 'edge' currently pointed to by an
     'edge_iterator'.

'ei_safe_safe'
     This function returns the 'edge' currently pointed to by an
     'edge_iterator', but returns 'NULL' if the iterator is pointing at
     the end of the sequence.  This function has been provided for
     existing code makes the assumption that a 'NULL' edge indicates the
     end of the sequence.

 The convenience macro 'FOR_EACH_EDGE' can be used to visit all of the
edges in a sequence of predecessor or successor edges.  It must not be
used when an element might be removed during the traversal, otherwise
elements will be missed.  Here is an example of how to use the macro:

     edge e;
     edge_iterator ei;

     FOR_EACH_EDGE (e, ei, bb->succs)
       {
          if (e->flags & EDGE_FALLTHRU)
            break;
       }

 There are various reasons why control flow may transfer from one block
to another.  One possibility is that some instruction, for example a
'CODE_LABEL', in a linearized instruction stream just always starts a
new basic block.  In this case a "fall-thru" edge links the basic block
to the first following basic block.  But there are several other reasons
why edges may be created.  The 'flags' field of the 'edge' data type is
used to store information about the type of edge we are dealing with.
Each edge is of one of the following types:

_jump_
     No type flags are set for edges corresponding to jump instructions.
     These edges are used for unconditional or conditional jumps and in
     RTL also for table jumps.  They are the easiest to manipulate as
     they may be freely redirected when the flow graph is not in SSA
     form.

_fall-thru_
     Fall-thru edges are present in case where the basic block may
     continue execution to the following one without branching.  These
     edges have the 'EDGE_FALLTHRU' flag set.  Unlike other types of
     edges, these edges must come into the basic block immediately
     following in the instruction stream.  The function
     'force_nonfallthru' is available to insert an unconditional jump in
     the case that redirection is needed.  Note that this may require
     creation of a new basic block.

_exception handling_
     Exception handling edges represent possible control transfers from
     a trapping instruction to an exception handler.  The definition of
     "trapping" varies.  In C++, only function calls can throw, but for
     Ada exceptions like division by zero or segmentation fault are
     defined and thus each instruction possibly throwing this kind of
     exception needs to be handled as control flow instruction.
     Exception edges have the 'EDGE_ABNORMAL' and 'EDGE_EH' flags set.

     When updating the instruction stream it is easy to change possibly
     trapping instruction to non-trapping, by simply removing the
     exception edge.  The opposite conversion is difficult, but should
     not happen anyway.  The edges can be eliminated via
     'purge_dead_edges' call.

     In the RTL representation, the destination of an exception edge is
     specified by 'REG_EH_REGION' note attached to the insn.  In case of
     a trapping call the 'EDGE_ABNORMAL_CALL' flag is set too.  In the
     'GIMPLE' representation, this extra flag is not set.

     In the RTL representation, the predicate 'may_trap_p' may be used
     to check whether instruction still may trap or not.  For the tree
     representation, the 'tree_could_trap_p' predicate is available, but
     this predicate only checks for possible memory traps, as in
     dereferencing an invalid pointer location.

_sibling calls_
     Sibling calls or tail calls terminate the function in a
     non-standard way and thus an edge to the exit must be present.
     'EDGE_SIBCALL' and 'EDGE_ABNORMAL' are set in such case.  These
     edges only exist in the RTL representation.

_computed jumps_
     Computed jumps contain edges to all labels in the function
     referenced from the code.  All those edges have 'EDGE_ABNORMAL'
     flag set.  The edges used to represent computed jumps often cause
     compile time performance problems, since functions consisting of
     many taken labels and many computed jumps may have _very_ dense
     flow graphs, so these edges need to be handled with special care.
     During the earlier stages of the compilation process, GCC tries to
     avoid such dense flow graphs by factoring computed jumps.  For
     example, given the following series of jumps,

            goto *x;
            [ ... ]

            goto *x;
            [ ... ]

            goto *x;
            [ ... ]

     factoring the computed jumps results in the following code sequence
     which has a much simpler flow graph:

            goto y;
            [ ... ]

            goto y;
            [ ... ]

            goto y;
            [ ... ]

          y:
            goto *x;

     However, the classic problem with this transformation is that it
     has a runtime cost in there resulting code: An extra jump.
     Therefore, the computed jumps are un-factored in the later passes
     of the compiler (in the pass called
     'pass_duplicate_computed_gotos').  Be aware of that when you work
     on passes in that area.  There have been numerous examples already
     where the compile time for code with unfactored computed jumps
     caused some serious headaches.

_nonlocal goto handlers_
     GCC allows nested functions to return into caller using a 'goto' to
     a label passed to as an argument to the callee.  The labels passed
     to nested functions contain special code to cleanup after function
     call.  Such sections of code are referred to as "nonlocal goto
     receivers".  If a function contains such nonlocal goto receivers,
     an edge from the call to the label is created with the
     'EDGE_ABNORMAL' and 'EDGE_ABNORMAL_CALL' flags set.

_function entry points_
     By definition, execution of function starts at basic block 0, so
     there is always an edge from the 'ENTRY_BLOCK_PTR' to basic block
     0.  There is no 'GIMPLE' representation for alternate entry points
     at this moment.  In RTL, alternate entry points are specified by
     'CODE_LABEL' with 'LABEL_ALTERNATE_NAME' defined.  This feature is
     currently used for multiple entry point prologues and is limited to
     post-reload passes only.  This can be used by back-ends to emit
     alternate prologues for functions called from different contexts.
     In future full support for multiple entry functions defined by
     Fortran 90 needs to be implemented.

_function exits_
     In the pre-reload representation a function terminates after the
     last instruction in the insn chain and no explicit return
     instructions are used.  This corresponds to the fall-thru edge into
     exit block.  After reload, optimal RTL epilogues are used that use
     explicit (conditional) return instructions that are represented by
     edges with no flags set.

==============================================================================
File: gccint.info,  Node: |Profile_information|,  Next: |Maintaining_the_CFG|,  Prev: |Edges|,  Up: |Control_Flow|
==============================================================================

                                                           *Profile_information*

15.3 Profile information
------------------------

In many cases a compiler must make a choice whether to trade speed in
one part of code for speed in another, or to trade code size for code
speed.  In such cases it is useful to know information about how often
some given block will be executed.  That is the purpose for maintaining
profile within the flow graph.  GCC can handle profile information
obtained through "profile feedback", but it can also estimate branch
probabilities based on statics and heuristics.

 The feedback based profile is produced by compiling the program with
instrumentation, executing it on a train run and reading the numbers of
executions of basic blocks and edges back to the compiler while
re-compiling the program to produce the final executable.  This method
provides very accurate information about where a program spends most of
its time on the train run.  Whether it matches the average run of course
depends on the choice of train data set, but several studies have shown
that the behavior of a program usually changes just marginally over
different data sets.

 When profile feedback is not available, the compiler may be asked to
attempt to predict the behavior of each branch in the program using a
set of heuristics (see 'predict.def' for details) and compute estimated
frequencies of each basic block by propagating the probabilities over
the graph.

 Each 'basic_block' contains two integer fields to represent profile
information: 'frequency' and 'count'.  The 'frequency' is an estimation
how often is basic block executed within a function.  It is represented
as an integer scaled in the range from 0 to 'BB_FREQ_BASE'.  The most
frequently executed basic block in function is initially set to
'BB_FREQ_BASE' and the rest of frequencies are scaled accordingly.
During optimization, the frequency of the most frequent basic block can
both decrease (for instance by loop unrolling) or grow (for instance by
cross-jumping optimization), so scaling sometimes has to be performed
multiple times.

 The 'count' contains hard-counted numbers of execution measured during
training runs and is nonzero only when profile feedback is available.
This value is represented as the host's widest integer (typically a 64
bit integer) of the special type 'gcov_type'.

 Most optimization passes can use only the frequency information of a
basic block, but a few passes may want to know hard execution counts.
The frequencies should always match the counts after scaling, however
during updating of the profile information numerical error may
accumulate into quite large errors.

 Each edge also contains a branch probability field: an integer in the
range from 0 to 'REG_BR_PROB_BASE'.  It represents probability of
passing control from the end of the 'src' basic block to the 'dest'
basic block, i.e. the probability that control will flow along this
edge.  The 'EDGE_FREQUENCY' macro is available to compute how frequently
a given edge is taken.  There is a 'count' field for each edge as well,
representing same information as for a basic block.

 The basic block frequencies are not represented in the instruction
stream, but in the RTL representation the edge frequencies are
represented for conditional jumps (via the 'REG_BR_PROB' macro) since
they are used when instructions are output to the assembly file and the
flow graph is no longer maintained.

 The probability that control flow arrives via a given edge to its
destination basic block is called "reverse probability" and is not
directly represented, but it may be easily computed from frequencies of
basic blocks.

 Updating profile information is a delicate task that can unfortunately
not be easily integrated with the CFG manipulation API.  Many of the
functions and hooks to modify the CFG, such as
'redirect_edge_and_branch', do not have enough information to easily
update the profile, so updating it is in the majority of cases left up
to the caller.  It is difficult to uncover bugs in the profile updating
code, because they manifest themselves only by producing worse code, and
checking profile consistency is not possible because of numeric error
accumulation.  Hence special attention needs to be given to this issue
in each pass that modifies the CFG.

 It is important to point out that 'REG_BR_PROB_BASE' and 'BB_FREQ_BASE'
are both set low enough to be possible to compute second power of any
frequency or probability in the flow graph, it is not possible to even
square the 'count' field, as modern CPUs are fast enough to execute
$2^32$ operations quickly.

==============================================================================
File: gccint.info,  Node: |Maintaining_the_CFG|,  Next: |Liveness_information|,  Prev: |Profile_information|,  Up: |Control_Flow|
==============================================================================

                                                           *Maintaining_the_CFG*

15.4 Maintaining the CFG
------------------------

An important task of each compiler pass is to keep both the control flow
graph and all profile information up-to-date.  Reconstruction of the
control flow graph after each pass is not an option, since it may be
very expensive and lost profile information cannot be reconstructed at
all.

 GCC has two major intermediate representations, and both use the
'basic_block' and 'edge' data types to represent control flow.  Both
representations share as much of the CFG maintenance code as possible.
For each representation, a set of "hooks" is defined so that each
representation can provide its own implementation of CFG manipulation
routines when necessary.  These hooks are defined in 'cfghooks.h'.
There are hooks for almost all common CFG manipulations, including block
splitting and merging, edge redirection and creating and deleting basic
blocks.  These hooks should provide everything you need to maintain and
manipulate the CFG in both the RTL and 'GIMPLE' representation.

 At the moment, the basic block boundaries are maintained transparently
when modifying instructions, so there rarely is a need to move them
manually (such as in case someone wants to output instruction outside
basic block explicitly).

 In the RTL representation, each instruction has a 'BLOCK_FOR_INSN'
value that represents pointer to the basic block that contains the
instruction.  In the 'GIMPLE' representation, the function 'gimple_bb'
returns a pointer to the basic block containing the queried statement.

 When changes need to be applied to a function in its 'GIMPLE'
representation, "GIMPLE statement iterators" should be used.  These
iterators provide an integrated abstraction of the flow graph and the
instruction stream.  Block statement iterators are constructed using the
'gimple_stmt_iterator' data structure and several modifiers are
available, including the following:

'gsi_start'
     This function initializes a 'gimple_stmt_iterator' that points to
     the first non-empty statement in a basic block.

'gsi_last'
     This function initializes a 'gimple_stmt_iterator' that points to
     the last statement in a basic block.

'gsi_end_p'
     This predicate is 'true' if a 'gimple_stmt_iterator' represents the
     end of a basic block.

'gsi_next'
     This function takes a 'gimple_stmt_iterator' and makes it point to
     its successor.

'gsi_prev'
     This function takes a 'gimple_stmt_iterator' and makes it point to
     its predecessor.

'gsi_insert_after'
     This function inserts a statement after the 'gimple_stmt_iterator'
     passed in.  The final parameter determines whether the statement
     iterator is updated to point to the newly inserted statement, or
     left pointing to the original statement.

'gsi_insert_before'
     This function inserts a statement before the 'gimple_stmt_iterator'
     passed in.  The final parameter determines whether the statement
     iterator is updated to point to the newly inserted statement, or
     left pointing to the original statement.

'gsi_remove'
     This function removes the 'gimple_stmt_iterator' passed in and
     rechains the remaining statements in a basic block, if any.

 In the RTL representation, the macros 'BB_HEAD' and 'BB_END' may be
used to get the head and end 'rtx' of a basic block.  No abstract
iterators are defined for traversing the insn chain, but you can just
use 'NEXT_INSN' and 'PREV_INSN' instead.  *Note Insns::.

 Usually a code manipulating pass simplifies the instruction stream and
the flow of control, possibly eliminating some edges.  This may for
example happen when a conditional jump is replaced with an unconditional
jump.  Updating of edges is not transparent and each optimization pass
is required to do so manually.  However only few cases occur in
practice.  The pass may call 'purge_dead_edges' on a given basic block
to remove superfluous edges, if any.

 Another common scenario is redirection of branch instructions, but this
is best modeled as redirection of edges in the control flow graph and
thus use of 'redirect_edge_and_branch' is preferred over more low level
functions, such as 'redirect_jump' that operate on RTL chain only.  The
CFG hooks defined in 'cfghooks.h' should provide the complete API
required for manipulating and maintaining the CFG.

 It is also possible that a pass has to insert control flow instruction
into the middle of a basic block, thus creating an entry point in the
middle of the basic block, which is impossible by definition: The block
must be split to make sure it only has one entry point, i.e. the head of
the basic block.  The CFG hook 'split_block' may be used when an
instruction in the middle of a basic block has to become the target of a
jump or branch instruction.

 For a global optimizer, a common operation is to split edges in the
flow graph and insert instructions on them.  In the RTL representation,
this can be easily done using the 'insert_insn_on_edge' function that
emits an instruction "on the edge", caching it for a later
'commit_edge_insertions' call that will take care of moving the inserted
instructions off the edge into the instruction stream contained in a
basic block.  This includes the creation of new basic blocks where
needed.  In the 'GIMPLE' representation, the equivalent functions are
'gsi_insert_on_edge' which inserts a block statement iterator on an
edge, and 'gsi_commit_edge_inserts' which flushes the instruction to
actual instruction stream.

 While debugging the optimization pass, the 'verify_flow_info' function
may be useful to find bugs in the control flow graph updating code.

==============================================================================
File: gccint.info,  Node: |Liveness_information|,  Prev: |Maintaining_the_CFG|,  Up: |Control_Flow|
==============================================================================

                                                          *Liveness_information*

15.5 Liveness information
-------------------------

Liveness information is useful to determine whether some register is
"live" at given point of program, i.e. that it contains a value that may
be used at a later point in the program.  This information is used, for
instance, during register allocation, as the pseudo registers only need
to be assigned to a unique hard register or to a stack slot if they are
live.  The hard registers and stack slots may be freely reused for other
values when a register is dead.

 Liveness information is available in the back end starting with
'pass_df_initialize' and ending with 'pass_df_finish'.  Three flavors of
live analysis are available: With 'LR', it is possible to determine at
any point 'P' in the function if the register may be used on some path
from 'P' to the end of the function.  With 'UR', it is possible to
determine if there is a path from the beginning of the function to 'P'
that defines the variable.  'LIVE' is the intersection of the 'LR' and
'UR' and a variable is live at 'P' if there is both an assignment that
reaches it from the beginning of the function and a use that can be
reached on some path from 'P' to the end of the function.

 In general 'LIVE' is the most useful of the three.  The macros
'DF_[LR,UR,LIVE]_[IN,OUT]' can be used to access this information.  The
macros take a basic block number and return a bitmap that is indexed by
the register number.  This information is only guaranteed to be up to
date after calls are made to 'df_analyze'.  See the file 'df-core.c' for
details on using the dataflow.

 The liveness information is stored partly in the RTL instruction stream
and partly in the flow graph.  Local information is stored in the
instruction stream: Each instruction may contain 'REG_DEAD' notes
representing that the value of a given register is no longer needed, or
'REG_UNUSED' notes representing that the value computed by the
instruction is never used.  The second is useful for instructions
computing multiple values at once.

==============================================================================
File: gccint.info,  Node: |Loop_Analysis_and_Representation|,  Next: |Machine_Desc|,  Prev: |Control_Flow|,  Up: |Top|
==============================================================================

                                              *Loop_Analysis_and_Representation*

16 Analysis and Representation of Loops
=======================================

GCC provides extensive infrastructure for work with natural loops, i.e.,
strongly connected components of CFG with only one entry block.  This
chapter describes representation of loops in GCC, both on GIMPLE and in
RTL, as well as the interfaces to loop-related analyses (induction
variable analysis and number of iterations analysis).

MENU

* |Loop_representation|::         Representation and analysis of loops.
* |Loop_querying|::               Getting information about loops.
* |Loop_manipulation|::           Loop manipulation functions.
* |LCSSA|::                       Loop-closed SSA form.
* |Scalar_evolutions|::           Induction variables on GIMPLE.
* |loop_iv|::                     Induction variables on RTL.
* |Number_of_iterations|::        Number of iterations analysis.
* |Dependency_analysis|::         Data dependency analysis.

vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
