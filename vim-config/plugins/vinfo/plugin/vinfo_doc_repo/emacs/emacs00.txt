==============================================================================
File: emacs.info,  Node: |Top|,  Next: |Distrib|,  Up: (dir)
==============================================================================

                                                                           *Top*

The Emacs Editor
================

Emacs is the extensible, customizable, self-documenting real-time
display editor.  This manual describes how to edit with Emacs and some
of the ways to customize it; it corresponds to GNU Emacs version 27.1.

   If you are reading this in Emacs, type 'h' to read a basic
introduction to the Info documentation system.

   For information on extending Emacs, see *note Emacs Lisp: (elisp)Top.

   This is the 'GNU Emacs Manual', updated for Emacs version 27.1.

   Copyright (C) 1985-1987, 1993-2020 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "The GNU Manifesto,"
     "Distribution" and "GNU GENERAL PUBLIC LICENSE," with the
     Front-Cover Texts being "A GNU Manual," and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

MENU

* |Distrib|::             How to get the latest Emacs distribution.
* |Intro|::               An introduction to Emacs concepts.

Important General Concepts
* |Screen|::              How to interpret what you see on the screen.
* |User_Input|::          Kinds of input events (characters, buttons,
                          function keys).
* |Keys|::                Key sequences: what you type to request one
                          editing action.
* |Commands|::            Named functions run by key sequences to do editing.
* |Entering_Emacs|::      Starting Emacs from the shell.
* |Exiting|::             Stopping or killing Emacs.

Fundamental Editing Commands
* |Basic|::               The most basic editing commands.
* |Minibuffer|::          Entering arguments that are prompted for.
* |M_x|::                 Invoking commands by their names.
* |Help|::                Commands for asking Emacs about its commands.

Important Text-Changing Commands
* |Mark|::                The mark: how to delimit a region of text.
* |Killing|::             Killing (cutting) and yanking (copying) text.
* |Registers|::           Saving a text string or a location in the buffer.
* |Display|::             Controlling what text is displayed.
* |Search|::              Finding or replacing occurrences of a string.
* |Fixit|::               Commands especially useful for fixing typos.
* |Keyboard_Macros|::     Recording a sequence of keystrokes to be replayed.

Major Structures of Emacs
* |Files|::               All about handling files.
* |Buffers|::             Multiple buffers; editing several files at once.
* |Windows|::             Viewing multiple pieces of text in one frame.
* |Frames|::              Using multiple windows on your display.
* |International|::       Using non-ASCII character sets.

Advanced Features
* |Modes|::               Major and minor modes alter Emacs's basic behavior.
* |Indentation|::         Editing the white space at the beginnings of lines.
* |Text|::                Commands and modes for editing human languages.
* |Programs|::            Commands and modes for editing programs.
* |Building|::            Compiling, running and debugging programs.
* |Maintaining|::         Features for maintaining large programs.
* |Abbrevs|::             Defining text abbreviations to reduce typing.
* |Dired|::               Directory and file manager.
* |Calendar/Diary|::      Calendar and diary facilities.
* |Sending_Mail|::        Sending mail in Emacs.
* |Rmail|::               Reading mail in Emacs.
* |Gnus|::                A flexible mail and news reader.
* |Host_Security|::       Security issues on a single computer.
* |Network_Security|::    Managing the network security.
* |Document_View|::       Viewing PDF, PS and DVI files.
* |Shell|::               Executing shell commands from Emacs.
* |Emacs_Server|::        Using Emacs as an editing server.
* |Printing|::            Printing hardcopies of buffers or regions.
* |Sorting|::             Sorting lines, paragraphs or pages within Emacs.
* |Picture_Mode|::        Editing pictures made up of text characters.
* |Editing_Binary_Files|::  Editing binary files with Hexl mode.
* |Saving_Emacs_Sessions|:: Saving Emacs state from one session to the next.
* |Recursive_Edit|::      Performing edits while within another command.
* |Hyperlinking|::        Following links in buffers.
* |Amusements|::          Various games and hacks.
* |Packages|::            Installing additional features.
* |Customization|::       Modifying the behavior of Emacs.

Recovery from Problems
* |Quitting|::            Quitting and aborting.
* |Lossage|::             What to do if Emacs is hung or malfunctioning.
* |Bugs|::                How and when to report a bug.
* |Contributing|::        How to contribute improvements to Emacs.
* |Service|::             How to get help for your own Emacs needs.

Appendices
* |Copying|::             The GNU General Public License gives you permission
                          to redistribute GNU Emacs on certain terms;
                          it also explains that there is no warranty.
* |GNU_Free_Documentation_License|:: The license for this documentation.
* |Emacs_Invocation|::    Hairy startup options.
* |X_Resources|::         X resources for customizing Emacs.
* |Antinews|::            Information about Emacs version 26.
* |Mac_OS_/_GNUstep|::     Using Emacs under macOS and GNUstep.
* |Microsoft_Windows|::   Using Emacs on Microsoft Windows and MS-DOS.
* |Manifesto|::           What's GNU?  Gnu's Not Unix!

* |Glossary|::            Terms used in this manual.
* |Acknowledgments|::     Major contributors to GNU Emacs.

Indexes (each index contains a large menu)
* |Key_Index|::           An item for each standard Emacs key sequence.
* |Option_Index|::        An item for every command-line option.
* |Command_Index|::       An item for each standard command name.
* |Variable_Index|::      An item for each variable documented in this manual.
* |Concept_Index|::       An item for concepts and other general subjects.


 -- The Detailed Node Listing --
 ----------------------

Here are some other nodes which are really subnodes of the ones
already listed, mentioned here so you can get to them in one step:

The Organization of the Screen

* |Point|::               The place in the text where editing commands operate.
* |Echo_Area|::           Short messages appear at the bottom of the screen.
* |Mode_Line|::           Interpreting the mode line.
* |Menu_Bar|::            How to use the menu bar.

Basic Editing Commands

* |Inserting_Text|::      Inserting text by simply typing it.
* |Moving_Point|::        Moving the cursor to the place where you want to
                        change something.
* |Erasing|::             Deleting and killing text.
* |Basic_Undo|::          Undoing recent changes in the text.
* |Basic_Files|::         Visiting, creating, and saving files.
* |Basic_Help|::          Asking what a character does.
* |Blank_Lines|::         Making and deleting blank lines.
* |Continuation_Lines|::  How Emacs displays lines too wide for the screen.
* |Position_Info|::       What line, row, or column is point on?
* |Arguments|::           Numeric arguments for repeating a command N times.
* |Repeating|::           Repeating the previous command quickly.

The Minibuffer

* |Basic_Minibuffer|::      Basic usage of the minibuffer.
* |Minibuffer_File|::     Entering file names with the minibuffer.
* |Minibuffer_Edit|::     How to edit in the minibuffer.
* |Completion|::          An abbreviation facility for minibuffer input.
* |Minibuffer_History|::  Reusing recent minibuffer arguments.
* |Repetition|::          Re-executing commands that used the minibuffer.
* |Passwords|::           Entering passwords in the echo area.
* |Yes_or_No_Prompts|::   Replying yes or no in the echo area.

Completion

* |Completion_Example|::  Examples of using completion.
* |Completion_Commands|:: A list of completion commands.
* |Completion_Exit|::     Completion and minibuffer text submission.
* |Completion_Styles|::   How completion matches are chosen.
* |Completion_Options|::  Options for completion.

Help

* |Help_Summary|::        Brief list of all Help commands.
* |Key_Help|::            Asking what a key does in Emacs.
* |Name_Help|::           Asking about a command, variable or function name.
* |Apropos|::             Asking what pertains to a given topic.
* |Help_Mode|::           Special features of Help mode and Help buffers.
* |Package_Keywords|::    Finding Lisp libraries by keywords (topics).
* |Language_Help|::       Help relating to international language support.
* |Misc_Help|::           Other help commands.
* |Help_Files|::          Commands to display auxiliary help files.
* |Help_Echo|::           Help on active text and tooltips.

The Mark and the Region

* |Setting_Mark|::        Commands to set the mark.
* |Marking_Objects|::     Commands to put region around textual units.
* |Using_Region|::        Summary of ways to operate on contents of the region.
* |Mark_Ring|::           Previous mark positions saved so you can go back there.
* |Global_Mark_Ring|::    Previous mark positions in various buffers.
* |Shift_Selection|::     Using shifted cursor motion keys.
* |Disabled_Transient_Mark|:: Leaving regions unhighlighted by default.

Killing and Moving Text

* |Deletion_and_Killing|:: Commands that remove text.
* |Yanking|::             Commands that insert text.
* |Cut_and_Paste|::       Clipboard and selections on graphical displays.
* |Accumulating_Text|::   Other methods to add text to the buffer.
* |Rectangles|::          Operating on text in rectangular areas.
* |CUA_Bindings|::        Using 'C-x'/'C-c'/'C-v' to kill and yank.

Deletion and Killing

* |Deletion|::            Commands for deleting small amounts of text and
                          blank areas.
* |Killing_by_Lines|::    How to kill entire lines of text at one time.
* |Other_Kill_Commands|:: Commands to kill large regions of text and
                          syntactic units such as words and sentences.
* |Kill_Options|::        Options that affect killing.

Yanking

* |Kill_Ring|::           Where killed text is stored.
* |Earlier_Kills|::       Yanking something killed some time ago.
* |Appending_Kills|::     Several kills in a row all yank together.

Cut and Paste Operations on Graphical Displays

* |Clipboard|::           How Emacs uses the system clipboard.
* |Primary_Selection|::   The temporarily selected text selection.
* |Secondary_Selection|:: Cutting without altering point and mark.

Registers

* |Position_Registers|::       Saving positions in registers.
* |Text_Registers|::           Saving text in registers.
* |Rectangle_Registers|::      Saving rectangles in registers.
* |Configuration_Registers|::  Saving window configurations in registers.
* |Number_Registers|::         Numbers in registers.
* |File_Registers|::           File names in registers.
* |Keyboard_Macro_Registers|:: Keyboard macros in registers.
* |Bookmarks|::                Bookmarks are like registers, but persistent.

Controlling the Display

* |Scrolling|::              Commands to move text up and down in a window.
* |Recentering|::            A scroll command that centers the current line.
* |Auto_Scrolling|::         Redisplay scrolls text automatically when needed.
* |Horizontal_Scrolling|::   Moving text left and right in a window.
* |Narrowing|::              Restricting display and editing to a portion
                             of the buffer.
* |View_Mode|::              Viewing read-only buffers.
* |Follow_Mode|::            Follow mode lets two windows scroll as one.
* |Faces|::                  How to change the display style using faces.
* |Colors|::                 Specifying colors for faces.
* |Standard_Faces|::         The main predefined faces.
* |Text_Scale|::             Increasing or decreasing text size in a buffer.
* |Font_Lock|::              Minor mode for syntactic highlighting using faces.
* |Highlight_Interactively|:: Tell Emacs what text to highlight.
* |Fringes|::                Enabling or disabling window fringes.
* |Displaying_Boundaries|::  Displaying top and bottom of the buffer.
* |Useless_Whitespace|::     Showing possibly spurious trailing whitespace.
* |Selective_Display|::      Hiding lines with lots of indentation.
* |Optional_Mode_Line|::     Optional mode line display features.
* |Text_Display|::           How text characters are normally displayed.
* |Cursor_Display|::         Features for displaying the cursor.
* |Line_Truncation|::        Truncating lines to fit the screen width instead
                             of continuing them to multiple screen lines.
* |Visual_Line_Mode|::       Word wrap and screen line-based editing.
* |Display_Custom|::         Information on variables for customizing display.

Searching and Replacement

* |Incremental_Search|::     Search happens as you type the string.
* |Nonincremental_Search|::  Specify entire string and then search.
* |Word_Search|::            Search for sequence of words.
* |Symbol_Search|::          Search for a source code symbol.
* |Regexp_Search|::          Search for match for a regexp.
* |Regexps|::                Syntax of regular expressions.
* |Regexp_Backslash|::       Regular expression constructs starting with '\'.
* |Regexp_Example|::         A complex regular expression explained.
* |Lax_Search|::                Search ignores some distinctions between
                                similar characters, like letter-case.
* |Replace|::                Search, and replace some or all matches.
* |Other_Repeating_Search|:: Operating on all matches for some regexp.
* |Search_Customizations|::  Various search customizations.

Incremental Search

* |Basic_Isearch|::        Basic incremental search commands.
* |Repeat_Isearch|::       Searching for the same string again.
* |Isearch_Yank|::         Commands that grab text into the search string
                           or else edit the search string.
* |Error_in_Isearch|::     When your string is not found.
* |Special_Isearch|::      Special input in incremental search.
* |Not_Exiting_Isearch|::  Prefix argument and scrolling commands.
* |Isearch_Minibuffer|::   Incremental search of the minibuffer history.

Replacement Commands

* |Unconditional_Replace|::  Replacing all matches for a string.
* |Regexp_Replace|::         Replacing all matches for a regexp.
* |Replacement_and_Lax_Matches|::
                           Lax searching for text to replace.
* |Query_Replace|::          How to use querying.

Commands for Fixing Typos

* |Undo|::                The Undo commands.
* |Transpose|::           Exchanging two characters, words, lines, lists...
* |Fixing_Case|::         Correcting case of last word entered.
* |Spelling|::            Apply spelling checker to a word, or a whole file.

Keyboard Macros

* |Basic_Keyboard_Macro|::     Defining and running keyboard macros.
* |Keyboard_Macro_Ring|::      Where previous keyboard macros are saved.
* |Keyboard_Macro_Counter|::   Inserting incrementing numbers in macros.
* |Keyboard_Macro_Query|::     Making keyboard macros do different things each
                                time.
* |Save_Keyboard_Macro|::      Giving keyboard macros names; saving them in
                                files.
* |Edit_Keyboard_Macro|::      Editing keyboard macros.
* |Keyboard_Macro_Step_Edit|:: Interactively executing and editing a keyboard
                                macro.

File Handling

* |File_Names|::          How to type and edit file-name arguments.
* |Visiting|::            Visiting a file prepares Emacs to edit the file.
* |Saving|::              Saving makes your changes permanent.
* |Reverting|::           Reverting cancels all the changes not saved.
* |Auto_Revert|::         Keeping buffers automatically up-to-date.
* |Auto_Save|::           Auto Save periodically protects against loss of data.
* |File_Aliases|::        Handling multiple names for one file.
* |Directories|::         Creating, deleting, and listing file directories.
* |Comparing_Files|::     Finding where two files differ.
* |Diff_Mode|::           Mode for editing file differences.
* |Copying_and_Naming|::  Copying, naming and renaming files.
* |Misc_File_Ops|::       Other things you can do on files.
* |Compressed_Files|::    Accessing compressed files.
* |File_Archives|::       Operating on tar, zip, jar etc. archive files.
* |Remote_Files|::        Accessing files on other machines.
* |Quoted_File_Names|::   Quoting special characters in file names.
* |File_Name_Cache|::     Completion against a list of files you often use.
* |File_Conveniences|::   Convenience features for finding files.
* |Image_Mode|::          Viewing image files.
* |Filesets|::            Handling sets of files.

Saving Files

* |Save_Commands|::       Commands for saving files.
* |Backup|::              How Emacs saves the old version of your file.
* |Customize_Save|::      Customizing the saving of files.
* |Interlocking|::        How Emacs protects against simultaneous editing
                          of one file by two users.
* |File_Shadowing|::      Copying files to shadows automatically.
* |Time_Stamps|::         Emacs can update time stamps on saved files.

Backup Files

* |Backup_Names|::        How backup files are named.
* |Backup_Deletion|::     Emacs deletes excess numbered backups.
* |Backup_Copying|::      Backups can be made by copying or renaming.

Auto Reverting Non-File Buffers

* |Auto_Reverting_the_Buffer_Menu|:: Auto Revert of the Buffer Menu.
* |Auto_Reverting_Dired|::           Auto Revert of Dired buffers.

Auto-Saving: Protection Against Disasters

* |Auto_Save_Files|::     The file where auto-saved changes are
                          actually made until you save the file.
* |Auto_Save_Control|::   Controlling when and how often to auto-save.
* |Recover|::             Recovering text from auto-save files.

Using Multiple Buffers

* |Select_Buffer|::       Creating a new buffer or reselecting an old one.
* |List_Buffers|::        Getting a list of buffers that exist.
* |Misc_Buffer|::         Renaming; changing read-only status; copying text.
* |Kill_Buffer|::         Killing buffers you no longer need.
* |Several_Buffers|::     How to go through the list of all buffers
                          and operate variously on several of them.
* |Indirect_Buffers|::    An indirect buffer shares the text of another buffer.
* |Buffer_Convenience|::  Convenience and customization features for
                          buffer handling.

Convenience Features and Customization of Buffer Handling

* |Uniquify|::            Making buffer names unique with directory parts.
* |Icomplete|::           Fast minibuffer selection.
* |Buffer_Menus|::        Configurable buffer menu.

Multiple Windows

* |Basic_Window|::        Introduction to Emacs windows.
* |Split_Window|::        New windows are made by splitting existing windows.
* |Other_Window|::        Moving to another window or doing something to it.
* |Pop_Up_Window|::       Finding a file or buffer in another window.
* |Change_Window|::       Deleting windows and changing their sizes.
* |Displaying_Buffers|::  How Emacs picks a window for displaying a buffer.
* |Temporary_Displays|::  Displaying non-editable buffers.
* |Window_Convenience|::  Convenience functions for window handling.
* |Tab_Line|::            Window tab line.

Displaying a Buffer in a Window

* |Window_Choice|::       How 'display-buffer' works.

Frames and Graphical Displays

* |Mouse_Commands|::      Moving, cutting, and pasting, with the mouse.
* |Word_and_Line_Mouse|:: Mouse commands for selecting whole words or lines.
* |Mouse_References|::    Using the mouse to select an item from a list.
* |Menu_Mouse_Clicks|::   Mouse clicks that bring up menus.
* |Mode_Line_Mouse|::     Mouse clicks on the mode line.
* |Creating_Frames|::     Creating additional Emacs frames with various contents.
* |Frame_Commands|::      Iconifying, deleting, and switching frames.
* |Fonts|::               Changing the frame font.
* |Speedbar|::            How to make and use a speedbar frame.
* |Multiple_Displays|::   How one Emacs instance can talk to several displays.
* |Frame_Parameters|::    Changing the colors and other modes of frames.
* |Scroll_Bars|::         How to enable and disable scroll bars; how to use them.
* |Window_Dividers|::     Window separators that can be dragged with the mouse.
* |Drag_and_Drop|::       Using drag and drop to open files and insert text.
* |Menu_Bars|::           Enabling and disabling the menu bar.
* |Tool_Bars|::           Enabling and disabling the tool bar.
* |Tab_Bars|::            Enabling and disabling the tab bar.
* |Dialog_Boxes|::        Controlling use of dialog boxes.
* |Tooltips|::            Displaying information at the current mouse position.
* |Mouse_Avoidance|::     Preventing the mouse pointer from obscuring text.
* |Non_Window_Terminals|::  Multiple frames on terminals that show only one.
* |Text_Only_Mouse|::     Using the mouse in text terminals.

International Character Set Support

* |International_Chars|::     Basic concepts of multibyte characters.
* |Language_Environments|::   Setting things up for the language you use.
* |Input_Methods|::           Entering text characters not on your keyboard.
* |Select_Input_Method|::     Specifying your choice of input methods.
* |Coding_Systems|::          Character set conversion when you read and
                              write files, and so on.
* |Recognize_Coding|::        How Emacs figures out which conversion to use.
* |Specify_Coding|::          Specifying a file's coding system explicitly.
* |Output_Coding|::           Choosing coding systems for output.
* |Text_Coding|::             Choosing conversion to use for file text.
* |Communication_Coding|::    Coding systems for interprocess communication.
* |File_Name_Coding|::        Coding systems for file _names_.
* |Terminal_Coding|::         Specifying coding systems for converting
                              terminal input and output.
* |Fontsets|::                Fontsets are collections of fonts
                              that cover the whole spectrum of characters.
* |Defining_Fontsets|::       Defining a new fontset.
* |Modifying_Fontsets|::      Modifying an existing fontset.
* |Undisplayable_Characters|::When characters don't display.
* |Unibyte_Mode|::            You can pick one European character set
                              to use without multibyte characters.
* |Charsets|::                How Emacs groups its internal character codes.
* |Bidirectional_Editing|::   Support for right-to-left scripts.

Major and Minor Modes

* |Major_Modes|::         Text mode vs. Lisp mode vs. C mode...
* |Minor_Modes|::         Each minor mode is a feature you can turn on
                          independently of any others.
* |Choosing_Modes|::      How modes are chosen when visiting files.

Indentation

* |Indentation_Commands|::  More commands for performing indentation.
* |Tab_Stops|::             Stop points for indentation in Text modes.
* |Just_Spaces|::           Using only space characters for indentation.
* |Indent_Convenience|::    Optional indentation features.

Commands for Human Languages

* |Words|::               Moving over and killing words.
* |Sentences|::           Moving over and killing sentences.
* |Paragraphs|::          Moving over paragraphs.
* |Pages|::               Moving over pages.
* |Quotation_Marks|::     Inserting quotation marks.
* |Filling|::             Filling or justifying text.
* |Case|::                Changing the case of text.
* |Text_Mode|::           The major modes for editing text files.
* |Outline_Mode|::        Editing outlines.
* |Org_Mode|::            The Emacs organizer.
* |TeX_Mode|::            Editing TeX and LaTeX files.
* |HTML_Mode|::           Editing HTML and SGML files.
* |Nroff_Mode|::          Editing input to the nroff formatter.
* |Enriched_Text|::       Editing text enriched with fonts, colors, etc.
* |Text_Based_Tables|::   Commands for editing text-based tables.
* |Two_Column|::          Splitting text columns into separate windows.

Filling Text

* |Auto_Fill|::           Auto Fill mode breaks long lines automatically.
* |Fill_Commands|::       Commands to refill paragraphs and center lines.
* |Fill_Prefix|::         Filling paragraphs that are indented
                          or in a comment, etc.
* |Adaptive_Fill|::       How Emacs can determine the fill prefix automatically.

Outline Mode

* |Outline_Format|::      What the text of an outline looks like.
* |Outline_Motion|::      Special commands for moving through outlines.
* |Outline_Visibility|::  Commands to control what is visible.
* |Outline_Views|::       Outlines and multiple views.
* |Foldout|::             Folding means zooming in on outlines.

Org Mode

* |Org_Organizer|::       Managing TODO lists and agendas.
* |Org_Authoring|::       Exporting Org buffers to various formats.

TeX Mode

* |TeX_Editing|::         Special commands for editing in TeX mode.
* |LaTeX_Editing|::       Additional commands for LaTeX input files.
* |TeX_Print|::           Commands for printing part of a file with TeX.
* |TeX_Misc|::            Customization of TeX mode, and related features.

Enriched Text

* |Enriched_Mode|::           Entering and exiting Enriched mode.
* |Hard_and_Soft_Newlines|::  There are two different kinds of newlines.
* |Editing_Format_Info|::     How to edit text properties.
* |Enriched_Faces|::          Bold, italic, underline, etc.
* |Enriched_Indentation|::    Changing the left and right margins.
* |Enriched_Justification|::  Centering, setting text flush with the
                              left or right margin, etc.
* |Enriched_Properties|::     The "Special text properties" submenu.


Editing Text-based Tables

* |Table_Definition|::    What is a text based table.
* |Table_Creation|::      How to create a table.
* |Table_Recognition|::   How to activate and deactivate tables.
* |Cell_Commands|::       Cell-oriented commands in a table.
* |Cell_Justification|::  Justifying cell contents.
* |Table_Rows_and_Columns|:: Inserting and deleting rows and columns.
* |Table_Conversion|::    Converting between plain text and tables.
* |Table_Misc|::          Table miscellany.

Editing Programs

* |Program_Modes|::       Major modes for editing programs.
* |Defuns|::              Commands to operate on major top-level parts
                          of a program.
* |Program_Indent|::      Adjusting indentation to show the nesting.
* |Parentheses|::         Commands that operate on parentheses.
* |Comments|::            Inserting, killing, and aligning comments.
* |Documentation|::       Getting documentation of functions you plan to call.
* |Hideshow|::            Displaying blocks selectively.
* |Symbol_Completion|::   Completion on symbol names of your program or language.
* |MixedCase_Words|::     Dealing with identifiersLikeThis.
* |Semantic|::            Suite of editing tools based on source code parsing.
* |Misc_for_Programs|::   Other Emacs features useful for editing programs.
* |C_Modes|::             Special commands of C, C++, Objective-C,
                          Java, IDL, Pike and AWK modes.
* |Asm_Mode|::            Asm mode and its special features.
* |Fortran|::             Fortran mode and its special features.

Top-Level Definitions, or Defuns

* |Left_Margin_Paren|::   An open-paren or similar opening delimiter
                          starts a defun if it is at the left margin.
* |Moving_by_Defuns|::    Commands to move over or mark a major definition.
* |Imenu|::               Making buffer indexes as menus.
* |Which_Function|::      Which Function mode shows which function you are in.

Indentation for Programs

* |Basic_Indent|::        Indenting a single line.
* |Multi_line_Indent|::   Commands to reindent many lines at once.
* |Lisp_Indent|::         Specifying how each Lisp function should be indented.
* |C_Indent|::            Extra features for indenting C and related modes.
* |Custom_C_Indent|::     Controlling indentation style for C and related modes.

Commands for Editing with Parentheses

* |Expressions|::         Expressions with balanced parentheses.
* |Moving_by_Parens|::    Commands for moving up, down and across
                          in the structure of parentheses.
* |Matching|::            Insertion of a close-delimiter flashes matching open.

Manipulating Comments

* |Comment_Commands|::    Inserting, killing, and aligning comments.
* |Multi_Line_Comments|:: Commands for adding and editing multi-line comments.
* |Options_for_Comments|::Customizing the comment features.

Documentation Lookup

* |Info_Lookup|::        Looking up library functions and commands in Info files.
* |Man_Page|::           Looking up man pages of library functions and commands.
* |Lisp_Doc|::           Looking up Emacs Lisp functions, etc.

C and Related Modes

* |Motion_in_C|::         Commands to move by C statements, etc.
* |Electric_C|::          Colon and other chars can automatically reindent.
* |Hungry_Delete|::       A more powerful DEL command.
* |Other_C_Commands|::    Filling comments, viewing expansion of macros,
                          and other neat features.

Fortran Mode

* |Fortran_Motion|::      Moving point by statements or subprograms.
* |Fortran_Indent|::      Indentation commands for Fortran.
* |Fortran_Comments|::    Inserting and aligning comments.
* |Fortran_Autofill|::    Auto fill support for Fortran.
* |Fortran_Columns|::     Measuring columns for valid Fortran.
* |Fortran_Abbrev|::      Built-in abbrevs for Fortran keywords.

Fortran Indentation

* |ForIndent_Commands|::  Commands for indenting and filling Fortran.
* |ForIndent_Cont|::      How continuation lines indent.
* |ForIndent_Num|::       How line numbers auto-indent.
* |ForIndent_Conv|::      Conventions you must obey to avoid trouble.
* |ForIndent_Vars|::      Variables controlling Fortran indent style.

Compiling and Testing Programs

* |Compilation|::         Compiling programs in languages other
                          than Lisp (C, Pascal, etc.).
* |Compilation_Mode|::    The mode for visiting compiler errors.
* |Compilation_Shell|::   Customizing your shell properly
                          for use in the compilation buffer.
* |Grep_Searching|::      Searching with grep.
* |Flymake|::             Finding syntax errors on the fly.
* |Debuggers|::           Running symbolic debuggers for non-Lisp programs.
* |Executing_Lisp|::      Various modes for editing Lisp programs,
                          with different facilities for running
                          the Lisp programs.
* |Lisp_Libraries|::      How Lisp programs are loaded into Emacs.
* |Lisp_Eval|::           Executing a single Lisp expression in Emacs.
* |Lisp_Interaction|::    Executing Lisp in an Emacs buffer.
* |External_Lisp|::       Communicating through Emacs with a separate Lisp.

Running Debuggers Under Emacs

* |Starting_GUD|::        How to start a debugger subprocess.
* |Debugger_Operation|::  Connection between the debugger and source buffers.
* |Commands_of_GUD|::     Key bindings for common commands.
* |GUD_Customization|::   Defining your own commands for GUD.
* |GDB_Graphical_Interface|::  An enhanced mode that uses GDB features to
                          implement a graphical debugging environment.

GDB Graphical Interface

* |GDB_User_Interface_Layout|::   Control the number of displayed buffers.
* |Source_Buffers|::              Use the mouse in the fringe/margin to
                                control your program.
* |Breakpoints_Buffer|::          A breakpoint control panel.
* |Threads_Buffer|::              Displays your threads.
* |Stack_Buffer|::                Select a frame from the call stack.
* |Other_GDB_Buffers|::           Other buffers for controlling the GDB state.
* |Watch_Expressions|::           Monitor variable values in the speedbar.
* |Multithreaded_Debugging|::     Debugging programs with several threads.

Maintaining Large Programs

* |Version_Control|::     Using version control systems.
* |Projects|::            Commands for handling source files in a project.
* |Change_Log|::          Maintaining a change history for your program.
* |Xref|::                Find definitions and references of any function,
                          method, struct, macro, ... in your program.
* |EDE|::                 An integrated development environment for Emacs.
* |Emerge|::              A convenient way of merging two versions of a program.

Version Control

* |Introduction_to_VC|::  How version control works in general.
* |VC_Mode_Line|::        How the mode line shows version control status.
* |Basic_VC_Editing|::    How to edit a file under version control.
* |Log_Buffer|::          Features available in log entry buffers.
* |Registering|::         Putting a file under version control.
* |Old_Revisions|::       Examining and comparing old versions.
* |VC_Change_Log|::       Viewing the VC Change Log.
* |VC_Undo|::             Canceling changes before or after committing.
* |VC_Ignore|::           Ignore files under version control system.
* |VC_Directory_Mode|::   Listing files managed by version control.
* |Branches|::            Multiple lines of development.
* |Miscellaneous_VC|::    Various other commands and features of VC.
* |Customizing_VC|::      Variables that change VC's behavior.

Introduction to Version Control

* |Why_Version_Control?|::    Understanding the problems it addresses.
* |Version_Control_Systems|:: Supported version control back-end systems.
* |VCS_Concepts|::            Words and concepts related to version control.
* |VCS_Merging|::             How file conflicts are handled.
* |VCS_Changesets|::          How changes are grouped.
* |VCS_Repositories|::        Where version control repositories are stored.
* |Types_of_Log_File|::       The VCS log in contrast to the ChangeLog.

Basic Editing under Version Control

* |VC_With_A_Merging_VCS|::  Without locking: default mode for CVS.
* |VC_With_A_Locking_VCS|::  RCS in its default mode, SCCS, and optionally CVS.
* |Advanced_C_x_v_v|::       Advanced features available with a prefix argument.

VC Directory Mode

* |VC_Directory_Buffer|::   What the buffer looks like and means.
* |VC_Directory_Commands|:: Commands to use in a VC directory buffer.

Version Control Branches

* |Switching_Branches|::    How to get to another existing branch.
* |Pulling_/_Pushing|::     Receiving/sending changes from/to elsewhere.
* |Merging|::               Transferring changes between branches.
* |Creating_Branches|::     How to start a new branch.

Miscellaneous Commands and Features of VC

* |Change_Logs_and_VC|::    Generating a change log file from log entries.
* |VC_Delete/Rename|::      Deleting and renaming version-controlled files.
* |Revision_Tags|::         Symbolic names for revisions.
* |Version_Headers|::       Inserting version control headers into working files.

Customizing VC

* |General_VC_Options|::    Options that apply to multiple back ends.
* |RCS_and_SCCS|::          Options for RCS and SCCS.
* |CVS_Options|::           Options for CVS.

Change Logs

* |Change_Log_Commands|:: Commands for editing change log files.
* |Format_of_ChangeLog|:: What the change log file looks like.

Xref

* |Find_Identifiers|::    Commands to find where an identifier is defined
                          or referenced, to list identifiers, etc.
* |Tags_Tables|::         Tags table records which file defines a symbol.
* |Select_Tags_Table|::   How to visit a specific tags table.

Find Identifiers

* |Looking_Up_Identifiers|:: Commands to find the definition of a specific tag.
* |Xref_Commands|::          Commands in the 'xref' buffer.
* |Identifier_Search|::      Searching and replacing identifiers.
* |List_Identifiers|::       Listing identifiers and completing on them.

Tags Tables

* |Tag_Syntax|::          Tag syntax for various types of code and text files.
* |Create_Tags_Table|::   Creating a tags table with 'etags'.
* |Etags_Regexps|::       Create arbitrary tags using regular expressions.

Merging Files with Emerge

* |Overview_of_Emerge|::  How to start Emerge.  Basic concepts.
* |Submodes_of_Emerge|::  Fast mode vs. Edit mode.
                          Skip Prefers mode and Auto Advance mode.
* |State_of_Difference|:: You do the merge by specifying state A or B
                          for each difference.
* |Merge_Commands|::      Commands for selecting a difference,
                          changing states of differences, etc.
* |Exiting_Emerge|::      What to do when you've finished the merge.
* |Combining_in_Emerge|::     How to keep both alternatives for a difference.
* |Fine_Points_of_Emerge|::   Miscellaneous issues.

Abbrevs

* |Abbrev_Concepts|::     Fundamentals of defined abbrevs.
* |Defining_Abbrevs|::    Defining an abbrev, so it will expand when typed.
* |Expanding_Abbrevs|::   Controlling expansion: prefixes, canceling expansion.
* |Editing_Abbrevs|::     Viewing or editing the entire list of defined abbrevs.
* |Saving_Abbrevs|::      Saving the entire list of abbrevs for another session.
* |Dynamic_Abbrevs|::     Abbreviations for words already in the buffer.
* |Dabbrev_Customization|:: What is a word, for dynamic abbrevs.  Case handling.

Editing Pictures

* |Basic_Picture|::         Basic concepts and simple commands of Picture Mode.
* |Insert_in_Picture|::     Controlling direction of cursor motion
                            after self-inserting characters.
* |Tabs_in_Picture|::       Various features for tab stops and indentation.
* |Rectangles_in_Picture|:: Clearing and superimposing rectangles.

Dired, the Directory Editor

* |Dired_Enter|::              How to invoke Dired.
* |Dired_Navigation|::         Special motion commands in the Dired buffer.
* |Dired_Deletion|::           Deleting files with Dired.
* |Flagging_Many_Files|::      Flagging files based on their names.
* |Dired_Visiting|::           Other file operations through Dired.
* |Marks_vs_Flags|::           Flagging for deletion vs marking.
* |Operating_on_Files|::       How to copy, rename, print, compress, etc.
                               either one file or several files.
* |Shell_Commands_in_Dired|::  Running a shell command on the marked files.
* |Transforming_File_Names|::  Using patterns to rename multiple files.
* |Comparison_in_Dired|::      Running 'diff' by way of Dired.
* |Subdirectories_in_Dired|::  Adding subdirectories to the Dired buffer.
* |Subdir_Switches|::          Subdirectory switches in Dired.
* |Subdirectory_Motion|::      Moving across subdirectories, and up and down.
* |Hiding_Subdirectories|::    Making subdirectories visible or invisible.
* |Dired_Updating|::           Discarding lines for files of no interest.
* |Dired_and_Find|::           Using 'find' to choose the files for Dired.
* |Wdired|::                   Operating on files by editing the Dired buffer.
* |Image_Dired|::              Viewing image thumbnails in Dired.
* |Misc_Dired_Features|::      Various other features.

The Calendar and the Diary

* |Calendar_Motion|::     Moving through the calendar; selecting a date.
* |Scroll_Calendar|::     Bringing earlier or later months onto the screen.
* |Counting_Days|::       How many days are there between two dates?
* |General_Calendar|::    Exiting or recomputing the calendar.
* |Writing_Calendar_Files|:: Writing calendars to files of various formats.
* |Holidays|::            Displaying dates of holidays.
* |Sunrise/Sunset|::      Displaying local times of sunrise and sunset.
* |Lunar_Phases|::        Displaying phases of the moon.
* |Other_Calendars|::     Converting dates to other calendar systems.
* |Diary|::               Displaying events from your diary.
* |Daylight_Saving|::     How to specify when daylight saving time is active.
* |Time_Intervals|::      Keeping track of time intervals.
* |Advanced_Calendar/Diary_Usage|:: Advanced Calendar/Diary customization.

Movement in the Calendar

* |Calendar_Unit_Motion|::      Moving by days, weeks, months, and years.
* |Move_to_Beginning_or_End|::  Moving to start/end of weeks, months, and years.
* |Specified_Dates|::           Moving to the current date or another
                                specific date.

Conversion To and From Other Calendars

* |Calendar_Systems|::       The calendars Emacs understands
                             (aside from Gregorian).
* |To_Other_Calendar|::      Converting the selected date to various calendars.
* |From_Other_Calendar|::    Moving to a date specified in another calendar.

The Diary

* |Format_of_Diary_File|::   Entering events in your diary.
* |Displaying_the_Diary|::   Viewing diary entries and associated calendar dates.
* |Date_Formats|::           Various ways you can specify dates.
* |Adding_to_Diary|::        Commands to create diary entries.
* |Special_Diary_Entries|::  Anniversaries, blocks of dates, cyclic entries, etc.
* |Appointments|::           Reminders when it's time to do something.
* |Importing_Diary|::        Converting diary events to/from other formats.

More advanced features of the Calendar and Diary

* |Calendar_Customizing|::   Calendar layout and hooks.
* |Holiday_Customizing|::    Defining your own holidays.
* |Mayan_Calendar|::         Moving to a date specified in a Mayan calendar.
* |Date_Display_Format|::    Changing the format.
* |Time_Display_Format|::    Changing the format.
* |Diary_Customizing|::      Defaults you can set.
* |Non_Gregorian_Diary|::    Diary entries based on other calendars.
* |Diary_Display|::          A choice of ways to display the diary.
* |Fancy_Diary_Display|::    Sorting diary entries, using included diary files.
* |Sexp_Diary_Entries|::     More flexible diary entries.

Sending Mail

* |Mail_Format|::         Format of a mail message.
* |Mail_Headers|::        Details of some standard mail header fields.
* |Mail_Aliases|::        Abbreviating and grouping mail addresses.
* |Mail_Commands|::       Special commands for editing mail being composed.
* |Mail_Signature|::      Adding a signature to every message.
* |Mail_Amusements|::     Distracting the NSA; adding fortune messages.
* |Mail_Methods|::        Using alternative mail-composition methods.

Mail Commands

* |Mail_Sending|::        Commands to send the message.
* |Header_Editing|::      Commands to move to header fields and edit them.
* |Citing_Mail|::         Quoting a message you are replying to.
* |Mail_Misc|::           Attachments, spell checking, etc.

Reading Mail with Rmail

* |Rmail_Basics|::        Basic concepts of Rmail, and simple use.
* |Rmail_Scrolling|::     Scrolling through a message.
* |Rmail_Motion|::        Moving to another message.
* |Rmail_Deletion|::      Deleting and expunging messages.
* |Rmail_Inbox|::         How mail gets into the Rmail file.
* |Rmail_Files|::         Using multiple Rmail files.
* |Rmail_Output|::        Copying message out to files.
* |Rmail_Labels|::        Classifying messages by labeling them.
* |Rmail_Attributes|::    Certain standard labels, called attributes.
* |Rmail_Reply|::         Sending replies to messages you are viewing.
* |Rmail_Summary|::       Summaries show brief info on many messages.
* |Rmail_Sorting|::       Sorting messages in Rmail.
* |Rmail_Display|::       How Rmail displays a message; customization.
* |Rmail_Coding|::        How Rmail handles decoding character sets.
* |Rmail_Editing|::       Editing message text and headers in Rmail.
* |Rmail_Digest|::        Extracting the messages from a digest message.
* |Rmail_Rot13|::         Reading messages encoded in the rot13 code.
* |Movemail|::            More details of fetching new mail.
* |Remote_Mailboxes|::    Retrieving mail from remote mailboxes.
* |Other_Mailbox_Formats|:: Retrieving mail from local mailboxes in
                          various formats.

Rmail Summaries

* |Rmail_Make_Summary|::  Making various sorts of summaries.
* |Rmail_Summary_Edit|::  Manipulating messages from the summary.

Gnus

* |Buffers_of_Gnus|::     The group, summary, and article buffers.
* |Gnus_Startup|::        What you should know about starting Gnus.
* |Gnus_Group_Buffer|::   A short description of Gnus group commands.
* |Gnus_Summary_Buffer|:: A short description of Gnus summary commands.

Document Viewing

* |DocView_Navigation|::  Navigating DocView buffers.
* |DocView_Searching|::   Searching inside documents.
* |DocView_Slicing|::     Specifying which part of a page is displayed.
* |DocView_Conversion|::  Influencing and triggering conversion.

Running Shell Commands from Emacs

* |Single_Shell|::        How to run one shell command and return.
* |Interactive_Shell|::   Permanent shell taking input via Emacs.
* |Shell_Mode|::          Special Emacs commands used with permanent shell.
* |Shell_Prompts|::       Two ways to recognize shell prompts.
* |Shell_History|::       Repeating previous commands in a shell buffer.
* |Directory_Tracking|::  Keeping track when the subshell changes directory.
* |Shell_Options|::       Options for customizing Shell mode.
* |Terminal_emulator|::   An Emacs window as a terminal emulator.
* |Term_Mode|::           Special Emacs commands used in Term mode.
* |Remote_Host|::         Connecting to another computer.
* |Serial_Terminal|::     Connecting to a serial port.

Shell Command History

* |Shell_Ring|::           Fetching commands from the history list.
* |Shell_History_Copying|::Moving to a command and then copying it.
* |History_References|::   Expanding '!'-style history references.

Using Emacs as a Server

* |TCP_Emacs_server|::     Listening to a TCP socket.
* |Invoking_emacsclient|:: Connecting to the Emacs server.
* |emacsclient_Options|::  Emacs client startup options.

Printing Hard Copies

* |PostScript|::           Printing buffers or regions as PostScript.
* |PostScript_Variables|:: Customizing the PostScript printing commands.
* |Printing_Package|::     An optional advanced printing interface.

Hyperlinking and Navigation Features

* |EWW|::                 A web browser in Emacs.
* |Embedded_WebKit_Widgets|:: Embedding browser widgets in Emacs buffers.
* |Browse_URL|::          Following URLs.
* |Goto_Address_mode|::   Activating URLs.
* |FFAP|::                Finding files etc. at point.

Emacs Lisp Packages

* |Package_Menu|::         Buffer for viewing and managing packages.
* |Package_Statuses|::     Which statuses a package can have.
* |Package_Installation|:: Options for package installation.
* |Package_Files|::        Where packages are installed.

Customization

* |Easy_Customization|::  Convenient way to browse and change settings.
* |Variables|::           Many Emacs commands examine Emacs variables
                          to decide what to do; by setting variables,
                          you can control their functioning.
* |Key_Bindings|::        The keymaps say what command each key runs.
                          By changing them, you can redefine keys.
* |Init_File|::           How to write common customizations in the
                          initialization file.
* |Authentication|::      Keeping persistent authentication information.

Easy Customization Interface

* |Customization_Groups|::     How settings are classified.
* |Browsing_Custom|::          Browsing and searching for settings.
* |Changing_a_Variable|::      How to edit an option's value and set the option.
* |Saving_Customizations|::    Saving customizations for future Emacs sessions.
* |Face_Customization|::       How to edit the attributes of a face.
* |Specific_Customization|::   Customizing specific settings or groups.
* |Custom_Themes|::            Collections of customization settings.
* |Creating_Custom_Themes|::   How to create a new custom theme.

Variables

* |Examining|::           Examining or setting one variable's value.
* |Hooks|::               Hook variables let you specify programs for parts
                          of Emacs to run on particular occasions.
* |Locals|::              Per-buffer values of variables.
* |File_Variables|::      How files can specify variable values.
* |Directory_Variables|:: How variable values can be specified by directory.
* |Connection_Variables|:: Variables which are valid for buffers with a
                           remote default directory.

Local Variables in Files

* |Specifying_File_Variables|:: Specifying file local variables.
* |Safe_File_Variables|::       Making sure file local variables are safe.

Customizing Key Bindings

* |Keymaps|::             Generalities.  The global keymap.
* |Prefix_Keymaps|::      Keymaps for prefix keys.
* |Local_Keymaps|::       Major and minor modes have their own keymaps.
* |Minibuffer_Maps|::     The minibuffer uses its own local keymaps.
* |Rebinding|::           How to redefine one key's meaning conveniently.
* |Init_Rebinding|::      Rebinding keys with your initialization file.
* |Modifier_Keys|::       Using modifier keys in key bindings.
* |Function_Keys|::       Rebinding terminal function keys.
* |Named_ASCII_Chars|::   Distinguishing <TAB> from 'C-i', and so on.
* |Mouse_Buttons|::       Rebinding mouse buttons in Emacs.
* |Disabling|::           Disabling a command means confirmation is required
                          before it can be executed.  This is done to protect
                          beginners from surprises.

The Emacs Initialization File

* |Init_Syntax|::         Syntax of constants in Emacs Lisp.
* |Init_Examples|::       How to do some things with an init file.
* |Terminal_Init|::       Each terminal type can have an init file.
* |Find_Init|::           How Emacs finds the init file.
* |Init_Non_ASCII|::      Using non-ASCII characters in an init file.
* |Early_Init_File|::     Another init file, which is read early on.

Dealing with Emacs Trouble

* |DEL_Does_Not_Delete|:: What to do if <DEL> doesn't delete.
* |Stuck_Recursive|::     '[...]' in mode line around the parentheses.
* |Screen_Garbled|::      Garbage on the screen.
* |Text_Garbled|::        Garbage in the text.
* |Memory_Full|::         How to cope when you run out of memory.
* |Crashing|::            What Emacs does when it crashes.
* |After_a_Crash|::       Recovering editing in an Emacs session that crashed.
* |Emergency_Escape|::    What to do if Emacs stops responding.
* |Long_Lines|::          Mitigating slowness due to extremely long lines.

Reporting Bugs

* |Known_Problems|::      How to read about known problems and bugs.
* |Bug_Criteria|::        Have you really found a bug?
* |Understanding_Bug_Reporting|:: How to report a bug effectively.
* |Checklist|::           Steps to follow for a good bug report.
* |Sending_Patches|::     How to send a patch for GNU Emacs.

Contributing to Emacs Development

* |Coding_Standards|::     GNU Emacs coding standards.
* |Copyright_Assignment|:: Assigning copyright to the FSF.

Command Line Arguments for Emacs Invocation

* |Action_Arguments|::    Arguments to visit files, load libraries,
                          and call functions.
* |Initial_Options|::     Arguments that take effect while starting Emacs.
* |Command_Example|::     Examples of using command line arguments.
* |Environment|::         Environment variables that Emacs uses.
* |Display_X|::           Changing the default display and using remote login.
* |Font_X|::              Choosing a font for text, under X.
* |Colors_X|::            Choosing display colors.
* |Window_Size_X|::       Start-up window size, under X.
* |Borders_X|::           Internal and outer borders, under X.
* |Title_X|::             Specifying the initial frame's title.
* |Icons_X|::             Choosing what sort of icon to use, under X.
* |Misc_X|::              Other display options.

Environment Variables

* |General_Variables|::   Environment variables that all versions of Emacs use.
* |Misc_Variables|::      Certain system-specific variables.
* |MS_Windows_Registry|:: An alternative to the environment on MS-Windows.

X Options and Resources

* |Resources|::           Using X resources with Emacs (in general).
* |Table_of_Resources|::  Table of specific X resources that affect Emacs.
* |Lucid_Resources|::     X resources for Lucid menus.
* |Motif_Resources|::     X resources for Motif and LessTif menus.
* |GTK_resources|::       Resources for GTK widgets.

GTK resources

* |GTK_Resource_Basics|::   Basic usage of GTK+ resources.
* |GTK_Widget_Names|::      How GTK+ widgets are named.
* |GTK_Names_in_Emacs|::    GTK+ widgets used by Emacs.
* |GTK_styles|::            What can be customized in a GTK+ widget.

Emacs and macOS / GNUstep

* |Mac_/_GNUstep_Basics|::        Basic Emacs usage under GNUstep or macOS.
* |Mac_/_GNUstep_Customization|:: Customizations under GNUstep or macOS.
* |Mac_/_GNUstep_Events|::        How window system events are handled.
* |GNUstep_Support|::             Details on status of GNUstep support.

Emacs and Microsoft Windows/MS-DOS

* |Windows_Startup|::     How to start Emacs on Windows.
* |Text_and_Binary|::     Text files use CRLF to terminate lines.
* |Windows_Files|::       File-name conventions on Windows.
* |ls_in_Lisp|::          Emulation of 'ls' for Dired.
* |Windows_HOME|::        Where Emacs looks for your '.emacs' and
                          where it starts up.
* |Windows_Keyboard|::    Windows-specific keyboard features.
* |Windows_Mouse|::       Windows-specific mouse features.
* |Windows_Processes|::   Running subprocesses on Windows.
* |Windows_Printing|::    How to specify the printer on MS-Windows.
* |Windows_Fonts|::       Specifying fonts on MS-Windows.
* |Windows_Misc|::        Miscellaneous Windows features.
* |MS_DOS|::              Using Emacs on MS-DOS.

Emacs and MS-DOS

* |MS_DOS_Keyboard|::     Keyboard conventions on MS-DOS.
* |MS_DOS_Mouse|::        Mouse conventions on MS-DOS.
* |MS_DOS_Display|::      Fonts, frames and display size on MS-DOS.
* |MS_DOS_File_Names|::   File name conventions on MS-DOS.
* |MS_DOS_Printing|::     Printing specifics on MS-DOS.
* |MS_DOS_and_MULE|::     Support for internationalization on MS-DOS.
* |MS_DOS_Processes|::    Running subprocesses on MS-DOS.


==============================================================================
File: emacs.info,  Node: |Distrib|,  Next: |Intro|,  Prev: |Top|,  Up: |Top|
==============================================================================

                                                                       *Distrib*

Distribution
============

GNU Emacs is "free software"; this means that everyone is free to use it
and free to redistribute it under certain conditions.  GNU Emacs is not
in the public domain; it is copyrighted and there are restrictions on
its distribution, but these restrictions are designed to permit
everything that a good cooperating citizen would want to do.  What is
not allowed is to try to prevent others from further sharing any version
of GNU Emacs that they might get from you.  The precise conditions are
found in the GNU General Public License that comes with Emacs and also
appears in this manual(1).  *Note Copying::.

   One way to get a copy of GNU Emacs is from someone else who has it.
You need not ask for our permission to do so, or tell anyone else; just
copy it.  If you have access to the Internet, you can get the latest
distribution version of GNU Emacs by anonymous FTP; see
<https://www.gnu.org/software/emacs> on our website for more
information.

   You may also receive GNU Emacs when you buy a computer.  Computer
manufacturers are free to distribute copies on the same terms that apply
to everyone else.  These terms require them to give you the full
sources, including whatever changes they may have made, and to permit
you to redistribute the GNU Emacs received from them under the usual
terms of the General Public License.  In other words, the program must
be free for you when you get it, not just free for the manufacturer.

   If you find GNU Emacs useful, please *send a donation* to the Free
Software Foundation to support our work.  Donations to the Free Software
Foundation are tax-deductible in the US.  If you use GNU Emacs at your
workplace, please suggest that the company make a donation.  To donate,
see <https://my.fsf.org/donate/>.  For other ways in which you can help,
see <https://www.gnu.org/help/help.html>.

   We also sell hardcopy versions of this manual and 'An Introduction to
Programming in Emacs Lisp', by Robert J. Chassell.  You can visit our
online store at <https://shop.fsf.org/>.  The income from sales goes to
support the foundation's purpose: the development of new free software,
and improvements to our existing programs including GNU Emacs.

   If you need to contact the Free Software Foundation, see
<https://www.fsf.org/about/contact/>, or write to

     Free Software Foundation
     51 Franklin Street, Fifth Floor
     Boston, MA 02110-1301
     USA

   ---------- Footnotes ----------

   (1) This manual is itself covered by the GNU Free Documentation
License.  This license is similar in spirit to the General Public
License, but is more suitable for documentation.  *Note GNU Free
Documentation License::.

==============================================================================
File: emacs.info,  Node: |Intro|,  Next: |Screen|,  Prev: |Distrib|,  Up: |Top|
==============================================================================

                                                                         *Intro*

Introduction
============

You are reading about GNU Emacs, the GNU incarnation of the advanced,
self-documenting, customizable, extensible editor Emacs.  (The 'G' in
GNU (GNU's Not Unix) is not silent.)

   We call Emacs "advanced" because it can do much more than simple
insertion and deletion of text.  It can control subprocesses, indent
programs automatically, show multiple files at once, edit remote files
like they were local files, and more.  Emacs editing commands operate in
terms of characters, words, lines, sentences, paragraphs, and pages, as
well as expressions and comments in various programming languages.

   "Self-documenting" means that at any time you can use special
commands, known as "help commands", to find out what your options are,
or to find out what any command does, or to find all the commands that
pertain to a given topic.  *Note Help::.

   "Customizable" means that you can easily alter the behavior of Emacs
commands in simple ways.  For instance, if you use a programming
language in which comments start with '<**' and end with '**>', you can
tell the Emacs comment manipulation commands to use those strings (*note
Comments::).  To take another example, you can rebind the basic cursor
motion commands (up, down, left and right) to any keys on the keyboard
that you find comfortable.  *Note Customization::.

   "Extensible" means that you can go beyond simple customization and
create entirely new commands.  New commands are simply programs written
in the Lisp language, which are run by Emacs's own Lisp interpreter.
Existing commands can even be redefined in the middle of an editing
session, without having to restart Emacs.  Most of the editing commands
in Emacs are written in Lisp; the few exceptions could have been written
in Lisp but use C instead for efficiency.  Writing an extension is
programming, but non-programmers can use it afterwards.  *Note Emacs
Lisp Intro: (eintr)Top, if you want to learn Emacs Lisp programming.

==============================================================================
File: emacs.info,  Node: |Screen|,  Next: |User_Input|,  Prev: |Intro|,  Up: |Top|
==============================================================================

                                                                        *Screen*

1 The Organization of the Screen
================================

On a graphical display, such as on GNU/Linux using the X Window System,
Emacs occupies a graphical window.  On a text terminal, Emacs occupies
the entire terminal screen.  We will use the term "frame" to mean a
graphical window or terminal screen occupied by Emacs.  Emacs behaves
very similarly on both kinds of frames.  It normally starts out with
just one frame, but you can create additional frames if you wish (*note
Frames::).

   Each frame consists of several distinct regions.  At the top of the
frame is a "menu bar", which allows you to access commands via a series
of menus.  On a graphical display, directly below the menu bar is a
"tool bar", a row of icons that perform editing commands when you click
on them.  At the very bottom of the frame is an "echo area", where
informative messages are displayed and where you enter information when
Emacs asks for it.

   The main area of the frame, below the tool bar (if one exists) and
above the echo area, is called "the window".  Henceforth in this manual,
we will use the word "window" in this sense.  Graphical display systems
commonly use the word "window" with a different meaning; but, as stated
above, we refer to those graphical windows as "frames".

   An Emacs window is where the "buffer"--the text or other graphics you
are editing or viewing--is displayed.  On a graphical display, the window
possesses a "scroll bar" on one side, which can be used to scroll
through the buffer.  The last line of the window is a "mode line".  This
displays various information about what is going on in the buffer, such
as whether there are unsaved changes, the editing modes that are in use,
the current line number, and so forth.

   When you start Emacs, there is normally only one window in the frame.
However, you can subdivide this window horizontally or vertically to
create multiple windows, each of which can independently display a
buffer (*note Windows::).

   At any time, one window is the "selected window".  On a graphical
display, the selected window shows a more prominent cursor (usually
solid and blinking); other windows show a less prominent cursor (usually
a hollow box).  On a text terminal, there is only one cursor, which is
shown in the selected window.  The buffer displayed in the selected
window is called the "current buffer", and it is where editing happens.
Most Emacs commands implicitly apply to the current buffer; the text
displayed in unselected windows is mostly visible for reference.  If you
use multiple frames on a graphical display, selecting a particular frame
selects a window in that frame.

MENU

* |Point|::             The place in the text where editing commands operate.
* |Echo_Area|::         Short messages appear at the bottom of the screen.
* |Mode_Line|::         Interpreting the mode line.
* |Menu_Bar|::          How to use the menu bar.

==============================================================================
File: emacs.info,  Node: |Point|,  Next: |Echo_Area|,  Up: |Screen|
==============================================================================

                                                                         *Point*

1.1 Point
---------

The cursor in the selected window shows the location where most editing
commands take effect, which is called "point"(1).  Many Emacs commands
move point to different places in the buffer; for example, you can place
point by clicking mouse button 1 (normally the left button) at the
desired location.

   By default, the cursor in the selected window is drawn as a solid
block and appears to be _on_ a character, but you should think of point
as _between_ two characters; it is situated _before_ the character under
the cursor.  For example, if your text looks like 'frob' with the cursor
over the 'b', then point is between the 'o' and the 'b'.  If you insert
the character '!' at that position, the result is 'fro!b', with point
between the '!' and the 'b'.  Thus, the cursor remains over the 'b', as
before.

   If you are editing several files in Emacs, each in its own buffer,
each buffer has its own value of point.  A buffer that is not currently
displayed remembers its value of point if you later display it again.
Furthermore, if a buffer is displayed in multiple windows, each of those
windows has its own value of point.

   *Note Cursor Display::, for options that control how Emacs displays
the cursor.

   ---------- Footnotes ----------

   (1) The term "point" comes from the character '.', which was the
command in TECO (the language in which the original Emacs was written)
for accessing the editing position.

==============================================================================
File: emacs.info,  Node: |Echo_Area|,  Next: |Mode_Line|,  Prev: |Point|,  Up: |Screen|
==============================================================================

                                                                     *Echo_Area*

1.2 The Echo Area
-----------------

The line at the very bottom of the frame is the "echo area".  It is used
to display small amounts of text for various purposes.

   The echo area is so-named because one of the things it is used for is
"echoing", which means displaying the characters of a multi-character
command as you type.  Single-character commands are not echoed.
Multi-character commands (*note Keys::) are echoed if you pause for more
than a second in the middle of a command.  Emacs then echoes all the
characters of the command so far, to prompt you for the rest.  Once
echoing has started, the rest of the command echoes immediately as you
type it.  This behavior is designed to give confident users fast
response, while giving hesitant users maximum feedback.

   The echo area is also used to display an "error message" when a
command cannot do its job.  Error messages may be accompanied by beeping
or by flashing the screen.

   Some commands display informative messages in the echo area to tell
you what the command has done, or to provide you with some specific
information.  These "informative" messages, unlike error messages, are
not accompanied with a beep or flash.  For example, 'C-x =' (hold down
<Ctrl> and type 'x', then let go of <Ctrl> and type '=') displays a
message describing the character at point, its position in the buffer,
and its current column in the window.  Commands that take a long time
often display messages ending in '...' while they are working (sometimes
also indicating how much progress has been made, as a percentage), and
add 'done' when they are finished.

   Informative echo area messages are saved in a special buffer named
'Messages'.  (We have not explained buffers yet; see *note Buffers::,
for more information about them.)  If you miss a message that appeared
briefly on the screen, you can switch to the 'Messages' buffer to see
it again.  The 'Messages' buffer is limited to a certain number of
lines, specified by the variable 'message-log-max'.  (We have not
explained variables either; see *note Variables::, for more information
about them.)  Beyond this limit, one line is deleted from the beginning
whenever a new message line is added at the end.

   *Note Display Custom::, for options that control how Emacs uses the
echo area.

   The echo area is also used to display the "minibuffer", a special
window where you can input arguments to commands, such as the name of a
file to be edited.  When the minibuffer is in use, the text displayed in
the echo area begins with a "prompt string", and the active cursor
appears within the minibuffer, which is temporarily considered the
selected window.  You can always get out of the minibuffer by typing
'C-g'.  *Note Minibuffer::.

==============================================================================
File: emacs.info,  Node: |Mode_Line|,  Next: |Menu_Bar|,  Prev: |Echo_Area|,  Up: |Screen|
==============================================================================

                                                                     *Mode_Line*

1.3 The Mode Line
-----------------

At the bottom of each window is a "mode line", which describes what is
going on in the current buffer.  When there is only one window, the mode
line appears right above the echo area; it is the next-to-last line in
the frame.  On a graphical display, the mode line is drawn with a 3D box
appearance.  Emacs also usually draws the mode line of the selected
window with a different color from that of unselected windows, in order
to make it stand out.

   The text displayed in the mode line has the following format:

      CS:CH-FR  BUF      POS LINE   (MAJOR MINOR)

On a text terminal, this text is followed by a series of dashes
extending to the right edge of the window.  These dashes are omitted on
a graphical display.

   The CS string and the colon character after it describe the character
set and newline convention used for the current buffer.  Normally, Emacs
automatically handles these settings for you, but it is sometimes useful
to have this information.

   CS describes the character set of the text in the buffer (*note
Coding Systems::).  If it is a dash ('-'), that indicates no special
character set handling (with the possible exception of end-of-line
conventions, described in the next paragraph).  '=' means no conversion
whatsoever, and is usually used for files containing non-textual data.
Other characters represent various "coding systems"--for example, '1'
represents ISO Latin-1.

   On a text terminal, CS is preceded by two additional characters that
describe the coding systems for keyboard input and terminal output.
Furthermore, if you are using an input method, CS is preceded by a
string that identifies the input method (*note Input Methods::).

   The character after CS is usually a colon.  If a different string is
displayed, that indicates a nontrivial end-of-line convention for
encoding a file.  Usually, lines of text are separated by "newline
characters" in a file, but two other conventions are sometimes used.
The MS-DOS convention uses a carriage return character followed by a
linefeed character; when editing such files, the colon changes to either
a backslash ('\') or '(DOS)', depending on the operating system.
Another convention, employed by older Macintosh systems, uses a carriage
return character instead of a newline; when editing such files, the
colon changes to either a forward slash ('/') or '(Mac)'.  On some
systems, Emacs displays '(Unix)' instead of the colon for files that use
newline as the line separator.

   On frames created for 'emacsclient' (*note Invoking emacsclient::),
the next character is '@'.  This indication is typical for frames of an
Emacs process running as a daemon (*note Emacs Server::).

   The next element on the mode line is the string indicated by CH.
This shows two dashes ('--') if the buffer displayed in the window has
the same contents as the corresponding file on the disk; i.e., if the
buffer is unmodified.  If the buffer is modified, it shows two stars
('**').  For a read-only buffer, it shows '%*' if the buffer is
modified, and '%%' otherwise.

   The character after CH is normally a dash ('-').  However, if
'default-directory' (*note File Names::) for the current buffer is on a
remote machine, '@' is displayed instead.

   FR gives the selected frame name (*note Frames::).  It appears only
on text terminals.  The initial frame's name is 'F1'.

   BUF is the name of the buffer displayed in the window.  Usually, this
is the same as the name of a file you are editing.  *Note Buffers::.

   POS tells you whether there is additional text above the top of the
window, or below the bottom.  If your buffer is small and all of it is
visible in the window, POS is 'All'.  Otherwise, it is 'Top' if you are
looking at the beginning of the buffer, 'Bot' if you are looking at the
end of the buffer, or 'NN%', where NN is the percentage of the buffer
above the top of the window.  With Size Indication mode, you can display
the size of the buffer as well.  *Note Optional Mode Line::.

   LINE is the character 'L' followed by the line number at point.  (You
can display the current column number too, by turning on Column Number
mode.  *Note Optional Mode Line::.)

   MAJOR is the name of the "major mode" used in the buffer.  A major
mode is a principal editing mode for the buffer, such as Text mode, Lisp
mode, C mode, and so forth.  *Note Major Modes::.  Some major modes
display additional information after the major mode name.  For example,
Compilation buffers and Shell buffers display the status of the
subprocess.

   MINOR is a list of some of the enabled "minor modes", which are
optional editing modes that provide additional features on top of the
major mode.  *Note Minor Modes::.

   Some features are listed together with the minor modes whenever they
are turned on, even though they are not really minor modes.  'Narrow'
means that the buffer being displayed has editing restricted to only a
portion of its text (*note Narrowing::).  'Def' means that a keyboard
macro is currently being defined (*note Keyboard Macros::).

   In addition, if Emacs is inside a recursive editing level, square
brackets ('[...]') appear around the parentheses that surround the
modes.  If Emacs is in one recursive editing level within another,
double square brackets appear, and so on.  Since recursive editing
levels affect Emacs globally, such square brackets appear in the mode
line of every window.  *Note Recursive Edit::.

   You can change the appearance of the mode line as well as the format
of its contents.  *Note Optional Mode Line::.  In addition, the mode
line is mouse-sensitive; clicking on different parts of the mode line
performs various commands.  *Note Mode Line Mouse::.  Also, hovering the
mouse pointer above mouse-sensitive portions of the mode line shows
tooltips (*note Tooltips::) with information about commands you can
invoke by clicking on the mode line.

==============================================================================
File: emacs.info,  Node: |Menu_Bar|,  Prev: |Mode_Line|,  Up: |Screen|
==============================================================================

                                                                      *Menu_Bar*

1.4 The Menu Bar
----------------

Each Emacs frame normally has a "menu bar" at the top which you can use
to perform common operations.  There's no need to list them here, as you
can more easily see them yourself.

   On a display that supports a mouse, you can use the mouse to choose a
command from the menu bar.  An arrow on the right edge of a menu item
means it leads to a subsidiary menu, or "submenu".  A '...' at the end
of a menu item means that the command will prompt you for further input
before it actually does anything.

   Some of the commands in the menu bar have ordinary key bindings as
well; if so, a key binding is shown after the item itself.  To view the
full command name and documentation for a menu item, type 'C-h k', and
then select the menu bar with the mouse in the usual way (*note Key
Help::).

   Instead of using the mouse, you can also invoke the first menu bar
item by pressing <F10> (to run the command 'menu-bar-open').  You can
then navigate the menus with the arrow keys or with 'C-b', 'C-f'
(left/right), 'C-p', and 'C-n' (up/down).  To activate a selected menu
item, press <RET>; to cancel menu navigation, press 'C-g' or '<ESC>
<ESC> <ESC>'.  (However, note that when Emacs was built with a GUI
toolkit, the menus are drawn and controlled by the toolkit, and the key
sequences to cancel menu navigation might be different from the above
description.)

   On a text terminal, you can optionally access the menu-bar menus in
the echo area.  To this end, customize the variable
'tty-menu-open-use-tmm' to a non-'nil' value.  Then typing <F10> will
run the command 'tmm-menubar' instead of dropping down the menu.  (You
can also type 'M-`', which always invokes 'tmm-menubar'.)  'tmm-menubar'
lets you select a menu item with the keyboard.  A provisional choice
appears in the echo area.  You can use the up and down arrow keys to
move through the menu to different items, and then you can type <RET> to
select the item.  Each menu item is also designated by a letter or digit
(usually the initial of some word in the item's name).  This letter or
digit is separated from the item name by '==>'.  You can type the item's
letter or digit to select the item.

==============================================================================
File: emacs.info,  Node: |User_Input|,  Next: |Keys|,  Prev: |Screen|,  Up: |Top|
==============================================================================

                                                                    *User_Input*

2 Kinds of User Input
=====================

GNU Emacs is primarily designed for use with the keyboard.  While it is
possible to use the mouse to issue editing commands through the menu bar
and tool bar, that is not as efficient as using the keyboard.
Therefore, this manual mainly documents how to edit with the keyboard.

   Keyboard input into Emacs is based on a heavily-extended version of
ASCII.  Simple characters, like 'a', 'B', '3', '=', and the space
character (denoted as <SPC>), are entered by typing the corresponding
key.  "Control characters", such as <RET>, <TAB>, <DEL>, <ESC>, <F1>,
<Home>, and <LEFT>, are also entered this way, as are certain characters
found on non-English keyboards (*note International::).

   Emacs also recognizes control characters that are entered using
"modifier keys".  Two commonly-used modifier keys are <Control> (usually
labeled <Ctrl>), and <Meta> (usually labeled <Alt>)(1).  For example,
'Control-a' is entered by holding down the <Ctrl> key while pressing
'a'; we will refer to this as 'C-a' for short.  Similarly, '<Meta>-a',
or 'M-a' for short, is entered by holding down the <Alt> key and
pressing 'a'.  Modifier keys can also be applied to non-alphanumerical
characters, e.g., 'C-<F1>' or 'M-<LEFT>'.

   You can also type Meta characters using two-character sequences
starting with <ESC>.  Thus, you can enter 'M-a' by typing '<ESC> a'.
You can enter 'C-M-a' (holding down both <Ctrl> and <Alt>, then pressing
'a') by typing '<ESC> C-a'.  Unlike <Meta>, <ESC> is entered as a
separate character.  You don't hold down <ESC> while typing the next
character; instead, press <ESC> and release it, then enter the next
character.  This feature is useful on certain text terminals where the
<Meta> key does not function reliably.

   Emacs supports 3 additional modifier keys, see *note Modifier Keys::.

   On graphical displays, the window manager might block some keyboard
inputs, including 'M-<TAB>', 'M-<SPC>', 'C-M-d' and 'C-M-l'.  If you
have this problem, you can either customize your window manager to not
block those keys, or rebind the affected Emacs commands (*note
Customization::).

   Simple characters and control characters, as well as certain
non-keyboard inputs such as mouse clicks, are collectively referred to
as "input events".  For details about how Emacs internally handles input
events, see *note (elisp)Input Events::.

   ---------- Footnotes ----------

   (1) We refer to <Alt> as <Meta> for historical reasons.

==============================================================================
File: emacs.info,  Node: |Keys|,  Next: |Commands|,  Prev: |User_Input|,  Up: |Top|
==============================================================================

                                                                          *Keys*

3 Keys
======

Some Emacs commands are invoked by just one input event; for example,
'C-f' moves forward one character in the buffer.  Other commands take
two or more input events to invoke, such as 'C-x C-f' and 'C-x 4 C-f'.

   A "key sequence", or "key" for short, is a sequence of one or more
input events that is meaningful as a unit.  If a key sequence invokes a
command, we call it a "complete key"; for example, 'C-f', 'C-x C-f' and
'C-x 4 C-f' are all complete keys.  If a key sequence isn't long enough
to invoke a command, we call it a "prefix key"; from the preceding
example, we see that 'C-x' and 'C-x 4' are prefix keys.  Every key
sequence is either a complete key or a prefix key.

   A prefix key combines with the following input event to make a longer
key sequence.  For example, 'C-x' is a prefix key, so typing 'C-x' alone
does not invoke a command; instead, Emacs waits for further input (if
you pause for longer than a second, it echoes the 'C-x' key to prompt
for that input; *note Echo Area::).  'C-x' combines with the next input
event to make a two-event key sequence, which could itself be a prefix
key (such as 'C-x 4'), or a complete key (such as 'C-x C-f').  There is
no limit to the length of key sequences, but in practice they are seldom
longer than three or four input events.

   You can't add input events onto a complete key.  For example, because
'C-f' is a complete key, the two-event sequence 'C-f C-k' is two key
sequences, not one.

   By default, the prefix keys in Emacs are 'C-c', 'C-h', 'C-x', 'C-x
<RET>', 'C-x @', 'C-x a', 'C-x n', 'C-x r', 'C-x t', 'C-x v', 'C-x 4',
'C-x 5', 'C-x 6', <ESC>, 'M-g', and 'M-o'.  (<F1> and <F2> are aliases
for 'C-h' and 'C-x 6'.)  This list is not cast in stone; if you
customize Emacs, you can make new prefix keys.  You could even eliminate
some of the standard ones, though this is not recommended for most
users; for example, if you remove the prefix definition of 'C-x 4', then
'C-x 4 C-f' becomes an invalid key sequence.  *Note Key Bindings::.

   Typing the help character ('C-h' or <F1>) after a prefix key displays
a list of the commands starting with that prefix.  The sole exception to
this rule is <ESC>: '<ESC> C-h' is equivalent to 'C-M-h', which does
something else entirely.  You can, however, use <F1> to display a list
of commands starting with <ESC>.

==============================================================================
File: emacs.info,  Node: |Commands|,  Next: |Entering_Emacs|,  Prev: |Keys|,  Up: |Top|
==============================================================================

                                                                      *Commands*

4 Keys and Commands
===================

This manual is full of passages that tell you what particular keys do.
But Emacs does not assign meanings to keys directly.  Instead, Emacs
assigns meanings to named "commands", and then gives keys their meanings
by "binding" them to commands.

   Every command has a name chosen by a programmer.  The name is usually
made of a few English words separated by dashes; for example,
'next-line' or 'forward-word'.  Internally, each command is a special
type of Lisp "function", and the actions associated with the command are
performed by running the function.  *Note What Is a Function:
(elisp)What Is a Function.

   The bindings between keys and commands are recorded in tables called
"keymaps".  *Note Keymaps::.

   When we say that "'C-n' moves down vertically one line" we are
glossing over a subtle distinction that is irrelevant in ordinary use,
but vital for Emacs customization.  The command 'next-line' does a
vertical move downward.  'C-n' has this effect _because_ it is bound to
'next-line'.  If you rebind 'C-n' to the command 'forward-word', 'C-n'
will move forward one word instead.

   In this manual, we will often speak of keys like 'C-n' as commands,
even though strictly speaking the key is bound to a command.  Usually,
we state the name of the command which really does the work in
parentheses after mentioning the key that runs it.  For example, we will
say that "The command 'C-n' ('next-line') moves point vertically down",
meaning that the command 'next-line' moves vertically down, and the key
'C-n' is normally bound to it.

   Since we are discussing customization, we should tell you about
"variables".  Often the description of a command will say, "To change
this, set the variable 'mumble-foo'." A variable is a name used to store
a value.  Most of the variables documented in this manual are meant for
customization: some command or other part of Emacs examines the variable
and behaves differently according to the value that you set.  You can
ignore the information about variables until you are interested in
customizing them.  Then read the basic information on variables (*note
Variables::) and the information about specific variables will make
sense.

==============================================================================
File: emacs.info,  Node: |Entering_Emacs|,  Next: |Exiting|,  Prev: |Commands|,  Up: |Top|
==============================================================================

                                                                *Entering_Emacs*

5 Entering Emacs
================

The usual way to invoke Emacs is with the shell command 'emacs'.  From a
terminal window running a Unix shell on a GUI terminal, you can run
Emacs in the background with 'emacs &'; this way, Emacs won't tie up the
terminal window, so you can use it to run other shell commands.  (For
comparable methods of starting Emacs on MS-Windows, see *note Windows
Startup::.)

   When Emacs starts up, the initial frame displays a special buffer
named '*GNU Emacs*'.  This "startup screen" contains information about
Emacs and "links" to common tasks that are useful for beginning users.
For instance, activating the 'Emacs Tutorial' link opens the Emacs
tutorial; this does the same thing as the command 'C-h t'
('help-with-tutorial').  To activate a link, either move point onto it
and type '<RET>', or click on it with 'mouse-1' (the left mouse button).

   Using a command line argument, you can tell Emacs to visit one or
more files as soon as it starts up.  For example, 'emacs foo.txt' starts
Emacs with a buffer displaying the contents of the file 'foo.txt'.  This
feature exists mainly for compatibility with other editors, which are
designed to be launched from the shell for short editing sessions.  If
you call Emacs this way, the initial frame is split into two windows--one
showing the specified file, and the other showing the startup screen.
*Note Windows::.

   Generally, it is unnecessary and wasteful to start Emacs afresh each
time you want to edit a file.  The recommended way to use Emacs is to
start it just once, just after you log in, and do all your editing in
the same Emacs session.  *Note Files::, for information on visiting more
than one file.  If you use Emacs this way, the Emacs session accumulates
valuable context, such as the kill ring, registers, undo history, and
mark ring data, which together make editing more convenient.  These
features are described later in the manual.

   To edit a file from another program while Emacs is running, you can
use the 'emacsclient' helper program to open a file in the existing
Emacs session.  *Note Emacs Server::.

   Emacs accepts other command line arguments that tell it to load
certain Lisp files, where to put the initial frame, and so forth.  *Note
Emacs Invocation::.

   If the variable 'inhibit-startup-screen' is non-'nil', Emacs does not
display the startup screen.  In that case, if one or more files were
specified on the command line, Emacs simply displays those files;
otherwise, it displays a buffer named 'scratch', which can be used to
evaluate Emacs Lisp expressions interactively.  *Note Lisp
Interaction::.  You can set the variable 'inhibit-startup-screen' using
the Customize facility (*note Easy Customization::), or by editing your
initialization file (*note Init File::).(1)

   You can also force Emacs to display a file or directory at startup by
setting the variable 'initial-buffer-choice' to a string naming that
file or directory.  The value of 'initial-buffer-choice' may also be a
function (of no arguments) that should return a buffer which is then
displayed.  If 'initial-buffer-choice' is non-'nil', then if you specify
any files on the command line, Emacs still visits them, but does not
display them initially.

   ---------- Footnotes ----------

   (1) Setting 'inhibit-startup-screen' in 'site-start.el' doesn't work,
because the startup screen is set up before reading 'site-start.el'.
*Note Init File::, for information about 'site-start.el'.

==============================================================================
File: emacs.info,  Node: |Exiting|,  Next: |Basic|,  Prev: |Entering_Emacs|,  Up: |Top|
==============================================================================

                                                                       *Exiting*

6 Exiting Emacs
===============

'C-x C-c'
     Kill Emacs ('save-buffers-kill-terminal').
'C-z'
     On a text terminal, suspend Emacs; on a graphical display, iconify
     (or "minimize") the selected frame ('suspend-frame').

   "Killing" Emacs means terminating the Emacs program.  To do this,
type 'C-x C-c' ('save-buffers-kill-terminal').  A two-character key
sequence is used to make it harder to type by accident.  If there are
any modified file-visiting buffers when you type 'C-x C-c', Emacs first
offers to save these buffers.  If you do not save them all, it asks for
confirmation again, since the unsaved changes will be lost.  Emacs also
asks for confirmation if any subprocesses are still running, since
killing Emacs will also kill the subprocesses (*note Shell::).

   'C-x C-c' behaves specially if you are using Emacs as a server.  If
you type it from a client frame, it closes the client connection.  *Note
Emacs Server::.

   Emacs can, optionally, record certain session information when you
kill it, such as the files you were visiting at the time.  This
information is then available the next time you start Emacs.  *Note
Saving Emacs Sessions::.

   If the value of the variable 'confirm-kill-emacs' is non-'nil', 'C-x
C-c' assumes that its value is a predicate function, and calls that
function.  If the result of the function call is non-'nil', the session
is killed, otherwise Emacs continues to run.  One convenient function to
use as the value of 'confirm-kill-emacs' is the function 'yes-or-no-p'.
The default value of 'confirm-kill-emacs' is 'nil'.

   If the value of the variable 'confirm-kill-processes' is 'nil', 'C-x
C-c' does not ask for confirmation before killing subprocesses started
by Emacs.  The value is 't' by default.

   To further customize what happens when Emacs is exiting, see *note
(elisp)Killing Emacs::.

   To kill Emacs without being prompted about saving, type 'M-x
kill-emacs'.

   'C-z' runs the command 'suspend-frame'.  On a graphical display, this
command "minimizes" (or "iconifies") the selected Emacs frame, hiding it
in a way that lets you bring it back later (exactly how this hiding
occurs depends on the window system).  On a text terminal, the 'C-z'
command "suspends" Emacs, stopping the program temporarily and returning
control to the parent process (usually a shell); in most shells, you can
resume Emacs after suspending it with the shell command '%emacs'.

   Text terminals usually listen for certain special characters whose
meaning is to kill or suspend the program you are running.  This
terminal feature is turned off while you are in Emacs.  The meanings of
'C-z' and 'C-x C-c' as keys in Emacs were inspired by the use of 'C-z'
and 'C-c' on several operating systems as the characters for stopping or
killing a program, but that is their only relationship with the
operating system.  You can customize these keys to run any commands of
your choice (*note Keymaps::).

==============================================================================
File: emacs.info,  Node: |Basic|,  Next: |Minibuffer|,  Prev: |Exiting|,  Up: |Top|
==============================================================================

                                                                         *Basic*

7 Basic Editing Commands
========================

Here we explain the basics of how to enter text, make corrections, and
save the text in a file.  If this material is new to you, we suggest you
first run the Emacs learn-by-doing tutorial, by typing 'C-h t'
('help-with-tutorial').

MENU


* |Inserting_Text|::      Inserting text by simply typing it.
* |Moving_Point|::        Moving the cursor to the place where you want to
                          change something.
* |Erasing|::             Deleting and killing text.
* |Basic_Undo|::          Undoing recent changes in the text.
* Files: Basic Files.   Visiting, creating, and saving files.
* Help: Basic Help.     Asking what a character does.
* |Blank_Lines|::         Making and deleting blank lines.
* |Continuation_Lines|::  How Emacs displays lines too wide for the screen.
* |Position_Info|::       What line, row, or column is point on?
* |Arguments|::           Numeric arguments for repeating a command N times.
* |Repeating|::           Repeating the previous command quickly.

==============================================================================
File: emacs.info,  Node: |Inserting_Text|,  Next: |Moving_Point|,  Up: |Basic|
==============================================================================

                                                                *Inserting_Text*

7.1 Inserting Text
------------------

You can insert an ordinary "graphic character" (e.g., 'a', 'B', '3', and
'=') by typing the associated key.  This adds the character to the
buffer at point.  Insertion moves point forward, so that point remains
just after the inserted text.  *Note Point::.

   To end a line and start a new one, type <RET> ('newline').  (The
<RET> key may be labeled <Return>, or <Enter>, or with a funny-looking
left-pointing arrow on your keyboard, but we refer to it as <RET> in
this manual.)  This command inserts a newline character into the buffer,
then indents (*note Indentation::) according to the major mode.  If
point is at the end of the line, the effect is to create a new blank
line after it and indent the new line; if point is in the middle of a
line, the line is split at that position.  To turn off the
auto-indentation, you can either disable Electric Indent mode (*note
Indent Convenience::) or type 'C-j', which inserts just a newline,
without any auto-indentation.

   As we explain later in this manual, you can change the way Emacs
handles text insertion by turning on "minor modes".  For instance, the
minor mode called Auto Fill mode splits lines automatically when they
get too long (*note Filling::).  The minor mode called Overwrite mode
causes inserted characters to replace (overwrite) existing text, instead
of shoving it to the right.  *Note Minor Modes::.

   Only graphic characters can be inserted by typing the associated key;
other keys act as editing commands and do not insert themselves.  For
instance, <DEL> runs the command 'delete-backward-char' by default (some
modes bind it to a different command); it does not insert a literal
'DEL' character (ASCII character code 127).

   To insert a non-graphic character, or a character that your keyboard
does not support, first "quote" it by typing 'C-q' ('quoted-insert').
There are two ways to use 'C-q':

   * 'C-q' followed by any non-graphic character (even 'C-g') inserts
     that character.  For instance, 'C-q <DEL>' inserts a literal 'DEL'
     character.

   * 'C-q' followed by a sequence of octal digits inserts the character
     with the specified octal character code.  You can use any number of
     octal digits; any non-digit terminates the sequence.  If the
     terminating character is <RET>, that <RET> serves only to terminate
     the sequence.  Any other non-digit terminates the sequence and then
     acts as normal input--thus, 'C-q 1 0 1 B' inserts 'AB'.

     The use of octal sequences is disabled in ordinary non-binary
     Overwrite mode, to give you a convenient way to insert a digit
     instead of overwriting with it.

To use decimal or hexadecimal instead of octal, set the variable
'read-quoted-char-radix' to 10 or 16.  If the radix is 16, the letters
'a' to 'f' serve as part of a character code, just like digits.  Case is
ignored.

   A few common Unicode characters can be inserted via a command
starting with 'C-x 8'.  For example, 'C-x 8 [' inserts ' which is
Unicode code-point U+2018 LEFT SINGLE QUOTATION MARK, sometimes called a
left single "curved quote" or "curly quote".  Similarly, 'C-x 8 ]', 'C-x
8 {' and 'C-x 8 }' insert the curved quotes ', " and ", respectively.
Also, a working <Alt> key acts like 'C-x 8' (unless followed by <RET>);
e.g., 'A-[' acts like 'C-x 8 [' and inserts '.  To see which characters
have 'C-x 8' shorthands, type 'C-x 8 C-h'.

   Alternatively, you can use the command 'C-x 8 <RET>' ('insert-char').
This prompts for the Unicode name or code-point of a character, using
the minibuffer.  If you enter a name, the command provides completion
(*note Completion::).  If you enter a code-point, it should be as a
hexadecimal number (the convention for Unicode), or a number with a
specified radix, e.g., '#o23072' (octal); *Note (elisp)Integer Basics::.
The command then inserts the corresponding character into the buffer.

   For example, the following all insert the same character:

     C-x 8 <RET> left single quotation mark <RET>
     C-x 8 <RET> left sin <TAB> <RET>
     C-x 8 <RET> 2018 <RET>
     C-x 8 [
     A-[  (if the Alt key works)
     `    (in Electric Quote mode)

   A numeric argument to 'C-q' or 'C-x 8 ...' specifies how many copies
of the character to insert (*note Arguments::).

   In addition, in some contexts, if you type a quotation using grave
accent and apostrophe '`like this'', it is converted to a form 'like
this' using single quotation marks, even without 'C-x 8' commands.
Similarly, typing a quotation '``like this''' using double grave accent
and apostrophe converts it to a form "like this" using double quotation
marks.  *Note Quotation Marks::.

==============================================================================
File: emacs.info,  Node: |Moving_Point|,  Next: |Erasing|,  Prev: |Inserting_Text|,  Up: |Basic|
==============================================================================

                                                                  *Moving_Point*

7.2 Changing the Location of Point
----------------------------------

To do more than insert characters, you have to know how to move point
(*note Point::).  The keyboard commands 'C-f', 'C-b', 'C-n', and 'C-p'
move point to the right, left, down, and up, respectively.  You can also
move point using the "arrow keys" present on most keyboards: <RIGHT>,
<LEFT>, <DOWN>, and <UP>; however, many Emacs users find that it is
slower to use the arrow keys than the control keys, because you need to
move your hand to the area of the keyboard where those keys are located.

   You can also click the left mouse button to move point to the
position clicked.  Emacs also provides a variety of additional keyboard
commands that move point in more sophisticated ways.

'C-f'
     Move forward one character ('forward-char').

'<RIGHT>'
     This command ('right-char') behaves like 'C-f', except when point
     is in a right-to-left paragraph (*note Bidirectional Editing::).

'C-b'
     Move backward one character ('backward-char').

'<LEFT>'
     This command ('left-char') behaves like 'C-b', except if the
     current paragraph is right-to-left (*note Bidirectional Editing::).

'C-n'
'<DOWN>'
     Move down one screen line ('next-line').  This command attempts to
     keep the horizontal position unchanged, so if you start in the
     middle of one line, you move to the middle of the next.

'C-p'
'<UP>'
     Move up one screen line ('previous-line').  This command preserves
     position within the line, like 'C-n'.

'C-a'
'<Home>'
     Move to the beginning of the line ('move-beginning-of-line').

'C-e'
'<End>'
     Move to the end of the line ('move-end-of-line').

'M-f'
     Move forward one word ('forward-word').  *Note Words::.

'C-<RIGHT>'
'M-<RIGHT>'
     This command ('right-word') behaves like 'M-f', except it moves
     _backward_ by one word if the current paragraph is right-to-left.
     *Note Bidirectional Editing::.

'M-b'
     Move backward one word ('backward-word').  *Note Words::.

'C-<LEFT>'
'M-<LEFT>'
     This command ('left-word') behaves like 'M-b', except it moves
     _forward_ by one word if the current paragraph is right-to-left.
     *Note Bidirectional Editing::.

'M-r'
     Without moving the text on the screen, reposition point on the left
     margin of the center-most text line of the window; on subsequent
     consecutive invocations, move point to the left margin of the
     top-most line, the bottom-most line, and so forth, in cyclic order
     ('move-to-window-line-top-bottom').

     A numeric argument says which screen line to place point on,
     counting downward from the top of the window (zero means the top
     line).  A negative argument counts lines up from the bottom (-1
     means the bottom line).  *Note Arguments::, for more information on
     numeric arguments.

'M-<'
     Move to the top of the buffer ('beginning-of-buffer').  With
     numeric argument N, move to N/10 of the way from the top.  On
     graphical displays, 'C-<HOME>' does the same.

'M->'
     Move to the end of the buffer ('end-of-buffer').  On graphical
     displays, 'C-<END>' does the same.

'C-v'
'<PageDown>'
'<next>'
     Scroll the display one screen forward, and move point onscreen if
     necessary ('scroll-up-command').  *Note Scrolling::.

'M-v'
'<PageUp>'
'<prior>'
     Scroll one screen backward, and move point onscreen if necessary
     ('scroll-down-command').  *Note Scrolling::.

'M-g c'
     Read a number N and move point to buffer position N.  Position 1 is
     the beginning of the buffer.

'M-g M-g'
'M-g g'
     Read a number N and move point to the beginning of line number N
     ('goto-line').  Line 1 is the beginning of the buffer.  If point is
     on or just after a number in the buffer, that is the default for N.
     Just type <RET> in the minibuffer to use it.  You can also specify
     N by giving 'M-g M-g' a numeric prefix argument.  *Note Select
     Buffer::, for the behavior of 'M-g M-g' when you give it a plain
     prefix argument.

'M-g <TAB>'
     Read a number N and move to column N in the current line.  Column 0
     is the leftmost column.  If called with a prefix argument, move to
     the column number specified by the argument's numeric value.

'C-x C-n'
     Use the current column of point as the "semipermanent goal column"
     for 'C-n' and 'C-p' ('set-goal-column') in the current buffer.
     When a semipermanent goal column is in effect, those commands
     always try to move to this column, or as close as possible to it,
     after moving vertically.  The goal column remains in effect until
     canceled.

'C-u C-x C-n'
     Cancel the goal column.  Henceforth, 'C-n' and 'C-p' try to
     preserve the horizontal position, as usual.

   When a line of text in the buffer is longer than the width of the
window, Emacs usually displays it on two or more "screen lines".  For
convenience, 'C-n' and 'C-p' move point by screen lines, as do the
equivalent keys '<down>' and '<up>'.  You can force these commands to
move according to "logical lines" (i.e., according to the text lines in
the buffer) by setting the variable 'line-move-visual' to 'nil'; if a
logical line occupies multiple screen lines, the cursor then skips over
the additional screen lines.  For details, see *note Continuation
Lines::.  *Note Variables::, for how to set variables such as
'line-move-visual'.

   Unlike 'C-n' and 'C-p', most of the Emacs commands that work on lines
work on _logical_ lines.  For instance, 'C-a' ('move-beginning-of-line')
and 'C-e' ('move-end-of-line') respectively move to the beginning and
end of the logical line.  Whenever we encounter commands that work on
screen lines, such as 'C-n' and 'C-p', we will point these out.

   When 'line-move-visual' is 'nil', you can also set the variable
'track-eol' to a non-'nil' value.  Then 'C-n' and 'C-p', when starting
at the end of the logical line, move to the end of the next logical
line.  Normally, 'track-eol' is 'nil'.

   'C-n' normally stops at the end of the buffer when you use it on the
last line in the buffer.  However, if you set the variable
'next-line-add-newlines' to a non-'nil' value, 'C-n' on the last line of
a buffer creates an additional line at the end and moves down into it.

==============================================================================
File: emacs.info,  Node: |Erasing|,  Next: |Basic_Undo|,  Prev: |Moving_Point|,  Up: |Basic|
==============================================================================

                                                                       *Erasing*

7.3 Erasing Text
----------------

'<DEL>'
'<BACKSPACE>'
     Delete the character before point, or the region if it is active
     ('delete-backward-char').

'<Delete>'
     Delete the character after point, or the region if it is active
     ('delete-forward-char').

'C-d'
     Delete the character after point ('delete-char').

'C-k'
     Kill to the end of the line ('kill-line').

'M-d'
     Kill forward to the end of the next word ('kill-word').

'M-<DEL>'
'M-<BACKSPACE>'
     Kill back to the beginning of the previous word
     ('backward-kill-word').

   The '<DEL>' ('delete-backward-char') command removes the character
before point, moving the cursor and the characters after it backwards.
If point was at the beginning of a line, this deletes the preceding
newline, joining this line to the previous one.

   If, however, the region is active, '<DEL>' instead deletes the text
in the region.  *Note Mark::, for a description of the region.

   On most keyboards, <DEL> is labeled <BACKSPACE>, but we refer to it
as <DEL> in this manual.  (Do not confuse <DEL> with the <Delete> key;
we will discuss <Delete> momentarily.)  On some text terminals, Emacs
may not recognize the <DEL> key properly.  *Note DEL Does Not Delete::,
if you encounter this problem.

   The <Delete> ('delete-forward-char') command deletes in the opposite
direction: it deletes the character after point, i.e., the character
under the cursor.  If point was at the end of a line, this joins the
following line onto this one.  Like '<DEL>', it deletes the text in the
region if the region is active (*note Mark::).

   'C-d' ('delete-char') deletes the character after point, similar to
<Delete>, but regardless of whether the region is active.

   *Note Deletion::, for more detailed information about the above
deletion commands.

   'C-k' ('kill-line') erases (kills) a line at a time.  If you type
'C-k' at the beginning or middle of a line, it kills all the text up to
the end of the line.  If you type 'C-k' at the end of a line, it joins
that line with the following line.

   *Note Killing::, for more information about 'C-k' and related
commands.

==============================================================================
File: emacs.info,  Node: |Basic_Undo|,  Next: |Basic_Files|,  Prev: |Erasing|,  Up: |Basic|
==============================================================================

                                                                    *Basic_Undo*

7.4 Undoing Changes
-------------------

'C-/'
'C-x u'
'C-_'
     Undo one entry of the undo records--usually, one command worth
     ('undo').  (The first key might be unavailable on text-mode
     displays.)

   Emacs records a list of changes made in the buffer text, so you can
undo recent changes.  This is done using the 'undo' command, which is
bound to 'C-/' (as well as 'C-x u' and 'C-_').  Normally, this command
undoes the last change, moving point back to where it was before the
change.  The undo command applies only to changes in the buffer; you
can't use it to undo cursor motion.

   Although each editing command usually makes a separate entry in the
undo records, very simple commands may be grouped together.  Sometimes,
an entry may cover just part of a complex command.

   If you repeat 'C-/' (or its aliases), each repetition undoes another,
earlier change, back to the limit of the undo information available.  If
all recorded changes have already been undone, the undo command displays
an error message and does nothing.

   To learn more about the 'undo' command, see *note Undo::.

==============================================================================
File: emacs.info,  Node: |Basic_Files|,  Next: |Basic_Help|,  Prev: |Basic_Undo|,  Up: |Basic|
==============================================================================

                                                                   *Basic_Files*

7.5 Files
---------

Text that you insert in an Emacs buffer lasts only as long as the Emacs
session.  To keep any text permanently, you must put it in a "file".

   Suppose there is a file named 'test.emacs' in your home directory.
To begin editing this file in Emacs, type

     C-x C-f test.emacs <RET>

Here the file name is given as an "argument" to the command 'C-x C-f'
('find-file').  That command uses the "minibuffer" to read the argument,
and you type <RET> to terminate the argument (*note Minibuffer::).

   Emacs obeys this command by "visiting" the file: it creates a buffer,
copies the contents of the file into the buffer, and then displays the
buffer for editing.  If you alter the text, you can "save" the new text
in the file by typing 'C-x C-s' ('save-buffer').  This copies the
altered buffer contents back into the file 'test.emacs', making them
permanent.  Until you save, the changed text exists only inside Emacs,
and the file 'test.emacs' is unaltered.

   To create a file, just visit it with 'C-x C-f' as if it already
existed.  This creates an empty buffer, in which you can insert the text
you want to put in the file.  Emacs actually creates the file the first
time you save this buffer with 'C-x C-s'.

   To learn more about using files in Emacs, see *note Files::.

==============================================================================
File: emacs.info,  Node: |Basic_Help|,  Next: |Blank_Lines|,  Prev: |Basic_Files|,  Up: |Basic|
==============================================================================

                                                                    *Basic_Help*

7.6 Help
--------

If you forget what a key does, you can find out by typing 'C-h k'
('describe-key'), followed by the key of interest; for example, 'C-h k
C-n' tells you what 'C-n' does.

   The prefix key 'C-h' stands for "help".  The key <F1> serves as an
alias for 'C-h'.  Apart from 'C-h k', there are many other help commands
providing different kinds of help.

   *Note Help::, for details.

==============================================================================
File: emacs.info,  Node: |Blank_Lines|,  Next: |Continuation_Lines|,  Prev: |Basic_Help|,  Up: |Basic|
==============================================================================

                                                                   *Blank_Lines*

7.7 Blank Lines
---------------

Here are special commands and techniques for inserting and deleting
blank lines.

'C-o'
     Insert a blank line after the cursor ('open-line').
'C-x C-o'
     Delete all but one of many consecutive blank lines
     ('delete-blank-lines').

   We have seen how '<RET>' ('newline') starts a new line of text.
However, it may be easier to see what you are doing if you first make a
blank line and then insert the desired text into it.  This is easy to do
using the key 'C-o' ('open-line'), which inserts a newline after point
but leaves point in front of the newline.  After 'C-o', type the text
for the new line.

   You can make several blank lines by typing 'C-o' several times, or by
giving it a numeric argument specifying how many blank lines to make.
*Note Arguments::, for how.  If you have a fill prefix, the 'C-o'
command inserts the fill prefix on the new line, if typed at the
beginning of a line.  *Note Fill Prefix::.

   The easy way to get rid of extra blank lines is with the command 'C-x
C-o' ('delete-blank-lines').  If point lies within a run of several
blank lines, 'C-x C-o' deletes all but one of them.  If point is on a
single blank line, 'C-x C-o' deletes it.  If point is on a nonblank
line, 'C-x C-o' deletes all following blank lines, if any exists.

==============================================================================
File: emacs.info,  Node: |Continuation_Lines|,  Next: |Position_Info|,  Prev: |Blank_Lines|,  Up: |Basic|
==============================================================================

                                                            *Continuation_Lines*

7.8 Continuation Lines
----------------------

Sometimes, a line of text in the buffer--a "logical line"--is too long to
fit in the window, and Emacs displays it as two or more "screen lines".
This is called "line wrapping" or "continuation", and the long logical
line is called a "continued line".  On a graphical display, Emacs
indicates line wrapping with small bent arrows in the left and right
window fringes.  On a text terminal, Emacs indicates line wrapping by
displaying a '\' character at the right margin.

   Most commands that act on lines act on logical lines, not screen
lines.  For instance, 'C-k' kills a logical line.  As described earlier,
'C-n' ('next-line') and 'C-p' ('previous-line') are special exceptions:
they move point down and up, respectively, by one screen line (*note
Moving Point::).

   Emacs can optionally "truncate" long logical lines instead of
continuing them.  This means that every logical line occupies a single
screen line; if it is longer than the width of the window, the rest of
the line is not displayed.  On a graphical display, a truncated line is
indicated by a small straight arrow in the right fringe; on a text
terminal, it is indicated by a '$' character in the right margin.  *Note
Line Truncation::.

   By default, continued lines are wrapped at the right window edge.
Since the wrapping may occur in the middle of a word, continued lines
can be difficult to read.  The usual solution is to break your lines
before they get too long, by inserting newlines.  If you prefer, you can
make Emacs insert a newline automatically when a line gets too long, by
using Auto Fill mode.  *Note Filling::.

   Sometimes, you may need to edit files containing many long logical
lines, and it may not be practical to break them all up by adding
newlines.  In that case, you can use Visual Line mode, which enables
"word wrapping": instead of wrapping long lines exactly at the right
window edge, Emacs wraps them at the word boundaries (i.e., space or tab
characters) nearest to the right window edge.  Visual Line mode also
redefines editing commands such as 'C-a', 'C-n', and 'C-k' to operate on
screen lines rather than logical lines.  *Note Visual Line Mode::.

==============================================================================
File: emacs.info,  Node: |Position_Info|,  Next: |Arguments|,  Prev: |Continuation_Lines|,  Up: |Basic|
==============================================================================

                                                                 *Position_Info*

7.9 Cursor Position Information
-------------------------------

Here are commands to get information about the size and position of
parts of the buffer, and to count words and lines.

'M-x what-line'
     Display the line number of point.
'M-x line-number-mode'
'M-x column-number-mode'
     Toggle automatic display of the current line number or column
     number.  *Note Optional Mode Line::.  If you want to have a line
     number displayed before each line, see *note Display Custom::.

'M-='
     Display the number of lines, words, and characters that are present
     in the region ('count-words-region').  *Note Mark::, for
     information about the region.

'M-x count-words'
     Display the number of lines, words, and characters that are present
     in the buffer.  If the region is active (*note Mark::), display the
     numbers for the region instead.

'C-x ='
     Display the character code of character after point, character
     position of point, and column of point ('what-cursor-position').
'M-x hl-line-mode'
     Enable or disable highlighting of the current line.  *Note Cursor
     Display::.
'M-x size-indication-mode'
     Toggle automatic display of the size of the buffer.  *Note Optional
     Mode Line::.

   'M-x what-line' displays the current line number in the echo area.
This command is usually redundant because the current line number is
shown in the mode line (*note Mode Line::).  However, if you narrow the
buffer, the mode line shows the line number relative to the accessible
portion (*note Narrowing::).  By contrast, 'what-line' displays both the
line number relative to the narrowed region and the line number relative
to the whole buffer.

   'M-=' ('count-words-region') displays a message reporting the number
of lines, words, and characters in the region (*note Mark::, for an
explanation of the region).  With a prefix argument, 'C-u M-=', the
command displays a count for the entire buffer.

   The command 'M-x count-words' does the same job, but with a different
calling convention.  It displays a count for the region if the region is
active, and for the buffer otherwise.

   The command 'C-x =' ('what-cursor-position') shows information about
the current cursor position and the buffer contents at that position.
It displays a line in the echo area that looks like this:

     Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53

   After 'Char:', this shows the character in the buffer at point.  The
text inside the parenthesis shows the corresponding decimal, octal and
hex character codes; for more information about how 'C-x =' displays
character information, see *note International Chars::.  After 'point='
is the position of point as a character count (the first character in
the buffer is position 1, the second character is position 2, and so
on).  The number after that is the total number of characters in the
buffer, and the number in parenthesis expresses the position as a
percentage of the total.  After 'column=' is the horizontal position of
point, in columns counting from the left edge of the window.

   If the user option 'what-cursor-show-names' is non-'nil', the name of
the character, as defined by the Unicode Character Database, is shown as
well.  The part in parentheses would then become:

     (99, #o143, #x63, LATIN SMALL LETTER C)

   If the buffer has been narrowed, making some of the text at the
beginning and the end temporarily inaccessible, 'C-x =' displays
additional text describing the currently accessible range.  For example,
it might display this:

     Char: C (67, #o103, #x43) point=252 of 889 (28%) <231-599> column=0

where the two extra numbers give the smallest and largest character
position that point is allowed to assume.  The characters between those
two positions are the accessible ones.  *Note Narrowing::.

   Related, but different feature is 'display-line-numbers-mode' (*note
Display Custom::).

==============================================================================
File: emacs.info,  Node: |Arguments|,  Next: |Repeating|,  Prev: |Position_Info|,  Up: |Basic|
==============================================================================

                                                                     *Arguments*

7.10 Numeric Arguments
----------------------

In the terminology of mathematics and computing, "argument" means "data
provided to a function or operation".  You can give any Emacs command a
"numeric argument" (also called a "prefix argument").  Some commands
interpret the argument as a repetition count.  For example, giving 'C-f'
an argument of ten causes it to move point forward by ten characters
instead of one.  With these commands, no argument is equivalent to an
argument of one, and negative arguments cause them to move or act in the
opposite direction.

   The easiest way to specify a numeric argument is to type a digit
and/or a minus sign while holding down the <Meta> key.  For example,

     M-5 C-n

moves down five lines.  The keys 'M-1', 'M-2', and so on, as well as
'M--', are bound to commands ('digit-argument' and 'negative-argument')
that set up an argument for the next command.  'M--' without digits
normally means -1.

   If you enter more than one digit, you need not hold down the <Meta>
key for the second and subsequent digits.  Thus, to move down fifty
lines, type

     M-5 0 C-n

Note that this _does not_ insert five copies of '0' and move down one
line, as you might expect--the '0' is treated as part of the prefix
argument.

   (What if you do want to insert five copies of '0'?  Type 'M-5 C-u 0'.
Here, 'C-u' terminates the prefix argument, so that the next keystroke
begins the command that you want to execute.  Note that this meaning of
'C-u' applies only to this case.  For the usual role of 'C-u', see
below.)

   Instead of typing 'M-1', 'M-2', and so on, another way to specify a
numeric argument is to type 'C-u' ('universal-argument') followed by
some digits, or (for a negative argument) a minus sign followed by
digits.  A minus sign without digits normally means -1.

   'C-u' alone has the special meaning of "four times": it multiplies
the argument for the next command by four.  'C-u C-u' multiplies it by
sixteen.  Thus, 'C-u C-u C-f' moves forward sixteen characters.  Other
useful combinations are 'C-u C-n', 'C-u C-u C-n' (move down a good
fraction of a screen), 'C-u C-u C-o' (make sixteen blank lines), and
'C-u C-k' (kill four lines).

   You can use a numeric argument before a self-inserting character to
insert multiple copies of it.  This is straightforward when the
character is not a digit; for example, 'C-u 6 4 a' inserts 64 copies of
the character 'a'.  But this does not work for inserting digits;
'C-u 6 4 1' specifies an argument of 641.  You can separate the argument
from the digit to insert with another 'C-u'; for example,
'C-u 6 4 C-u 1' does insert 64 copies of the character '1'.

   Some commands care whether there is an argument, but ignore its
value.  For example, the command 'M-q' ('fill-paragraph') fills text;
with an argument, it justifies the text as well.  (*Note Filling::, for
more information on 'M-q'.)  For these commands, it is enough to specify
the argument with a single 'C-u'.

   Some commands use the value of the argument as a repeat count but do
something special when there is no argument.  For example, the command
'C-k' ('kill-line') with argument N kills N lines, including their
terminating newlines.  But 'C-k' with no argument is special: it kills
the text up to the next newline, or, if point is right at the end of the
line, it kills the newline itself.  Thus, two 'C-k' commands with no
arguments can kill a nonblank line, just like 'C-k' with an argument of
one.  (*Note Killing::, for more information on 'C-k'.)

   A few commands treat a plain 'C-u' differently from an ordinary
argument.  A few others may treat an argument of just a minus sign
differently from an argument of -1.  These unusual cases are described
when they come up; they exist to make an individual command more
convenient, and they are documented in that command's documentation
string.

   We use the term "prefix argument" to emphasize that you type such
arguments _before_ the command, and to distinguish them from minibuffer
arguments (*note Minibuffer::), which are entered _after_ invoking the
command.

   On graphical displays, 'C-0', 'C-1', etc. act the same as 'M-0',
'M-1', etc.

==============================================================================
File: emacs.info,  Node: |Repeating|,  Prev: |Arguments|,  Up: |Basic|
==============================================================================

                                                                     *Repeating*

7.11 Repeating a Command
------------------------

Many simple commands, such as those invoked with a single key or with
'M-x COMMAND-NAME <RET>', can be repeated by invoking them with a
numeric argument that serves as a repeat count (*note Arguments::).
However, if the command you want to repeat prompts for input, or uses a
numeric argument in another way, that method won't work.

   The command 'C-x z' ('repeat') provides another way to repeat an
Emacs command many times.  This command repeats the previous Emacs
command, whatever that was.  Repeating a command uses the same arguments
that were used before; it does not read new arguments each time.

   To repeat the command more than once, type additional 'z''s: each 'z'
repeats the command one more time.  Repetition ends when you type a
character other than 'z' or press a mouse button.

   For example, suppose you type 'C-u 2 0 C-d' to delete 20 characters.
You can repeat that command (including its argument) three additional
times, to delete a total of 80 characters, by typing 'C-x z z z'.  The
first 'C-x z' repeats the command once, and each subsequent 'z' repeats
it once again.

==============================================================================
File: emacs.info,  Node: |Minibuffer|,  Next: |M_x|,  Prev: |Basic|,  Up: |Top|
==============================================================================

                                                                    *Minibuffer*

8 The Minibuffer
================

The "minibuffer" is where Emacs commands read complicated arguments,
such as file names, buffer names, Emacs command names, or Lisp
expressions.  We call it the "minibuffer" because it's a special-purpose
buffer with a small amount of screen space.  You can use the usual Emacs
editing commands in the minibuffer to edit the argument text.

MENU

* |Basic_Minibuffer|::      Basic usage of the minibuffer.
* |Minibuffer_File|::       Entering file names with the minibuffer.
* |Minibuffer_Edit|::       How to edit in the minibuffer.
* |Completion|::            An abbreviation facility for minibuffer input.
* |Minibuffer_History|::    Reusing recent minibuffer arguments.
* |Repetition|::            Re-executing commands that used the minibuffer.
* |Passwords|::             Entering passwords in the echo area.
* |Yes_or_No_Prompts|::     Replying yes or no in the echo area.

==============================================================================
File: emacs.info,  Node: |Basic_Minibuffer|,  Next: |Minibuffer_File|,  Up: |Minibuffer|
==============================================================================

                                                              *Basic_Minibuffer*

8.1 Using the Minibuffer
------------------------

When the minibuffer is in use, it appears in the echo area, with a
cursor.  The minibuffer starts with a "prompt", usually ending with a
colon.  The prompt states what kind of input is expected, and how it
will be used.  The prompt is highlighted using the 'minibuffer-prompt'
face (*note Faces::).

   The simplest way to enter a minibuffer argument is to type the text,
then <RET> to submit the argument and exit the minibuffer.
Alternatively, you can type 'C-g' to exit the minibuffer by canceling
the command asking for the argument (*note Quitting::).

   Sometimes, the prompt shows a "default argument", inside parentheses
before the colon.  This default will be used as the argument if you just
type <RET>.  For example, commands that read buffer names usually show a
buffer name as the default; you can type <RET> to operate on that
default buffer.

   If you enable Minibuffer Electric Default mode, a global minor mode,
Emacs hides the default argument as soon as you modify the contents of
the minibuffer (since typing <RET> would no longer submit that default).
If you ever bring back the original minibuffer text, the prompt again
shows the default.  Furthermore, if you change the variable
'minibuffer-eldef-shorten-default' to a non-'nil' value, the default
argument is displayed as '[DEFAULT-ARG]' instead of '(default
DEFAULT-ARG)', saving some screen space.  To enable this minor mode,
type 'M-x minibuffer-electric-default-mode'.

   Since the minibuffer appears in the echo area, it can conflict with
other uses of the echo area.  If an error message or an informative
message is emitted while the minibuffer is active, the message hides the
minibuffer for a few seconds, or until you type something; then the
minibuffer comes back.  While the minibuffer is in use, Emacs does not
echo keystrokes.

==============================================================================
File: emacs.info,  Node: |Minibuffer_File|,  Next: |Minibuffer_Edit|,  Prev: |Basic_Minibuffer|,  Up: |Minibuffer|
==============================================================================

                                                               *Minibuffer_File*

8.2 Minibuffers for File Names
------------------------------

Commands such as 'C-x C-f' ('find-file') use the minibuffer to read a
file name argument (*note Basic Files::).  When the minibuffer is used
to read a file name, it typically starts out with some initial text
ending in a slash.  This is the "default directory".  For example, it
may start out like this:

     Find file: /u2/emacs/src/

Here, 'Find file: ' is the prompt and '/u2/emacs/src/' is the default
directory.  If you now type 'buffer.c' as input, that specifies the file
'/u2/emacs/src/buffer.c'.  *Note File Names::, for information about the
default directory.

   Alternative defaults for the file name you may want are available by
typing 'M-n', see *note Minibuffer History::.

   You can specify a file in the parent directory with '..':
'/a/b/../foo.el' is equivalent to '/a/foo.el'.  Alternatively, you can
use 'M-<DEL>' to kill directory names backwards (*note Words::).

   To specify a file in a completely different directory, you can kill
the entire default with 'C-a C-k' (*note Minibuffer Edit::).
Alternatively, you can ignore the default, and enter an absolute file
name starting with a slash or a tilde after the default directory.  For
example, you can specify '/etc/termcap' as follows:

     Find file: /u2/emacs/src//etc/termcap

A double slash causes Emacs to ignore everything before the second slash
in the pair.  In the example above, '/u2/emacs/src/' is ignored, so the
argument you supplied is '/etc/termcap'.  The ignored part of the file
name is dimmed if the terminal allows it.  (To disable this dimming,
turn off File Name Shadow mode with the command
'M-x file-name-shadow-mode'.)

   When completing remote file names (*note Remote Files::), a double
slash behaves slightly differently: it causes Emacs to ignore only the
file-name part, leaving the rest (method, host and username, etc.)
intact.  Typing three slashes in a row ignores everything in remote file
names.  *Note (tramp)File name completion::.

   Emacs interprets '~/' as your home directory.  Thus, '~/foo/bar.txt'
specifies a file named 'bar.txt', inside a directory named 'foo', which
is in turn located in your home directory.  In addition, '~USER-ID/'
means the home directory of a user whose login name is USER-ID.  Any
leading directory name in front of the '~' is ignored: thus,
'/u2/emacs/~/foo/bar.txt' is equivalent to '~/foo/bar.txt'.

   On MS-Windows and MS-DOS systems, where a user doesn't always have a
home directory, Emacs uses several alternatives.  For MS-Windows, see
*note Windows HOME::; for MS-DOS, see *note MS-DOS File Names::.  On
these systems, the '~USER-ID/' construct is supported only for the
current user, i.e., only if USER-ID is the current user's login name.

   To prevent Emacs from inserting the default directory when reading
file names, change the variable 'insert-default-directory' to 'nil'.  In
that case, the minibuffer starts out empty.  Nonetheless, relative file
name arguments are still interpreted based on the same default
directory.

   You can also enter remote file names in the minibuffer.  *Note Remote
Files::.

==============================================================================
File: emacs.info,  Node: |Minibuffer_Edit|,  Next: |Completion|,  Prev: |Minibuffer_File|,  Up: |Minibuffer|
==============================================================================

                                                               *Minibuffer_Edit*

8.3 Editing in the Minibuffer
-----------------------------

The minibuffer is an Emacs buffer, albeit a peculiar one, and the usual
Emacs commands are available for editing the argument text.  (The
prompt, however, is "read-only", and cannot be changed.)

   Since <RET> in the minibuffer submits the argument, you can't use it
to insert a newline.  You can do that with 'C-q C-j', which inserts a
'C-j' control character, which is formally equivalent to a newline
character (*note Inserting Text::).  Alternatively, you can use the
'C-o' ('open-line') command (*note Blank Lines::).

   Inside a minibuffer, the keys <TAB>, <SPC>, and '?' are often bound
to "completion commands", which allow you to easily fill in the desired
text without typing all of it.  *Note Completion::.  As with <RET>, you
can use 'C-q' to insert a <TAB>, <SPC>, or '?' character.

   For convenience, 'C-a' ('move-beginning-of-line') in a minibuffer
moves point to the beginning of the argument text, not the beginning of
the prompt.  For example, this allows you to erase the entire argument
with 'C-a C-k'.

   When the minibuffer is active, the echo area is treated much like an
ordinary Emacs window.  For instance, you can switch to another window
(with 'C-x o'), edit text there, then return to the minibuffer window to
finish the argument.  You can even kill text in another window, return
to the minibuffer window, and yank the text into the argument.  There
are some restrictions on the minibuffer window, however: for instance,
you cannot split it.  *Note Windows::.

   Normally, the minibuffer window occupies a single screen line.
However, if you add two or more lines' worth of text into the
minibuffer, it expands automatically to accommodate the text.  The
variable 'resize-mini-windows' controls the resizing of the minibuffer.
The default value is 'grow-only', which means the behavior we have just
described.  If the value is 't', the minibuffer window will also shrink
automatically if you remove some lines of text from the minibuffer, down
to a minimum of one screen line.  If the value is 'nil', the minibuffer
window never changes size automatically, but you can use the usual
window-resizing commands on it (*note Windows::).

   The variable 'max-mini-window-height' controls the maximum height for
resizing the minibuffer window.  A floating-point number specifies a
fraction of the frame's height; an integer specifies the maximum number
of lines; 'nil' means do not resize the minibuffer window automatically.
The default value is 0.25.

   The 'C-M-v' command in the minibuffer scrolls the help text from
commands that display help text of any sort in another window.  You can
also scroll the help text with 'M-<PageUp>' and 'M-<PageDown>' (or,
equivalently, 'M-<prior>' and 'M-<next>').  This is especially useful
with long lists of possible completions.  *Note Other Window::.

   Emacs normally disallows most commands that use the minibuffer while
the minibuffer is active.  To allow such commands in the minibuffer, set
the variable 'enable-recursive-minibuffers' to 't'.  You might need also
to enable 'minibuffer-depth-indicate-mode' to show the current recursion
depth in the minibuffer prompt on recursive use of the minibuffer.

   When not active, the minibuffer is in 'minibuffer-inactive-mode', and
clicking 'mouse-1' there shows the 'Messages' buffer.  If you use a
dedicated frame for minibuffers, Emacs also recognizes certain keys
there, for example, 'n' to make a new frame.

==============================================================================
File: emacs.info,  Node: |Completion|,  Next: |Minibuffer_History|,  Prev: |Minibuffer_Edit|,  Up: |Minibuffer|
==============================================================================

                                                                    *Completion*

8.4 Completion
--------------

You can often use a feature called "completion" to help enter arguments.
This means that after you type part of the argument, Emacs can fill in
the rest, or some of it, based on what was typed so far.

   When completion is available, certain keys (usually <TAB>, <RET>, and
<SPC>) are rebound in the minibuffer to special completion commands
(*note Completion Commands::).  These commands attempt to complete the
text in the minibuffer, based on a set of "completion alternatives"
provided by the command that requested the argument.  You can usually
type '?' to see a list of completion alternatives.

   Although completion is usually done in the minibuffer, the feature is
sometimes available in ordinary buffers too.  *Note Symbol Completion::.

MENU

* |Completion_Example|::       Examples of using completion.
* |Completion_Commands|::      A list of completion commands.
* |Completion_Exit|::          Completion and minibuffer text submission.
* |Completion_Styles|::        How completion matches are chosen.
* |Completion_Options|::       Options for completion.

==============================================================================
File: emacs.info,  Node: |Completion_Example|,  Next: |Completion_Commands|,  Up: |Completion|
==============================================================================

                                                            *Completion_Example*

8.4.1 Completion Example
------------------------

A simple example may help here.  'M-x' uses the minibuffer to read the
name of a command, so completion works by matching the minibuffer text
against the names of existing Emacs commands.  Suppose you wish to run
the command 'auto-fill-mode'.  You can do that by typing 'M-x
auto-fill-mode <RET>', but it is easier to use completion.

   If you type 'M-x a u <TAB>', the <TAB> looks for completion
alternatives (in this case, command names) that start with 'au'.  There
are several, including 'auto-fill-mode' and 'autoconf-mode', but they
all begin with 'auto', so the 'au' in the minibuffer completes to
'auto'.  (More commands may be defined in your Emacs session.  For
example, if a command called 'authorize-me' was defined, Emacs could
only complete as far as 'aut'.)

   If you type <TAB> again immediately, it cannot determine the next
character; it could be '-', 'a', or 'c'.  So it does not add any
characters; instead, <TAB> displays a list of all possible completions
in another window.

   Next, type '-f'.  The minibuffer now contains 'auto-f', and the only
command name that starts with this is 'auto-fill-mode'.  If you now type
<TAB>, completion fills in the rest of the argument 'auto-fill-mode'
into the minibuffer.

   Hence, typing just 'a u <TAB> - f <TAB>' allows you to enter
'auto-fill-mode'.

==============================================================================
File: emacs.info,  Node: |Completion_Commands|,  Next: |Completion_Exit|,  Prev: |Completion_Example|,  Up: |Completion|
==============================================================================

                                                           *Completion_Commands*

8.4.2 Completion Commands
-------------------------

Here is a list of the completion commands defined in the minibuffer when
completion is allowed.

'<TAB>'
     Complete the text in the minibuffer as much as possible; if unable
     to complete, display a list of possible completions
     ('minibuffer-complete').
'<SPC>'
     Complete up to one word from the minibuffer text before point
     ('minibuffer-complete-word').  This command is not available for
     arguments that often include spaces, such as file names.
'<RET>'
     Submit the text in the minibuffer as the argument, possibly
     completing first ('minibuffer-complete-and-exit').  *Note
     Completion Exit::.
'?'
     Display a list of completions ('minibuffer-completion-help').

   <TAB> ('minibuffer-complete') is the most fundamental completion
command.  It searches for all possible completions that match the
existing minibuffer text, and attempts to complete as much as it can.
*Note Completion Styles::, for how completion alternatives are chosen.

   <SPC> ('minibuffer-complete-word') completes like <TAB>, but only up
to the next hyphen or space.  If you have 'auto-f' in the minibuffer and
type <SPC>, it finds that the completion is 'auto-fill-mode', but it
only inserts 'ill-', giving 'auto-fill-'.  Another <SPC> at this point
completes all the way to 'auto-fill-mode'.

   If <TAB> or <SPC> is unable to complete, it displays a list of
matching completion alternatives (if there are any) in another window.
You can display the same list with '?' ('minibuffer-completion-help').
The following commands can be used with the completion list:

'M-v'
'<PageUp>'
'<prior>'
     Typing 'M-v', while in the minibuffer, selects the window showing
     the completion list ('switch-to-completions').  This paves the way
     for using the commands below.  <PageUp> or <prior> does the same.
     You can also select the window in other ways (*note Windows::).

'<RET>'
'mouse-1'
'mouse-2'
     While in the completion list buffer, this chooses the completion at
     point ('choose-completion').

'<TAB>'
'<RIGHT>'
     While in the completion list buffer, these keys move point to the
     following completion alternative ('next-completion').

'<S-TAB>'
'<LEFT>'
     While in the completion list buffer, these keys move point to the
     previous completion alternative ('previous-completion').

'q'
     While in the completion list buffer, this quits the window showing
     it and selects the window showing the minibuffer ('quit-window').

'z'
     While in the completion list buffer, kill it and delete the window
     showing it ('kill-current-buffer').

==============================================================================
File: emacs.info,  Node: |Completion_Exit|,  Next: |Completion_Styles|,  Prev: |Completion_Commands|,  Up: |Completion|
==============================================================================

                                                               *Completion_Exit*

8.4.3 Completion Exit
---------------------

When a command reads an argument using the minibuffer with completion,
it also controls what happens when you type <RET>
('minibuffer-complete-and-exit') to submit the argument.  There are four
types of behavior:

   * "Strict completion" accepts only exact completion matches.  Typing
     <RET> exits the minibuffer only if the minibuffer text is an exact
     match, or completes to one.  Otherwise, Emacs refuses to exit the
     minibuffer; instead it tries to complete, and if no completion can
     be done it momentarily displays '[No match]' after the minibuffer
     text.  (You can still leave the minibuffer by typing 'C-g' to
     cancel the command.)

     An example of a command that uses this behavior is 'M-x', since it
     is meaningless for it to accept a non-existent command name.

   * "Cautious completion" is like strict completion, except <RET> exits
     only if the text is already an exact match.  If the text completes
     to an exact match, <RET> performs that completion but does not exit
     yet; you must type a second <RET> to exit.

     Cautious completion is used for reading file names for files that
     must already exist, for example.

   * "Permissive completion" allows any input; the completion candidates
     are just suggestions.  Typing <RET> does not complete, it just
     submits the argument as you have entered it.

   * "Permissive completion with confirmation" is like permissive
     completion, with an exception: if you typed <TAB> and this
     completed the text up to some intermediate state (i.e., one that is
     not yet an exact completion match), typing <RET> right afterward
     does not submit the argument.  Instead, Emacs asks for confirmation
     by momentarily displaying '[Confirm]' after the text; type <RET>
     again to confirm and submit the text.  This catches a common
     mistake, in which one types <RET> before realizing that <TAB> did
     not complete as far as desired.

     You can tweak the confirmation behavior by customizing the variable
     'confirm-nonexistent-file-or-buffer'.  The default value,
     'after-completion', gives the behavior we have just described.  If
     you change it to 'nil', Emacs does not ask for confirmation,
     falling back on permissive completion.  If you change it to any
     other non-'nil' value, Emacs asks for confirmation whether or not
     the preceding command was <TAB>.

     This behavior is used by most commands that read file names, like
     'C-x C-f', and commands that read buffer names, like 'C-x b'.

==============================================================================
File: emacs.info,  Node: |Completion_Styles|,  Next: |Completion_Options|,  Prev: |Completion_Exit|,  Up: |Completion|
==============================================================================

                                                             *Completion_Styles*

8.4.4 How Completion Alternatives Are Chosen
--------------------------------------------

Completion commands work by narrowing a large list of possible
completion alternatives to a smaller subset that matches what you have
typed in the minibuffer.  In *note Completion Example::, we gave a
simple example of such matching.  The procedure of determining what
constitutes a match is quite intricate.  Emacs attempts to offer
plausible completions under most circumstances.

   Emacs performs completion using one or more "completion styles"--sets
of criteria for matching minibuffer text to completion alternatives.
During completion, Emacs tries each completion style in turn.  If a
style yields one or more matches, that is used as the list of completion
alternatives.  If a style produces no matches, Emacs falls back on the
next style.

   The list variable 'completion-styles' specifies the completion styles
to use.  Each list element is the name of a completion style (a Lisp
symbol).  The default completion styles are (in order):

'basic'
     A matching completion alternative must have the same beginning as
     the text in the minibuffer before point.  Furthermore, if there is
     any text in the minibuffer after point, the rest of the completion
     alternative must contain that text as a substring.

'partial-completion'
     This aggressive completion style divides the minibuffer text into
     words separated by hyphens or spaces, and completes each word
     separately.  (For example, when completing command names, 'em-l-m'
     completes to 'emacs-lisp-mode'.)

     Furthermore, a '*' in the minibuffer text is treated as a
     "wildcard"--it matches any string of characters at the corresponding
     position in the completion alternative.

'emacs22'
     This completion style is similar to 'basic', except that it ignores
     the text in the minibuffer after point.  It is so-named because it
     corresponds to the completion behavior in Emacs 22.

The following additional completion styles are also defined, and you can
add them to 'completion-styles' if you wish (*note Customization::):

'substring'
     A matching completion alternative must contain the text in the
     minibuffer before point, and the text in the minibuffer after
     point, as substrings (in that same order).

     Thus, if the text in the minibuffer is 'foobar', with point between
     'foo' and 'bar', that matches 'AfooBbarC', where A, B, and C can be
     any string including the empty string.

'initials'
     This very aggressive completion style attempts to complete acronyms
     and initialisms.  For example, when completing command names, it
     matches 'lch' to 'list-command-history'.

There is also a very simple completion style called 'emacs21'.  In this
style, if the text in the minibuffer is 'foobar', only matches starting
with 'foobar' are considered.

   You can use different completion styles in different situations, by
setting the variable 'completion-category-overrides'.  For example, the
default setting says to use only 'basic' and 'substring' completion for
buffer names.

==============================================================================
File: emacs.info,  Node: |Completion_Options|,  Prev: |Completion_Styles|,  Up: |Completion|
==============================================================================

                                                            *Completion_Options*

8.4.5 Completion Options
------------------------

Case is significant when completing case-sensitive arguments, such as
command names.  For example, when completing command names, 'AU' does
not complete to 'auto-fill-mode'.  Case differences are ignored when
completing arguments in which case does not matter.

   When completing file names, case differences are ignored if the
variable 'read-file-name-completion-ignore-case' is non-'nil'.  The
default value is 'nil' on systems that have case-sensitive file-names,
such as GNU/Linux; it is non-'nil' on systems that have case-insensitive
file-names, such as Microsoft Windows.  When completing buffer names,
case differences are ignored if the variable
'read-buffer-completion-ignore-case' is non-'nil'; the default is 'nil'.

   When completing file names, Emacs usually omits certain alternatives
that are considered unlikely to be chosen, as determined by the list
variable 'completion-ignored-extensions'.  Each element in the list
should be a string; any file name ending in such a string is ignored as
a completion alternative.  Any element ending in a slash ('/')
represents a subdirectory name.  The standard value of
'completion-ignored-extensions' has several elements including '".o"',
'".elc"', and '"~"'.  For example, if a directory contains 'foo.c' and
'foo.elc', 'foo' completes to 'foo.c'.  However, if _all_ possible
completions end in otherwise-ignored strings, they are not ignored: in
the previous example, 'foo.e' completes to 'foo.elc'.  Emacs disregards
'completion-ignored-extensions' when showing completion alternatives in
the completion list.

   Shell completion is an extended version of filename completion, *note
Shell Options::.

   If 'completion-auto-help' is set to 'nil', the completion commands
never display the completion list buffer; you must type '?' to display
the list.  If the value is 'lazy', Emacs only shows the completion list
buffer on the second attempt to complete.  In other words, if there is
nothing to complete, the first <TAB> echoes 'Next char not unique'; the
second <TAB> shows the completion list buffer.

   If 'completion-cycle-threshold' is non-'nil', completion commands can
cycle through completion alternatives.  Normally, if there is more than
one completion alternative for the text in the minibuffer, a completion
command completes up to the longest common substring.  If you change
'completion-cycle-threshold' to 't', the completion command instead
completes to the first of those completion alternatives; each subsequent
invocation of the completion command replaces that with the next
completion alternative, in a cyclic manner.  If you give
'completion-cycle-threshold' a numeric value N, completion commands
switch to this cycling behavior only when there are N or fewer
alternatives.

==============================================================================
File: emacs.info,  Node: |Minibuffer_History|,  Next: |Repetition|,  Prev: |Completion|,  Up: |Minibuffer|
==============================================================================

                                                            *Minibuffer_History*

8.5 Minibuffer History
----------------------

Every argument that you enter with the minibuffer is saved in a
"minibuffer history list" so you can easily use it again later.  You can
use the following arguments to quickly fetch an earlier argument into
the minibuffer:

'M-p'
     Move to the previous item in the minibuffer history, an earlier
     argument ('previous-history-element').
'M-n'
     Move to the next item in the minibuffer history
     ('next-history-element').
'<UP>'
'<DOWN>'
     Like 'M-p' and 'M-n', but move to the previous or next line of a
     multi-line item before going to the previous history item
     ('previous-line-or-history-element' and
     'next-line-or-history-element') .
'M-r REGEXP <RET>'
     Move to an earlier item in the minibuffer history that matches
     REGEXP ('previous-matching-history-element').
'M-s REGEXP <RET>'
     Move to a later item in the minibuffer history that matches REGEXP
     ('next-matching-history-element').

   While in the minibuffer, 'M-p' ('previous-history-element') moves
through the minibuffer history list, one item at a time.  Each 'M-p'
fetches an earlier item from the history list into the minibuffer,
replacing its existing contents.  Typing 'M-n' ('next-history-element')
moves through the minibuffer history list in the opposite direction,
fetching later entries into the minibuffer.

   If you type 'M-n' in the minibuffer when there are no later entries
in the minibuffer history (e.g., if you haven't previously typed 'M-p'),
Emacs tries fetching from a list of default arguments: values that you
are likely to enter.  You can think of this as moving through the
"future history".

   The "future history" for file names includes several possible
alternatives you may find useful, such as the file name or the URL at
point in the current buffer.  The defaults put into the "future history"
in this case are controlled by the functions mentioned in the value of
the option 'file-name-at-point-functions'.  By default, its value
invokes the 'ffap' package (*note FFAP::), which tries to guess the
default file or URL from the text around point.  To disable this
guessing, customize the option to a 'nil' value, then the "future
history" of file names will include only the file, if any, visited by
the current buffer, and the default directory.

   The arrow keys '<UP>' and '<DOWN>' work like 'M-p' and 'M-n', but if
the current history item is longer than a single line, they allow you to
move to the previous or next line of the current history item before
going to the previous or next history item.

   If you edit the text inserted by the 'M-p' or 'M-n' minibuffer
history commands, this does not change its entry in the history list.
However, the edited argument does go at the end of the history list when
you submit it.

   You can use 'M-r' ('previous-matching-history-element') to search
through older elements in the history list, and 'M-s'
('next-matching-history-element') to search through newer entries.  Each
of these commands asks for a "regular expression" as an argument, and
fetches the first matching entry into the minibuffer.  *Note Regexps::,
for an explanation of regular expressions.  A numeric prefix argument N
means to fetch the Nth matching entry.  These commands are unusual, in
that they use the minibuffer to read the regular expression argument,
even though they are invoked from the minibuffer.  An upper-case letter
in the regular expression makes the search case-sensitive (*note Lax
Search::).

   You can also search through the history using an incremental search.
*Note Isearch Minibuffer::.

   Emacs keeps separate history lists for several different kinds of
arguments.  For example, there is a list for file names, used by all the
commands that read file names.  Other history lists include buffer
names, command names (used by 'M-x'), and command arguments (used by
commands like 'query-replace').

   The variable 'history-length' specifies the maximum length of a
minibuffer history list; adding a new element deletes the oldest element
if the list gets too long.  If the value is 't', there is no maximum
length.

   The variable 'history-delete-duplicates' specifies whether to delete
duplicates in history.  If it is non-'nil', adding a new element deletes
from the list all other elements that are equal to it.  The default is
'nil'.

==============================================================================
File: emacs.info,  Node: |Repetition|,  Next: |Passwords|,  Prev: |Minibuffer_History|,  Up: |Minibuffer|
==============================================================================

                                                                    *Repetition*

8.6 Repeating Minibuffer Commands
---------------------------------

Every command that uses the minibuffer once is recorded on a special
history list, the "command history", together with the values of its
arguments, so that you can repeat the entire command.  In particular,
every use of 'M-x' is recorded there, since 'M-x' uses the minibuffer to
read the command name.

'C-x <ESC> <ESC>'
     Re-execute a recent minibuffer command from the command history
     ('repeat-complex-command').
'M-x list-command-history'
     Display the entire command history, showing all the commands 'C-x
     <ESC> <ESC>' can repeat, most recent first.

   'C-x <ESC> <ESC>' re-executes a recent command that used the
minibuffer.  With no argument, it repeats the last such command.  A
numeric argument specifies which command to repeat; 1 means the last
one, 2 the previous, and so on.

   'C-x <ESC> <ESC>' works by turning the previous command into a Lisp
expression and then entering a minibuffer initialized with the text for
that expression.  Even if you don't know Lisp, it will probably be
obvious which command is displayed for repetition.  If you type just
<RET>, that repeats the command unchanged.  You can also change the
command by editing the Lisp expression before you execute it.  The
executed command is added to the front of the command history unless it
is identical to the most recent item.

   Once inside the minibuffer for 'C-x <ESC> <ESC>', you can use the
usual minibuffer history commands (*note Minibuffer History::) to move
through the history list.  After finding the desired previous command,
you can edit its expression as usual and then execute it by typing
<RET>.

   Incremental search does not, strictly speaking, use the minibuffer.
Therefore, although it behaves like a complex command, it normally does
not appear in the history list for 'C-x <ESC> <ESC>'.  You can make
incremental search commands appear in the history by setting
'isearch-resume-in-command-history' to a non-'nil' value.  *Note
Incremental Search::.

   The list of previous minibuffer-using commands is stored as a Lisp
list in the variable 'command-history'.  Each element is a Lisp
expression that describes one command and its arguments.  Lisp programs
can re-execute a command by calling 'eval' with the 'command-history'
element.

==============================================================================
File: emacs.info,  Node: |Passwords|,  Next: |Yes_or_No_Prompts|,  Prev: |Repetition|,  Up: |Minibuffer|
==============================================================================

                                                                     *Passwords*

8.7 Entering passwords
----------------------

Sometimes, you may need to enter a password into Emacs.  For instance,
when you tell Emacs to visit a file on another machine via a network
protocol such as FTP, you often need to supply a password to gain access
to the machine (*note Remote Files::).

   Entering a password is similar to using a minibuffer.  Emacs displays
a prompt in the echo area (such as 'Password: '); after you type the
required password, press <RET> to submit it.  To prevent others from
seeing your password, every character you type is displayed as a dot
('.') instead of its usual form.

   Most of the features and commands associated with the minibuffer
_cannot_ be used when entering a password.  There is no history or
completion, and you cannot change windows or perform any other action
with Emacs until you have submitted the password.

   While you are typing the password, you may press <DEL> to delete
backwards, removing the last character entered.  'C-u' deletes
everything you have typed so far.  'C-g' quits the password prompt
(*note Quitting::).  'C-y' inserts the current kill into the password
(*note Killing::).  You may type either <RET> or <ESC> to submit the
password.  Any other self-inserting character key inserts the associated
character into the password, and all other input is ignored.

==============================================================================
File: emacs.info,  Node: |Yes_or_No_Prompts|,  Prev: |Passwords|,  Up: |Minibuffer|
==============================================================================

                                                             *Yes_or_No_Prompts*

8.8 Yes or No Prompts
---------------------

An Emacs command may require you to answer a yes-or-no question during
the course of its execution.  Such queries come in two main varieties.

   For the first type of yes-or-no query, the prompt ends with
'(y or n)'.  You answer the query by typing a single key, either 'y' or
'n', which immediately exits the minibuffer and delivers the response.
For example, if you type 'C-x C-w' ('write-file') to save a buffer, and
enter the name of an existing file, Emacs issues a prompt like this:

     File 'foo.el' exists; overwrite? (y or n)

   The second type of yes-or-no query is typically employed if giving
the wrong answer would have serious consequences; it thus features a
longer prompt ending with '(yes or no)'.  For example, if you invoke
'C-x k' ('kill-buffer') on a file-visiting buffer with unsaved changes,
Emacs activates the minibuffer with a prompt like this:

     Buffer foo.el modified; kill anyway? (yes or no)

To answer, you must type 'yes' or 'no' into the minibuffer, followed by
<RET>.

   With both types of yes-or-no query the minibuffer behaves as
described in the previous sections; you can recenter the selected window
with 'C-l', scroll that window ('C-v' or 'PageDown' scrolls forward,
'M-v' or 'PageUp' scrolls backward), switch to another window with 'C-x
o', use the history commands 'M-p' and 'M-n', etc.  Type 'C-g' to
dismiss the query, and quit the minibuffer and the querying command
(*note Quitting::).

==============================================================================
File: emacs.info,  Node: |M_x|,  Next: |Help|,  Prev: |Minibuffer|,  Up: |Top|
==============================================================================

                                                                           *M_x*

9 Running Commands by Name
==========================

Every Emacs command has a name that you can use to run it.  For
convenience, many commands also have key bindings.  You can run those
commands by typing the keys, or run them by name.  Most Emacs commands
have no key bindings, so the only way to run them is by name.  (*Note
Key Bindings::, for how to set up key bindings.)

   By convention, a command name consists of one or more words,
separated by hyphens; for example, 'auto-fill-mode' or 'manual-entry'.
Command names mostly use complete English words to make them easier to
remember.

   To run a command by name, start with 'M-x', type the command name,
then terminate it with <RET>.  'M-x' uses the minibuffer to read the
command name.  The string 'M-x' appears at the beginning of the
minibuffer as a "prompt" to remind you to enter a command name to be
run.  <RET> exits the minibuffer and runs the command.  *Note
Minibuffer::, for more information on the minibuffer.

   You can use completion to enter the command name.  For example, to
invoke the command 'forward-char', you can type

     M-x forward-char <RET>

or

     M-x forw <TAB> c <RET>

Note that 'forward-char' is the same command that you invoke with the
key 'C-f'.  The existence of a key binding does not stop you from
running the command by name.

   When 'M-x' completes on commands, it ignores the commands that are
declared "obsolete"; for these, you will have to type their full name.
Obsolete commands are those for which newer, better alternatives exist,
and which are slated for removal in some future Emacs release.

   To cancel the 'M-x' and not run a command, type 'C-g' instead of
entering the command name.  This takes you back to command level.

   To pass a numeric argument to the command you are invoking with
'M-x', specify the numeric argument before 'M-x'.  The argument value
appears in the prompt while the command name is being read, and finally
'M-x' passes the argument to that command.  For example, to pass the
numeric argument of 42 to the command 'forward-char' you can type 'C-u
42 M-x forward-char <RET>'.

   When the command you run with 'M-x' has a key binding, Emacs mentions
this in the echo area after running the command.  For example, if you
type 'M-x forward-word', the message says that you can run the same
command by typing 'M-f'.  You can turn off these messages by setting the
variable 'suggest-key-bindings' to 'nil'.  The value of
'suggest-key-bindings' can also be a number, in which case Emacs will
show the binding for that many seconds before removing it from display.
The default behavior is to display the binding for 2 seconds.

   Commands that don't have key bindings, can still be invoked after
typing less than their full name at the 'M-x' prompt.  Emacs mentions
such shorthands in the echo area if they are significantly shorter than
the full command name, and 'extended-command-suggest-shorter' is
non-'nil'.  The setting of 'suggest-key-bindings' affects these hints as
well.

   In this manual, when we speak of running a command by name, we often
omit the <RET> that terminates the name.  Thus we might say 'M-x
auto-fill-mode' rather than 'M-x auto-fill-mode <RET>'.  We mention the
<RET> only for emphasis, such as when the command is followed by
arguments.

   'M-x' works by running the command 'execute-extended-command', which
is responsible for reading the name of another command and invoking it.

==============================================================================
File: emacs.info,  Node: |Help|,  Next: |Mark|,  Prev: |M_x|,  Up: |Top|
==============================================================================

                                                                          *Help*

10 Help
=======

Emacs provides a wide variety of help commands, all accessible through
the prefix key 'C-h' (or, equivalently, the function key <F1>).  These
help commands are described in the following sections.  You can also
type 'C-h C-h' to view a list of help commands ('help-for-help').  You
can scroll the list with <SPC> and <DEL>, then type the help command you
want.  To cancel, type 'C-g'.

   Many help commands display their information in a special "help
buffer".  In this buffer, you can type <SPC> and <DEL> to scroll and
type <RET> to follow hyperlinks.  *Note Help Mode::.

   If you are looking for a certain feature, but don't know what it is
called or where to look, we recommend three methods.  First, try an
apropos command, then try searching the manual index, then look in the
FAQ and the package keywords.

'C-h a TOPICS <RET>'
     This searches for commands whose names match the argument TOPICS.
     The argument can be a keyword, a list of keywords, or a regular
     expression (*note Regexps::).  *Note Apropos::.

'C-h i d m emacs <RET> i TOPIC <RET>'
     This searches for TOPIC in the indices of the Emacs Info manual,
     displaying the first match found.  Press ',' to see subsequent
     matches.  You can use a regular expression as TOPIC.

'C-h i d m emacs <RET> s TOPIC <RET>'
     Similar, but searches the _text_ of the manual rather than the
     indices.

'C-h C-f'
     This displays the Emacs FAQ, using Info.

'C-h p'
     This displays the available Emacs packages based on keywords.
     *Note Package Keywords::.

   'C-h' or <F1> mean "help" in various other contexts as well.  For
instance, you can type them after a prefix key to view a list of the
keys that can follow the prefix key.  (You can also use '?' in this
context.  A few prefix keys don't support 'C-h' or '?' in this way,
because they define other meanings for those inputs, but they all
support <F1>.)

MENU

* |Help_Summary|::        Brief list of all Help commands.
* |Key_Help|::            Asking what a key does in Emacs.
* |Name_Help|::           Asking about a command, variable or function name.
* |Apropos|::             Asking what pertains to a given topic.
* |Help_Mode|::           Special features of Help mode and Help buffers.
* |Package_Keywords|::    Finding Lisp libraries by keywords (topics).
* |Language_Help|::       Help relating to international language support.
* |Misc_Help|::           Other help commands.
* |Help_Files|::          Commands to display auxiliary help files.
* |Help_Echo|::           Help on active text and tooltips ("balloon help").

==============================================================================
File: emacs.info,  Node: |Help_Summary|,  Next: |Key_Help|,  Up: |Help|
==============================================================================

                                                                  *Help_Summary*

10.1 Help Summary
-----------------

Here is a summary of help commands for accessing the built-in
documentation.  Most of these are described in more detail in the
following sections.

'C-h a TOPICS <RET>'
     Display a list of commands whose names match TOPICS
     ('apropos-command').  *Note Apropos::.
'C-h b'
     Display all active key bindings; minor mode bindings first, then
     those of the major mode, then global bindings
     ('describe-bindings').  *Note Misc Help::.
'C-h c KEY'
     Show the name of the command that the key sequence KEY is bound to
     ('describe-key-briefly').  Here 'c' stands for "character".  For
     more extensive information on KEY, use 'C-h k'.  *Note Key Help::.
'C-h d TOPICS <RET>'
     Display the commands and variables whose documentation matches
     TOPICS ('apropos-documentation').  *Note Apropos::.
'C-h e'
     Display the 'Messages' buffer ('view-echo-area-messages').  *Note
     Misc Help::.
'C-h f FUNCTION <RET>'
     Display documentation on the Lisp function named FUNCTION
     ('describe-function').  Since commands are Lisp functions, this
     works for commands too.  *Note Name Help::.
'C-h h'
     Display the 'HELLO' file, which shows examples of various character
     sets.
'C-h i'
     Run Info, the GNU documentation browser ('info').  The Emacs manual
     is available in Info.  *Note Misc Help::.
'C-h k KEY'
     Display the name and documentation of the command that KEY runs
     ('describe-key').  *Note Key Help::.
'C-h l'
     Display a description of your last 300 keystrokes ('view-lossage').
     *Note Misc Help::.
'C-h m'
     Display documentation of the current major mode and minor modes
     ('describe-mode').  *Note Misc Help::.
'C-h n'
     Display news of recent Emacs changes ('view-emacs-news').  *Note
     Help Files::.
'C-h o SYMBOL'
     Display documentation of the Lisp symbol named SYMBOL
     ('describe-symbol').  This will show the documentation of all kinds
     of symbols: functions, variables, and faces.  *Note Name Help::.
'C-h p'
     Find packages by topic keyword ('finder-by-keyword').  *Note
     Package Keywords::.  This lists packages using a package menu
     buffer.  *Note Packages::.
'C-h P PACKAGE <RET>'
     Display documentation about the specified package
     ('describe-package').  *Note Package Keywords::.
'C-h r'
     Display the Emacs manual in Info ('info-emacs-manual').
'C-h s'
     Display the contents of the current "syntax table"
     ('describe-syntax').  *Note Misc Help::.  The syntax table says
     which characters are opening delimiters, which are parts of words,
     and so on.  *Note Syntax Tables: (elisp)Syntax Tables, for details.
'C-h t'
     Enter the Emacs interactive tutorial ('help-with-tutorial').
'C-h v VAR <RET>'
     Display the documentation of the Lisp variable VAR
     ('describe-variable').  *Note Name Help::.
'C-h w COMMAND <RET>'
     Show which keys run the command named COMMAND ('where-is').  *Note
     Key Help::.
'C-h C CODING <RET>'
     Describe the coding system CODING ('describe-coding-system').
     *Note Coding Systems::.
'C-h C <RET>'
     Describe the coding systems currently in use.
'C-h F COMMAND <RET>'
     Enter Info and go to the node that documents the Emacs command
     COMMAND ('Info-goto-emacs-command-node').  *Note Name Help::.
'C-h I METHOD <RET>'
     Describe the input method METHOD ('describe-input-method').  *Note
     Select Input Method::.
'C-h K KEY'
     Enter Info and go to the node that documents the key sequence KEY
     ('Info-goto-emacs-key-command-node').  *Note Key Help::.
'C-h L LANGUAGE-ENV <RET>'
     Display information on the character sets, coding systems, and
     input methods used in language environment LANGUAGE-ENV
     ('describe-language-environment').  *Note Language Environments::.
'C-h S SYMBOL <RET>'
     Display the Info documentation on symbol SYMBOL according to the
     programming language you are editing ('info-lookup-symbol').  *Note
     Misc Help::.
'C-h .'
     Display the help message for a special text area, if point is in
     one ('display-local-help').  (These include, for example, links in
     'Help' buffers.)  *Note Help Echo::.

==============================================================================
File: emacs.info,  Node: |Key_Help|,  Next: |Name_Help|,  Prev: |Help_Summary|,  Up: |Help|
==============================================================================

                                                                      *Key_Help*

10.2 Documentation for a Key
----------------------------

The help commands to get information about a key sequence are 'C-h c'
('describe-key-briefly') and 'C-h k' ('describe-key').

   'C-h c KEY' displays in the echo area the name of the command that
KEY is bound to.  For example, 'C-h c C-f' displays 'forward-char'.

   'C-h k KEY' is similar but gives more information: it displays a help
buffer containing the command's "documentation string", which describes
exactly what the command does.

   'C-h K KEY' displays the section of the Emacs manual that describes
the command corresponding to KEY.

   'C-h c', 'C-h k' and 'C-h K' work for any sort of key sequences,
including function keys, menus, and mouse events (except that 'C-h c'
ignores mouse movement events).  For instance, after 'C-h k' you can
select a menu item from the menu bar, to view the documentation string
of the command it runs.

   'C-h w COMMAND <RET>' lists the keys that are bound to COMMAND.  It
displays the list in the echo area.  If it says the command is not on
any key, that means you must use 'M-x' to run it.  'C-h w' runs the
command 'where-is'.

==============================================================================
File: emacs.info,  Node: |Name_Help|,  Next: |Apropos|,  Prev: |Key_Help|,  Up: |Help|
==============================================================================

                                                                     *Name_Help*

10.3 Help by Command or Variable Name
-------------------------------------

'C-h f FUNCTION <RET>' ('describe-function') displays the documentation
of Lisp function FUNCTION, in a window.  Since commands are Lisp
functions, you can use this method to view the documentation of any
command whose name you know.  For example,

     C-h f auto-fill-mode <RET>

displays the documentation of 'auto-fill-mode'.  This is the only way to
get the documentation of a command that is not bound to any key (one
which you would normally run using 'M-x').

   'C-h f' is also useful for Lisp functions that you use in a Lisp
program.  For example, if you have just written the expression
'(make-vector len)' and want to check that you are using 'make-vector'
properly, type 'C-h f make-vector <RET>'.  Because 'C-h f' allows all
function names, not just command names, you may find that some of your
favorite completion abbreviations that work in 'M-x' don't work in 'C-h
f'.  An abbreviation that is unique among command names may not be
unique among all function names.

   If you type 'C-h f <RET>', it describes the function called by the
innermost Lisp expression in the buffer around point, _provided_ that
function name is a valid, defined Lisp function.  (That name appears as
the default while you enter the argument.)  For example, if point is
located following the text '(make-vector (car x)', the innermost list
containing point is the one that starts with '(make-vector', so 'C-h f
<RET>' describes the function 'make-vector'.

   'C-h f' is also useful just to verify that you spelled a function
name correctly.  If the minibuffer prompt for 'C-h f' shows the function
name from the buffer as the default, it means that name is defined as a
Lisp function.  Type 'C-g' to cancel the 'C-h f' command if you don't
really want to view the documentation.

   'C-h v' ('describe-variable') is like 'C-h f' but describes Lisp
variables instead of Lisp functions.  Its default is the Lisp symbol
around or before point, if that is the name of a defined Lisp variable.
*Note Variables::.

   Help buffers that describe Emacs variables and functions normally
have hyperlinks to the corresponding source code, if you have the source
files installed (*note Hyperlinking::).

   To find a command's documentation in a manual, use 'C-h F'
('Info-goto-emacs-command-node').  This knows about various manuals, not
just the Emacs manual, and finds the right one.

   'C-h o' ('describe-symbol') is like 'C-h f' and 'C-h v', but it
describes any symbol, be it a function, a variable, or a face.  If the
symbol has more than one definition, like it has both definition as a
function and as a variable, this command will show the documentation of
all of them, one after the other.

==============================================================================
File: emacs.info,  Node: |Apropos|,  Next: |Help_Mode|,  Prev: |Name_Help|,  Up: |Help|
==============================================================================

                                                                       *Apropos*

10.4 Apropos
------------

The "apropos" commands answer questions like, "What are the commands for
working with files?" More precisely, you specify an "apropos pattern",
which means either a word, a list of words, or a regular expression.

   Each of the following apropos commands reads an apropos pattern in
the minibuffer, searches for items that match the pattern, and displays
the results in a different window.

'C-h a'
     Search for commands ('apropos-command').  With a prefix argument,
     search for noninteractive functions too.

'M-x apropos'
     Search for functions and variables.  Both interactive functions
     (commands) and noninteractive functions can be found by this.

'M-x apropos-user-option'
     Search for user-customizable variables.  With a prefix argument,
     search for non-customizable variables too.

'M-x apropos-variable'
     Search for variables.  With a prefix argument, search for
     customizable variables only.

'M-x apropos-local-variable'
     Search for buffer-local variables.

'M-x apropos-value'
     Search for variables whose values match the specified pattern.
     With a prefix argument, search also for functions with definitions
     matching the pattern, and Lisp symbols with properties matching the
     pattern.

'M-x apropos-local-value'
     Search for buffer-local variables whose values match the specified
     pattern.

'C-h d'
     Search for functions and variables whose documentation strings
     match the specified pattern ('apropos-documentation').

   The simplest kind of apropos pattern is one word.  Anything
containing that word matches the pattern.  Thus, to find commands that
work on files, type 'C-h a file <RET>'.  This displays a list of all
command names that contain 'file', including 'copy-file', 'find-file',
and so on.  Each command name comes with a brief description and a list
of keys you can currently invoke it with.  In our example, it would say
that you can invoke 'find-file' by typing 'C-x C-f'.

   For more information about a function definition, variable or symbol
property listed in an apropos buffer, you can click on it with 'mouse-1'
or 'mouse-2', or move there and type <RET>.

   When you specify more than one word in the apropos pattern, a name
must contain at least two of the words in order to match.  Thus, if you
are looking for commands to kill a chunk of text before point, you could
try 'C-h a kill back backward behind before <RET>'.  The real command
name 'kill-backward' will match that; if there were a command
'kill-text-before', it would also match, since it contains two of the
specified words.

   For even greater flexibility, you can specify a regular expression
(*note Regexps::).  An apropos pattern is interpreted as a regular
expression if it contains any of the regular expression special
characters, '^$*+?.\['.

   Following the conventions for naming Emacs commands, here are some
words that you'll find useful in apropos patterns.  By using them in
'C-h a', you will also get a feel for the naming conventions.

     char, line, word, sentence, paragraph, region, page, sexp, list,
     defun, rect, buffer, frame, window, face, file, dir, register,
     mode, beginning, end, forward, backward, next, previous, up, down,
     search, goto, kill, delete, mark, insert, yank, fill, indent, case,
     change, set, what, list, find, view, describe, default.

   If the variable 'apropos-do-all' is non-'nil', most apropos commands
behave as if they had been given a prefix argument.  There is one
exception: 'apropos-variable' without a prefix argument will always
search for all variables, no matter what the value of 'apropos-do-all'
is.

   By default, all apropos commands except 'apropos-documentation' list
their results in alphabetical order.  If the variable
'apropos-sort-by-scores' is non-'nil', these commands instead try to
guess the relevance of each result, and display the most relevant ones
first.  The 'apropos-documentation' command lists its results in order
of relevance by default; to list them in alphabetical order, change the
variable 'apropos-documentation-sort-by-scores' to 'nil'.

==============================================================================
File: emacs.info,  Node: |Help_Mode|,  Next: |Package_Keywords|,  Prev: |Apropos|,  Up: |Help|
==============================================================================

                                                                     *Help_Mode*

10.5 Help Mode Commands
-----------------------

Help buffers provide the same commands as View mode (*note View Mode::);
for instance, <SPC> scrolls forward, and <DEL> or 'S-<SPC>' scrolls
backward.  A few special commands are also provided:

'<RET>'
     Follow a cross reference at point ('help-follow').
'<TAB>'
     Move point forward to the next hyperlink ('forward-button').
'S-<TAB>'
     Move point back to the previous hyperlink ('backward-button').
'mouse-1'
'mouse-2'
     Follow a hyperlink that you click on.
'C-c C-c'
     Show all documentation about the symbol at point
     ('help-follow-symbol').
'C-c C-f'
'r'
     Go forward to the next help topic ('help-go-forward').
'C-c C-b'
'l'
     Go back to the previous help topic ('help-go-back').

   When a function name, variable name, or face name (*note Faces::)
appears in the documentation in the help buffer, it is normally an
underlined "hyperlink".  To view the associated documentation, move
point there and type <RET> ('help-follow'), or click on the hyperlink
with 'mouse-1' or 'mouse-2'.  Doing so replaces the contents of the help
buffer; to retrace your steps, type 'C-c C-b' or 'l' ('help-go-back').
While retracing your steps, you can go forward by using 'C-c C-f' or 'r'
('help-go-forward').

   A help buffer can also contain hyperlinks to Info manuals, source
code definitions, and URLs (web pages).  The first two are opened in
Emacs, and the third using a web browser via the 'browse-url' command
(*note Browse-URL::).

   In a help buffer, <TAB> ('forward-button') moves point forward to the
next hyperlink, while 'S-<TAB>' ('backward-button') moves point back to
the previous hyperlink.  These commands act cyclically; for instance,
typing <TAB> at the last hyperlink moves back to the first hyperlink.

   To view all documentation about any symbol in the text, move point to
the symbol and type 'C-c C-c' ('help-follow-symbol').  This shows the
documentation for all the meanings of the symbol--as a variable, as a
function, and/or as a face.

==============================================================================
File: emacs.info,  Node: |Package_Keywords|,  Next: |Language_Help|,  Prev: |Help_Mode|,  Up: |Help|
==============================================================================

                                                              *Package_Keywords*

10.6 Keyword Search for Packages
--------------------------------

Most optional features in Emacs are grouped into "packages".  Emacs
contains several hundred built-in packages, and more can be installed
over the network (*note Packages::).

   To make it easier to find packages related to a topic, most packages
are associated with one or more "keywords" based on what they do.  Type
'C-h p' ('finder-by-keyword') to bring up a list of package keywords,
together with a description of what the keywords mean.  To view a list
of packages for a given keyword, type <RET> on that line; this displays
the list of packages in a Package Menu buffer (*note Package Menu::).

   'C-h P' ('describe-package') prompts for the name of a package (*note
Packages::), and displays a help buffer describing the attributes of the
package and the features that it implements.  The buffer lists the
keywords that relate to the package in the form of buttons.  Click on a
button with 'mouse-1' or 'mouse-2' to see the list of other packages
related to that keyword.

==============================================================================
File: emacs.info,  Node: |Language_Help|,  Next: |Misc_Help|,  Prev: |Package_Keywords|,  Up: |Help|
==============================================================================

                                                                 *Language_Help*

10.7 Help for International Language Support
--------------------------------------------

For information on a specific language environment (*note Language
Environments::), type 'C-h L' ('describe-language-environment').  This
displays a help buffer describing the languages supported by the
language environment, and listing the associated character sets, coding
systems, and input methods, as well as some sample text for that
language environment.

   The command 'C-h h' ('view-hello-file') displays the file
'etc/HELLO', which demonstrates various character sets by showing how to
say "hello" in many languages.

   The command 'C-h I' ('describe-input-method') describes an input
method--either a specified input method, or by default the input method
currently in use.  *Note Input Methods::.

   The command 'C-h C' ('describe-coding-system') describes coding
systems--either a specified coding system, or the ones currently in use.
*Note Coding Systems::.

==============================================================================
File: emacs.info,  Node: |Misc_Help|,  Next: |Help_Files|,  Prev: |Language_Help|,  Up: |Help|
==============================================================================

                                                                     *Misc_Help*

10.8 Other Help Commands
------------------------

'C-h i' ('info') runs the Info program, which browses structured
documentation files.  'C-h 4 i' ('info-other-window') does the same, but
shows the Info buffer in another window.  The entire Emacs manual is
available within Info, along with many other manuals for the GNU system.
Type 'h' after entering Info to run a tutorial on using Info.

   With a numeric argument N, 'C-h i' selects the Info buffer
'info<N>'.  This is useful if you want to browse multiple Info manuals
simultaneously.  If you specify just 'C-u' as the prefix argument, 'C-h
i' prompts for the name of a documentation file, so you can browse a
file which doesn't have an entry in the top-level Info menu.

   The help commands 'C-h F FUNCTION <RET>' and 'C-h K KEY', described
above, enter Info and go straight to the documentation of FUNCTION or
KEY.

   When editing a program, if you have an Info version of the manual for
the programming language, you can use 'C-h S' ('info-lookup-symbol') to
find an entry for a symbol (keyword, function or variable) in the proper
manual.  The details of how this command works depend on the major mode.

   If something surprising happens, and you are not sure what you typed,
use 'C-h l' ('view-lossage').  'C-h l' displays your last 300 input
keystrokes and the commands they invoked.  If you see commands that you
are not familiar with, you can use 'C-h k' or 'C-h f' to find out what
they do.

   To review recent echo area messages, use 'C-h e'
('view-echo-area-messages').  This displays the buffer 'Messages',
where those messages are kept.

   Each Emacs major mode typically redefines a few keys and makes other
changes in how editing works.  'C-h m' ('describe-mode') displays
documentation on the current major mode, which normally describes the
commands and features that are changed in this mode, and also its key
bindings.

   'C-h b' ('describe-bindings') and 'C-h s' ('describe-syntax') show
other information about the current environment within Emacs.  'C-h b'
displays a list of all the key bindings now in effect: first the local
bindings of the current minor modes, then the local bindings defined by
the current major mode, and finally the global bindings (*note Key
Bindings::).  'C-h s' displays the contents of the syntax table, with
explanations of each character's syntax (*note Syntax Tables:
(elisp)Syntax Tables.).

   You can get a list of subcommands for a particular prefix key by
typing 'C-h', '?', or <F1> ('describe-prefix-bindings') after the prefix
key.  (There are a few prefix keys for which not all of these keys
work--those that provide their own bindings for that key.  One of these
prefix keys is <ESC>, because '<ESC> C-h' is actually 'C-M-h', which
marks a defun.  However, '<ESC> <F1>' and '<ESC> ?' work fine.)

==============================================================================
File: emacs.info,  Node: |Help_Files|,  Next: |Help_Echo|,  Prev: |Misc_Help|,  Up: |Help|
==============================================================================

                                                                    *Help_Files*

10.9 Help Files
---------------

Apart from the built-in documentation and manuals, Emacs contains
several other files describing topics like copying conditions, release
notes, instructions for debugging and reporting bugs, and so forth.  You
can use the following commands to view these files.  Apart from 'C-h g',
they all have the form 'C-h C-CHAR'.

'C-h C-c'
     Display the rules under which you can copy and redistribute Emacs
     ('describe-copying').
'C-h C-d'
     Display help for debugging Emacs ('view-emacs-debugging').
'C-h C-e'
     Display information about where to get external packages
     ('view-external-packages').
'C-h C-f'
     Display the Emacs frequently-answered-questions list
     ('view-emacs-FAQ').
'C-h g'
     Visit the page (https://www.gnu.org) with information about the GNU
     Project ('describe-gnu-project').
'C-h C-m'
     Display information about ordering printed copies of Emacs manuals
     ('view-order-manuals').
'C-h C-n'
     Display the news, which lists the new features in this version of
     Emacs ('view-emacs-news').
'C-h C-o'
     Display how to order or download the latest version of Emacs and
     other GNU software ('describe-distribution').
'C-h C-p'
     Display the list of known Emacs problems, sometimes with suggested
     workarounds ('view-emacs-problems').
'C-h C-t'
     Display the Emacs to-do list ('view-emacs-todo').
'C-h C-w'
     Display the full details on the complete absence of warranty for
     GNU Emacs ('describe-no-warranty').

==============================================================================
File: emacs.info,  Node: |Help_Echo|,  Prev: |Help_Files|,  Up: |Help|
==============================================================================

                                                                     *Help_Echo*

10.10 Help on Active Text and Tooltips
--------------------------------------

In Emacs, stretches of "active text" (text that does something special
in response to mouse clicks or <RET>) often have associated help text.
This includes hyperlinks in Emacs buffers, as well as parts of the mode
line.  On graphical displays, as well as some text terminals which
support mouse tracking, moving the mouse over the active text displays
the help text as a "tooltip".  *Note Tooltips::.

   On terminals that don't support mouse-tracking, you can display the
help text for active buffer text at point by typing 'C-h .'
('display-local-help').  This shows the help text in the echo area.  To
display help text automatically whenever it is available at point, set
the variable 'help-at-pt-display-when-idle' to 't'.

==============================================================================
File: emacs.info,  Node: |Mark|,  Next: |Killing|,  Prev: |Help|,  Up: |Top|
==============================================================================

                                                                          *Mark*

11 The Mark and the Region
==========================

Many Emacs commands operate on an arbitrary contiguous part of the
current buffer.  To specify the text for such a command to operate on,
you set "the mark" at one end of it, and move point to the other end.
The text between point and the mark is called "the region".  The region
always extends between point and the mark, no matter which one comes
earlier in the text; each time you move point, the region changes.

   Setting the mark at a position in the text also "activates" it.  When
the mark is active, we say also that the region is active; Emacs
indicates its extent by highlighting the text within it, using the
'region' face (*note Face Customization::).

   This is one of the few faces that has the ':extend t' attribute by
default, which implies that the same face is used to highlight the text
and space between end of line and the window border.  To highlight only
the text you could set this attribute to 'nil'.

   After certain non-motion commands, including any command that changes
the text in the buffer, Emacs automatically "deactivates" the mark; this
turns off the highlighting.  You can also explicitly deactivate the mark
at any time, by typing 'C-g' (*note Quitting::).

   The above default behavior is known as Transient Mark mode.
Disabling Transient Mark mode switches Emacs to an alternative behavior,
in which the region is usually not highlighted.  *Note Disabled
Transient Mark::.

   Setting the mark in one buffer has no effect on the marks in other
buffers.  When you return to a buffer with an active mark, the mark is
at the same place as before.  When multiple windows show the same
buffer, they can have different values of point, and thus different
regions, but they all share one common mark position.  *Note Windows::.
Ordinarily, only the selected window highlights its region; however, if
the variable 'highlight-nonselected-windows' is non-'nil', each window
highlights its own region.

   There is another kind of region: the rectangular region.  *Note
Rectangles::.

MENU

* |Setting_Mark|::            Commands to set the mark.
* |Marking_Objects|::         Commands to put region around textual units.
* |Using_Region|::            Summary of ways to operate on contents of the region.
* |Mark_Ring|::               Previous mark positions saved so you can go back there.
* |Global_Mark_Ring|::        Previous mark positions in various buffers.
* |Shift_Selection|::         Using shifted cursor motion keys.
* |Disabled_Transient_Mark|:: Leaving regions unhighlighted by default.

==============================================================================
File: emacs.info,  Node: |Setting_Mark|,  Next: |Marking_Objects|,  Up: |Mark|
==============================================================================

                                                                  *Setting_Mark*

11.1 Setting the Mark
---------------------

Here are some commands for setting the mark:

'C-<SPC>'
     Set the mark at point, and activate it ('set-mark-command').
'C-@'
     The same.
'C-x C-x'
     Set the mark at point, and activate it; then move point where the
     mark used to be ('exchange-point-and-mark').
'Drag-mouse-1'
     Set point and the mark around the text you drag across.
'mouse-3'
     Set the mark at point, then move point to where you click
     ('mouse-save-then-kill').
'Shifted cursor motion keys'
     Set the mark at point if the mark is inactive, then move point.
     *Note Shift Selection::.

   The most common way to set the mark is with 'C-<SPC>'
('set-mark-command')(1).  This sets the mark where point is, and
activates it.  You can then move point away, leaving the mark behind.

   For example, suppose you wish to convert part of the buffer to upper
case.  To accomplish this, go to one end of the desired text, type
'C-<SPC>', and move point until the desired portion of text is
highlighted.  Now type 'C-x C-u' ('upcase-region').  This converts the
text in the region to upper case, and then deactivates the mark.

   Whenever the mark is active, you can deactivate it by typing 'C-g'
(*note Quitting::).  Most commands that operate on the region also
automatically deactivate the mark, like 'C-x C-u' in the above example.

   Instead of setting the mark in order to operate on a region, you can
also use it to remember a position in the buffer (by typing 'C-<SPC>
C-<SPC>'), and later jump back there (by typing 'C-u C-<SPC>').  *Note
Mark Ring::, for details.

   The command 'C-x C-x' ('exchange-point-and-mark') exchanges the
positions of point and the mark.  'C-x C-x' is useful when you are
satisfied with the position of point but want to move the other end of
the region (where the mark is).  Using 'C-x C-x' a second time, if
necessary, puts the mark at the new position with point back at its
original position.  Normally, if the mark is inactive, this command
first reactivates the mark wherever it was last set, to ensure that the
region is left highlighted.  However, if you call it with a prefix
argument, it leaves the mark inactive and the region unhighlighted; you
can use this to jump to the mark in a manner similar to 'C-u C-<SPC>'.

   You can also set the mark with the mouse.  If you press the left
mouse button ('down-mouse-1') and drag the mouse across a range of text,
this sets the mark where you first pressed the mouse button and puts
point where you release it.  Alternatively, clicking the right mouse
button ('mouse-3') sets the mark at point and then moves point to where
you clicked.  *Note Mouse Commands::, for a more detailed description of
these mouse commands.

   Finally, you can set the mark by holding down the shift key while
typing certain cursor motion commands (such as 'S-<RIGHT>', 'S-C-f',
'S-C-n', etc.).  This is called "shift-selection".  It sets the mark at
point before moving point, but only if there is no active mark set via a
previous shift-selection or mouse commands.  The mark set by mouse
commands and by shift-selection behaves slightly differently from the
usual mark: any subsequent unshifted cursor motion command deactivates
it automatically.  For details, see *note Shift Selection::.

   Many commands that insert text, such as 'C-y' ('yank'), set the mark
at the other end of the inserted text, without activating it.  This lets
you easily return to that position (*note Mark Ring::).  You can tell
that a command does this when it shows 'Mark set' in the echo area.

   Under X, every time the active region changes, Emacs saves the text
in the region to the "primary selection".  This lets you insert that
text into other X applications with 'mouse-2' clicks.  *Note Primary
Selection::.

   ---------- Footnotes ----------

   (1) There is no 'C-<SPC>' character in ASCII; usually, typing
'C-<SPC>' on a text terminal gives the character 'C-@'.  This key is
also bound to 'set-mark-command', so unless you are unlucky enough to
have a text terminal that behaves differently, you might as well think
of 'C-@' as 'C-<SPC>'.

==============================================================================
File: emacs.info,  Node: |Marking_Objects|,  Next: |Using_Region|,  Prev: |Setting_Mark|,  Up: |Mark|
==============================================================================

                                                               *Marking_Objects*

11.2 Commands to Mark Textual Objects
-------------------------------------

Here are commands for placing point and the mark around a textual object
such as a word, list, paragraph or page:

'M-@'
     Set mark at the end of the next word ('mark-word').  This does not
     move point.
'C-M-@'
     Set mark after end of following balanced expression ('mark-sexp').
     This does not move point.
'M-h'
     Move point to the beginning of the current paragraph, and set mark
     at the end ('mark-paragraph').
'C-M-h'
     Move point to the beginning of the current defun, and set mark at
     the end ('mark-defun').
'C-x C-p'
     Move point to the beginning of the current page, and set mark at
     the end ('mark-page').
'C-x h'
     Move point to the beginning of the buffer, and set mark at the end
     ('mark-whole-buffer').

   'M-@' ('mark-word') sets the mark at the end of the next word (*note
Words::, for information about words).  Repeated invocations of this
command extend the region by advancing the mark one word at a time.  As
an exception, if the mark is active and located before point, 'M-@'
moves the mark backwards from its current position one word at a time.

   This command also accepts a numeric argument N, which tells it to
advance the mark by N words.  A negative argument -N moves the mark back
by N words.

   Similarly, 'C-M-@' ('mark-sexp') puts the mark at the end of the next
balanced expression (*note Expressions::).  Repeated invocations extend
the region to subsequent expressions, while positive or negative numeric
arguments move the mark forward or backward by the specified number of
expressions.

   The other commands in the above list set both point and mark, so as
to delimit an object in the buffer.  'M-h' ('mark-paragraph') marks
paragraphs (*note Paragraphs::), 'C-M-h' ('mark-defun') marks top-level
definitions (*note Moving by Defuns::), and 'C-x C-p' ('mark-page')
marks pages (*note Pages::).  Repeated invocations again play the same
role, extending the region to consecutive objects; similarly, numeric
arguments specify how many objects to move the mark by.

   'C-x h' ('mark-whole-buffer') sets up the entire buffer as the
region, by putting point at the beginning and the mark at the end.

==============================================================================
File: emacs.info,  Node: |Using_Region|,  Next: |Mark_Ring|,  Prev: |Marking_Objects|,  Up: |Mark|
==============================================================================

                                                                  *Using_Region*

11.3 Operating on the Region
----------------------------

Once you have a region, here are some of the ways you can operate on it:

   * Kill it with 'C-w' (*note Killing::).
   * Copy it to the kill ring with 'M-w' (*note Yanking::).
   * Convert case with 'C-x C-l' or 'C-x C-u' (*note Case::).
   * Undo changes within it using 'C-u C-/' (*note Undo::).
   * Replace text within it using 'M-%' (*note Query Replace::).
   * Indent it with 'C-x <TAB>' or 'C-M-\' (*note Indentation::).
   * Fill it as text with 'M-x fill-region' (*note Filling::).
   * Check the spelling of words within it with 'M-$' (*note
     Spelling::).
   * Evaluate it as Lisp code with 'M-x eval-region' (*note Lisp
     Eval::).
   * Save it in a register with 'C-x r s' (*note Registers::).
   * Save it in a buffer or a file (*note Accumulating Text::).

   Some commands have a default behavior when the mark is inactive, but
operate on the region if the mark is active.  For example, 'M-$'
('ispell-word') normally checks the spelling of the word at point, but
it checks the text in the region if the mark is active (*note
Spelling::).  Normally, such commands use their default behavior if the
region is empty (i.e., if mark and point are at the same position).  If
you want them to operate on the empty region, change the variable
'use-empty-active-region' to 't'.

   As described in *note Erasing::, the <DEL> ('backward-delete-char')
and <Delete> ('delete-forward-char') commands also act this way.  If the
mark is active, they delete the text in the region.  (As an exception,
if you supply a numeric argument N, where N is not one, these commands
delete N characters regardless of whether the mark is active).  If you
change the variable 'delete-active-region' to 'nil', then these commands
don't act differently when the mark is active.  If you change the value
to 'kill', these commands "kill" the region instead of deleting it
(*note Killing::).

   Other commands always operate on the region, and have no default
behavior.  Such commands usually have the word 'region' in their names,
like 'C-w' ('kill-region') and 'C-x C-u' ('upcase-region').  If the mark
is inactive, they operate on the "inactive region"--that is, on the text
between point and the position at which the mark was last set (*note
Mark Ring::).  To disable this behavior, change the variable
'mark-even-if-inactive' to 'nil'.  Then these commands will instead
signal an error if the mark is inactive.

   By default, text insertion occurs normally even if the mark is
active--for example, typing 'a' inserts the character 'a', then
deactivates the mark.  Delete Selection mode, a minor mode, modifies
this behavior: if you enable that mode, then inserting text while the
mark is active causes the text in the region to be deleted first.  To
toggle Delete Selection mode on or off, type 'M-x
delete-selection-mode'.

==============================================================================
File: emacs.info,  Node: |Mark_Ring|,  Next: |Global_Mark_Ring|,  Prev: |Using_Region|,  Up: |Mark|
==============================================================================

                                                                     *Mark_Ring*

11.4 The Mark Ring
------------------

Each buffer remembers previous locations of the mark, in the "mark
ring".  Commands that set the mark also push the old mark onto this
ring.  One of the uses of the mark ring is to remember spots that you
may want to go back to.

'C-<SPC> C-<SPC>'
     Set the mark, pushing it onto the mark ring, without activating it.
'C-u C-<SPC>'
     Move point to where the mark was, and restore the mark from the
     ring of former marks.

   The command 'C-<SPC> C-<SPC>' is handy when you want to use the mark
to remember a position to which you may wish to return.  It pushes the
current point onto the mark ring, without activating the mark (which
would cause Emacs to highlight the region).  This is actually two
consecutive invocations of 'C-<SPC>' ('set-mark-command'); the first
'C-<SPC>' sets the mark, and the second 'C-<SPC>' deactivates it.  (When
Transient Mark mode is off, 'C-<SPC> C-<SPC>' instead activates
Transient Mark mode temporarily; *note Disabled Transient Mark::.)

   To return to a marked position, use 'set-mark-command' with a prefix
argument: 'C-u C-<SPC>'.  This moves point to where the mark was, and
deactivates the mark if it was active.  Each subsequent 'C-u C-<SPC>'
jumps to a prior position stored in the mark ring.  The positions you
move through in this way are not lost; they go to the end of the ring.

   If you set 'set-mark-command-repeat-pop' to non-'nil', then
immediately after you type 'C-u C-<SPC>', you can type 'C-<SPC>' instead
of 'C-u C-<SPC>' to cycle through the mark ring.  By default,
'set-mark-command-repeat-pop' is 'nil'.

   Each buffer has its own mark ring.  All editing commands use the
current buffer's mark ring.  In particular, 'C-u C-<SPC>' always stays
in the same buffer.

   The variable 'mark-ring-max' specifies the maximum number of entries
to keep in the mark ring.  This defaults to 16 entries.  If that many
entries exist and another one is pushed, the earliest one in the list is
discarded.  Repeating 'C-u C-<SPC>' cycles through the positions
currently in the ring.

   If you want to move back to the same place over and over, the mark
ring may not be convenient enough.  If so, you can record the position
in a register for later retrieval (*note Saving Positions in Registers:
Position Registers.).

==============================================================================
File: emacs.info,  Node: |Global_Mark_Ring|,  Next: |Shift_Selection|,  Prev: |Mark_Ring|,  Up: |Mark|
==============================================================================

                                                              *Global_Mark_Ring*

11.5 The Global Mark Ring
-------------------------

In addition to the ordinary mark ring that belongs to each buffer, Emacs
has a single "global mark ring".  Each time you set a mark, this is
recorded in the global mark ring in addition to the current buffer's own
mark ring, if you have switched buffers since the previous mark setting.
Hence, the global mark ring records a sequence of buffers that you have
been in, and, for each buffer, a place where you set the mark.  The
length of the global mark ring is controlled by 'global-mark-ring-max',
and is 16 by default.

   The command 'C-x C-<SPC>' ('pop-global-mark') jumps to the buffer and
position of the latest entry in the global ring.  It also rotates the
ring, so that successive uses of 'C-x C-<SPC>' take you to earlier
buffers and mark positions.

==============================================================================
File: emacs.info,  Node: |Shift_Selection|,  Next: |Disabled_Transient_Mark|,  Prev: |Global_Mark_Ring|,  Up: |Mark|
==============================================================================

                                                               *Shift_Selection*

11.6 Shift Selection
--------------------

If you hold down the shift key while typing a cursor motion command,
this sets the mark before moving point, so that the region extends from
the original position of point to its new position.  This feature is
referred to as "shift-selection".  It is similar to the way text is
selected in other editors.

   The mark set via shift-selection behaves a little differently from
what we have described above.  Firstly, in addition to the usual ways of
deactivating the mark (such as changing the buffer text or typing
'C-g'), the mark is deactivated by any _unshifted_ cursor motion
command.  Secondly, any subsequent _shifted_ cursor motion command
avoids setting the mark anew.  Therefore, a series of shifted cursor
motion commands will continuously adjust the region.

   Shift-selection only works if the shifted cursor motion key is not
already bound to a separate command (*note Customization::).  For
example, if you bind 'S-C-f' to another command, typing 'S-C-f' runs
that command instead of performing a shift-selected version of 'C-f'
('forward-char').

   A mark set via mouse commands behaves the same as a mark set via
shift-selection (*note Setting Mark::).  For example, if you specify a
region by dragging the mouse, you can continue to extend the region
using shifted cursor motion commands.  In either case, any unshifted
cursor motion command deactivates the mark.

   To turn off shift-selection, set 'shift-select-mode' to 'nil'.  Doing
so does not disable setting the mark via mouse commands.

==============================================================================
File: emacs.info,  Node: |Disabled_Transient_Mark|,  Prev: |Shift_Selection|,  Up: |Mark|
==============================================================================

                                                       *Disabled_Transient_Mark*

11.7 Disabling Transient Mark Mode
----------------------------------

The default behavior of the mark and region, in which setting the mark
activates it and highlights the region, is called Transient Mark mode.
This is a minor mode that is enabled by default.  It can be toggled with
'M-x transient-mark-mode', or with the 'Highlight Active Region' menu
item in the 'Options' menu.  Turning it off switches Emacs to an
alternative mode of operation:

   * Setting the mark, with commands like 'C-<SPC>' or 'C-x C-x', does
     not highlight the region.  Therefore, you can't tell by looking
     where the mark is located; you have to remember.

     The usual solution to this problem is to set the mark and then use
     it soon, before you forget where it is.  You can also check where
     the mark is by using 'C-x C-x', which exchanges the positions of
     the point and the mark (*note Setting Mark::).

   * Some commands, which ordinarily act on the region when the mark is
     active, no longer do so.  For example, normally 'M-%'
     ('query-replace') performs replacements within the region, if the
     mark is active.  When Transient Mark mode is off, it always
     operates from point to the end of the buffer.  Commands that act
     this way are identified in their own documentation.

   While Transient Mark mode is off, you can activate it temporarily
using 'C-<SPC> C-<SPC>' or 'C-u C-x C-x'.

'C-<SPC> C-<SPC>'
     Set the mark at point (like plain 'C-<SPC>') and enable Transient
     Mark mode just once, until the mark is deactivated.  (This is not
     really a separate command; you are using the 'C-<SPC>' command
     twice.)

'C-u C-x C-x'
     Exchange point and mark, activate the mark and enable Transient
     Mark mode temporarily, until the mark is next deactivated.  (This
     is the 'C-x C-x' command, 'exchange-point-and-mark', with a prefix
     argument.)

   These commands set or activate the mark, and enable Transient Mark
mode only until the mark is deactivated.  One reason you may want to use
them is that some commands operate on the entire buffer instead of the
region when Transient Mark mode is off.  Enabling Transient Mark mode
momentarily gives you a way to use these commands on the region.

   When you specify a region with the mouse (*note Setting Mark::), or
with shift-selection (*note Shift Selection::), this likewise activates
Transient Mark mode temporarily and highlights the region.

==============================================================================
File: emacs.info,  Node: |Killing|,  Next: |Registers|,  Prev: |Mark|,  Up: |Top|
==============================================================================

                                                                       *Killing*

12 Killing and Moving Text
==========================

In Emacs, "killing" means erasing text and copying it into the "kill
ring".  "Yanking" means bringing text from the kill ring back into the
buffer.  (Some applications use the terms "cutting" and "pasting" for
similar operations.)  The kill ring is so-named because it can be
visualized as a set of blocks of text arranged in a ring, which you can
access in cyclic order.  *Note Kill Ring::.

   Killing and yanking are the most common way to move or copy text
within Emacs.  It is very versatile, because there are commands for
killing many different types of syntactic units.

MENU

* |Deletion_and_Killing|:: Commands that remove text.
* |Yanking|::              Commands that insert text.
* |Cut_and_Paste|::        Clipboard and selections on graphical displays.
* |Accumulating_Text|::    Other methods to add text to the buffer.
* |Rectangles|::           Operating on text in rectangular areas.
* |CUA_Bindings|::         Using 'C-x'/'C-c'/'C-v' to kill and yank.

==============================================================================
File: emacs.info,  Node: |Deletion_and_Killing|,  Next: |Yanking|,  Up: |Killing|
==============================================================================

                                                          *Deletion_and_Killing*

12.1 Deletion and Killing
-------------------------

Most commands which erase text from the buffer save it in the kill ring
(*note Kill Ring::).  These are known as "kill" commands, and their
names normally contain the word 'kill' (e.g., 'kill-line').  The kill
ring stores several recent kills, not just the last one, so killing is a
very safe operation: you don't have to worry much about losing text that
you previously killed.  The kill ring is shared by all buffers, so text
that is killed in one buffer can be yanked into another buffer.

   When you use 'C-/' ('undo') to undo a kill command (*note Undo::),
that brings the killed text back into the buffer, but does not remove it
from the kill ring.

   On graphical displays, killing text also copies it to the system
clipboard.  *Note Cut and Paste::.

   Commands that erase text but do not save it in the kill ring are
known as "delete" commands; their names usually contain the word
'delete'.  These include 'C-d' ('delete-char') and <DEL>
('delete-backward-char'), which delete only one character at a time, and
those commands that delete only spaces or newlines.  Commands that can
erase significant amounts of nontrivial data generally do a kill
operation instead.

   You can also use the mouse to kill and yank.  *Note Cut and Paste::.

MENU

* |Deletion|::            Commands for deleting small amounts of text and
                          blank areas.
* |Killing_by_Lines|::    How to kill entire lines of text at one time.
* |Other_Kill_Commands|:: Commands to kill large regions of text and
                          syntactic units such as words and sentences.
* |Kill_Options|::        Options that affect killing.

==============================================================================
File: emacs.info,  Node: |Deletion|,  Next: |Killing_by_Lines|,  Up: Deletion and Killing
==============================================================================

                                                                      *Deletion*

12.1.1 Deletion
---------------

Deletion means erasing text and not saving it in the kill ring.  For the
most part, the Emacs commands that delete text are those that erase just
one character or only whitespace.

'<DEL>'
'<BACKSPACE>'
     Delete the previous character, or the text in the region if it is
     active ('delete-backward-char').

'<Delete>'
     Delete the next character, or the text in the region if it is
     active ('delete-forward-char').

'C-d'
     Delete the next character ('delete-char').

'M-\'
     Delete spaces and tabs around point ('delete-horizontal-space').
'M-<SPC>'
     Delete spaces and tabs around point, leaving one space
     ('just-one-space').
'C-x C-o'
     Delete blank lines around the current line ('delete-blank-lines').
'M-^'
     Join two lines by deleting the intervening newline, along with any
     indentation following it ('delete-indentation').

   We have already described the basic deletion commands <DEL>
('delete-backward-char'), <delete> ('delete-forward-char'), and 'C-d'
('delete-char').  *Note Erasing::.  With a numeric argument, they delete
the specified number of characters.  If the numeric argument is omitted
or one, <DEL> and <delete> delete all the text in the region if it is
active (*note Using Region::).

   The other delete commands are those that delete only whitespace
characters: spaces, tabs and newlines.  'M-\'
('delete-horizontal-space') deletes all the spaces and tab characters
before and after point.  With a prefix argument, this only deletes
spaces and tab characters before point.  'M-<SPC>' ('just-one-space')
does likewise but leaves a single space before point, regardless of the
number of spaces that existed previously (even if there were none
before).  With a numeric argument N, it leaves N spaces before point if
N is positive; if N is negative, it deletes newlines in addition to
spaces and tabs, leaving -N spaces before point.  The command
'cycle-spacing' acts like a more flexible version of 'just-one-space'.
It does different things if you call it repeatedly in succession.  The
first call acts like 'just-one-space', the next removes all whitespace,
and a third call restores the original whitespace.

   'C-x C-o' ('delete-blank-lines') deletes all blank lines after the
current line.  If the current line is blank, it deletes all blank lines
preceding the current line as well (leaving one blank line, the current
line).  On a solitary blank line, it deletes that line.

   'M-^' ('delete-indentation') joins the current line and the previous
line, by deleting a newline and all surrounding spaces, usually leaving
a single space.  *Note M-^: Indentation.

   The command 'delete-duplicate-lines' searches the region for
identical lines, and removes all but one copy of each.  Normally it
keeps the first instance of each repeated line, but with a 'C-u' prefix
argument it keeps the last.  With a 'C-u C-u' prefix argument, it only
searches for adjacent identical lines.  This is a more efficient mode of
operation, useful when the lines have already been sorted.  With a 'C-u
C-u C-u' prefix argument, it retains repeated blank lines.

==============================================================================
File: emacs.info,  Node: |Killing_by_Lines|,  Next: |Other_Kill_Commands|,  Prev: |Deletion|,  Up: |Deletion_and_Killing|
==============================================================================

                                                              *Killing_by_Lines*

12.1.2 Killing by Lines
-----------------------

'C-k'
     Kill rest of line or one or more lines ('kill-line').
'C-S-backspace'
     Kill an entire line at once ('kill-whole-line')

   The simplest kill command is 'C-k' ('kill-line').  If used at the end
of a line, it kills the line-ending newline character, merging the next
line into the current one (thus, a blank line is entirely removed).
Otherwise, 'C-k' kills all the text from point up to the end of the
line; if point was originally at the beginning of the line, this leaves
the line blank.

   Spaces and tabs at the end of the line are ignored when deciding
which case applies.  As long as point is after the last non-whitespace
character in the line, you can be sure that 'C-k' will kill the newline.
To kill an entire non-blank line, go to the beginning and type 'C-k'
twice.

   In this context, "line" means a logical text line, not a screen line
(*note Continuation Lines::).

   When 'C-k' is given a positive argument N, it kills N lines and the
newlines that follow them (text on the current line before point is not
killed).  With a negative argument -N, it kills N lines preceding the
current line, together with the text on the current line before point.
'C-k' with an argument of zero kills the text before point on the
current line.

   If the variable 'kill-whole-line' is non-'nil', 'C-k' at the very
beginning of a line kills the entire line including the following
newline.  This variable is normally 'nil'.

   'C-S-backspace' ('kill-whole-line') kills a whole line including its
newline, regardless of the position of point within the line.  Note that
many text terminals will prevent you from typing the key sequence
'C-S-backspace'.

==============================================================================
File: emacs.info,  Node: |Other_Kill_Commands|,  Next: |Kill_Options|,  Prev: |Killing_by_Lines|,  Up: |Deletion_and_Killing|
==============================================================================

                                                           *Other_Kill_Commands*

12.1.3 Other Kill Commands
--------------------------

'C-w'
     Kill the region ('kill-region').
'M-w'
     Copy the region into the kill ring ('kill-ring-save').
'M-d'
     Kill the next word ('kill-word').  *Note Words::.
'M-<DEL>'
     Kill one word backwards ('backward-kill-word').
'C-x <DEL>'
     Kill back to beginning of sentence ('backward-kill-sentence').
     *Note Sentences::.
'M-k'
     Kill to the end of the sentence ('kill-sentence').
'C-M-k'
     Kill the following balanced expression ('kill-sexp').  *Note
     Expressions::.
'M-z CHAR'
     Kill through the next occurrence of CHAR ('zap-to-char').
'M-x zap-up-to-char CHAR'
     Kill up to, but not including, the next occurrence of CHAR.

   One of the commonly-used kill commands is 'C-w' ('kill-region'),
which kills the text in the region (*note Mark::).  Similarly, 'M-w'
('kill-ring-save') copies the text in the region into the kill ring
without removing it from the buffer.  If the mark is inactive when you
type 'C-w' or 'M-w', the command acts on the text between point and
where you last set the mark (*note Using Region::).

   Emacs also provides commands to kill specific syntactic units: words,
with 'M-<DEL>' and 'M-d' (*note Words::); balanced expressions, with
'C-M-k' (*note Expressions::); and sentences, with 'C-x <DEL>' and 'M-k'
(*note Sentences::).

   The command 'M-z' ('zap-to-char') combines killing with searching: it
reads a character and kills from point up to (and including) the next
occurrence of that character in the buffer.  A numeric argument acts as
a repeat count; a negative argument means to search backward and kill
text before point.  A history of previously used characters is
maintained and can be accessed via the 'M-p'/'M-n' keystrokes.  This is
mainly useful if the character to be used has to be entered via a
complicated input method.  A similar command 'zap-up-to-char' kills from
point up to, but not including the next occurrence of a character, with
numeric argument acting as a repeat count.

==============================================================================
File: emacs.info,  Node: |Kill_Options|,  Prev: |Other_Kill_Commands|,  Up: |Deletion_and_Killing|
==============================================================================

                                                                  *Kill_Options*

12.1.4 Options for Killing
--------------------------

Some specialized buffers contain "read-only text", which cannot be
modified and therefore cannot be killed.  The kill commands work
specially in a read-only buffer: they move over text and copy it to the
kill ring, without actually deleting it from the buffer.  Normally, they
also beep and display an error message when this happens.  But if you
set the variable 'kill-read-only-ok' to a non-'nil' value, they just
print a message in the echo area to explain why the text has not been
erased.

   If you change the variable 'kill-do-not-save-duplicates' to a
non-'nil' value, identical subsequent kills yield a single kill-ring
entry, without duplication.

==============================================================================
File: emacs.info,  Node: |Yanking|,  Next: |Cut_and_Paste|,  Prev: |Deletion_and_Killing|,  Up: |Killing|
==============================================================================

                                                                       *Yanking*

12.2 Yanking
------------

"Yanking" means reinserting text previously killed.  The usual way to
move or copy text is to kill it and then yank it elsewhere.

'C-y'
     Yank the last kill into the buffer, at point ('yank').
'M-y'
     Replace the text just yanked with an earlier batch of killed text
     ('yank-pop').  *Note Earlier Kills::.
'C-M-w'
     Cause the following command, if it is a kill command, to append to
     the previous kill ('append-next-kill').  *Note Appending Kills::.

   The basic yanking command is 'C-y' ('yank').  It inserts the most
recent kill, leaving the cursor at the end of the inserted text.  It
also sets the mark at the beginning of the inserted text, without
activating the mark; this lets you jump easily to that position, if you
wish, with 'C-u C-<SPC>' (*note Mark Ring::).

   With a plain prefix argument ('C-u C-y'), the command instead leaves
the cursor in front of the inserted text, and sets the mark at the end.
Using any other prefix argument specifies an earlier kill; e.g., 'C-u 4
C-y' reinserts the fourth most recent kill.  *Note Earlier Kills::.

   On graphical displays, 'C-y' first checks if another application has
placed any text in the system clipboard more recently than the last
Emacs kill.  If so, it inserts the clipboard's text instead.  Thus,
Emacs effectively treats "cut" or "copy" clipboard operations performed
in other applications like Emacs kills, except that they are not
recorded in the kill ring.  *Note Cut and Paste::, for details.

MENU

* |Kill_Ring|::           Where killed text is stored.
* |Earlier_Kills|::       Yanking something killed some time ago.
* |Appending_Kills|::     Several kills in a row all yank together.

==============================================================================
File: emacs.info,  Node: |Kill_Ring|,  Next: |Earlier_Kills|,  Up: |Yanking|
==============================================================================

                                                                     *Kill_Ring*

12.2.1 The Kill Ring
--------------------

The "kill ring" is a list of blocks of text that were previously killed.
There is only one kill ring, shared by all buffers, so you can kill text
in one buffer and yank it in another buffer.  This is the usual way to
move text from one buffer to another.  (There are several other methods:
for instance, you could store the text in a register; see *note
Registers::.  *Note Accumulating Text::, for some other ways to move
text around.)

   The maximum number of entries in the kill ring is controlled by the
variable 'kill-ring-max'.  The default is 60.  If you make a new kill
when this limit has been reached, Emacs makes room by deleting the
oldest entry in the kill ring.

   The actual contents of the kill ring are stored in a variable named
'kill-ring'; you can view the entire contents of the kill ring with 'C-h
v kill-ring'.

==============================================================================
File: emacs.info,  Node: |Earlier_Kills|,  Next: |Appending_Kills|,  Prev: |Kill_Ring|,  Up: |Yanking|
==============================================================================

                                                                 *Earlier_Kills*

12.2.2 Yanking Earlier Kills
----------------------------

As explained in *note Yanking::, you can use a numeric argument to 'C-y'
to yank text that is no longer the most recent kill.  This is useful if
you remember which kill ring entry you want.  If you don't, you can use
the 'M-y' ('yank-pop') command to cycle through the possibilities.

   If the previous command was a yank command, 'M-y' takes the text that
was yanked and replaces it with the text from an earlier kill.  So, to
recover the text of the next-to-the-last kill, first use 'C-y' to yank
the last kill, and then use 'M-y' to replace it with the previous kill.
'M-y' is allowed only after a 'C-y' or another 'M-y'.

   You can understand 'M-y' in terms of a last-yank pointer which points
at an entry in the kill ring.  Each time you kill, the last-yank pointer
moves to the newly made entry at the front of the ring.  'C-y' yanks the
entry which the last-yank pointer points to.  'M-y' moves the last-yank
pointer to a different entry, and the text in the buffer changes to
match.  Enough 'M-y' commands can move the pointer to any entry in the
ring, so you can get any entry into the buffer.  Eventually the pointer
reaches the end of the ring; the next 'M-y' loops back around to the
first entry again.

   'M-y' moves the last-yank pointer around the ring, but it does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

   'M-y' can take a numeric argument, which tells it how many entries to
advance the last-yank pointer by.  A negative argument moves the pointer
toward the front of the ring; from the front of the ring, it moves
around to the last entry and continues forward from there.

   Once the text you are looking for is brought into the buffer, you can
stop doing 'M-y' commands and it will stay there.  It's just a copy of
the kill ring entry, so editing it in the buffer does not change what's
in the ring.  As long as no new killing is done, the last-yank pointer
remains at the same place in the kill ring, so repeating 'C-y' will yank
another copy of the same previous kill.

   When you call 'C-y' with a numeric argument, that also sets the
last-yank pointer to the entry that it yanks.

==============================================================================
File: emacs.info,  Node: |Appending_Kills|,  Prev: |Earlier_Kills|,  Up: |Yanking|
==============================================================================

                                                               *Appending_Kills*

12.2.3 Appending Kills
----------------------

Normally, each kill command pushes a new entry onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single 'C-y' yanks all the text as a unit, just
as it was before it was killed.

   Thus, if you want to yank text as a unit, you need not kill all of it
with one command; you can keep killing line after line, or word after
word, until you have killed it all, and you can still get it all back at
once.

   Commands that kill forward from point add onto the end of the
previous killed text.  Commands that kill backward from point add text
onto the beginning.  This way, any sequence of mixed forward and
backward kill commands puts all the killed text into one entry without
rearrangement.  Numeric arguments do not break the sequence of appending
kills.  For example, suppose the buffer contains this text:

     This is a line -!-of sample text.

with point shown by -!-.  If you type 'M-d M-<DEL> M-d M-<DEL>', killing
alternately forward and backward, you end up with 'a line of sample' as
one entry in the kill ring, and 'This is  text.' in the buffer.  (Note
the double space between 'is' and 'text', which you can clean up with
'M-<SPC>' or 'M-q'.)

   Another way to kill the same text is to move back two words with 'M-b
M-b', then kill all four words forward with 'C-u M-d'.  This produces
exactly the same results in the buffer and in the kill ring.  'M-f M-f
C-u M-<DEL>' kills the same text, all going backward; once again, the
result is the same.  The text in the kill ring entry always has the same
order that it had in the buffer before you killed it.

   If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the kill
ring.  But you can force it to combine with the last killed text, by
typing 'C-M-w' ('append-next-kill') right beforehand.  The 'C-M-w' tells
its following command, if it is a kill command, to treat the kill as
part of the sequence of previous kills.  As usual, the kill is appended
to the previous killed text if the command kills forward, and prepended
if the command kills backward.  In this way, you can kill several
separated pieces of text and accumulate them to be yanked back in one
place.

   A kill command following 'M-w' ('kill-ring-save') does not append to
the text that 'M-w' copied into the kill ring.

==============================================================================
File: emacs.info,  Node: |Cut_and_Paste|,  Next: |Accumulating_Text|,  Prev: |Yanking|,  Up: |Killing|
==============================================================================

                                                                 *Cut_and_Paste*

12.3 "Cut and Paste" Operations on Graphical Displays
-----------------------------------------------------

In most graphical desktop environments, you can transfer data (usually
text) between different applications using a system facility called the
"clipboard".  On X, two other similar facilities are available: the
primary selection and the secondary selection.  When Emacs is run on a
graphical display, its kill and yank commands integrate with these
facilities, so that you can easily transfer text between Emacs and other
graphical applications.

   By default, Emacs uses UTF-8 as the coding system for inter-program
text transfers.  If you find that the pasted text is not what you
expected, you can specify another coding system by typing 'C-x <RET> x'
or 'C-x <RET> X'.  You can also request a different data type by
customizing 'x-select-request-type'.  *Note Communication Coding::.

MENU

* |Clipboard|::           How Emacs uses the system clipboard.
* |Primary_Selection|::   The temporarily selected text selection.
* |Secondary_Selection|:: Cutting without altering point and mark.

==============================================================================
File: emacs.info,  Node: |Clipboard|,  Next: |Primary_Selection|,  Up: |Cut_and_Paste|
==============================================================================

                                                                     *Clipboard*

12.3.1 Using the Clipboard
--------------------------

The "clipboard" is the facility that most graphical applications use for
"cutting and pasting".  When the clipboard exists, the kill and yank
commands in Emacs make use of it.

   When you kill some text with a command such as 'C-w' ('kill-region'),
or copy it to the kill ring with a command such as 'M-w'
('kill-ring-save'), that text is also put in the clipboard.

   When an Emacs kill command puts text in the clipboard, the existing
clipboard contents are normally lost.  Optionally, you can change
'save-interprogram-paste-before-kill' to 't'.  Then Emacs will first
save the clipboard to its kill ring, preventing you from losing the old
clipboard data--at the risk of high memory consumption if that data turns
out to be large.

   Yank commands, such as 'C-y' ('yank'), also use the clipboard.  If
another application "owns" the clipboard--i.e., if you cut or copied text
there more recently than your last kill command in Emacs--then Emacs
yanks from the clipboard instead of the kill ring.

   Normally, rotating the kill ring with 'M-y' ('yank-pop') does not
alter the clipboard.  However, if you change 'yank-pop-change-selection'
to 't', then 'M-y' saves the new yank to the clipboard.

   To prevent kill and yank commands from accessing the clipboard,
change the variable 'select-enable-clipboard' to 'nil'.

   Many X desktop environments support a feature called the "clipboard
manager".  If you exit Emacs while it is the current "owner" of the
clipboard data, and there is a clipboard manager running, Emacs
transfers the clipboard data to the clipboard manager so that it is not
lost.  In some circumstances, this may cause a delay when exiting Emacs;
if you wish to prevent Emacs from transferring data to the clipboard
manager, change the variable 'x-select-enable-clipboard-manager' to
'nil'.

   Since strings containing NUL bytes are usually truncated when passed
through the clipboard, Emacs replaces such characters with "\0" before
transferring them to the system's clipboard.

   Prior to Emacs 24, the kill and yank commands used the primary
selection (*note Primary Selection::), not the clipboard.  If you prefer
this behavior, change 'select-enable-clipboard' to 'nil',
'select-enable-primary' to 't', and 'mouse-drag-copy-region' to 't'.  In
this case, you can use the following commands to act explicitly on the
clipboard: 'clipboard-kill-region' kills the region and saves it to the
clipboard; 'clipboard-kill-ring-save' copies the region to the kill ring
and saves it to the clipboard; and 'clipboard-yank' yanks the contents
of the clipboard at point.

==============================================================================
File: emacs.info,  Node: |Primary_Selection|,  Next: |Secondary_Selection|,  Prev: |Clipboard|,  Up: |Cut_and_Paste|
==============================================================================

                                                             *Primary_Selection*

12.3.2 Cut and Paste with Other Window Applications
---------------------------------------------------

Under the X Window System, there exists a "primary selection" containing
the last stretch of text selected in an X application (usually by
dragging the mouse).  Typically, this text can be inserted into other X
applications by 'mouse-2' clicks.  The primary selection is separate
from the clipboard.  Its contents are more fragile; they are overwritten
each time you select text with the mouse, whereas the clipboard is only
overwritten by explicit cut or copy commands.

   Under X, whenever the region is active (*note Mark::), the text in
the region is saved in the primary selection.  This applies regardless
of whether the region was made by dragging or clicking the mouse (*note
Mouse Commands::), or by keyboard commands (e.g., by typing 'C-<SPC>'
and moving point; *note Setting Mark::).

   If you change the variable 'select-active-regions' to 'only', Emacs
saves only temporarily active regions to the primary selection, i.e.,
those made with the mouse or with shift selection (*note Shift
Selection::).  If you change 'select-active-regions' to 'nil', Emacs
avoids saving active regions to the primary selection entirely.

   To insert the primary selection into an Emacs buffer, click 'mouse-2'
('mouse-yank-primary') where you want to insert it.  *Note Mouse
Commands::.

   MS-Windows provides no primary selection, but Emacs emulates it
within a single Emacs session by storing the selected text internally.
Therefore, all the features and commands related to the primary
selection work on Windows as they do on X, for cutting and pasting
within the same session, but not across Emacs sessions or with other
applications.

==============================================================================
File: emacs.info,  Node: |Secondary_Selection|,  Prev: |Primary_Selection|,  Up: |Cut_and_Paste|
==============================================================================

                                                           *Secondary_Selection*

12.3.3 Secondary Selection
--------------------------

In addition to the primary selection, the X Window System provides a
second similar facility known as the "secondary selection".  Nowadays,
few X applications make use of the secondary selection, but you can
access it using the following Emacs commands:

'M-Drag-mouse-1'
     Set the secondary selection, with one end at the place where you
     press down the button, and the other end at the place where you
     release it ('mouse-set-secondary').  The selected text is
     highlighted, using the 'secondary-selection' face, as you drag.
     The window scrolls automatically if you drag the mouse off the top
     or bottom of the window, just like 'mouse-set-region' (*note Mouse
     Commands::).

     This command does not alter the kill ring.

'M-mouse-1'
     Set one endpoint for the "secondary selection"
     ('mouse-start-secondary'); use 'M-mouse-3' to set the other end and
     complete the selection.  This command cancels any existing
     secondary selection, when it starts a new one.

'M-mouse-3'
     Set the secondary selection ('mouse-secondary-save-then-kill'),
     with one end at the position you click 'M-mouse-3', and the other
     at the position specified previously with 'M-mouse-1'.  This also
     puts the selected text in the kill ring.  A second 'M-mouse-3' at
     the same place kills the text selected by the secondary selection
     just made.

'M-mouse-2'
     Insert the secondary selection where you click, placing point at
     the end of the yanked text ('mouse-yank-secondary').

   Double or triple clicking of 'M-mouse-1' operates on words and lines,
much like 'mouse-1'.

   If 'mouse-yank-at-point' is non-'nil', 'M-mouse-2' yanks at point.
Then it does not matter precisely where you click, or even which of the
frame's windows you click on.  *Note Mouse Commands::.

==============================================================================
File: emacs.info,  Node: |Accumulating_Text|,  Next: |Rectangles|,  Prev: |Cut_and_Paste|,  Up: |Killing|
==============================================================================

                                                             *Accumulating_Text*

12.4 Accumulating Text
----------------------

Usually we copy or move text by killing it and yanking it, but there are
other convenient methods for copying one block of text in many places,
or for copying many scattered blocks of text into one place.  Here we
describe the commands to accumulate scattered pieces of text into a
buffer or into a file.

'M-x append-to-buffer'
     Append region to the contents of a specified buffer.
'M-x prepend-to-buffer'
     Prepend region to the contents of a specified buffer.
'M-x copy-to-buffer'
     Copy region into a specified buffer, deleting that buffer's old
     contents.
'M-x insert-buffer'
     Insert the contents of a specified buffer into current buffer at
     point.
'M-x append-to-file'
     Append region to the contents of a specified file, at the end.

   To accumulate text into a buffer, use 'M-x append-to-buffer'.  This
reads a buffer name, then inserts a copy of the region into the buffer
specified.  If you specify a nonexistent buffer, 'append-to-buffer'
creates the buffer.  The text is inserted wherever point is in that
buffer.  If you have been using the buffer for editing, the copied text
goes into the middle of the text of the buffer, starting from wherever
point happens to be at that moment.

   Point in that buffer is left at the end of the copied text, so
successive uses of 'append-to-buffer' accumulate the text in the
specified buffer in the same order as they were copied.  Strictly
speaking, 'append-to-buffer' does not always append to the text already
in the buffer--it appends only if point in that buffer is at the end.
However, if 'append-to-buffer' is the only command you use to alter a
buffer, then point is always at the end.

   'M-x prepend-to-buffer' is just like 'append-to-buffer' except that
point in the other buffer is left before the copied text, so successive
uses of this command add text in reverse order.  'M-x copy-to-buffer' is
similar, except that any existing text in the other buffer is deleted,
so the buffer is left containing just the text newly copied into it.

   The command 'M-x insert-buffer' can be used to retrieve the
accumulated text from another buffer.  This prompts for the name of a
buffer, and inserts a copy of all the text in that buffer into the
current buffer at point, leaving point at the beginning of the inserted
text.  It also adds the position of the end of the inserted text to the
mark ring, without activating the mark.  *Note Buffers::, for background
information on buffers.

   Instead of accumulating text in a buffer, you can append text
directly into a file with 'M-x append-to-file'.  This prompts for a
filename, and adds the text of the region to the end of the specified
file.  The file is changed immediately on disk.

   You should use 'append-to-file' only with files that are _not_ being
visited in Emacs.  Using it on a file that you are editing in Emacs
would change the file behind Emacs's back, which can lead to losing some
of your editing.

   Another way to move text around is to store it in a register.  *Note
Registers::.

==============================================================================
File: emacs.info,  Node: |Rectangles|,  Next: |CUA_Bindings|,  Prev: |Accumulating_Text|,  Up: |Killing|
==============================================================================

                                                                    *Rectangles*

12.5 Rectangles
---------------

"Rectangle" commands operate on rectangular areas of the text: all the
characters between a certain pair of columns, in a certain range of
lines.  Emacs has commands to kill rectangles, yank killed rectangles,
clear them out, fill them with blanks or text, or delete them.
Rectangle commands are useful with text in multicolumn formats, and for
changing text into or out of such formats.

   To specify a rectangle for a command to work on, set the mark at one
corner and point at the opposite corner.  The rectangle thus specified
is called the "region-rectangle".  If point and the mark are in the same
column, the region-rectangle is empty.  If they are in the same line,
the region-rectangle is one line high.

   The region-rectangle is controlled in much the same way as the region
is controlled.  But remember that a given combination of point and mark
values can be interpreted either as a region or as a rectangle,
depending on the command that uses them.

   A rectangular region can also be marked using the mouse: click and
drag 'C-M-mouse-1' from one corner of the rectangle to the opposite.

'C-x r k'
     Kill the text of the region-rectangle, saving its contents as the
     last killed rectangle ('kill-rectangle').
'C-x r M-w'
     Save the text of the region-rectangle as the last killed rectangle
     ('copy-rectangle-as-kill').
'C-x r d'
     Delete the text of the region-rectangle ('delete-rectangle').
'C-x r y'
     Yank the last killed rectangle with its upper left corner at point
     ('yank-rectangle').
'C-x r o'
     Insert blank space to fill the space of the region-rectangle
     ('open-rectangle').  This pushes the previous contents of the
     region-rectangle to the right.
'C-x r N'
     Insert line numbers along the left edge of the region-rectangle
     ('rectangle-number-lines').  This pushes the previous contents of
     the region-rectangle to the right.
'C-x r c'
     Clear the region-rectangle by replacing all of its contents with
     spaces ('clear-rectangle').
'M-x delete-whitespace-rectangle'
     Delete whitespace in each of the lines on the specified rectangle,
     starting from the left edge column of the rectangle.
'C-x r t STRING <RET>'
     Replace rectangle contents with STRING on each line
     ('string-rectangle').
'M-x string-insert-rectangle <RET> STRING <RET>'
     Insert STRING on each line of the rectangle.
'C-x <SPC>'
     Toggle Rectangle Mark mode ('rectangle-mark-mode').  When this mode
     is active, the region-rectangle is highlighted and can be
     shrunk/grown, and the standard kill and yank commands operate on
     it.

   The rectangle operations fall into two classes: commands to erase or
insert rectangles, and commands to make blank rectangles.

   There are two ways to erase the text in a rectangle: 'C-x r d'
('delete-rectangle') to delete the text outright, or 'C-x r k'
('kill-rectangle') to remove the text and save it as the "last killed
rectangle".  In both cases, erasing the region-rectangle is like erasing
the specified text on each line of the rectangle; if there is any
following text on the line, it moves backwards to fill the gap.

   Killing a rectangle is not killing in the usual sense; the rectangle
is not stored in the kill ring, but in a special place that only records
the most recent rectangle killed.  This is because yanking a rectangle
is so different from yanking linear text that different yank commands
have to be used.  Yank-popping is not defined for rectangles.

   'C-x r M-w' ('copy-rectangle-as-kill') is the equivalent of 'M-w' for
rectangles: it records the rectangle as the last killed rectangle,
without deleting the text from the buffer.

   To yank the last killed rectangle, type 'C-x r y' ('yank-rectangle').
The rectangle's first line is inserted at point, the rectangle's second
line is inserted at the same horizontal position one line vertically
below, and so on.  The number of lines affected is determined by the
height of the saved rectangle.

   For example, you can convert two single-column lists into a
double-column list by killing one of the single-column lists as a
rectangle, and then yanking it beside the other list.

   You can also copy rectangles into and out of registers with 'C-x r r
R' and 'C-x r i R'.  *Note Rectangle Registers::.

   There are two commands you can use for making blank rectangles: 'C-x
r c' ('clear-rectangle') blanks out existing text in the
region-rectangle, and 'C-x r o' ('open-rectangle') inserts a blank
vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
