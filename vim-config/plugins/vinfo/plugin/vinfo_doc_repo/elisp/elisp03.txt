     needs to run fast.  Unlike functions defined in Lisp, primitives
     can be modified or added only by changing the C sources and
     recompiling Emacs.  See *note Writing Emacs Primitives::.

"special form"
     A primitive that is like a function but does not evaluate all of
     its arguments in the usual way.  It may evaluate only some of the
     arguments, or may evaluate them in an unusual order, or several
     times.  Examples include 'if', 'and', and 'while'.  *Note Special
     Forms::.

"macro"
     A construct defined in Lisp, which differs from a function in that
     it translates a Lisp expression into another expression which is to
     be evaluated instead of the original expression.  Macros enable
     Lisp programmers to do the sorts of things that special forms can
     do.  *Note Macros::.

"command"
     An object which can be invoked via the 'command-execute' primitive,
     usually due to the user typing in a key sequence "bound" to that
     command.  *Note Interactive Call::.  A command is usually a
     function; if the function is written in Lisp, it is made into a
     command by an 'interactive' form in the function definition (*note
     Defining Commands::).  Commands that are functions can also be
     called from Lisp expressions, just like other functions.

     Keyboard macros (strings and vectors) are commands also, even
     though they are not functions.  *Note Keyboard Macros::.  We say
     that a symbol is a command if its function cell contains a command
     (*note Symbol Components::); such a "named command" can be invoked
     with 'M-x'.

"closure"
     A function object that is much like a lambda expression, except
     that it also encloses an environment of lexical variable bindings.
     *Note Closures::.

"byte-code function"
     A function that has been compiled by the byte compiler.  *Note
     Byte-Code Type::.

"autoload object"
     A place-holder for a real function.  If the autoload object is
     called, Emacs loads the file containing the definition of the real
     function, and then calls the real function.  *Note Autoload::.

   You can use the function 'functionp' to test if an object is a
function:

 -- Function: functionp object
     This function returns 't' if OBJECT is any kind of function, i.e.,
     can be passed to 'funcall'.  Note that 'functionp' returns 't' for
     symbols that are function names, and returns 'nil' for special
     forms.

   It is also possible to find out how many arguments an arbitrary
function expects:

 -- Function: func-arity function
     This function provides information about the argument list of the
     specified FUNCTION.  The returned value is a cons cell of the form
     '(MIN . MAX)', where MIN is the minimum number of arguments, and
     MAX is either the maximum number of arguments, or the symbol 'many'
     for functions with '&rest' arguments, or the symbol 'unevalled' if
     FUNCTION is a special form.

     Note that this function might return inaccurate results in some
     situations, such as the following:

        - Functions defined using 'apply-partially' (*note
          apply-partially: Calling Functions.).

        - Functions that are advised using 'advice-add' (*note Advising
          Named Functions::).

        - Functions that determine the argument list dynamically, as
          part of their code.

Unlike 'functionp', the next three functions do _not_ treat a symbol as
its function definition.

 -- Function: subrp object
     This function returns 't' if OBJECT is a built-in function (i.e., a
     Lisp primitive).

          (subrp 'message)            ; 'message' is a symbol,
               => nil                 ;   not a subr object.
          (subrp (symbol-function 'message))
               => t

 -- Function: byte-code-function-p object
     This function returns 't' if OBJECT is a byte-code function.  For
     example:

          (byte-code-function-p (symbol-function 'next-line))
               => t

 -- Function: subr-arity subr
     This works like 'func-arity', but only for built-in functions and
     without symbol indirection.  It signals an error for non-built-in
     functions.  We recommend to use 'func-arity' instead.

==============================================================================
File: elisp.info,  Node: |Lambda_Expressions|,  Next: |Function_Names|,  Prev: |What_Is_a_Function|,  Up: |Functions|
==============================================================================

                                                            *Lambda_Expressions*

13.2 Lambda Expressions
=====------------------

A lambda expression is a function object written in Lisp.  Here is an
example:

     (lambda (x)
       "Return the hyperbolic cosine of X."
       (* 0.5 (+ (exp x) (exp (- x)))))

In Emacs Lisp, such a list is a valid expression which evaluates to a
function object.

   A lambda expression, by itself, has no name; it is an "anonymous
function".  Although lambda expressions can be used this way (*note
Anonymous Functions::), they are more commonly associated with symbols
to make "named functions" (*note Function Names::).  Before going into
these details, the following subsections describe the components of a
lambda expression and what they do.

MENU

* |Lambda_Components|::           The parts of a lambda expression.
* |Simple_Lambda|::               A simple example.
* |Argument_List|::               Details and special features of argument lists.
* |Function_Documentation|::      How to put documentation in a function.

==============================================================================
File: elisp.info,  Node: |Lambda_Components|,  Next: |Simple_Lambda|,  Up: |Lambda_Expressions|
==============================================================================

                                                             *Lambda_Components*

13.2.1 Components of a Lambda Expression
----------------------------------------

A lambda expression is a list that looks like this:

     (lambda (ARG-VARIABLES...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-DECLARATION]
       BODY-FORMS...)

   The first element of a lambda expression is always the symbol
'lambda'.  This indicates that the list represents a function.  The
reason functions are defined to start with 'lambda' is so that other
lists, intended for other uses, will not accidentally be valid as
functions.

   The second element is a list of symbols--the argument variable names.
This is called the "lambda list".  When a Lisp function is called, the
argument values are matched up against the variables in the lambda list,
which are given local bindings with the values provided.  *Note Local
Variables::.

   The documentation string is a Lisp string object placed within the
function definition to describe the function for the Emacs help
facilities.  *Note Function Documentation::.

   The interactive declaration is a list of the form '(interactive
CODE-STRING)'.  This declares how to provide arguments if the function
is used interactively.  Functions with this declaration are called
"commands"; they can be called using 'M-x' or bound to a key.  Functions
not intended to be called in this way should not have interactive
declarations.  *Note Defining Commands::, for how to write an
interactive declaration.

   The rest of the elements are the "body" of the function: the Lisp
code to do the work of the function (or, as a Lisp programmer would say,
"a list of Lisp forms to evaluate").  The value returned by the function
is the value returned by the last element of the body.

==============================================================================
File: elisp.info,  Node: |Simple_Lambda|,  Next: |Argument_List|,  Prev: |Lambda_Components|,  Up: |Lambda_Expressions|
==============================================================================

                                                                 *Simple_Lambda*

13.2.2 A Simple Lambda Expression Example
-----------------------------------------

Consider the following example:

     (lambda (a b c) (+ a b c))

We can call this function by passing it to 'funcall', like this:

     (funcall (lambda (a b c) (+ a b c))
              1 2 3)

This call evaluates the body of the lambda expression with the variable
'a' bound to 1, 'b' bound to 2, and 'c' bound to 3.  Evaluation of the
body adds these three numbers, producing the result 6; therefore, this
call to the function returns the value 6.

   Note that the arguments can be the results of other function calls,
as in this example:

     (funcall (lambda (a b c) (+ a b c))
              1 (* 2 3) (- 5 4))

This evaluates the arguments '1', '(* 2 3)', and '(- 5 4)' from left to
right.  Then it applies the lambda expression to the argument values 1,
6 and 1 to produce the value 8.

   As these examples show, you can use a form with a lambda expression
as its CAR to make local variables and give them values.  In the old
days of Lisp, this technique was the only way to bind and initialize
local variables.  But nowadays, it is clearer to use the special form
'let' for this purpose (*note Local Variables::).  Lambda expressions
are mainly used as anonymous functions for passing as arguments to other
functions (*note Anonymous Functions::), or stored as symbol function
definitions to produce named functions (*note Function Names::).

==============================================================================
File: elisp.info,  Node: |Argument_List|,  Next: |Function_Documentation|,  Prev: |Simple_Lambda|,  Up: |Lambda_Expressions|
==============================================================================

                                                                 *Argument_List*

13.2.3 Other Features of Argument Lists
---------------------------------------

Our simple sample function, '(lambda (a b c) (+ a b c))', specifies
three argument variables, so it must be called with three arguments: if
you try to call it with only two arguments or four arguments, you get a
'wrong-number-of-arguments' error (*note Errors::).

   It is often convenient to write a function that allows certain
arguments to be omitted.  For example, the function 'substring' accepts
three arguments--a string, the start index and the end index--but the
third argument defaults to the LENGTH of the string if you omit it.  It
is also convenient for certain functions to accept an indefinite number
of arguments, as the functions 'list' and '+' do.

   To specify optional arguments that may be omitted when a function is
called, simply include the keyword '&optional' before the optional
arguments.  To specify a list of zero or more extra arguments, include
the keyword '&rest' before one final argument.

   Thus, the complete syntax for an argument list is as follows:

     (REQUIRED-VARS...
      [&optional [OPTIONAL-VARS...]]
      [&rest [REST-VAR]])

The square brackets indicate that the '&optional' and '&rest' clauses,
and the variables that follow them, are optional.

   A call to the function requires one actual argument for each of the
REQUIRED-VARS.  There may be actual arguments for zero or more of the
OPTIONAL-VARS, and there cannot be any actual arguments beyond that
unless the lambda list uses '&rest'.  In that case, there may be any
number of extra actual arguments.

   If actual arguments for the optional and rest variables are omitted,
then they always default to 'nil'.  There is no way for the function to
distinguish between an explicit argument of 'nil' and an omitted
argument.  However, the body of the function is free to consider 'nil'
an abbreviation for some other meaningful value.  This is what
'substring' does; 'nil' as the third argument to 'substring' means to
use the length of the string supplied.

     Common Lisp note: Common Lisp allows the function to specify what
     default value to use when an optional argument is omitted; Emacs
     Lisp always uses 'nil'.  Emacs Lisp does not support 'supplied-p'
     variables that tell you whether an argument was explicitly passed.

   For example, an argument list that looks like this:

     (a b &optional c d &rest e)

binds 'a' and 'b' to the first two actual arguments, which are required.
If one or two more arguments are provided, 'c' and 'd' are bound to them
respectively; any arguments after the first four are collected into a
list and 'e' is bound to that list.  Thus, if there are only two
arguments, 'c', 'd' and 'e' are 'nil'; if two or three arguments, 'd'
and 'e' are 'nil'; if four arguments or fewer, 'e' is 'nil'.  Note that
exactly five arguments with an explicit 'nil' argument provided for 'e'
will cause that 'nil' argument to be passed as a list with one element,
'(nil)', as with any other single value for 'e'.

   There is no way to have required arguments following optional ones--it
would not make sense.  To see why this must be so, suppose that 'c' in
the example were optional and 'd' were required.  Suppose three actual
arguments are given; which variable would the third argument be for?
Would it be used for the C, or for D?  One can argue for both
possibilities.  Similarly, it makes no sense to have any more arguments
(either required or optional) after a '&rest' argument.

   Here are some examples of argument lists and proper calls:

     (funcall (lambda (n) (1+ n))        ; One required:
              1)                         ; requires exactly one argument.
          => 2
     (funcall (lambda (n &optional n1)   ; One required and one optional:
                (if n1 (+ n n1) (1+ n))) ; 1 or 2 arguments.
              1 2)
          => 3
     (funcall (lambda (n &rest ns)       ; One required and one rest:
                (+ n (apply '+ ns)))     ; 1 or more arguments.
              1 2 3 4 5)
          => 15

==============================================================================
File: elisp.info,  Node: |Function_Documentation|,  Prev: |Argument_List|,  Up: |Lambda_Expressions|
==============================================================================

                                                        *Function_Documentation*

13.2.4 Documentation Strings of Functions
-----------------------------------------

A lambda expression may optionally have a "documentation string" just
after the lambda list.  This string does not affect execution of the
function; it is a kind of comment, but a systematized comment which
actually appears inside the Lisp world and can be used by the Emacs help
facilities.  *Note Documentation::, for how the documentation string is
accessed.

   It is a good idea to provide documentation strings for all the
functions in your program, even those that are called only from within
your program.  Documentation strings are like comments, except that they
are easier to access.

   The first line of the documentation string should stand on its own,
because 'apropos' displays just this first line.  It should consist of
one or two complete sentences that summarize the function's purpose.

   The start of the documentation string is usually indented in the
source file, but since these spaces come before the starting
double-quote, they are not part of the string.  Some people make a
practice of indenting any additional lines of the string so that the
text lines up in the program source.  _That is a mistake._  The
indentation of the following lines is inside the string; what looks nice
in the source code will look ugly when displayed by the help commands.

   You may wonder how the documentation string could be optional, since
there are required components of the function that follow it (the body).
Since evaluation of a string returns that string, without any side
effects, it has no effect if it is not the last form in the body.  Thus,
in practice, there is no confusion between the first form of the body
and the documentation string; if the only body form is a string then it
serves both as the return value and as the documentation.

   The last line of the documentation string can specify calling
conventions different from the actual function arguments.  Write text
like this:

     \(fn ARGLIST)

following a blank line, at the beginning of the line, with no newline
following it inside the documentation string.  (The '\' is used to avoid
confusing the Emacs motion commands.)  The calling convention specified
in this way appears in help messages in place of the one derived from
the actual arguments of the function.

   This feature is particularly useful for macro definitions, since the
arguments written in a macro definition often do not correspond to the
way users think of the parts of the macro call.

   Do not use this feature if you want to deprecate the calling
convention and favor the one you advertise by the above specification.
Instead, use the 'advertised-calling-convention' declaration (*note
Declare Form::) or 'set-advertised-calling-convention' (*note Obsolete
Functions::), because these two will cause the byte compiler emit a
warning message when it compiles Lisp programs which use the deprecated
calling convention.

==============================================================================
File: elisp.info,  Node: |Function_Names|,  Next: |Defining_Functions|,  Prev: |Lambda_Expressions|,  Up: |Functions|
==============================================================================

                                                                *Function_Names*

13.3 Naming a Function
=====-----------------

A symbol can serve as the name of a function.  This happens when the
symbol's "function cell" (*note Symbol Components::) contains a function
object (e.g., a lambda expression).  Then the symbol itself becomes a
valid, callable function, equivalent to the function object in its
function cell.

   The contents of the function cell are also called the symbol's
"function definition".  The procedure of using a symbol's function
definition in place of the symbol is called "symbol function
indirection"; see *note Function Indirection::.  If you have not given a
symbol a function definition, its function cell is said to be "void",
and it cannot be used as a function.

   In practice, nearly all functions have names, and are referred to by
their names.  You can create a named Lisp function by defining a lambda
expression and putting it in a function cell (*note Function Cells::).
However, it is more common to use the 'defun' special form, described in
the next section.  *Note Defining Functions::.

   We give functions names because it is convenient to refer to them by
their names in Lisp expressions.  Also, a named Lisp function can easily
refer to itself--it can be recursive.  Furthermore, primitives can only
be referred to textually by their names, since primitive function
objects (*note Primitive Function Type::) have no read syntax.

   A function need not have a unique name.  A given function object
_usually_ appears in the function cell of only one symbol, but this is
just a convention.  It is easy to store it in several symbols using
'fset'; then each of the symbols is a valid name for the same function.

   Note that a symbol used as a function name may also be used as a
variable; these two uses of a symbol are independent and do not
conflict.  (This is not the case in some dialects of Lisp, like Scheme.)

   By convention, if a function's symbol consists of two names separated
by '--', the function is intended for internal use and the first part
names the file defining the function.  For example, a function named
'vc-git--rev-parse' is an internal function defined in 'vc-git.el'.
Internal-use functions written in C have names ending in '-internal',
e.g., 'bury-buffer-internal'.  Emacs code contributed before 2018 may
follow other internal-use naming conventions, which are being phased
out.

==============================================================================
File: elisp.info,  Node: |Defining_Functions|,  Next: |Calling_Functions|,  Prev: |Function_Names|,  Up: |Functions|
==============================================================================

                                                            *Defining_Functions*

13.4 Defining Functions
=====------------------

We usually give a name to a function when it is first created.  This is
called "defining a function", and we usually do it with the 'defun'
macro.  This section also describes other ways to define a function.

 -- Macro: defun name args [doc] [declare] [interactive] body...
     'defun' is the usual way to define new Lisp functions.  It defines
     the symbol NAME as a function with argument list ARGS and body
     forms given by BODY.  Neither NAME nor ARGS should be quoted.

     DOC, if present, should be a string specifying the function's
     documentation string (*note Function Documentation::).  DECLARE, if
     present, should be a 'declare' form specifying function metadata
     (*note Declare Form::).  INTERACTIVE, if present, should be an
     'interactive' form specifying how the function is to be called
     interactively (*note Interactive Call::).

     The return value of 'defun' is undefined.

     Here are some examples:

          (defun foo () 5)
          (foo)
               => 5

          (defun bar (a &optional b &rest c)
              (list a b c))
          (bar 1 2 3 4 5)
               => (1 2 (3 4 5))
          (bar 1)
               => (1 nil nil)
          (bar)
          error-> Wrong number of arguments.

          (defun capitalize-backwards ()
            "Upcase the last letter of the word at point."
            (interactive)
            (backward-word 1)
            (forward-word 1)
            (backward-char 1)
            (capitalize-word 1))

     Be careful not to redefine existing functions unintentionally.
     'defun' redefines even primitive functions such as 'car' without
     any hesitation or notification.  Emacs does not prevent you from
     doing this, because redefining a function is sometimes done
     deliberately, and there is no way to distinguish deliberate
     redefinition from unintentional redefinition.

 -- Function: defalias name definition &optional doc
     This function defines the symbol NAME as a function, with
     definition DEFINITION (which can be any valid Lisp function).  Its
     return value is _undefined_.

     If DOC is non-'nil', it becomes the function documentation of NAME.
     Otherwise, any documentation provided by DEFINITION is used.

     Internally, 'defalias' normally uses 'fset' to set the definition.
     If NAME has a 'defalias-fset-function' property, however, the
     associated value is used as a function to call in place of 'fset'.

     The proper place to use 'defalias' is where a specific function
     name is being defined--especially where that name appears explicitly
     in the source file being loaded.  This is because 'defalias'
     records which file defined the function, just like 'defun' (*note
     Unloading::).

     By contrast, in programs that manipulate function definitions for
     other purposes, it is better to use 'fset', which does not keep
     such records.  *Note Function Cells::.

   You cannot create a new primitive function with 'defun' or
'defalias', but you can use them to change the function definition of
any symbol, even one such as 'car' or 'x-popup-menu' whose normal
definition is a primitive.  However, this is risky: for instance, it is
next to impossible to redefine 'car' without breaking Lisp completely.
Redefining an obscure function such as 'x-popup-menu' is less dangerous,
but it still may not work as you expect.  If there are calls to the
primitive from C code, they call the primitive's C definition directly,
so changing the symbol's definition will have no effect on them.

   See also 'defsubst', which defines a function like 'defun' and tells
the Lisp compiler to perform inline expansion on it.  *Note Inline
Functions::.

   To undefine a function name, use 'fmakunbound'.  *Note Function
Cells::.

==============================================================================
File: elisp.info,  Node: |Calling_Functions|,  Next: |Mapping_Functions|,  Prev: |Defining_Functions|,  Up: |Functions|
==============================================================================

                                                             *Calling_Functions*

13.5 Calling Functions
=====-----------------

Defining functions is only half the battle.  Functions don't do anything
until you "call" them, i.e., tell them to run.  Calling a function is
also known as "invocation".

   The most common way of invoking a function is by evaluating a list.
For example, evaluating the list '(concat "a" "b")' calls the function
'concat' with arguments '"a"' and '"b"'.  *Note Evaluation::, for a
description of evaluation.

   When you write a list as an expression in your program, you specify
which function to call, and how many arguments to give it, in the text
of the program.  Usually that's just what you want.  Occasionally you
need to compute at run time which function to call.  To do that, use the
function 'funcall'.  When you also need to determine at run time how
many arguments to pass, use 'apply'.

 -- Function: funcall function &rest arguments
     'funcall' calls FUNCTION with ARGUMENTS, and returns whatever
     FUNCTION returns.

     Since 'funcall' is a function, all of its arguments, including
     FUNCTION, are evaluated before 'funcall' is called.  This means
     that you can use any expression to obtain the function to be
     called.  It also means that 'funcall' does not see the expressions
     you write for the ARGUMENTS, only their values.  These values are
     _not_ evaluated a second time in the act of calling FUNCTION; the
     operation of 'funcall' is like the normal procedure for calling a
     function, once its arguments have already been evaluated.

     The argument FUNCTION must be either a Lisp function or a primitive
     function.  Special forms and macros are not allowed, because they
     make sense only when given the unevaluated argument expressions.
     'funcall' cannot provide these because, as we saw above, it never
     knows them in the first place.

     If you need to use 'funcall' to call a command and make it behave
     as if invoked interactively, use 'funcall-interactively' (*note
     Interactive Call::).

          (setq f 'list)
               => list
          (funcall f 'x 'y 'z)
               => (x y z)
          (funcall f 'x 'y '(z))
               => (x y (z))
          (funcall 'and t nil)
          error-> Invalid function: #<subr and>

     Compare these examples with the examples of 'apply'.

 -- Function: apply function &rest arguments
     'apply' calls FUNCTION with ARGUMENTS, just like 'funcall' but with
     one difference: the last of ARGUMENTS is a list of objects, which
     are passed to FUNCTION as separate arguments, rather than a single
     list.  We say that 'apply' "spreads" this list so that each
     individual element becomes an argument.

     'apply' returns the result of calling FUNCTION.  As with 'funcall',
     FUNCTION must either be a Lisp function or a primitive function;
     special forms and macros do not make sense in 'apply'.

          (setq f 'list)
               => list
          (apply f 'x 'y 'z)
          error-> Wrong type argument: listp, z
          (apply '+ 1 2 '(3 4))
               => 10
          (apply '+ '(1 2 3 4))
               => 10

          (apply 'append '((a b c) nil (x y z) nil))
               => (a b c x y z)

     For an interesting example of using 'apply', see *note Definition
     of mapcar::.

   Sometimes it is useful to fix some of the function's arguments at
certain values, and leave the rest of arguments for when the function is
actually called.  The act of fixing some of the function's arguments is
called "partial application" of the function(1).  The result is a new
function that accepts the rest of arguments and calls the original
function with all the arguments combined.

   Here's how to do partial application in Emacs Lisp:

 -- Function: apply-partially func &rest args
     This function returns a new function which, when called, will call
     FUNC with the list of arguments composed from ARGS and additional
     arguments specified at the time of the call.  If FUNC accepts N
     arguments, then a call to 'apply-partially' with 'M < N' arguments
     will produce a new function of 'N - M' arguments.

     Here's how we could define the built-in function '1+', if it didn't
     exist, using 'apply-partially' and '+', another built-in function:

          (defalias '1+ (apply-partially '+ 1)
            "Increment argument by one.")
          (1+ 10)
               => 11

   It is common for Lisp functions to accept functions as arguments or
find them in data structures (especially in hook variables and property
lists) and call them using 'funcall' or 'apply'.  Functions that accept
function arguments are often called "functionals".

   Sometimes, when you call a functional, it is useful to supply a no-op
function as the argument.  Here are two different kinds of no-op
function:

 -- Function: identity argument
     This function returns ARGUMENT and has no side effects.

 -- Function: ignore &rest arguments
     This function ignores any ARGUMENTS and returns 'nil'.

   Some functions are user-visible "commands", which can be called
interactively (usually by a key sequence).  It is possible to invoke
such a command exactly as though it was called interactively, by using
the 'call-interactively' function.  *Note Interactive Call::.

   ---------- Footnotes ----------

   (1) This is related to, but different from "currying", which
transforms a function that takes multiple arguments in such a way that
it can be called as a chain of functions, each one with a single
argument.

==============================================================================
File: elisp.info,  Node: |Mapping_Functions|,  Next: |Anonymous_Functions|,  Prev: |Calling_Functions|,  Up: |Functions|
==============================================================================

                                                             *Mapping_Functions*

13.6 Mapping Functions
=====-----------------

A "mapping function" applies a given function (_not_ a special form or
macro) to each element of a list or other collection.  Emacs Lisp has
several such functions; this section describes 'mapcar', 'mapc',
'mapconcat', and 'mapcan', which map over a list.  *Note Definition of
mapatoms::, for the function 'mapatoms' which maps over the symbols in
an obarray.  *Note Definition of maphash::, for the function 'maphash'
which maps over key/value associations in a hash table.

   These mapping functions do not allow char-tables because a char-table
is a sparse array whose nominal range of indices is very large.  To map
over a char-table in a way that deals properly with its sparse nature,
use the function 'map-char-table' (*note Char-Tables::).

 -- Function: mapcar function sequence
     'mapcar' applies FUNCTION to each element of SEQUENCE in turn, and
     returns a list of the results.

     The argument SEQUENCE can be any kind of sequence except a
     char-table; that is, a list, a vector, a bool-vector, or a string.
     The result is always a list.  The length of the result is the same
     as the length of SEQUENCE.  For example:

          (mapcar 'car '((a b) (c d) (e f)))
               => (a c e)
          (mapcar '1+ [1 2 3])
               => (2 3 4)
          (mapcar 'string "abc")
               => ("a" "b" "c")

          ;; Call each function in 'my-hooks'.
          (mapcar 'funcall my-hooks)

          (defun mapcar* (function &rest args)
            "Apply FUNCTION to successive cars of all ARGS.
          Return the list of results."
            ;; If no list is exhausted,
            (if (not (memq nil args))
                ;; apply function to CARs.
                (cons (apply function (mapcar 'car args))
                      (apply 'mapcar* function
                             ;; Recurse for rest of elements.
                             (mapcar 'cdr args)))))

          (mapcar* 'cons '(a b c) '(1 2 3 4))
               => ((a . 1) (b . 2) (c . 3))

 -- Function: mapcan function sequence
     This function applies FUNCTION to each element of SEQUENCE, like
     'mapcar', but instead of collecting the results into a list, it
     returns a single list with all the elements of the results (which
     must be lists), by altering the results (using 'nconc'; *note
     Rearrangement::).  Like with 'mapcar', SEQUENCE can be of any type
     except a char-table.

          ;; Contrast this:
          (mapcar 'list '(a b c d))
               => ((a) (b) (c) (d))
          ;; with this:
          (mapcan 'list '(a b c d))
               => (a b c d)

 -- Function: mapc function sequence
     'mapc' is like 'mapcar' except that FUNCTION is used for
     side-effects only--the values it returns are ignored, not collected
     into a list.  'mapc' always returns SEQUENCE.

 -- Function: mapconcat function sequence separator
     'mapconcat' applies FUNCTION to each element of SEQUENCE; the
     results, which must be sequences of characters (strings, vectors,
     or lists), are concatenated into a single string return value.
     Between each pair of result sequences, 'mapconcat' inserts the
     characters from SEPARATOR, which also must be a string, or a vector
     or list of characters.  *Note Sequences Arrays Vectors::.

     The argument FUNCTION must be a function that can take one argument
     and returns a sequence of characters: a string, a vector, or a
     list.  The argument SEQUENCE can be any kind of sequence except a
     char-table; that is, a list, a vector, a bool-vector, or a string.

          (mapconcat 'symbol-name
                     '(The cat in the hat)
                     " ")
               => "The cat in the hat"

          (mapconcat (lambda (x) (format "%c" (1+ x)))
                     "HAL-8000"
                     "")
               => "IBM.9111"

==============================================================================
File: elisp.info,  Node: |Anonymous_Functions|,  Next: |Generic_Functions|,  Prev: |Mapping_Functions|,  Up: |Functions|
==============================================================================

                                                           *Anonymous_Functions*

13.7 Anonymous Functions
=====-------------------

Although functions are usually defined with 'defun' and given names at
the same time, it is sometimes convenient to use an explicit lambda
expression--an "anonymous function".  Anonymous functions are valid
wherever function names are.  They are often assigned as variable
values, or as arguments to functions; for instance, you might pass one
as the FUNCTION argument to 'mapcar', which applies that function to
each element of a list (*note Mapping Functions::).  *Note
describe-symbols example::, for a realistic example of this.

   When defining a lambda expression that is to be used as an anonymous
function, you can in principle use any method to construct the list.
But typically you should use the 'lambda' macro, or the 'function'
special form, or the '#'' read syntax:

 -- Macro: lambda args [doc] [interactive] body...
     This macro returns an anonymous function with argument list ARGS,
     documentation string DOC (if any), interactive spec INTERACTIVE (if
     any), and body forms given by BODY.

     Under dynamic binding, this macro effectively makes 'lambda' forms
     self-quoting: evaluating a form whose CAR is 'lambda' yields the
     form itself:

          (lambda (x) (* x x))
               => (lambda (x) (* x x))

     Note that when evaluating under lexical binding the result is a
     closure object (*note Closures::).

     The 'lambda' form has one other effect: it tells the Emacs
     evaluator and byte-compiler that its argument is a function, by
     using 'function' as a subroutine (see below).

 -- Special Form: function function-object
     This special form returns FUNCTION-OBJECT without evaluating it.
     In this, it is similar to 'quote' (*note Quoting::).  But unlike
     'quote', it also serves as a note to the Emacs evaluator and
     byte-compiler that FUNCTION-OBJECT is intended to be used as a
     function.  Assuming FUNCTION-OBJECT is a valid lambda expression,
     this has two effects:

        * When the code is byte-compiled, FUNCTION-OBJECT is compiled
          into a byte-code function object (*note Byte Compilation::).

        * When lexical binding is enabled, FUNCTION-OBJECT is converted
          into a closure.  *Note Closures::.

     When FUNCTION-OBJECT is a symbol and the code is byte compiled, the
     byte-compiler will warn if that function is not defined or might
     not be known at run time.

   The read syntax '#'' is a short-hand for using 'function'.  The
following forms are all equivalent:

     (lambda (x) (* x x))
     (function (lambda (x) (* x x)))
     #'(lambda (x) (* x x))

   In the following example, we define a 'change-property' function that
takes a function as its third argument, followed by a 'double-property'
function that makes use of 'change-property' by passing it an anonymous
function:

     (defun change-property (symbol prop function)
       (let ((value (get symbol prop)))
         (put symbol prop (funcall function value))))

     (defun double-property (symbol prop)
       (change-property symbol prop (lambda (x) (* 2 x))))

Note that we do not quote the 'lambda' form.

   If you compile the above code, the anonymous function is also
compiled.  This would not happen if, say, you had constructed the
anonymous function by quoting it as a list:

     (defun double-property (symbol prop)
       (change-property symbol prop '(lambda (x) (* 2 x))))

In that case, the anonymous function is kept as a lambda expression in
the compiled code.  The byte-compiler cannot assume this list is a
function, even though it looks like one, since it does not know that
'change-property' intends to use it as a function.

==============================================================================
File: elisp.info,  Node: |Generic_Functions|,  Next: |Function_Cells|,  Prev: |Anonymous_Functions|,  Up: |Functions|
==============================================================================

                                                             *Generic_Functions*

13.8 Generic Functions
=====-----------------

Functions defined using 'defun' have a hard-coded set of assumptions
about the types and expected values of their arguments.  For example, a
function that was designed to handle values of its argument that are
either numbers or lists of numbers will fail or signal an error if
called with a value of any other type, such as a vector or a string.
This happens because the implementation of the function is not prepared
to deal with types other than those assumed during the design.

   By contrast, object-oriented programs use "polymorphic functions": a
set of specialized functions having the same name, each one of which was
written for a certain specific set of argument types.  Which of the
functions is actually called is decided at run time based on the types
of the actual arguments.

   Emacs provides support for polymorphism.  Like other Lisp
environments, notably Common Lisp and its Common Lisp Object System
(CLOS), this support is based on "generic functions".  The Emacs generic
functions closely follow CLOS, including use of similar names, so if you
have experience with CLOS, the rest of this section will sound very
familiar.

   A generic function specifies an abstract operation, by defining its
name and list of arguments, but (usually) no implementation.  The actual
implementation for several specific classes of arguments is provided by
"methods", which should be defined separately.  Each method that
implements a generic function has the same name as the generic function,
but the method's definition indicates what kinds of arguments it can
handle by "specializing" the arguments defined by the generic function.
These "argument specializers" can be more or less specific; for example,
a 'string' type is more specific than a more general type, such as
'sequence'.

   Note that, unlike in message-based OO languages, such as C++ and
Simula, methods that implement generic functions don't belong to a
class, they belong to the generic function they implement.

   When a generic function is invoked, it selects the applicable methods
by comparing the actual arguments passed by the caller with the argument
specializers of each method.  A method is applicable if the actual
arguments of the call are compatible with the method's specializers.  If
more than one method is applicable, they are combined using certain
rules, described below, and the combination then handles the call.

 -- Macro: cl-defgeneric name arguments [documentation]
          [options-and-methods...] &rest body
     This macro defines a generic function with the specified NAME and
     ARGUMENTS.  If BODY is present, it provides the default
     implementation.  If DOCUMENTATION is present (it should always be),
     it specifies the documentation string for the generic function, in
     the form '(:documentation DOCSTRING)'.  The optional
     OPTIONS-AND-METHODS can be one of the following forms:

     '(declare DECLARATIONS)'
          A declare form, as described in *note Declare Form::.
     '(:argument-precedence-order &rest ARGS)'
          This form affects the sorting order for combining applicable
          methods.  Normally, when two methods are compared during
          combination, method arguments are examined left to right, and
          the first method whose argument specializer is more specific
          will come before the other one.  The order defined by this
          form overrides that, and the arguments are examined according
          to their order in this form, and not left to right.
     '(:method [QUALIFIERS...] args &rest body)'
          This form defines a method like 'cl-defmethod' does.

 -- Macro: cl-defmethod name [qualifier] arguments [&context (expr
          spec)...] &rest [docstring] body
     This macro defines a particular implementation for the generic
     function called NAME.  The implementation code is given by BODY.
     If present, DOCSTRING is the documentation string for the method.
     The ARGUMENTS list, which must be identical in all the methods that
     implement a generic function, and must match the argument list of
     that function, provides argument specializers of the form '(ARG
     SPEC)', where ARG is the argument name as specified in the
     'cl-defgeneric' call, and SPEC is one of the following specializer
     forms:

     'TYPE'
          This specializer requires the argument to be of the given
          TYPE, one of the types from the type hierarchy described
          below.
     '(eql OBJECT)'
          This specializer requires the argument be 'eql' to the given
          OBJECT.
     '(head OBJECT)'
          The argument must be a cons cell whose 'car' is 'eql' to
          OBJECT.
     'STRUCT-TYPE'
          The argument must be an instance of a class named STRUCT-TYPE
          defined with 'cl-defstruct' (*note (cl)Structures::), or of
          one of its child classes.

     Method definitions can make use of a new argument-list keyword,
     '&context', which introduces extra specializers that test the
     environment at the time the method is run.  This keyword should
     appear after the list of required arguments, but before any '&rest'
     or '&optional' keywords.  The '&context' specializers look much
     like regular argument specializers--(EXPR SPEC)--except that EXPR is
     an expression to be evaluated in the current context, and the SPEC
     is a value to compare against.  For example, '&context
     (overwrite-mode (eql t))' will make the method applicable only when
     'overwrite-mode' is turned on.  The '&context' keyword can be
     followed by any number of context specializers.  Because the
     context specializers are not part of the generic function's
     argument signature, they may be omitted in methods that don't
     require them.

     The type specializer, '(ARG TYPE)', can specify one of the "system
     types" in the following list.  When a parent type is specified, an
     argument whose type is any of its more specific child types, as
     well as grand-children, grand-grand-children, etc.  will also be
     compatible.

     'integer'
          Parent type: 'number'.
     'number'
     'null'
          Parent type: 'symbol'
     'symbol'
     'string'
          Parent type: 'array'.
     'array'
          Parent type: 'sequence'.
     'cons'
          Parent type: 'list'.
     'list'
          Parent type: 'sequence'.
     'marker'
     'overlay'
     'float'
          Parent type: 'number'.
     'window-configuration'
     'process'
     'window'
     'subr'
     'compiled-function'
     'buffer'
     'char-table'
          Parent type: 'array'.
     'bool-vector'
          Parent type: 'array'.
     'vector'
          Parent type: 'array'.
     'frame'
     'hash-table'
     'font-spec'
     'font-entity'
     'font-object'

     The optional QUALIFIER allows combining several applicable methods.
     If it is not present, the defined method is a "primary" method,
     responsible for providing the primary implementation of the generic
     function for the specialized arguments.  You can also define
     "auxiliary methods", by using one of the following values as
     QUALIFIER:

     ':before'
          This auxiliary method will run before the primary method.
          More accurately, all the ':before' methods will run before the
          primary, in the most-specific-first order.
     ':after'
          This auxiliary method will run after the primary method.  More
          accurately, all such methods will run after the primary, in
          the most-specific-last order.
     ':around'
          This auxiliary method will run _instead_ of the primary
          method.  The most specific of such methods will be run before
          any other method.  Such methods normally use
          'cl-call-next-method', described below, to invoke the other
          auxiliary or primary methods.
     ':extra STRING'
          This allows you to add more methods, distinguished by STRING,
          for the same specializers and qualifiers.

     Functions defined using 'cl-defmethod' cannot be made interactive,
     i.e. commands (*note Defining Commands::), by adding the
     'interactive' form to them.  If you need a polymorphic command, we
     recommend defining a normal command that calls a polymorphic
     function defined via 'cl-defgeneric' and 'cl-defmethod'.

   Each time a generic function is called, it builds the "effective
method" which will handle this invocation by combining the applicable
methods defined for the function.  The process of finding the applicable
methods and producing the effective method is called "dispatch".  The
applicable methods are those all of whose specializers are compatible
with the actual arguments of the call.  Since all of the arguments must
be compatible with the specializers, they all determine whether a method
is applicable.  Methods that explicitly specialize more than one
argument are called "multiple-dispatch methods".

   The applicable methods are sorted into the order in which they will
be combined.  The method whose left-most argument specializer is the
most specific one will come first in the order.  (Specifying
':argument-precedence-order' as part of 'cl-defmethod' overrides that,
as described above.)  If the method body calls 'cl-call-next-method',
the next most-specific method will run.  If there are applicable
':around' methods, the most-specific of them will run first; it should
call 'cl-call-next-method' to run any of the less specific ':around'
methods.  Next, the ':before' methods run in the order of their
specificity, followed by the primary method, and lastly the ':after'
methods in the reverse order of their specificity.

 -- Function: cl-call-next-method &rest args
     When invoked from within the lexical body of a primary or an
     ':around' auxiliary method, call the next applicable method for the
     same generic function.  Normally, it is called with no arguments,
     which means to call the next applicable method with the same
     arguments that the calling method was invoked.  Otherwise, the
     specified arguments are used instead.

 -- Function: cl-next-method-p
     This function, when called from within the lexical body of a
     primary or an ':around' auxiliary method, returns non-'nil' if
     there is a next method to call.

==============================================================================
File: elisp.info,  Node: |Function_Cells|,  Next: |Closures|,  Prev: |Generic_Functions|,  Up: |Functions|
==============================================================================

                                                                *Function_Cells*

13.9 Accessing Function Cell Contents
=====--------------------------------

The "function definition" of a symbol is the object stored in the
function cell of the symbol.  The functions described here access, test,
and set the function cell of symbols.

   See also the function 'indirect-function'.  *Note Definition of
indirect-function::.

 -- Function: symbol-function symbol
     This returns the object in the function cell of SYMBOL.  It does
     not check that the returned object is a legitimate function.

     If the function cell is void, the return value is 'nil'.  To
     distinguish between a function cell that is void and one set to
     'nil', use 'fboundp' (see below).

          (defun bar (n) (+ n 2))
          (symbol-function 'bar)
               => (lambda (n) (+ n 2))
          (fset 'baz 'bar)
               => bar
          (symbol-function 'baz)
               => bar

   If you have never given a symbol any function definition, we say that
that symbol's function cell is "void".  In other words, the function
cell does not have any Lisp object in it.  If you try to call the symbol
as a function, Emacs signals a 'void-function' error.

   Note that void is not the same as 'nil' or the symbol 'void'.  The
symbols 'nil' and 'void' are Lisp objects, and can be stored into a
function cell just as any other object can be (and they can be valid
functions if you define them in turn with 'defun').  A void function
cell contains no object whatsoever.

   You can test the voidness of a symbol's function definition with
'fboundp'.  After you have given a symbol a function definition, you can
make it void once more using 'fmakunbound'.

 -- Function: fboundp symbol
     This function returns 't' if the symbol has an object in its
     function cell, 'nil' otherwise.  It does not check that the object
     is a legitimate function.

 -- Function: fmakunbound symbol
     This function makes SYMBOL's function cell void, so that a
     subsequent attempt to access this cell will cause a 'void-function'
     error.  It returns SYMBOL.  (See also 'makunbound', in *note Void
     Variables::.)

          (defun foo (x) x)
          (foo 1)
               =>1
          (fmakunbound 'foo)
               => foo
          (foo 1)
          error-> Symbol's function definition is void: foo

 -- Function: fset symbol definition
     This function stores DEFINITION in the function cell of SYMBOL.
     The result is DEFINITION.  Normally DEFINITION should be a function
     or the name of a function, but this is not checked.  The argument
     SYMBOL is an ordinary evaluated argument.

     The primary use of this function is as a subroutine by constructs
     that define or alter functions, like 'defun' or 'advice-add' (*note
     Advising Functions::).  You can also use it to give a symbol a
     function definition that is not a function, e.g., a keyboard macro
     (*note Keyboard Macros::):

          ;; Define a named keyboard macro.
          (fset 'kill-two-lines "\^u2\^k")
               => "\^u2\^k"

     It you wish to use 'fset' to make an alternate name for a function,
     consider using 'defalias' instead.  *Note Definition of defalias::.

==============================================================================
File: elisp.info,  Node: |Closures|,  Next: |Advising_Functions|,  Prev: |Function_Cells|,  Up: |Functions|
==============================================================================

                                                                      *Closures*

13.10 Closures
=====---------

As explained in *note Variable Scoping::, Emacs can optionally enable
lexical binding of variables.  When lexical binding is enabled, any
named function that you create (e.g., with 'defun'), as well as any
anonymous function that you create using the 'lambda' macro or the
'function' special form or the '#'' syntax (*note Anonymous
Functions::), is automatically converted into a "closure".

   A closure is a function that also carries a record of the lexical
environment that existed when the function was defined.  When it is
invoked, any lexical variable references within its definition use the
retained lexical environment.  In all other respects, closures behave
much like ordinary functions; in particular, they can be called in the
same way as ordinary functions.

   *Note Lexical Binding::, for an example of using a closure.

   Currently, an Emacs Lisp closure object is represented by a list with
the symbol 'closure' as the first element, a list representing the
lexical environment as the second element, and the argument list and
body forms as the remaining elements:

     ;; lexical binding is enabled.
     (lambda (x) (* x x))
          => (closure (t) (x) (* x x))

However, the fact that the internal structure of a closure is exposed to
the rest of the Lisp world is considered an internal implementation
detail.  For this reason, we recommend against directly examining or
altering the structure of closure objects.

==============================================================================
File: elisp.info,  Node: |Advising_Functions|,  Next: |Obsolete_Functions|,  Prev: |Closures|,  Up: |Functions|
==============================================================================

                                                            *Advising_Functions*

13.11 Advising Emacs Lisp Functions
=====------------------------------

When you need to modify a function defined in another library, or when
you need to modify a hook like 'FOO-function', a process filter, or
basically any variable or object field which holds a function value, you
can use the appropriate setter function, such as 'fset' or 'defun' for
named functions, 'setq' for hook variables, or 'set-process-filter' for
process filters, but those are often too blunt, completely throwing away
the previous value.

   The "advice" feature lets you add to the existing definition of a
function, by "advising the function".  This is a cleaner method than
redefining the whole function.

   Emacs's advice system provides two sets of primitives for that: the
core set, for function values held in variables and object fields (with
the corresponding primitives being 'add-function' and 'remove-function')
and another set layered on top of it for named functions (with the main
primitives being 'advice-add' and 'advice-remove').

   As a trivial example, here's how to add advice that'll modify the
return value of a function every time it's called:

     (defun my-double (x)
       (* x 2))
     (defun my-increase (x)
       (+ x 1))
     (advice-add 'my-double :filter-return #'my-increase)

   After adding this advice, if you call 'my-double' with '3', the
return value will be '7'.  To remove this advice, say

     (advice-remove 'my-double #'my-increase)

   A more advanced example would be to trace the calls to the process
filter of a process PROC:

     (defun my-tracing-function (proc string)
       (message "Proc %S received %S" proc string))

     (add-function :before (process-filter PROC) #'my-tracing-function)

   This will cause the process's output to be passed to
'my-tracing-function' before being passed to the original process
filter.  'my-tracing-function' receives the same arguments as the
original function.  When you're done with it, you can revert to the
untraced behavior with:

     (remove-function (process-filter PROC) #'my-tracing-function)

   Similarly, if you want to trace the execution of the function named
'display-buffer', you could use:

     (defun his-tracing-function (orig-fun &rest args)
       (message "display-buffer called with args %S" args)
       (let ((res (apply orig-fun args)))
         (message "display-buffer returned %S" res)
         res))

     (advice-add 'display-buffer :around #'his-tracing-function)

   Here, 'his-tracing-function' is called instead of the original
function and receives the original function (additionally to that
function's arguments) as argument, so it can call it if and when it
needs to.  When you're tired of seeing this output, you can revert to
the untraced behavior with:

     (advice-remove 'display-buffer #'his-tracing-function)

   The arguments ':before' and ':around' used in the above examples
specify how the two functions are composed, since there are many
different ways to do it.  The added function is also called a piece of
_advice_.

MENU

* |Core_Advising_Primitives|::    Primitives to manipulate advice.
* |Advising_Named_Functions|::    Advising named functions.
* |Advice_Combinators|::          Ways to compose advice.
* |Porting_Old_Advice|::          Adapting code using the old defadvice.

==============================================================================
File: elisp.info,  Node: |Core_Advising_Primitives|,  Next: |Advising_Named_Functions|,  Up: |Advising_Functions|
==============================================================================

                                                      *Core_Advising_Primitives*

13.11.1 Primitives to manipulate advices
----------------------------------------

 -- Macro: add-function where place function &optional props
     This macro is the handy way to add the advice FUNCTION to the
     function stored in PLACE (*note Generalized Variables::).

     WHERE determines how FUNCTION is composed with the existing
     function, e.g., whether FUNCTION should be called before, or after
     the original function.  *Note Advice Combinators::, for the list of
     available ways to compose the two functions.

     When modifying a variable (whose name will usually end with
     '-function'), you can choose whether FUNCTION is used globally or
     only in the current buffer: if PLACE is just a symbol, then
     FUNCTION is added to the global value of PLACE.  Whereas if PLACE
     is of the form '(local SYMBOL)', where SYMBOL is an expression
     which returns the variable name, then FUNCTION will only be added
     in the current buffer.  Finally, if you want to modify a lexical
     variable, you will have to use '(var VARIABLE)'.

     Every function added with 'add-function' can be accompanied by an
     association list of properties PROPS.  Currently only two of those
     properties have a special meaning:

     'name'
          This gives a name to the advice, which 'remove-function' can
          use to identify which function to remove.  Typically used when
          FUNCTION is an anonymous function.

     'depth'
          This specifies how to order the advice, should several pieces
          of advice be present.  By default, the depth is 0.  A depth of
          100 indicates that this piece of advice should be kept as deep
          as possible, whereas a depth of -100 indicates that it should
          stay as the outermost piece.  When two pieces of advice
          specify the same depth, the most recently added one will be
          outermost.

          For ':before' advice, being outermost means that this advice
          will be run first, before any other advice, whereas being
          innermost means that it will run right before the original
          function, with no other advice run between itself and the
          original function.  Similarly, for ':after' advice innermost
          means that it will run right after the original function, with
          no other advice run in between, whereas outermost means that
          it will be run right at the end after all other advice.  An
          innermost ':override' piece of advice will only override the
          original function and other pieces of advice will apply to it,
          whereas an outermost ':override' piece of advice will override
          not only the original function but all other advice applied to
          it as well.

     If FUNCTION is not interactive, then the combined function will
     inherit the interactive spec, if any, of the original function.
     Else, the combined function will be interactive and will use the
     interactive spec of FUNCTION.  One exception: if the interactive
     spec of FUNCTION is a function (i.e., a 'lambda' expression or an
     'fbound' symbol rather than an expression or a string), then the
     interactive spec of the combined function will be a call to that
     function with as sole argument the interactive spec of the original
     function.  To interpret the spec received as argument, use
     'advice-eval-interactive-spec'.

     Note: The interactive spec of FUNCTION will apply to the combined
     function and should hence obey the calling convention of the
     combined function rather than that of FUNCTION.  In many cases, it
     makes no difference since they are identical, but it does matter
     for ':around', ':filter-args', and ':filter-return', where FUNCTION
     receives different arguments than the original function stored in
     PLACE.

 -- Macro: remove-function place function
     This macro removes FUNCTION from the function stored in PLACE.
     This only works if FUNCTION was added to PLACE using
     'add-function'.

     FUNCTION is compared with functions added to PLACE using 'equal',
     to try and make it work also with lambda expressions.  It is
     additionally compared also with the 'name' property of the
     functions added to PLACE, which can be more reliable than comparing
     lambda expressions using 'equal'.

 -- Function: advice-function-member-p advice function-def
     Return non-'nil' if ADVICE is already in FUNCTION-DEF.  Like for
     'remove-function' above, instead of ADVICE being the actual
     function, it can also be the 'name' of the piece of advice.

 -- Function: advice-function-mapc f function-def
     Call the function F for every piece of advice that was added to
     FUNCTION-DEF.  F is called with two arguments: the advice function
     and its properties.

 -- Function: advice-eval-interactive-spec spec
     Evaluate the interactive SPEC just like an interactive call to a
     function with such a spec would, and then return the corresponding
     list of arguments that was built.  E.g.,
     '(advice-eval-interactive-spec "r\nP")' will return a list of three
     elements, containing the boundaries of the region and the current
     prefix argument.

     For instance, if you want to make the 'C-x m' ('compose-mail')
     command prompt for a 'From:' header, you could say something like
     this:

          (defun my-compose-mail-advice (orig &rest args)
            "Read From: address interactively."
            (interactive
             (lambda (spec)
               (let* ((user-mail-address
                       (completing-read "From: "
                                        '("one.address@example.net"
                                          "alternative.address@example.net")))
                      (from (message-make-from user-full-name
                                               user-mail-address))
                      (spec (advice-eval-interactive-spec spec)))
                 ;; Put the From header into the OTHER-HEADERS argument.
                 (push (cons 'From from) (nth 2 spec))
                 spec)))
            (apply orig args))

          (advice-add 'compose-mail :around #'my-compose-mail-advice)

==============================================================================
File: elisp.info,  Node: |Advising_Named_Functions|,  Next: |Advice_Combinators|,  Prev: |Core_Advising_Primitives|,  Up: |Advising_Functions|
==============================================================================

                                                      *Advising_Named_Functions*

13.11.2 Advising Named Functions
--------------------------------

A common use of advice is for named functions and macros.  You could
just use 'add-function' as in:

     (add-function :around (symbol-function 'FUN) #'his-tracing-function)

   But you should use 'advice-add' and 'advice-remove' for that instead.
This separate set of functions to manipulate pieces of advice applied to
named functions, offers the following extra features compared to
'add-function': they know how to deal with macros and autoloaded
functions, they let 'describe-function' preserve the original docstring
as well as document the added advice, and they let you add and remove
advice before a function is even defined.

   'advice-add' can be useful for altering the behavior of existing
calls to an existing function without having to redefine the whole
function.  However, it can be a source of bugs, since existing callers
to the function may assume the old behavior, and work incorrectly when
the behavior is changed by advice.  Advice can also cause confusion in
debugging, if the person doing the debugging does not notice or remember
that the function has been modified by advice.

   For these reasons, advice should be reserved for the cases where you
cannot modify a function's behavior in any other way.  If it is possible
to do the same thing via a hook, that is preferable (*note Hooks::).  If
you simply want to change what a particular key does, it may be better
to write a new command, and remap the old command's key bindings to the
new one (*note Remapping Commands::).

   If you are writing code for release, for others to use, try to avoid
including advice in it.  If the function you want to advise has no hook
to do the job, please talk with the Emacs developers about adding a
suitable hook.  Especially, Emacs's own source files should not put
advice on functions in Emacs.  (There are currently a few exceptions to
this convention, but we aim to correct them.)  It is generally cleaner
to create a new hook in 'foo', and make 'bar' use the hook, than to have
'bar' put advice in 'foo'.

   Special forms (*note Special Forms::) cannot be advised, however
macros can be advised, in much the same way as functions.  Of course,
this will not affect code that has already been macro-expanded, so you
need to make sure the advice is installed before the macro is expanded.

   It is possible to advise a primitive (*note What Is a Function::),
but one should typically _not_ do so, for two reasons.  Firstly, some
primitives are used by the advice mechanism, and advising them could
cause an infinite recursion.  Secondly, many primitives are called
directly from C, and such calls ignore advice; hence, one ends up in a
confusing situation where some calls (occurring from Lisp code) obey the
advice and other calls (from C code) do not.

 -- Macro: define-advice symbol (where lambda-list &optional name depth)
          &rest body
     This macro defines a piece of advice and adds it to the function
     named SYMBOL.  The advice is an anonymous function if NAME is 'nil'
     or a function named 'symbol@name'.  See 'advice-add' for
     explanation of other arguments.

 -- Function: advice-add symbol where function &optional props
     Add the advice FUNCTION to the named function SYMBOL.  WHERE and
     PROPS have the same meaning as for 'add-function' (*note Core
     Advising Primitives::).

 -- Function: advice-remove symbol function
     Remove the advice FUNCTION from the named function SYMBOL.
     FUNCTION can also be the 'name' of a piece of advice.

 -- Function: advice-member-p function symbol
     Return non-'nil' if the advice FUNCTION is already in the named
     function SYMBOL.  FUNCTION can also be the 'name' of a piece of
     advice.

 -- Function: advice-mapc function symbol
     Call FUNCTION for every piece of advice that was added to the named
     function SYMBOL.  FUNCTION is called with two arguments: the advice
     function and its properties.

==============================================================================
File: elisp.info,  Node: |Advice_Combinators|,  Next: |Porting_Old_Advice|,  Prev: |Advising_Named_Functions|,  Up: |Advising_Functions|
==============================================================================

                                                            *Advice_Combinators*

13.11.3 Ways to compose advice
------------------------------

Here are the different possible values for the WHERE argument of
'add-function' and 'advice-add', specifying how the advice FUNCTION and
the original function should be composed.

':before'
     Call FUNCTION before the old function.  Both functions receive the
     same arguments, and the return value of the composition is the
     return value of the old function.  More specifically, the
     composition of the two functions behaves like:
          (lambda (&rest r) (apply FUNCTION r) (apply OLDFUN r))
     '(add-function :before FUNVAR FUNCTION)' is comparable for
     single-function hooks to '(add-hook 'HOOKVAR FUNCTION)' for normal
     hooks.

':after'
     Call FUNCTION after the old function.  Both functions receive the
     same arguments, and the return value of the composition is the
     return value of the old function.  More specifically, the
     composition of the two functions behaves like:
          (lambda (&rest r) (prog1 (apply OLDFUN r) (apply FUNCTION r)))
     '(add-function :after FUNVAR FUNCTION)' is comparable for
     single-function hooks to '(add-hook 'HOOKVAR FUNCTION 'append)' for
     normal hooks.

':override'
     This completely replaces the old function with the new one.  The
     old function can of course be recovered if you later call
     'remove-function'.

':around'
     Call FUNCTION instead of the old function, but provide the old
     function as an extra argument to FUNCTION.  This is the most
     flexible composition.  For example, it lets you call the old
     function with different arguments, or many times, or within a
     let-binding, or you can sometimes delegate the work to the old
     function and sometimes override it completely.  More specifically,
     the composition of the two functions behaves like:
          (lambda (&rest r) (apply FUNCTION OLDFUN r))

':before-while'
     Call FUNCTION before the old function and don't call the old
     function if FUNCTION returns 'nil'.  Both functions receive the
     same arguments, and the return value of the composition is the
     return value of the old function.  More specifically, the
     composition of the two functions behaves like:
          (lambda (&rest r) (and (apply FUNCTION r) (apply OLDFUN r)))
     '(add-function :before-while FUNVAR FUNCTION)' is comparable for
     single-function hooks to '(add-hook 'HOOKVAR FUNCTION)' when
     HOOKVAR is run via 'run-hook-with-args-until-failure'.

':before-until'
     Call FUNCTION before the old function and only call the old
     function if FUNCTION returns 'nil'.  More specifically, the
     composition of the two functions behaves like:
          (lambda (&rest r) (or (apply FUNCTION r) (apply OLDFUN r)))
     '(add-function :before-until FUNVAR FUNCTION)' is comparable for
     single-function hooks to '(add-hook 'HOOKVAR FUNCTION)' when
     HOOKVAR is run via 'run-hook-with-args-until-success'.

':after-while'
     Call FUNCTION after the old function and only if the old function
     returned non-'nil'.  Both functions receive the same arguments, and
     the return value of the composition is the return value of
     FUNCTION.  More specifically, the composition of the two functions
     behaves like:
          (lambda (&rest r) (and (apply OLDFUN r) (apply FUNCTION r)))
     '(add-function :after-while FUNVAR FUNCTION)' is comparable for
     single-function hooks to '(add-hook 'HOOKVAR FUNCTION 'append)'
     when HOOKVAR is run via 'run-hook-with-args-until-failure'.

':after-until'
     Call FUNCTION after the old function and only if the old function
     returned 'nil'.  More specifically, the composition of the two
     functions behaves like:
          (lambda (&rest r) (or  (apply OLDFUN r) (apply FUNCTION r)))
     '(add-function :after-until FUNVAR FUNCTION)' is comparable for
     single-function hooks to '(add-hook 'HOOKVAR FUNCTION 'append)'
     when HOOKVAR is run via 'run-hook-with-args-until-success'.

':filter-args'
     Call FUNCTION first and use the result (which should be a list) as
     the new arguments to pass to the old function.  More specifically,
     the composition of the two functions behaves like:
          (lambda (&rest r) (apply OLDFUN (funcall FUNCTION r)))

':filter-return'
     Call the old function first and pass the result to FUNCTION.  More
     specifically, the composition of the two functions behaves like:
          (lambda (&rest r) (funcall FUNCTION (apply OLDFUN r)))

==============================================================================
File: elisp.info,  Node: |Porting_Old_Advice|,  Prev: |Advice_Combinators|,  Up: |Advising_Functions|
==============================================================================

                                                            *Porting_Old_Advice*

13.11.4 Adapting code using the old defadvice
---------------------------------------------

A lot of code uses the old 'defadvice' mechanism, which is largely made
obsolete by the new 'advice-add', whose implementation and semantics is
significantly simpler.

   An old piece of advice such as:

     (defadvice previous-line (before next-line-at-end
                                      (&optional arg try-vscroll))
       "Insert an empty line when moving up from the top line."
       (if (and next-line-add-newlines (= arg 1)
                (save-excursion (beginning-of-line) (bobp)))
           (progn
             (beginning-of-line)
             (newline))))

   could be translated in the new advice mechanism into a plain
function:

     (defun previous-line--next-line-at-end (&optional arg try-vscroll)
       "Insert an empty line when moving up from the top line."
       (if (and next-line-add-newlines (= arg 1)
                (save-excursion (beginning-of-line) (bobp)))
           (progn
             (beginning-of-line)
             (newline))))

   Obviously, this does not actually modify 'previous-line'.  For that
the old advice needed:
     (ad-activate 'previous-line)
   whereas the new advice mechanism needs:
     (advice-add 'previous-line :before #'previous-line--next-line-at-end)

   Note that 'ad-activate' had a global effect: it activated all pieces
of advice enabled for that specified function.  If you wanted to only
activate or deactivate a particular piece, you needed to _enable_ or
_disable_ it with 'ad-enable-advice' and 'ad-disable-advice'.  The new
mechanism does away with this distinction.

   Around advice such as:

     (defadvice foo (around foo-around)
       "Ignore case in `foo'."
       (let ((case-fold-search t))
         ad-do-it))
     (ad-activate 'foo)

   could translate into:

     (defun foo--foo-around (orig-fun &rest args)
       "Ignore case in `foo'."
       (let ((case-fold-search t))
         (apply orig-fun args)))
     (advice-add 'foo :around #'foo--foo-around)

   Regarding the advice's _class_, note that the new ':before' is not
quite equivalent to the old 'before', because in the old advice you
could modify the function's arguments (e.g., with 'ad-set-arg'), and
that would affect the argument values seen by the original function,
whereas in the new ':before', modifying an argument via 'setq' in the
advice has no effect on the arguments seen by the original function.
When porting 'before' advice which relied on this behavior, you'll need
to turn it into new ':around' or ':filter-args' advice instead.

   Similarly old 'after' advice could modify the returned value by
changing 'ad-return-value', whereas new ':after' advice cannot, so when
porting such old 'after' advice, you'll need to turn it into new
':around' or ':filter-return' advice instead.

==============================================================================
File: elisp.info,  Node: |Obsolete_Functions|,  Next: |Inline_Functions|,  Prev: |Advising_Functions|,  Up: |Functions|
==============================================================================

                                                            *Obsolete_Functions*

13.12 Declaring Functions Obsolete
=====-----------------------------

You can mark a named function as "obsolete", meaning that it may be
removed at some point in the future.  This causes Emacs to warn that the
function is obsolete whenever it byte-compiles code containing that
function, and whenever it displays the documentation for that function.
In all other respects, an obsolete function behaves like any other
function.

   The easiest way to mark a function as obsolete is to put a '(declare
(obsolete ...))' form in the function's 'defun' definition.  *Note
Declare Form::.  Alternatively, you can use the 'make-obsolete'
function, described below.

   A macro (*note Macros::) can also be marked obsolete with
'make-obsolete'; this has the same effects as for a function.  An alias
for a function or macro can also be marked as obsolete; this makes the
alias itself obsolete, not the function or macro which it resolves to.

 -- Function: make-obsolete obsolete-name current-name when
     This function marks OBSOLETE-NAME as obsolete.  OBSOLETE-NAME
     should be a symbol naming a function or macro, or an alias for a
     function or macro.

     If CURRENT-NAME is a symbol, the warning message says to use
     CURRENT-NAME instead of OBSOLETE-NAME.  CURRENT-NAME does not need
     to be an alias for OBSOLETE-NAME; it can be a different function
     with similar functionality.  CURRENT-NAME can also be a string,
     which serves as the warning message.  The message should begin in
     lower case, and end with a period.  It can also be 'nil', in which
     case the warning message provides no additional details.

     The argument WHEN should be a string indicating when the function
     was first made obsolete--for example, a date or a release number.

 -- Macro: define-obsolete-function-alias obsolete-name current-name
          when &optional doc
     This convenience macro marks the function OBSOLETE-NAME obsolete
     and also defines it as an alias for the function CURRENT-NAME.  It
     is equivalent to the following:

          (defalias OBSOLETE-NAME CURRENT-NAME DOC)
          (make-obsolete OBSOLETE-NAME CURRENT-NAME WHEN)

   In addition, you can mark a particular calling convention for a
function as obsolete:

 -- Function: set-advertised-calling-convention function signature when
     This function specifies the argument list SIGNATURE as the correct
     way to call FUNCTION.  This causes the Emacs byte compiler to issue
     a warning whenever it comes across an Emacs Lisp program that calls
     FUNCTION any other way (however, it will still allow the code to be
     byte compiled).  WHEN should be a string indicating when the
     variable was first made obsolete (usually a version number string).

     For instance, in old versions of Emacs the 'sit-for' function
     accepted three arguments, like this

            (sit-for seconds milliseconds nodisp)

     However, calling 'sit-for' this way is considered obsolete (*note
     Waiting::).  The old calling convention is deprecated like this:

          (set-advertised-calling-convention
            'sit-for '(seconds &optional nodisp) "22.1")

==============================================================================
File: elisp.info,  Node: |Inline_Functions|,  Next: |Declare_Form|,  Prev: |Obsolete_Functions|,  Up: |Functions|
==============================================================================

                                                              *Inline_Functions*

13.13 Inline Functions
=====-----------------

An "inline function" is a function that works just like an ordinary
function, except for one thing: when you byte-compile a call to the
function (*note Byte Compilation::), the function's definition is
expanded into the caller.

   The simple way to define an inline function, is to write 'defsubst'
instead of 'defun'.  The rest of the definition looks just the same, but
using 'defsubst' says to make it inline for byte compilation.

 -- Macro: defsubst name args [doc] [declare] [interactive] body...
     This macro defines an inline function.  Its syntax is exactly the
     same as 'defun' (*note Defining Functions::).

   Making a function inline often makes its function calls run faster.
But it also has disadvantages.  For one thing, it reduces flexibility;
if you change the definition of the function, calls already inlined
still use the old definition until you recompile them.

   Another disadvantage is that making a large function inline can
increase the size of compiled code both in files and in memory.  Since
the speed advantage of inline functions is greatest for small functions,
you generally should not make large functions inline.

   Also, inline functions do not behave well with respect to debugging,
tracing, and advising (*note Advising Functions::).  Since ease of
debugging and the flexibility of redefining functions are important
features of Emacs, you should not make a function inline, even if it's
small, unless its speed is really crucial, and you've timed the code to
verify that using 'defun' actually has performance problems.

   After an inline function is defined, its inline expansion can be
performed later on in the same file, just like macros.

   It's possible to use 'defmacro' to define a macro to expand into the
same code that an inline function would execute (*note Macros::).  But
the macro would be limited to direct use in expressions--a macro cannot
be called with 'apply', 'mapcar' and so on.  Also, it takes some work to
convert an ordinary function into a macro.  To convert it into an inline
function is easy; just replace 'defun' with 'defsubst'.  Since each
argument of an inline function is evaluated exactly once, you needn't
worry about how many times the body uses the arguments, as you do for
macros.

   Alternatively, you can define a function by providing the code which
will inline it as a compiler macro.  The following macros make this
possible.

 -- Macro: define-inline name args [doc] [declare] body...
     Define a function NAME by providing code that does its inlining, as
     a compiler macro.  The function will accept the argument list ARGS
     and will have the specified BODY.

     If present, DOC should be the function's documentation string
     (*note Function Documentation::); DECLARE, if present, should be a
     'declare' form (*note Declare Form::) specifying the function's
     metadata.

   Functions defined via 'define-inline' have several advantages with
respect to macros defined by 'defsubst' or 'defmacro':

   - They can be passed to 'mapcar' (*note Mapping Functions::).

   - They are more efficient.

   - They can be used as "place forms" to store values (*note
     Generalized Variables::).

   - They behave in a more predictable way than 'cl-defsubst' (*note
     (cl)Argument Lists::).

   Like 'defmacro', a function inlined with 'define-inline' inherits the
scoping rules, either dynamic or lexical, from the call site.  *Note
Variable Scoping::.

   The following macros should be used in the body of a function defined
by 'define-inline'.

 -- Macro: inline-quote expression
     Quote EXPRESSION for 'define-inline'.  This is similar to the
     backquote (*note Backquote::), but quotes code and accepts only
     ',', not ',@'.

 -- Macro: inline-letevals (bindings...) body...
     This is similar to 'let' (*note Local Variables::): it sets up
     local variables as specified by BINDINGS, and then evaluates BODY
     with those bindings in effect.  Each element of BINDINGS should be
     either a symbol or a list of the form '(VAR EXPR)'; the result is
     to evaluate EXPR and bind VAR to the result.  The tail of BINDINGS
     can be either 'nil' or a symbol which should hold a list of
     arguments, in which case each argument is evaluated, and the symbol
     is bound to the resulting list.

 -- Macro: inline-const-p expression
     Return non-'nil' if the value of EXPRESSION is already known.

 -- Macro: inline-const-val expression
     Return the value of EXPRESSION.

 -- Macro: inline-error format &rest args
     Signal an error, formatting ARGS according to FORMAT.

   Here's an example of using 'define-inline':

     (define-inline myaccessor (obj)
       (inline-letevals (obj)
         (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))

This is equivalent to

     (defsubst myaccessor (obj)
       (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))

==============================================================================
File: elisp.info,  Node: |Declare_Form|,  Next: |Declaring_Functions|,  Prev: |Inline_Functions|,  Up: |Functions|
==============================================================================

                                                                  *Declare_Form*

13.14 The 'declare' Form
=====-------------------

'declare' is a special macro which can be used to add meta properties to
a function or macro: for example, marking it as obsolete, or giving its
forms a special <TAB> indentation convention in Emacs Lisp mode.

 -- Macro: declare specs...
     This macro ignores its arguments and evaluates to 'nil'; it has no
     run-time effect.  However, when a 'declare' form occurs in the
     DECLARE argument of a 'defun' or 'defsubst' function definition
     (*note Defining Functions::) or a 'defmacro' macro definition
     (*note Defining Macros::), it appends the properties specified by
     SPECS to the function or macro.  This work is specially performed
     by 'defun', 'defsubst', and 'defmacro'.

     Each element in SPECS should have the form '(PROPERTY ARGS...)',
     which should not be quoted.  These have the following effects:

     '(advertised-calling-convention SIGNATURE WHEN)'
          This acts like a call to 'set-advertised-calling-convention'
          (*note Obsolete Functions::); SIGNATURE specifies the correct
          argument list for calling the function or macro, and WHEN
          should be a string indicating when the old argument list was
          first made obsolete.

     '(debug EDEBUG-FORM-SPEC)'
          This is valid for macros only.  When stepping through the
          macro with Edebug, use EDEBUG-FORM-SPEC.  *Note Instrumenting
          Macro Calls::.

     '(doc-string N)'
          This is used when defining a function or macro which itself
          will be used to define entities like functions, macros, or
          variables.  It indicates that the Nth argument, if any, should
          be considered as a documentation string.

     '(indent INDENT-SPEC)'
          Indent calls to this function or macro according to
          INDENT-SPEC.  This is typically used for macros, though it
          works for functions too.  *Note Indenting Macros::.

     '(interactive-only VALUE)'
          Set the function's 'interactive-only' property to VALUE.
          *Note The interactive-only property::.

     '(obsolete CURRENT-NAME WHEN)'
          Mark the function or macro as obsolete, similar to a call to
          'make-obsolete' (*note Obsolete Functions::).  CURRENT-NAME
          should be a symbol (in which case the warning message says to
          use that instead), a string (specifying the warning message),
          or 'nil' (in which case the warning message gives no extra
          details).  WHEN should be a string indicating when the
          function or macro was first made obsolete.

     '(compiler-macro EXPANDER)'
          This can only be used for functions, and tells the compiler to
          use EXPANDER as an optimization function.  When encountering a
          call to the function, of the form '(FUNCTION ARGS...)', the
          macro expander will call EXPANDER with that form as well as
          with ARGS..., and EXPANDER can either return a new expression
          to use instead of the function call, or it can return just the
          form unchanged, to indicate that the function call should be
          left alone.  EXPANDER can be a symbol, or it can be a form
          '(lambda (ARG) BODY)' in which case ARG will hold the original
          function call expression, and the (unevaluated) arguments to
          the function can be accessed using the function's formal
          arguments.

     '(gv-expander EXPANDER)'
          Declare EXPANDER to be the function to handle calls to the
          macro (or function) as a generalized variable, similarly to
          'gv-define-expander'.  EXPANDER can be a symbol or it can be
          of the form '(lambda (ARG) BODY)' in which case that function
          will additionally have access to the macro (or function)'s
          arguments.

     '(gv-setter SETTER)'
          Declare SETTER to be the function to handle calls to the macro
          (or function) as a generalized variable.  SETTER can be a
          symbol in which case it will be passed to
          'gv-define-simple-setter', or it can be of the form '(lambda
          (ARG) BODY)' in which case that function will additionally
          have access to the macro (or function)'s arguments and it will
          be passed to 'gv-define-setter'.

==============================================================================
File: elisp.info,  Node: |Declaring_Functions|,  Next: |Function_Safety|,  Prev: |Declare_Form|,  Up: |Functions|
==============================================================================

                                                           *Declaring_Functions*

13.15 Telling the Compiler that a Function is Defined
=====------------------------------------------------

Byte-compiling a file often produces warnings about functions that the
compiler doesn't know about (*note Compiler Errors::).  Sometimes this
indicates a real problem, but usually the functions in question are
defined in other files which would be loaded if that code is run.  For
example, byte-compiling 'simple.el' used to warn:

     simple.el:8727:1:Warning: the function 'shell-mode' is not known to be
         defined.

   In fact, 'shell-mode' is used only in a function that executes
'(require 'shell)' before calling 'shell-mode', so 'shell-mode' will be
defined properly at run-time.  When you know that such a warning does
not indicate a real problem, it is good to suppress the warning.  That
makes new warnings which might mean real problems more visible.  You do
that with 'declare-function'.

   All you need to do is add a 'declare-function' statement before the
first use of the function in question:

     (declare-function shell-mode "shell" ())

   This says that 'shell-mode' is defined in 'shell.el' (the '.el' can
be omitted).  The compiler takes for granted that that file really
defines the function, and does not check.

   The optional third argument specifies the argument list of
'shell-mode'.  In this case, it takes no arguments ('nil' is different
from not specifying a value).  In other cases, this might be something
like '(file &optional overwrite)'.  You don't have to specify the
argument list, but if you do the byte compiler can check that the calls
match the declaration.

 -- Macro: declare-function function file &optional arglist fileonly
     Tell the byte compiler to assume that FUNCTION is defined in the
     file FILE.  The optional third argument ARGLIST is either 't',
     meaning the argument list is unspecified, or a list of formal
     parameters in the same style as 'defun'.  An omitted ARGLIST
     defaults to 't', not 'nil'; this is atypical behavior for omitted
     arguments, and it means that to supply a fourth but not third
     argument one must specify 't' for the third-argument placeholder
     instead of the usual 'nil'.  The optional fourth argument FILEONLY
     non-'nil' means check only that FILE exists, not that it actually
     defines FUNCTION.

   To verify that these functions really are declared where
'declare-function' says they are, use 'check-declare-file' to check all
'declare-function' calls in one source file, or use
'check-declare-directory' check all the files in and under a certain
directory.

   These commands find the file that ought to contain a function's
definition using 'locate-library'; if that finds no file, they expand
the definition file name relative to the directory of the file that
contains the 'declare-function' call.

   You can also say that a function is a primitive by specifying a file
name ending in '.c' or '.m'.  This is useful only when you call a
primitive that is defined only on certain systems.  Most primitives are
always defined, so they will never give you a warning.

   Sometimes a file will optionally use functions from an external
package.  If you prefix the filename in the 'declare-function' statement
with 'ext:', then it will be checked if it is found, otherwise skipped
without error.

   There are some function definitions that 'check-declare' does not
understand (e.g., 'defstruct' and some other macros).  In such cases,
you can pass a non-'nil' FILEONLY argument to 'declare-function',
meaning to only check that the file exists, not that it actually defines
the function.  Note that to do this without having to specify an
argument list, you should set the ARGLIST argument to 't' (because 'nil'
means an empty argument list, as opposed to an unspecified one).

==============================================================================
File: elisp.info,  Node: |Function_Safety|,  Next: |Related_Topics|,  Prev: |Declaring_Functions|,  Up: |Functions|
==============================================================================

                                                               *Function_Safety*

13.16 Determining whether a Function is Safe to Call
=====-----------------------------------------------

Some major modes, such as SES, call functions that are stored in user
files.  (*note (ses)Top::, for more information on SES.)  User files
sometimes have poor pedigrees--you can get a spreadsheet from someone
you've just met, or you can get one through email from someone you've
never met.  So it is risky to call a function whose source code is
stored in a user file until you have determined that it is safe.

 -- Function: unsafep form &optional unsafep-vars
     Returns 'nil' if FORM is a "safe" Lisp expression, or returns a
     list that describes why it might be unsafe.  The argument
     UNSAFEP-VARS is a list of symbols known to have temporary bindings
     at this point; it is mainly used for internal recursive calls.  The
     current buffer is an implicit argument, which provides a list of
     buffer-local bindings.

   Being quick and simple, 'unsafep' does a very light analysis and
rejects many Lisp expressions that are actually safe.  There are no
known cases where 'unsafep' returns 'nil' for an unsafe expression.
However, a safe Lisp expression can return a string with a 'display'
property, containing an associated Lisp expression to be executed after
the string is inserted into a buffer.  This associated expression can be
a virus.  In order to be safe, you must delete properties from all
strings calculated by user code before inserting them into buffers.

==============================================================================
File: elisp.info,  Node: |Related_Topics|,  Prev: |Function_Safety|,  Up: |Functions|
==============================================================================

                                                                *Related_Topics*

13.17 Other Topics Related to Functions
=====----------------------------------

Here is a table of several functions that do things related to function
calling and function definitions.  They are documented elsewhere, but we
provide cross references here.

'apply'
     See *note Calling Functions::.

'autoload'
     See *note Autoload::.

'call-interactively'
     See *note Interactive Call::.

'called-interactively-p'
     See *note Distinguish Interactive::.

'commandp'
     See *note Interactive Call::.

'documentation'
     See *note Accessing Documentation::.

'eval'
     See *note Eval::.

'funcall'
     See *note Calling Functions::.

'function'
     See *note Anonymous Functions::.

'ignore'
     See *note Calling Functions::.

'indirect-function'
     See *note Function Indirection::.

'interactive'
     See *note Using Interactive::.

'interactive-p'
     See *note Distinguish Interactive::.

'mapatoms'
     See *note Creating Symbols::.

'mapcar'
     See *note Mapping Functions::.

'map-char-table'
     See *note Char-Tables::.

'mapconcat'
     See *note Mapping Functions::.

'undefined'
     See *note Functions for Key Lookup::.

==============================================================================
File: elisp.info,  Node: |Macros|,  Next: |Customization|,  Prev: |Functions|,  Up: |Top|
==============================================================================

                                                                        *Macros*

14 Macros
*****====

"Macros" enable you to define new control constructs and other language
features.  A macro is defined much like a function, but instead of
telling how to compute a value, it tells how to compute another Lisp
expression which will in turn compute the value.  We call this
expression the "expansion" of the macro.

   Macros can do this because they operate on the unevaluated
expressions for the arguments, not on the argument values as functions
do.  They can therefore construct an expansion containing these argument
expressions or parts of them.

   If you are using a macro to do something an ordinary function could
do, just for the sake of speed, consider using an inline function
instead.  *Note Inline Functions::.

MENU

* |Simple_Macro|::            A basic example.
* |Expansion|::               How, when and why macros are expanded.
* |Compiling_Macros|::        How macros are expanded by the compiler.
* |Defining_Macros|::         How to write a macro definition.
* |Problems_with_Macros|::    Don't evaluate the macro arguments too many times.
                              Don't hide the user's variables.
* |Indenting_Macros|::        Specifying how to indent macro calls.

==============================================================================
File: elisp.info,  Node: |Simple_Macro|,  Next: |Expansion|,  Up: |Macros|
==============================================================================

                                                                  *Simple_Macro*

14.1 A Simple Example of a Macro
=====---------------------------

Suppose we would like to define a Lisp construct to increment a variable
value, much like the '++' operator in C.  We would like to write '(inc
x)' and have the effect of '(setq x (1+ x))'.  Here's a macro definition
that does the job:

     (defmacro inc (var)
        (list 'setq var (list '1+ var)))

   When this is called with '(inc x)', the argument VAR is the symbol
'x'--_not_ the _value_ of 'x', as it would be in a function.  The body of
the macro uses this to construct the expansion, which is '(setq x (1+
x))'.  Once the macro definition returns this expansion, Lisp proceeds
to evaluate it, thus incrementing 'x'.

 -- Function: macrop object
     This predicate tests whether its argument is a macro, and returns
     't' if so, 'nil' otherwise.

==============================================================================
File: elisp.info,  Node: |Expansion|,  Next: |Compiling_Macros|,  Prev: |Simple_Macro|,  Up: |Macros|
==============================================================================

                                                                     *Expansion*

14.2 Expansion of a Macro Call
=====-------------------------

A macro call looks just like a function call in that it is a list which
starts with the name of the macro.  The rest of the elements of the list
are the arguments of the macro.

   Evaluation of the macro call begins like evaluation of a function
call except for one crucial difference: the macro arguments are the
actual expressions appearing in the macro call.  They are not evaluated
before they are given to the macro definition.  By contrast, the
arguments of a function are results of evaluating the elements of the
function call list.

   Having obtained the arguments, Lisp invokes the macro definition just
as a function is invoked.  The argument variables of the macro are bound
to the argument values from the macro call, or to a list of them in the
case of a '&rest' argument.  And the macro body executes and returns its
value just as a function body does.

   The second crucial difference between macros and functions is that
the value returned by the macro body is an alternate Lisp expression,
also known as the "expansion" of the macro.  The Lisp interpreter
proceeds to evaluate the expansion as soon as it comes back from the
macro.

   Since the expansion is evaluated in the normal manner, it may contain
calls to other macros.  It may even be a call to the same macro, though
this is unusual.

   Note that Emacs tries to expand macros when loading an uncompiled
Lisp file.  This is not always possible, but if it is, it speeds up
subsequent execution.  *Note How Programs Do Loading::.

   You can see the expansion of a given macro call by calling
'macroexpand'.

 -- Function: macroexpand form &optional environment
     This function expands FORM, if it is a macro call.  If the result
     is another macro call, it is expanded in turn, until something
     which is not a macro call results.  That is the value returned by
     'macroexpand'.  If FORM is not a macro call to begin with, it is
     returned as given.

     Note that 'macroexpand' does not look at the subexpressions of FORM
     (although some macro definitions may do so).  Even if they are
     macro calls themselves, 'macroexpand' does not expand them.

     The function 'macroexpand' does not expand calls to inline
     functions.  Normally there is no need for that, since a call to an
     inline function is no harder to understand than a call to an
     ordinary function.

     If ENVIRONMENT is provided, it specifies an alist of macro
     definitions that shadow the currently defined macros.  Byte
     compilation uses this feature.

          (defmacro inc (var)
              (list 'setq var (list '1+ var)))

          (macroexpand '(inc r))
               => (setq r (1+ r))

          (defmacro inc2 (var1 var2)
              (list 'progn (list 'inc var1) (list 'inc var2)))

          (macroexpand '(inc2 r s))
               => (progn (inc r) (inc s))  ; 'inc' not expanded here.

 -- Function: macroexpand-all form &optional environment
     'macroexpand-all' expands macros like 'macroexpand', but will look
     for and expand all macros in FORM, not just at the top-level.  If
     no macros are expanded, the return value is 'eq' to FORM.

     Repeating the example used for 'macroexpand' above with
     'macroexpand-all', we see that 'macroexpand-all' _does_ expand the
     embedded calls to 'inc':

          (macroexpand-all '(inc2 r s))
               => (progn (setq r (1+ r)) (setq s (1+ s)))

 -- Function: macroexpand-1 form &optional environment
     This function expands macros like 'macroexpand', but it only
     performs one step of the expansion: if the result is another macro
     call, 'macroexpand-1' will not expand it.

==============================================================================
File: elisp.info,  Node: |Compiling_Macros|,  Next: |Defining_Macros|,  Prev: |Expansion|,  Up: |Macros|
==============================================================================

                                                              *Compiling_Macros*

14.3 Macros and Byte Compilation
=====---------------------------

You might ask why we take the trouble to compute an expansion for a
macro and then evaluate the expansion.  Why not have the macro body
produce the desired results directly?  The reason has to do with
compilation.

   When a macro call appears in a Lisp program being compiled, the Lisp
compiler calls the macro definition just as the interpreter would, and
receives an expansion.  But instead of evaluating this expansion, it
compiles the expansion as if it had appeared directly in the program.
As a result, the compiled code produces the value and side effects
intended for the macro, but executes at full compiled speed.  This would
not work if the macro body computed the value and side effects
itself--they would be computed at compile time, which is not useful.

   In order for compilation of macro calls to work, the macros must
already be defined in Lisp when the calls to them are compiled.  The
compiler has a special feature to help you do this: if a file being
compiled contains a 'defmacro' form, the macro is defined temporarily
for the rest of the compilation of that file.

   Byte-compiling a file also executes any 'require' calls at top-level
in the file, so you can ensure that necessary macro definitions are
available during compilation by requiring the files that define them
(*note Named Features::).  To avoid loading the macro definition files
when someone _runs_ the compiled program, write 'eval-when-compile'
around the 'require' calls (*note Eval During Compile::).

==============================================================================
File: elisp.info,  Node: |Defining_Macros|,  Next: |Problems_with_Macros|,  Prev: |Compiling_Macros|,  Up: |Macros|
==============================================================================

                                                               *Defining_Macros*

14.4 Defining Macros
=====---------------

A Lisp macro object is a list whose CAR is 'macro', and whose CDR is a
function.  Expansion of the macro works by applying the function (with
'apply') to the list of _unevaluated_ arguments from the macro call.

   It is possible to use an anonymous Lisp macro just like an anonymous
function, but this is never done, because it does not make sense to pass
an anonymous macro to functionals such as 'mapcar'.  In practice, all
Lisp macros have names, and they are almost always defined with the
'defmacro' macro.

 -- Macro: defmacro name args [doc] [declare] body...
     'defmacro' defines the symbol NAME (which should not be quoted) as
     a macro that looks like this:

          (macro lambda ARGS . BODY)

     (Note that the CDR of this list is a lambda expression.)  This
     macro object is stored in the function cell of NAME.  The meaning
     of ARGS is the same as in a function, and the keywords '&rest' and
     '&optional' may be used (*note Argument List::).  Neither NAME nor
     ARGS should be quoted.  The return value of 'defmacro' is
     undefined.

     DOC, if present, should be a string specifying the macro's
     documentation string.  DECLARE, if present, should be a 'declare'
     form specifying metadata for the macro (*note Declare Form::).
     Note that macros cannot have interactive declarations, since they
     cannot be called interactively.

   Macros often need to construct large list structures from a mixture
of constants and nonconstant parts.  To make this easier, use the '`'
syntax (*note Backquote::).  For example:

          (defmacro t-becomes-nil (variable)
            `(if (eq ,variable t)
                 (setq ,variable nil)))

          (t-becomes-nil foo)
               ??? (if (eq foo t) (setq foo nil))

==============================================================================
File: elisp.info,  Node: |Problems_with_Macros|,  Next: |Indenting_Macros|,  Prev: |Defining_Macros|,  Up: |Macros|
==============================================================================

                                                          *Problems_with_Macros*

14.5 Common Problems Using Macros
=====----------------------------

Macro expansion can have counterintuitive consequences.  This section
describes some important consequences that can lead to trouble, and
rules to follow to avoid trouble.

MENU

* |Wrong_Time|::             Do the work in the expansion, not in the macro.
* |Argument_Evaluation|::    The expansion should evaluate each macro arg once.
* |Surprising_Local_Vars|::  Local variable bindings in the expansion
                              require special care.
* |Eval_During_Expansion|::  Don't evaluate them; put them in the expansion.
* |Repeated_Expansion|::     Avoid depending on how many times expansion is done.

==============================================================================
File: elisp.info,  Node: |Wrong_Time|,  Next: |Argument_Evaluation|,  Up: |Problems_with_Macros|
==============================================================================

                                                                    *Wrong_Time*

14.5.1 Wrong Time
-----------------

The most common problem in writing macros is doing some of the real work
prematurely--while expanding the macro, rather than in the expansion
itself.  For instance, one real package had this macro definition:

     (defmacro my-set-buffer-multibyte (arg)
       (if (fboundp 'set-buffer-multibyte)
           (set-buffer-multibyte arg)))

   With this erroneous macro definition, the program worked fine when
interpreted but failed when compiled.  This macro definition called
'set-buffer-multibyte' during compilation, which was wrong, and then did
nothing when the compiled package was run.  The definition that the
programmer really wanted was this:

     (defmacro my-set-buffer-multibyte (arg)
       (if (fboundp 'set-buffer-multibyte)
           `(set-buffer-multibyte ,arg)))

This macro expands, if appropriate, into a call to
'set-buffer-multibyte' that will be executed when the compiled program
is actually run.

==============================================================================
File: elisp.info,  Node: |Argument_Evaluation|,  Next: |Surprising_Local_Vars|,  Prev: |Wrong_Time|,  Up: |Problems_with_Macros|
==============================================================================

                                                           *Argument_Evaluation*

14.5.2 Evaluating Macro Arguments Repeatedly
--------------------------------------------

When defining a macro you must pay attention to the number of times the
arguments will be evaluated when the expansion is executed.  The
following macro (used to facilitate iteration) illustrates the problem.
This macro allows us to write a for-loop construct.

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       (list 'let (list (list var init))
             (cons 'while
                   (cons (list '<= var final)
                         (append body (list (list 'inc var)))))))

     (for i from 1 to 3 do
        (setq square (* i i))
        (princ (format "\n%d %d" i square)))
     ==>
     (let ((i 1))
       (while (<= i 3)
         (setq square (* i i))
         (princ (format "\n%d %d" i square))
         (inc i)))

          -|1       1
          -|2       4
          -|3       9
     => nil

The arguments 'from', 'to', and 'do' in this macro are syntactic sugar;
they are entirely ignored.  The idea is that you will write noise words
(such as 'from', 'to', and 'do') in those positions in the macro call.

   Here's an equivalent definition simplified through use of backquote:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       `(let ((,var ,init))
          (while (<= ,var ,final)
            ,@body
            (inc ,var))))

   Both forms of this definition (with backquote and without) suffer
from the defect that FINAL is evaluated on every iteration.  If FINAL is
a constant, this is not a problem.  If it is a more complex form, say
'(long-complex-calculation x)', this can slow down the execution
significantly.  If FINAL has side effects, executing it more than once
is probably incorrect.

   A well-designed macro definition takes steps to avoid this problem by
producing an expansion that evaluates the argument expressions exactly
once unless repeated evaluation is part of the intended purpose of the
macro.  Here is a correct expansion for the 'for' macro:

     (let ((i 1)
           (max 3))
       (while (<= i max)
         (setq square (* i i))
         (princ (format "%d      %d" i square))
         (inc i)))

   Here is a macro definition that creates this expansion:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       `(let ((,var ,init)
              (max ,final))
          (while (<= ,var max)
            ,@body
            (inc ,var))))

   Unfortunately, this fix introduces another problem, described in the
following section.

==============================================================================
File: elisp.info,  Node: |Surprising_Local_Vars|,  Next: |Eval_During_Expansion|,  Prev: |Argument_Evaluation|,  Up: |Problems_with_Macros|
==============================================================================

                                                         *Surprising_Local_Vars*

14.5.3 Local Variables in Macro Expansions
------------------------------------------

In the previous section, the definition of 'for' was fixed as follows to
make the expansion evaluate the macro arguments the proper number of
times:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       `(let ((,var ,init)
              (max ,final))
          (while (<= ,var max)
            ,@body
            (inc ,var))))

   The new definition of 'for' has a new problem: it introduces a local
variable named 'max' which the user does not expect.  This causes
trouble in examples such as the following:

     (let ((max 0))
       (for x from 0 to 10 do
         (let ((this (frob x)))
           (if (< max this)
               (setq max this)))))

The references to 'max' inside the body of the 'for', which are supposed
to refer to the user's binding of 'max', really access the binding made
by 'for'.

   The way to correct this is to use an uninterned symbol instead of
'max' (*note Creating Symbols::).  The uninterned symbol can be bound
and referred to just like any other symbol, but since it is created by
'for', we know that it cannot already appear in the user's program.
Since it is not interned, there is no way the user can put it into the
program later.  It will never appear anywhere except where put by 'for'.
Here is a definition of 'for' that works this way:

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       (let ((tempvar (make-symbol "max")))
         `(let ((,var ,init)
                (,tempvar ,final))
            (while (<= ,var ,tempvar)
              ,@body
              (inc ,var)))))

This creates an uninterned symbol named 'max' and puts it in the
expansion instead of the usual interned symbol 'max' that appears in
expressions ordinarily.

==============================================================================
File: elisp.info,  Node: |Eval_During_Expansion|,  Next: |Repeated_Expansion|,  Prev: |Surprising_Local_Vars|,  Up: |Problems_with_Macros|
==============================================================================

                                                         *Eval_During_Expansion*

14.5.4 Evaluating Macro Arguments in Expansion
----------------------------------------------

Another problem can happen if the macro definition itself evaluates any
of the macro argument expressions, such as by calling 'eval' (*note
Eval::).  If the argument is supposed to refer to the user's variables,
you may have trouble if the user happens to use a variable with the same
name as one of the macro arguments.  Inside the macro body, the macro
argument binding is the most local binding of this variable, so any
references inside the form being evaluated do refer to it.  Here is an
example:

     (defmacro foo (a)
       (list 'setq (eval a) t))
     (setq x 'b)
     (foo x) ==> (setq b t)
          => t                  ; and 'b' has been set.
     ;; but
     (setq a 'c)
     (foo a) ==> (setq a t)
          => t                  ; but this set 'a', not 'c'.


   It makes a difference whether the user's variable is named 'a' or
'x', because 'a' conflicts with the macro argument variable 'a'.

   Another problem with calling 'eval' in a macro definition is that it
probably won't do what you intend in a compiled program.  The byte
compiler runs macro definitions while compiling the program, when the
program's own computations (which you might have wished to access with
'eval') don't occur and its local variable bindings don't exist.

   To avoid these problems, *don't evaluate an argument expression while
computing the macro expansion*.  Instead, substitute the expression into
the macro expansion, so that its value will be computed as part of
executing the expansion.  This is how the other examples in this chapter
work.

==============================================================================
File: elisp.info,  Node: |Repeated_Expansion|,  Prev: |Eval_During_Expansion|,  Up: |Problems_with_Macros|
==============================================================================

                                                            *Repeated_Expansion*

14.5.5 How Many Times is the Macro Expanded?
--------------------------------------------

Occasionally problems result from the fact that a macro call is expanded
each time it is evaluated in an interpreted function, but is expanded
only once (during compilation) for a compiled function.  If the macro
definition has side effects, they will work differently depending on how
many times the macro is expanded.

   Therefore, you should avoid side effects in computation of the macro
expansion, unless you really know what you are doing.

   One special kind of side effect can't be avoided: constructing Lisp
objects.  Almost all macro expansions include constructed lists; that is
the whole point of most macros.  This is usually safe; there is just one
case where you must be careful: when the object you construct is part of
a quoted constant in the macro expansion.

   If the macro is expanded just once, in compilation, then the object
is constructed just once, during compilation.  But in interpreted
execution, the macro is expanded each time the macro call runs, and this
means a new object is constructed each time.

   In most clean Lisp code, this difference won't matter.  It can matter
only if you perform side-effects on the objects constructed by the macro
definition.  Thus, to avoid trouble, *avoid side effects on objects
constructed by macro definitions*.  Here is an example of how such side
effects can get you into trouble:

     (defmacro empty-object ()
       (list 'quote (cons nil nil)))

     (defun initialize (condition)
       (let ((object (empty-object)))
         (if condition
             (setcar object condition))
         object))

If 'initialize' is interpreted, a new list '(nil)' is constructed each
time 'initialize' is called.  Thus, no side effect survives between
calls.  If 'initialize' is compiled, then the macro 'empty-object' is
expanded during compilation, producing a single constant '(nil)' that is
reused and altered each time 'initialize' is called.

   One way to avoid pathological cases like this is to think of
'empty-object' as a funny kind of constant, not as a memory allocation
construct.  You wouldn't use 'setcar' on a constant such as ''(nil)', so
naturally you won't use it on '(empty-object)' either.

==============================================================================
File: elisp.info,  Node: |Indenting_Macros|,  Prev: Problems with Macros,  Up: |Macros|
==============================================================================

                                                              *Indenting_Macros*

14.6 Indenting Macros
=====----------------

Within a macro definition, you can use the 'declare' form (*note
Defining Macros::) to specify how <TAB> should indent calls to the
macro.  An indentation specification is written like this:

     (declare (indent INDENT-SPEC))

This results in the 'lisp-indent-function' property being set on the
macro name.

Here are the possibilities for INDENT-SPEC:

'nil'
     This is the same as no property--use the standard indentation
     pattern.
'defun'
     Handle this function like a 'def' construct: treat the second line
     as the start of a "body".
an integer, NUMBER
     The first NUMBER arguments of the function are "distinguished"
     arguments; the rest are considered the body of the expression.  A
     line in the expression is indented according to whether the first
     argument on it is distinguished or not.  If the argument is part of
     the body, the line is indented 'lisp-body-indent' more columns than
     the open-parenthesis starting the containing expression.  If the
     argument is distinguished and is either the first or second
     argument, it is indented _twice_ that many extra columns.  If the
     argument is distinguished and not the first or second argument, the
     line uses the standard pattern.
a symbol, SYMBOL
     SYMBOL should be a function name; that function is called to
     calculate the indentation of a line within this expression.  The
     function receives two arguments:

     POS
          The position at which the line being indented begins.
     STATE
          The value returned by 'parse-partial-sexp' (a Lisp primitive
          for indentation and nesting computation) when it parses up to
          the beginning of this line.

     It should return either a number, which is the number of columns of
     indentation for that line, or a list whose car is such a number.
     The difference between returning a number and returning a list is
     that a number says that all following lines at the same nesting
     level should be indented just like this one; a list says that
     following lines might call for different indentations.  This makes
     a difference when the indentation is being computed by 'C-M-q'; if
     the value is a number, 'C-M-q' need not recalculate indentation for
     the following lines until the end of the list.

==============================================================================
File: elisp.info,  Node: |Customization|,  Next: |Loading|,  Prev: |Macros|,  Up: |Top|
==============================================================================

                                                                 *Customization*

15 Customization Settings
*****====================

Users of Emacs can customize variables and faces without writing Lisp
code, by using the Customize interface.  *Note (emacs)Easy
Customization::.  This chapter describes how to define "customization
items" that users can interact with through the Customize interface.

   Customization items include customizable variables, which are defined
with the 'defcustom' macro (*note Variable Definitions::); customizable
faces, which are defined with 'defface' (described separately in *note
Defining Faces::); and "customization groups", defined with 'defgroup'
(*note Group Definitions::), which act as containers for groups of
related customization items.

MENU

* |Common_Keywords|::         Common keyword arguments for all kinds of
                             customization declarations.
* |Group_Definitions|::       Writing customization group definitions.
* |Variable_Definitions|::    Declaring user options.
* |Customization_Types|::     Specifying the type of a user option.
* |Applying_Customizations|:: Functions to apply customization settings.
* |Custom_Themes|::           Writing Custom themes.

==============================================================================
File: elisp.info,  Node: |Common_Keywords|,  Next: |Group_Definitions|,  Up: |Customization|
==============================================================================

                                                               *Common_Keywords*

15.1 Common Item Keywords
=====--------------------

The customization declarations that we will describe in the next few
sections--'defcustom', 'defgroup', etc.--all accept keyword arguments
(*note Constant Variables::) for specifying various information.  This
section describes keywords that apply to all types of customization
declarations.

   All of these keywords, except ':tag', can be used more than once in a
given item.  Each use of the keyword has an independent effect.  The
keyword ':tag' is an exception because any given item can only display
one name.

':tag LABEL'
     Use LABEL, a string, instead of the item's name, to label the item
     in customization menus and buffers.  *Don't use a tag which is
     substantially different from the item's real name; that would cause
     confusion.*

':group GROUP'
     Put this customization item in group GROUP.  If this keyword is
     missing from a customization item, it'll be placed in the same
     group that was last defined (in the current file).

     When you use ':group' in a 'defgroup', it makes the new group a
     subgroup of GROUP.

     If you use this keyword more than once, you can put a single item
     into more than one group.  Displaying any of those groups will show
     this item.  Please don't overdo this, since the result would be
     annoying.

':link LINK-DATA'
     Include an external link after the documentation string for this
     item.  This is a sentence containing a button that references some
     other documentation.

     There are several alternatives you can use for LINK-DATA:

     '(custom-manual INFO-NODE)'
          Link to an Info node; INFO-NODE is a string which specifies
          the node name, as in '"(emacs)Top"'.  The link appears as
          '[Manual]' in the customization buffer and enters the built-in
          Info reader on INFO-NODE.

     '(info-link INFO-NODE)'
          Like 'custom-manual' except that the link appears in the
          customization buffer with the Info node name.

     '(url-link URL)'
          Link to a web page; URL is a string which specifies the URL.
          The link appears in the customization buffer as URL and
          invokes the WWW browser specified by
          'browse-url-browser-function'.

     '(emacs-commentary-link LIBRARY)'
          Link to the commentary section of a library; LIBRARY is a
          string which specifies the library name.  *Note Library
          Headers::.

     '(emacs-library-link LIBRARY)'
          Link to an Emacs Lisp library file; LIBRARY is a string which
          specifies the library name.

     '(file-link FILE)'
          Link to a file; FILE is a string which specifies the name of
          the file to visit with 'find-file' when the user invokes this
          link.

     '(function-link FUNCTION)'
          Link to the documentation of a function; FUNCTION is a string
          which specifies the name of the function to describe with
          'describe-function' when the user invokes this link.

     '(variable-link VARIABLE)'
          Link to the documentation of a variable; VARIABLE is a string
          which specifies the name of the variable to describe with
          'describe-variable' when the user invokes this link.

     '(custom-group-link GROUP)'
          Link to another customization group.  Invoking it creates a
          new customization buffer for GROUP.

     You can specify the text to use in the customization buffer by
     adding ':tag NAME' after the first element of the LINK-DATA; for
     example, '(info-link :tag "foo" "(emacs)Top")' makes a link to the
     Emacs manual which appears in the buffer as 'foo'.

     You can use this keyword more than once, to add multiple links.

':load FILE'
     Load file FILE (a string) before displaying this customization item
     (*note Loading::).  Loading is done with 'load', and only if the
     file is not already loaded.

':require FEATURE'
     Execute '(require 'FEATURE)' when your saved customizations set the
     value of this item.  FEATURE should be a symbol.

     The most common reason to use ':require' is when a variable enables
     a feature such as a minor mode, and just setting the variable won't
     have any effect unless the code which implements the mode is
     loaded.

':version VERSION'
     This keyword specifies that the item was first introduced in Emacs
     version VERSION, or that its default value was changed in that
     version.  The value VERSION must be a string.

':package-version '(PACKAGE . VERSION)'
     This keyword specifies that the item was first introduced in
     PACKAGE version VERSION, or that its meaning or default value was
     changed in that version.  This keyword takes priority over
     ':version'.

     PACKAGE should be the official name of the package, as a symbol
     (e.g., 'MH-E').  VERSION should be a string.  If the package
     PACKAGE is released as part of Emacs, PACKAGE and VERSION should
     appear in the value of 'customize-package-emacs-version-alist'.

   Packages distributed as part of Emacs that use the ':package-version'
keyword must also update the 'customize-package-emacs-version-alist'
variable.

 -- Variable: customize-package-emacs-version-alist
     This alist provides a mapping for the versions of Emacs that are
     associated with versions of a package listed in the
     ':package-version' keyword.  Its elements are:

          (PACKAGE (PVERSION . EVERSION)...)

     For each PACKAGE, which is a symbol, there are one or more elements
     that contain a package version PVERSION with an associated Emacs
     version EVERSION.  These versions are strings.  For example, the
     MH-E package updates this alist with the following:

          (add-to-list 'customize-package-emacs-version-alist
                       '(MH-E ("6.0" . "22.1") ("6.1" . "22.1") ("7.0" . "22.1")
                              ("7.1" . "22.1") ("7.2" . "22.1") ("7.3" . "22.1")
                              ("7.4" . "22.1") ("8.0" . "22.1")))

     The value of PACKAGE needs to be unique and it needs to match the
     PACKAGE value appearing in the ':package-version' keyword.  Since
     the user might see the value in an error message, a good choice is
     the official name of the package, such as MH-E or Gnus.

==============================================================================
File: elisp.info,  Node: |Group_Definitions|,  Next: |Variable_Definitions|,  Prev: |Common_Keywords|,  Up: |Customization|
==============================================================================

                                                             *Group_Definitions*

15.2 Defining Customization Groups
=====-----------------------------

Each Emacs Lisp package should have one main customization group which
contains all the options, faces and other groups in the package.  If the
package has a small number of options and faces, use just one group and
put everything in it.  When there are more than twenty or so options and
faces, then you should structure them into subgroups, and put the
subgroups under the package's main customization group.  It is OK to put
some of the options and faces in the package's main group alongside the
subgroups.

   The package's main or only group should be a member of one or more of
the standard customization groups.  (To display the full list of them,
use 'M-x customize'.)  Choose one or more of them (but not too many),
and add your group to each of them using the ':group' keyword.

   The way to declare new customization groups is with 'defgroup'.

 -- Macro: defgroup group members doc [keyword value]...
     Declare GROUP as a customization group containing MEMBERS.  Do not
     quote the symbol GROUP.  The argument DOC specifies the
     documentation string for the group.

     The argument MEMBERS is a list specifying an initial set of
     customization items to be members of the group.  However, most
     often MEMBERS is 'nil', and you specify the group's members by
     using the ':group' keyword when defining those members.

     If you want to specify group members through MEMBERS, each element
     should have the form '(NAME WIDGET)'.  Here NAME is a symbol, and
     WIDGET is a widget type for editing that symbol.  Useful widgets
     are 'custom-variable' for a variable, 'custom-face' for a face, and
     'custom-group' for a group.

     When you introduce a new group into Emacs, use the ':version'
     keyword in the 'defgroup'; then you need not use it for the
     individual members of the group.

     In addition to the common keywords (*note Common Keywords::), you
     can also use this keyword in 'defgroup':

     ':prefix PREFIX'
          If the name of an item in the group starts with PREFIX, and
          the customizable variable 'custom-unlispify-remove-prefixes'
          is non-'nil', the item's tag will omit PREFIX.  A group can
          have any number of prefixes.

     The variables and subgroups of a group are stored in the
     'custom-group' property of the group's symbol.  *Note Symbol
     Plists::.  The value of that property is a list of pairs whose
     'car' is the variable or subgroup symbol and the 'cdr' is either
     'custom-variable' or 'custom-group'.

 -- User Option: custom-unlispify-remove-prefixes
     If this variable is non-'nil', the prefixes specified by a group's
     ':prefix' keyword are omitted from tag names, whenever the user
     customizes the group.

     The default value is 'nil', i.e., the prefix-discarding feature is
     disabled.  This is because discarding prefixes often leads to
     confusing names for options and faces.

==============================================================================
File: elisp.info,  Node: |Variable_Definitions|,  Next: |Customization_Types|,  Prev: |Group_Definitions|,  Up: |Customization|
==============================================================================

                                                          *Variable_Definitions*

15.3 Defining Customization Variables
=====--------------------------------

"Customizable variables", also called "user options", are global Lisp
variables whose values can be set through the Customize interface.
Unlike other global variables, which are defined with 'defvar' (*note
Defining Variables::), customizable variables are defined using the
'defcustom' macro.  In addition to calling 'defvar' as a subroutine,
'defcustom' states how the variable should be displayed in the Customize
interface, the values it is allowed to take, etc.

 -- Macro: defcustom option standard doc [keyword value]...
     This macro declares OPTION as a user option (i.e., a customizable
     variable).  You should not quote OPTION.

     The argument STANDARD is an expression that specifies the standard
     value for OPTION.  Evaluating the 'defcustom' form evaluates
     STANDARD, but does not necessarily bind the option to that value.
     If OPTION already has a default value, it is left unchanged.  If
     the user has already saved a customization for OPTION, the user's
     customized value is installed as the default value.  Otherwise, the
     result of evaluating STANDARD is installed as the default value.

     Like 'defvar', this macro marks 'option' as a special variable,
     meaning that it should always be dynamically bound.  If OPTION is
     already lexically bound, that lexical binding remains in effect
     until the binding construct exits.  *Note Variable Scoping::.

     The expression STANDARD can be evaluated at various other times,
     too--whenever the customization facility needs to know OPTION's
     standard value.  So be sure to use an expression which is harmless
     to evaluate at any time.

     The argument DOC specifies the documentation string for the
     variable.

     If a 'defcustom' does not specify any ':group', the last group
     defined with 'defgroup' in the same file will be used.  This way,
     most 'defcustom' do not need an explicit ':group'.

     When you evaluate a 'defcustom' form with 'C-M-x' in Emacs Lisp
     mode ('eval-defun'), a special feature of 'eval-defun' arranges to
     set the variable unconditionally, without testing whether its value
     is void.  (The same feature applies to 'defvar', *note Defining
     Variables::.)  Using 'eval-defun' on a defcustom that is already
     defined calls the ':set' function (see below), if there is one.

     If you put a 'defcustom' in a pre-loaded Emacs Lisp file (*note
     Building Emacs::), the standard value installed at dump time might
     be incorrect, e.g., because another variable that it depends on has
     not been assigned the right value yet.  In that case, use
     'custom-reevaluate-setting', described below, to re-evaluate the
     standard value after Emacs starts up.

   In addition to the keywords listed in *note Common Keywords::, this
macro accepts the following keywords:

':type TYPE'
     Use TYPE as the data type for this option.  It specifies which
     values are legitimate, and how to display the value (*note
     Customization Types::).  Every 'defcustom' should specify a value
     for this keyword.

':options VALUE-LIST'
     Specify the list of reasonable values for use in this option.  The
     user is not restricted to using only these values, but they are
     offered as convenient alternatives.

     This is meaningful only for certain types, currently including
     'hook', 'plist' and 'alist'.  See the definition of the individual
     types for a description of how to use ':options'.

':set SETFUNCTION'
     Specify SETFUNCTION as the way to change the value of this option
     when using the Customize interface.  The function SETFUNCTION
     should take two arguments, a symbol (the option name) and the new
     value, and should do whatever is necessary to update the value
     properly for this option (which may not mean simply setting the
     option as a Lisp variable); preferably, though, it should not
     modify its value argument destructively.  The default for
     SETFUNCTION is 'set-default'.

     If you specify this keyword, the variable's documentation string
     should describe how to do the same job in hand-written Lisp code.

':get GETFUNCTION'
     Specify GETFUNCTION as the way to extract the value of this option.
     The function GETFUNCTION should take one argument, a symbol, and
     should return whatever customize should use as the current value
     for that symbol (which need not be the symbol's Lisp value).  The
     default is 'default-value'.

     You have to really understand the workings of Custom to use ':get'
     correctly.  It is meant for values that are treated in Custom as
     variables but are not actually stored in Lisp variables.  It is
     almost surely a mistake to specify GETFUNCTION for a value that
     really is stored in a Lisp variable.

':initialize FUNCTION'
     FUNCTION should be a function used to initialize the variable when
     the 'defcustom' is evaluated.  It should take two arguments, the
     option name (a symbol) and the value.  Here are some predefined
     functions meant for use in this way:

     'custom-initialize-set'
          Use the variable's ':set' function to initialize the variable,
          but do not reinitialize it if it is already non-void.

     'custom-initialize-default'
          Like 'custom-initialize-set', but use the function
          'set-default' to set the variable, instead of the variable's
          ':set' function.  This is the usual choice for a variable
          whose ':set' function enables or disables a minor mode; with
          this choice, defining the variable will not call the minor
          mode function, but customizing the variable will do so.

     'custom-initialize-reset'
          Always use the ':set' function to initialize the variable.  If
          the variable is already non-void, reset it by calling the
          ':set' function using the current value (returned by the
          ':get' method).  This is the default ':initialize' function.

     'custom-initialize-changed'
          Use the ':set' function to initialize the variable, if it is
          already set or has been customized; otherwise, just use
          'set-default'.

     'custom-initialize-delay'
          This function behaves like 'custom-initialize-set', but it
          delays the actual initialization to the next Emacs start.
          This should be used in files that are preloaded (or for
          autoloaded variables), so that the initialization is done in
          the run-time context rather than the build-time context.  This
          also has the side-effect that the (delayed) initialization is
          performed with the ':set' function.  *Note Building Emacs::.

':local VALUE'
     If the VALUE is 't', mark OPTION as automatically buffer-local; if
     the value is 'permanent', also set OPTIONs 'permanent-local'
     property to 't'.  *Note Creating Buffer-Local::.

':risky VALUE'
     Set the variable's 'risky-local-variable' property to VALUE (*note
     File Local Variables::).

':safe FUNCTION'
     Set the variable's 'safe-local-variable' property to FUNCTION
     (*note File Local Variables::).

':set-after VARIABLES'
     When setting variables according to saved customizations, make sure
     to set the variables VARIABLES before this one; i.e., delay setting
     this variable until after those others have been handled.  Use
     ':set-after' if setting this variable won't work properly unless
     those other variables already have their intended values.

   It is useful to specify the ':require' keyword for an option that
turns on a certain feature.  This causes Emacs to load the feature, if
it is not already loaded, whenever the option is set.  *Note Common
Keywords::.  Here is an example:

     (defcustom frobnicate-automatically nil
       "Non-nil means automatically frobnicate all buffers."
       :type 'boolean
       :require 'frobnicate-mode
       :group 'frobnicate)

   If a customization item has a type such as 'hook' or 'alist', which
supports ':options', you can add additional values to the list from
outside the 'defcustom' declaration by calling
'custom-add-frequent-value'.  For example, if you define a function
'my-lisp-mode-initialization' intended to be called from
'emacs-lisp-mode-hook', you might want to add that to the list of
reasonable values for 'emacs-lisp-mode-hook', but not by editing its
definition.  You can do it thus:

     (custom-add-frequent-value 'emacs-lisp-mode-hook
        'my-lisp-mode-initialization)

 -- Function: custom-add-frequent-value symbol value
     For the customization option SYMBOL, add VALUE to the list of
     reasonable values.

     The precise effect of adding a value depends on the customization
     type of SYMBOL.

   Internally, 'defcustom' uses the symbol property 'standard-value' to
record the expression for the standard value, 'saved-value' to record
the value saved by the user with the customization buffer, and
'customized-value' to record the value set by the user with the
customization buffer, but not saved.  *Note Symbol Properties::.  In
addition, there's 'themed-value', which is used to record the value set
by a theme (*note Custom Themes::).  These properties are lists, the car
of which is an expression that evaluates to the value.

 -- Function: custom-reevaluate-setting symbol
     This function re-evaluates the standard value of SYMBOL, which
     should be a user option declared via 'defcustom'.  If the variable
     was customized, this function re-evaluates the saved value instead.
     Then it sets the user option to that value (using the option's
     ':set' property if that is defined).

     This is useful for customizable options that are defined before
     their value could be computed correctly.  For example, during
     startup Emacs calls this function for some user options that were
     defined in pre-loaded Emacs Lisp files, but whose initial values
     depend on information available only at run-time.

 -- Function: custom-variable-p arg
     This function returns non-'nil' if ARG is a customizable variable.
     A customizable variable is either a variable that has a
     'standard-value' or 'custom-autoload' property (usually meaning it
     was declared with 'defcustom'), or an alias for another
     customizable variable.

==============================================================================
File: elisp.info,  Node: |Customization_Types|,  Next: |Applying_Customizations|,  Prev: |Variable_Definitions|,  Up: |Customization|
==============================================================================

                                                           *Customization_Types*

15.4 Customization Types
=====-------------------

When you define a user option with 'defcustom', you must specify its
"customization type".  That is a Lisp object which describes (1) which
values are legitimate and (2) how to display the value in the
customization buffer for editing.

   You specify the customization type in 'defcustom' with the ':type'
keyword.  The argument of ':type' is evaluated, but only once when the
'defcustom' is executed, so it isn't useful for the value to vary.
Normally we use a quoted constant.  For example:

     (defcustom diff-command "diff"
       "The command to use to run diff."
       :type '(string)
       :group 'diff)

   In general, a customization type is a list whose first element is a
symbol, one of the customization type names defined in the following
sections.  After this symbol come a number of arguments, depending on
the symbol.  Between the type symbol and its arguments, you can
optionally write keyword-value pairs (*note Type Keywords::).

   Some type symbols do not use any arguments; those are called "simple
types".  For a simple type, if you do not use any keyword-value pairs,
you can omit the parentheses around the type symbol.  For example just
'string' as a customization type is equivalent to '(string)'.

   All customization types are implemented as widgets; see *note
Introduction: (widget)Top, for details.

MENU

* |Simple_Types|::            Simple customization types: sexp, integer, etc.
* |Composite_Types|::         Build new types from other types or data.
* |Splicing_into_Lists|::     Splice elements into list with ':inline'.
* |Type_Keywords|::           Keyword-argument pairs in a customization type.
* |Defining_New_Types|::      Give your type a name.

==============================================================================
File: elisp.info,  Node: |Simple_Types|,  Next: |Composite_Types|,  Up: |Customization_Types|
==============================================================================

                                                                  *Simple_Types*

15.4.1 Simple Types
-------------------

This section describes all the simple customization types.  For several
of these customization types, the customization widget provides inline
completion with 'C-M-i' or 'M-<TAB>'.

'sexp'
     The value may be any Lisp object that can be printed and read back.
     You can use 'sexp' as a fall-back for any option, if you don't want
     to take the time to work out a more specific type to use.

'integer'
     The value must be an integer.

'number'
     The value must be a number (floating point or integer).

'float'
     The value must be floating point.

'string'
     The value must be a string.  The customization buffer shows the
     string without delimiting '"' characters or '\' quotes.

'regexp'
     Like 'string' except that the string must be a valid regular
     expression.

'character'
     The value must be a character code.  A character code is actually
     an integer, but this type shows the value by inserting the
     character in the buffer, rather than by showing the number.

'file'
     The value must be a file name.  The widget provides completion.

'(file :must-match t)'
     The value must be a file name for an existing file.  The widget
     provides completion.

'directory'
     The value must be a directory.  The widget provides completion.

'hook'
     The value must be a list of functions.  This customization type is
     used for hook variables.  You can use the ':options' keyword in a
     hook variable's 'defcustom' to specify a list of functions
     recommended for use in the hook; *Note Variable Definitions::.

'symbol'
     The value must be a symbol.  It appears in the customization buffer
     as the symbol name.  The widget provides completion.

'function'
     The value must be either a lambda expression or a function name.
     The widget provides completion for function names.

'variable'
     The value must be a variable name.  The widget provides completion.

'face'
     The value must be a symbol which is a face name.  The widget
     provides completion.

'boolean'
     The value is boolean--either 'nil' or 't'.  Note that by using
     'choice' and 'const' together (see the next section), you can
     specify that the value must be 'nil' or 't', but also specify the
     text to describe each value in a way that fits the specific meaning
     of the alternative.

'key-sequence'
     The value is a key sequence.  The customization buffer shows the
     key sequence using the same syntax as the 'kbd' function.  *Note
     Key Sequences::.

'coding-system'
     The value must be a coding-system name, and you can do completion
     with 'M-<TAB>'.

'color'
     The value must be a valid color name.  The widget provides
     completion for color names, as well as a sample and a button for
     selecting a color name from a list of color names shown in a
     'Colors' buffer.

==============================================================================
File: elisp.info,  Node: |Composite_Types|,  Next: |Splicing_into_Lists|,  Prev: |Simple_Types|,  Up: |Customization_Types|
==============================================================================

                                                               *Composite_Types*

15.4.2 Composite Types
----------------------

When none of the simple types is appropriate, you can use composite
types, which build new types from other types or from specified data.
The specified types or data are called the "arguments" of the composite
type.  The composite type normally looks like this:

     (CONSTRUCTOR ARGUMENTS...)

but you can also add keyword-value pairs before the arguments, like
this:

     (CONSTRUCTOR {KEYWORD VALUE}... ARGUMENTS...)

   Here is a table of constructors and how to use them to write
composite types:

'(cons CAR-TYPE CDR-TYPE)'
     The value must be a cons cell, its CAR must fit CAR-TYPE, and its
     CDR must fit CDR-TYPE.  For example, '(cons string symbol)' is a
     customization type which matches values such as '("foo" . foo)'.

     In the customization buffer, the CAR and CDR are displayed and
     edited separately, each according to their specified type.

'(list ELEMENT-TYPES...)'
     The value must be a list with exactly as many elements as the
     ELEMENT-TYPES given; and each element must fit the corresponding
     ELEMENT-TYPE.

     For example, '(list integer string function)' describes a list of
     three elements; the first element must be an integer, the second a
     string, and the third a function.

     In the customization buffer, each element is displayed and edited
     separately, according to the type specified for it.

'(group ELEMENT-TYPES...)'
     This works like 'list' except for the formatting of text in the
     Custom buffer.  'list' labels each element value with its tag;
     'group' does not.

'(vector ELEMENT-TYPES...)'
     Like 'list' except that the value must be a vector instead of a
     list.  The elements work the same as in 'list'.

'(alist :key-type KEY-TYPE :value-type VALUE-TYPE)'
     The value must be a list of cons-cells, the CAR of each cell
     representing a key of customization type KEY-TYPE, and the CDR of
     the same cell representing a value of customization type
     VALUE-TYPE.  The user can add and delete key/value pairs, and edit
     both the key and the value of each pair.

     If omitted, KEY-TYPE and VALUE-TYPE default to 'sexp'.

     The user can add any key matching the specified key type, but you
     can give some keys a preferential treatment by specifying them with
     the ':options' (see *note Variable Definitions::).  The specified
     keys will always be shown in the customize buffer (together with a
     suitable value), with a checkbox to include or exclude or disable
     the key/value pair from the alist.  The user will not be able to
     edit the keys specified by the ':options' keyword argument.

     The argument to the ':options' keywords should be a list of
     specifications for reasonable keys in the alist.  Ordinarily, they
     are simply atoms, which stand for themselves.  For example:

          :options '("foo" "bar" "baz")

     specifies that there are three known keys, namely '"foo"', '"bar"'
     and '"baz"', which will always be shown first.

     You may want to restrict the value type for specific keys, for
     example, the value associated with the '"bar"' key can only be an
     integer.  You can specify this by using a list instead of an atom
     in the list.  The first element will specify the key, like before,
     while the second element will specify the value type.  For example:

          :options '("foo" ("bar" integer) "baz")

     Finally, you may want to change how the key is presented.  By
     default, the key is simply shown as a 'const', since the user
     cannot change the special keys specified with the ':options'
     keyword.  However, you may want to use a more specialized type for
     presenting the key, like 'function-item' if you know it is a symbol
     with a function binding.  This is done by using a customization
     type specification instead of a symbol for the key.

          :options '("foo"
                     ((function-item some-function) integer)
                     "baz")

     Many alists use lists with two elements, instead of cons cells.
     For example,

          (defcustom list-alist
            '(("foo" 1) ("bar" 2) ("baz" 3))
            "Each element is a list of the form (KEY VALUE).")

     instead of

          (defcustom cons-alist
            '(("foo" . 1) ("bar" . 2) ("baz" . 3))
            "Each element is a cons-cell (KEY . VALUE).")

     Because of the way lists are implemented on top of cons cells, you
     can treat 'list-alist' in the example above as a cons cell alist,
     where the value type is a list with a single element containing the
     real value.

          (defcustom list-alist '(("foo" 1) ("bar" 2) ("baz" 3))
            "Each element is a list of the form (KEY VALUE)."
            :type '(alist :value-type (group integer)))

     The 'group' widget is used here instead of 'list' only because the
     formatting is better suited for the purpose.

     Similarly, you can have alists with more values associated with
     each key, using variations of this trick:

          (defcustom person-data '(("brian"  50 t)
                                   ("dorith" 55 nil)
                                   ("ken"    52 t))
            "Alist of basic info about people.
          Each element has the form (NAME AGE MALE-FLAG)."
            :type '(alist :value-type (group integer boolean)))

'(plist :key-type KEY-TYPE :value-type VALUE-TYPE)'
     This customization type is similar to 'alist' (see above), except
     that (i) the information is stored as a property list, (*note
     Property Lists::), and (ii) KEY-TYPE, if omitted, defaults to
     'symbol' rather than 'sexp'.

'(choice ALTERNATIVE-TYPES...)'
     The value must fit one of ALTERNATIVE-TYPES.  For example, '(choice
     integer string)' allows either an integer or a string.

     In the customization buffer, the user selects an alternative using
     a menu, and can then edit the value in the usual way for that
     alternative.

     Normally the strings in this menu are determined automatically from
     the choices; however, you can specify different strings for the
     menu by including the ':tag' keyword in the alternatives.  For
     example, if an integer stands for a number of spaces, while a
     string is text to use verbatim, you might write the customization
     type this way,

          (choice (integer :tag "Number of spaces")
                  (string :tag "Literal text"))

     so that the menu offers 'Number of spaces' and 'Literal text'.

     In any alternative for which 'nil' is not a valid value, other than
     a 'const', you should specify a valid default for that alternative
     using the ':value' keyword.  *Note Type Keywords::.

     If some values are covered by more than one of the alternatives,
     customize will choose the first alternative that the value fits.
     This means you should always list the most specific types first,
     and the most general last.  Here's an example of proper usage:

          (choice (const :tag "Off" nil)
                  symbol (sexp :tag "Other"))

     This way, the special value 'nil' is not treated like other
     symbols, and symbols are not treated like other Lisp expressions.

'(radio ELEMENT-TYPES...)'
     This is similar to 'choice', except that the choices are displayed
     using radio buttons rather than a menu.  This has the advantage of
     displaying documentation for the choices when applicable and so is
     often a good choice for a choice between constant functions
     ('function-item' customization types).

'(const VALUE)'
     The value must be VALUE--nothing else is allowed.

     The main use of 'const' is inside of 'choice'.  For example,
     '(choice integer (const nil))' allows either an integer or 'nil'.

     ':tag' is often used with 'const', inside of 'choice'.  For
     example,

          (choice (const :tag "Yes" t)
                  (const :tag "No" nil)
                  (const :tag "Ask" foo))

     describes a variable for which 't' means yes, 'nil' means no, and
     'foo' means "ask".

'(other VALUE)'
     This alternative can match any Lisp value, but if the user chooses
     this alternative, that selects the value VALUE.

     The main use of 'other' is as the last element of 'choice'.  For
     example,

          (choice (const :tag "Yes" t)
                  (const :tag "No" nil)
                  (other :tag "Ask" foo))

     describes a variable for which 't' means yes, 'nil' means no, and
     anything else means "ask".  If the user chooses 'Ask' from the menu
     of alternatives, that specifies the value 'foo'; but any other
     value (not 't', 'nil' or 'foo') displays as 'Ask', just like 'foo'.

'(function-item FUNCTION)'
     Like 'const', but used for values which are functions.  This
     displays the documentation string as well as the function name.
     The documentation string is either the one you specify with ':doc',
     or FUNCTION's own documentation string.

'(variable-item VARIABLE)'
     Like 'const', but used for values which are variable names.  This
     displays the documentation string as well as the variable name.
     The documentation string is either the one you specify with ':doc',
     or VARIABLE's own documentation string.

'(set TYPES...)'
     The value must be a list, and each element of the list must match
     one of the TYPES specified.

     This appears in the customization buffer as a checklist, so that
     each of TYPES may have either one corresponding element or none.
     It is not possible to specify two different elements that match the
     same one of TYPES.  For example, '(set integer symbol)' allows one
     integer and/or one symbol in the list; it does not allow multiple
     integers or multiple symbols.  As a result, it is rare to use
     nonspecific types such as 'integer' in a 'set'.

     Most often, the TYPES in a 'set' are 'const' types, as shown here:

          (set (const :bold) (const :italic))

     Sometimes they describe possible elements in an alist:

          (set (cons :tag "Height" (const height) integer)
               (cons :tag "Width" (const width) integer))

     That lets the user specify a height value optionally and a width
     value optionally.

'(repeat ELEMENT-TYPE)'
     The value must be a list and each element of the list must fit the
     type ELEMENT-TYPE.  This appears in the customization buffer as a
     list of elements, with '[INS]' and '[DEL]' buttons for adding more
     elements or removing elements.

'(restricted-sexp :match-alternatives CRITERIA)'
     This is the most general composite type construct.  The value may
     be any Lisp object that satisfies one of CRITERIA.  CRITERIA should
     be a list, and each element should be one of these possibilities:

        * A predicate--that is, a function of one argument that returns
          either 'nil' or non-'nil' according to the argument.  Using a
          predicate in the list says that objects for which the
          predicate returns non-'nil' are acceptable.

        * A quoted constant--that is, ''OBJECT'.  This sort of element in
          the list says that OBJECT itself is an acceptable value.

     For example,

          (restricted-sexp :match-alternatives
                           (integerp 't 'nil))

     allows integers, 't' and 'nil' as legitimate values.

     The customization buffer shows all legitimate values using their
     read syntax, and the user edits them textually.

   Here is a table of the keywords you can use in keyword-value pairs in
a composite type:

':tag TAG'
     Use TAG as the name of this alternative, for user communication
     purposes.  This is useful for a type that appears inside of a
     'choice'.

':match-alternatives CRITERIA'
     Use CRITERIA to match possible values.  This is used only in
     'restricted-sexp'.

':args ARGUMENT-LIST'
     Use the elements of ARGUMENT-LIST as the arguments of the type
     construct.  For instance, '(const :args (foo))' is equivalent to
     '(const foo)'.  You rarely need to write ':args' explicitly,
     because normally the arguments are recognized automatically as
     whatever follows the last keyword-value pair.

==============================================================================
File: elisp.info,  Node: |Splicing_into_Lists|,  Next: |Type_Keywords|,  Prev: |Composite_Types|,  Up: |Customization_Types|
==============================================================================

                                                           *Splicing_into_Lists*

15.4.3 Splicing into Lists
--------------------------

The ':inline' feature lets you splice a variable number of elements into
the middle of a 'list' or 'vector' customization type.  You use it by
adding ':inline t' to a type specification which is contained in a
'list' or 'vector' specification.

   Normally, each entry in a 'list' or 'vector' type specification
describes a single element type.  But when an entry contains ':inline
t', the value it matches is merged directly into the containing
sequence.  For example, if the entry matches a list with three elements,
those become three elements of the overall sequence.  This is analogous
to ',@' in a backquote construct (*note Backquote::).

   For example, to specify a list whose first element must be 'baz' and
whose remaining arguments should be zero or more of 'foo' and 'bar', use
this customization type:

     (list (const baz) (set :inline t (const foo) (const bar)))

This matches values such as '(baz)', '(baz foo)', '(baz bar)' and '(baz
foo bar)'.

   When the element-type is a 'choice', you use ':inline' not in the
'choice' itself, but in (some of) the alternatives of the 'choice'.  For
example, to match a list which must start with a file name, followed
either by the symbol 't' or two strings, use this customization type:

     (list file
           (choice (const t)
                   (list :inline t string string)))

If the user chooses the first alternative in the choice, then the
overall list has two elements and the second element is 't'.  If the
user chooses the second alternative, then the overall list has three
elements and the second and third must be strings.

   The widgets can specify predicates to say whether an inline value
matches the widget with the ':match-inline' element.

==============================================================================
File: elisp.info,  Node: |Type_Keywords|,  Next: |Defining_New_Types|,  Prev: |Splicing_into_Lists|,  Up: |Customization_Types|
==============================================================================

                                                                 *Type_Keywords*

15.4.4 Type Keywords
--------------------

You can specify keyword-argument pairs in a customization type after the
type name symbol.  Here are the keywords you can use, and their
meanings:

':value DEFAULT'
     Provide a default value.

     If 'nil' is not a valid value for the alternative, then it is
     essential to specify a valid default with ':value'.

     If you use this for a type that appears as an alternative inside of
     'choice'; it specifies the default value to use, at first, if and
     when the user selects this alternative with the menu in the
     customization buffer.

     Of course, if the actual value of the option fits this alternative,
     it will appear showing the actual value, not DEFAULT.

':format FORMAT-STRING'
     This string will be inserted in the buffer to represent the value
     corresponding to the type.  The following '%' escapes are available
     for use in FORMAT-STRING:

     '%[BUTTON%]'
          Display the text BUTTON marked as a button.  The ':action'
          attribute specifies what the button will do if the user
          invokes it; its value is a function which takes two
          arguments--the widget which the button appears in, and the
          event.

          There is no way to specify two different buttons with
          different actions.

     '%{SAMPLE%}'
          Show SAMPLE in a special face specified by ':sample-face'.

     '%v'
          Substitute the item's value.  How the value is represented
          depends on the kind of item, and (for variables) on the
          customization type.

     '%d'
          Substitute the item's documentation string.

     '%h'
          Like '%d', but if the documentation string is more than one
          line, add a button to control whether to show all of it or
          just the first line.

     '%t'
          Substitute the tag here.  You specify the tag with the ':tag'
          keyword.

     '%%'
          Display a literal '%'.

':action ACTION'
     Perform ACTION if the user clicks on a button.

':button-face FACE'
     Use the face FACE (a face name or a list of face names) for button
     text displayed with '%[...%]'.

':button-prefix PREFIX'
':button-suffix SUFFIX'
     These specify the text to display before and after a button.  Each
     can be:

     'nil'
          No text is inserted.

     a string
          The string is inserted literally.

     a symbol
          The symbol's value is used.

':tag TAG'
     Use TAG (a string) as the tag for the value (or part of the value)
     that corresponds to this type.

':doc DOC'
     Use DOC as the documentation string for this value (or part of the
     value) that corresponds to this type.  In order for this to work,
     you must specify a value for ':format', and use '%d' or '%h' in
     that value.

     The usual reason to specify a documentation string for a type is to
     provide more information about the meanings of alternatives inside
     a 'choice' type or the parts of some other composite type.

':help-echo MOTION-DOC'
     When you move to this item with 'widget-forward' or
     'widget-backward', it will display the string MOTION-DOC in the
     echo area.  In addition, MOTION-DOC is used as the mouse
     'help-echo' string and may actually be a function or form evaluated
     to yield a help string.  If it is a function, it is called with one
     argument, the widget.

':match FUNCTION'
     Specify how to decide whether a value matches the type.  The
     corresponding value, FUNCTION, should be a function that accepts
     two arguments, a widget and a value; it should return non-'nil' if
     the value is acceptable.

':match-inline FUNCTION'
     Specify how to decide whether an inline value matches the type.
     The corresponding value, FUNCTION, should be a function that
     accepts two arguments, a widget and an inline value; it should
     return non-'nil' if the value is acceptable.  See *note Splicing
     into Lists:: for more information about inline values.

':validate FUNCTION'
     Specify a validation function for input.  FUNCTION takes a widget
     as an argument, and should return 'nil' if the widget's current
     value is valid for the widget.  Otherwise, it should return the
     widget containing the invalid data, and set that widget's ':error'
     property to a string explaining the error.

==============================================================================
File: elisp.info,  Node: |Defining_New_Types|,  Prev: |Type_Keywords|,  Up: |Customization_Types|
==============================================================================

                                                            *Defining_New_Types*

15.4.5 Defining New Types
-------------------------

In the previous sections we have described how to construct elaborate
type specifications for 'defcustom'.  In some cases you may want to give
such a type specification a name.  The obvious case is when you are
using the same type for many user options: rather than repeat the
specification for each option, you can give the type specification a
name, and use that name each 'defcustom'.  The other case is when a user
option's value is a recursive data structure.  To make it possible for a
datatype to refer to itself, it needs to have a name.

   Since custom types are implemented as widgets, the way to define a
new customize type is to define a new widget.  We are not going to
describe the widget interface here in details, see *note Introduction:
(widget)Top, for that.  Instead we are going to demonstrate the minimal
functionality needed for defining new customize types by a simple
example.

     (define-widget 'binary-tree-of-string 'lazy
       "A binary tree made of cons-cells and strings."
       :offset 4
       :tag "Node"
       :type '(choice (string :tag "Leaf" :value "")
                      (cons :tag "Interior"
                            :value ("" . "")
                            binary-tree-of-string
                            binary-tree-of-string)))

     (defcustom foo-bar ""
       "Sample variable holding a binary tree of strings."
       :type 'binary-tree-of-string)

   The function to define a new widget is called 'define-widget'.  The
first argument is the symbol we want to make a new widget type.  The
second argument is a symbol representing an existing widget, the new
widget is going to be defined in terms of difference from the existing
widget.  For the purpose of defining new customization types, the 'lazy'
widget is perfect, because it accepts a ':type' keyword argument with
the same syntax as the keyword argument to 'defcustom' with the same
name.  The third argument is a documentation string for the new widget.
You will be able to see that string with the 'M-x widget-browse <RET>
binary-tree-of-string <RET>' command.

   After these mandatory arguments follow the keyword arguments.  The
most important is ':type', which describes the data type we want to
match with this widget.  Here a 'binary-tree-of-string' is described as
being either a string, or a cons-cell whose car and cdr are themselves
both 'binary-tree-of-string'.  Note the reference to the widget type we
are currently in the process of defining.  The ':tag' attribute is a
string to name the widget in the user interface, and the ':offset'
argument is there to ensure that child nodes are indented four spaces
relative to the parent node, making the tree structure apparent in the
customization buffer.

   The 'defcustom' shows how the new widget can be used as an ordinary
customization type.

   The reason for the name 'lazy' is that the other composite widgets
convert their inferior widgets to internal form when the widget is
instantiated in a buffer.  This conversion is recursive, so the inferior
widgets will convert _their_ inferior widgets.  If the data structure is
itself recursive, this conversion is an infinite recursion.  The 'lazy'
widget prevents the recursion: it convert its ':type' argument only when
needed.

==============================================================================
File: elisp.info,  Node: |Applying_Customizations|,  Next: |Custom_Themes|,  Prev: |Customization_Types|,  Up: |Customization|
==============================================================================

                                                       *Applying_Customizations*

15.5 Applying Customizations
=====-----------------------

The following functions are responsible for installing the user's
customization settings for variables and faces, respectively.  When the
user invokes 'Save for future sessions' in the Customize interface, that
takes effect by writing a 'custom-set-variables' and/or a
'custom-set-faces' form into the custom file, to be evaluated the next
time Emacs starts.

 -- Function: custom-set-variables &rest args
     This function installs the variable customizations specified by
     ARGS.  Each argument in ARGS should have the form

          (VAR EXPRESSION [NOW [REQUEST [COMMENT]]])

     VAR is a variable name (a symbol), and EXPRESSION is an expression
     which evaluates to the desired customized value.

     If the 'defcustom' form for VAR has been evaluated prior to this
     'custom-set-variables' call, EXPRESSION is immediately evaluated,
     and the variable's value is set to the result.  Otherwise,
     EXPRESSION is stored into the variable's 'saved-value' property, to
     be evaluated when the relevant 'defcustom' is called (usually when
     the library defining that variable is loaded into Emacs).

     The NOW, REQUEST, and COMMENT entries are for internal use only,
     and may be omitted.  NOW, if non-'nil', means to set the variable's
     value now, even if the variable's 'defcustom' form has not been
     evaluated.  REQUEST is a list of features to be loaded immediately
     (*note Named Features::).  COMMENT is a string describing the
     customization.

 -- Function: custom-set-faces &rest args
     This function installs the face customizations specified by ARGS.
     Each argument in ARGS should have the form

          (FACE SPEC [NOW [COMMENT]])

     FACE is a face name (a symbol), and SPEC is the customized face
     specification for that face (*note Defining Faces::).

     The NOW and COMMENT entries are for internal use only, and may be
     omitted.  NOW, if non-'nil', means to install the face
     specification now, even if the 'defface' form has not been
     evaluated.  COMMENT is a string describing the customization.

==============================================================================
File: elisp.info,  Node: |Custom_Themes|,  Prev: |Applying_Customizations|,  Up: |Customization|
==============================================================================

                                                                 *Custom_Themes*

15.6 Custom Themes
=====-------------

"Custom themes" are collections of settings that can be enabled or
disabled as a unit.  *Note (emacs)Custom Themes::.  Each Custom theme is
defined by an Emacs Lisp source file, which should follow the
conventions described in this section.  (Instead of writing a Custom
theme by hand, you can also create one using a Customize-like interface;
*note (emacs)Creating Custom Themes::.)

   A Custom theme file should be named 'FOO-theme.el', where FOO is the
theme name.  The first Lisp form in the file should be a call to
'deftheme', and the last form should be a call to 'provide-theme'.

 -- Macro: deftheme theme &optional doc
     This macro declares THEME (a symbol) as the name of a Custom theme.
     The optional argument DOC should be a string describing the theme;
     this is the description shown when the user invokes the
     'describe-theme' command or types '?' in the '*Custom Themes*'
     buffer.

     Two special theme names are disallowed (using them causes an
     error): 'user' is a dummy theme that stores the user's direct
     customization settings, and 'changed' is a dummy theme that stores
     changes made outside of the Customize system.

 -- Macro: provide-theme theme
     This macro declares that the theme named THEME has been fully
     specified.

   In between 'deftheme' and 'provide-theme' are Lisp forms specifying
the theme settings: usually a call to 'custom-theme-set-variables'
and/or a call to 'custom-theme-set-faces'.

 -- Function: custom-theme-set-variables theme &rest args
     This function specifies the Custom theme THEME's variable settings.
     THEME should be a symbol.  Each argument in ARGS should be a list
     of the form

          (VAR EXPRESSION [NOW [REQUEST [COMMENT]]])

     where the list entries have the same meanings as in
     'custom-set-variables'.  *Note Applying Customizations::.

 -- Function: custom-theme-set-faces theme &rest args
     This function specifies the Custom theme THEME's face settings.
     THEME should be a symbol.  Each argument in ARGS should be a list
     of the form

          (FACE SPEC [NOW [COMMENT]])

     where the list entries have the same meanings as in
     'custom-set-faces'.  *Note Applying Customizations::.

   In theory, a theme file can also contain other Lisp forms, which
would be evaluated when loading the theme, but that is bad form.  To
protect against loading themes containing malicious code, Emacs displays
the source file and asks for confirmation from the user before loading
any non-built-in theme for the first time.  As such, themes are not
ordinarily byte-compiled, and source files always take precedence when
Emacs is looking for a theme to load.

   The following functions are useful for programmatically enabling and
disabling themes:

 -- Function: custom-theme-p theme
     This function return a non-'nil' value if THEME (a symbol) is the
     name of a Custom theme (i.e., a Custom theme which has been loaded
     into Emacs, whether or not the theme is enabled).  Otherwise, it
     returns 'nil'.

 -- Variable: custom-known-themes
     The value of this variable is a list of themes loaded into Emacs.
     Each theme is represented by a Lisp symbol (the theme name).  The
     default value of this variable is a list containing two dummy
     themes: '(user changed)'.  The 'changed' theme stores settings made
     before any Custom themes are applied (e.g., variables set outside
     of Customize).  The 'user' theme stores settings the user has
     customized and saved.  Any additional themes declared with the
     'deftheme' macro are added to the front of this list.

 -- Command: load-theme theme &optional no-confirm no-enable
     This function loads the Custom theme named THEME from its source
     file, looking for the source file in the directories specified by
     the variable 'custom-theme-load-path'.  *Note (emacs)Custom
     Themes::.  It also "enables" the theme (unless the optional
     argument NO-ENABLE is non-'nil'), causing its variable and face
     settings to take effect.  It prompts the user for confirmation
     before loading the theme, unless the optional argument NO-CONFIRM
     is non-'nil'.

 -- Command: enable-theme theme
     This function enables the Custom theme named THEME.  It signals an
     error if no such theme has been loaded.

 -- Command: disable-theme theme
     This function disables the Custom theme named THEME.  The theme
     remains loaded, so that a subsequent call to 'enable-theme' will
     re-enable it.

==============================================================================
File: elisp.info,  Node: |Loading|,  Next: |Byte_Compilation|,  Prev: |Customization|,  Up: |Top|
==============================================================================

                                                                       *Loading*

16 Loading
*****=====

Loading a file of Lisp code means bringing its contents into the Lisp
environment in the form of Lisp objects.  Emacs finds and opens the
file, reads the text, evaluates each form, and then closes the file.
Such a file is also called a "Lisp library".

   The load functions evaluate all the expressions in a file just as the
'eval-buffer' function evaluates all the expressions in a buffer.  The
difference is that the load functions read and evaluate the text in the
file as found on disk, not the text in an Emacs buffer.

   The loaded file must contain Lisp expressions, either as source code
or as byte-compiled code.  Each form in the file is called a "top-level
form".  There is no special format for the forms in a loadable file; any
form in a file may equally well be typed directly into a buffer and
evaluated there.  (Indeed, most code is tested this way.)  Most often,
the forms are function definitions and variable definitions.

   Emacs can also load compiled dynamic modules: shared libraries that
provide additional functionality for use in Emacs Lisp programs, just
like a package written in Emacs Lisp would.  When a dynamic module is
loaded, Emacs calls a specially-named initialization function which the
module needs to implement, and which exposes the additional functions
and variables to Emacs Lisp programs.

   For on-demand loading of external libraries which are known in
advance to be required by certain Emacs primitives, *note Dynamic
Libraries::.

MENU

* |How_Programs_Do_Loading|:: The 'load' function and others.
* |Load_Suffixes|::           Details about the suffixes that 'load' tries.
* |Library_Search|::          Finding a library to load.
* |Loading_Non_ASCII|::       Non-ASCII characters in Emacs Lisp files.
* |Autoload|::                Setting up a function to autoload.
* |Repeated_Loading|::        Precautions about loading a file twice.
* |Named_Features|::          Loading a library if it isn't already loaded.
* |Where_Defined|::           Finding which file defined a certain symbol.
* |Unloading|::               How to unload a library that was loaded.
* |Hooks_for_Loading|::       Providing code to be run when
                              particular libraries are loaded.
* |Dynamic_Modules|::         Modules provide additional Lisp primitives.

==============================================================================
File: elisp.info,  Node: |How_Programs_Do_Loading|,  Next: |Load_Suffixes|,  Up: |Loading|
==============================================================================

                                                       *How_Programs_Do_Loading*

16.1 How Programs Do Loading
=====-----------------------

Emacs Lisp has several interfaces for loading.  For example, 'autoload'
creates a placeholder object for a function defined in a file; trying to
call the autoloading function loads the file to get the function's real
definition (*note Autoload::).  'require' loads a file if it isn't
already loaded (*note Named Features::).  Ultimately, all these
facilities call the 'load' function to do the work.

 -- Function: load filename &optional missing-ok nomessage nosuffix
          must-suffix
     This function finds and opens a file of Lisp code, evaluates all
     the forms in it, and closes the file.

     To find the file, 'load' first looks for a file named
     'FILENAME.elc', that is, for a file whose name is FILENAME with the
     extension '.elc' appended.  If such a file exists, it is loaded.
     If there is no file by that name, then 'load' looks for a file
     named 'FILENAME.el'.  If that file exists, it is loaded.  If Emacs
     was compiled with support for dynamic modules (*note Dynamic
     Modules::), 'load' next looks for a file named 'FILENAME.EXT',
     where EXT is a system-dependent file-name extension of shared
     libraries.  Finally, if neither of those names is found, 'load'
     looks for a file named FILENAME with nothing appended, and loads it
     if it exists.  (The 'load' function is not clever about looking at
     FILENAME.  In the perverse case of a file named 'foo.el.el',
     evaluation of '(load "foo.el")' will indeed find it.)

     If Auto Compression mode is enabled, as it is by default, then if
     'load' can not find a file, it searches for a compressed version of
     the file before trying other file names.  It decompresses and loads
     it if it exists.  It looks for compressed versions by appending
     each of the suffixes in 'jka-compr-load-suffixes' to the file name.
     The value of this variable must be a list of strings.  Its standard
     value is '(".gz")'.

     If the optional argument NOSUFFIX is non-'nil', then 'load' does
     not try the suffixes '.elc' and '.el'.  In this case, you must
     specify the precise file name you want, except that, if Auto
     Compression mode is enabled, 'load' will still use
     'jka-compr-load-suffixes' to find compressed versions.  By
     specifying the precise file name and using 't' for NOSUFFIX, you
     can prevent file names like 'foo.el.el' from being tried.

     If the optional argument MUST-SUFFIX is non-'nil', then 'load'
     insists that the file name used must end in either '.el' or '.elc'
     (possibly extended with a compression suffix) or the shared-library
     extension, unless it contains an explicit directory name.

     If the option 'load-prefer-newer' is non-'nil', then when searching
     suffixes, 'load' selects whichever version of a file ('.elc',
     '.el', etc.) has been modified most recently.

     If FILENAME is a relative file name, such as 'foo' or
     'baz/foo.bar', 'load' searches for the file using the variable
     'load-path'.  It appends FILENAME to each of the directories listed
     in 'load-path', and loads the first file it finds whose name
     matches.  The current default directory is tried only if it is
     specified in 'load-path', where 'nil' stands for the default
     directory.  'load' tries all three possible suffixes in the first
     directory in 'load-path', then all three suffixes in the second
     directory, and so on.  *Note Library Search::.

     Whatever the name under which the file is eventually found, and the
     directory where Emacs found it, Emacs sets the value of the
     variable 'load-file-name' to that file's name.

     If you get a warning that 'foo.elc' is older than 'foo.el', it
     means you should consider recompiling 'foo.el'.  *Note Byte
     Compilation::.

     When loading a source file (not compiled), 'load' performs
     character set translation just as Emacs would do when visiting the
     file.  *Note Coding Systems::.

     When loading an uncompiled file, Emacs tries to expand any macros
     that the file contains (*note Macros::).  We refer to this as
     "eager macro expansion".  Doing this (rather than deferring the
     expansion until the relevant code runs) can significantly speed up
     the execution of uncompiled code.  Sometimes, this macro expansion
     cannot be done, owing to a cyclic dependency.  In the simplest
     example of this, the file you are loading refers to a macro defined
     in another file, and that file in turn requires the file you are
     loading.  This is generally harmless.  Emacs prints a warning
     ('Eager macro-expansion skipped due to cycle...') giving details of
     the problem, but it still loads the file, just leaving the macro
     unexpanded for now.  You may wish to restructure your code so that
     this does not happen.  Loading a compiled file does not cause
     macroexpansion, because this should already have happened during
     compilation.  *Note Compiling Macros::.

     Messages like 'Loading foo...' and 'Loading foo...done' appear in
     the echo area during loading unless NOMESSAGE is non-'nil'.

     Any unhandled errors while loading a file terminate loading.  If
     the load was done for the sake of 'autoload', any function
     definitions made during the loading are undone.

     If 'load' can't find the file to load, then normally it signals a
     'file-error' (with 'Cannot open load file FILENAME').  But if
     MISSING-OK is non-'nil', then 'load' just returns 'nil'.

     You can use the variable 'load-read-function' to specify a function
     for 'load' to use instead of 'read' for reading expressions.  See
     below.

     'load' returns 't' if the file loads successfully.

 -- Command: load-file filename
     This command loads the file FILENAME.  If FILENAME is a relative
     file name, then the current default directory is assumed.  This
     command does not use 'load-path', and does not append suffixes.
     However, it does look for compressed versions (if Auto Compression
     Mode is enabled).  Use this command if you wish to specify
     precisely the file name to load.

 -- Command: load-library library
     This command loads the library named LIBRARY.  It is equivalent to
     'load', except for the way it reads its argument interactively.
     *Note (emacs)Lisp Libraries::.

 -- Variable: load-in-progress
     This variable is non-'nil' if Emacs is in the process of loading a
     file, and it is 'nil' otherwise.

 -- Variable: load-file-name
     When Emacs is in the process of loading a file, this variable's
     value is the name of that file, as Emacs found it during the search
     described earlier in this section.

 -- Variable: load-read-function
     This variable specifies an alternate expression-reading function
     for 'load' and 'eval-region' to use instead of 'read'.  The
     function should accept one argument, just as 'read' does.

     By default, this variable's value is 'read'.  *Note Input
     Functions::.

     Instead of using this variable, it is cleaner to use another, newer
     feature: to pass the function as the READ-FUNCTION argument to
     'eval-region'.  *Note Eval: Definition of eval-region.

   For information about how 'load' is used in building Emacs, see *note
Building Emacs::.

==============================================================================
File: elisp.info,  Node: |Load_Suffixes|,  Next: |Library_Search|,  Prev: |How_Programs_Do_Loading|,  Up: |Loading|
==============================================================================

                                                                 *Load_Suffixes*

16.2 Load Suffixes
=====-------------

We now describe some technical details about the exact suffixes that
'load' tries.

 -- Variable: load-suffixes
     This is a list of suffixes indicating (compiled or source) Emacs
     Lisp files.  It should not include the empty string.  'load' uses
     these suffixes in order when it appends Lisp suffixes to the
     specified file name.  The standard value is '(".elc" ".el")' which
     produces the behavior described in the previous section.

 -- Variable: load-file-rep-suffixes
     This is a list of suffixes that indicate representations of the
     same file.  This list should normally start with the empty string.
     When 'load' searches for a file it appends the suffixes in this
     list, in order, to the file name, before searching for another
     file.

     Enabling Auto Compression mode appends the suffixes in
     'jka-compr-load-suffixes' to this list and disabling Auto
     Compression mode removes them again.  The standard value of
     'load-file-rep-suffixes' if Auto Compression mode is disabled is
     '("")'.  Given that the standard value of 'jka-compr-load-suffixes'
     is '(".gz")', the standard value of 'load-file-rep-suffixes' if
     Auto Compression mode is enabled is '("" ".gz")'.

 -- Function: get-load-suffixes
     This function returns the list of all suffixes that 'load' should
     try, in order, when its MUST-SUFFIX argument is non-'nil'.  This
     takes both 'load-suffixes' and 'load-file-rep-suffixes' into
     account.  If 'load-suffixes', 'jka-compr-load-suffixes' and
     'load-file-rep-suffixes' all have their standard values, this
     function returns '(".elc" ".elc.gz" ".el" ".el.gz")' if Auto
     Compression mode is enabled and '(".elc" ".el")' if Auto
     Compression mode is disabled.

   To summarize, 'load' normally first tries the suffixes in the value
of '(get-load-suffixes)' and then those in 'load-file-rep-suffixes'.  If
NOSUFFIX is non-'nil', it skips the former group, and if MUST-SUFFIX is
non-'nil', it skips the latter group.

 -- User Option: load-prefer-newer
     If this option is non-'nil', then rather than stopping at the first
     suffix that exists, 'load' tests them all, and uses whichever file
     is the newest.

==============================================================================
File: elisp.info,  Node: |Library_Search|,  Next: |Loading_Non_ASCII|,  Prev: |Load_Suffixes|,  Up: |Loading|
==============================================================================

                                                                *Library_Search*

16.3 Library Search
=====--------------

When Emacs loads a Lisp library, it searches for the library in a list
of directories specified by the variable 'load-path'.

 -- Variable: load-path
     The value of this variable is a list of directories to search when
     loading files with 'load'.  Each element is a string (which must be
     a directory) or 'nil' (which stands for the current working
     directory).

   When Emacs starts up, it sets up the value of 'load-path' in several
steps.  First, it initializes 'load-path' using default locations set
when Emacs was compiled.  Normally, this is a directory something like

     "/usr/local/share/emacs/VERSION/lisp"

   (In this and the following examples, replace '/usr/local' with the
installation prefix appropriate for your Emacs.)  These directories
contain the standard Lisp files that come with Emacs.  If Emacs cannot
find them, it will not start correctly.

   If you run Emacs from the directory where it was built--that is, an
executable that has not been formally installed--Emacs instead
initializes 'load-path' using the 'lisp' directory in the directory
containing the sources from which it was built.  If you built Emacs in a
separate directory from the sources, it also adds the lisp directories
from the build directory.  (In all cases, elements are represented as
absolute file names.)

   Unless you start Emacs with the '--no-site-lisp' option, it then adds
two more 'site-lisp' directories to the front of 'load-path'.  These are
intended for locally installed Lisp files, and are normally of the form:

     "/usr/local/share/emacs/VERSION/site-lisp"

and

     "/usr/local/share/emacs/site-lisp"

The first one is for locally installed files for a specific Emacs
version; the second is for locally installed files meant for use with
all installed Emacs versions.  (If Emacs is running uninstalled, it also
adds 'site-lisp' directories from the source and build directories, if
they exist.  Normally these directories do not contain 'site-lisp'
directories.)

   If the environment variable 'EMACSLOADPATH' is set, it modifies the
above initialization procedure.  Emacs initializes 'load-path' based on
the value of the environment variable.

   The syntax of 'EMACSLOADPATH' is the same as used for 'PATH';
directories are separated by ':' (or ';', on some operating systems).
Here is an example of how to set 'EMACSLOADPATH' variable (from a
'sh'-style shell):

     export EMACSLOADPATH=/home/foo/.emacs.d/lisp:

   An empty element in the value of the environment variable, whether
trailing (as in the above example), leading, or embedded, is replaced by
the default value of 'load-path' as determined by the standard
initialization procedure.  If there are no such empty elements, then
'EMACSLOADPATH' specifies the entire 'load-path'.  You must include
either an empty element, or the explicit path to the directory
containing the standard Lisp files, else Emacs will not function.
(Another way to modify 'load-path' is to use the '-L' command-line
option when starting Emacs; see below.)

   For each directory in 'load-path', Emacs then checks to see if it
contains a file 'subdirs.el', and if so, loads it.  The 'subdirs.el'
file is created when Emacs is built/installed, and contains code that
causes Emacs to add any subdirectories of those directories to
'load-path'.  Both immediate subdirectories and subdirectories multiple
levels down are added.  But it excludes subdirectories whose names do
not start with a letter or digit, and subdirectories named 'RCS' or
'CVS', and subdirectories containing a file named '.nosearch'.

   Next, Emacs adds any extra load directories that you specify using
the '-L' command-line option (*note (emacs)Action Arguments::).  It also
adds the directories where optional packages are installed, if any
(*note Packaging Basics::).

   It is common to add code to one's init file (*note Init File::) to
add one or more directories to 'load-path'.  For example:

     (push "~/.emacs.d/lisp" load-path)

   Dumping Emacs uses a special value of 'load-path'.  If you use a
'site-load.el' or 'site-init.el' file to customize the dumped Emacs
(*note Building Emacs::), any changes to 'load-path' that these files
make will be lost after dumping.

 -- Command: locate-library library &optional nosuffix path
          interactive-call
     This command finds the precise file name for library LIBRARY.  It
     searches for the library in the same way 'load' does, and the
     argument NOSUFFIX has the same meaning as in 'load': don't add
     suffixes '.elc' or '.el' to the specified name LIBRARY.

     If the PATH is non-'nil', that list of directories is used instead
     of 'load-path'.

     When 'locate-library' is called from a program, it returns the file
     name as a string.  When the user runs 'locate-library'
     interactively, the argument INTERACTIVE-CALL is 't', and this tells
     'locate-library' to display the file name in the echo area.

 -- Command: list-load-path-shadows &optional stringp
     This command shows a list of "shadowed" Emacs Lisp files.  A
     shadowed file is one that will not normally be loaded, despite
     being in a directory on 'load-path', due to the existence of
     another similarly-named file in a directory earlier on 'load-path'.

     For instance, suppose 'load-path' is set to

            ("/opt/emacs/site-lisp" "/usr/share/emacs/23.3/lisp")

     and that both these directories contain a file named 'foo.el'.
     Then '(require 'foo)' never loads the file in the second directory.
     Such a situation might indicate a problem in the way Emacs was
     installed.

     When called from Lisp, this function prints a message listing the
     shadowed files, instead of displaying them in a buffer.  If the
     optional argument 'stringp' is non-'nil', it instead returns the
     shadowed files as a string.

==============================================================================
File: elisp.info,  Node: |Loading_Non_ASCII|,  Next: |Autoload|,  Prev: |Library_Search|,  Up: |Loading|
==============================================================================

                                                             *Loading_Non_ASCII*

16.4 Loading Non-ASCII Characters
=====----------------------------

When Emacs Lisp programs contain string constants with non-ASCII
characters, these can be represented within Emacs either as unibyte
strings or as multibyte strings (*note Text Representations::).  Which
representation is used depends on how the file is read into Emacs.  If
it is read with decoding into multibyte representation, the text of the
Lisp program will be multibyte text, and its string constants will be
multibyte strings.  If a file containing Latin-1 characters (for
example) is read without decoding, the text of the program will be
unibyte text, and its string constants will be unibyte strings.  *Note
Coding Systems::.

   In most Emacs Lisp programs, the fact that non-ASCII strings are
multibyte strings should not be noticeable, since inserting them in
unibyte buffers converts them to unibyte automatically.  However, if
this does make a difference, you can force a particular Lisp file to be
interpreted as unibyte by writing 'coding: raw-text' in a local
variables section.  With that designator, the file will unconditionally
be interpreted as unibyte.  This can matter when making keybindings to
non-ASCII characters written as '?vLITERAL'.

==============================================================================
File: elisp.info,  Node: |Autoload|,  Next: |Repeated_Loading|,  Prev: |Loading_Non_ASCII|,  Up: |Loading|
==============================================================================

                                                                      *Autoload*

16.5 Autoload
=====--------

The "autoload" facility lets you register the existence of a function or
macro, but put off loading the file that defines it.  The first call to
the function automatically loads the proper library, in order to install
the real definition and other associated code, then runs the real
definition as if it had been loaded all along.  Autoloading can also be
triggered by looking up the documentation of the function or macro
(*note Documentation Basics::), and completion of variable and function
names (*note Autoload by Prefix:: below).

MENU

* |Autoload_by_Prefix|:: Autoload by Prefix.
* |When_to_Autoload|::   When to Use Autoload.

   There are two ways to set up an autoloaded function: by calling
'autoload', and by writing a "magic" comment in the source before the
real definition.  'autoload' is the low-level primitive for autoloading;
any Lisp program can call 'autoload' at any time.  Magic comments are
the most convenient way to make a function autoload, for packages
installed along with Emacs.  These comments do nothing on their own, but
they serve as a guide for the command 'update-file-autoloads', which
constructs calls to 'autoload' and arranges to execute them when Emacs
is built.

 -- Function: autoload function filename &optional docstring interactive
          type
     This function defines the function (or macro) named FUNCTION so as
     to load automatically from FILENAME.  The string FILENAME specifies
     the file to load to get the real definition of FUNCTION.

     If FILENAME does not contain either a directory name, or the suffix
     '.el' or '.elc', this function insists on adding one of these
     suffixes, and it will not load from a file whose name is just
     FILENAME with no added suffix.  (The variable 'load-suffixes'
     specifies the exact required suffixes.)

     The argument DOCSTRING is the documentation string for the
     function.  Specifying the documentation string in the call to
     'autoload' makes it possible to look at the documentation without
     loading the function's real definition.  Normally, this should be
     identical to the documentation string in the function definition
     itself.  If it isn't, the function definition's documentation
     string takes effect when it is loaded.

     If INTERACTIVE is non-'nil', that says FUNCTION can be called
     interactively.  This lets completion in 'M-x' work without loading
     FUNCTION's real definition.  The complete interactive specification
     is not given here; it's not needed unless the user actually calls
     FUNCTION, and when that happens, it's time to load the real
     definition.

     You can autoload macros and keymaps as well as ordinary functions.
     Specify TYPE as 'macro' if FUNCTION is really a macro.  Specify
     TYPE as 'keymap' if FUNCTION is really a keymap.  Various parts of
     Emacs need to know this information without loading the real
     definition.

     An autoloaded keymap loads automatically during key lookup when a
     prefix key's binding is the symbol FUNCTION.  Autoloading does not
     occur for other kinds of access to the keymap.  In particular, it
     does not happen when a Lisp program gets the keymap from the value
     of a variable and calls 'define-key'; not even if the variable name
     is the same symbol FUNCTION.

     If FUNCTION already has a non-void function definition that is not
     an autoload object, this function does nothing and returns 'nil'.
     Otherwise, it constructs an autoload object (*note Autoload
     Type::), and stores it as the function definition for FUNCTION.
     The autoload object has this form:

          (autoload FILENAME DOCSTRING INTERACTIVE TYPE)

     For example,

          (symbol-function 'run-prolog)
               => (autoload "prolog" 169681 t nil)

     In this case, '"prolog"' is the name of the file to load, 169681
     refers to the documentation string in the 'emacs/etc/DOC' file
     (*note Documentation Basics::), 't' means the function is
     interactive, and 'nil' that it is not a macro or a keymap.

 -- Function: autoloadp object
     This function returns non-'nil' if OBJECT is an autoload object.
     For example, to check if 'run-prolog' is defined as an autoloaded
     function, evaluate

          (autoloadp (symbol-function 'run-prolog))

   The autoloaded file usually contains other definitions and may
require or provide one or more features.  If the file is not completely
loaded (due to an error in the evaluation of its contents), any function
definitions or 'provide' calls that occurred during the load are undone.
This is to ensure that the next attempt to call any function autoloading
from this file will try again to load the file.  If not for this, then
some of the functions in the file might be defined by the aborted load,
but fail to work properly for the lack of certain subroutines not loaded
successfully because they come later in the file.

   If the autoloaded file fails to define the desired Lisp function or
macro, then an error is signaled with data '"Autoloading failed to
define function FUNCTION-NAME"'.

   A magic autoload comment (often called an "autoload cookie") consists
of ';;;###autoload', on a line by itself, just before the real
definition of the function in its autoloadable source file.  The command
'M-x update-file-autoloads' writes a corresponding 'autoload' call into
'loaddefs.el'.  (The string that serves as the autoload cookie and the
name of the file generated by 'update-file-autoloads' can be changed
from the above defaults, see below.)  Building Emacs loads 'loaddefs.el'
and thus calls 'autoload'.  'M-x update-directory-autoloads' is even
more powerful; it updates autoloads for all files in the current
directory.

   The same magic comment can copy any kind of form into 'loaddefs.el'.
The form following the magic comment is copied verbatim, _except_ if it
is one of the forms which the autoload facility handles specially (e.g.,
by conversion into an 'autoload' call).  The forms which are not copied
verbatim are the following:

Definitions for function or function-like objects:
     'defun' and 'defmacro'; also 'cl-defun' and 'cl-defmacro' (*note
     (cl)Argument Lists::), and 'define-overloadable-function' (see the
     commentary in 'mode-local.el').

Definitions for major or minor modes:
     'define-minor-mode', 'define-globalized-minor-mode',
     'define-generic-mode', 'define-derived-mode',
     'easy-mmode-define-minor-mode', 'easy-mmode-define-global-mode',
     'define-compilation-mode', and 'define-global-minor-mode'.

Other definition types:
     'defcustom', 'defgroup', 'defclass' (*note EIEIO: (eieio)Top.), and
     'define-skeleton' (*note Autotyping: (autotype)Top.).

   You can also use a magic comment to execute a form at build time
_without_ executing it when the file itself is loaded.  To do this,
write the form _on the same line_ as the magic comment.  Since it is in
a comment, it does nothing when you load the source file; but 'M-x
update-file-autoloads' copies it to 'loaddefs.el', where it is executed
while building Emacs.

   The following example shows how 'doctor' is prepared for autoloading
with a magic comment:

     ;;;###autoload
     (defun doctor ()
       "Switch to doctor buffer and start giving psychotherapy."
       (interactive)
       (switch-to-buffer "doctor")
       (doctor-mode))

Here's what that produces in 'loaddefs.el':

     (autoload 'doctor "doctor" "\
     Switch to doctor buffer and start giving psychotherapy.

     \(fn)" t nil)

The backslash and newline immediately following the double-quote are a
convention used only in the preloaded uncompiled Lisp files such as
'loaddefs.el'; they tell 'make-docfile' to put the documentation string
in the 'etc/DOC' file.  *Note Building Emacs::.  See also the commentary
in 'lib-src/make-docfile.c'.  '(fn)' in the usage part of the
documentation string is replaced with the function's name when the
various help functions (*note Help Functions::) display it.

   If you write a function definition with an unusual macro that is not
one of the known and recognized function definition methods, use of an
ordinary magic autoload comment would copy the whole definition into
'loaddefs.el'.  That is not desirable.  You can put the desired
'autoload' call into 'loaddefs.el' instead by writing this:

     ;;;###autoload (autoload 'foo "myfile")
     (mydefunmacro foo
       ...)

   You can use a non-default string as the autoload cookie and have the
corresponding autoload calls written into a file whose name is different
from the default 'loaddefs.el'.  Emacs provides two variables to control
this:

 -- Variable: generate-autoload-cookie
     The value of this variable should be a string whose syntax is a
     Lisp comment.  'M-x update-file-autoloads' copies the Lisp form
     that follows the cookie into the autoload file it generates.  The
     default value of this variable is '";;;###autoload"'.

 -- Variable: generated-autoload-file
     The value of this variable names an Emacs Lisp file where the
     autoload calls should go.  The default value is 'loaddefs.el', but
     you can override that, e.g., in the local variables section of a
     '.el' file (*note File Local Variables::).  The autoload file is
     assumed to contain a trailer starting with a formfeed character.

   The following function may be used to explicitly load the library
specified by an autoload object:

 -- Function: autoload-do-load autoload &optional name macro-only
     This function performs the loading specified by AUTOLOAD, which
     should be an autoload object.  The optional argument NAME, if
     non-'nil', should be a symbol whose function value is AUTOLOAD; in
     that case, the return value of this function is the symbol's new
     function value.  If the value of the optional argument MACRO-ONLY
     is 'macro', this function avoids loading a function, only a macro.

==============================================================================
File: elisp.info,  Node: |Autoload_by_Prefix|,  Next: |When_to_Autoload|,  Up: |Autoload|
==============================================================================

                                                            *Autoload_by_Prefix*

16.5.1 Autoload by Prefix
-------------------------

During completion for the commands 'describe-variable' and
'describe-function', Emacs will try to load files which may contain
definitions matching the prefix being completed.  The variable
'definition-prefixes' holds a hashtable which maps a prefix to the
corresponding list of files to load for it.  Entries to this mapping are
added by calls to 'register-definition-prefixes' which are generated by
'update-file-autoloads' (*note Autoload::).  Files which don't contain
any definitions worth loading (test files, for examples), should set
'autoload-compute-prefixes' to 'nil' as a file-local variable.

==============================================================================
File: elisp.info,  Node: |When_to_Autoload|,  Prev: |Autoload_by_Prefix|,  Up: |Autoload|
==============================================================================

                                                              *When_to_Autoload*

16.5.2 When to Use Autoload
---------------------------

Do not add an autoload comment unless it is really necessary.
Autoloading code means it is always globally visible.  Once an item is
autoloaded, there is no compatible way to transition back to it not
being autoloaded (after people become accustomed to being able to use it
without an explicit load).

   * The most common items to autoload are the interactive entry points
     to a library.  For example, if 'python.el' is a library defining a
     major-mode for editing Python code, autoload the definition of the
     'python-mode' function, so that people can simply use 'M-x
     python-mode' to load the library.

   * Variables usually don't need to be autoloaded.  An exception is if
     the variable on its own is generally useful without the whole
     defining library being loaded.  (An example of this might be
     something like 'find-exec-terminator'.)

   * Don't autoload a user option just so that a user can set it.

   * Never add an autoload _comment_ to silence a compiler warning in
     another file.  In the file that produces the warning, use '(defvar
     foo)' to silence an undefined variable warning, and
     'declare-function' (*note Declaring Functions::) to silence an
     undefined function warning; or require the relevant library; or use
     an explicit autoload _statement_.

==============================================================================
File: elisp.info,  Node: |Repeated_Loading|,  Next: |Named_Features|,  Prev: |Autoload|,  Up: |Loading|
==============================================================================

                                                              *Repeated_Loading*

16.6 Repeated Loading
=====----------------

You can load a given file more than once in an Emacs session.  For
example, after you have rewritten and reinstalled a function definition
by editing it in a buffer, you may wish to return to the original
version; you can do this by reloading the file it came from.

   When you load or reload files, bear in mind that the 'load' and
'load-library' functions automatically load a byte-compiled file rather
than a non-compiled file of similar name.  If you rewrite a file that
you intend to save and reinstall, you need to byte-compile the new
version; otherwise Emacs will load the older, byte-compiled file instead
of your newer, non-compiled file!  If that happens, the message
displayed when loading the file includes, '(compiled; note, source is
newer)', to remind you to recompile it.

   When writing the forms in a Lisp library file, keep in mind that the
file might be loaded more than once.  For example, think about whether
each variable should be reinitialized when you reload the library;
'defvar' does not change the value if the variable is already
initialized.  (*Note Defining Variables::.)

   The simplest way to add an element to an alist is like this:

     (push '(leif-mode " Leif") minor-mode-alist)

But this would add multiple elements if the library is reloaded.  To
avoid the problem, use 'add-to-list' (*note List Variables::):

     (add-to-list 'minor-mode-alist '(leif-mode " Leif"))

   Occasionally you will want to test explicitly whether a library has
already been loaded.  If the library uses 'provide' to provide a named
feature, you can use 'featurep' earlier in the file to test whether the
'provide' call has been executed before (*note Named Features::).
Alternatively, you could use something like this:

     (defvar foo-was-loaded nil)

     (unless foo-was-loaded
       EXECUTE-FIRST-TIME-ONLY
       (setq foo-was-loaded t))


==============================================================================
File: elisp.info,  Node: |Named_Features|,  Next: |Where_Defined|,  Prev: |Repeated_Loading|,  Up: |Loading|
==============================================================================

                                                                *Named_Features*

16.7 Features
=====--------

'provide' and 'require' are an alternative to 'autoload' for loading
files automatically.  They work in terms of named "features".
Autoloading is triggered by calling a specific function, but a feature
is loaded the first time another program asks for it by name.

   A feature name is a symbol that stands for a collection of functions,
variables, etc.  The file that defines them should "provide" the
feature.  Another program that uses them may ensure they are defined by
"requiring" the feature.  This loads the file of definitions if it
hasn't been loaded already.

   To require the presence of a feature, call 'require' with the feature
name as argument.  'require' looks in the global variable 'features' to
see whether the desired feature has been provided already.  If not, it
loads the feature from the appropriate file.  This file should call
'provide' at the top level to add the feature to 'features'; if it fails
to do so, 'require' signals an error.

   For example, in 'idlwave.el', the definition for
'idlwave-complete-filename' includes the following code:

     (defun idlwave-complete-filename ()
       "Use the comint stuff to complete a file name."
        (require 'comint)
        (let* ((comint-file-name-chars "~/A-Za-z0-9+@:_.$#%={}\\-")
               (comint-completion-addsuffix nil)
               ...)
            (comint-dynamic-complete-filename)))

The expression '(require 'comint)' loads the file 'comint.el' if it has
not yet been loaded, ensuring that 'comint-dynamic-complete-filename' is
defined.  Features are normally named after the files that provide them,
so that 'require' need not be given the file name.  (Note that it is
important that the 'require' statement be outside the body of the 'let'.
Loading a library while its variables are let-bound can have unintended
consequences, namely the variables becoming unbound after the let
exits.)

   The 'comint.el' file contains the following top-level expression:

     (provide 'comint)

This adds 'comint' to the global 'features' list, so that '(require
'comint)' will henceforth know that nothing needs to be done.

   When 'require' is used at top level in a file, it takes effect when
you byte-compile that file (*note Byte Compilation::) as well as when
you load it.  This is in case the required package contains macros that
the byte compiler must know about.  It also avoids byte compiler
warnings for functions and variables defined in the file loaded with
'require'.

   Although top-level calls to 'require' are evaluated during byte
compilation, 'provide' calls are not.  Therefore, you can ensure that a
file of definitions is loaded before it is byte-compiled by including a
'provide' followed by a 'require' for the same feature, as in the
following example.

     (provide 'my-feature)  ; Ignored by byte compiler,
                            ;   evaluated by 'load'.
     (require 'my-feature)  ; Evaluated by byte compiler.

The compiler ignores the 'provide', then processes the 'require' by
loading the file in question.  Loading the file does execute the
'provide' call, so the subsequent 'require' call does nothing when the
file is loaded.

 -- Function: provide feature &optional subfeatures
     This function announces that FEATURE is now loaded, or being
     loaded, into the current Emacs session.  This means that the
     facilities associated with FEATURE are or will be available for
     other Lisp programs.

     The direct effect of calling 'provide' is to add FEATURE to the
     front of 'features' if it is not already in that list and call any
     'eval-after-load' code waiting for it (*note Hooks for Loading::).
     The argument FEATURE must be a symbol.  'provide' returns FEATURE.

     If provided, SUBFEATURES should be a list of symbols indicating a
     set of specific subfeatures provided by this version of FEATURE.
     You can test the presence of a subfeature using 'featurep'.  The
     idea of subfeatures is that you use them when a package (which is
     one FEATURE) is complex enough to make it useful to give names to
     various parts or functionalities of the package, which might or
     might not be loaded, or might or might not be present in a given
     version.  *Note Network Feature Testing::, for an example.

          features
               => (bar bish)

          (provide 'foo)
               => foo
          features
               => (foo bar bish)

     When a file is loaded to satisfy an autoload, and it stops due to
     an error in the evaluation of its contents, any function
     definitions or 'provide' calls that occurred during the load are
     undone.  *Note Autoload::.

 -- Function: require feature &optional filename noerror
     This function checks whether FEATURE is present in the current
     Emacs session (using '(featurep FEATURE)'; see below).  The
     argument FEATURE must be a symbol.

     If the feature is not present, then 'require' loads FILENAME with
     'load'.  If FILENAME is not supplied, then the name of the symbol
     FEATURE is used as the base file name to load.  However, in this
     case, 'require' insists on finding FEATURE with an added '.el' or
     '.elc' suffix (possibly extended with a compression suffix); a file
     whose name is just FEATURE won't be used.  (The variable
     'load-suffixes' specifies the exact required Lisp suffixes.)

     If NOERROR is non-'nil', that suppresses errors from actual loading
     of the file.  In that case, 'require' returns 'nil' if loading the
     file fails.  Normally, 'require' returns FEATURE.

     If loading the file succeeds but does not provide FEATURE,
     'require' signals an error about the missing feature.

 -- Function: featurep feature &optional subfeature
     This function returns 't' if FEATURE has been provided in the
     current Emacs session (i.e., if FEATURE is a member of 'features'.)
     If SUBFEATURE is non-'nil', then the function returns 't' only if
     that subfeature is provided as well (i.e., if SUBFEATURE is a
     member of the 'subfeature' property of the FEATURE symbol.)

 -- Variable: features
     The value of this variable is a list of symbols that are the
     features loaded in the current Emacs session.  Each symbol was put
     in this list with a call to 'provide'.  The order of the elements
     in the 'features' list is not significant.

==============================================================================
File: elisp.info,  Node: |Where_Defined|,  Next: |Unloading|,  Prev: |Named_Features|,  Up: |Loading|
==============================================================================

                                                                 *Where_Defined*

16.8 Which File Defined a Certain Symbol
=====-----------------------------------

 -- Function: symbol-file symbol &optional type
     This function returns the name of the file that defined SYMBOL.  If
     TYPE is 'nil', then any kind of definition is acceptable.  If TYPE
     is 'defun', 'defvar', or 'defface', that specifies function
     definition, variable definition, or face definition only.

     The value is normally an absolute file name.  It can also be 'nil',
     if the definition is not associated with any file.  If SYMBOL
     specifies an autoloaded function, the value can be a relative file
     name without extension.

   The basis for 'symbol-file' is the data in the variable
'load-history'.

 -- Variable: load-history
     The value of this variable is an alist that associates the names of
     loaded library files with the names of the functions and variables
     they defined, as well as the features they provided or required.

     Each element in this alist describes one loaded library (including
     libraries that are preloaded at startup).  It is a list whose CAR
     is the absolute file name of the library (a string).  The rest of
     the list elements have these forms:

     'VAR'
          The symbol VAR was defined as a variable.
     '(defun . FUN)'
          The function FUN was defined.
     '(t . FUN)'
          The function FUN was previously an autoload before this
          library redefined it as a function.  The following element is
          always '(defun . FUN)', which represents defining FUN as a
          function.
     '(autoload . FUN)'
          The function FUN was defined as an autoload.
     '(defface . FACE)'
          The face FACE was defined.
     '(require . FEATURE)'
          The feature FEATURE was required.
     '(provide . FEATURE)'
          The feature FEATURE was provided.
     '(cl-defmethod METHOD SPECIALIZERS)'
          The named METHOD was defined by using 'cl-defmethod', with
          SPECIALIZERS as its specializers.
     '(define-type . TYPE)'
          The type TYPE was defined.

     The value of 'load-history' may have one element whose CAR is
     'nil'.  This element describes definitions made with 'eval-buffer'
     on a buffer that is not visiting a file.

   The command 'eval-region' updates 'load-history', but does so by
adding the symbols defined to the element for the file being visited,
rather than replacing that element.  *Note Eval::.

==============================================================================
File: elisp.info,  Node: |Unloading|,  Next: |Hooks_for_Loading|,  Prev: |Where_Defined|,  Up: |Loading|
==============================================================================

                                                                     *Unloading*

16.9 Unloading
=====---------

You can discard the functions and variables loaded by a library to
reclaim memory for other Lisp objects.  To do this, use the function
'unload-feature':

 -- Command: unload-feature feature &optional force
     This command unloads the library that provided feature FEATURE.  It
     undefines all functions, macros, and variables defined in that
     library with 'defun', 'defalias', 'defsubst', 'defmacro',
     'defconst', 'defvar', and 'defcustom'.  It then restores any
     autoloads formerly associated with those symbols.  (Loading saves
     these in the 'autoload' property of the symbol.)

     Before restoring the previous definitions, 'unload-feature' runs
     'remove-hook' to remove functions in the library from certain
     hooks.  These hooks include variables whose names end in '-hook'
     (or the deprecated suffix '-hooks'), plus those listed in
     'unload-feature-special-hooks', as well as 'auto-mode-alist'.  This
     is to prevent Emacs from ceasing to function because important
     hooks refer to functions that are no longer defined.

     Standard unloading activities also undoes ELP profiling of
     functions in that library, unprovides any features provided by the
     library, and cancels timers held in variables defined by the
     library.

     If these measures are not sufficient to prevent malfunction, a
     library can define an explicit unloader named
     'FEATURE-unload-function'.  If that symbol is defined as a
     function, 'unload-feature' calls it with no arguments before doing
     anything else.  It can do whatever is appropriate to unload the
     library.  If it returns 'nil', 'unload-feature' proceeds to take
     the normal unload actions.  Otherwise it considers the job to be
     done.

     Ordinarily, 'unload-feature' refuses to unload a library on which
     other loaded libraries depend.  (A library A depends on library B
     if A contains a 'require' for B.)  If the optional argument FORCE
     is non-'nil', dependencies are ignored and you can unload any
     library.

   The 'unload-feature' function is written in Lisp; its actions are
based on the variable 'load-history'.

 -- Variable: unload-feature-special-hooks
     This variable holds a list of hooks to be scanned before unloading
     a library, to remove functions defined in the library.

==============================================================================
File: elisp.info,  Node: |Hooks_for_Loading|,  Next: |Dynamic_Modules|,  Prev: |Unloading|,  Up: |Loading|
==============================================================================

                                                             *Hooks_for_Loading*

16.10 Hooks for Loading
=====------------------

You can ask for code to be executed each time Emacs loads a library, by
using the variable 'after-load-functions':

 -- Variable: after-load-functions
     This abnormal hook is run after loading a file.  Each function in
     the hook is called with a single argument, the absolute filename of
     the file that was just loaded.

   If you want code to be executed when a _particular_ library is
loaded, use the macro 'with-eval-after-load':

 -- Macro: with-eval-after-load library body...
     This macro arranges to evaluate BODY at the end of loading the file
     LIBRARY, each time LIBRARY is loaded.  If LIBRARY is already
     loaded, it evaluates BODY right away.

     You don't need to give a directory or extension in the file name
     LIBRARY.  Normally, you just give a bare file name, like this:

          (with-eval-after-load "edebug" (def-edebug-spec c-point t))

     To restrict which files can trigger the evaluation, include a
     directory or an extension or both in LIBRARY.  Only a file whose
     absolute true name (i.e., the name with all symbolic links chased
     out) matches all the given name components will match.  In the
     following example, 'my_inst.elc' or 'my_inst.elc.gz' in some
     directory '..../foo/bar' will trigger the evaluation, but not
     'my_inst.el':

          (with-eval-after-load "foo/bar/my_inst.elc" ...)

     LIBRARY can also be a feature (i.e., a symbol), in which case BODY
     is evaluated at the end of any file where '(provide LIBRARY)' is
     called.

     An error in BODY does not undo the load, but does prevent execution
     of the rest of BODY.

   Normally, well-designed Lisp programs should not use
'with-eval-after-load'.  If you need to examine and set the variables
defined in another library (those meant for outside use), you can do it
immediately--there is no need to wait until the library is loaded.  If
you need to call functions defined by that library, you should load the
library, preferably with 'require' (*note Named Features::).

==============================================================================
File: elisp.info,  Node: |Dynamic_Modules|,  Prev: |Hooks_for_Loading|,  Up: |Loading|
==============================================================================

                                                               *Dynamic_Modules*

16.11 Emacs Dynamic Modules
=====----------------------

A "dynamic Emacs module" is a shared library that provides additional
functionality for use in Emacs Lisp programs, just like a package
written in Emacs Lisp would.

   Functions that load Emacs Lisp packages can also load dynamic
modules.  They recognize dynamic modules by looking at their file-name
extension, a.k.a. "suffix".  This suffix is platform-dependent.

 -- Variable: module-file-suffix
     This variable holds the system-dependent value of the file-name
     extension of the module files.  Its value is '.so' on POSIX hosts
     and '.dll' on MS-Windows.

   Every dynamic module should export a C-callable function named
'emacs_module_init', which Emacs will call as part of the call to 'load'
or 'require' which loads the module.  It should also export a symbol
named 'plugin_is_GPL_compatible' to indicate that its code is released
under the GPL or compatible license; Emacs will signal an error if your
program tries to load modules that don't export such a symbol.

   If a module needs to call Emacs functions, it should do so through
the API (Application Programming Interface) defined and documented in
the header file 'emacs-module.h' that is part of the Emacs distribution.
*Note Writing Dynamic Modules::, for details of using that API when
writing your own modules.

   Modules can create 'user-ptr' Lisp objects that embed pointers to C
struct's defined by the module.  This is useful for keeping around
complex data structures created by a module, to be passed back to the
module's functions.  User-ptr objects can also have associated
"finalizers" - functions to be run when the object is GC'ed; this is
useful for freeing any resources allocated for the underlying data
structure, such as memory, open file descriptors, etc.  *Note Module
Values::.

 -- Function: user-ptrp object
     This function returns 't' if its argument is a 'user-ptr' object.

 -- Function: module-load file
     Emacs calls this low-level primitive to load a module from the
     specified FILE and perform the necessary initialization of the
     module.  This is the primitive which makes sure the module exports
     the 'plugin_is_GPL_compatible' symbol, calls the module's
     'emacs_module_init' function, and signals an error if that function
     returns an error indication, or if the use typed 'C-g' during the
     initialization.  If the initialization succeeds, 'module-load'
     returns 't'.  Note that FILE must already have the proper file-name
     extension, as this function doesn't try looking for files with
     known extensions, unlike 'load'.

     Unlike 'load', 'module-load' doesn't record the module in
     'load-history', doesn't print any messages, and doesn't protect
     against recursive loads.  Most users should therefore use 'load',
     'load-file', 'load-library', or 'require' instead of 'module-load'.

   Loadable modules in Emacs are enabled by using the '--with-modules'
option at configure time.

==============================================================================
File: elisp.info,  Node: |Byte_Compilation|,  Next: |Debugging|,  Prev: |Loading|,  Up: |Top|
==============================================================================

                                                              *Byte_Compilation*

17 Byte Compilation
*****==============

Emacs Lisp has a "compiler" that translates functions written in Lisp
into a special representation called "byte-code" that can be executed
more efficiently.  The compiler replaces Lisp function definitions with
byte-code.  When a byte-code function is called, its definition is
evaluated by the "byte-code interpreter".

   Because the byte-compiled code is evaluated by the byte-code
interpreter, instead of being executed directly by the machine's
hardware (as true compiled code is), byte-code is completely
transportable from machine to machine without recompilation.  It is not,
however, as fast as true compiled code.

   In general, any version of Emacs can run byte-compiled code produced
by recent earlier versions of Emacs, but the reverse is not true.

   If you do not want a Lisp file to be compiled, ever, put a file-local
variable binding for 'no-byte-compile' into it, like this:

     ;; -*-no-byte-compile: t; -*-

MENU

* |Speed_of_Byte_Code|::          An example of speedup from byte compilation.
* |Compilation_Functions|::       Byte compilation functions.
* |Docs_and_Compilation|::        Dynamic loading of documentation strings.
* |Dynamic_Loading|::             Dynamic loading of individual functions.
* |Eval_During_Compile|::         Code to be evaluated when you compile.
* |Compiler_Errors|::             Handling compiler error messages.
* |Byte_Code_Objects|::           The data type used for byte-compiled functions.
* |Disassembly|::                 Disassembling byte-code; how to read byte-code.

==============================================================================
File: elisp.info,  Node: |Speed_of_Byte_Code|,  Next: |Compilation_Functions|,  Up: |Byte_Compilation|
==============================================================================

                                                            *Speed_of_Byte_Code*

17.1 Performance of Byte-Compiled Code
=====---------------------------------

A byte-compiled function is not as efficient as a primitive function
written in C, but runs much faster than the version written in Lisp.
Here is an example:

     (defun silly-loop (n)
       "Return the time, in seconds, to run N iterations of a loop."
       (let ((t1 (float-time)))
         (while (> (setq n (1- n)) 0))
         (- (float-time) t1)))
     => silly-loop

     (silly-loop 50000000)
     => 10.235304117202759

     (byte-compile 'silly-loop)
     => [Compiled code not shown]

     (silly-loop 50000000)
     => 3.705854892730713

   In this example, the interpreted code required 10 seconds to run,
whereas the byte-compiled code required less than 4 seconds.  These
results are representative, but actual results may vary.

==============================================================================
File: elisp.info,  Node: |Compilation_Functions|,  Next: |Docs_and_Compilation|,  Prev: |Speed_of_Byte_Code|,  Up: |Byte_Compilation|
==============================================================================

                                                         *Compilation_Functions*

17.2 Byte-Compilation Functions
=====--------------------------

You can byte-compile an individual function or macro definition with the
'byte-compile' function.  You can compile a whole file with
vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
