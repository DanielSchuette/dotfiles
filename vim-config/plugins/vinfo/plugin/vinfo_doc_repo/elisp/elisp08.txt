     The reason for a mode to change this variable instead of
     'revert-buffer-function' is to avoid duplicating or replacing the
     rest of what 'revert-buffer' does: asking for confirmation,
     clearing the undo list, deciding the proper major mode, and running
     the hooks listed below.

 -- Variable: before-revert-hook
     This normal hook is run by the default 'revert-buffer-function'
     before inserting the modified contents.  A custom
     'revert-buffer-function' may or may not run this hook.

 -- Variable: after-revert-hook
     This normal hook is run by the default 'revert-buffer-function'
     after inserting the modified contents.  A custom
     'revert-buffer-function' may or may not run this hook.

   Emacs can revert buffers automatically.  It does that by default for
buffers visiting files.  The following describes how to add support for
auto-reverting new types of buffers.

   First, such buffers must have a suitable 'revert-buffer-function' and
'buffer-stale-function' defined.

 -- Variable: buffer-stale-function
     The value of this variable specifies a function to call to check
     whether a buffer needs reverting.  The default value only handles
     buffers that are visiting files, by checking their modification
     time.  Buffers that are not visiting files require a custom
     function of one optional argument NOCONFIRM.  The function should
     return non-'nil' if the buffer should be reverted.  The buffer is
     current when this function is called.

     While this function is mainly intended for use in auto-reverting,
     it could be used for other purposes as well.  For instance, if
     auto-reverting is not enabled, it could be used to warn the user
     that the buffer needs reverting.  The idea behind the NOCONFIRM
     argument is that it should be 't' if the buffer is going to be
     reverted without asking the user and 'nil' if the function is just
     going to be used to warn the user that the buffer is out of date.
     In particular, for use in auto-reverting, NOCONFIRM is 't'.  If the
     function is only going to be used for auto-reverting, you can
     ignore the NOCONFIRM argument.

     If you just want to automatically auto-revert every
     'auto-revert-interval' seconds (like the Buffer Menu), use:

          (setq-local buffer-stale-function
               (lambda (&optional noconfirm) 'fast))

     in the buffer's mode function.

     The special return value 'fast' tells the caller that the need for
     reverting was not checked, but that reverting the buffer is fast.
     It also tells Auto Revert not to print any revert messages, even if
     'auto-revert-verbose' is non-'nil'.  This is important, as getting
     revert messages every 'auto-revert-interval' seconds can be very
     annoying.  The information provided by this return value could also
     be useful if the function is consulted for purposes other than
     auto-reverting.

   Once the buffer has a suitable 'revert-buffer-function' and
'buffer-stale-function', several problems usually remain.

   The buffer will only auto-revert if it is marked unmodified.  Hence,
you will have to make sure that various functions mark the buffer
modified if and only if either the buffer contains information that
might be lost by reverting, or there is reason to believe that the user
might be inconvenienced by auto-reverting, because he is actively
working on the buffer.  The user can always override this by manually
adjusting the modified status of the buffer.  To support this, calling
the 'revert-buffer-function' on a buffer that is marked unmodified
should always keep the buffer marked unmodified.

   It is important to assure that point does not continuously jump
around as a consequence of auto-reverting.  Of course, moving point
might be inevitable if the buffer radically changes.

   You should make sure that the 'revert-buffer-function' does not print
messages that unnecessarily duplicate Auto Revert's own messages,
displayed if 'auto-revert-verbose' is 't', and effectively override a
'nil' value for 'auto-revert-verbose'.  Hence, adapting a mode for
auto-reverting often involves getting rid of such messages.  This is
especially important for buffers that automatically revert every
'auto-revert-interval' seconds.

   If the new auto-reverting is part of Emacs, you should mention it in
the documentation string of 'global-auto-revert-non-file-buffers'.

   Similarly, you should document the additions in the Emacs manual.

==============================================================================
File: elisp.info,  Node: |Buffers|,  Next: |Windows|,  Prev: |Backups_and_Auto_Saving|,  Up: |Top|
==============================================================================

                                                                       *Buffers*

27 Buffers
*****=====

A "buffer" is a Lisp object containing text to be edited.  Buffers are
used to hold the contents of files that are being visited; there may
also be buffers that are not visiting files.  While several buffers may
exist at one time, only one buffer is designated the "current buffer" at
any time.  Most editing commands act on the contents of the current
buffer.  Each buffer, including the current buffer, may or may not be
displayed in any windows.

MENU

* |Buffer_Basics|::       What is a buffer?
* |Current_Buffer|::      Designating a buffer as current
                          so that primitives will access its contents.
* |Buffer_Names|::        Accessing and changing buffer names.
* |Buffer_File_Name|::    The buffer file name indicates which file is visited.
* |Buffer_Modification|:: A buffer is "modified" if it needs to be saved.
* |Modification_Time|::   Determining whether the visited file was changed
                         behind Emacs's back.
* |Read_Only_Buffers|::   Modifying text is not allowed in a read-only buffer.
* |Buffer_List|::         How to look at all the existing buffers.
* |Creating_Buffers|::    Functions that create buffers.
* |Killing_Buffers|::     Buffers exist until explicitly killed.
* |Indirect_Buffers|::    An indirect buffer shares text with some other buffer.
* |Swapping_Text|::       Swapping text between two buffers.
* |Buffer_Gap|::          The gap in the buffer.

==============================================================================
File: elisp.info,  Node: |Buffer_Basics|,  Next: |Current_Buffer|,  Up: |Buffers|
==============================================================================

                                                                 *Buffer_Basics*

27.1 Buffer Basics
=====-------------

A "buffer" is a Lisp object containing text to be edited.  Buffers are
used to hold the contents of files that are being visited; there may
also be buffers that are not visiting files.  Although several buffers
normally exist, only one buffer is designated the "current buffer" at
any time.  Most editing commands act on the contents of the current
buffer.  Each buffer, including the current buffer, may or may not be
displayed in any windows.

   Buffers in Emacs editing are objects that have distinct names and
hold text that can be edited.  Buffers appear to Lisp programs as a
special data type.  You can think of the contents of a buffer as a
string that you can extend; insertions and deletions may occur in any
part of the buffer.  *Note Text::.

   A Lisp buffer object contains numerous pieces of information.  Some
of this information is directly accessible to the programmer through
variables, while other information is accessible only through
special-purpose functions.  For example, the visited file name is
directly accessible through a variable, while the value of point is
accessible only through a primitive function.

   Buffer-specific information that is directly accessible is stored in
"buffer-local" variable bindings, which are variable values that are
effective only in a particular buffer.  This feature allows each buffer
to override the values of certain variables.  Most major modes override
variables such as 'fill-column' or 'comment-column' in this way.  For
more information about buffer-local variables and functions related to
them, see *note Buffer-Local Variables::.

   For functions and variables related to visiting files in buffers, see
*note Visiting Files:: and *note Saving Buffers::.  For functions and
variables related to the display of buffers in windows, see *note
Buffers and Windows::.

 -- Function: bufferp object
     This function returns 't' if OBJECT is a buffer, 'nil' otherwise.

==============================================================================
File: elisp.info,  Node: |Current_Buffer|,  Next: |Buffer_Names|,  Prev: |Buffer_Basics|,  Up: |Buffers|
==============================================================================

                                                                *Current_Buffer*

27.2 The Current Buffer
=====------------------

There are, in general, many buffers in an Emacs session.  At any time,
one of them is designated the "current buffer"--the buffer in which most
editing takes place.  Most of the primitives for examining or changing
text operate implicitly on the current buffer (*note Text::).

   Normally, the buffer displayed in the selected window is the current
buffer, but this is not always so: a Lisp program can temporarily
designate any buffer as current in order to operate on its contents,
without changing what is displayed on the screen.  The most basic
function for designating a current buffer is 'set-buffer'.

 -- Function: current-buffer
     This function returns the current buffer.

          (current-buffer)
               => #<buffer buffers.texi>

 -- Function: set-buffer buffer-or-name
     This function makes BUFFER-OR-NAME the current buffer.
     BUFFER-OR-NAME must be an existing buffer or the name of an
     existing buffer.  The return value is the buffer made current.

     This function does not display the buffer in any window, so the
     user cannot necessarily see the buffer.  But Lisp programs will now
     operate on it.

   When an editing command returns to the editor command loop, Emacs
automatically calls 'set-buffer' on the buffer shown in the selected
window.  This is to prevent confusion: it ensures that the buffer that
the cursor is in, when Emacs reads a command, is the buffer to which
that command applies (*note Command Loop::).  Thus, you should not use
'set-buffer' to switch visibly to a different buffer; for that, use the
functions described in *note Switching Buffers::.

   When writing a Lisp function, do _not_ rely on this behavior of the
command loop to restore the current buffer after an operation.  Editing
commands can also be called as Lisp functions by other programs, not
just from the command loop; it is convenient for the caller if the
subroutine does not change which buffer is current (unless, of course,
that is the subroutine's purpose).

   To operate temporarily on another buffer, put the 'set-buffer' within
a 'save-current-buffer' form.  Here, as an example, is a simplified
version of the command 'append-to-buffer':

     (defun append-to-buffer (buffer start end)
       "Append the text of the region to BUFFER."
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (save-current-buffer
           (set-buffer (get-buffer-create buffer))
           (insert-buffer-substring oldbuf start end))))

Here, we bind a local variable to record the current buffer, and then
'save-current-buffer' arranges to make it current again later.  Next,
'set-buffer' makes the specified buffer current, and
'insert-buffer-substring' copies the string from the original buffer to
the specified (and now current) buffer.

   Alternatively, we can use the 'with-current-buffer' macro:

     (defun append-to-buffer (buffer start end)
       "Append the text of the region to BUFFER."
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (with-current-buffer (get-buffer-create buffer)
           (insert-buffer-substring oldbuf start end))))

   In either case, if the buffer appended to happens to be displayed in
some window, the next redisplay will show how its text has changed.  If
it is not displayed in any window, you will not see the change
immediately on the screen.  The command causes the buffer to become
current temporarily, but does not cause it to be displayed.

   If you make local bindings (with 'let' or function arguments) for a
variable that may also have buffer-local bindings, make sure that the
same buffer is current at the beginning and at the end of the local
binding's scope.  Otherwise you might bind it in one buffer and unbind
it in another!

   Do not rely on using 'set-buffer' to change the current buffer back,
because that won't do the job if a quit happens while the wrong buffer
is current.  For instance, in the previous example, it would have been
wrong to do this:

       (let ((oldbuf (current-buffer)))
         (set-buffer (get-buffer-create buffer))
         (insert-buffer-substring oldbuf start end)
         (set-buffer oldbuf))

Using 'save-current-buffer' or 'with-current-buffer', as we did,
correctly handles quitting, errors, and 'throw', as well as ordinary
evaluation.

 -- Special Form: save-current-buffer body...
     The 'save-current-buffer' special form saves the identity of the
     current buffer, evaluates the BODY forms, and finally restores that
     buffer as current.  The return value is the value of the last form
     in BODY.  The current buffer is restored even in case of an
     abnormal exit via 'throw' or error (*note Nonlocal Exits::).

     If the buffer that used to be current has been killed by the time
     of exit from 'save-current-buffer', then it is not made current
     again, of course.  Instead, whichever buffer was current just
     before exit remains current.

 -- Macro: with-current-buffer buffer-or-name body...
     The 'with-current-buffer' macro saves the identity of the current
     buffer, makes BUFFER-OR-NAME current, evaluates the BODY forms, and
     finally restores the current buffer.  BUFFER-OR-NAME must specify
     an existing buffer or the name of an existing buffer.

     The return value is the value of the last form in BODY.  The
     current buffer is restored even in case of an abnormal exit via
     'throw' or error (*note Nonlocal Exits::).

 -- Macro: with-temp-buffer body...
     The 'with-temp-buffer' macro evaluates the BODY forms with a
     temporary buffer as the current buffer.  It saves the identity of
     the current buffer, creates a temporary buffer and makes it
     current, evaluates the BODY forms, and finally restores the
     previous current buffer while killing the temporary buffer.  By
     default, undo information (*note Undo::) is not recorded in the
     buffer created by this macro (but BODY can enable that, if needed).

     The return value is the value of the last form in BODY.  You can
     return the contents of the temporary buffer by using
     '(buffer-string)' as the last form.

     The current buffer is restored even in case of an abnormal exit via
     'throw' or error (*note Nonlocal Exits::).

     See also 'with-temp-file' in *note Writing to Files: Definition of
     with-temp-file.

==============================================================================
File: elisp.info,  Node: |Buffer_Names|,  Next: |Buffer_File_Name|,  Prev: |Current_Buffer|,  Up: |Buffers|
==============================================================================

                                                                  *Buffer_Names*

27.3 Buffer Names
=====------------

Each buffer has a unique name, which is a string.  Many of the functions
that work on buffers accept either a buffer or a buffer name as an
argument.  Any argument called BUFFER-OR-NAME is of this sort, and an
error is signaled if it is neither a string nor a buffer.  Any argument
called BUFFER must be an actual buffer object, not a name.

   Buffers that are ephemeral and generally uninteresting to the user
have names starting with a space, so that the 'list-buffers' and
'buffer-menu' commands don't mention them (but if such a buffer visits a
file, it is mentioned).  A name starting with space also initially
disables recording undo information; see *note Undo::.

 -- Function: buffer-name &optional buffer
     This function returns the name of BUFFER as a string.  BUFFER
     defaults to the current buffer.

     If 'buffer-name' returns 'nil', it means that BUFFER has been
     killed.  *Note Killing Buffers::.

          (buffer-name)
               => "buffers.texi"

          (setq foo (get-buffer "temp"))
               => #<buffer temp>
          (kill-buffer foo)
               => nil
          (buffer-name foo)
               => nil
          foo
               => #<killed buffer>

 -- Command: rename-buffer newname &optional unique
     This function renames the current buffer to NEWNAME.  An error is
     signaled if NEWNAME is not a string.

     Ordinarily, 'rename-buffer' signals an error if NEWNAME is already
     in use.  However, if UNIQUE is non-'nil', it modifies NEWNAME to
     make a name that is not in use.  Interactively, you can make UNIQUE
     non-'nil' with a numeric prefix argument.  (This is how the command
     'rename-uniquely' is implemented.)

     This function returns the name actually given to the buffer.

 -- Function: get-buffer buffer-or-name
     This function returns the buffer specified by BUFFER-OR-NAME.  If
     BUFFER-OR-NAME is a string and there is no buffer with that name,
     the value is 'nil'.  If BUFFER-OR-NAME is a buffer, it is returned
     as given; that is not very useful, so the argument is usually a
     name.  For example:

          (setq b (get-buffer "lewis"))
               => #<buffer lewis>
          (get-buffer b)
               => #<buffer lewis>
          (get-buffer "Frazzle-nots")
               => nil

     See also the function 'get-buffer-create' in *note Creating
     Buffers::.

 -- Function: generate-new-buffer-name starting-name &optional ignore
     This function returns a name that would be unique for a new
     buffer--but does not create the buffer.  It starts with
     STARTING-NAME, and produces a name not currently in use for any
     buffer by appending a number inside of '<...>'.  It starts at 2 and
     keeps incrementing the number until it is not the name of an
     existing buffer.

     If the optional second argument IGNORE is non-'nil', it should be a
     string, a potential buffer name.  It means to consider that
     potential buffer acceptable, if it is tried, even it is the name of
     an existing buffer (which would normally be rejected).  Thus, if
     buffers named 'foo', 'foo<2>', 'foo<3>' and 'foo<4>' exist,

          (generate-new-buffer-name "foo")
               => "foo<5>"
          (generate-new-buffer-name "foo" "foo<3>")
               => "foo<3>"
          (generate-new-buffer-name "foo" "foo<6>")
               => "foo<5>"

     See the related function 'generate-new-buffer' in *note Creating
     Buffers::.

==============================================================================
File: elisp.info,  Node: |Buffer_File_Name|,  Next: |Buffer_Modification|,  Prev: |Buffer_Names|,  Up: |Buffers|
==============================================================================

                                                              *Buffer_File_Name*

27.4 Buffer File Name
=====----------------

The "buffer file name" is the name of the file that is visited in that
buffer.  When a buffer is not visiting a file, its buffer file name is
'nil'.  Most of the time, the buffer name is the same as the
nondirectory part of the buffer file name, but the buffer file name and
the buffer name are distinct and can be set independently.  *Note
Visiting Files::.

 -- Function: buffer-file-name &optional buffer
     This function returns the absolute file name of the file that
     BUFFER is visiting.  If BUFFER is not visiting any file,
     'buffer-file-name' returns 'nil'.  If BUFFER is not supplied, it
     defaults to the current buffer.

          (buffer-file-name (other-buffer))
               => "/usr/user/lewis/manual/files.texi"

 -- Variable: buffer-file-name
     This buffer-local variable contains the name of the file being
     visited in the current buffer, or 'nil' if it is not visiting a
     file.  It is a permanent local variable, unaffected by
     'kill-all-local-variables'.

          buffer-file-name
               => "/usr/user/lewis/manual/buffers.texi"

     It is risky to change this variable's value without doing various
     other things.  Normally it is better to use 'set-visited-file-name'
     (see below); some of the things done there, such as changing the
     buffer name, are not strictly necessary, but others are essential
     to avoid confusing Emacs.

 -- Variable: buffer-file-truename
     This buffer-local variable holds the abbreviated truename of the
     file visited in the current buffer, or 'nil' if no file is visited.
     It is a permanent local, unaffected by 'kill-all-local-variables'.
     *Note Truenames::, and *note abbreviate-file-name::.

 -- Variable: buffer-file-number
     This buffer-local variable holds the file number and directory
     device number of the file visited in the current buffer, or 'nil'
     if no file or a nonexistent file is visited.  It is a permanent
     local, unaffected by 'kill-all-local-variables'.

     The value is normally a list of the form '(FILENUM DEVNUM)'.  This
     pair of numbers uniquely identifies the file among all files
     accessible on the system.  See the function 'file-attributes', in
     *note File Attributes::, for more information about them.

     If 'buffer-file-name' is the name of a symbolic link, then both
     numbers refer to the recursive target.

 -- Function: get-file-buffer filename
     This function returns the buffer visiting file FILENAME.  If there
     is no such buffer, it returns 'nil'.  The argument FILENAME, which
     must be a string, is expanded (*note File Name Expansion::), then
     compared against the visited file names of all live buffers.  Note
     that the buffer's 'buffer-file-name' must match the expansion of
     FILENAME exactly.  This function will not recognize other names for
     the same file.

          (get-file-buffer "buffers.texi")
              => #<buffer buffers.texi>

     In unusual circumstances, there can be more than one buffer
     visiting the same file name.  In such cases, this function returns
     the first such buffer in the buffer list.

 -- Function: find-buffer-visiting filename &optional predicate
     This is like 'get-file-buffer', except that it can return any
     buffer visiting the file _possibly under a different name_.  That
     is, the buffer's 'buffer-file-name' does not need to match the
     expansion of FILENAME exactly, it only needs to refer to the same
     file.  If PREDICATE is non-'nil', it should be a function of one
     argument, a buffer visiting FILENAME.  The buffer is only
     considered a suitable return value if PREDICATE returns non-'nil'.
     If it can not find a suitable buffer to return,
     'find-buffer-visiting' returns 'nil'.

 -- Command: set-visited-file-name filename &optional no-query
          along-with-file
     If FILENAME is a non-empty string, this function changes the name
     of the file visited in the current buffer to FILENAME.  (If the
     buffer had no visited file, this gives it one.)  The _next time_
     the buffer is saved it will go in the newly-specified file.

     This command marks the buffer as modified, since it does not (as
     far as Emacs knows) match the contents of FILENAME, even if it
     matched the former visited file.  It also renames the buffer to
     correspond to the new file name, unless the new name is already in
     use.

     If FILENAME is 'nil' or the empty string, that stands for "no
     visited file".  In this case, 'set-visited-file-name' marks the
     buffer as having no visited file, without changing the buffer's
     modified flag.

     Normally, this function asks the user for confirmation if there
     already is a buffer visiting FILENAME.  If NO-QUERY is non-'nil',
     that prevents asking this question.  If there already is a buffer
     visiting FILENAME, and the user confirms or NO-QUERY is non-'nil',
     this function makes the new buffer name unique by appending a
     number inside of '<...>' to FILENAME.

     If ALONG-WITH-FILE is non-'nil', that means to assume that the
     former visited file has been renamed to FILENAME.  In this case,
     the command does not change the buffer's modified flag, nor the
     buffer's recorded last file modification time as reported by
     'visited-file-modtime' (*note Modification Time::).  If
     ALONG-WITH-FILE is 'nil', this function clears the recorded last
     file modification time, after which 'visited-file-modtime' returns
     zero.

     When the function 'set-visited-file-name' is called interactively,
     it prompts for FILENAME in the minibuffer.

 -- Variable: list-buffers-directory
     This buffer-local variable specifies a string to display in a
     buffer listing where the visited file name would go, for buffers
     that don't have a visited file name.  Dired buffers use this
     variable.

==============================================================================
File: elisp.info,  Node: |Buffer_Modification|,  Next: |Modification_Time|,  Prev: |Buffer_File_Name|,  Up: |Buffers|
==============================================================================

                                                           *Buffer_Modification*

27.5 Buffer Modification
=====-------------------

Emacs keeps a flag called the "modified flag" for each buffer, to record
whether you have changed the text of the buffer.  This flag is set to
't' whenever you alter the contents of the buffer, and cleared to 'nil'
when you save it.  Thus, the flag shows whether there are unsaved
changes.  The flag value is normally shown in the mode line (*note Mode
Line Variables::), and controls saving (*note Saving Buffers::) and
auto-saving (*note Auto-Saving::).

   Some Lisp programs set the flag explicitly.  For example, the
function 'set-visited-file-name' sets the flag to 't', because the text
does not match the newly-visited file, even if it is unchanged from the
file formerly visited.

   The functions that modify the contents of buffers are described in
*note Text::.

 -- Function: buffer-modified-p &optional buffer
     This function returns 't' if the buffer BUFFER has been modified
     since it was last read in from a file or saved, or 'nil' otherwise.
     If BUFFER is not supplied, the current buffer is tested.

 -- Function: set-buffer-modified-p flag
     This function marks the current buffer as modified if FLAG is
     non-'nil', or as unmodified if the flag is 'nil'.

     Another effect of calling this function is to cause unconditional
     redisplay of the mode line for the current buffer.  In fact, the
     function 'force-mode-line-update' works by doing this:

          (set-buffer-modified-p (buffer-modified-p))

 -- Function: restore-buffer-modified-p flag
     Like 'set-buffer-modified-p', but does not force redisplay of mode
     lines.

 -- Command: not-modified &optional arg
     This command marks the current buffer as unmodified, and not
     needing to be saved.  If ARG is non-'nil', it marks the buffer as
     modified, so that it will be saved at the next suitable occasion.
     Interactively, ARG is the prefix argument.

     Don't use this function in programs, since it prints a message in
     the echo area; use 'set-buffer-modified-p' (above) instead.

 -- Function: buffer-modified-tick &optional buffer
     This function returns BUFFER's modification-count.  This is a
     counter that increments every time the buffer is modified.  If
     BUFFER is 'nil' (or omitted), the current buffer is used.

 -- Function: buffer-chars-modified-tick &optional buffer
     This function returns BUFFER's character-change modification-count.
     Changes to text properties leave this counter unchanged; however,
     each time text is inserted or removed from the buffer, the counter
     is reset to the value that would be returned by
     'buffer-modified-tick'.  By comparing the values returned by two
     'buffer-chars-modified-tick' calls, you can tell whether a
     character change occurred in that buffer in between the calls.  If
     BUFFER is 'nil' (or omitted), the current buffer is used.

   Sometimes there's a need for modifying buffer in a way that doesn't
really change its text, like if only its text properties are changed.
If your program needs to modify a buffer without triggering any hooks
and features that react to buffer modifications, use the
'with-silent-modifications' macro.

 -- Macro: with-silent-modifications body...
     Execute BODY pretending it does not modify the buffer.  This
     includes checking whether the buffer's file is locked (*note File
     Locks::), running buffer modification hooks (*note Change Hooks::),
     etc.  Note that if BODY actually modifies the buffer text, its undo
     data may become corrupted.

==============================================================================
File: elisp.info,  Node: |Modification_Time|,  Next: |Read_Only_Buffers|,  Prev: |Buffer_Modification|,  Up: |Buffers|
==============================================================================

                                                             *Modification_Time*

27.6 Buffer Modification Time
=====------------------------

Suppose that you visit a file and make changes in its buffer, and
meanwhile the file itself is changed on disk.  At this point, saving the
buffer would overwrite the changes in the file.  Occasionally this may
be what you want, but usually it would lose valuable information.  Emacs
therefore checks the file's modification time using the functions
described below before saving the file.  (*Note File Attributes::, for
how to examine a file's modification time.)

 -- Function: verify-visited-file-modtime &optional buffer
     This function compares what BUFFER (by default, the current-buffer)
     has recorded for the modification time of its visited file against
     the actual modification time of the file as recorded by the
     operating system.  The two should be the same unless some other
     process has written the file since Emacs visited or saved it.

     The function returns 't' if the last actual modification time and
     Emacs's recorded modification time are the same, 'nil' otherwise.
     It also returns 't' if the buffer has no recorded last modification
     time, that is if 'visited-file-modtime' would return zero.

     It always returns 't' for buffers that are not visiting a file,
     even if 'visited-file-modtime' returns a non-zero value.  For
     instance, it always returns 't' for dired buffers.  It returns 't'
     for buffers that are visiting a file that does not exist and never
     existed, but 'nil' for file-visiting buffers whose file has been
     deleted.

 -- Function: clear-visited-file-modtime
     This function clears out the record of the last modification time
     of the file being visited by the current buffer.  As a result, the
     next attempt to save this buffer will not complain of a discrepancy
     in file modification times.

     This function is called in 'set-visited-file-name' and other
     exceptional places where the usual test to avoid overwriting a
     changed file should not be done.

 -- Function: visited-file-modtime
     This function returns the current buffer's recorded last file
     modification time, as a Lisp timestamp (*note Time of Day::).

     If the buffer has no recorded last modification time, this function
     returns zero.  This case occurs, for instance, if the buffer is not
     visiting a file or if the time has been explicitly cleared by
     'clear-visited-file-modtime'.  Note, however, that
     'visited-file-modtime' returns a timestamp for some non-file
     buffers too.  For instance, in a Dired buffer listing a directory,
     it returns the last modification time of that directory, as
     recorded by Dired.

     If the buffer is visiting a file that doesn't exist, this function
     returns -1.

 -- Function: set-visited-file-modtime &optional time
     This function updates the buffer's record of the last modification
     time of the visited file, to the value specified by TIME if TIME is
     not 'nil', and otherwise to the last modification time of the
     visited file.

     If TIME is neither 'nil' nor an integer flag returned by
     'visited-file-modtime', it should be a Lisp time value (*note Time
     of Day::).

     This function is useful if the buffer was not read from the file
     normally, or if the file itself has been changed for some known
     benign reason.

 -- Function: ask-user-about-supersession-threat filename
     This function is used to ask a user how to proceed after an attempt
     to modify a buffer visiting file FILENAME when the file is newer
     than the buffer text.  Emacs detects this because the modification
     time of the file on disk is newer than the last save-time and its
     contents have changed.  This means some other program has probably
     altered the file.

     Depending on the user's answer, the function may return normally,
     in which case the modification of the buffer proceeds, or it may
     signal a 'file-supersession' error with data '(FILENAME)', in which
     case the proposed buffer modification is not allowed.

     This function is called automatically by Emacs on the proper
     occasions.  It exists so you can customize Emacs by redefining it.
     See the file 'userlock.el' for the standard definition.

     See also the file locking mechanism in *note File Locks::.

==============================================================================
File: elisp.info,  Node: |Read_Only_Buffers|,  Next: |Buffer_List|,  Prev: |Modification_Time|,  Up: |Buffers|
==============================================================================

                                                             *Read_Only_Buffers*

27.7 Read-Only Buffers
=====-----------------

If a buffer is "read-only", then you cannot change its contents,
although you may change your view of the contents by scrolling and
narrowing.

   Read-only buffers are used in two kinds of situations:

   * A buffer visiting a write-protected file is normally read-only.

     Here, the purpose is to inform the user that editing the buffer
     with the aim of saving it in the file may be futile or undesirable.
     The user who wants to change the buffer text despite this can do so
     after clearing the read-only flag with 'C-x C-q'.

   * Modes such as Dired and Rmail make buffers read-only when altering
     the contents with the usual editing commands would probably be a
     mistake.

     The special commands of these modes bind 'buffer-read-only' to
     'nil' (with 'let') or bind 'inhibit-read-only' to 't' around the
     places where they themselves change the text.

 -- Variable: buffer-read-only
     This buffer-local variable specifies whether the buffer is
     read-only.  The buffer is read-only if this variable is non-'nil'.
     However, characters that have the 'inhibit-read-only' text property
     can still be modified.  *Note inhibit-read-only: Special
     Properties.

 -- Variable: inhibit-read-only
     If this variable is non-'nil', then read-only buffers and,
     depending on the actual value, some or all read-only characters may
     be modified.  Read-only characters in a buffer are those that have
     a non-'nil' 'read-only' text property.  *Note Special Properties::,
     for more information about text properties.

     If 'inhibit-read-only' is 't', all 'read-only' character properties
     have no effect.  If 'inhibit-read-only' is a list, then 'read-only'
     character properties have no effect if they are members of the list
     (comparison is done with 'eq').

 -- Command: read-only-mode &optional arg
     This is the mode command for Read Only minor mode, a buffer-local
     minor mode.  When the mode is enabled, 'buffer-read-only' is
     non-'nil' in the buffer; when disabled, 'buffer-read-only' is 'nil'
     in the buffer.  The calling convention is the same as for other
     minor mode commands (*note Minor Mode Conventions::).

     This minor mode mainly serves as a wrapper for 'buffer-read-only';
     unlike most minor modes, there is no separate 'read-only-mode'
     variable.  Even when Read Only mode is disabled, characters with
     non-'nil' 'read-only' text properties remain read-only.  To
     temporarily ignore all read-only states, bind 'inhibit-read-only',
     as described above.

     When enabling Read Only mode, this mode command also enables View
     mode if the option 'view-read-only' is non-'nil'.  *Note
     Miscellaneous Buffer Operations: (emacs)Misc Buffer.  When
     disabling Read Only mode, it disables View mode if View mode was
     enabled.

 -- Function: barf-if-buffer-read-only &optional position
     This function signals a 'buffer-read-only' error if the current
     buffer is read-only.  If the text at POSITION (which defaults to
     point) has the 'inhibit-read-only' text property set, the error
     will not be raised.

     *Note Using Interactive::, for another way to signal an error if
     the current buffer is read-only.

==============================================================================
File: elisp.info,  Node: |Buffer_List|,  Next: |Creating_Buffers|,  Prev: |Read_Only_Buffers|,  Up: |Buffers|
==============================================================================

                                                                   *Buffer_List*

27.8 The Buffer List
=====---------------

The "buffer list" is a list of all live buffers.  The order of the
buffers in this list is based primarily on how recently each buffer has
been displayed in a window.  Several functions, notably 'other-buffer',
use this ordering.  A buffer list displayed for the user also follows
this order.

   Creating a buffer adds it to the end of the buffer list, and killing
a buffer removes it from that list.  A buffer moves to the front of this
list whenever it is chosen for display in a window (*note Switching
Buffers::) or a window displaying it is selected (*note Selecting
Windows::).  A buffer moves to the end of the list when it is buried
(see 'bury-buffer', below).  There are no functions available to the
Lisp programmer which directly manipulate the buffer list.

   In addition to the fundamental buffer list just described, Emacs
maintains a local buffer list for each frame, in which the buffers that
have been displayed (or had their windows selected) in that frame come
first.  (This order is recorded in the frame's 'buffer-list' frame
parameter; see *note Buffer Parameters::.)  Buffers never displayed in
that frame come afterward, ordered according to the fundamental buffer
list.

 -- Function: buffer-list &optional frame
     This function returns the buffer list, including all buffers, even
     those whose names begin with a space.  The elements are actual
     buffers, not their names.

     If FRAME is a frame, this returns FRAME's local buffer list.  If
     FRAME is 'nil' or omitted, the fundamental buffer list is used: the
     buffers appear in order of most recent display or selection,
     regardless of which frames they were displayed on.

          (buffer-list)
               => (#<buffer buffers.texi>
                   #<buffer  Minibuf-1> #<buffer buffer.c>
                   #<buffer Help> #<buffer TAGS>)

          ;; Note that the name of the minibuffer
          ;;   begins with a space!
          (mapcar #'buffer-name (buffer-list))
              => ("buffers.texi" " Minibuf-1"
                  "buffer.c" "Help" "TAGS")

   The list returned by 'buffer-list' is constructed specifically; it is
not an internal Emacs data structure, and modifying it has no effect on
the order of buffers.  If you want to change the order of buffers in the
fundamental buffer list, here is an easy way:

     (defun reorder-buffer-list (new-list)
       (while new-list
         (bury-buffer (car new-list))
         (setq new-list (cdr new-list))))

   With this method, you can specify any order for the list, but there
is no danger of losing a buffer or adding something that is not a valid
live buffer.

   To change the order or value of a specific frame's buffer list, set
that frame's 'buffer-list' parameter with 'modify-frame-parameters'
(*note Parameter Access::).

 -- Function: other-buffer &optional buffer visible-ok frame
     This function returns the first buffer in the buffer list other
     than BUFFER.  Usually, this is the buffer appearing in the most
     recently selected window (in frame FRAME or else the selected
     frame, *note Input Focus::), aside from BUFFER.  Buffers whose
     names start with a space are not considered at all.

     If BUFFER is not supplied (or if it is not a live buffer), then
     'other-buffer' returns the first buffer in the selected frame's
     local buffer list.  (If FRAME is non-'nil', it returns the first
     buffer in FRAME's local buffer list instead.)

     If FRAME has a non-'nil' 'buffer-predicate' parameter, then
     'other-buffer' uses that predicate to decide which buffers to
     consider.  It calls the predicate once for each buffer, and if the
     value is 'nil', that buffer is ignored.  *Note Buffer Parameters::.

     If VISIBLE-OK is 'nil', 'other-buffer' avoids returning a buffer
     visible in any window on any visible frame, except as a last
     resort.  If VISIBLE-OK is non-'nil', then it does not matter
     whether a buffer is displayed somewhere or not.

     If no suitable buffer exists, the buffer 'scratch' is returned
     (and created, if necessary).

 -- Function: last-buffer &optional buffer visible-ok frame
     This function returns the last buffer in FRAME's buffer list other
     than BUFFER.  If FRAME is omitted or 'nil', it uses the selected
     frame's buffer list.

     The argument VISIBLE-OK is handled as with 'other-buffer', see
     above.  If no suitable buffer can be found, the buffer 'scratch'
     is returned.

 -- Command: bury-buffer &optional buffer-or-name
     This command puts BUFFER-OR-NAME at the end of the buffer list,
     without changing the order of any of the other buffers on the list.
     This buffer therefore becomes the least desirable candidate for
     'other-buffer' to return.  The argument can be either a buffer
     itself or the name of one.

     This function operates on each frame's 'buffer-list' parameter as
     well as the fundamental buffer list; therefore, the buffer that you
     bury will come last in the value of '(buffer-list FRAME)' and in
     the value of '(buffer-list)'.  In addition, it also puts the buffer
     at the end of the list of buffers of the selected window (*note
     Window History::) provided it is shown in that window.

     If BUFFER-OR-NAME is 'nil' or omitted, this means to bury the
     current buffer.  In addition, if the current buffer is displayed in
     the selected window, this makes sure that the window is either
     deleted or another buffer is shown in it.  More precisely, if the
     selected window is dedicated (*note Dedicated Windows::) and there
     are other windows on its frame, the window is deleted.  If it is
     the only window on its frame and that frame is not the only frame
     on its terminal, the frame is dismissed by calling the function
     specified by 'frame-auto-hide-function' (*note Quitting Windows::).
     Otherwise, it calls 'switch-to-prev-buffer' (*note Window
     History::) to show another buffer in that window.  If
     BUFFER-OR-NAME is displayed in some other window, it remains
     displayed there.

     To replace a buffer in all the windows that display it, use
     'replace-buffer-in-windows', *Note Buffers and Windows::.

 -- Command: unbury-buffer
     This command switches to the last buffer in the local buffer list
     of the selected frame.  More precisely, it calls the function
     'switch-to-buffer' (*note Switching Buffers::), to display the
     buffer returned by 'last-buffer' (see above), in the selected
     window.

 -- Variable: buffer-list-update-hook
     This is a normal hook run whenever the buffer list changes.
     Functions (implicitly) running this hook are 'get-buffer-create'
     (*note Creating Buffers::), 'rename-buffer' (*note Buffer Names::),
     'kill-buffer' (*note Killing Buffers::), 'bury-buffer' (see above)
     and 'select-window' (*note Selecting Windows::).

     Functions run by this hook should avoid calling 'select-window'
     with a nil NORECORD argument or 'with-temp-buffer' since either may
     lead to infinite recursion.

==============================================================================
File: elisp.info,  Node: |Creating_Buffers|,  Next: |Killing_Buffers|,  Prev: |Buffer_List|,  Up: |Buffers|
==============================================================================

                                                              *Creating_Buffers*

27.9 Creating Buffers
=====----------------

This section describes the two primitives for creating buffers.
'get-buffer-create' creates a buffer if it finds no existing buffer with
the specified name; 'generate-new-buffer' always creates a new buffer
and gives it a unique name.

   Other functions you can use to create buffers include
'with-output-to-temp-buffer' (*note Temporary Displays::) and
'create-file-buffer' (*note Visiting Files::).  Starting a subprocess
can also create a buffer (*note Processes::).

 -- Function: get-buffer-create buffer-or-name
     This function returns a buffer named BUFFER-OR-NAME.  The buffer
     returned does not become the current buffer--this function does not
     change which buffer is current.

     BUFFER-OR-NAME must be either a string or an existing buffer.  If
     it is a string and a live buffer with that name already exists,
     'get-buffer-create' returns that buffer.  If no such buffer exists,
     it creates a new buffer.  If BUFFER-OR-NAME is a buffer instead of
     a string, it is returned as given, even if it is dead.

          (get-buffer-create "foo")
               => #<buffer foo>

     The major mode for a newly created buffer is set to Fundamental
     mode.  (The default value of the variable 'major-mode' is handled
     at a higher level; see *note Auto Major Mode::.)  If the name
     begins with a space, the buffer initially disables undo information
     recording (*note Undo::).

 -- Function: generate-new-buffer name
     This function returns a newly created, empty buffer, but does not
     make it current.  The name of the buffer is generated by passing
     NAME to the function 'generate-new-buffer-name' (*note Buffer
     Names::).  Thus, if there is no buffer named NAME, then that is the
     name of the new buffer; if that name is in use, a suffix of the
     form '<N>', where N is an integer, is appended to NAME.

     An error is signaled if NAME is not a string.

          (generate-new-buffer "bar")
               => #<buffer bar>
          (generate-new-buffer "bar")
               => #<buffer bar<2>>
          (generate-new-buffer "bar")
               => #<buffer bar<3>>

     The major mode for the new buffer is set to Fundamental mode.  The
     default value of the variable 'major-mode' is handled at a higher
     level.  *Note Auto Major Mode::.

==============================================================================
File: elisp.info,  Node: |Killing_Buffers|,  Next: |Indirect_Buffers|,  Prev: |Creating_Buffers|,  Up: |Buffers|
==============================================================================

                                                               *Killing_Buffers*

27.10 Killing Buffers
=====----------------

"Killing a buffer" makes its name unknown to Emacs and makes the memory
space it occupied available for other use.

   The buffer object for the buffer that has been killed remains in
existence as long as anything refers to it, but it is specially marked
so that you cannot make it current or display it.  Killed buffers retain
their identity, however; if you kill two distinct buffers, they remain
distinct according to 'eq' although both are dead.

   If you kill a buffer that is current or displayed in a window, Emacs
automatically selects or displays some other buffer instead.  This means
that killing a buffer can change the current buffer.  Therefore, when
you kill a buffer, you should also take the precautions associated with
changing the current buffer (unless you happen to know that the buffer
being killed isn't current).  *Note Current Buffer::.

   If you kill a buffer that is the base buffer of one or more indirect
buffers (*note Indirect Buffers::), the indirect buffers are
automatically killed as well.

   The 'buffer-name' of a buffer is 'nil' if, and only if, the buffer is
killed.  A buffer that has not been killed is called a "live" buffer.
To test whether a buffer is live or killed, use the function
'buffer-live-p' (see below).

 -- Command: kill-buffer &optional buffer-or-name
     This function kills the buffer BUFFER-OR-NAME, freeing all its
     memory for other uses or to be returned to the operating system.
     If BUFFER-OR-NAME is 'nil' or omitted, it kills the current buffer.

     Any processes that have this buffer as the 'process-buffer' are
     sent the 'SIGHUP' (hangup) signal, which normally causes them to
     terminate.  *Note Signals to Processes::.

     If the buffer is visiting a file and contains unsaved changes,
     'kill-buffer' asks the user to confirm before the buffer is killed.
     It does this even if not called interactively.  To prevent the
     request for confirmation, clear the modified flag before calling
     'kill-buffer'.  *Note Buffer Modification::.

     This function calls 'replace-buffer-in-windows' for cleaning up all
     windows currently displaying the buffer to be killed.

     Killing a buffer that is already dead has no effect.

     This function returns 't' if it actually killed the buffer.  It
     returns 'nil' if the user refuses to confirm or if BUFFER-OR-NAME
     was already dead.

          (kill-buffer "foo.unchanged")
               => t
          (kill-buffer "foo.changed")

          ---------- Buffer: Minibuffer ----------
          Buffer foo.changed modified; kill anyway? (yes or no) yes
          ---------- Buffer: Minibuffer ----------

               => t

 -- Variable: kill-buffer-query-functions
     Before confirming unsaved changes, 'kill-buffer' calls the
     functions in the list 'kill-buffer-query-functions', in order of
     appearance, with no arguments.  The buffer being killed is the
     current buffer when they are called.  The idea of this feature is
     that these functions will ask for confirmation from the user.  If
     any of them returns 'nil', 'kill-buffer' spares the buffer's life.

 -- Variable: kill-buffer-hook
     This is a normal hook run by 'kill-buffer' after asking all the
     questions it is going to ask, just before actually killing the
     buffer.  The buffer to be killed is current when the hook functions
     run.  *Note Hooks::.  This variable is a permanent local, so its
     local binding is not cleared by changing major modes.

 -- User Option: buffer-offer-save
     This variable, if non-'nil' in a particular buffer, tells
     'save-buffers-kill-emacs' to offer to save that buffer, just as it
     offers to save file-visiting buffers.  If 'save-some-buffers' is
     called with the second optional argument set to 't', it will also
     offer to save the buffer.  Lastly, if this variable is set to the
     symbol 'always', both 'save-buffers-kill-emacs' and
     'save-some-buffers' will always offer to save.  *Note Definition of
     save-some-buffers::.  The variable 'buffer-offer-save'
     automatically becomes buffer-local when set for any reason.  *Note
     Buffer-Local Variables::.

 -- Variable: buffer-save-without-query
     This variable, if non-'nil' in a particular buffer, tells
     'save-buffers-kill-emacs' and 'save-some-buffers' to save this
     buffer (if it's modified) without asking the user.  The variable
     automatically becomes buffer-local when set for any reason.

 -- Function: buffer-live-p object
     This function returns 't' if OBJECT is a live buffer (a buffer
     which has not been killed), 'nil' otherwise.

==============================================================================
File: elisp.info,  Node: |Indirect_Buffers|,  Next: |Swapping_Text|,  Prev: |Killing_Buffers|,  Up: |Buffers|
==============================================================================

                                                              *Indirect_Buffers*

27.11 Indirect Buffers
=====-----------------

An "indirect buffer" shares the text of some other buffer, which is
called the "base buffer" of the indirect buffer.  In some ways it is the
analogue, for buffers, of a symbolic link among files.  The base buffer
may not itself be an indirect buffer.

   The text of the indirect buffer is always identical to the text of
its base buffer; changes made by editing either one are visible
immediately in the other.  This includes the text properties as well as
the characters themselves.

   In all other respects, the indirect buffer and its base buffer are
completely separate.  They have different names, independent values of
point, independent narrowing, independent markers and overlays (though
inserting or deleting text in either buffer relocates the markers and
overlays for both), independent major modes, and independent
buffer-local variable bindings.

   An indirect buffer cannot visit a file, but its base buffer can.  If
you try to save the indirect buffer, that actually saves the base
buffer.

   Killing an indirect buffer has no effect on its base buffer.  Killing
the base buffer effectively kills the indirect buffer in that it cannot
ever again be the current buffer.

 -- Command: make-indirect-buffer base-buffer name &optional clone
     This creates and returns an indirect buffer named NAME whose base
     buffer is BASE-BUFFER.  The argument BASE-BUFFER may be a live
     buffer or the name (a string) of an existing buffer.  If NAME is
     the name of an existing buffer, an error is signaled.

     If CLONE is non-'nil', then the indirect buffer originally shares
     the state of BASE-BUFFER such as major mode, minor modes, buffer
     local variables and so on.  If CLONE is omitted or 'nil' the
     indirect buffer's state is set to the default state for new
     buffers.

     If BASE-BUFFER is an indirect buffer, its base buffer is used as
     the base for the new buffer.  If, in addition, CLONE is non-'nil',
     the initial state is copied from the actual base buffer, not from
     BASE-BUFFER.

 -- Command: clone-indirect-buffer newname display-flag &optional
          norecord
     This function creates and returns a new indirect buffer that shares
     the current buffer's base buffer and copies the rest of the current
     buffer's attributes.  (If the current buffer is not indirect, it is
     used as the base buffer.)

     If DISPLAY-FLAG is non-'nil', as it always is in interactive calls,
     that means to display the new buffer by calling 'pop-to-buffer'.
     If NORECORD is non-'nil', that means not to put the new buffer to
     the front of the buffer list.

 -- Function: buffer-base-buffer &optional buffer
     This function returns the base buffer of BUFFER, which defaults to
     the current buffer.  If BUFFER is not indirect, the value is 'nil'.
     Otherwise, the value is another buffer, which is never an indirect
     buffer.

==============================================================================
File: elisp.info,  Node: |Swapping_Text|,  Next: |Buffer_Gap|,  Prev: |Indirect_Buffers|,  Up: |Buffers|
==============================================================================

                                                                 *Swapping_Text*

27.12 Swapping Text Between Two Buffers
=====----------------------------------

Specialized modes sometimes need to let the user access from the same
buffer several vastly different types of text.  For example, you may
need to display a summary of the buffer text, in addition to letting the
user access the text itself.

   This could be implemented with multiple buffers (kept in sync when
the user edits the text), or with narrowing (*note Narrowing::).  But
these alternatives might sometimes become tedious or prohibitively
expensive, especially if each type of text requires expensive
buffer-global operations in order to provide correct display and editing
commands.

   Emacs provides another facility for such modes: you can quickly swap
buffer text between two buffers with 'buffer-swap-text'.  This function
is very fast because it doesn't move any text, it only changes the
internal data structures of the buffer object to point to a different
chunk of text.  Using it, you can pretend that a group of two or more
buffers are actually a single virtual buffer that holds the contents of
all the individual buffers together.

 -- Function: buffer-swap-text buffer
     This function swaps the text of the current buffer and that of its
     argument BUFFER.  It signals an error if one of the two buffers is
     an indirect buffer (*note Indirect Buffers::) or is a base buffer
     of an indirect buffer.

     All the buffer properties that are related to the buffer text are
     swapped as well: the positions of point and mark, all the markers,
     the overlays, the text properties, the undo list, the value of the
     'enable-multibyte-characters' flag (*note
     enable-multibyte-characters: Text Representations.), etc.

     Warning: If this function is called from within a
     'save-excursion' form, the current buffer will be set to BUFFER
     upon leaving the form, since the marker used by 'save-excursion' to
     save the position and buffer will be swapped as well.

   If you use 'buffer-swap-text' on a file-visiting buffer, you should
set up a hook to save the buffer's original text rather than what it was
swapped with.  'write-region-annotate-functions' works for this purpose.
You should probably set 'buffer-saved-size' to -2 in the buffer, so that
changes in the text it is swapped with will not interfere with
auto-saving.

==============================================================================
File: elisp.info,  Node: |Buffer_Gap|,  Prev: |Swapping_Text|,  Up: |Buffers|
==============================================================================

                                                                    *Buffer_Gap*

27.13 The Buffer Gap
=====---------------

Emacs buffers are implemented using an invisible "gap" to make insertion
and deletion faster.  Insertion works by filling in part of the gap, and
deletion adds to the gap.  Of course, this means that the gap must first
be moved to the locus of the insertion or deletion.  Emacs moves the gap
only when you try to insert or delete.  This is why your first editing
command in one part of a large buffer, after previously editing in
another far-away part, sometimes involves a noticeable delay.

   This mechanism works invisibly, and Lisp code should never be
affected by the gap's current location, but these functions are
available for getting information about the gap status.

 -- Function: gap-position
     This function returns the current gap position in the current
     buffer.

 -- Function: gap-size
     This function returns the current gap size of the current buffer.

==============================================================================
File: elisp.info,  Node: |Windows|,  Next: |Frames|,  Prev: |Buffers|,  Up: |Top|
==============================================================================

                                                                       *Windows*

28 Windows
*****=====

This chapter describes the functions and variables related to Emacs
windows.  *Note Frames::, for how windows are assigned an area of screen
available for Emacs to use.  *Note Display::, for information on how
text is displayed in windows.

MENU

* |Basic_Windows|::           Basic information on using windows.
* |Windows_and_Frames|::      Relating windows to the frame they appear on.
* |Window_Sizes|::            Accessing a window's size.
* |Resizing_Windows|::        Changing the sizes of windows.
* |Preserving_Window_Sizes|:: Preserving the size of windows.
* |Splitting_Windows|::       Creating a new window.
* |Deleting_Windows|::        Removing a window from its frame.
* |Recombining_Windows|::     Preserving the frame layout when splitting and
                              deleting windows.
* |Selecting_Windows|::       The selected window is the one that you edit in.
* |Cyclic_Window_Ordering|::  Moving around the existing windows.
* |Buffers_and_Windows|::     Each window displays the contents of a buffer.
* |Switching_Buffers|::       Higher-level functions for switching to a buffer.
* |Displaying_Buffers|::      Displaying a buffer in a suitable window.
* |Window_History|::          Each window remembers the buffers displayed in it.
* |Dedicated_Windows|::       How to avoid displaying another buffer in
                              a specific window.
* |Quitting_Windows|::        How to restore the state prior to displaying a
                              buffer.
* |Side_Windows|::            Special windows on a frame's sides.
* |Atomic_Windows|::          Preserving parts of the window layout.
* |Window_Point|::            Each window has its own location of point.
* |Window_Start_and_End|::    Buffer positions indicating which text is
                              on-screen in a window.
* |Textual_Scrolling|::       Moving text up and down through the window.
* |Vertical_Scrolling|::      Moving the contents up and down on the window.
* |Horizontal_Scrolling|::    Moving the contents sideways on the window.
* |Coordinates_and_Windows|:: Converting coordinates to windows.
* |Mouse_Window_Auto_selection|:: Automatically selecting windows with the mouse.
* |Window_Configurations|::   Saving and restoring the state of the screen.
* |Window_Parameters|::       Associating additional information with windows.
* |Window_Hooks|::            Hooks for scrolling, window size changes,
                              redisplay going past a certain point,
                              or window configuration changes.

==============================================================================
File: elisp.info,  Node: |Basic_Windows|,  Next: |Windows_and_Frames|,  Up: |Windows|
==============================================================================

                                                                 *Basic_Windows*

28.1 Basic Concepts of Emacs Windows
=====-------------------------------

A "window" is an area of the screen that is used to display a buffer
(*note Buffers::).  In Emacs Lisp, windows are represented by a special
Lisp object type.

   Windows are grouped into frames (*note Frames::).  Each frame
contains at least one window; the user can subdivide it into multiple,
non-overlapping windows to view several buffers at once.  Lisp programs
can use multiple windows for a variety of purposes.  In Rmail, for
example, you can view a summary of message titles in one window, and the
contents of the selected message in another window.

   Emacs uses the word "window" with a different meaning than in
graphical desktop environments and window systems, such as the X Window
System.  When Emacs is run on X, each of its graphical X windows is an
Emacs frame (containing one or more Emacs windows).  When Emacs is run
on a text terminal, the frame fills the entire terminal screen.

   Unlike X windows, Emacs windows are "tiled"; they never overlap
within the area of the frame.  When a window is created, resized, or
deleted, the change in window space is taken from or given to the
adjacent windows, so that the total area of the frame is unchanged.

 -- Function: windowp object
     This function returns 't' if OBJECT is a window (whether or not it
     displays a buffer).  Otherwise, it returns 'nil'.

   A "live window" is one that is actually displaying a buffer in a
frame.

 -- Function: window-live-p object
     This function returns 't' if OBJECT is a live window and 'nil'
     otherwise.  A live window is one that displays a buffer.

   The windows in each frame are organized into a "window tree".  *Note
Windows and Frames::.  The leaf nodes of each window tree are live
windows--the ones actually displaying buffers.  The internal nodes of the
window tree are "internal windows", which are not live.

   A "valid window" is one that is either live or internal.  A valid
window can be "deleted", i.e., removed from its frame (*note Deleting
Windows::); then it is no longer valid, but the Lisp object representing
it might be still referenced from other Lisp objects.  A deleted window
may be made valid again by restoring a saved window configuration (*note
Window Configurations::).

   You can distinguish valid windows from deleted windows with
'window-valid-p'.

 -- Function: window-valid-p object
     This function returns 't' if OBJECT is a live window, or an
     internal window in a window tree.  Otherwise, it returns 'nil',
     including for the case where OBJECT is a deleted window.

   In each frame, at any time, exactly one Emacs window is designated as
"selected within the frame".  For the selected frame, that window is
called the "selected window"--the one in which most editing takes place,
and in which the cursor for selected windows appears (*note Cursor
Parameters::).  Keyboard input that inserts or deletes text is also
normally directed to this window.  The selected window's buffer is
usually also the current buffer, except when 'set-buffer' has been used
(*note Current Buffer::).  As for non-selected frames, the window
selected within the frame becomes the selected window if the frame is
ever selected.  *Note Selecting Windows::.

 -- Function: selected-window
     This function returns the selected window (which is always a live
     window).

   Sometimes several windows collectively and cooperatively display a
buffer, for example, under the management of Follow Mode (*note
(emacs)Follow Mode::), where the windows together display a bigger
portion of the buffer than one window could alone.  It is often useful
to consider such a "window group" as a single entity.  Several functions
such as 'window-group-start' (*note Window Start and End::) allow you to
do this by supplying, as an argument, one of the windows as a stand in
for the whole group.

 -- Function: selected-window-group
     When the selected window is a member of a group of windows, this
     function returns a list of the windows in the group, ordered such
     that the first window in the list is displaying the earliest part
     of the buffer, and so on.  Otherwise the function returns a list
     containing just the selected window.

     The selected window is considered part of a group when the buffer
     local variable 'selected-window-group-function' is set to a
     function.  In this case, 'selected-window-group' calls it with no
     arguments and returns its result (which should be the list of
     windows in the group).

==============================================================================
File: elisp.info,  Node: |Windows_and_Frames|,  Next: |Window_Sizes|,  Prev: |Basic_Windows|,  Up: |Windows|
==============================================================================

                                                            *Windows_and_Frames*

28.2 Windows and Frames
=====------------------

Each window belongs to exactly one frame (*note Frames::).

 -- Function: window-frame &optional window
     This function returns the frame that the window WINDOW belongs to.
     If WINDOW is 'nil', it defaults to the selected window.

 -- Function: window-list &optional frame minibuffer window
     This function returns a list of live windows belonging to the frame
     FRAME.  If FRAME is omitted or 'nil', it defaults to the selected
     frame.

     The optional argument MINIBUFFER specifies whether to include the
     minibuffer window in the returned list.  If MINIBUFFER is 't', the
     minibuffer window is included.  If MINIBUFFER is 'nil' or omitted,
     the minibuffer window is included only if it is active.  If
     MINIBUFFER is neither 'nil' nor 't', the minibuffer window is never
     included.

     The optional argument WINDOW, if non-'nil', should be a live window
     on the specified frame; then WINDOW will be the first element in
     the returned list.  If WINDOW is omitted or 'nil', the window
     selected within the frame is the first element.

   Windows in the same frame are organized into a "window tree", whose
leaf nodes are the live windows.  The internal nodes of a window tree
are not live; they exist for the purpose of organizing the relationships
between live windows.  The root node of a window tree is called the
"root window".  It can be either a live window (if the frame has just
one window), or an internal window.

   A minibuffer window (*note Minibuffer Windows::) that is not alone on
its frame does not have a parent window, so it strictly speaking is not
part of its frame's window tree.  Nonetheless, it is a sibling window of
the frame's root window, and thus can be reached via
'window-next-sibling'.  Also, the function 'window-tree' described at
the end of this section lists the minibuffer window alongside the actual
window tree.

 -- Function: frame-root-window &optional frame-or-window
     This function returns the root window for FRAME-OR-WINDOW.  The
     argument FRAME-OR-WINDOW should be either a window or a frame; if
     omitted or 'nil', it defaults to the selected frame.  If
     FRAME-OR-WINDOW is a window, the return value is the root window of
     that window's frame.

   When a window is split, there are two live windows where previously
there was one.  One of these is represented by the same Lisp window
object as the original window, and the other is represented by a
newly-created Lisp window object.  Both of these live windows become
leaf nodes of the window tree, as "child windows" of a single internal
window.  If necessary, Emacs automatically creates this internal window,
which is also called the "parent window", and assigns it to the
appropriate position in the window tree.  A set of windows that share
the same parent are called "siblings".

 -- Function: window-parent &optional window
     This function returns the parent window of WINDOW.  If WINDOW is
     omitted or 'nil', it defaults to the selected window.  The return
     value is 'nil' if WINDOW has no parent (i.e., it is a minibuffer
     window or the root window of its frame).

   Each internal window always has at least two child windows.  If this
number falls to one as a result of window deletion, Emacs automatically
deletes the internal window, and its sole remaining child window takes
its place in the window tree.

   Each child window can be either a live window, or an internal window
(which in turn would have its own child windows).  Therefore, each
internal window can be thought of as occupying a certain rectangular
"screen area"--the union of the areas occupied by the live windows that
are ultimately descended from it.

   For each internal window, the screen areas of the immediate children
are arranged either vertically or horizontally (never both).  If the
child windows are arranged one above the other, they are said to form a
"vertical combination"; if they are arranged side by side, they are said
to form a "horizontal combination".  Consider the following example:

          ______________________________________
         | ______  ____________________________ |
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W4____________|||
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W5____________|||
         ||__W2__||_____________W3_____________ |
         |__________________W1__________________|


The root window of this frame is an internal window, W1.  Its child
windows form a horizontal combination, consisting of the live window W2
and the internal window W3.  The child windows of W3 form a vertical
combination, consisting of the live windows W4 and W5.  Hence, the live
windows in this window tree are W2, W4, and W5.

   The following functions can be used to retrieve a child window of an
internal window, and the siblings of a child window.

 -- Function: window-top-child &optional window
     This function returns the topmost child window of WINDOW, if WINDOW
     is an internal window whose children form a vertical combination.
     For any other type of window, the return value is 'nil'.

 -- Function: window-left-child &optional window
     This function returns the leftmost child window of WINDOW, if
     WINDOW is an internal window whose children form a horizontal
     combination.  For any other type of window, the return value is
     'nil'.

 -- Function: window-child window
     This function returns the first child window of the internal window
     WINDOW--the topmost child window for a vertical combination, or the
     leftmost child window for a horizontal combination.  If WINDOW is a
     live window, the return value is 'nil'.

 -- Function: window-combined-p &optional window horizontal
     This function returns a non-'nil' value if and only if WINDOW is
     part of a vertical combination.  If WINDOW is omitted or 'nil', it
     defaults to the selected one.

     If the optional argument HORIZONTAL is non-'nil', this means to
     return non-'nil' if and only if WINDOW is part of a horizontal
     combination.

 -- Function: window-next-sibling &optional window
     This function returns the next sibling of the window WINDOW.  If
     omitted or 'nil', WINDOW defaults to the selected window.  The
     return value is 'nil' if WINDOW is the last child of its parent.

 -- Function: window-prev-sibling &optional window
     This function returns the previous sibling of the window WINDOW.
     If omitted or 'nil', WINDOW defaults to the selected window.  The
     return value is 'nil' if WINDOW is the first child of its parent.

   The functions 'window-next-sibling' and 'window-prev-sibling' should
not be confused with the functions 'next-window' and 'previous-window',
which return the next and previous window, respectively, in the cyclic
ordering of windows (*note Cyclic Window Ordering::).

   The following functions can be useful to locate a window within its
frame.

 -- Function: frame-first-window &optional frame-or-window
     This function returns the live window at the upper left corner of
     the frame specified by FRAME-OR-WINDOW.  The argument
     FRAME-OR-WINDOW must denote a window or a live frame and defaults
     to the selected frame.  If FRAME-OR-WINDOW specifies a window, this
     function returns the first window on that window's frame.  Under
     the assumption that the frame from our canonical example is
     selected '(frame-first-window)' returns W2.

 -- Function: window-at-side-p &optional window side
     This function returns 't' if WINDOW is located at SIDE of its
     containing frame.  The argument WINDOW must be a valid window and
     defaults to the selected one.  The argument SIDE can be any of the
     symbols 'left', 'top', 'right' or 'bottom'.  The default value
     'nil' is handled like 'bottom'.

     Note that this function disregards the minibuffer window (*note
     Minibuffer Windows::).  Hence, with SIDE equal to 'bottom' it may
     return 't' also when the minibuffer window appears right below
     WINDOW.

 -- Function: window-in-direction direction &optional window ignore sign
          wrap mini
     This function returns the nearest live window in direction
     DIRECTION as seen from the position of 'window-point' in window
     WINDOW.  The argument DIRECTION must be one of 'above', 'below',
     'left' or 'right'.  The optional argument WINDOW must denote a live
     window and defaults to the selected one.

     This function does not return a window whose 'no-other-window'
     parameter is non-'nil' (*note Window Parameters::).  If the nearest
     window's 'no-other-window' parameter is non-'nil', this function
     tries to find another window in the indicated direction whose
     'no-other-window' parameter is 'nil'.  If the optional argument
     IGNORE is non-'nil', a window may be returned even if its
     'no-other-window' parameter is non-'nil'.

     If the optional argument SIGN is a negative number, it means to use
     the right or bottom edge of WINDOW as reference position instead of
     'window-point'.  If SIGN is a positive number, it means to use the
     left or top edge of WINDOW as reference position.

     If the optional argument WRAP is non-'nil', this means to wrap
     DIRECTION around frame borders.  For example, if WINDOW is at the
     top of the frame and DIRECTION is 'above', then this function
     usually returns the frame's minibuffer window if it's active and a
     window at the bottom of the frame otherwise.

     If the optional argument MINI is 'nil', this means to return the
     minibuffer window if and only if it is currently active.  If MINI
     is non-'nil', this function may return the minibuffer window even
     when it's not active.  However, if WRAP is non-'nil', it always
     acts as if MINI were 'nil'.

     If it doesn't find a suitable window, this function returns 'nil'.

     Don't use this function to check whether there is _no_ window in
     DIRECTION.  Calling 'window-at-side-p' described above is a much
     more efficient way to do that.

   The following function allows the entire window tree of a frame to be
retrieved:

 -- Function: window-tree &optional frame
     This function returns a list representing the window tree for frame
     FRAME.  If FRAME is omitted or 'nil', it defaults to the selected
     frame.

     The return value is a list of the form '(ROOT MINI)', where ROOT
     represents the window tree of the frame's root window, and MINI is
     the frame's minibuffer window.

     If the root window is live, ROOT is that window itself.  Otherwise,
     ROOT is a list '(DIR EDGES W1 W2 ...)' where DIR is 'nil' for a
     horizontal combination and 't' for a vertical combination, EDGES
     gives the size and position of the combination, and the remaining
     elements are the child windows.  Each child window may again be a
     window object (for a live window) or a list with the same format as
     above (for an internal window).  The EDGES element is a list '(LEFT
     TOP RIGHT BOTTOM)', similar to the value returned by 'window-edges'
     (*note Coordinates and Windows::).

==============================================================================
File: elisp.info,  Node: |Window_Sizes|,  Next: |Resizing_Windows|,  Prev: |Windows_and_Frames|,  Up: |Windows|
==============================================================================

                                                                  *Window_Sizes*

28.3 Window Sizes
=====------------

The following schematic shows the structure of a live window:

             ____________________________________________
            |______________ Header Line ______________|RD| ^
          ^ |LS|LM|LF|                       |RF|RM|RS|  | |
          | |  |  |  |                       |  |  |  |  | |
     Window |  |  |  |       Text Area       |  |  |  |  | Window
     Body | |  |  |  |     (Window Body)     |  |  |  |  | Total
     Height |  |  |  |                       |  |  |  |  | Height
          | |  |  |  |<- Window Body Width ->|  |  |  |  | |
          v |__|__|__|_______________________|__|__|__|  | |
            |_________ Horizontal Scroll Bar _________|  | |
            |_______________ Mode Line _______________|__| |
            |_____________ Bottom Divider _______________| v
             <---------- Window Total Width ------------>


   At the center of the window is the "text area", or "body", where the
buffer text is displayed.  The text area can be surrounded by a series
of optional areas.  On the left and right, from innermost to outermost,
these are the left and right fringes, denoted by LF and RF (*note
Fringes::); the left and right margins, denoted by LM and RM in the
schematic (*note Display Margins::); the left or right vertical scroll
bar, only one of which is present at any time, denoted by LS and RS
(*note Scroll Bars::); and the right divider, denoted by RD (*note
Window Dividers::).  At the top of the window is the header line (*note
Header Lines::).  At the bottom of the window are the horizontal scroll
bar (*note Scroll Bars::); the mode line (*note Mode Line Format::); and
the bottom divider (*note Window Dividers::).

   Emacs provides miscellaneous functions for finding the height and
width of a window.  The return value of many of these functions can be
specified either in units of pixels or in units of lines and columns.
On a graphical display, the latter actually correspond to the height and
width of a default character specified by the frame's default font as
returned by 'frame-char-height' and 'frame-char-width' (*note Frame
Font::).  Thus, if a window is displaying text with a different font or
size, the reported line height and column width for that window may
differ from the actual number of text lines or columns displayed within
it.

   The "total height" of a window is the number of lines comprising the
window's body, the header line, the horizontal scroll bar, the mode line
and the bottom divider (if any).

 -- Function: window-total-height &optional window round
     This function returns the total height, in lines, of the window
     WINDOW.  If WINDOW is omitted or 'nil', it defaults to the selected
     window.  If WINDOW is an internal window, the return value is the
     total height occupied by its descendant windows.

     If a window's pixel height is not an integral multiple of its
     frame's default character height, the number of lines occupied by
     the window is rounded internally.  This is done in a way such that,
     if the window is a parent window, the sum of the total heights of
     all its child windows internally equals the total height of their
     parent.  This means that although two windows have the same pixel
     height, their internal total heights may differ by one line.  This
     means also, that if window is vertically combined and has a next
     sibling, the topmost row of that sibling can be calculated as the
     sum of this window's topmost row and total height (*note
     Coordinates and Windows::)

     If the optional argument ROUND is 'ceiling', this function returns
     the smallest integer larger than WINDOW's pixel height divided by
     the character height of its frame; if it is 'floor', it returns the
     largest integer smaller than said value; with any other ROUND it
     returns the internal value of WINDOWS's total height.

   The "total width" of a window is the number of lines comprising the
window's body, its margins, fringes, scroll bars and a right divider (if
any).

 -- Function: window-total-width &optional window round
     This function returns the total width, in columns, of the window
     WINDOW.  If WINDOW is omitted or 'nil', it defaults to the selected
     window.  If WINDOW is internal, the return value is the total width
     occupied by its descendant windows.

     If a window's pixel width is not an integral multiple of its
     frame's character width, the number of lines occupied by the window
     is rounded internally.  This is done in a way such that, if the
     window is a parent window, the sum of the total widths of all its
     children internally equals the total width of their parent.  This
     means that although two windows have the same pixel width, their
     internal total widths may differ by one column.  This means also,
     that if this window is horizontally combined and has a next
     sibling, the leftmost column of that sibling can be calculated as
     the sum of this window's leftmost column and total width (*note
     Coordinates and Windows::).  The optional argument ROUND behaves as
     it does for 'window-total-height'.

 -- Function: window-total-size &optional window horizontal round
     This function returns either the total height in lines or the total
     width in columns of the window WINDOW.  If HORIZONTAL is omitted or
     'nil', this is equivalent to calling 'window-total-height' for
     WINDOW; otherwise it is equivalent to calling 'window-total-width'
     for WINDOW.  The optional argument ROUND behaves as it does for
     'window-total-height'.

   The following two functions can be used to return the total size of a
window in units of pixels.

 -- Function: window-pixel-height &optional window
     This function returns the total height of window WINDOW in pixels.
     WINDOW must be a valid window and defaults to the selected one.

     The return value includes mode and header line, a horizontal scroll
     bar and a bottom divider, if any.  If WINDOW is an internal window,
     its pixel height is the pixel height of the screen areas spanned by
     its children.

 -- Function: window-pixel-width &optional window
     This function returns the width of window WINDOW in pixels.  WINDOW
     must be a valid window and defaults to the selected one.

     The return value includes the fringes and margins of WINDOW as well
     as any vertical dividers or scroll bars belonging to WINDOW.  If
     WINDOW is an internal window, its pixel width is the width of the
     screen areas spanned by its children.

   The following functions can be used to determine whether a given
window has any adjacent windows.

 -- Function: window-full-height-p &optional window
     This function returns non-'nil' if WINDOW has no other window above
     or below it in its frame.  More precisely, this means that the
     total height of WINDOW equals the total height of the root window
     on that frame.  The minibuffer window does not count in this
     regard.  If WINDOW is omitted or 'nil', it defaults to the selected
     window.

 -- Function: window-full-width-p &optional window
     This function returns non-'nil' if WINDOW has no other window to
     the left or right in its frame, i.e., its total width equals that
     of the root window on that frame.  If WINDOW is omitted or 'nil',
     it defaults to the selected window.

   The "body height" of a window is the height of its text area, which
does not include a mode or header line, a horizontal scroll bar, or a
bottom divider.

 -- Function: window-body-height &optional window pixelwise
     This function returns the height, in lines, of the body of window
     WINDOW.  If WINDOW is omitted or 'nil', it defaults to the selected
     window; otherwise it must be a live window.

     If the optional argument PIXELWISE is non-'nil', this function
     returns the body height of WINDOW counted in pixels.

     If PIXELWISE is 'nil', the return value is rounded down to the
     nearest integer, if necessary.  This means that if a line at the
     bottom of the text area is only partially visible, that line is not
     counted.  It also means that the height of a window's body can
     never exceed its total height as returned by 'window-total-height'.

   The "body width" of a window is the width of its text area, which
does not include the scroll bar, fringes, margins or a right divider.
Note that when one or both fringes are removed (by setting their width
to zero), the display engine reserves two character cells, one on each
side of the window, for displaying the continuation and truncation
glyphs, which leaves 2 columns less for text display.  (The function
'window-max-chars-per-line', described below, takes this peculiarity
into account.)

 -- Function: window-body-width &optional window pixelwise
     This function returns the width, in columns, of the body of window
     WINDOW.  If WINDOW is omitted or 'nil', it defaults to the selected
     window; otherwise it must be a live window.

     If the optional argument PIXELWISE is non-'nil', this function
     returns the body width of WINDOW in units of pixels.

     If PIXELWISE is 'nil', the return value is rounded down to the
     nearest integer, if necessary.  This means that if a column on the
     right of the text area is only partially visible, that column is
     not counted.  It also means that the width of a window's body can
     never exceed its total width as returned by 'window-total-width'.

 -- Function: window-body-size &optional window horizontal pixelwise
     This function returns the body height or body width of WINDOW.  If
     HORIZONTAL is omitted or 'nil', it is equivalent to calling
     'window-body-height' for WINDOW; otherwise it is equivalent to
     calling 'window-body-width'.  In either case, the optional argument
     PIXELWISE is passed to the function called.

   For compatibility with previous versions of Emacs, 'window-height' is
an alias for 'window-total-height', and 'window-width' is an alias for
'window-body-width'.  These aliases are considered obsolete and will be
removed in the future.

   The pixel heights of a window's mode and header line can be retrieved
with the functions given below.  Their return value is usually accurate
unless the window has not been displayed before: In that case, the
return value is based on an estimate of the font used for the window's
frame.

 -- Function: window-mode-line-height &optional window
     This function returns the height in pixels of WINDOW's mode line.
     WINDOW must be a live window and defaults to the selected one.  If
     WINDOW has no mode line, the return value is zero.

 -- Function: window-header-line-height &optional window
     This function returns the height in pixels of WINDOW's header line.
     WINDOW must be a live window and defaults to the selected one.  If
     WINDOW has no header line, the return value is zero.

   Functions for retrieving the height and/or width of window dividers
(*note Window Dividers::), fringes (*note Fringes::), scroll bars (*note
Scroll Bars::), and display margins (*note Display Margins::) are
described in the corresponding sections.

   If your Lisp program needs to make layout decisions, you will find
the following function useful:

 -- Function: window-max-chars-per-line &optional window face
     This function returns the number of characters displayed in the
     specified face FACE in the specified window WINDOW (which must be a
     live window).  If FACE was remapped (*note Face Remapping::), the
     information is returned for the remapped face.  If omitted or
     'nil', FACE defaults to the default face, and WINDOW defaults to
     the selected window.

     Unlike 'window-body-width', this function accounts for the actual
     size of FACE's font, instead of working in units of the canonical
     character width of WINDOW's frame (*note Frame Font::).  It also
     accounts for space used by the continuation glyph, if WINDOW lacks
     one or both of its fringes.

   Commands that change the size of windows (*note Resizing Windows::),
or split them (*note Splitting Windows::), obey the variables
'window-min-height' and 'window-min-width', which specify the smallest
allowable window height and width.  They also obey the variable
'window-size-fixed', with which a window can be "fixed" in size (*note
Preserving Window Sizes::).

 -- User Option: window-min-height
     This option specifies the minimum total height, in lines, of any
     window.  Its value has to accommodate at least one text line as
     well as a mode and header line, a horizontal scroll bar and a
     bottom divider, if present.

 -- User Option: window-min-width
     This option specifies the minimum total width, in columns, of any
     window.  Its value has to accommodate two text columns as well as
     margins, fringes, a scroll bar and a right divider, if present.

   The following function tells how small a specific window can get
taking into account the sizes of its areas and the values of
'window-min-height', 'window-min-width' and 'window-size-fixed' (*note
Preserving Window Sizes::).

 -- Function: window-min-size &optional window horizontal ignore
          pixelwise
     This function returns the minimum size of WINDOW.  WINDOW must be a
     valid window and defaults to the selected one.  The optional
     argument HORIZONTAL non-'nil' means to return the minimum number of
     columns of WINDOW; otherwise return the minimum number of WINDOW's
     lines.

     The return value makes sure that all components of WINDOW remain
     fully visible if WINDOW's size were actually set to it.  With
     HORIZONTAL 'nil' it includes the mode and header line, the
     horizontal scroll bar and the bottom divider, if present.  With
     HORIZONTAL non-'nil' it includes the margins and fringes, the
     vertical scroll bar and the right divider, if present.

     The optional argument IGNORE, if non-'nil', means ignore
     restrictions imposed by fixed size windows, 'window-min-height' or
     'window-min-width' settings.  If IGNORE equals 'safe', live windows
     may get as small as 'window-safe-min-height' lines and
     'window-safe-min-width' columns.  If IGNORE is a window, ignore
     restrictions for that window only.  Any other non-'nil' value means
     ignore all of the above restrictions for all windows.

     The optional argument PIXELWISE non-'nil' means to return the
     minimum size of WINDOW counted in pixels.

==============================================================================
File: elisp.info,  Node: |Resizing_Windows|,  Next: |Preserving_Window_Sizes|,  Prev: |Window_Sizes|,  Up: |Windows|
==============================================================================

                                                              *Resizing_Windows*

28.4 Resizing Windows
=====----------------

This section describes functions for resizing a window without changing
the size of its frame.  Because live windows do not overlap, these
functions are meaningful only on frames that contain two or more
windows: resizing a window also changes the size of a neighboring
window.  If there is just one window on a frame, its size cannot be
changed except by resizing the frame (*note Frame Size::).

   Except where noted, these functions also accept internal windows as
arguments.  Resizing an internal window causes its child windows to be
resized to fit the same space.

 -- Function: window-resizable window delta &optional horizontal ignore
          pixelwise
     This function returns DELTA if the size of WINDOW can be changed
     vertically by DELTA lines.  If the optional argument HORIZONTAL is
     non-'nil', it instead returns DELTA if WINDOW can be resized
     horizontally by DELTA columns.  It does not actually change the
     window size.

     If WINDOW is 'nil', it defaults to the selected window.

     A positive value of DELTA means to check whether the window can be
     enlarged by that number of lines or columns; a negative value of
     DELTA means to check whether the window can be shrunk by that many
     lines or columns.  If DELTA is non-zero, a return value of 0 means
     that the window cannot be resized.

     Normally, the variables 'window-min-height' and 'window-min-width'
     specify the smallest allowable window size (*note Window Sizes::).
     However, if the optional argument IGNORE is non-'nil', this
     function ignores 'window-min-height' and 'window-min-width', as
     well as 'window-size-fixed'.  Instead, it considers the
     minimum-height window to be one consisting of a header and a mode
     line, a horizontal scrollbar and a bottom divider (if any), plus a
     text area one line tall; and a minimum-width window as one
     consisting of fringes, margins, a scroll bar and a right divider
     (if any), plus a text area two columns wide.

     If the optional argument PIXELWISE is non-'nil', DELTA is
     interpreted as pixels.

 -- Function: window-resize window delta &optional horizontal ignore
          pixelwise
     This function resizes WINDOW by DELTA increments.  If HORIZONTAL is
     'nil', it changes the height by DELTA lines; otherwise, it changes
     the width by DELTA columns.  A positive DELTA means to enlarge the
     window, and a negative DELTA means to shrink it.

     If WINDOW is 'nil', it defaults to the selected window.  If the
     window cannot be resized as demanded, an error is signaled.

     The optional argument IGNORE has the same meaning as for the
     function 'window-resizable' above.

     If the optional argument PIXELWISE is non-'nil', DELTA will be
     interpreted as pixels.

     The choice of which window edges this function alters depends on
     the values of the option 'window-combination-resize' and the
     combination limits of the involved windows; in some cases, it may
     alter both edges.  *Note Recombining Windows::.  To resize by
     moving only the bottom or right edge of a window, use the function
     'adjust-window-trailing-edge'.

 -- Function: adjust-window-trailing-edge window delta &optional
          horizontal pixelwise
     This function moves WINDOW's bottom edge by DELTA lines.  If
     optional argument HORIZONTAL is non-'nil', it instead moves the
     right edge by DELTA columns.  If WINDOW is 'nil', it defaults to
     the selected window.

     If the optional argument PIXELWISE is non-'nil', DELTA is
     interpreted as pixels.

     A positive DELTA moves the edge downwards or to the right; a
     negative DELTA moves it upwards or to the left.  If the edge cannot
     be moved as far as specified by DELTA, this function moves it as
     far as possible but does not signal an error.

     This function tries to resize windows adjacent to the edge that is
     moved.  If this is not possible for some reason (e.g., if that
     adjacent window is fixed-size), it may resize other windows.

 -- User Option: window-resize-pixelwise
     If the value of this option is non-'nil', Emacs resizes windows in
     units of pixels.  This currently affects functions like
     'split-window' (*note Splitting Windows::), 'maximize-window',
     'minimize-window', 'fit-window-to-buffer', 'fit-frame-to-buffer'
     and 'shrink-window-if-larger-than-buffer' (all listed below).

     Note that when a frame's pixel size is not a multiple of its
     character size, at least one window may get resized pixelwise even
     if this option is 'nil'.  The default value is 'nil'.

   The following commands resize windows in more specific ways.  When
called interactively, they act on the selected window.

 -- Command: fit-window-to-buffer &optional window max-height min-height
          max-width min-width preserve-size
     This command adjusts the height or width of WINDOW to fit the text
     in it.  It returns non-'nil' if it was able to resize WINDOW, and
     'nil' otherwise.  If WINDOW is omitted or 'nil', it defaults to the
     selected window.  Otherwise, it should be a live window.

     If WINDOW is part of a vertical combination, this function adjusts
     WINDOW's height.  The new height is calculated from the actual
     height of the accessible portion of its buffer.  The optional
     argument MAX-HEIGHT, if non-'nil', specifies the maximum total
     height that this function can give WINDOW.  The optional argument
     MIN-HEIGHT, if non-'nil', specifies the minimum total height that
     it can give, which overrides the variable 'window-min-height'.
     Both MAX-HEIGHT and MIN-HEIGHT are specified in lines and include
     mode and header line and a bottom divider, if any.

     If WINDOW is part of a horizontal combination and the value of the
     option 'fit-window-to-buffer-horizontally' (see below) is
     non-'nil', this function adjusts WINDOW's width.  The new width of
     WINDOW is calculated from the maximum length of its buffer's lines
     that follow the current start position of WINDOW.  The optional
     argument MAX-WIDTH specifies a maximum width and defaults to the
     width of WINDOW's frame.  The optional argument MIN-WIDTH specifies
     a minimum width and defaults to 'window-min-width'.  Both MAX-WIDTH
     and MIN-WIDTH are specified in columns and include fringes, margins
     and scrollbars, if any.

     The optional argument PRESERVE-SIZE, if non-'nil', will install a
     parameter to preserve the size of WINDOW during future resize
     operations (*note Preserving Window Sizes::).

     If the option 'fit-frame-to-buffer' (see below) is non-'nil', this
     function will try to resize the frame of WINDOW to fit its contents
     by calling 'fit-frame-to-buffer' (see below).

 -- User Option: fit-window-to-buffer-horizontally
     If this is non-'nil', 'fit-window-to-buffer' can resize windows
     horizontally.  If this is 'nil' (the default)
     'fit-window-to-buffer' never resizes windows horizontally.  If this
     is 'only', it can resize windows horizontally only.  Any other
     value means 'fit-window-to-buffer' can resize windows in both
     dimensions.

 -- User Option: fit-frame-to-buffer
     If this option is non-'nil', 'fit-window-to-buffer' can fit a frame
     to its buffer.  A frame is fit if and only if its root window is a
     live window and this option is non-'nil'.  If this is
     'horizontally', frames are fit horizontally only.  If this is
     'vertically', frames are fit vertically only.  Any other non-'nil'
     value means frames can be resized in both dimensions.

   If you have a frame that displays only one window, you can fit that
frame to its buffer using the command 'fit-frame-to-buffer'.

 -- Command: fit-frame-to-buffer &optional frame max-height min-height
          max-width min-width only
     This command adjusts the size of FRAME to display the contents of
     its buffer exactly.  FRAME can be any live frame and defaults to
     the selected one.  Fitting is done only if FRAME's root window is
     live.  The arguments MAX-HEIGHT, MIN-HEIGHT, MAX-WIDTH and
     MIN-WIDTH specify bounds on the new total size of FRAME's root
     window.  MIN-HEIGHT and MIN-WIDTH default to the values of
     'window-min-height' and 'window-min-width' respectively.

     If the optional argument ONLY is 'vertically', this function may
     resize the frame vertically only.  If ONLY is 'horizontally', it
     may resize the frame horizontally only.

   The behavior of 'fit-frame-to-buffer' can be controlled with the help
of the two options listed next.

 -- User Option: fit-frame-to-buffer-margins
     This option can be used to specify margins around frames to be fit
     by 'fit-frame-to-buffer'.  Such margins can be useful to avoid, for
     example, that the resized frame overlaps the taskbar or parts of
     its parent frame.

     It specifies the numbers of pixels to be left free on the left,
     above, the right, and below a frame that shall be fit.  The default
     specifies 'nil' for each which means to use no margins.  The value
     specified here can be overridden for a specific frame by that
     frame's 'fit-frame-to-buffer-margins' parameter, if present.

 -- User Option: fit-frame-to-buffer-sizes
     This option specifies size boundaries for 'fit-frame-to-buffer'.
     It specifies the total maximum and minimum lines and maximum and
     minimum columns of the root window of any frame that shall be fit
     to its buffer.  If any of these values is non-'nil', it overrides
     the corresponding argument of 'fit-frame-to-buffer'.

 -- Command: shrink-window-if-larger-than-buffer &optional window
     This command attempts to reduce WINDOW's height as much as possible
     while still showing its full buffer, but no less than
     'window-min-height' lines.  The return value is non-'nil' if the
     window was resized, and 'nil' otherwise.  If WINDOW is omitted or
     'nil', it defaults to the selected window.  Otherwise, it should be
     a live window.

     This command does nothing if the window is already too short to
     display all of its buffer, or if any of the buffer is scrolled
     off-screen, or if the window is the only live window in its frame.

     This command calls 'fit-window-to-buffer' (see above) to do its
     work.

 -- Command: balance-windows &optional window-or-frame
     This function balances windows in a way that gives more space to
     full-width and/or full-height windows.  If WINDOW-OR-FRAME
     specifies a frame, it balances all windows on that frame.  If
     WINDOW-OR-FRAME specifies a window, it balances only that window
     and its siblings (*note Windows and Frames::).

 -- Command: balance-windows-area
     This function attempts to give all windows on the selected frame
     approximately the same share of the screen area.  Full-width or
     full-height windows are not given more space than other windows.

 -- Command: maximize-window &optional window
     This function attempts to make WINDOW as large as possible, in both
     dimensions, without resizing its frame or deleting other windows.
     If WINDOW is omitted or 'nil', it defaults to the selected window.

 -- Command: minimize-window &optional window
     This function attempts to make WINDOW as small as possible, in both
     dimensions, without deleting it or resizing its frame.  If WINDOW
     is omitted or 'nil', it defaults to the selected window.

==============================================================================
File: elisp.info,  Node: |Preserving_Window_Sizes|,  Next: |Splitting_Windows|,  Prev: |Resizing_Windows|,  Up: |Windows|
==============================================================================

                                                       *Preserving_Window_Sizes*

28.5 Preserving Window Sizes
=====-----------------------

A window can get resized explicitly by using one of the functions from
the preceding section or implicitly, for example, when resizing an
adjacent window, when splitting or deleting a window (*note Splitting
Windows::, *note Deleting Windows::) or when resizing the window's frame
(*note Frame Size::).

   It is possible to avoid implicit resizing of a specific window when
there are one or more other resizable windows on the same frame.  For
this purpose, Emacs must be advised to "preserve" the size of that
window.  There are two basic ways to do that.

 -- Variable: window-size-fixed
     If this buffer-local variable is non-'nil', the size of any window
     displaying the buffer cannot normally be changed.  Deleting a
     window or changing the frame's size may still change the window's
     size, if there is no choice.

     If the value is 'height', then only the window's height is fixed;
     if the value is 'width', then only the window's width is fixed.
     Any other non-'nil' value fixes both the width and the height.

     If this variable is 'nil', this does not necessarily mean that any
     window showing the buffer can be resized in the desired direction.
     To determine that, use the function 'window-resizable'.  *Note
     Resizing Windows::.

   Often 'window-size-fixed' is overly aggressive because it inhibits
any attempt to explicitly resize or split an affected window as well.
This may even happen after the window has been resized implicitly, for
example, when deleting an adjacent window or resizing the window's
frame.  The following function tries hard to never disallow resizing
such a window explicitly:

 -- Function: window-preserve-size &optional window horizontal preserve
     This function (un-)marks the height of window WINDOW as preserved
     for future resize operations.  WINDOW must be a live window and
     defaults to the selected one.  If the optional argument HORIZONTAL
     is non-'nil', it (un-)marks the width of WINDOW as preserved.

     If the optional argument PRESERVE is 't', this means to preserve
     the current height/width of WINDOW's body.  The height/width of
     WINDOW will change only if Emacs has no better choice.  Resizing a
     window whose height/width is preserved by this function never
     throws an error.

     If PRESERVE is 'nil', this means to stop preserving the
     height/width of WINDOW, lifting any respective restraint induced by
     a previous call of this function for WINDOW.  Calling
     'enlarge-window', 'shrink-window' or 'fit-window-to-buffer' with
     WINDOW as argument may also remove the respective restraint.

   'window-preserve-size' is currently invoked by the following
functions:

'fit-window-to-buffer'
     If the optional argument PRESERVE-SIZE of that function (*note
     Resizing Windows::) is non-'nil', the size established by that
     function is preserved.

'display-buffer'
     If the ALIST argument of that function (*note Choosing Window::)
     contains a 'preserve-size' entry, the size of the window produced
     by that function is preserved.

   'window-preserve-size' installs a window parameter (*note Window
Parameters::) called 'window-preserved-size' which is consulted by the
window resizing functions.  This parameter will not prevent resizing the
window when the window shows another buffer than the one when
'window-preserve-size' was invoked or if its size has changed since
then.

   The following function can be used to check whether the height of a
particular window is preserved:

 -- Function: window-preserved-size &optional window horizontal
     This function returns the preserved height of window WINDOW in
     pixels.  WINDOW must be a live window and defaults to the selected
     one.  If the optional argument HORIZONTAL is non-'nil', it returns
     the preserved width of WINDOW.  It returns 'nil' if the size of
     WINDOW is not preserved.

==============================================================================
File: elisp.info,  Node: |Splitting_Windows|,  Next: |Deleting_Windows|,  Prev: |Preserving_Window_Sizes|,  Up: |Windows|
==============================================================================

                                                             *Splitting_Windows*

28.6 Splitting Windows
=====-----------------

This section describes functions for creating a new window by
"splitting" an existing one.  Note that some windows are special in the
sense that these functions may fail to split them as described here.
Examples of such windows are side windows (*note Side Windows::) and
atomic windows (*note Atomic Windows::).

 -- Function: split-window &optional window size side pixelwise
     This function creates a new live window next to the window WINDOW.
     If WINDOW is omitted or 'nil', it defaults to the selected window.
     That window is split, and reduced in size.  The space is taken up
     by the new window, which is returned.

     The optional second argument SIZE determines the sizes of WINDOW
     and/or the new window.  If it is omitted or 'nil', both windows are
     given equal sizes; if there is an odd line, it is allocated to the
     new window.  If SIZE is a positive number, WINDOW is given SIZE
     lines (or columns, depending on the value of SIDE).  If SIZE is a
     negative number, the new window is given -SIZE lines (or columns).

     If SIZE is 'nil', this function obeys the variables
     'window-min-height' and 'window-min-width' (*note Window Sizes::).
     Thus, it signals an error if splitting would result in making a
     window smaller than those variables specify.  However, a non-'nil'
     value for SIZE causes those variables to be ignored; in that case,
     the smallest allowable window is considered to be one that has
     space for a text area one line tall and/or two columns wide.

     Hence, if SIZE is specified, it's the caller's responsibility to
     check whether the emanating windows are large enough to encompass
     all areas like a mode line or a scroll bar.  The function
     'window-min-size' (*note Window Sizes::) can be used to determine
     the minimum requirements of WINDOW in this regard.  Since the new
     window usually inherits areas like the mode line or the scroll bar
     from WINDOW, that function is also a good guess for the minimum
     size of the new window.  The caller should specify a smaller size
     only if it correspondingly removes an inherited area before the
     next redisplay.

     The optional third argument SIDE determines the position of the new
     window relative to WINDOW.  If it is 'nil' or 'below', the new
     window is placed below WINDOW.  If it is 'above', the new window is
     placed above WINDOW.  In both these cases, SIZE specifies a total
     window height, in lines.

     If SIDE is 't' or 'right', the new window is placed on the right of
     WINDOW.  If SIDE is 'left', the new window is placed on the left of
     WINDOW.  In both these cases, SIZE specifies a total window width,
     in columns.

     The optional fourth argument PIXELWISE, if non-'nil', means to
     interpret SIZE in units of pixels, instead of lines and columns.

     If WINDOW is a live window, the new window inherits various
     properties from it, including margins and scroll bars.  If WINDOW
     is an internal window, the new window inherits the properties of
     the window selected within WINDOW's frame.

     The behavior of this function may be altered by the window
     parameters of WINDOW, so long as the variable
     'ignore-window-parameters' is 'nil'.  If the value of the
     'split-window' window parameter is 't', this function ignores all
     other window parameters.  Otherwise, if the value of the
     'split-window' window parameter is a function, that function is
     called with the arguments WINDOW, SIZE, and SIDE, in lieu of the
     usual action of 'split-window'.  Otherwise, this function obeys the
     'window-atom' or 'window-side' window parameter, if any.  *Note
     Window Parameters::.

   As an example, here is a sequence of 'split-window' calls that yields
the window configuration discussed in *note Windows and Frames::.  This
example demonstrates splitting a live window as well as splitting an
internal window.  We begin with a frame containing a single window (a
live root window), which we denote by W4.  Calling '(split-window W4)'
yields this window configuration:

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W5_________________||
         |__________________W3__________________|


The 'split-window' call has created a new live window, denoted by W5.
It has also created a new internal window, denoted by W3, which becomes
the root window and the parent of both W4 and W5.

   Next, we call '(split-window W3 nil 'left)', passing the internal
window W3 as the argument.  The result:

          ______________________________________
         | ______  ____________________________ |
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W4____________|||
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W5____________|||
         ||__W2__||_____________W3_____________ |
         |__________________W1__________________|

A new live window W2 is created, to the left of the internal window W3.
A new internal window W1 is created, becoming the new root window.

   For interactive use, Emacs provides two commands which always split
the selected window.  These call 'split-window' internally.

 -- Command: split-window-right &optional size
     This function splits the selected window into two side-by-side
     windows, putting the selected window on the left.  If SIZE is
     positive, the left window gets SIZE columns; if SIZE is negative,
     the right window gets -SIZE columns.

 -- Command: split-window-below &optional size
     This function splits the selected window into two windows, one
     above the other, leaving the upper window selected.  If SIZE is
     positive, the upper window gets SIZE lines; if SIZE is negative,
     the lower window gets -SIZE lines.

 -- User Option: split-window-keep-point
     If the value of this variable is non-'nil' (the default),
     'split-window-below' behaves as described above.

     If it is 'nil', 'split-window-below' adjusts point in each of the
     two windows to minimize redisplay.  (This is useful on slow
     terminals.)  It selects whichever window contains the screen line
     that point was previously on.  Note that this only affects
     'split-window-below', not the lower-level 'split-window' function.

==============================================================================
File: elisp.info,  Node: |Deleting_Windows|,  Next: |Recombining_Windows|,  Prev: |Splitting_Windows|,  Up: |Windows|
==============================================================================

                                                              *Deleting_Windows*

28.7 Deleting Windows
=====----------------

"Deleting" a window removes it from the frame's window tree.  If the
window is a live window, it disappears from the screen.  If the window
is an internal window, its child windows are deleted too.

   Even after a window is deleted, it continues to exist as a Lisp
object, until there are no more references to it.  Window deletion can
be reversed, by restoring a saved window configuration (*note Window
Configurations::).

 -- Command: delete-window &optional window
     This function removes WINDOW from display and returns 'nil'.  If
     WINDOW is omitted or 'nil', it defaults to the selected window.

     If deleting the window would leave no more windows in the window
     tree (e.g., if it is the only live window in the frame) or all
     remaining windows on WINDOW's frame are side windows (*note Side
     Windows::), an error is signaled.  If WINDOW is part of an atomic
     window (*note Atomic Windows::), this function tries to delete the
     root of that atomic window instead.

     By default, the space taken up by WINDOW is given to one of its
     adjacent sibling windows, if any.  However, if the variable
     'window-combination-resize' is non-'nil', the space is
     proportionally distributed among any remaining windows in the same
     window combination.  *Note Recombining Windows::.

     The behavior of this function may be altered by the window
     parameters of WINDOW, so long as the variable
     'ignore-window-parameters' is 'nil'.  If the value of the
     'delete-window' window parameter is 't', this function ignores all
     other window parameters.  Otherwise, if the value of the
     'delete-window' window parameter is a function, that function is
     called with the argument WINDOW, in lieu of the usual action of
     'delete-window'.  *Note Window Parameters::.

 -- Command: delete-other-windows &optional window
     This function makes WINDOW fill its frame, deleting other windows
     as necessary.  If WINDOW is omitted or 'nil', it defaults to the
     selected window.  An error is signaled if WINDOW is a side window
     (*note Side Windows::).  If WINDOW is part of an atomic window
     (*note Atomic Windows::), this function tries to make the root of
     that atomic window fill its frame.  The return value is 'nil'.

     The behavior of this function may be altered by the window
     parameters of WINDOW, so long as the variable
     'ignore-window-parameters' is 'nil'.  If the value of the
     'delete-other-windows' window parameter is 't', this function
     ignores all other window parameters.  Otherwise, if the value of
     the 'delete-other-windows' window parameter is a function, that
     function is called with the argument WINDOW, in lieu of the usual
     action of 'delete-other-windows'.  *Note Window Parameters::.

     Also, if 'ignore-window-parameters' is 'nil', this function does
     not delete any window whose 'no-delete-other-windows' parameter is
     non-'nil'.

 -- Command: delete-windows-on &optional buffer-or-name frame
     This function deletes all windows showing BUFFER-OR-NAME, by
     calling 'delete-window' on those windows.  BUFFER-OR-NAME should be
     a buffer, or the name of a buffer; if omitted or 'nil', it defaults
     to the current buffer.  If there are no windows showing the
     specified buffer, this function does nothing.  If the specified
     buffer is a minibuffer, an error is signaled.

     If there is a dedicated window showing the buffer, and that window
     is the only one on its frame, this function also deletes that frame
     if it is not the only frame on the terminal.

     The optional argument FRAME specifies which frames to operate on:

        * 'nil' means operate on all frames.
        * 't' means operate on the selected frame.
        * 'visible' means operate on all visible frames.
        * '0' means operate on all visible or iconified frames.
        * A frame means operate on that frame.

     Note that this argument does not have the same meaning as in other
     functions which scan all live windows (*note Cyclic Window
     Ordering::).  Specifically, the meanings of 't' and 'nil' here are
     the opposite of what they are in those other functions.

==============================================================================
File: elisp.info,  Node: |Recombining_Windows|,  Next: |Selecting_Windows|,  Prev: |Deleting_Windows|,  Up: |Windows|
==============================================================================

                                                           *Recombining_Windows*

28.8 Recombining Windows
=====-------------------

When deleting the last sibling of a window W, its parent window is
deleted too, with W replacing it in the window tree.  This means that W
must be recombined with its parent's siblings to form a new window
combination (*note Windows and Frames::).  In some occasions, deleting a
live window may even entail the deletion of two internal windows.

          ______________________________________
         | ______  ____________________________ |
         ||      || __________________________ ||
         ||      ||| ___________  ___________ |||
         ||      ||||           ||           ||||
         ||      ||||____W6_____||_____W7____||||
         ||      |||____________W4____________|||
         ||      || __________________________ ||
         ||      |||                          |||
         ||      |||                          |||
         ||      |||____________W5____________|||
         ||__W2__||_____________W3_____________ |
         |__________________W1__________________|


Deleting W5 in this configuration normally causes the deletion of W3 and
W4.  The remaining live windows W2, W6 and W7 are recombined to form a
new horizontal combination with parent W1.

   Sometimes, however, it makes sense to not delete a parent window like
W4.  In particular, a parent window should not be removed when it was
used to preserve a combination embedded in a combination of the same
type.  Such embeddings make sense to assure that when you split a window
and subsequently delete the new window, Emacs reestablishes the layout
of the associated frame as it existed before the splitting.

   Consider a scenario starting with two live windows W2 and W3 and
their parent W1.

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


Split W2 to make a new window W4 as follows.

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


Now, when enlarging a window vertically, Emacs tries to obtain the
corresponding space from its lower sibling, provided such a window
exists.  In our scenario, enlarging W4 will steal space from W3.

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         | ____________________________________ |
         ||_________________W3_________________||
         |__________________W1__________________|


Deleting W4 will now give its entire space to W2, including the space
earlier stolen from W3.

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||_________________W3_________________||
         |__________________W1__________________|


This can be counterintuitive, in particular if W4 were used for
displaying a buffer only temporarily (*note Temporary Displays::), and
you want to continue working with the initial layout.

   The behavior can be fixed by making a new parent window when
splitting W2.  The variable described next allows that to be done.

 -- User Option: window-combination-limit
     This variable controls whether splitting a window shall make a new
     parent window.  The following values are recognized:

     'nil'
          This means that the new live window is allowed to share the
          existing parent window, if one exists, provided the split
          occurs in the same direction as the existing window
          combination (otherwise, a new internal window is created
          anyway).

     'window-size'
          This means that 'display-buffer' makes a new parent window
          when it splits a window and is passed a 'window-height' or
          'window-width' entry in the ALIST argument (*note Buffer
          Display Action Functions::).  Otherwise, window splitting
          behaves as for a value of 'nil'.

     'temp-buffer-resize'
          In this case 'with-temp-buffer-window' makes a new parent
          window when it splits a window and 'temp-buffer-resize-mode'
          is enabled (*note Temporary Displays::).  Otherwise, window
          splitting behaves as for 'nil'.

     'temp-buffer'
          In this case 'with-temp-buffer-window' always makes a new
          parent window when it splits an existing window (*note
          Temporary Displays::).  Otherwise, window splitting behaves as
          for 'nil'.

     'display-buffer'
          This means that when 'display-buffer' (*note Choosing
          Window::) splits a window it always makes a new parent window.
          Otherwise, window splitting behaves as for 'nil'.

     't'
          This means that splitting a window always creates a new parent
          window.  Thus, if the value of this variable is at all times
          't', then at all times every window tree is a binary tree (a
          tree where each window except the root window has exactly one
          sibling).

     The default is 'window-size'.  Other values are reserved for future
     use.

     If, as a consequence of this variable's setting, 'split-window'
     makes a new parent window, it also calls
     'set-window-combination-limit' (see below) on the newly-created
     internal window.  This affects how the window tree is rearranged
     when the child windows are deleted (see below).

   If 'window-combination-limit' is 't', splitting W2 in the initial
configuration of our scenario would have produced this:

          ______________________________________
         | ____________________________________ |
         || __________________________________ ||
         |||                                  |||
         |||________________W2________________|||
         || __________________________________ ||
         |||                                  |||
         |||________________W4________________|||
         ||_________________W5_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


A new internal window W5 has been created; its children are W2 and the
new live window W4.  Now, W2 is the only sibling of W4, so enlarging W4
will try to shrink W2, leaving W3 unaffected.  Observe that W5
represents a vertical combination of two windows embedded in the
vertical combination W1.

 -- Function: set-window-combination-limit window limit
     This function sets the "combination limit" of the window WINDOW to
     LIMIT.  This value can be retrieved via the function
     'window-combination-limit'.  See below for its effects; note that
     it is only meaningful for internal windows.  The 'split-window'
     function automatically calls this function, passing it 't' as
     LIMIT, provided the value of the variable
     'window-combination-limit' is 't' when it is called.

 -- Function: window-combination-limit window
     This function returns the combination limit for WINDOW.

     The combination limit is meaningful only for an internal window.
     If it is 'nil', then Emacs is allowed to automatically delete
     WINDOW, in response to a window deletion, in order to group the
     child windows of WINDOW with its sibling windows to form a new
     window combination.  If the combination limit is 't', the child
     windows of WINDOW are never automatically recombined with its
     siblings.

     If, in the configuration shown at the beginning of this section,
     the combination limit of W4 (the parent window of W6 and W7) is
     't', deleting W5 will not implicitly delete W4 too.

   Alternatively, the problems sketched above can be avoided by always
resizing all windows in the same combination whenever one of its windows
is split or deleted.  This also permits splitting windows that would be
otherwise too small for such an operation.

 -- User Option: window-combination-resize
     If this variable is 'nil', 'split-window' can only split a window
     (denoted by WINDOW) if WINDOW's screen area is large enough to
     accommodate both itself and the new window.

     If this variable is 't', 'split-window' tries to resize all windows
     that are part of the same combination as WINDOW, in order to
     accommodate the new window.  In particular, this may allow
     'split-window' to succeed even if WINDOW is a fixed-size window or
     too small to ordinarily split.  Furthermore, subsequently resizing
     or deleting WINDOW may resize all other windows in its combination.

     The default is 'nil'.  Other values are reserved for future use.  A
     specific split operation may ignore the value of this variable if
     it is affected by a non-'nil' value of 'window-combination-limit'.

   To illustrate the effect of 'window-combination-resize', consider the
following frame layout.

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         |__________________W1__________________|


If 'window-combination-resize' is 'nil', splitting window W3 leaves the
size of W2 unchanged:

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||_________________W3_________________||
         | ____________________________________ |
         ||                                    ||
         ||_________________W4_________________||
         |__________________W1__________________|


If 'window-combination-resize' is 't', splitting W3 instead leaves all
three live windows with approximately the same height:

          ______________________________________
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W2_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W3_________________||
         | ____________________________________ |
         ||                                    ||
         ||                                    ||
         ||_________________W4_________________||
         |__________________W1__________________|


Deleting any of the live windows W2, W3 or W4 will distribute its space
proportionally among the two remaining live windows.

==============================================================================
File: elisp.info,  Node: |Selecting_Windows|,  Next: |Cyclic_Window_Ordering|,  Prev: |Recombining_Windows|,  Up: |Windows|
==============================================================================

                                                             *Selecting_Windows*

28.9 Selecting Windows
=====-----------------

 -- Function: select-window window &optional norecord
     This function makes WINDOW the selected window and the window
     selected within its frame (*note Basic Windows::), and selects that
     frame.  It also makes WINDOW's buffer (*note Buffers and Windows::)
     current and sets that buffer's value of 'point' to the value of
     'window-point' (*note Window Point::) in WINDOW.  WINDOW must be a
     live window.  The return value is WINDOW.

     By default, this function also moves WINDOW's buffer to the front
     of the buffer list (*note Buffer List::) and makes WINDOW the most
     recently selected window.  If the optional argument NORECORD is
     non-'nil', these additional actions are omitted.

     In addition, this function by default also tells the display engine
     to update the display of WINDOW when its frame gets redisplayed the
     next time.  If NORECORD is non-'nil', such updates are usually not
     performed.  If, however, NORECORD equals the special symbol
     'mark-for-redisplay', the additional actions mentioned above are
     omitted but WINDOW will be nevertheless updated.

     Note that sometimes selecting a window is not enough to show it, or
     make its frame the top-most frame on display: you may also need to
     raise the frame or make sure input focus is directed to that frame.
     *Note Input Focus::.

   For historical reasons, Emacs does not run a separate hook whenever a
window gets selected.  Applications and internal routines often
temporarily select a window to perform a few actions on it.  They do
that either to simplify coding--because many functions by default operate
on the selected window when no WINDOW argument is specified--or because
some functions did not (and still do not) take a window as argument and
always operate(d) on the selected window instead.  Running a hook every
time a window gets selected for a short time and once more when the
previously selected window gets restored is not useful.

   However, when its NORECORD argument is 'nil', 'select-window' updates
the buffer list and thus indirectly runs the normal hook
'buffer-list-update-hook' (*note Buffer List::).  Consequently, that
hook provides one way to run a function whenever a window gets selected
more "permanently".

   Since 'buffer-list-update-hook' is also run by functions that are not
related to window management, it will usually make sense to save the
value of the selected window somewhere and compare it with the value of
'selected-window' while running that hook.  Also, to avoid false
positives when using 'buffer-list-update-hook', it is good practice that
every 'select-window' call supposed to select a window only temporarily
passes a non-'nil' NORECORD argument.  If possible, the macro
'with-selected-window' (see below) should be used in such cases.

   Emacs also runs the hook 'window-selection-change-functions' whenever
the redisplay routine detects that another window has been selected
since last redisplay.  *Note Window Hooks::, for a detailed explanation.
'window-state-change-functions' (described in the same section) is
another abnormal hook run after a different window has been selected but
is triggered by other window changes as well.

   The sequence of calls to 'select-window' with a non-'nil' NORECORD
argument determines an ordering of windows by their selection time.  The
function 'get-lru-window' can be used to retrieve the least recently
selected live window (*note Cyclic Window Ordering::).

 -- Macro: save-selected-window forms...
     This macro records the selected frame, as well as the selected
     window of each frame, executes FORMS in sequence, then restores the
     earlier selected frame and windows.  It also saves and restores the
     current buffer.  It returns the value of the last form in FORMS.

     This macro does not save or restore anything about the sizes,
     arrangement or contents of windows; therefore, if FORMS change
     them, the change persists.  If the previously selected window of
     some frame is no longer live at the time of exit from FORMS, that
     frame's selected window is left alone.  If the previously selected
     window is no longer live, then whatever window is selected at the
     end of FORMS remains selected.  The current buffer is restored if
     and only if it is still live when exiting FORMS.

     This macro changes neither the ordering of recently selected
     windows nor the buffer list.

 -- Macro: with-selected-window window forms...
     This macro selects WINDOW, executes FORMS in sequence, then
     restores the previously selected window and current buffer.  The
     ordering of recently selected windows and the buffer list remain
     unchanged unless you deliberately change them within FORMS; for
     example, by calling 'select-window' with argument NORECORD 'nil'.
     Hence, this macro is the preferred way to temporarily work with
     WINDOW as the selected window without needlessly running
     'buffer-list-update-hook'.

 -- Function: frame-selected-window &optional frame
     This function returns the window on FRAME that is selected within
     that frame.  FRAME should be a live frame; if omitted or 'nil', it
     defaults to the selected frame.

 -- Function: set-frame-selected-window frame window &optional norecord
     This function makes WINDOW the window selected within the frame
     FRAME.  FRAME should be a live frame; if 'nil', it defaults to the
     selected frame.  WINDOW should be a live window; if 'nil', it
     defaults to the selected window.

     If FRAME is the selected frame, this makes WINDOW the selected
     window.

     If the optional argument NORECORD is non-'nil', this function does
     not alter the list of most recently selected windows, nor the
     buffer list.

 -- Function: window-use-time &optional window
     This functions returns the use time of window WINDOW.  WINDOW must
     be a live window and defaults to the selected one.

     The "use time" of a window is not really a time value, but an
     integer that does increase monotonically with each call of
     'select-window' with a 'nil' NORECORD argument.  The window with
     the lowest use time is usually called the least recently used
     window while the window with the highest use time is called the
     most recently used one (*note Cyclic Window Ordering::).

==============================================================================
File: elisp.info,  Node: |Cyclic_Window_Ordering|,  Next: |Buffers_and_Windows|,  Prev: |Selecting_Windows|,  Up: |Windows|
==============================================================================

                                                        *Cyclic_Window_Ordering*

28.10 Cyclic Ordering of Windows
=====---------------------------

When you use the command 'C-x o' ('other-window') to select some other
window, it moves through live windows in a specific order.  For any
given configuration of windows, this order never varies.  It is called
the "cyclic ordering of windows".

   The ordering is determined by a depth-first traversal of each frame's
window tree, retrieving the live windows which are the leaf nodes of the
tree (*note Windows and Frames::).  If the minibuffer is active, the
minibuffer window is included too.  The ordering is cyclic, so the last
window in the sequence is followed by the first one.

 -- Function: next-window &optional window minibuf all-frames
     This function returns a live window, the one following WINDOW in
     the cyclic ordering of windows.  WINDOW should be a live window; if
     omitted or 'nil', it defaults to the selected window.

     The optional argument MINIBUF specifies whether minibuffer windows
     should be included in the cyclic ordering.  Normally, when MINIBUF
     is 'nil', a minibuffer window is included only if it is currently
     active; this matches the behavior of 'C-x o'.  (Note that a
     minibuffer window is active as long as its minibuffer is in use;
     see *note Minibuffers::).

     If MINIBUF is 't', the cyclic ordering includes all minibuffer
     windows.  If MINIBUF is neither 't' nor 'nil', minibuffer windows
     are not included even if they are active.

     The optional argument ALL-FRAMES specifies which frames to
     consider:

        * 'nil' means to consider windows on WINDOW's frame.  If the
          minibuffer window is considered (as specified by the MINIBUF
          argument), then frames that share the minibuffer window are
          considered too.

        * 't' means to consider windows on all existing frames.

        * 'visible' means to consider windows on all visible frames.

        * 0 means to consider windows on all visible or iconified
          frames.

        * A frame means to consider windows on that specific frame.

        * Anything else means to consider windows on WINDOW's frame, and
          no others.

     If more than one frame is considered, the cyclic ordering is
     obtained by appending the orderings for those frames, in the same
     order as the list of all live frames (*note Finding All Frames::).

 -- Function: previous-window &optional window minibuf all-frames
     This function returns a live window, the one preceding WINDOW in
     the cyclic ordering of windows.  The other arguments are handled
     like in 'next-window'.

 -- Command: other-window count &optional all-frames
     This function selects a live window, one COUNT places from the
     selected window in the cyclic ordering of windows.  If COUNT is a
     positive number, it skips COUNT windows forwards; if COUNT is
     negative, it skips -COUNT windows backwards; if COUNT is zero, that
     simply re-selects the selected window.  When called interactively,
     COUNT is the numeric prefix argument.

     The optional argument ALL-FRAMES has the same meaning as in
     'next-window', like a 'nil' MINIBUF argument to 'next-window'.

     This function does not select a window that has a non-'nil'
     'no-other-window' window parameter (*note Window Parameters::),
     provided that 'ignore-window-parameters' is 'nil'.

     If the 'other-window' parameter of the selected window is a
     function, and 'ignore-window-parameters' is 'nil', that function
     will be called with the arguments COUNT and ALL-FRAMES instead of
     the normal operation of this function.

 -- Function: walk-windows fun &optional minibuf all-frames
     This function calls the function FUN once for each live window,
     with the window as the argument.

     It follows the cyclic ordering of windows.  The optional arguments
     MINIBUF and ALL-FRAMES specify the set of windows included; these
     have the same arguments as in 'next-window'.  If ALL-FRAMES
     specifies a frame, the first window walked is the first window on
     that frame (the one returned by 'frame-first-window'), not
     necessarily the selected window.

     If FUN changes the window configuration by splitting or deleting
     windows, that does not alter the set of windows walked, which is
     determined prior to calling FUN for the first time.

 -- Function: one-window-p &optional no-mini all-frames
     This function returns 't' if the selected window is the only live
     window, and 'nil' otherwise.

     If the minibuffer window is active, it is normally considered (so
     that this function returns 'nil').  However, if the optional
     argument NO-MINI is non-'nil', the minibuffer window is ignored
     even if active.  The optional argument ALL-FRAMES has the same
     meaning as for 'next-window'.

   The following functions return a window which satisfies some
criterion, without selecting it:

 -- Function: get-lru-window &optional all-frames dedicated not-selected
     This function returns a live window which is heuristically the
     least recently used.  The optional argument ALL-FRAMES has the same
     meaning as in 'next-window'.

     If any full-width windows are present, only those windows are
     considered.  A minibuffer window is never a candidate.  A dedicated
     window (*note Dedicated Windows::) is never a candidate unless the
     optional argument DEDICATED is non-'nil'.  The selected window is
     never returned, unless it is the only candidate.  However, if the
     optional argument NOT-SELECTED is non-'nil', this function returns
     'nil' in that case.

 -- Function: get-mru-window &optional all-frames dedicated not-selected
     This function is like 'get-lru-window', but it returns the most
     recently used window instead.  The meaning of the arguments is the
     same as described for 'get-lru-window'.

 -- Function: get-largest-window &optional all-frames dedicated
          not-selected
     This function returns the window with the largest area (height
     times width).  The optional argument ALL-FRAMES specifies the
     windows to search, and has the same meaning as in 'next-window'.

     A minibuffer window is never a candidate.  A dedicated window
     (*note Dedicated Windows::) is never a candidate unless the
     optional argument DEDICATED is non-'nil'.  The selected window is
     not a candidate if the optional argument NOT-SELECTED is non-'nil'.
     If the optional argument NOT-SELECTED is non-'nil' and the selected
     window is the only candidate, this function returns 'nil'.

     If there are two candidate windows of the same size, this function
     prefers the one that comes first in the cyclic ordering of windows,
     starting from the selected window.

 -- Function: get-window-with-predicate predicate &optional minibuf
          all-frames default
     This function calls the function PREDICATE for each of the windows
     in the cyclic order of windows in turn, passing it the window as an
     argument.  If the predicate returns non-'nil' for any window, this
     function stops and returns that window.  If no such window is
     found, the return value is DEFAULT (which defaults to 'nil').

     The optional arguments MINIBUF and ALL-FRAMES specify the windows
     to search, and have the same meanings as in 'next-window'.

==============================================================================
File: elisp.info,  Node: |Buffers_and_Windows|,  Next: |Switching_Buffers|,  Prev: |Cyclic_Window_Ordering|,  Up: |Windows|
==============================================================================

                                                           *Buffers_and_Windows*

28.11 Buffers and Windows
=====--------------------

This section describes low-level functions for examining and setting the
contents of windows.  *Note Switching Buffers::, for higher-level
functions for displaying a specific buffer in a window.

 -- Function: window-buffer &optional window
     This function returns the buffer that WINDOW is displaying.  If
     WINDOW is omitted or 'nil' it defaults to the selected window.  If
     WINDOW is an internal window, this function returns 'nil'.

 -- Function: set-window-buffer window buffer-or-name &optional
          keep-margins
     This function makes WINDOW display BUFFER-OR-NAME.  WINDOW should
     be a live window; if 'nil', it defaults to the selected window.
     BUFFER-OR-NAME should be a buffer, or the name of an existing
     buffer.  This function does not change which window is selected,
     nor does it directly change which buffer is current (*note Current
     Buffer::).  Its return value is 'nil'.

     If WINDOW is "strongly dedicated" to a buffer and BUFFER-OR-NAME
     does not specify that buffer, this function signals an error.
     *Note Dedicated Windows::.

     By default, this function resets WINDOW's position, display
     margins, fringe widths, and scroll bar settings, based on the local
     variables in the specified buffer.  However, if the optional
     argument KEEP-MARGINS is non-'nil', it leaves WINDOW's display
     margins, fringes and scroll bar settings alone.

     When writing an application, you should normally use
     'display-buffer' (*note Choosing Window::) or the higher-level
     functions described in *note Switching Buffers::, instead of
     calling 'set-window-buffer' directly.

     This runs 'window-scroll-functions', followed by
     'window-configuration-change-hook'.  *Note Window Hooks::.

 -- Variable: buffer-display-count
     This buffer-local variable records the number of times a buffer has
     been displayed in a window.  It is incremented each time
     'set-window-buffer' is called for the buffer.

 -- Variable: buffer-display-time
     This buffer-local variable records the time at which a buffer was
     last displayed in a window.  The value is 'nil' if the buffer has
     never been displayed.  It is updated each time 'set-window-buffer'
     is called for the buffer, with the value returned by 'current-time'
     (*note Time of Day::).

 -- Function: get-buffer-window &optional buffer-or-name all-frames
     This function returns the first window displaying BUFFER-OR-NAME in
     the cyclic ordering of windows, starting from the selected window
     (*note Cyclic Window Ordering::).  If no such window exists, the
     return value is 'nil'.

     BUFFER-OR-NAME should be a buffer or the name of a buffer; if
     omitted or 'nil', it defaults to the current buffer.  The optional
     argument ALL-FRAMES specifies which windows to consider:

        * 't' means consider windows on all existing frames.
        * 'visible' means consider windows on all visible frames.
        * 0 means consider windows on all visible or iconified frames.
        * A frame means consider windows on that frame only.
        * Any other value means consider windows on the selected frame.

     Note that these meanings differ slightly from those of the
     ALL-FRAMES argument to 'next-window' (*note Cyclic Window
     Ordering::).  This function may be changed in a future version of
     Emacs to eliminate this discrepancy.

 -- Function: get-buffer-window-list &optional buffer-or-name minibuf
          all-frames
     This function returns a list of all windows currently displaying
     BUFFER-OR-NAME.  BUFFER-OR-NAME should be a buffer or the name of
     an existing buffer.  If omitted or 'nil', it defaults to the
     current buffer.  If the currently selected window displays
     BUFFER-OR-NAME, it will be the first in the list returned by this
     function.

     The arguments MINIBUF and ALL-FRAMES have the same meanings as in
     the function 'next-window' (*note Cyclic Window Ordering::).  Note
     that the ALL-FRAMES argument does _not_ behave exactly like in
     'get-buffer-window'.

 -- Command: replace-buffer-in-windows &optional buffer-or-name
     This command replaces BUFFER-OR-NAME with some other buffer, in all
     windows displaying it.  BUFFER-OR-NAME should be a buffer, or the
     name of an existing buffer; if omitted or 'nil', it defaults to the
     current buffer.

     The replacement buffer in each window is chosen via
     'switch-to-prev-buffer' (*note Window History::).  Any dedicated
     window displaying BUFFER-OR-NAME is deleted if possible (*note
     Dedicated Windows::).  If such a window is the only window on its
     frame and there are other frames on the same terminal, the frame is
     deleted as well.  If the dedicated window is the only window on the
     only frame on its terminal, the buffer is replaced anyway.

==============================================================================
File: elisp.info,  Node: |Switching_Buffers|,  Next: |Displaying_Buffers|,  Prev: |Buffers_and_Windows|,  Up: |Windows|
==============================================================================

                                                             *Switching_Buffers*

28.12 Switching to a Buffer in a Window
=====----------------------------------

This section describes high-level functions for switching to a specified
buffer in some window.  In general, "switching to a buffer" means to (1)
show the buffer in some window, (2) make that window the selected window
(and its frame the selected frame), and (3) make the buffer the current
buffer.

   Do _not_ use these functions to make a buffer temporarily current
just so a Lisp program can access or modify it.  They have side-effects,
such as changing window histories (*note Window History::), which will
surprise the user if used that way.  If you want to make a buffer
current to modify it in Lisp, use 'with-current-buffer',
'save-current-buffer', or 'set-buffer'.  *Note Current Buffer::.

 -- Command: switch-to-buffer buffer-or-name &optional norecord
          force-same-window
     This command attempts to display BUFFER-OR-NAME in the selected
     window and make it the current buffer.  It is often used
     interactively (as the binding of 'C-x b'), as well as in Lisp
     programs.  The return value is the buffer switched to.

     If BUFFER-OR-NAME is 'nil', it defaults to the buffer returned by
     'other-buffer' (*note Buffer List::).  If BUFFER-OR-NAME is a
     string that is not the name of any existing buffer, this function
     creates a new buffer with that name; the new buffer's major mode is
     determined by the variable 'major-mode' (*note Major Modes::).

     Normally, the specified buffer is put at the front of the buffer
     list--both the global buffer list and the selected frame's buffer
     list (*note Buffer List::).  However, this is not done if the
     optional argument NORECORD is non-'nil'.

     Sometimes, the selected window may not be suitable for displaying
     the buffer.  This happens if the selected window is a minibuffer
     window, or if the selected window is strongly dedicated to its
     buffer (*note Dedicated Windows::).  In such cases, the command
     normally tries to display the buffer in some other window, by
     invoking 'pop-to-buffer' (see below).

     If the optional argument FORCE-SAME-WINDOW is non-'nil' and the
     selected window is not suitable for displaying the buffer, this
     function always signals an error when called non-interactively.  In
     interactive use, if the selected window is a minibuffer window,
     this function will try to use some other window instead.  If the
     selected window is strongly dedicated to its buffer, the option
     'switch-to-buffer-in-dedicated-window' described next can be used
     to proceed.

 -- User Option: switch-to-buffer-in-dedicated-window
     This option, if non-'nil', allows 'switch-to-buffer' to proceed
     when called interactively and the selected window is strongly
     dedicated to its buffer.

     The following values are respected:

     'nil'
          Disallows switching and signals an error as in non-interactive
          use.

     'prompt'
          Prompts the user whether to allow switching.

     'pop'
          Invokes 'pop-to-buffer' to proceed.

     't'
          Marks the selected window as non-dedicated and proceeds.

     This option does not affect non-interactive calls of
     'switch-to-buffer'.

   By default, 'switch-to-buffer' tries to preserve 'window-point'.
This behavior can be tuned using the following option.

 -- User Option: switch-to-buffer-preserve-window-point
     If this variable is 'nil', 'switch-to-buffer' displays the buffer
     specified by BUFFER-OR-NAME at the position of that buffer's
     'point'.  If this variable is 'already-displayed', it tries to
     display the buffer at its previous position in the selected window,
     provided the buffer is currently displayed in some other window on
     any visible or iconified frame.  If this variable is 't',
     'switch-to-buffer' unconditionally tries to display the buffer at
     its previous position in the selected window.

     This variable is ignored if the buffer is already displayed in the
     selected window or never appeared in it before, or if
     'switch-to-buffer' calls 'pop-to-buffer' to display the buffer.

 -- User Option: switch-to-buffer-obey-display-actions
     If this variable is non-'nil', 'switch-to-buffer' respects display
     actions specified by 'display-buffer-overriding-action',
     'display-buffer-alist' and other display related variables.

   The next two commands are similar to 'switch-to-buffer', except for
the described features.

 -- Command: switch-to-buffer-other-window buffer-or-name &optional
          norecord
     This function displays the buffer specified by BUFFER-OR-NAME in
     some window other than the selected window.  It uses the function
     'pop-to-buffer' internally (see below).

     If the selected window already displays the specified buffer, it
     continues to do so, but another window is nonetheless found to
     display it as well.

     The BUFFER-OR-NAME and NORECORD arguments have the same meanings as
     in 'switch-to-buffer'.

 -- Command: switch-to-buffer-other-frame buffer-or-name &optional
          norecord
     This function displays the buffer specified by BUFFER-OR-NAME in a
     new frame.  It uses the function 'pop-to-buffer' internally (see
     below).

     If the specified buffer is already displayed in another window, in
     any frame on the current terminal, this switches to that window
     instead of creating a new frame.  However, the selected window is
     never used for this.

     The BUFFER-OR-NAME and NORECORD arguments have the same meanings as
     in 'switch-to-buffer'.

   The above commands use the function 'pop-to-buffer', which flexibly
displays a buffer in some window and selects that window for editing.
In turn, 'pop-to-buffer' uses 'display-buffer' for displaying the
buffer.  Hence, all the variables affecting 'display-buffer' will affect
it as well.  *Note Choosing Window::, for the documentation of
'display-buffer'.

 -- Command: pop-to-buffer buffer-or-name &optional action norecord
     This function makes BUFFER-OR-NAME the current buffer and displays
     it in some window, preferably not the window currently selected.
     It then selects the displaying window.  If that window is on a
     different graphical frame, that frame is given input focus if
     possible (*note Input Focus::).

     If BUFFER-OR-NAME is 'nil', it defaults to the buffer returned by
     'other-buffer' (*note Buffer List::).  If BUFFER-OR-NAME is a
     string that is not the name of any existing buffer, this function
     creates a new buffer with that name; the new buffer's major mode is
     determined by the variable 'major-mode' (*note Major Modes::).  In
     any case, that buffer is made current and returned, even when no
     suitable window was found to display it.

     If ACTION is non-'nil', it should be a display action to pass to
     'display-buffer' (*note Choosing Window::).  Alternatively, a
     non-'nil', non-list value means to pop to a window other than the
     selected one--even if the buffer is already displayed in the
     selected window.

     Like 'switch-to-buffer', this function updates the buffer list
     unless NORECORD is non-'nil'.

==============================================================================
File: elisp.info,  Node: |Displaying_Buffers|,  Next: |Window_History|,  Prev: |Switching_Buffers|,  Up: |Windows|
==============================================================================

                                                            *Displaying_Buffers*

28.13 Displaying a Buffer in a Suitable Window
=====-----------------------------------------

This section describes lower-level functions Emacs uses to find or
create a window for displaying a specified buffer.  The common workhorse
of these functions is 'display-buffer' which eventually handles all
incoming requests for buffer display (*note Choosing Window::).

   'display-buffer' delegates the task of finding a suitable window to
so-called action functions (*note Buffer Display Action Functions::).
First, 'display-buffer' compiles a so-called action alist--a special
association list that action functions can use to fine-tune their
behavior.  Then it passes that alist on to each action function it calls
(*note Buffer Display Action Alists::).

   The behavior of 'display-buffer' is highly customizable.  To
understand how customizations are used in practice, you may wish to
study examples illustrating the order of precedence which
'display-buffer' uses to call action functions (*note Precedence of
Action Functions::).  To avoid conflicts between Lisp programs calling
'display-buffer' and user customizations of its behavior, it may make
sense to follow a number of guidelines which are sketched in the final
part of this section (*note The Zen of Buffer Display::).

MENU

* |Choosing_Window|::         How to choose a window for displaying a buffer.
* |Buffer_Display_Action_Functions|:: Support functions for buffer display.
* |Buffer_Display_Action_Alists|:: Alists for fine-tuning buffer display.
* |Choosing_Window_Options|:: Extra options affecting how buffers are displayed.
* |Precedence_of_Action_Functions|:: Examples to explain the precedence of
                              action functions.
* |The_Zen_of_Buffer_Display|:: How to avoid that buffers get lost in between
                              windows.

==============================================================================
File: elisp.info,  Node: |Choosing_Window|,  Next: |Buffer_Display_Action_Functions|,  Up: |Displaying_Buffers|
==============================================================================

                                                               *Choosing_Window*

28.13.1 Choosing a Window for Displaying a Buffer
-------------------------------------------------

The command 'display-buffer' flexibly chooses a window for display, and
displays a specified buffer in that window.  It can be called
interactively, via the key binding 'C-x 4 C-o'.  It is also used as a
subroutine by many functions and commands, including 'switch-to-buffer'
and 'pop-to-buffer' (*note Switching Buffers::).

   This command performs several complex steps to find a window to
display in.  These steps are described by means of "display actions",
which have the form '(FUNCTIONS . ALIST)'.  Here, FUNCTIONS is either a
single function or a list of functions, referred to as "action
functions" (*note Buffer Display Action Functions::); and ALIST is an
association list, referred to as "action alist" (*note Buffer Display
Action Alists::).  *Note The Zen of Buffer Display::, for samples of
display actions.

   An action function accepts two arguments: the buffer to display and
an action alist.  It attempts to display the buffer in some window,
picking or creating a window according to its own criteria.  If
successful, it returns the window; otherwise, it returns 'nil'.

   'display-buffer' works by combining display actions from several
sources, and calling the action functions in turn, until one of them
manages to display the buffer and returns a non-'nil' value.

 -- Command: display-buffer buffer-or-name &optional action frame
     This command makes BUFFER-OR-NAME appear in some window, without
     selecting the window or making the buffer current.  The argument
     BUFFER-OR-NAME must be a buffer or the name of an existing buffer.
     The return value is the window chosen to display the buffer, or
     'nil' if no suitable window was found.

     The optional argument ACTION, if non-'nil', should normally be a
     display action (described above).  'display-buffer' builds a list
     of action functions and an action alist, by consolidating display
     actions from the following sources (in order of their precedence,
     from highest to lowest):

        * The variable 'display-buffer-overriding-action'.

        * The user option 'display-buffer-alist'.

        * The ACTION argument.

        * The user option 'display-buffer-base-action'.

        * The constant 'display-buffer-fallback-action'.

     In practice this means that 'display-buffer' builds a list of all
     action functions specified by these display actions.  The first
     element of this list is the first action function specified by
     'display-buffer-overriding-action', if any.  Its last element is
     'display-buffer-pop-up-frame'--the last action function specified by
     'display-buffer-fallback-action'.  Duplicates are not removed from
     this list--hence one and the same action function may be called
     multiple times during one call of 'display-buffer'.

     'display-buffer' calls the action functions specified by this list
     in turn, passing the buffer as the first argument and the combined
     action alist as the second argument, until one of the functions
     returns non-'nil'.  *Note Precedence of Action Functions::, for
     examples how display actions specified by different sources are
     processed by 'display-buffer'.

     Note that the second argument is always the list of _all_ action
     alist entries specified by the sources named above.  Hence, the
     first element of that list is the first action alist entry
     specified by 'display-buffer-overriding-action', if any.  Its last
     element is the last alist entry of 'display-buffer-base-action', if
     any (the action alist of 'display-buffer-fallback-action' is
     empty).

     Note also, that the combined action alist may contain duplicate
     entries and entries for the same key with different values.  As a
     rule, action functions always use the first association of a key
     they find.  Hence, the association an action function uses is not
     necessarily the association provided by the display action that
     specified that action function,

     The argument ACTION can also have a non-'nil', non-list value.
     This has the special meaning that the buffer should be displayed in
     a window other than the selected one, even if the selected window
     is already displaying it.  If called interactively with a prefix
     argument, ACTION is 't'.  Lisp programs should always supply a list
     value.

     The optional argument FRAME, if non-'nil', specifies which frames
     to check when deciding whether the buffer is already displayed.  It
     is equivalent to adding an element '(reusable-frames . FRAME)' to
     the action alist of ACTION (*note Buffer Display Action Alists::).
     The FRAME argument is provided for compatibility reasons, Lisp
     programs should not use it.

 -- Variable: display-buffer-overriding-action
     The value of this variable should be a display action, which is
     treated with the highest priority by 'display-buffer'.  The default
     value is an empty display action, i.e., '(nil . nil)'.

 -- User Option: display-buffer-alist
     The value of this option is an alist mapping conditions to display
     actions.  Each condition may be either a regular expression
     matching a buffer name or a function that takes two arguments: a
     buffer name and the ACTION argument passed to 'display-buffer'.  If
     either the name of the buffer passed to 'display-buffer' matches a
     regular expression in this alist, or the function specified by a
     condition returns non-'nil', then 'display-buffer' uses the
     corresponding display action to display the buffer.

 -- User Option: display-buffer-base-action
     The value of this option should be a display action.  This option
     can be used to define a standard display action for calls to
     'display-buffer'.

 -- Constant: display-buffer-fallback-action
     This display action specifies the fallback behavior for
     'display-buffer' if no other display actions are given.

==============================================================================
File: elisp.info,  Node: |Buffer_Display_Action_Functions|,  Next: |Buffer_Display_Action_Alists|,  Prev: |Choosing_Window|,  Up: |Displaying_Buffers|
==============================================================================

                                               *Buffer_Display_Action_Functions*

28.13.2 Action Functions for Buffer Display
-------------------------------------------

An "action function" is a function 'display-buffer' calls for choosing a
window to display a buffer.  Action functions take two arguments:
BUFFER, the buffer to display, and ALIST, an action alist (*note Buffer
Display Action Alists::).  They are supposed to return a window
displaying BUFFER if they succeed and 'nil' if they fail.

   The following basic action functions are defined in Emacs.

 -- Function: display-buffer-same-window buffer alist
     This function tries to display BUFFER in the selected window.  It
     fails if the selected window is a minibuffer window or is dedicated
     to another buffer (*note Dedicated Windows::).  It also fails if
     ALIST has a non-'nil' 'inhibit-same-window' entry.

 -- Function: display-buffer-reuse-window buffer alist
     This function tries to display BUFFER by finding a window that is
     already displaying it.  Windows on the selected frame are preferred
     to windows on other frames.

     If ALIST has a non-'nil' 'inhibit-same-window' entry, the selected
     window is not eligible for reuse.  The set of frames to search for
     a window already displaying BUFFER can be specified with the help
     of the 'reusable-frames' action alist entry.  If ALIST contains no
     'reusable-frames' entry, this function searches just the selected
     frame.

     If this function chooses a window on another frame, it makes that
     frame visible and, unless ALIST contains an 'inhibit-switch-frame'
     entry, raises that frame if necessary.

 -- Function: display-buffer-reuse-mode-window buffer alist
     This function tries to display BUFFER by finding a window that is
     displaying a buffer in a given mode.

     If ALIST contains a 'mode' entry, its value specifes a major mode
     (a symbol) or a list of major modes.  If ALIST contains no 'mode'
     entry, the current major mode of BUFFER is used instead.  A window
     is a candidate if it displays a buffer whose mode derives from one
     of the modes specified thusly.

     The behavior is also controlled by ALIST entries for
     'inhibit-same-window', 'reusable-frames' and
     'inhibit-switch-frame', like 'display-buffer-reuse-window' does.

 -- Function: display-buffer-pop-up-window buffer alist
     This function tries to display BUFFER by splitting the largest or
     least recently-used window (usually located on the selected frame).
     It actually performs the split by calling the function specified by
     'split-window-preferred-function' (*note Choosing Window
     Options::).

     The size of the new window can be adjusted by supplying
     'window-height' and 'window-width' entries in ALIST.  If ALIST
     contains a 'preserve-size' entry, Emacs will also try to preserve
     the size of the new window during future resize operations (*note
     Preserving Window Sizes::).

     This function fails if no window can be split.  More often than
     not, this happens because no window is large enough to allow
     splitting.  Setting 'split-height-threshold' or
     'split-width-threshold' to lower values may help in this regard.
     Splitting also fails when the selected frame has an 'unsplittable'
     frame parameter; *note Buffer Parameters::.

 -- Function: display-buffer-in-previous-window buffer alist
     This function tries to display BUFFER in a window where it was
     displayed previously.

     If ALIST contains a non-'nil' 'inhibit-same-window' entry, the
     selected window is not eligible for use.  A dedicated window is
     usable only if it already shows BUFFER.  If ALIST contains a
     'previous-window' entry, the window specified by that entry is
     usable even if it never showed BUFFER before.

     If ALIST contains a 'reusable-frames' entry (*note Buffer Display
     Action Alists::), its value determines which frames to search for a
     suitable window.  If ALIST contains no 'reusable-frames' entry,
     this function searches just the selected frame if
     'display-buffer-reuse-frames' and 'pop-up-frames' are both 'nil';
     it searches all frames on the current terminal if either of those
     variables is non-'nil'.

     If more than one window qualifies as usable according to these
     rules, this function makes a choice in the following order of
     preference:

        * The window specified by any 'previous-window' ALIST entry,
          provided it is not the selected window.

        * A window that showed BUFFER before, provided it is not the
          selected window.

        * The selected window if it is either specified by a
          'previous-window' ALIST entry or showed BUFFER before.

 -- Function: display-buffer-use-some-window buffer alist
     This function tries to display BUFFER by choosing an existing
     window and displaying the buffer in that window.  It can fail if
     all windows are dedicated to other buffers (*note Dedicated
     Windows::).

 -- Function: display-buffer-in-direction buffer alist
     This function tries to display BUFFER at a location specified by
     ALIST.  For this purpose, ALIST should contain a 'direction' entry
     whose value is one of 'left', 'above' (or 'up'), 'right' and
     'below' (or 'down').  Other values are usually interpreted as
     'below'.

     If ALIST also contains a 'window' entry, its value specifies a
     reference window.  That value can be a special symbol like 'main'
     which stands for the selected frame's main window (*note Side
     Window Options and Functions::) or 'root' standing for the selected
     frame's root window (*note Windows and Frames::).  It can also
     specify an arbitrary valid window.  Any other value (or omitting
     the 'window' entry entirely) means to use the selected window as
     reference window.

     This function first tries to reuse a window in the specified
     direction that already shows BUFFER.  If no such window exists, it
     tries to split the reference window in order to produce a new
     window in the specified direction.  If this fails as well, it will
     try to display BUFFER in an existing window in the specified
     direction.  In either case, the window chosen will appear on the
     side of the reference window specified by the 'direction' entry,
     sharing at least one edge with the reference window.

     If the reference window is live, the edge the chosen window will
     share with it is always the opposite of the one specified by the
     'direction' entry.  For example, if the value of the 'direction'
     entry is 'left', the chosen window's right edge coordinate (*note
     Coordinates and Windows::) will equal the reference window's left
     edge coordinate.

     If the reference window is internal, a reused window must share
     with it the edge specified by the 'direction' entry.  Hence if, for
     example, the reference window is the frame's root window and the
     value of the 'direction' entry is 'left', a reused window must be
     on the left of the frame.  This means that the left edge coordinate
     of the chosen window and that of the reference window are the same.

     A new window, however, will be created by splitting the reference
     window such that the chosen window will share the opposite edge
     with the reference window.  In our example, a new root window would
     be created with a new live window and the reference window as its
     children.  The chosen window's right edge coordinate would then
     equal the left edge coordinate of the reference window.  Its left
     edge coordinate would equal the left edge coordinate of the frame's
     new root window.

     Four special values for 'direction' entries allow to implicitly
     specify the selected frame's main window as the reference window:
     'leftmost', 'top', 'rightmost' and 'bottom'.  This means that
     instead of, for example, '(direction . left) (window . main)' one
     can just specify '(direction . leftmost)'.  An existing 'window'
     ALIST entry is ignored in such cases.

 -- Function: display-buffer-below-selected buffer alist
     This function tries to display BUFFER in a window below the
     selected window.  If there is a window below the selected one and
     that window already displays BUFFER, it reuses that window.

     If there is no such window, this function tries to create a new
     window by splitting the selected one, and displays BUFFER there.
     It will also try to adjust that window's size provided ALIST
     contains a suitable 'window-height' or 'window-width' entry, see
     above.

     If splitting the selected window fails and there is a non-dedicated
     window below the selected one showing some other buffer, this
     function tries to use that window for showing BUFFER.

     If ALIST contains a 'window-min-height' entry, this function
     ensures that the window used is or can become at least as high as
     specified by that entry's value.  Note that this is only a
     guarantee.  In order to actually resize the window used, ALIST must
     also provide an appropriate 'window-height' entry.

 -- Function: display-buffer-at-bottom buffer alist
     This function tries to display BUFFER in a window at the bottom of
     the selected frame.

     This either tries to split the window at the bottom of the frame or
     the frame's root window, or to reuse an existing window at the
     bottom of the selected frame.

 -- Function: display-buffer-pop-up-frame buffer alist
     This function creates a new frame, and displays the buffer in that
     frame's window.  It actually performs the frame creation by calling
     the function specified in 'pop-up-frame-function' (*note Choosing
     Window Options::).  If ALIST contains a 'pop-up-frame-parameters'
     entry, the associated value is added to the newly created frame's
     parameters.

 -- Function: display-buffer-in-child-frame buffer alist
     This function tries to display BUFFER in a child frame (*note Child
     Frames::) of the selected frame, either reusing an existing child
     frame or by making a new one.  If ALIST has a non-'nil'
     'child-frame-parameters' entry, the corresponding value is an alist
     of frame parameters to give the new frame.  A 'parent-frame'
     parameter specifying the selected frame is provided by default.  If
     the child frame should become the child of another frame, a
     corresponding entry must be added to ALIST.

     The appearance of child frames is largely dependent on the
     parameters provided via ALIST.  It is advisable to use at least
     ratios to specify the size (*note Size Parameters::) and the
     position (*note Position Parameters::) of the child frame, and to
     add a 'keep-ratio' parameter (*note Frame Interaction
     Parameters::), in order to make sure that the child frame remains
     visible.  For other parameters that should be considered see *note
     Child Frames::.

 -- Function: display-buffer-use-some-frame buffer alist
     This function tries to display BUFFER by finding a frame that meets
     a predicate (by default any frame other than the selected frame).

     If this function chooses a window on another frame, it makes that
     frame visible and, unless ALIST contains an 'inhibit-switch-frame'
     entry, raises that frame if necessary.

     If ALIST has a non-'nil' 'frame-predicate' entry, its value is a
     function taking one argument (a frame), returning non-'nil' if the
     frame is a candidate; this function replaces the default predicate.

     If ALIST has a non-'nil' 'inhibit-same-window' entry, the selected
     window is not used; thus if the selected frame has a single window,
     it is not used.

 -- Function: display-buffer-no-window buffer alist
     If ALIST has a non-'nil' 'allow-no-window' entry, then this
     function does not display BUFFER and returns the symbol 'fail'.
     This constitutes the only exception to the convention that an
     action function returns either 'nil' or a window showing BUFFER.
     If ALIST has no such 'allow-no-window' entry, this function returns
     'nil'.

     If this function returns 'fail', 'display-buffer' will skip the
     execution of any further display actions and return 'nil'
     immediately.  If this function returns 'nil', 'display-buffer' will
     continue with the next display action, if any.

     It is assumed that when a caller of 'display-buffer' specifies a
     non-'nil' 'allow-no-window' entry, it is also able to handle a
     'nil' return value.

   Two other action functions are described in their proper
sections--'display-buffer-in-side-window' (*note Displaying Buffers in
Side Windows::) and 'display-buffer-in-atom-window' (*note Atomic
Windows::).

==============================================================================
File: elisp.info,  Node: |Buffer_Display_Action_Alists|,  Next: |Choosing_Window_Options|,  Prev: |Buffer_Display_Action_Functions|,  Up: |Displaying_Buffers|
==============================================================================

                                                  *Buffer_Display_Action_Alists*

28.13.3 Action Alists for Buffer Display
----------------------------------------

An "action alist" is an association list mapping predefined symbols
recognized by action functions to values these functions are supposed to
interpret accordingly.  In each call, 'display-buffer' constructs a new,
possibly empty action alist and passes that entire list on to any action
function it calls.

   By design, action functions are free in their interpretation of
action alist entries.  In fact, some entries like 'allow-no-window' or
'previous-window' have a meaning only for one or a few action functions,
and are ignored by the rest.  Other entries, like 'inhibit-same-window'
or 'window-parameters', are supposed to be respected by most action
functions, including those provided by application programs and external
packages.

   In the previous subsection we have described in detail how individual
action functions interpret the action alist entries they care about.
Here we give a reference list of all known action alist entries
according to their symbols, together with their values and action
functions (*note Buffer Display Action Functions::) that recognize them.
Throughout this list, the terms "buffer" will refer to the buffer
'display-buffer' is supposed to display, and "value" refers to the
entry's value.

'inhibit-same-window'
     If the value is non-'nil', this signals that the selected window
     must not be used for displaying the buffer.  All action functions
     that (re-)use an existing window should respect this entry.

'previous-window'
     The value must specify a window that may have displayed the buffer
     previously.  'display-buffer-in-previous-window' will give
     preference to such a window provided it is still live and not
     dedicated to another buffer.

'mode'
     The value is either a major mode or a list of major modes.
     'display-buffer-reuse-mode-window' may reuse a window whenever the
     value specified by this entry matches the major mode of that
     window's buffer.  Other action functions ignore such entries.

'frame-predicate'
     The value must be a function taking one argument (a frame),
     supposed to return non-'nil' if that frame is a candidate for
     displaying the buffer.  This entry is used by
     'display-buffer-use-some-frame'.

'reusable-frames'
     The value specifies the set of frames to search for a window that
     can be reused because it already displays the buffer.  It can be
     set as follows:

        * 'nil' means consider only windows on the selected frame.
          (Actually, the last frame used that is not a minibuffer-only
          frame.)
        * 't' means consider windows on all frames.
        * 'visible' means consider windows on all visible frames.
        * 0 means consider windows on all visible or iconified frames.
        * A frame means consider windows on that frame only.

     Note that the meaning of 'nil' differs slightly from that of the
     ALL-FRAMES argument to 'next-window' (*note Cyclic Window
     Ordering::).

     A major client of this is 'display-buffer-reuse-window', but all
     other action functions that try to reuse a window are affected as
     well.  'display-buffer-in-previous-window' consults it when
     searching for a window that previously displayed the buffer on
     another frame.

'inhibit-switch-frame'
     A non-'nil' value prevents another frame from being raised or
     selected, if the window chosen by 'display-buffer' is displayed
     there.  Primarily affected by this are
     'display-buffer-use-some-frame' and 'display-buffer-reuse-window'.
     'display-buffer-pop-up-frame' should be affected as well, but there
     is no guarantee that the window manager will comply.

'window-parameters'
     The value specifies an alist of window parameters to give the
     chosen window.  All action functions that choose a window should
     process this entry.

'window-min-height'
     The value specifies a minimum height of the window used, in lines.
     If a window is not or cannot be made as high as specified by this
     entry, the window is not considered for use.  The only client of
     this entry is presently 'display-buffer-below-selected'.

     Note that providing such an entry alone does not necessarily make
     the window as tall as specified by its value.  To actually resize
     an existing window or make a new window as tall as specified by
     that value, a 'window-height' entry specifying that value should be
     provided as well.  Such a 'window-height' entry can, however,
     specify a completely different value or ask the window height to be
     fit to that of its buffer in which case the 'window-min-height'
     entry provides the guaranteed minimum height of the window used.

'window-height'
     The value specifies whether and how to adjust the height of the
     chosen window and can be one of the following:

        * 'nil' means to leave the height of the chosen window alone.

        * An integer number specifies the desired total height of the
          chosen window in lines.

        * A floating-point number specifies the fraction of the chosen
          window's desired total height with respect to the total height
          of its frame's root window.

        * If the value specifies a function, that function is called
          with one argument--the chosen window.  The function is supposed
          to adjust the height of the window; its return value is
          ignored.  Suitable functions are
          'shrink-window-if-larger-than-buffer' and
          'fit-window-to-buffer', see *note Resizing Windows::.

     By convention, the height of the chosen window is adjusted only if
     the window is part of a vertical combination (*note Windows and
     Frames::) to avoid changing the height of other, unrelated windows.
     Also, this entry should be processed only under certain conditions
     which are specified right below this list.

'window-width'
     This entry is similar to the 'window-height' entry described
     before, but used to adjust the chosen window's width instead.  The
     value can be one of the following:

        * 'nil' means to leave the width of the chosen window alone.

        * An integer specifies the desired total width of the chosen
          window in columns.

        * A floating-point number specifies the fraction of the chosen
          window's desired total width with respect to the total width
          of the frame's root window.

        * If the value specifies a function, that function is called
          with one argument--the chosen window.  The function is supposed
          to adjust the width of the window; its return value is
          ignored.

     By convention, the width of the chosen window is adjusted only if
     the window is part of a horizontal combination (*note Windows and
     Frames::) to avoid changing the width of other, unrelated windows.
     Also, this entry should be processed under only certain conditions
     which are specified right below this list.

'dedicated'
     If non-'nil', such an entry tells 'display-buffer' to mark any
     window it creates as dedicated to its buffer (*note Dedicated
     Windows::).  It does that by calling 'set-window-dedicated-p' with
     the chosen window as first argument and the entry's value as
     second.

'preserve-size'
     If non-'nil' such an entry tells Emacs to preserve the size of the
     window chosen (*note Preserving Window Sizes::).  The value should
     be either '(t . nil)' to preserve the width of the window,
     '(nil . t)' to preserve its height or '(t . t)' to preserve both,
     its width and its height.  This entry should be processed only
     under certain conditions which are specified right after this list.

'pop-up-frame-parameters'
     The value specifies an alist of frame parameters to give a new
     frame, if one is created.  'display-buffer-pop-up-frame' is its one
     and only addressee.

'parent-frame'
     The value specifies the parent frame to be used when the buffer is
     displayed on a child frame.  This entry is used only by
     'display-buffer-in-child-frame'.

'child-frame-parameters'
     The value specifies an alist of frame parameters to use when the
     buffer is displayed on a child frame.  This entry is used only by
     'display-buffer-in-child-frame'.

'side'
     The value denotes the side of the frame or window where a new
     window displaying the buffer shall be created.  This entry is used
     by 'display-buffer-in-side-window' to indicate the side of the
     frame where a new side window shall be placed (*note Displaying
     Buffers in Side Windows::).  It is also used by
     'display-buffer-in-atom-window' to indicate the side of an existing
     window where the new window shall be located (*note Atomic
     Windows::).

'slot'
     If non-'nil', the value specifies the slot of the side window
     supposed to display the buffer.  This entry is used only by
     'display-buffer-in-side-window'.

'direction'
     The value specifies a direction which, together with a 'window'
     entry, allows 'display-buffer-in-direction' to determine the
     location of the window to display the buffer.

'window'
     The value specifies a window that is in some way related to the
     window chosen by 'display-buffer'.  This entry is currently used by
     'display-buffer-in-atom-window' to indicate the window on whose
     side the new window shall be created.  It is also used by
     'display-buffer-in-direction' to specify the reference window on
     whose side the resulting window shall appear.

'allow-no-window'
     If the value is non-'nil', 'display-buffer' does not necessarily
     have to display the buffer and the caller is prepared to accept
     that.  This entry is not intended for user customizations, since
     there is no guarantee that an arbitrary caller of 'display-buffer'
     will be able to handle the case that no window will display the
     buffer.  'display-buffer-no-window' is the only action function
     that cares about this entry.

   By convention, the entries 'window-height', 'window-width' and
'preserve-size' are applied after the chosen window's buffer has been
set up and if and only if that window never showed another buffer
before.  More precisely, the latter means that the window must have been
either created by the current 'display-buffer' call or the window was
created earlier by 'display-buffer' to show the buffer and never was
used to show another buffer until it was reused by the current
invocation of 'display-buffer'.

==============================================================================
File: elisp.info,  Node: |Choosing_Window_Options|,  Next: |Precedence_of_Action_Functions|,  Prev: |Buffer_Display_Action_Alists|,  Up: |Displaying_Buffers|
==============================================================================

                                                       *Choosing_Window_Options*

28.13.4 Additional Options for Displaying Buffers
-------------------------------------------------

The behavior of buffer display actions (*note Choosing Window::) can be
further modified by the following user options.

 -- User Option: pop-up-windows
     If the value of this variable is non-'nil', 'display-buffer' is
     allowed to split an existing window to make a new window for
     displaying in.  This is the default.

     This variable is provided for backward compatibility only.  It is
     obeyed by 'display-buffer' via a special mechanism in
     'display-buffer-fallback-action', which calls the action function
     'display-buffer-pop-up-window' (*note Buffer Display Action
     Functions::) when the value of this option is non-'nil'.  It is not
     consulted by 'display-buffer-pop-up-window' itself, which the user
     may specify directly in 'display-buffer-alist' etc.

 -- User Option: split-window-preferred-function
     This variable specifies a function for splitting a window, in order
     to make a new window for displaying a buffer.  It is used by the
     'display-buffer-pop-up-window' action function to actually split
     the window.

     The value must be a function that takes one argument, a window, and
     returns either a new window (which will be used to display the
     desired buffer) or 'nil' (which means the splitting failed).  The
     default value is 'split-window-sensibly', which is documented next.

 -- Function: split-window-sensibly &optional window
     This function tries to split WINDOW and return the newly created
     window.  If WINDOW cannot be split, it returns 'nil'.  If WINDOW is
     omitted or 'nil', it defaults to the selected window.

     This function obeys the usual rules that determine when a window
     may be split (*note Splitting Windows::).  It first tries to split
     by placing the new window below, subject to the restriction imposed
     by 'split-height-threshold' (see below), in addition to any other
     restrictions.  If that fails, it tries to split by placing the new
     window to the right, subject to 'split-width-threshold' (see
     below).  If that also fails, and the window is the only window on
     its frame, this function again tries to split and place the new
     window below, disregarding 'split-height-threshold'.  If this fails
     as well, this function gives up and returns 'nil'.

 -- User Option: split-height-threshold
     This variable specifies whether 'split-window-sensibly' is allowed
     to split the window placing the new window below.  If it is an
     integer, that means to split only if the original window has at
     least that many lines.  If it is 'nil', that means not to split
     this way.

 -- User Option: split-width-threshold
     This variable specifies whether 'split-window-sensibly' is allowed
     to split the window placing the new window to the right.  If the
     value is an integer, that means to split only if the original
     window has at least that many columns.  If the value is 'nil', that
     means not to split this way.

 -- User Option: even-window-sizes
     This variable, if non-'nil', causes 'display-buffer' to even window
     sizes whenever it reuses an existing window, and that window is
     adjacent to the selected one.

     If its value is 'width-only', sizes are evened only if the reused
     window is on the left or right of the selected one and the selected
     window is wider than the reused one.  If its value is 'height-only'
     sizes are evened only if the reused window is above or beneath the
     selected window and the selected window is higher than the reused
     one.  Any other non-'nil' value means to even sizes in any of these
     cases provided the selected window is larger than the reused one in
     the sense of their combination.

 -- User Option: pop-up-frames
     If the value of this variable is non-'nil', that means
     'display-buffer' may display buffers by making new frames.  The
     default is 'nil'.

     A non-'nil' value also means that when 'display-buffer' is looking
     for a window already displaying BUFFER-OR-NAME, it can search any
     visible or iconified frame, not just the selected frame.

     This variable is provided mainly for backward compatibility.  It is
     obeyed by 'display-buffer' via a special mechanism in
     'display-buffer-fallback-action', which calls the action function
     'display-buffer-pop-up-frame' (*note Buffer Display Action
     Functions::) if the value is non-'nil'.  (This is done before
     attempting to split a window.)  This variable is not consulted by
     'display-buffer-pop-up-frame' itself, which the user may specify
     directly in 'display-buffer-alist' etc.

 -- User Option: pop-up-frame-function
     This variable specifies a function for creating a new frame, in
     order to make a new window for displaying a buffer.  It is used by
     the 'display-buffer-pop-up-frame' action function.

     The value should be a function that takes no arguments and returns
     a frame, or 'nil' if no frame could be created.  The default value
     is a function that creates a frame using the parameters specified
     by 'pop-up-frame-alist' (see below).

 -- User Option: pop-up-frame-alist
     This variable holds an alist of frame parameters (*note Frame
     Parameters::), which is used by the function specified by
     'pop-up-frame-function' to make a new frame.  The default is 'nil'.

     This option is provided for backward compatibility only.  Note,
     that when 'display-buffer-pop-up-frame' calls the function
     specified by 'pop-up-frame-function', it prepends the value of all
     'pop-up-frame-parameters' action alist entries to
     'pop-up-frame-alist' so that the values specified by the action
     alist entry effectively override any corresponding values of
     'pop-up-frame-alist'.

     Hence, users should set up a 'pop-up-frame-parameters' action alist
     entry in 'display-buffer-alist' instead of customizing
     'pop-up-frame-alist'.  Only this will guarantee that the value of a
     parameter specified by the user overrides the value of that
     parameter specified by the caller of 'display-buffer'.

   Many efforts in the design of 'display-buffer' have been given to
maintain compatibility with code that uses older options like
'pop-up-windows', 'pop-up-frames', 'pop-up-frame-alist',
'same-window-buffer-names' and 'same-window-regexps'.  Lisp Programs and
users should refrain from using these options.  Above we already warned
against customizing 'pop-up-frame-alist'.  Here we describe how to
convert the remaining options to use display actions instead.

'pop-up-windows'
     This variable is 't' by default.  Instead of customizing it to
     'nil' and thus telling 'display-buffer' what not to do, it's much
     better to list in 'display-buffer-base-action' the action functions
     it should try instead as, for example:

          (customize-set-variable
           'display-buffer-base-action
           '((display-buffer-reuse-window display-buffer-same-window
              display-buffer-in-previous-window
              display-buffer-use-some-window)))

'pop-up-frames'
     Instead of customizing this variable to 't', customize
     'display-buffer-base-action', for example, as follows:

          (customize-set-variable
           'display-buffer-base-action
           '((display-buffer-reuse-window display-buffer-pop-up-frame)
             (reusable-frames . 0)))

'same-window-buffer-names'
'same-window-regexps'
     Instead of adding a buffer name or a regular expression to one of
     these options use a 'display-buffer-alist' entry for that buffer
     specifying the action function 'display-buffer-same-window'.

          (customize-set-variable
           'display-buffer-alist
           (cons '("\\*foo\\*" (display-buffer-same-window))
                  display-buffer-alist))

==============================================================================
File: elisp.info,  Node: |Precedence_of_Action_Functions|,  Next: |The_Zen_of_Buffer_Display|,  Prev: |Choosing_Window_Options|,  Up: |Displaying_Buffers|
==============================================================================

                                                *Precedence_of_Action_Functions*

28.13.5 Precedence of Action Functions
--------------------------------------

From the past subsections we already know that 'display-buffer' must be
supplied with a number of display actions (*note Choosing Window::) in
order to display a buffer.  In a completely uncustomized Emacs, these
actions are specified by 'display-buffer-fallback-action' in the
following order of precedence: Reuse a window, pop up a new window on
the same frame, use a window previously showing the buffer, use some
window and pop up a new frame.  (Note that the remaining actions named
by 'display-buffer-fallback-action' are void in an uncustomized Emacs).

   Consider the following form:

     (display-buffer (get-buffer-create "foo"))

Evaluating this form in the buffer 'scratch' of an uncustomized Emacs
session will usually fail to reuse a window that shows 'foo' already,
but succeed in popping up a new window.  Evaluating the same form again
will now not cause any visible changes--'display-buffer' reused the
window already showing 'foo' because that action was applicable and
had the highest precedence among all applicable actions.

   Popping up a new window will fail if there is not enough space on the
selected frame.  In an uncustomized Emacs it typically fails when there
are already two windows on a frame.  For example, if you now type
'C-x 1' followed by 'C-x 2' and evaluate the form once more, 'foo'
should show up in the lower window--'display-buffer' just used "some"
window.  If, before typing 'C-x 2' you had typed 'C-x o', 'foo' would
have been shown in the upper window because "some" window stands for the
"least recently used" window and the selected window has been least
recently used if and only if it is alone on its frame.

   Let's assume you did not type 'C-x o' and 'foo' is shown in the
lower window.  Type 'C-x o' to get there followed by 'C-x left' and
evaluate the form again.  This should display 'foo' in the same, lower
window because that window had already shown 'foo' previously and was
therefore chosen instead of some other window.

   So far we have only observed the default behavior in an uncustomized
Emacs session.  To see how this behavior can be customized, let's
consider the option 'display-buffer-base-action'.  It provides a very
coarse customization which conceptually affects the display of _any_
buffer.  It can be used to supplement the actions supplied by
'display-buffer-fallback-action' by reordering them or by adding actions
that are not present there but fit more closely the user's editing
practice.  However, it can also be used to change the default behavior
in a more profound way.

   Let's consider a user who, as a rule, prefers to display buffers on
another frame.  Such a user might provide the following customization:

     (customize-set-variable
      'display-buffer-base-action
      '((display-buffer-reuse-window display-buffer-pop-up-frame)
        (reusable-frames . 0)))

This setting will cause 'display-buffer' to first try to find a window
showing the buffer on a visible or iconified frame and, if no such frame
exists, pop up a new frame.  You can observe this behavior on a
graphical system by typing 'C-x 1' in the window showing 'scratch' and
evaluating our canonical 'display-buffer' form.  This will usually
create (and give focus to) a new frame whose root window shows 'foo'.
Iconify that frame and evaluate the canonical form again:
'display-buffer' will reuse the window on the new frame (usually raising
the frame and giving it focus too).

   Only if creating a new frame fails, 'display-buffer' will apply the
actions supplied by 'display-buffer-fallback-action' which means to
again try reusing a window, popping up a new window and so on.  A
trivial way to make frame creation fail is supplied by the following
form:

     (let ((pop-up-frame-function 'ignore))
       (display-buffer (get-buffer-create "foo")))

We will forget about that form immediately after observing that it fails
to create a new frame and uses a fallback action instead.

   Note that 'display-buffer-reuse-window' appears redundant in the
customization of 'display-buffer-base-action' because it is already part
of 'display-buffer-fallback-action' and should be tried there anyway.
However, that would fail because due to the precedence of
'display-buffer-base-action' over 'display-buffer-fallback-action', at
that time 'display-buffer-pop-up-frame' would have already won the race.
In fact, this:

     (customize-set-variable
      'display-buffer-base-action
      '(display-buffer-pop-up-frame (reusable-frames . 0)))

would cause 'display-buffer' to _always_ pop up a new frame which is
probably not what our user wants.

   So far, we have only shown how _users_ can customize the default
behavior of 'display-buffer'.  Let us now see how _applications_ can
change the course of 'display-buffer'.  The canonical way to do that is
to use the ACTION argument of 'display-buffer' or a function that calls
it, like, for example, 'pop-to-buffer' (*note Switching Buffers::).

   Suppose an application wants to display 'foo' preferably below the
selected window (to immediately attract the attention of the user to the
new window) or, if that fails, in a window at the bottom of the frame.
It could do that with a call like this:

     (display-buffer
      (get-buffer-create "foo")
      '((display-buffer-below-selected display-buffer-at-bottom)))

In order to see how this new, modified form works, delete any frame
showing 'foo', type 'C-x 1' followed by 'C-x 2' in the window showing
'scratch', and subsequently evaluate that form.  'display-buffer'
should split the upper window, and show 'foo' in the new window.
Alternatively, if after 'C-x 2' you had typed 'C-x o', 'display-buffer'
would have split the window at the bottom instead.

   Suppose now that, before evaluating the new form, you have made the
selected window as small as possible, for example, by evaluating the
form '(fit-window-to-buffer)' in that window.  In that case,
'display-buffer' would have failed to split the selected window and
would have split the frame's root window instead, effectively displaying
'foo' at the bottom of the frame.

   In either case, evaluating the new form a second time should reuse
the window already showing 'foo' since both functions supplied by the
ACTION argument try to reuse such a window first.

   By setting the ACTION argument, an application effectively overrules
any customization of 'display-buffer-base-action'.  Our user can now
either accept the choice of the application, or redouble by customizing
the option 'display-buffer-alist' as follows:

     (customize-set-variable
      'display-buffer-alist
      '(("\\*foo\\*"
         (display-buffer-reuse-window display-buffer-pop-up-frame))))

Trying this with the new, modified form above in a configuration that
does not show 'foo' anywhere, will display '*foo*' on a separate
frame, completely ignoring the ACTION argument of 'display-buffer'.

   Note that we didn't care to specify a 'reusable-frames' action alist
entry in our specification of 'display-buffer-alist'.  'display-buffer'
always takes the first one it finds--in our case the one specified by
'display-buffer-base-action'.  If we wanted to use a different
specification, for example, to exclude iconified frames showing 'foo'
from the list of reusable ones, we would have to specify that
separately, however:

     (customize-set-variable
      'display-buffer-alist
      '(("\\*foo\\*"
         (display-buffer-reuse-window display-buffer-pop-up-frame)
         (reusable-frames . visible))))

If you try this, you will notice that repeated attempts to display
'foo' will succeed to reuse a frame only if that frame is visible.

   The above example would allow the conclusion that users customize
'display-buffer-alist' for the sole purpose to overrule the ACTION
argument chosen by applications.  Such a conclusion would be incorrect.
'display-buffer-alist' is the standard option for users to direct the
course of display of specific buffers in a preferred way regardless of
whether the display is also guided by an ACTION argument.

   We can, however, reasonably conclude that customizing
'display-buffer-alist' differs from customizing
'display-buffer-base-action' in two major aspects: it is stronger
because it overrides the ACTION argument of 'display-buffer', and it
allows to explicitly specify the affected buffers.  In fact, displaying
other buffers is not affected in any way by a customization for 'foo'.
For example,

     (display-buffer (get-buffer-create "bar"))

continues being governed by the settings of 'display-buffer-base-action'
and 'display-buffer-fallback-action' only.

   We could stop with our examples here but Lisp programs still have an
ace up their sleeves which they can use to overrule any customization of
'display-buffer-alist'.  It's the variable
'display-buffer-overriding-action' which they can bind around
'display-buffer' calls as follows:

     (let ((display-buffer-overriding-action
            '((display-buffer-same-window))))
       (display-buffer
        (get-buffer-create "foo")
        '((display-buffer-below-selected display-buffer-at-bottom))))

Evaluating this form will usually display 'foo' in the selected window
regardless of the ACTION argument and any user customizations.
(Usually, an application will not bother to also provide an ACTION
argument.  Here it just serves to illustrate the fact that it gets
overridden.)

   It might be illustrative to look at the list of action functions
'display-buffer' would have tried to display 'foo' with the
customizations we provided here.  The list (including comments
explaining who added this and the subsequent elements) is:

     (display-buffer-same-window  ;; `display-buffer-overriding-action'
      display-buffer-reuse-window ;; `display-buffer-alist'
      display-buffer-pop-up-frame
      display-buffer-below-selected ;; ACTION argument
      display-buffer-at-bottom
      display-buffer-reuse-window ;; `display-buffer-base-action'
      display-buffer-pop-up-frame
      display-buffer--maybe-same-window ;; `display-buffer-fallback-action'
      display-buffer-reuse-window
      display-buffer--maybe-pop-up-frame-or-window
      display-buffer-in-previous-window
      display-buffer-use-some-window
      display-buffer-pop-up-frame)

Note that among the internal functions listed here,
'display-buffer--maybe-same-window' is effectively ignored while
'display-buffer--maybe-pop-up-frame-or-window' actually runs
'display-buffer-pop-up-window'.

   The action alist passed in each function call is:

     ((reusable-frames . visible)
      (reusable-frames . 0))

which shows that we have used the second specification of
'display-buffer-alist' above, overriding the specification supplied by
'display-buffer-base-action'.  Suppose our user had written that as

     (customize-set-variable
      'display-buffer-alist
      '(("\\*foo\\*"
         (display-buffer-reuse-window display-buffer-pop-up-frame)
         (inhibit-same-window . t)
         (reusable-frames . visible))))

In this case the 'inhibit-same-window' alist entry will successfully
invalidate the 'display-buffer-same-window' specification from
'display-buffer-overriding-action' and 'display-buffer' will show
'foo' on another frame.  To make 'display-buffer-overriding-action'
more robust in this regard, the application would have to specify an
appropriate 'inhibit-same-window' entry too, for example, as follows:

     (let ((display-buffer-overriding-action
            '(display-buffer-same-window (inhibit-same-window . nil))))
       (display-buffer (get-buffer-create "foo")))

This last example shows that while the precedence order of action
functions is fixed, as described in *note Choosing Window::, an action
alist entry specified by a display action ranked lower in that order can
affect the execution of a higher ranked display action.

==============================================================================
File: elisp.info,  Node: |The_Zen_of_Buffer_Display|,  Prev: |Precedence_of_Action_Functions|,  Up: |Displaying_Buffers|
==============================================================================

                                                     *The_Zen_of_Buffer_Display*

28.13.6 The Zen of Buffer Display
---------------------------------

In its most simplistic form, a frame accommodates always one single
window that can be used for displaying a buffer.  As a consequence, it
is always the latest call of 'display-buffer' that will have succeeded
in placing its buffer there.

   Since working with such a frame is not very practical, Emacs by
default allows for more complex frame layouts controlled by the default
values of the frame size and the 'split-height-threshold' and
'split-width-threshold' options.  Displaying a buffer not yet shown on a
frame then either splits the single window on that frame or (re-)uses
one of its two windows.

   The default behavior is abandoned as soon as the user customizes one
of these thresholds or manually changes the frame's layout.  The default
behavior is also abandoned when calling 'display-buffer' with a
non-'nil' ACTION argument or the user customizes one of the options
mentioned in the previous subsections.  Mastering 'display-buffer' soon
may become a frustrating experience due to the plethora of applicable
display actions and the resulting frame layouts.

   However, refraining from using buffer display functions and falling
back on a split & delete windows metaphor is not a good idea either.
Buffer display functions give Lisp programs and users a framework to
reconcile their different needs; no comparable framework exists for
splitting and deleting windows.  Buffer display functions also allow to
at least partially restore the layout of a frame when removing a buffer
from it later (*note Quitting Windows::).

   Below we will give a number of guidelines to redeem the frustration
mentioned above and thus to avoid literally losing buffers in-between
the windows of a frame.

Write display actions without stress
     Writing display actions can be a pain because one has to lump
     together action functions and action alists in one huge list.
     (Historical reasons prevented us from having 'display-buffer'
     support separate arguments for these.)  It might help to memorize
     some basic forms like the ones listed below:

          '(nil (inhibit-same-window . t))

     specifies an action alist entry only and no action function.  Its
     sole purpose is to inhibit a 'display-buffer-same-window' function
     specified elsewhere from showing the buffer in the same window, see
     also the last example of the preceding subsection.

          '(display-buffer-below-selected)

     on the other hand, specifies one action function and an empty
     action alist.  To combine the effects of the above two
     specifications one would write the form

          '(display-buffer-below-selected (inhibit-same-window . t))

     to add another action function one would write

          '((display-buffer-below-selected display-buffer-at-bottom)
            (inhibit-same-window . t))

     and to add another alist entry one would write

          '((display-buffer-below-selected display-buffer-at-bottom)
            (inhibit-same-window . t)
            (window-height . fit-window-to-buffer))

     That last form can be used as ACTION argument of 'display-buffer'
     in the following way:

          (display-buffer
           (get-buffer-create "foo")
           '((display-buffer-below-selected display-buffer-at-bottom)
             (inhibit-same-window . t)
             (window-height . fit-window-to-buffer)))

     In a customization of 'display-buffer-alist' it would be used as
     follows:

          (customize-set-variable
           'display-buffer-alist
           '(("\\*foo\\*"
              (display-buffer-below-selected display-buffer-at-bottom)
              (inhibit-same-window . t)
              (window-height . fit-window-to-buffer))))

     To add a customization for a second buffer one would then write:

          (customize-set-variable
           'display-buffer-alist
           '(("\\*foo\\*"
              (display-buffer-below-selected display-buffer-at-bottom)
              (inhibit-same-window . t)
              (window-height . fit-window-to-buffer))
             ("\\*bar\\*"
              (display-buffer-reuse-window display-buffer-pop-up-frame)
              (reusable-frames . visible))))

Treat each other with respect
     'display-buffer-alist' and 'display-buffer-base-action' are user
     options--Lisp programs must never set or rebind them.
     'display-buffer-overriding-action', on the other hand, is reserved
     for applications--who seldom use that option and if they use it,
     then with utmost care.

     Older implementations of 'display-buffer' frequently caused users
     and applications to fight over the settings of user options like
     'pop-up-frames' and 'pop-up-windows' (*note Choosing Window
     Options::).  This was one major reason for redesigning
     'display-buffer'--to provide a clear framework specifying what users
     and applications should be allowed to do.

     Lisp programs must be prepared that user customizations may cause
     buffers to get displayed in an unexpected way.  They should never
     assume in their subsequent behavior, that the buffer has been shown
     precisely the way they asked for in the ACTION argument of
     'display-buffer'.

     Users should not pose too many and too severe restrictions on how
     arbitrary buffers get displayed.  Otherwise, they will risk to lose
     the characteristics of showing a buffer for a certain purpose.
     Suppose a Lisp program has been written to compare different
     versions of a buffer in two windows side-by-side.  If the
     customization of 'display-buffer-alist' prescribes that any such
     buffer should be always shown in or below the selected window, the
     program will have a hard time to set up the desired window
     configuration via 'display-buffer'.

     To specify a preference for showing an arbitrary buffer, users
     should customize 'display-buffer-base-action'.  An example of how
     users who prefer working with multiple frames would do that was
     given in the previous subsection.  'display-buffer-alist' should be
     reserved for displaying specific buffers in a specific way.

Consider reusing a window that already shows the buffer
     Generally, it's always a good idea for users and Lisp programmers
     to be prepared for the case that a window already shows the buffer
     in question and to reuse that window.  In the preceding subsection
     we have shown that failing to do so properly may cause
     'display-buffer' to continuously pop up a new frame although a
     frame showing that buffer existed already.  In a few cases only, it
     might be undesirable to reuse a window, for example, when a
     different portion of the buffer should be shown in that window.

     Hence, 'display-buffer-reuse-window' is one action function that
     should be used as often as possible, both in ACTION arguments and
     customizations.  An 'inhibit-same-window' entry in the ACTION
     argument usually takes care of the most common case where reusing a
     window showing the buffer should be avoided--that where the window
     in question is the selected one.

Attract focus to the window chosen
     This is a no-brainer for people working with multiple frames--the
     frame showing the buffer will automatically raise and get focus
     unless an 'inhibit-switch-frame' entry forbids it.  For single
     frame users this task can be considerably more difficult.  In
     particular, 'display-buffer-pop-up-window' and
     'display-buffer-use-some-window' can become obtrusive in this
     regard.  They split or use a seemingly arbitrary (often the largest
     or least recently used) window, distracting the user's attention.

     Some Lisp programs therefore try to choose a window at the bottom
     of the frame, for example, in order to display the buffer in
     vicinity of the minibuffer window where the user is expected to
     answer a question related to the new window.  For non-input related
     actions 'display-buffer-below-selected' might be preferable because
     the selected window usually already has the user's attention.

Handle subsequent invocations of 'display-buffer'
     'display-buffer' is not overly well suited for displaying several
     buffers in sequence and making sure that all these buffers are
     shown orderly in the resulting window configuration.  Again, the
     standard action functions 'display-buffer-pop-up-window' and
     'display-buffer-use-some-window' are not very suited for this
     purpose due to their somewhat chaotic nature in more complex
     configurations.

     To produce a window configuration displaying multiple buffers (or
     different views of one and the same buffer) in one and the same
     display cycle, Lisp programmers will unavoidably have to write
     their own action functions.  A few tricks listed below might help
     in this regard.

        * Making windows atomic (*note Atomic Windows::) avoids breaking
          an existing window composition when popping up a new window.
          The new window will pop up outside the composition instead.

        * Temporarily dedicating windows to their buffers (*note
          Dedicated Windows::) avoids using a window for displaying a
          different buffer.  A non-dedicated window will be used
          instead.

        * Calling 'window-preserve-size' (*note Preserving Window
          Sizes::) will try to keep the size of the argument window
          unchanged when popping up a new window.  You have to make sure
          that another window in the same combination can be shrunk
          instead, though.

        * Side windows (*note Side Windows::) can be used for displaying
          specific buffers always in a window at the same position of a
          frame.  This permits grouping buffers that do not compete for
          being shown at the same time on a frame and showing any such
          buffer in the same window without disrupting the display of
          other buffers.

        * Child frames (*note Child Frames::) can be used to display a
          buffer within the screen estate of the selected frame without
          disrupting that frame's window configuration and without the
          overhead associated with full-fledged frames as inflicted by
          'display-buffer-pop-up-frame'.

==============================================================================
File: elisp.info,  Node: |Window_History|,  Next: |Dedicated_Windows|,  Prev: |Displaying_Buffers|,  Up: |Windows|
==============================================================================

                                                                *Window_History*

28.14 Window History
=====---------------

Each window remembers in a list the buffers it has previously displayed,
and the order in which these buffers were removed from it.  This history
is used, for example, by 'replace-buffer-in-windows' (*note Buffers and
Windows::), and when quitting windows (*note Quitting Windows::).  The
list is automatically maintained by Emacs, but you can use the following
functions to explicitly inspect or alter it:

 -- Function: window-prev-buffers &optional window
     This function returns a list specifying the previous contents of
     WINDOW.  The optional argument WINDOW should be a live window and
     defaults to the selected one.

     Each list element has the form '(BUFFER WINDOW-START WINDOW-POS)',
     where BUFFER is a buffer previously shown in the window,
     WINDOW-START is the window start position (*note Window Start and
     End::) when that buffer was last shown, and WINDOW-POS is the point
     position (*note Window Point::) when that buffer was last shown in
     WINDOW.

     The list is ordered so that earlier elements correspond to more
     recently-shown buffers, and the first element usually corresponds
     to the buffer most recently removed from the window.

 -- Function: set-window-prev-buffers window prev-buffers
     This function sets WINDOW's previous buffers to the value of
     PREV-BUFFERS.  The argument WINDOW must be a live window and
     defaults to the selected one.  The argument PREV-BUFFERS should be
     a list of the same form as that returned by 'window-prev-buffers'.

   In addition, each window maintains a list of "next buffers", which is
a list of buffers re-shown by 'switch-to-prev-buffer' (see below).  This
list is mainly used by 'switch-to-prev-buffer' and
'switch-to-next-buffer' for choosing buffers to switch to.

 -- Function: window-next-buffers &optional window
     This function returns the list of buffers recently re-shown in
     WINDOW via 'switch-to-prev-buffer'.  The WINDOW argument must
     denote a live window or 'nil' (meaning the selected window).

 -- Function: set-window-next-buffers window next-buffers
     This function sets the next buffer list of WINDOW to NEXT-BUFFERS.
     The WINDOW argument should be a live window or 'nil' (meaning the
     selected window).  The argument NEXT-BUFFERS should be a list of
     buffers.

   The following commands can be used to cycle through the global buffer
list, much like 'bury-buffer' and 'unbury-buffer'.  However, they cycle
according to the specified window's history list, rather than the global
buffer list.  In addition, they restore window-specific window start and
point positions, and may show a buffer even if it is already shown in
another window.  The 'switch-to-prev-buffer' command, in particular, is
used by 'replace-buffer-in-windows', 'bury-buffer' and 'quit-window' to
find a replacement buffer for a window.

 -- Command: switch-to-prev-buffer &optional window bury-or-kill
     This command displays the previous buffer in WINDOW.  The argument
     WINDOW should be a live window or 'nil' (meaning the selected
     window).  If the optional argument BURY-OR-KILL is non-'nil', this
     means that the buffer currently shown in WINDOW is about to be
     buried or killed and consequently should not be switched to in
     future invocations of this command.

     The previous buffer is usually the buffer shown before the buffer
     currently shown in WINDOW.  However, a buffer that has been buried
     or killed, or has been already shown by a recent invocation of
     'switch-to-prev-buffer', does not qualify as previous buffer.

     If repeated invocations of this command have already shown all
     buffers previously shown in WINDOW, further invocations will show
     buffers from the buffer list of the frame WINDOW appears on (*note
     Buffer List::).

     The option 'switch-to-prev-buffer-skip' described below can be used
     to inhibit switching to certain buffers, for example, to those
     already shown in another window.  Also, if WINDOW's frame has a
     'buffer-predicate' parameter (*note Buffer Parameters::), that
     predicate may inhibit switching to certain buffers.

 -- Command: switch-to-next-buffer &optional window
     This command switches to the next buffer in WINDOW, thus undoing
     the effect of the last 'switch-to-prev-buffer' command in WINDOW.
     The argument WINDOW must be a live window and defaults to the
     selected one.

     If there is no recent invocation of 'switch-to-prev-buffer' that
     can be undone, this function tries to show a buffer from the buffer
     list of the frame WINDOW appears on (*note Buffer List::).

     The option 'switch-to-prev-buffer-skip' and the 'buffer-predicate'
     (*note Buffer Parameters::) of WINDOW's frame affect this command
     as they do for 'switch-to-prev-buffer'.

   By default 'switch-to-prev-buffer' and 'switch-to-next-buffer' can
switch to a buffer that is already shown in another window.  The
following option can be used to override this behavior.

 -- User Option: switch-to-prev-buffer-skip
     If this variable is 'nil', 'switch-to-prev-buffer' may switch to
     any buffer, including those already shown in other windows.

     If this variable is non-'nil', 'switch-to-prev-buffer' will refrain
     from switching to certain buffers.  The following values can be
     used:

        * 'this' means do not switch to a buffer shown on the frame that
          hosts the window 'switch-to-prev-buffer' is acting upon.

        * 'visible' means do not switch to a buffer shown on any visible
          frame.

        * 0 (the number zero) means do not switch to a buffer shown on
          any visible or iconified frame.

        * 't' means do not switch to a buffer shown on any live frame.

        * A function that takes three arguments--the WINDOW argument of
          'switch-to-prev-buffer', a buffer 'switch-to-prev-buffer'
          intends to switch to and the BURY-OR-KILL argument of
          'switch-to-prev-buffer'.  If that function returns non-'nil',
          'switch-to-prev-buffer' will refrain from switching to the
          buffer specified by the second argument.

     The command 'switch-to-next-buffer' obeys this option in a similar
     way.  If this option specifies a function, 'switch-to-next-buffer'
     will call that function with the third argument always 'nil'.

     Note that since 'switch-to-prev-buffer' is called by 'bury-buffer',
     'replace-buffer-in-windows' and 'quit-restore-window' as well,
     customizing this option may also affect the behavior of Emacs when
     a window is quit or a buffer gets buried or killed.

     Note also that under certain circumstances 'switch-to-prev-buffer'
     and 'switch-to-next-buffer' may ignore this option, for example,
     when there is only one buffer left these functions can switch to.

==============================================================================
File: elisp.info,  Node: |Dedicated_Windows|,  Next: |Quitting_Windows|,  Prev: |Window_History|,  Up: |Windows|
==============================================================================

                                                             *Dedicated_Windows*

28.15 Dedicated Windows
=====------------------

Functions for displaying a buffer can be told to not use specific
windows by marking these windows as "dedicated" to their buffers.
'display-buffer' (*note Choosing Window::) never uses a dedicated window
for displaying another buffer in it.  'get-lru-window' and
'get-largest-window' (*note Cyclic Window Ordering::) do not consider
dedicated windows as candidates when their DEDICATED argument is
non-'nil'.  The behavior of 'set-window-buffer' (*note Buffers and
Windows::) with respect to dedicated windows is slightly different, see
below.

   Functions supposed to remove a buffer from a window or a window from
a frame can behave specially when a window they operate on is dedicated.
We will distinguish three basic cases, namely where (1) the window is
not the only window on its frame, (2) the window is the only window on
its frame but there are other frames on the same terminal left, and (3)
the window is the only window on the only frame on the same terminal.

   In particular, 'delete-windows-on' (*note Deleting Windows::) handles
case (2) by deleting the associated frame and case (3) by showing
another buffer in that frame's only window.  The function
'replace-buffer-in-windows' (*note Buffers and Windows::) which is
called when a buffer gets killed, deletes the window in case (1) and
behaves like 'delete-windows-on' otherwise.

   When 'bury-buffer' (*note Buffer List::) operates on the selected
window (which shows the buffer that shall be buried), it handles case
(2) by calling 'frame-auto-hide-function' (*note Quitting Windows::) to
deal with the selected frame.  The other two cases are handled as with
'replace-buffer-in-windows'.

 -- Function: window-dedicated-p &optional window
     This function returns non-'nil' if WINDOW is dedicated to its
     buffer and 'nil' otherwise.  More precisely, the return value is
     the value assigned by the last call of 'set-window-dedicated-p' for
     WINDOW, or 'nil' if that function was never called with WINDOW as
     its argument.  The default for WINDOW is the selected window.

 -- Function: set-window-dedicated-p window flag
     This function marks WINDOW as dedicated to its buffer if FLAG is
     non-'nil', and non-dedicated otherwise.

     As a special case, if FLAG is 't', WINDOW becomes "strongly"
     dedicated to its buffer.  'set-window-buffer' signals an error when
     the window it acts upon is strongly dedicated to its buffer and
     does not already display the buffer it is asked to display.  Other
     functions do not treat 't' differently from any non-'nil' value.

   You can also tell 'display-buffer' to mark a window it creates as
dedicated to its buffer by providing a suitable 'dedicated' action alist
entry (*note Buffer Display Action Alists::).

==============================================================================
File: elisp.info,  Node: |Quitting_Windows|,  Next: |Side_Windows|,  Prev: |Dedicated_Windows|,  Up: |Windows|
==============================================================================

                                                              *Quitting_Windows*

28.16 Quitting Windows
=====-----------------

When you want to get rid of a window used for displaying a buffer, you
can call 'delete-window' or 'delete-windows-on' (*note Deleting
Windows::) to remove that window from its frame.  If the buffer is shown
on a separate frame, you might want to call 'delete-frame' (*note
Deleting Frames::) instead.  If, on the other hand, a window has been
reused for displaying the buffer, you might prefer showing the buffer
previously shown in that window, by calling the function
'switch-to-prev-buffer' (*note Window History::).  Finally, you might
want to either bury (*note Buffer List::) or kill (*note Killing
Buffers::) the window's buffer.

   The following command uses information on how the window for
displaying the buffer was obtained in the first place, thus attempting
to automate the above decisions for you.

 -- Command: quit-window &optional kill window
     This command quits WINDOW and buries its buffer.  The argument
     WINDOW must be a live window and defaults to the selected one.
     With prefix argument KILL non-'nil', it kills the buffer instead of
     burying it.  It calls the function 'quit-restore-window' described
     next to deal with the window and its buffer.

     The functions in 'quit-window-hook' are run before doing anything
     else.

 -- Function: quit-restore-window &optional window bury-or-kill
     This function handles WINDOW and its buffer after quitting.  The
     optional argument WINDOW must be a live window and defaults to the
     selected one.  The function's behavior is determined by the four
     elements of the list specified by WINDOW's 'quit-restore' parameter
     (*note Window Parameters::).

     The first element of the 'quit-restore' parameter is one of the
     symbols 'window', meaning that the window has been specially
     created by 'display-buffer'; 'frame', a separate frame has been
     created; 'same', the window has only ever displayed this buffer; or
     'other', the window showed another buffer before.  'frame' and
     'window' affect how the window is quit, while 'same' and 'other'
     affect the redisplay of buffers previously shown in WINDOW.

     The parameter's second element is either one of the symbols
     'window' or 'frame', or a list whose elements are the buffer shown
     in WINDOW before, that buffer's window start and window point
     positions, and WINDOW's height at that time.  If that buffer is
     still live when WINDOW is quit, then this function may reuse WINDOW
     to display it.

     The third element is the window selected at the time the parameter
     was created.  If this function deletes WINDOW, it subsequently
     tries to reselect the window named by that element.

     The fourth element is the buffer whose display caused the creation
     of this parameter.  This function may delete WINDOW if and only if
     it still shows that buffer.

     This function will try to delete WINDOW if and only if (1) the
     first element of its 'quit-restore' parameter is either 'window' or
     'frame', (2) the window has no history of previously-displayed
     buffers and (3) the fourth element of the 'quit-restore' parameter
     specifies the buffer currently displayed in WINDOW.  If WINDOW is
     part of an atomic window (*note Atomic Windows::), it will try to
     delete the root of that atomic window instead.  In either case, it
     tries to avoid signaling an error when WINDOW cannot be deleted.

     If WINDOW shall be deleted, is the only window on its frame and
     there are other frames on that frame's terminal, the value of the
     optional argument BURY-OR-KILL determines how to proceed with the
     window.  If BURY-OR-KILL equals 'kill', the frame is deleted
     unconditionally.  Otherwise, the fate of the frame is determined by
     calling 'frame-auto-hide-function' (see below) with that frame as
     sole argument.

     If the third element of the 'quit-restore' parameter is a list of
     buffer, window start (*note Window Start and End::), and point
     (*note Window Point::), and that buffer is still live, the buffer
     will be displayed, and start and point set accordingly.  If, in
     addition, WINDOW's buffer was temporarily resized, this function
     will also try to restore the original height of WINDOW.

     Otherwise, if WINDOW was previously used for displaying other
     buffers (*note Window History::), the most recent buffer in that
     history will be displayed.  In either case, if WINDOW is not
     deleted, its 'quit-restore' parameter is reset to 'nil'.

     The optional argument BURY-OR-KILL specifies how to deal with
     WINDOW's buffer.  The following values are handled:

     'nil'
          This means to not deal with the buffer in any particular way.
          As a consequence, if WINDOW is not deleted, invoking
          'switch-to-prev-buffer' will usually show the buffer again.

     'append'
          This means that if WINDOW is not deleted, its buffer is moved
          to the end of WINDOW's list of previous buffers, so it's less
          likely that a future invocation of 'switch-to-prev-buffer'
          will switch to it.  Also, it moves the buffer to the end of
          the frame's buffer list.

     'bury'
          This means that if WINDOW is not deleted, its buffer is
          removed from WINDOW's list of previous buffers.  Also, it
          moves the buffer to the end of the frame's buffer list.  This
          value provides the most reliable remedy to not have
          'switch-to-prev-buffer' switch to this buffer again without
          killing the buffer.

     'kill'
          This means to kill WINDOW's buffer.

     Typically, the display routines run by 'display-buffer' will set
     the 'quit-restore' window parameter correctly.  It's also possible
     to set it manually, using the following code for displaying BUFFER
     in WINDOW:

          (display-buffer-record-window type window buffer)

          (set-window-buffer window buffer)

          (set-window-prev-buffers window nil)

     Setting the window history to 'nil' ensures that a future call to
     'quit-window' can delete the window altogether.

   The following option specifies how to deal with a frame containing
just one window that should be either quit, or whose buffer should be
buried.

 -- User Option: frame-auto-hide-function
     The function specified by this option is called to automatically
     hide frames.  This function is called with one argument--a frame.

     The function specified here is called by 'bury-buffer' (*note
     Buffer List::) when the selected window is dedicated and shows the
     buffer to bury.  It is also called by 'quit-restore-window' (see
     above) when the frame of the window to quit has been specially
     created for displaying that window's buffer and the buffer is not
     killed.

     The default is to call 'iconify-frame' (*note Visibility of
     Frames::).  Alternatively, you may specify either 'delete-frame'
     (*note Deleting Frames::) to remove the frame from its display,
     'make-frame-invisible' to make the frame invisible, 'ignore' to
     leave the frame unchanged, or any other function that can take a
     frame as its sole argument.

     Note that the function specified by this option is called only if
     the specified frame contains just one live window and there is at
     least one other frame on the same terminal.

     For a particular frame, the value specified here may be overridden
     by that frame's 'auto-hide-function' frame parameter (*note Frame
     Interaction Parameters::).

==============================================================================
File: elisp.info,  Node: |Side_Windows|,  Next: |Atomic_Windows|,  Prev: |Quitting_Windows|,  Up: |Windows|
==============================================================================

                                                                  *Side_Windows*

28.17 Side Windows
=====-------------

Side windows are special windows positioned at any of the four sides of
a frame's root window (*note Windows and Frames::).  In practice, this
means that the area of the frame's root window is subdivided into a main
window and a number of side windows surrounding that main window.  The
main window is either a "normal" live window or specifies the area
containing all the normal windows.

   In their most simple form of use, side windows allow to display
specific buffers always in the same area of a frame.  Hence they can be
regarded as a generalization of the concept provided by
'display-buffer-at-bottom' (*note Buffer Display Action Functions::) to
the remaining sides of a frame.  With suitable customizations, however,
side windows can be also used to provide frame layouts similar to those
found in so-called integrated development environments (IDEs).

MENU

* |Displaying_Buffers_in_Side_Windows|:: An action function for displaying
                              buffers in side windows.
* |Side_Window_Options_and_Functions|:: Further tuning of side windows.
* |Frame_Layouts_with_Side_Windows|:: Setting up frame layouts with side
                              windows.

==============================================================================
File: elisp.info,  Node: |Displaying_Buffers_in_Side_Windows|,  Next: |Side_Window_Options_and_Functions|,  Up: |Side_Windows|
==============================================================================

                                            *Displaying_Buffers_in_Side_Windows*

28.17.1 Displaying Buffers in Side Windows
------------------------------------------

The following action function for 'display-buffer' (*note Buffer Display
Action Functions::) creates or reuses a side window for displaying the
specified buffer.

 -- Function: display-buffer-in-side-window buffer alist
     This function displays BUFFER in a side window of the selected
     frame.  It returns the window used for displaying BUFFER, 'nil' if
     no such window can be found or created.

     ALIST is an association list of symbols and values as for
     'display-buffer'.  The following symbols in ALIST are special for
     this function:

     'side'
          Denotes the side of the frame where the window shall be
          located.  Valid values are 'left', 'top', 'right' and
          'bottom'.  If unspecified, the window is located at the bottom
          of the frame.

     'slot'
          Denotes a slot at the specified side where to locate the
          window.  A value of zero means to preferably position the
          window in the middle of the specified side.  A negative value
          means to use a slot preceding (that is, above or on the left
          of) the middle slot.  A positive value means to use a slot
          following (that is, below or on the right of) the middle slot.
          Hence, all windows on a specific side are ordered by their
          'slot' value.  If unspecified, the window is located in the
          middle of the specified side.

     If you specify the same slot on the same side for two or more
     different buffers, the buffer displayed last is shown in the
     corresponding window.  Hence, slots can be used for sharing the
     same side window between buffers.

     This function installs the 'window-side' and 'window-slot'
     parameters (*note Window Parameters::) and makes them persistent.
     It does not install any other window parameters unless they have
     been explicitly provided via a 'window-parameters' entry in ALIST.

   By default, side windows cannot be split via 'split-window' (*note
Splitting Windows::).  Also, a side window is not reused or split by any
buffer display action (*note Buffer Display Action Functions::) unless
it is explicitly specified as target of that action.  Note also that
'delete-other-windows' cannot make a side window the only window on its
frame (*note Deleting Windows::).

   Once set up, side windows also change the behavior of the commands
'switch-to-prev-buffer' and 'switch-to-next-buffer' (*note Window
History::).  In particular, these commands will refrain from showing, in
a side window, buffers that have not been displayed in that window
before.  They will also refrain from having a normal, non-side window
show a buffer that has been already displayed in a side window.  A
notable exception to the latter rule occurs when an application, after
displaying a buffer, resets that buffer's local variables.

==============================================================================
File: elisp.info,  Node: |Side_Window_Options_and_Functions|,  Next: |Frame_Layouts_with_Side_Windows|,  Prev: |Displaying_Buffers_in_Side_Windows|,  Up: |Side_Windows|
==============================================================================

                                             *Side_Window_Options_and_Functions*

28.17.2 Side Window Options and Functions
-----------------------------------------

The following options provide additional control over the placement of
side windows.

 -- User Option: window-sides-vertical
     If non-'nil', the side windows on the left and right of a frame
     occupy the frame's full height.  Otherwise, the side windows on the
     top and bottom of the frame occupy the frame's full width.

 -- User Option: window-sides-slots
     This option specifies the maximum number of side windows on each
     side of a frame.  The value is a list of four elements specifying
     the number of side window slots on (in this order) the left, top,
     right and bottom of each frame.  If an element is a number, it
     means to display at most that many windows on the corresponding
     side.  If an element is 'nil', it means there's no bound on the
     number of slots on that side.

     If any of the specified values is zero, no window can be created on
     the corresponding side.  'display-buffer-in-side-window' will not
     signal an error in that case, but will return 'nil'.  If a
     specified value just forbids the creation of an additional side
     window, the most suitable window on that side is reused and may
     have its 'window-slot' parameter changed accordingly.

 -- User Option: window-sides-reversed
     This option specifies whether top/bottom side windows should appear
     in reverse order.  When this is 'nil', side windows on the top and
     bottom of a frame are always drawn from left to right with
     increasing slot values.  When this is 't', the drawing order is
     reversed and side windows on the top and bottom of a frame are
     drawn from right to left with increasing slot values.
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
