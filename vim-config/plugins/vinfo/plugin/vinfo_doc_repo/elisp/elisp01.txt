4.1 String and Character Basics
===============================

A character is a Lisp object which represents a single character of
text.  In Emacs Lisp, characters are simply integers; whether an integer
is a character or not is determined only by how it is used.  *Note
Character Codes::, for details about character representation in Emacs.

   A string is a fixed sequence of characters.  It is a type of sequence
called a "array", meaning that its length is fixed and cannot be altered
once it is created (*note Sequences Arrays Vectors::).  Unlike in C,
Emacs Lisp strings are _not_ terminated by a distinguished character
code.

   Since strings are arrays, and therefore sequences as well, you can
operate on them with the general array and sequence functions documented
in *note Sequences Arrays Vectors::.  For example, you can access
individual characters in a string using the function 'aref' (*note Array
Functions::).

   There are two text representations for non-ASCII characters in Emacs
strings (and in buffers): unibyte and multibyte.  For most Lisp
programming, you don't need to be concerned with these two
representations.  *Note Text Representations::, for details.

   Sometimes key sequences are represented as unibyte strings.  When a
unibyte string is a key sequence, string elements in the range 128 to
255 represent meta characters (which are large integers) rather than
character codes in the range 128 to 255.  Strings cannot hold characters
that have the hyper, super or alt modifiers; they can hold ASCII control
characters, but no other control characters.  They do not distinguish
case in ASCII control characters.  If you want to store such characters
in a sequence, such as a key sequence, you must use a vector instead of
a string.  *Note Character Type::, for more information about keyboard
input characters.

   Strings are useful for holding regular expressions.  You can also
match regular expressions against strings with 'string-match' (*note
Regexp Search::).  The functions 'match-string' (*note Simple Match
Data::) and 'replace-match' (*note Replacing Match::) are useful for
decomposing and modifying strings after matching regular expressions
against them.

   Like a buffer, a string can contain text properties for the
characters in it, as well as the characters themselves.  *Note Text
Properties::.  All the Lisp primitives that copy text from strings to
buffers or other strings also copy the properties of the characters
being copied.

   *Note Text::, for information about functions that display strings or
copy them into buffers.  *Note Character Type::, and *note String
Type::, for information about the syntax of characters and strings.
*Note Non-ASCII Characters::, for functions to convert between text
representations and to encode and decode character codes.  Also, note
that 'length' should _not_ be used for computing the width of a string
on display; use 'string-width' (*note Size of Displayed Text::) instead.

==============================================================================
File: elisp.info,  Node: |Predicates_for_Strings|,  Next: |Creating_Strings|,  Prev: |String_Basics|,  Up: |Strings_and_Characters|
==============================================================================

                                                        *Predicates_for_Strings*

4.2 Predicates for Strings
--------------------------

For more information about general sequence and array predicates, see
*note Sequences Arrays Vectors::, and *note Arrays::.

 -- Function: stringp object
     This function returns 't' if OBJECT is a string, 'nil' otherwise.

 -- Function: string-or-null-p object
     This function returns 't' if OBJECT is a string or 'nil'.  It
     returns 'nil' otherwise.

 -- Function: char-or-string-p object
     This function returns 't' if OBJECT is a string or a character
     (i.e., an integer), 'nil' otherwise.

==============================================================================
File: elisp.info,  Node: |Creating_Strings|,  Next: |Modifying_Strings|,  Prev: |Predicates_for_Strings|,  Up: |Strings_and_Characters|
==============================================================================

                                                              *Creating_Strings*

4.3 Creating Strings
--------------------

The following functions create strings, either from scratch, or by
putting strings together, or by taking them apart.

 -- Function: make-string count character &optional multibyte
     This function returns a string made up of COUNT repetitions of
     CHARACTER.  If COUNT is negative, an error is signaled.

          (make-string 5 ?x)
               => "xxxxx"
          (make-string 0 ?x)
               => ""

     Normally, if CHARACTER is an ASCII character, the result is a
     unibyte string.  But if the optional argument MULTIBYTE is
     non-'nil', the function will produce a multibyte string instead.
     This is useful when you later need to concatenate the result with
     non-ASCII strings or replace some of its characters with non-ASCII
     characters.

     Other functions to compare with this one include 'make-vector'
     (*note Vectors::) and 'make-list' (*note Building Lists::).

 -- Function: string &rest characters
     This returns a string containing the characters CHARACTERS.

          (string ?a ?b ?c)
               => "abc"

 -- Function: substring string &optional start end
     This function returns a new string which consists of those
     characters from STRING in the range from (and including) the
     character at the index START up to (but excluding) the character at
     the index END.  The first character is at index zero.  With one
     argument, this function just copies STRING.

          (substring "abcdefg" 0 3)
               => "abc"

     In the above example, the index for 'a' is 0, the index for 'b' is
     1, and the index for 'c' is 2.  The index 3--which is the fourth
     character in the string--marks the character position up to which
     the substring is copied.  Thus, 'abc' is copied from the string
     '"abcdefg"'.

     A negative number counts from the end of the string, so that -1
     signifies the index of the last character of the string.  For
     example:

          (substring "abcdefg" -3 -1)
               => "ef"

     In this example, the index for 'e' is -3, the index for 'f' is -2,
     and the index for 'g' is -1.  Therefore, 'e' and 'f' are included,
     and 'g' is excluded.

     When 'nil' is used for END, it stands for the length of the string.
     Thus,

          (substring "abcdefg" -3 nil)
               => "efg"

     Omitting the argument END is equivalent to specifying 'nil'.  It
     follows that '(substring STRING 0)' returns a copy of all of
     STRING.

          (substring "abcdefg" 0)
               => "abcdefg"

     But we recommend 'copy-sequence' for this purpose (*note Sequence
     Functions::).

     If the characters copied from STRING have text properties, the
     properties are copied into the new string also.  *Note Text
     Properties::.

     'substring' also accepts a vector for the first argument.  For
     example:

          (substring [a b (c) "d"] 1 3)
               => [b (c)]

     A 'wrong-type-argument' error is signaled if START is not an
     integer or if END is neither an integer nor 'nil'.  An
     'args-out-of-range' error is signaled if START indicates a
     character following END, or if either integer is out of range for
     STRING.

     Contrast this function with 'buffer-substring' (*note Buffer
     Contents::), which returns a string containing a portion of the
     text in the current buffer.  The beginning of a string is at index
     0, but the beginning of a buffer is at index 1.

 -- Function: substring-no-properties string &optional start end
     This works like 'substring' but discards all text properties from
     the value.  Also, START may be omitted or 'nil', which is
     equivalent to 0.  Thus, '(substring-no-properties STRING)' returns
     a copy of STRING, with all text properties removed.

 -- Function: concat &rest sequences
     This function returns a string consisting of the characters in the
     arguments passed to it (along with their text properties, if any).
     The arguments may be strings, lists of numbers, or vectors of
     numbers; they are not themselves changed.  If 'concat' receives no
     arguments, it returns an empty string.

          (concat "abc" "-def")
               => "abc-def"
          (concat "abc" (list 120 121) [122])
               => "abcxyz"
          ;; 'nil' is an empty sequence.
          (concat "abc" nil "-def")
               => "abc-def"
          (concat "The " "quick brown " "fox.")
               => "The quick brown fox."
          (concat)
               => ""

     This function does not always allocate a new string.  Callers are
     advised not rely on the result being a new string nor on it being
     'eq' to an existing string.

     In particular, mutating the returned value may inadvertently change
     another string, alter a constant string in the program, or even
     raise an error.  To obtain a string that you can safely mutate, use
     'copy-sequence' on the result.

     For information about other concatenation functions, see the
     description of 'mapconcat' in *note Mapping Functions::, 'vconcat'
     in *note Vector Functions::, and 'append' in *note Building
     Lists::.  For concatenating individual command-line arguments into
     a string to be used as a shell command, see *note
     combine-and-quote-strings: Shell Arguments.

 -- Function: split-string string &optional separators omit-nulls trim
     This function splits STRING into substrings based on the regular
     expression SEPARATORS (*note Regular Expressions::).  Each match
     for SEPARATORS defines a splitting point; the substrings between
     splitting points are made into a list, which is returned.

     If SEPARATORS is 'nil' (or omitted), the default is the value of
     'split-string-default-separators' and the function behaves as if
     OMIT-NULLS were 't'.

     If OMIT-NULLS is 'nil' (or omitted), the result contains null
     strings whenever there are two consecutive matches for SEPARATORS,
     or a match is adjacent to the beginning or end of STRING.  If
     OMIT-NULLS is 't', these null strings are omitted from the result.

     If the optional argument TRIM is non-'nil', it should be a regular
     expression to match text to trim from the beginning and end of each
     substring.  If trimming makes the substring empty, it is treated as
     null.

     If you need to split a string into a list of individual
     command-line arguments suitable for 'call-process' or
     'start-process', see *note split-string-and-unquote: Shell
     Arguments.

     Examples:

          (split-string "  two words ")
               => ("two" "words")

     The result is not '("" "two" "words" "")', which would rarely be
     useful.  If you need such a result, use an explicit value for
     SEPARATORS:

          (split-string "  two words "
                        split-string-default-separators)
               => ("" "two" "words" "")

          (split-string "Soup is good food" "o")
               => ("S" "up is g" "" "d f" "" "d")
          (split-string "Soup is good food" "o" t)
               => ("S" "up is g" "d f" "d")
          (split-string "Soup is good food" "o+")
               => ("S" "up is g" "d f" "d")

     Empty matches do count, except that 'split-string' will not look
     for a final empty match when it already reached the end of the
     string using a non-empty match or when STRING is empty:

          (split-string "aooob" "o*")
               => ("" "a" "" "b" "")
          (split-string "ooaboo" "o*")
               => ("" "" "a" "b" "")
          (split-string "" "")
               => ("")

     However, when SEPARATORS can match the empty string, OMIT-NULLS is
     usually 't', so that the subtleties in the three previous examples
     are rarely relevant:

          (split-string "Soup is good food" "o*" t)
               => ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
          (split-string "Nice doggy!" "" t)
               => ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
          (split-string "" "" t)
               => nil

     Somewhat odd, but predictable, behavior can occur for certain
     "non-greedy" values of SEPARATORS that can prefer empty matches
     over non-empty matches.  Again, such values rarely occur in
     practice:

          (split-string "ooo" "o*" t)
               => nil
          (split-string "ooo" "\\|o+" t)
               => ("o" "o" "o")

 -- Variable: split-string-default-separators
     The default value of SEPARATORS for 'split-string'.  Its usual
     value is '"[ \f\t\n\r\v]+"'.

==============================================================================
File: elisp.info,  Node: |Modifying_Strings|,  Next: |Text_Comparison|,  Prev: |Creating_Strings|,  Up: |Strings_and_Characters|
==============================================================================

                                                             *Modifying_Strings*

4.4 Modifying Strings
---------------------

You can alter the contents of a mutable string via operations described
in this section.  *Note Mutability::.

   The most basic way to alter the contents of an existing string is
with 'aset' (*note Array Functions::).  '(aset STRING IDX CHAR)' stores
CHAR into STRING at index IDX.  Each character occupies one or more
bytes, and if CHAR needs a different number of bytes from the character
already present at that index, 'aset' signals an error.

   A more powerful function is 'store-substring':

 -- Function: store-substring string idx obj
     This function alters part of the contents of the string STRING, by
     storing OBJ starting at index IDX.  The argument OBJ may be either
     a character or a (smaller) string.

     Since it is impossible to change the length of an existing string,
     it is an error if OBJ doesn't fit within STRING's actual length, or
     if any new character requires a different number of bytes from the
     character currently present at that point in STRING.

   To clear out a string that contained a password, use 'clear-string':

 -- Function: clear-string string
     This makes STRING a unibyte string and clears its contents to
     zeros.  It may also change STRING's length.

==============================================================================
File: elisp.info,  Node: |Text_Comparison|,  Next: |String_Conversion|,  Prev: |Modifying_Strings|,  Up: |Strings_and_Characters|
==============================================================================

                                                               *Text_Comparison*

4.5 Comparison of Characters and Strings
----------------------------------------

 -- Function: char-equal character1 character2
     This function returns 't' if the arguments represent the same
     character, 'nil' otherwise.  This function ignores differences in
     case if 'case-fold-search' is non-'nil'.

          (char-equal ?x ?x)
               => t
          (let ((case-fold-search nil))
            (char-equal ?x ?X))
               => nil

 -- Function: string= string1 string2
     This function returns 't' if the characters of the two strings
     match exactly.  Symbols are also allowed as arguments, in which
     case the symbol names are used.  Case is always significant,
     regardless of 'case-fold-search'.

     This function is equivalent to 'equal' for comparing two strings
     (*note Equality Predicates::).  In particular, the text properties
     of the two strings are ignored; use 'equal-including-properties' if
     you need to distinguish between strings that differ only in their
     text properties.  However, unlike 'equal', if either argument is
     not a string or symbol, 'string=' signals an error.

          (string= "abc" "abc")
               => t
          (string= "abc" "ABC")
               => nil
          (string= "ab" "ABC")
               => nil

     For technical reasons, a unibyte and a multibyte string are 'equal'
     if and only if they contain the same sequence of character codes
     and all these codes are either in the range 0 through 127 (ASCII)
     or 160 through 255 ('eight-bit-graphic').  However, when a unibyte
     string is converted to a multibyte string, all characters with
     codes in the range 160 through 255 are converted to characters with
     higher codes, whereas ASCII characters remain unchanged.  Thus, a
     unibyte string and its conversion to multibyte are only 'equal' if
     the string is all ASCII.  Character codes 160 through 255 are not
     entirely proper in multibyte text, even though they can occur.  As
     a consequence, the situation where a unibyte and a multibyte string
     are 'equal' without both being all ASCII is a technical oddity that
     very few Emacs Lisp programmers ever get confronted with.  *Note
     Text Representations::.

 -- Function: string-equal string1 string2
     'string-equal' is another name for 'string='.

 -- Function: string-collate-equalp string1 string2 &optional locale
          ignore-case
     This function returns 't' if STRING1 and STRING2 are equal with
     respect to collation rules.  A collation rule is not only
     determined by the lexicographic order of the characters contained
     in STRING1 and STRING2, but also further rules about relations
     between these characters.  Usually, it is defined by the LOCALE
     environment Emacs is running with.

     For example, characters with different coding points but the same
     meaning might be considered as equal, like different grave accent
     Unicode characters:

          (string-collate-equalp (string ?\uFF40) (string ?\u1FEF))
               => t

     The optional argument LOCALE, a string, overrides the setting of
     your current locale identifier for collation.  The value is system
     dependent; a LOCALE '"en_US.UTF-8"' is applicable on POSIX systems,
     while it would be, e.g., '"enu_USA.1252"' on MS-Windows systems.

     If IGNORE-CASE is non-'nil', characters are converted to lower-case
     before comparing them.

     To emulate Unicode-compliant collation on MS-Windows systems, bind
     'w32-collate-ignore-punctuation' to a non-'nil' value, since the
     codeset part of the locale cannot be '"UTF-8"' on MS-Windows.

     If your system does not support a locale environment, this function
     behaves like 'string-equal'.

     Do _not_ use this function to compare file names for equality, as
     filesystems generally don't honor linguistic equivalence of strings
     that collation implements.

 -- Function: string< string1 string2
     This function compares two strings a character at a time.  It scans
     both the strings at the same time to find the first pair of
     corresponding characters that do not match.  If the lesser
     character of these two is the character from STRING1, then STRING1
     is less, and this function returns 't'.  If the lesser character is
     the one from STRING2, then STRING1 is greater, and this function
     returns 'nil'.  If the two strings match entirely, the value is
     'nil'.

     Pairs of characters are compared according to their character
     codes.  Keep in mind that lower case letters have higher numeric
     values in the ASCII character set than their upper case
     counterparts; digits and many punctuation characters have a lower
     numeric value than upper case letters.  An ASCII character is less
     than any non-ASCII character; a unibyte non-ASCII character is
     always less than any multibyte non-ASCII character (*note Text
     Representations::).

          (string< "abc" "abd")
               => t
          (string< "abd" "abc")
               => nil
          (string< "123" "abc")
               => t

     When the strings have different lengths, and they match up to the
     length of STRING1, then the result is 't'.  If they match up to the
     length of STRING2, the result is 'nil'.  A string of no characters
     is less than any other string.

          (string< "" "abc")
               => t
          (string< "ab" "abc")
               => t
          (string< "abc" "")
               => nil
          (string< "abc" "ab")
               => nil
          (string< "" "")
               => nil

     Symbols are also allowed as arguments, in which case their print
     names are compared.

 -- Function: string-lessp string1 string2
     'string-lessp' is another name for 'string<'.

 -- Function: string-greaterp string1 string2
     This function returns the result of comparing STRING1 and STRING2
     in the opposite order, i.e., it is equivalent to calling
     '(string-lessp STRING2 STRING1)'.

 -- Function: string-collate-lessp string1 string2 &optional locale
          ignore-case
     This function returns 't' if STRING1 is less than STRING2 in
     collation order.  A collation order is not only determined by the
     lexicographic order of the characters contained in STRING1 and
     STRING2, but also further rules about relations between these
     characters.  Usually, it is defined by the LOCALE environment Emacs
     is running with.

     For example, punctuation and whitespace characters might be ignored
     for sorting (*note Sequence Functions::):

          (sort (list "11" "12" "1 1" "1 2" "1.1" "1.2") 'string-collate-lessp)
               => ("11" "1 1" "1.1" "12" "1 2" "1.2")

     This behavior is system-dependent; e.g., punctuation and whitespace
     are never ignored on Cygwin, regardless of locale.

     The optional argument LOCALE, a string, overrides the setting of
     your current locale identifier for collation.  The value is system
     dependent; a LOCALE '"en_US.UTF-8"' is applicable on POSIX systems,
     while it would be, e.g., '"enu_USA.1252"' on MS-Windows systems.
     The LOCALE value of '"POSIX"' or '"C"' lets 'string-collate-lessp'
     behave like 'string-lessp':

          (sort (list "11" "12" "1 1" "1 2" "1.1" "1.2")
                (lambda (s1 s2) (string-collate-lessp s1 s2 "POSIX")))
               => ("1 1" "1 2" "1.1" "1.2" "11" "12")

     If IGNORE-CASE is non-'nil', characters are converted to lower-case
     before comparing them.

     To emulate Unicode-compliant collation on MS-Windows systems, bind
     'w32-collate-ignore-punctuation' to a non-'nil' value, since the
     codeset part of the locale cannot be '"UTF-8"' on MS-Windows.

     If your system does not support a locale environment, this function
     behaves like 'string-lessp'.

 -- Function: string-version-lessp string1 string2
     This function compares strings lexicographically, except it treats
     sequences of numerical characters as if they comprised a base-ten
     number, and then compares the numbers.  So 'foo2.png' is "smaller"
     than 'foo12.png' according to this predicate, even if '12' is
     lexicographically "smaller" than '2'.

 -- Function: string-prefix-p string1 string2 &optional ignore-case
     This function returns non-'nil' if STRING1 is a prefix of STRING2;
     i.e., if STRING2 starts with STRING1.  If the optional argument
     IGNORE-CASE is non-'nil', the comparison ignores case differences.

 -- Function: string-suffix-p suffix string &optional ignore-case
     This function returns non-'nil' if SUFFIX is a suffix of STRING;
     i.e., if STRING ends with SUFFIX.  If the optional argument
     IGNORE-CASE is non-'nil', the comparison ignores case differences.

 -- Function: compare-strings string1 start1 end1 string2 start2 end2
          &optional ignore-case
     This function compares a specified part of STRING1 with a specified
     part of STRING2.  The specified part of STRING1 runs from index
     START1 (inclusive) up to index END1 (exclusive); 'nil' for START1
     means the start of the string, while 'nil' for END1 means the
     length of the string.  Likewise, the specified part of STRING2 runs
     from index START2 up to index END2.

     The strings are compared by the numeric values of their characters.
     For instance, STR1 is considered less than STR2 if its first
     differing character has a smaller numeric value.  If IGNORE-CASE is
     non-'nil', characters are converted to upper-case before comparing
     them.  Unibyte strings are converted to multibyte for comparison
     (*note Text Representations::), so that a unibyte string and its
     conversion to multibyte are always regarded as equal.

     If the specified portions of the two strings match, the value is
     't'.  Otherwise, the value is an integer which indicates how many
     leading characters agree, and which string is less.  Its absolute
     value is one plus the number of characters that agree at the
     beginning of the two strings.  The sign is negative if STRING1 (or
     its specified portion) is less.

 -- Function: string-distance string1 string2 &optional bytecompare
     This function returns the "Levenshtein distance" between the source
     string STRING1 and the target string STRING2.  The Levenshtein
     distance is the number of single-character changes--deletions,
     insertions, or replacements--required to transform the source string
     into the target string; it is one possible definition of the "edit
     distance" between strings.

     Letter-case of the strings is significant for the computed
     distance, but their text properties are ignored.  If the optional
     argument BYTECOMPARE is non-'nil', the function calculates the
     distance in terms of bytes instead of characters.  The byte-wise
     comparison uses the internal Emacs representation of characters, so
     it will produce inaccurate results for multibyte strings that
     include raw bytes (*note Text Representations::); make the strings
     unibyte by encoding them (*note Explicit Encoding::) if you need
     accurate results with raw bytes.

 -- Function: assoc-string key alist &optional case-fold
     This function works like 'assoc', except that KEY must be a string
     or symbol, and comparison is done using 'compare-strings'.  Symbols
     are converted to strings before testing.  If CASE-FOLD is
     non-'nil', KEY and the elements of ALIST are converted to
     upper-case before comparison.  Unlike 'assoc', this function can
     also match elements of the alist that are strings or symbols rather
     than conses.  In particular, ALIST can be a list of strings or
     symbols rather than an actual alist.  *Note Association Lists::.

   See also the function 'compare-buffer-substrings' in *note Comparing
Text::, for a way to compare text in buffers.  The function
'string-match', which matches a regular expression against a string, can
be used for a kind of string comparison; see *note Regexp Search::.

==============================================================================
File: elisp.info,  Node: |String_Conversion|,  Next: |Formatting_Strings|,  Prev: |Text_Comparison|,  Up: |Strings_and_Characters|
==============================================================================

                                                             *String_Conversion*

4.6 Conversion of Characters and Strings
----------------------------------------

This section describes functions for converting between characters,
strings and integers.  'format' (*note Formatting Strings::) and
'prin1-to-string' (*note Output Functions::) can also convert Lisp
objects into strings.  'read-from-string' (*note Input Functions::) can
convert a string representation of a Lisp object into an object.  The
functions 'string-to-multibyte' and 'string-to-unibyte' convert the text
representation of a string (*note Converting Representations::).

   *Note Documentation::, for functions that produce textual
descriptions of text characters and general input events
('single-key-description' and 'text-char-description').  These are used
primarily for making help messages.

 -- Function: number-to-string number
     This function returns a string consisting of the printed base-ten
     representation of NUMBER.  The returned value starts with a minus
     sign if the argument is negative.

          (number-to-string 256)
               => "256"
          (number-to-string -23)
               => "-23"
          (number-to-string -23.5)
               => "-23.5"

     'int-to-string' is a semi-obsolete alias for this function.

     See also the function 'format' in *note Formatting Strings::.

 -- Function: string-to-number string &optional base
     This function returns the numeric value of the characters in
     STRING.  If BASE is non-'nil', it must be an integer between 2 and
     16 (inclusive), and integers are converted in that base.  If BASE
     is 'nil', then base ten is used.  Floating-point conversion only
     works in base ten; we have not implemented other radices for
     floating-point numbers, because that would be much more work and
     does not seem useful.  If STRING looks like an integer but its
     value is too large to fit into a Lisp integer, 'string-to-number'
     returns a floating-point result.

     The parsing skips spaces and tabs at the beginning of STRING, then
     reads as much of STRING as it can interpret as a number in the
     given base.  (On some systems it ignores other whitespace at the
     beginning, not just spaces and tabs.)  If STRING cannot be
     interpreted as a number, this function returns 0.

          (string-to-number "256")
               => 256
          (string-to-number "25 is a perfect square.")
               => 25
          (string-to-number "X256")
               => 0
          (string-to-number "-4.5")
               => -4.5
          (string-to-number "1e5")
               => 100000.0

     'string-to-int' is an obsolete alias for this function.

 -- Function: char-to-string character
     This function returns a new string containing one character,
     CHARACTER.  This function is semi-obsolete because the function
     'string' is more general.  *Note Creating Strings::.

 -- Function: string-to-char string
     This function returns the first character in STRING.  This mostly
     identical to '(aref string 0)', except that it returns 0 if the
     string is empty.  (The value is also 0 when the first character of
     STRING is the null character, ASCII code 0.)  This function may be
     eliminated in the future if it does not seem useful enough to
     retain.

   Here are some other functions that can convert to or from a string:

'concat'
     This function converts a vector or a list into a string.  *Note
     Creating Strings::.

'vconcat'
     This function converts a string into a vector.  *Note Vector
     Functions::.

'append'
     This function converts a string into a list.  *Note Building
     Lists::.

'byte-to-string'
     This function converts a byte of character data into a unibyte
     string.  *Note Converting Representations::.

==============================================================================
File: elisp.info,  Node: |Formatting_Strings|,  Next: |Custom_Format_Strings|,  Prev: |String_Conversion|,  Up: |Strings_and_Characters|
==============================================================================

                                                            *Formatting_Strings*

4.7 Formatting Strings
----------------------

"Formatting" means constructing a string by substituting computed values
at various places in a constant string.  This constant string controls
how the other values are printed, as well as where they appear; it is
called a "format string".

   Formatting is often useful for computing messages to be displayed.
In fact, the functions 'message' and 'error' provide the same formatting
feature described here; they differ from 'format-message' only in how
they use the result of formatting.

 -- Function: format string &rest objects
     This function returns a string equal to STRING, replacing any
     format specifications with encodings of the corresponding OBJECTS.
     The arguments OBJECTS are the computed values to be formatted.

     The characters in STRING, other than the format specifications, are
     copied directly into the output, including their text properties,
     if any.  Any text properties of the format specifications are
     copied to the produced string representations of the argument
     OBJECTS.

     The output string need not be newly-allocated.  For example, if 'x'
     is the string '"foo"', the expressions '(eq x (format x))' and '(eq
     x (format "%s" x))' might both yield 't'.

 -- Function: format-message string &rest objects
     This function acts like 'format', except it also converts any grave
     accents (`) and apostrophes (') in STRING as per the value of
     'text-quoting-style'.

     Typically grave accent and apostrophe in the format translate to
     matching curved quotes, e.g., "Missing `%s'" might result in
     "Missing 'foo'".  *Note Text Quoting Style::, for how to influence
     or inhibit this translation.

   A format specification is a sequence of characters beginning with a
'%'.  Thus, if there is a '%d' in STRING, the 'format' function replaces
it with the printed representation of one of the values to be formatted
(one of the arguments OBJECTS).  For example:

     (format "The value of fill-column is %d." fill-column)
          => "The value of fill-column is 72."

   Since 'format' interprets '%' characters as format specifications,
you should _never_ pass an arbitrary string as the first argument.  This
is particularly true when the string is generated by some Lisp code.
Unless the string is _known_ to never include any '%' characters, pass
'"%s"', described below, as the first argument, and the string as the
second, like this:

       (format "%s" ARBITRARY-STRING)

   Certain format specifications require values of particular types.  If
you supply a value that doesn't fit the requirements, an error is
signaled.

   Here is a table of valid format specifications:

'%s'
     Replace the specification with the printed representation of the
     object, made without quoting (that is, using 'princ', not
     'prin1'--*note Output Functions::).  Thus, strings are represented
     by their contents alone, with no '"' characters, and symbols appear
     without '\' characters.

     If the object is a string, its text properties are copied into the
     output.  The text properties of the '%s' itself are also copied,
     but those of the object take priority.

'%S'
     Replace the specification with the printed representation of the
     object, made with quoting (that is, using 'prin1'--*note Output
     Functions::).  Thus, strings are enclosed in '"' characters, and
     '\' characters appear where necessary before special characters.

'%o'
     Replace the specification with the base-eight representation of an
     integer.  Negative integers are formatted in a platform-dependent
     way.  The object can also be a floating-point number that is
     formatted as an integer, dropping any fraction.

'%d'
     Replace the specification with the base-ten representation of a
     signed integer.  The object can also be a floating-point number
     that is formatted as an integer, dropping any fraction.

'%x'
'%X'
     Replace the specification with the base-sixteen representation of
     an integer.  Negative integers are formatted in a
     platform-dependent way.  '%x' uses lower case and '%X' uses upper
     case.  The object can also be a floating-point number that is
     formatted as an integer, dropping any fraction.

'%c'
     Replace the specification with the character which is the value
     given.

'%e'
     Replace the specification with the exponential notation for a
     floating-point number.

'%f'
     Replace the specification with the decimal-point notation for a
     floating-point number.

'%g'
     Replace the specification with notation for a floating-point
     number, using either exponential notation or decimal-point
     notation.  The exponential notation is used if the exponent would
     be less than -4 or greater than or equal to the precision (default:
     6).  By default, trailing zeros are removed from the fractional
     portion of the result and a decimal-point character appears only if
     it is followed by a digit.

'%%'
     Replace the specification with a single '%'.  This format
     specification is unusual in that its only form is plain '%%' and
     that it does not use a value.  For example, '(format "%% %d" 30)'
     returns '"% 30"'.

   Any other format character results in an 'Invalid format operation'
error.

   Here are several examples, which assume the typical
'text-quoting-style' settings:

     (format "The octal value of %d is %o,
              and the hex value is %x." 18 18 18)
          => "The octal value of 18 is 22,
              and the hex value is 12."

     (format-message
      "The name of this buffer is '%s'." (buffer-name))
          => "The name of this buffer is 'strings.texi'."

     (format-message
      "The buffer object prints as `%s'." (current-buffer))
          => "The buffer object prints as 'strings.texi'."

   By default, format specifications correspond to successive values
from OBJECTS.  Thus, the first format specification in STRING uses the
first such value, the second format specification uses the second such
value, and so on.  Any extra format specifications (those for which
there are no corresponding values) cause an error.  Any extra values to
be formatted are ignored.

   A format specification can have a "field number", which is a decimal
number immediately after the initial '%', followed by a literal dollar
sign '$'.  It causes the format specification to convert the argument
with the given number instead of the next argument.  Field numbers start
at 1.  A format can contain either numbered or unnumbered format
specifications but not both, except that '%%' can be mixed with numbered
specifications.

     (format "%2$s, %3$s, %%, %1$s" "x" "y" "z")
          => "y, z, %, x"

   After the '%' and any field number, you can put certain "flag
characters".

   The flag '+' inserts a plus sign before a nonnegative number, so that
it always has a sign.  A space character as flag inserts a space before
a nonnegative number.  (Otherwise, nonnegative numbers start with the
first digit.)  These flags are useful for ensuring that nonnegative and
negative numbers use the same number of columns.  They are ignored
except for '%d', '%e', '%f', '%g', and if both flags are used, '+' takes
precedence.

   The flag '#' specifies an alternate form which depends on the format
in use.  For '%o', it ensures that the result begins with a '0'.  For
'%x' and '%X', it prefixes nonzero results with '0x' or '0X'.  For '%e'
and '%f', the '#' flag means include a decimal point even if the
precision is zero.  For '%g', it always includes a decimal point, and
also forces any trailing zeros after the decimal point to be left in
place where they would otherwise be removed.

   The flag '0' ensures that the padding consists of '0' characters
instead of spaces.  This flag is ignored for non-numerical specification
characters like '%s', '%S' and '%c'.  These specification characters
accept the '0' flag, but still pad with _spaces_.

   The flag '-' causes any padding inserted by the width, if specified,
to be inserted on the right rather than the left.  If both '-' and '0'
are present, the '0' flag is ignored.

     (format "%06d is padded on the left with zeros" 123)
          => "000123 is padded on the left with zeros"

     (format "'%-6d' is padded on the right" 123)
          => "'123   ' is padded on the right"

     (format "The word '%-7s' actually has %d letters in it."
             "foo" (length "foo"))
          => "The word 'foo    ' actually has 3 letters in it."

   A specification can have a "width", which is a decimal number that
appears after any field number and flags.  If the printed representation
of the object contains fewer characters than this width, 'format'
extends it with padding.  Any padding introduced by the width normally
consists of spaces inserted on the left:

     (format "%5d is padded on the left with spaces" 123)
          => "  123 is padded on the left with spaces"

If the width is too small, 'format' does not truncate the object's
printed representation.  Thus, you can use a width to specify a minimum
spacing between columns with no risk of losing information.  In the
following two examples, '%7s' specifies a minimum width of 7.  In the
first case, the string inserted in place of '%7s' has only 3 letters,
and needs 4 blank spaces as padding.  In the second case, the string
'"specification"' is 13 letters wide but is not truncated.

     (format "The word '%7s' has %d letters in it."
             "foo" (length "foo"))
          => "The word '    foo' has 3 letters in it."
     (format "The word '%7s' has %d letters in it."
             "specification" (length "specification"))
          => "The word 'specification' has 13 letters in it."

   All the specification characters allow an optional "precision" after
the field number, flags and width, if present.  The precision is a
decimal-point '.' followed by a digit-string.  For the floating-point
specifications ('%e' and '%f'), the precision specifies how many digits
following the decimal point to show; if zero, the decimal-point itself
is also omitted.  For '%g', the precision specifies how many significant
digits to show (significant digits are the first digit before the
decimal point and all the digits after it).  If the precision of %g is
zero or unspecified, it is treated as 1.  For '%s' and '%S', the
precision truncates the string to the given width, so '%.3s' shows only
the first three characters of the representation for OBJECT.  For other
specification characters, the effect of precision is what the local
library functions of the 'printf' family produce.

   If you plan to use 'read' later on the formatted string to retrieve a
copy of the formatted value, use a specification that lets 'read'
reconstruct the value.  To format numbers in this reversible way you can
use '%s' and '%S', to format just integers you can also use '%d', and to
format just nonnegative integers you can also use '#x%x' and '#o%o'.
Other formats may be problematic; for example, '%d' and '%g' can
mishandle NaNs and can lose precision and type, and '#x%x' and '#o%o'
can mishandle negative integers.  *Note Input Functions::.

   The functions described in this section accept a fixed set of
specification characters.  The next section describes a function
'format-spec' which can accept custom specification characters, such as
'%a' or '%z'.

==============================================================================
File: elisp.info,  Node: |Custom_Format_Strings|,  Next: |Case_Conversion|,  Prev: |Formatting_Strings|,  Up: |Strings_and_Characters|
==============================================================================

                                                         *Custom_Format_Strings*

4.8 Custom Format Strings
-------------------------

Sometimes it is useful to allow users and Lisp programs alike to control
how certain text is generated via custom format control strings.  For
example, a format string could control how to display someone's
forename, surname, and email address.  Using the function 'format'
described in the previous section, the format string could be something
like '"%s %s <%s>"'.  This approach quickly becomes impractical,
however, as it can be unclear which specification character corresponds
to which piece of information.

   A more convenient format string for such cases would be something
like '"%f %l <%e>"', where each specification character carries more
semantic information and can easily be rearranged relative to other
specification characters, making such format strings more easily
customizable by the user.

   The function 'format-spec' described in this section performs a
similar function to 'format', except it operates on format control
strings that use arbitrary specification characters.

 -- Function: format-spec template spec-alist &optional only-present
     This function returns a string produced from the format string
     TEMPLATE according to conversions specified in SPEC-ALIST, which is
     an alist (*note Association Lists::) of the form
     '(LETTER . REPLACEMENT)'.  Each specification '%LETTER' in TEMPLATE
     will be replaced by REPLACEMENT when formatting the resulting
     string.

     The characters in TEMPLATE, other than the format specifications,
     are copied directly into the output, including their text
     properties, if any.  Any text properties of the format
     specifications are copied to their replacements.

     Using an alist to specify conversions gives rise to some useful
     properties:

        * If SPEC-ALIST contains more unique LETTER keys than there are
          unique specification characters in TEMPLATE, the unused keys
          are simply ignored.
        * If SPEC-ALIST contains more than one association with the same
          LETTER, the closest one to the start of the list is used.
        * If TEMPLATE contains the same specification character more
          than once, then the same REPLACEMENT found in SPEC-ALIST is
          used as a basis for all of that character's substitutions.
        * The order of specifications in TEMPLATE need not correspond to
          the order of associations in SPEC-ALIST.

     The optional argument ONLY-PRESENT indicates how to handle
     specification characters in TEMPLATE that are not found in
     SPEC-ALIST.  If it is 'nil' or omitted, the function signals an
     error.  Otherwise, those format specifications and any occurrences
     of '%%' in TEMPLATE are left verbatim in the output, including
     their text properties, if any.

   The syntax of format specifications accepted by 'format-spec' is
similar, but not identical, to that accepted by 'format'.  In both
cases, a format specification is a sequence of characters beginning with
'%' and ending with an alphabetic letter such as 's'.

   Unlike 'format', which assigns specific meanings to a fixed set of
specification characters, 'format-spec' accepts arbitrary specification
characters and treats them all equally.  For example:

     (setq my-site-info
           (list (cons ?s system-name)
                 (cons ?t (symbol-name system-type))
                 (cons ?c system-configuration)
                 (cons ?v emacs-version)
                 (cons ?e invocation-name)
                 (cons ?p (number-to-string (emacs-pid)))
                 (cons ?a user-mail-address)
                 (cons ?n user-full-name)))

     (format-spec "%e %v (%c)" my-site-info)
          => "emacs 27.1 (x86_64-pc-linux-gnu)"

     (format-spec "%n <%a>" my-site-info)
          => "Emacs Developers <emacs-devel@gnu.org>"

   A format specification can include any number of the following flag
characters immediately after the '%' to modify aspects of the
substitution.

'0'
     This flag causes any padding specified by the width to consist of
     '0' characters instead of spaces.

'-'
     This flag causes any padding specified by the width to be inserted
     on the right rather than the left.

'<'
     This flag causes the substitution to be truncated on the left to
     the given width, if specified.

'>'
     This flag causes the substitution to be truncated on the right to
     the given width, if specified.

'^'
     This flag converts the substituted text to upper case (*note Case
     Conversion::).

'_'
     This flag converts the substituted text to lower case (*note Case
     Conversion::).

   The result of using contradictory flags (for instance, both upper and
lower case) is undefined.

   As is the case with 'format', a format specification can include a
width, which is a decimal number that appears after any flags.  If a
substitution contains fewer characters than its specified width, it is
padded on the left:

     (format-spec "%8a is padded on the left with spaces"
                  '((?a . "alpha")))
          => "   alpha is padded on the left with spaces"

   Here is a more complicated example that combines several
aforementioned features:

     (setq my-battery-info
           (list (cons ?p "73")      ; Percentage
                 (cons ?L "Battery") ; Status
                 (cons ?t "2:23")    ; Remaining time
                 (cons ?c "24330")   ; Capacity
                 (cons ?r "10.6")))  ; Rate of discharge

     (format-spec "%>^-3L : %3p%% (%05t left)" my-battery-info)
          => "BAT :  73% (02:23 left)"

     (format-spec "%>^-3L : %3p%% (%05t left)"
                  (cons (cons ?L "AC")
                        my-battery-info))
          => "AC  :  73% (02:23 left)"

   As the examples in this section illustrate, 'format-spec' is often
used for selectively formatting an assortment of different pieces of
information.  This is useful in programs that provide user-customizable
format strings, as the user can choose to format with a regular syntax
and in any desired order only a subset of the information that the
program makes available.

==============================================================================
File: elisp.info,  Node: |Case_Conversion|,  Next: |Case_Tables|,  Prev: |Custom_Format_Strings|,  Up: |Strings_and_Characters|
==============================================================================

                                                               *Case_Conversion*

4.9 Case Conversion in Lisp
---------------------------

The character case functions change the case of single characters or of
the contents of strings.  The functions normally convert only alphabetic
characters (the letters 'A' through 'Z' and 'a' through 'z', as well as
non-ASCII letters); other characters are not altered.  You can specify a
different case conversion mapping by specifying a case table (*note Case
Tables::).

   These functions do not modify the strings that are passed to them as
arguments.

   The examples below use the characters 'X' and 'x' which have ASCII
codes 88 and 120 respectively.

 -- Function: downcase string-or-char
     This function converts STRING-OR-CHAR, which should be either a
     character or a string, to lower case.

     When STRING-OR-CHAR is a string, this function returns a new string
     in which each letter in the argument that is upper case is
     converted to lower case.  When STRING-OR-CHAR is a character, this
     function returns the corresponding lower case character (an
     integer); if the original character is lower case, or is not a
     letter, the return value is equal to the original character.

          (downcase "The cat in the hat")
               => "the cat in the hat"

          (downcase ?X)
               => 120

 -- Function: upcase string-or-char
     This function converts STRING-OR-CHAR, which should be either a
     character or a string, to upper case.

     When STRING-OR-CHAR is a string, this function returns a new string
     in which each letter in the argument that is lower case is
     converted to upper case.  When STRING-OR-CHAR is a character, this
     function returns the corresponding upper case character (an
     integer); if the original character is upper case, or is not a
     letter, the return value is equal to the original character.

          (upcase "The cat in the hat")
               => "THE CAT IN THE HAT"

          (upcase ?x)
               => 88

 -- Function: capitalize string-or-char
     This function capitalizes strings or characters.  If STRING-OR-CHAR
     is a string, the function returns a new string whose contents are a
     copy of STRING-OR-CHAR in which each word has been capitalized.
     This means that the first character of each word is converted to
     upper case, and the rest are converted to lower case.

     The definition of a word is any sequence of consecutive characters
     that are assigned to the word constituent syntax class in the
     current syntax table (*note Syntax Class Table::).

     When STRING-OR-CHAR is a character, this function does the same
     thing as 'upcase'.

          (capitalize "The cat in the hat")
               => "The Cat In The Hat"

          (capitalize "THE 77TH-HATTED CAT")
               => "The 77th-Hatted Cat"

          (capitalize ?x)
               => 88

 -- Function: upcase-initials string-or-char
     If STRING-OR-CHAR is a string, this function capitalizes the
     initials of the words in STRING-OR-CHAR, without altering any
     letters other than the initials.  It returns a new string whose
     contents are a copy of STRING-OR-CHAR, in which each word has had
     its initial letter converted to upper case.

     The definition of a word is any sequence of consecutive characters
     that are assigned to the word constituent syntax class in the
     current syntax table (*note Syntax Class Table::).

     When the argument to 'upcase-initials' is a character,
     'upcase-initials' has the same result as 'upcase'.

          (upcase-initials "The CAT in the hAt")
               => "The CAT In The HAt"

   Note that case conversion is not a one-to-one mapping of codepoints
and length of the result may differ from length of the argument.
Furthermore, because passing a character forces return type to be a
character, functions are unable to perform proper substitution and
result may differ compared to treating a one-character string.  For
example:

     (upcase "???")  ; note: single character, ligature "fi"
          => "FI"
     (upcase ????)
          => 64257  ; i.e. ????

   To avoid this, a character must first be converted into a string,
using 'string' function, before being passed to one of the casing
functions.  Of course, no assumptions on the length of the result may be
made.

   Mapping for such special cases are taken from 'special-uppercase',
'special-lowercase' and 'special-titlecase' *Note Character
Properties::.

   *Note Text Comparison::, for functions that compare strings; some of
them ignore case differences, or can optionally ignore case differences.

==============================================================================
File: elisp.info,  Node: |Case_Tables|,  Prev: |Case_Conversion|,  Up: |Strings_and_Characters|
==============================================================================

                                                                   *Case_Tables*

4.10 The Case Table
-------------------

You can customize case conversion by installing a special "case table".
A case table specifies the mapping between upper case and lower case
letters.  It affects both the case conversion functions for Lisp objects
(see the previous section) and those that apply to text in the buffer
(*note Case Changes::).  Each buffer has a case table; there is also a
standard case table which is used to initialize the case table of new
buffers.

   A case table is a char-table (*note Char-Tables::) whose subtype is
'case-table'.  This char-table maps each character into the
corresponding lower case character.  It has three extra slots, which
hold related tables:

UPCASE
     The upcase table maps each character into the corresponding upper
     case character.
CANONICALIZE
     The canonicalize table maps all of a set of case-related characters
     into a particular member of that set.
EQUIVALENCES
     The equivalences table maps each one of a set of case-related
     characters into the next character in that set.

   In simple cases, all you need to specify is the mapping to
lower-case; the three related tables will be calculated automatically
from that one.

   For some languages, upper and lower case letters are not in
one-to-one correspondence.  There may be two different lower case
letters with the same upper case equivalent.  In these cases, you need
to specify the maps for both lower case and upper case.

   The extra table CANONICALIZE maps each character to a canonical
equivalent; any two characters that are related by case-conversion have
the same canonical equivalent character.  For example, since 'a' and 'A'
are related by case-conversion, they should have the same canonical
equivalent character (which should be either 'a' for both of them, or
'A' for both of them).

   The extra table EQUIVALENCES is a map that cyclically permutes each
equivalence class (of characters with the same canonical equivalent).
(For ordinary ASCII, this would map 'a' into 'A' and 'A' into 'a', and
likewise for each set of equivalent characters.)

   When constructing a case table, you can provide 'nil' for
CANONICALIZE; then Emacs fills in this slot from the lower case and
upper case mappings.  You can also provide 'nil' for EQUIVALENCES; then
Emacs fills in this slot from CANONICALIZE.  In a case table that is
actually in use, those components are non-'nil'.  Do not try to specify
EQUIVALENCES without also specifying CANONICALIZE.

   Here are the functions for working with case tables:

 -- Function: case-table-p object
     This predicate returns non-'nil' if OBJECT is a valid case table.

 -- Function: set-standard-case-table table
     This function makes TABLE the standard case table, so that it will
     be used in any buffers created subsequently.

 -- Function: standard-case-table
     This returns the standard case table.

 -- Function: current-case-table
     This function returns the current buffer's case table.

 -- Function: set-case-table table
     This sets the current buffer's case table to TABLE.

 -- Macro: with-case-table table body...
     The 'with-case-table' macro saves the current case table, makes
     TABLE the current case table, evaluates the BODY forms, and finally
     restores the case table.  The return value is the value of the last
     form in BODY.  The case table is restored even in case of an
     abnormal exit via 'throw' or error (*note Nonlocal Exits::).

   Some language environments modify the case conversions of ASCII
characters; for example, in the Turkish language environment, the ASCII
capital I is downcased into a Turkish dotless i ('??').  This can
interfere with code that requires ordinary ASCII case conversion, such
as implementations of ASCII-based network protocols.  In that case, use
the 'with-case-table' macro with the variable ASCII-CASE-TABLE, which
stores the unmodified case table for the ASCII character set.

 -- Variable: ascii-case-table
     The case table for the ASCII character set.  This should not be
     modified by any language environment settings.

   The following three functions are convenient subroutines for packages
that define non-ASCII character sets.  They modify the specified case
table CASE-TABLE; they also modify the standard syntax table.  *Note
Syntax Tables::.  Normally you would use these functions to change the
standard case table.

 -- Function: set-case-syntax-pair uc lc case-table
     This function specifies a pair of corresponding letters, one upper
     case and one lower case.

 -- Function: set-case-syntax-delims l r case-table
     This function makes characters L and R a matching pair of
     case-invariant delimiters.

 -- Function: set-case-syntax char syntax case-table
     This function makes CHAR case-invariant, with syntax SYNTAX.

 -- Command: describe-buffer-case-table
     This command displays a description of the contents of the current
     buffer's case table.

==============================================================================
File: elisp.info,  Node: |Lists|,  Next: |Sequences_Arrays_Vectors|,  Prev: |Strings_and_Characters|,  Up: |Top|
==============================================================================

                                                                         *Lists*

5 Lists
=======

A "list" represents a sequence of zero or more elements (which may be
any Lisp objects).  The important difference between lists and vectors
is that two or more lists can share part of their structure; in
addition, you can insert or delete elements in a list without copying
the whole list.

MENU

* |Cons_Cells|::          How lists are made out of cons cells.
* |List_related_Predicates|::        Is this object a list?  Comparing two lists.
* |List_Elements|::       Extracting the pieces of a list.
* |Building_Lists|::      Creating list structure.
* |List_Variables|::      Modifying lists stored in variables.
* |Modifying_Lists|::     Storing new pieces into an existing list.
* |Sets_And_Lists|::      A list can represent a finite mathematical set.
* |Association_Lists|::   A list can represent a finite relation or mapping.
* |Property_Lists|::      A list of paired elements.

==============================================================================
File: elisp.info,  Node: |Cons_Cells|,  Next: |List_related_Predicates|,  Up: |Lists|
==============================================================================

                                                                    *Cons_Cells*

5.1 Lists and Cons Cells
------------------------

Lists in Lisp are not a primitive data type; they are built up from
"cons cells" (*note Cons Cell Type::).  A cons cell is a data object
that represents an ordered pair.  That is, it has two slots, and each
slot "holds", or "refers to", some Lisp object.  One slot is known as
the CAR, and the other is known as the CDR.  (These names are
traditional; see *note Cons Cell Type::.)  CDR is pronounced "could-er".

   We say that "the CAR of this cons cell is" whatever object its CAR
slot currently holds, and likewise for the CDR.

   A list is a series of cons cells chained together, so that each cell
refers to the next one.  There is one cons cell for each element of the
list.  By convention, the CARs of the cons cells hold the elements of
the list, and the CDRs are used to chain the list (this asymmetry
between CAR and CDR is entirely a matter of convention; at the level of
cons cells, the CAR and CDR slots have similar properties).  Hence, the
CDR slot of each cons cell in a list refers to the following cons cell.

   Also by convention, the CDR of the last cons cell in a list is 'nil'.
We call such a 'nil'-terminated structure a "proper list"(1).  In Emacs
Lisp, the symbol 'nil' is both a symbol and a list with no elements.
For convenience, the symbol 'nil' is considered to have 'nil' as its CDR
(and also as its CAR).

   Hence, the CDR of a proper list is always a proper list.  The CDR of
a nonempty proper list is a proper list containing all the elements
except the first.

   If the CDR of a list's last cons cell is some value other than 'nil',
we call the structure a "dotted list", since its printed representation
would use dotted pair notation (*note Dotted Pair Notation::).  There is
one other possibility: some cons cell's CDR could point to one of the
previous cons cells in the list.  We call that structure a "circular
list".

   For some purposes, it does not matter whether a list is proper,
circular or dotted.  If a program doesn't look far enough down the list
to see the CDR of the final cons cell, it won't care.  However, some
functions that operate on lists demand proper lists and signal errors if
given a dotted list.  Most functions that try to find the end of a list
enter infinite loops if given a circular list.

   Because most cons cells are used as part of lists, we refer to any
structure made out of cons cells as a "list structure".

   ---------- Footnotes ----------

   (1) It is sometimes also referred to as a "true list", but we
generally do not use this terminology in this manual.

==============================================================================
File: elisp.info,  Node: |List_related_Predicates|,  Next: |List_Elements|,  Prev: |Cons_Cells|,  Up: |Lists|
==============================================================================

                                                       *List_related_Predicates*

5.2 Predicates on Lists
-----------------------

The following predicates test whether a Lisp object is an atom, whether
it is a cons cell or is a list, or whether it is the distinguished
object 'nil'.  (Many of these predicates can be defined in terms of the
others, but they are used so often that it is worth having them.)

 -- Function: consp object
     This function returns 't' if OBJECT is a cons cell, 'nil'
     otherwise.  'nil' is not a cons cell, although it _is_ a list.

 -- Function: atom object
     This function returns 't' if OBJECT is an atom, 'nil' otherwise.
     All objects except cons cells are atoms.  The symbol 'nil' is an
     atom and is also a list; it is the only Lisp object that is both.

          (atom OBJECT) ??? (not (consp OBJECT))

 -- Function: listp object
     This function returns 't' if OBJECT is a cons cell or 'nil'.
     Otherwise, it returns 'nil'.

          (listp '(1))
               => t
          (listp '())
               => t

 -- Function: nlistp object
     This function is the opposite of 'listp': it returns 't' if OBJECT
     is not a list.  Otherwise, it returns 'nil'.

          (listp OBJECT) ??? (not (nlistp OBJECT))

 -- Function: null object
     This function returns 't' if OBJECT is 'nil', and returns 'nil'
     otherwise.  This function is identical to 'not', but as a matter of
     clarity we use 'null' when OBJECT is considered a list and 'not'
     when it is considered a truth value (see 'not' in *note Combining
     Conditions::).

          (null '(1))
               => nil
          (null '())
               => t

 -- Function: proper-list-p object
     This function returns the length of OBJECT if it is a proper list,
     'nil' otherwise (*note Cons Cells::).  In addition to satisfying
     'listp', a proper list is neither circular nor dotted.

          (proper-list-p '(a b c))
              => 3
          (proper-list-p '(a b . c))
              => nil

==============================================================================
File: elisp.info,  Node: |List_Elements|,  Next: |Building_Lists|,  Prev: |List_related_Predicates|,  Up: |Lists|
==============================================================================

                                                                 *List_Elements*

5.3 Accessing Elements of Lists
-------------------------------

 -- Function: car cons-cell
     This function returns the value referred to by the first slot of
     the cons cell CONS-CELL.  In other words, it returns the CAR of
     CONS-CELL.

     As a special case, if CONS-CELL is 'nil', this function returns
     'nil'.  Therefore, any list is a valid argument.  An error is
     signaled if the argument is not a cons cell or 'nil'.

          (car '(a b c))
               => a
          (car '())
               => nil

 -- Function: cdr cons-cell
     This function returns the value referred to by the second slot of
     the cons cell CONS-CELL.  In other words, it returns the CDR of
     CONS-CELL.

     As a special case, if CONS-CELL is 'nil', this function returns
     'nil'; therefore, any list is a valid argument.  An error is
     signaled if the argument is not a cons cell or 'nil'.

          (cdr '(a b c))
               => (b c)
          (cdr '())
               => nil

 -- Function: car-safe object
     This function lets you take the CAR of a cons cell while avoiding
     errors for other data types.  It returns the CAR of OBJECT if
     OBJECT is a cons cell, 'nil' otherwise.  This is in contrast to
     'car', which signals an error if OBJECT is not a list.

          (car-safe OBJECT)
          ???
          (let ((x OBJECT))
            (if (consp x)
                (car x)
              nil))

 -- Function: cdr-safe object
     This function lets you take the CDR of a cons cell while avoiding
     errors for other data types.  It returns the CDR of OBJECT if
     OBJECT is a cons cell, 'nil' otherwise.  This is in contrast to
     'cdr', which signals an error if OBJECT is not a list.

          (cdr-safe OBJECT)
          ???
          (let ((x OBJECT))
            (if (consp x)
                (cdr x)
              nil))

 -- Macro: pop listname
     This macro provides a convenient way to examine the CAR of a list,
     and take it off the list, all at once.  It operates on the list
     stored in LISTNAME.  It removes the first element from the list,
     saves the CDR into LISTNAME, then returns the removed element.

     In the simplest case, LISTNAME is an unquoted symbol naming a list;
     in that case, this macro is equivalent to
     '(prog1 (car listname) (setq listname (cdr listname)))'.

          x
               => (a b c)
          (pop x)
               => a
          x
               => (b c)

     More generally, LISTNAME can be a generalized variable.  In that
     case, this macro saves into LISTNAME using 'setf'.  *Note
     Generalized Variables::.

     For the 'push' macro, which adds an element to a list, *Note List
     Variables::.

 -- Function: nth n list
     This function returns the Nth element of LIST.  Elements are
     numbered starting with zero, so the CAR of LIST is element number
     zero.  If the length of LIST is N or less, the value is 'nil'.

          (nth 2 '(1 2 3 4))
               => 3
          (nth 10 '(1 2 3 4))
               => nil

          (nth n x) ??? (car (nthcdr n x))

     The function 'elt' is similar, but applies to any kind of sequence.
     For historical reasons, it takes its arguments in the opposite
     order.  *Note Sequence Functions::.

 -- Function: nthcdr n list
     This function returns the Nth CDR of LIST.  In other words, it
     skips past the first N links of LIST and returns what follows.

     If N is zero, 'nthcdr' returns all of LIST.  If the length of LIST
     is N or less, 'nthcdr' returns 'nil'.

          (nthcdr 1 '(1 2 3 4))
               => (2 3 4)
          (nthcdr 10 '(1 2 3 4))
               => nil
          (nthcdr 0 '(1 2 3 4))
               => (1 2 3 4)

 -- Function: last list &optional n
     This function returns the last link of LIST.  The 'car' of this
     link is the list's last element.  If LIST is null, 'nil' is
     returned.  If N is non-'nil', the Nth-to-last link is returned
     instead, or the whole of LIST if N is bigger than LIST's length.

 -- Function: safe-length list
     This function returns the length of LIST, with no risk of either an
     error or an infinite loop.  It generally returns the number of
     distinct cons cells in the list.  However, for circular lists, the
     value is just an upper bound; it is often too large.

     If LIST is not 'nil' or a cons cell, 'safe-length' returns 0.

   The most common way to compute the length of a list, when you are not
worried that it may be circular, is with 'length'.  *Note Sequence
Functions::.

 -- Function: caar cons-cell
     This is the same as '(car (car CONS-CELL))'.

 -- Function: cadr cons-cell
     This is the same as '(car (cdr CONS-CELL))' or '(nth 1 CONS-CELL)'.

 -- Function: cdar cons-cell
     This is the same as '(cdr (car CONS-CELL))'.

 -- Function: cddr cons-cell
     This is the same as '(cdr (cdr CONS-CELL))' or '(nthcdr 2
     CONS-CELL)'.

   In addition to the above, 24 additional compositions of 'car' and
'cdr' are defined as 'cXXXr' and 'cXXXXr', where each 'X' is either 'a'
or 'd'.  'cadr', 'caddr', and 'cadddr' pick out the second, third or
fourth elements of a list, respectively.  'cl-lib' provides the same
under the names 'cl-second', 'cl-third', and 'cl-fourth'.  *Note
(cl)List Functions::.

 -- Function: butlast x &optional n
     This function returns the list X with the last element, or the last
     N elements, removed.  If N is greater than zero it makes a copy of
     the list so as not to damage the original list.  In general,
     '(append (butlast X N) (last X N))' will return a list equal to X.

 -- Function: nbutlast x &optional n
     This is a version of 'butlast' that works by destructively
     modifying the 'cdr' of the appropriate element, rather than making
     a copy of the list.

==============================================================================
File: elisp.info,  Node: |Building_Lists|,  Next: |List_Variables|,  Prev: |List_Elements|,  Up: |Lists|
==============================================================================

                                                                *Building_Lists*

5.4 Building Cons Cells and Lists
---------------------------------

Many functions build lists, as lists reside at the very heart of Lisp.
'cons' is the fundamental list-building function; however, it is
interesting to note that 'list' is used more times in the source code
for Emacs than 'cons'.

 -- Function: cons object1 object2
     This function is the most basic function for building new list
     structure.  It creates a new cons cell, making OBJECT1 the CAR, and
     OBJECT2 the CDR.  It then returns the new cons cell.  The arguments
     OBJECT1 and OBJECT2 may be any Lisp objects, but most often OBJECT2
     is a list.

          (cons 1 '(2))
               => (1 2)
          (cons 1 '())
               => (1)
          (cons 1 2)
               => (1 . 2)

     'cons' is often used to add a single element to the front of a
     list.  This is called "consing the element onto the list".  (1) For
     example:

          (setq list (cons newelt list))

     Note that there is no conflict between the variable named 'list'
     used in this example and the function named 'list' described below;
     any symbol can serve both purposes.

 -- Function: list &rest objects
     This function creates a list with OBJECTS as its elements.  The
     resulting list is always 'nil'-terminated.  If no OBJECTS are
     given, the empty list is returned.

          (list 1 2 3 4 5)
               => (1 2 3 4 5)
          (list 1 2 '(3 4 5) 'foo)
               => (1 2 (3 4 5) foo)
          (list)
               => nil

 -- Function: make-list length object
     This function creates a list of LENGTH elements, in which each
     element is OBJECT.  Compare 'make-list' with 'make-string' (*note
     Creating Strings::).

          (make-list 3 'pigs)
               => (pigs pigs pigs)
          (make-list 0 'pigs)
               => nil
          (setq l (make-list 3 '(a b)))
               => ((a b) (a b) (a b))
          (eq (car l) (cadr l))
               => t

 -- Function: append &rest sequences
     This function returns a list containing all the elements of
     SEQUENCES.  The SEQUENCES may be lists, vectors, bool-vectors, or
     strings, but the last one should usually be a list.  All arguments
     except the last one are copied, so none of the arguments is
     altered.  (See 'nconc' in *note Rearrangement::, for a way to join
     lists with no copying.)

     More generally, the final argument to 'append' may be any Lisp
     object.  The final argument is not copied or converted; it becomes
     the CDR of the last cons cell in the new list.  If the final
     argument is itself a list, then its elements become in effect
     elements of the result list.  If the final element is not a list,
     the result is a dotted list since its final CDR is not 'nil' as
     required in a proper list (*note Cons Cells::).

   Here is an example of using 'append':

     (setq trees '(pine oak))
          => (pine oak)
     (setq more-trees (append '(maple birch) trees))
          => (maple birch pine oak)

     trees
          => (pine oak)
     more-trees
          => (maple birch pine oak)
     (eq trees (cdr (cdr more-trees)))
          => t

   You can see how 'append' works by looking at a box diagram.  The
variable 'trees' is set to the list '(pine oak)' and then the variable
'more-trees' is set to the list '(maple birch pine oak)'.  However, the
variable 'trees' continues to refer to the original list:

     more-trees                trees
     |                           |
     |     --- ---      --- ---   -> --- ---      --- ---
      --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil
           --- ---      --- ---      --- ---      --- ---
            |            |            |            |
            |            |            |            |
             --> maple    -->birch     --> pine     --> oak

   An empty sequence contributes nothing to the value returned by
'append'.  As a consequence of this, a final 'nil' argument forces a
copy of the previous argument:

     trees
          => (pine oak)
     (setq wood (append trees nil))
          => (pine oak)
     wood
          => (pine oak)
     (eq wood trees)
          => nil

This once was the usual way to copy a list, before the function
'copy-sequence' was invented.  *Note Sequences Arrays Vectors::.

   Here we show the use of vectors and strings as arguments to 'append':

     (append [a b] "cd" nil)
          => (a b 99 100)

   With the help of 'apply' (*note Calling Functions::), we can append
all the lists in a list of lists:

     (apply 'append '((a b c) nil (x y z) nil))
          => (a b c x y z)

   If no SEQUENCES are given, 'nil' is returned:

     (append)
          => nil

   Here are some examples where the final argument is not a list:

     (append '(x y) 'z)
          => (x y . z)
     (append '(x y) [z])
          => (x y . [z])

The second example shows that when the final argument is a sequence but
not a list, the sequence's elements do not become elements of the
resulting list.  Instead, the sequence becomes the final CDR, like any
other non-list final argument.

 -- Function: copy-tree tree &optional vecp
     This function returns a copy of the tree TREE.  If TREE is a cons
     cell, this makes a new cons cell with the same CAR and CDR, then
     recursively copies the CAR and CDR in the same way.

     Normally, when TREE is anything other than a cons cell, 'copy-tree'
     simply returns TREE.  However, if VECP is non-'nil', it copies
     vectors too (and operates recursively on their elements).

 -- Function: flatten-tree tree
     This function returns a "flattened" copy of TREE, that is, a list
     containing all the non-'nil' terminal nodes, or leaves, of the tree
     of cons cells rooted at TREE.  Leaves in the returned list are in
     the same order as in TREE.

     (flatten-tree '(1 (2 . 3) nil (4 5 (6)) 7))
         =>(1 2 3 4 5 6 7)

 -- Function: number-sequence from &optional to separation
     This function returns a list of numbers starting with FROM and
     incrementing by SEPARATION, and ending at or just before TO.
     SEPARATION can be positive or negative and defaults to 1.  If TO is
     'nil' or numerically equal to FROM, the value is the one-element
     list '(FROM)'.  If TO is less than FROM with a positive SEPARATION,
     or greater than FROM with a negative SEPARATION, the value is 'nil'
     because those arguments specify an empty sequence.

     If SEPARATION is 0 and TO is neither 'nil' nor numerically equal to
     FROM, 'number-sequence' signals an error, since those arguments
     specify an infinite sequence.

     All arguments are numbers.  Floating-point arguments can be tricky,
     because floating-point arithmetic is inexact.  For instance,
     depending on the machine, it may quite well happen that
     '(number-sequence 0.4 0.6 0.2)' returns the one element list
     '(0.4)', whereas '(number-sequence 0.4 0.8 0.2)' returns a list
     with three elements.  The Nth element of the list is computed by
     the exact formula '(+ FROM (* N SEPARATION))'.  Thus, if one wants
     to make sure that TO is included in the list, one can pass an
     expression of this exact type for TO.  Alternatively, one can
     replace TO with a slightly larger value (or a slightly more
     negative value if SEPARATION is negative).

     Some examples:

          (number-sequence 4 9)
               => (4 5 6 7 8 9)
          (number-sequence 9 4 -1)
               => (9 8 7 6 5 4)
          (number-sequence 9 4 -2)
               => (9 7 5)
          (number-sequence 8)
               => (8)
          (number-sequence 8 5)
               => nil
          (number-sequence 5 8 -1)
               => nil
          (number-sequence 1.5 6 2)
               => (1.5 3.5 5.5)

   ---------- Footnotes ----------

   (1) There is no strictly equivalent way to add an element to the end
of a list.  You can use '(append LISTNAME (list NEWELT))', which creates
a whole new list by copying LISTNAME and adding NEWELT to its end.  Or
you can use '(nconc LISTNAME (list NEWELT))', which modifies LISTNAME by
following all the CDRs and then replacing the terminating 'nil'.
Compare this to adding an element to the beginning of a list with
'cons', which neither copies nor modifies the list.

==============================================================================
File: elisp.info,  Node: |List_Variables|,  Next: |Modifying_Lists|,  Prev: |Building_Lists|,  Up: |Lists|
==============================================================================

                                                                *List_Variables*

5.5 Modifying List Variables
----------------------------

These functions, and one macro, provide convenient ways to modify a list
which is stored in a variable.

 -- Macro: push element listname
     This macro creates a new list whose CAR is ELEMENT and whose CDR is
     the list specified by LISTNAME, and saves that list in LISTNAME.
     In the simplest case, LISTNAME is an unquoted symbol naming a list,
     and this macro is equivalent to
     '(setq LISTNAME (cons ELEMENT LISTNAME))'.

          (setq l '(a b))
               => (a b)
          (push 'c l)
               => (c a b)
          l
               => (c a b)

     More generally, 'listname' can be a generalized variable.  In that
     case, this macro does the equivalent of
     '(setf LISTNAME (cons ELEMENT LISTNAME))'.  *Note Generalized
     Variables::.

     For the 'pop' macro, which removes the first element from a list,
     *Note List Elements::.

   Two functions modify lists that are the values of variables.

 -- Function: add-to-list symbol element &optional append compare-fn
     This function sets the variable SYMBOL by consing ELEMENT onto the
     old value, if ELEMENT is not already a member of that value.  It
     returns the resulting list, whether updated or not.  The value of
     SYMBOL had better be a list already before the call.  'add-to-list'
     uses COMPARE-FN to compare ELEMENT against existing list members;
     if COMPARE-FN is 'nil', it uses 'equal'.

     Normally, if ELEMENT is added, it is added to the front of SYMBOL,
     but if the optional argument APPEND is non-'nil', it is added at
     the end.

     The argument SYMBOL is not implicitly quoted; 'add-to-list' is an
     ordinary function, like 'set' and unlike 'setq'.  Quote the
     argument yourself if that is what you want.

     Do not use this function when SYMBOL refers to a lexical variable.

   Here's a scenario showing how to use 'add-to-list':

     (setq foo '(a b))
          => (a b)

     (add-to-list 'foo 'c)     ;; Add 'c'.
          => (c a b)

     (add-to-list 'foo 'b)     ;; No effect.
          => (c a b)

     foo                       ;; 'foo' was changed.
          => (c a b)

   An equivalent expression for '(add-to-list 'VAR VALUE)' is this:

     (if (member VALUE VAR)
         VAR
       (setq VAR (cons VALUE VAR)))

 -- Function: add-to-ordered-list symbol element &optional order
     This function sets the variable SYMBOL by inserting ELEMENT into
     the old value, which must be a list, at the position specified by
     ORDER.  If ELEMENT is already a member of the list, its position in
     the list is adjusted according to ORDER.  Membership is tested
     using 'eq'.  This function returns the resulting list, whether
     updated or not.

     The ORDER is typically a number (integer or float), and the
     elements of the list are sorted in non-decreasing numerical order.

     ORDER may also be omitted or 'nil'.  Then the numeric order of
     ELEMENT stays unchanged if it already has one; otherwise, ELEMENT
     has no numeric order.  Elements without a numeric list order are
     placed at the end of the list, in no particular order.

     Any other value for ORDER removes the numeric order of ELEMENT if
     it already has one; otherwise, it is equivalent to 'nil'.

     The argument SYMBOL is not implicitly quoted; 'add-to-ordered-list'
     is an ordinary function, like 'set' and unlike 'setq'.  Quote the
     argument yourself if necessary.

     The ordering information is stored in a hash table on SYMBOL's
     'list-order' property.  SYMBOL cannot refer to a lexical variable.

   Here's a scenario showing how to use 'add-to-ordered-list':

     (setq foo '())
          => nil

     (add-to-ordered-list 'foo 'a 1)     ;; Add 'a'.
          => (a)

     (add-to-ordered-list 'foo 'c 3)     ;; Add 'c'.
          => (a c)

     (add-to-ordered-list 'foo 'b 2)     ;; Add 'b'.
          => (a b c)

     (add-to-ordered-list 'foo 'b 4)     ;; Move 'b'.
          => (a c b)

     (add-to-ordered-list 'foo 'd)       ;; Append 'd'.
          => (a c b d)

     (add-to-ordered-list 'foo 'e)       ;; Add 'e'.
          => (a c b e d)

     foo                       ;; 'foo' was changed.
          => (a c b e d)

==============================================================================
File: elisp.info,  Node: |Modifying_Lists|,  Next: |Sets_And_Lists|,  Prev: |List_Variables|,  Up: |Lists|
==============================================================================

                                                               *Modifying_Lists*

5.6 Modifying Existing List Structure
-------------------------------------

You can modify the CAR and CDR contents of a cons cell with the
primitives 'setcar' and 'setcdr'.  These are destructive operations
because they change existing list structure.  Destructive operations
should be applied only to mutable lists, that is, lists constructed via
'cons', 'list' or similar operations.  Lists created by quoting are part
of the program and should not be changed by destructive operations.
*Note Mutability::.

     Common Lisp note: Common Lisp uses functions 'rplaca' and 'rplacd'
     to alter list structure; they change structure the same way as
     'setcar' and 'setcdr', but the Common Lisp functions return the
     cons cell while 'setcar' and 'setcdr' return the new CAR or CDR.

MENU

* |Setcar|::          Replacing an element in a list.
* |Setcdr|::          Replacing part of the list backbone.
                      This can be used to remove or add elements.
* |Rearrangement|::   Reordering the elements in a list; combining lists.

==============================================================================
File: elisp.info,  Node: |Setcar|,  Next: |Setcdr|,  Up: |Modifying_Lists|
==============================================================================

                                                                        *Setcar*

5.6.1 Altering List Elements with 'setcar'
------------------------------------------

Changing the CAR of a cons cell is done with 'setcar'.  When used on a
list, 'setcar' replaces one element of a list with a different element.

 -- Function: setcar cons object
     This function stores OBJECT as the new CAR of CONS, replacing its
     previous CAR.  In other words, it changes the CAR slot of CONS to
     refer to OBJECT.  It returns the value OBJECT.  For example:

          (setq x (list 1 2))
               => (1 2)
          (setcar x 4)
               => 4
          x
               => (4 2)

   When a cons cell is part of the shared structure of several lists,
storing a new CAR into the cons changes one element of each of these
lists.  Here is an example:

     ;; Create two lists that are partly shared.
     (setq x1 (list 'a 'b 'c))
          => (a b c)
     (setq x2 (cons 'z (cdr x1)))
          => (z b c)

     ;; Replace the CAR of a shared link.
     (setcar (cdr x1) 'foo)
          => foo
     x1                           ; Both lists are changed.
          => (a foo c)
     x2
          => (z foo c)

     ;; Replace the CAR of a link that is not shared.
     (setcar x1 'baz)
          => baz
     x1                           ; Only one list is changed.
          => (baz foo c)
     x2
          => (z foo c)

   Here is a graphical depiction of the shared structure of the two
lists in the variables 'x1' and 'x2', showing why replacing 'b' changes
them both:

             --- ---        --- ---      --- ---
     x1---> |   |   |----> |   |   |--> |   |   |--> nil
             --- ---        --- ---      --- ---
              |        -->   |            |
              |       |      |            |
               --> a  |       --> b        --> c
                      |
            --- ---   |
     x2--> |   |   |--
            --- ---
             |
             |
              --> z

   Here is an alternative form of box diagram, showing the same
relationship:

     x1:
      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   a   |   o------->|   b   |   o------->|   c   |  nil |
     |       |      |  -->|       |      |     |       |      |
      --------------  |    --------------       --------------
                      |
     x2:              |
      --------------  |
     | car   | cdr  | |
     |   z   |   o----
     |       |      |
      --------------

==============================================================================
File: elisp.info,  Node: |Setcdr|,  Next: |Rearrangement|,  Prev: |Setcar|,  Up: |Modifying_Lists|
==============================================================================

                                                                        *Setcdr*

5.6.2 Altering the CDR of a List
--------------------------------

The lowest-level primitive for modifying a CDR is 'setcdr':

 -- Function: setcdr cons object
     This function stores OBJECT as the new CDR of CONS, replacing its
     previous CDR.  In other words, it changes the CDR slot of CONS to
     refer to OBJECT.  It returns the value OBJECT.

   Here is an example of replacing the CDR of a list with a different
list.  All but the first element of the list are removed in favor of a
different sequence of elements.  The first element is unchanged, because
it resides in the CAR of the list, and is not reached via the CDR.

     (setq x (list 1 2 3))
          => (1 2 3)
     (setcdr x '(4))
          => (4)
     x
          => (1 4)

   You can delete elements from the middle of a list by altering the
CDRs of the cons cells in the list.  For example, here we delete the
second element, 'b', from the list '(a b c)', by changing the CDR of the
first cons cell:

     (setq x1 (list 'a 'b 'c))
          => (a b c)
     (setcdr x1 (cdr (cdr x1)))
          => (c)
     x1
          => (a c)

   Here is the result in box notation:

                        --------------------
                       |                    |
      --------------   |   --------------   |    --------------
     | car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
     |   a   |   o-----   |   b   |   o-------->|   c   |  nil |
     |       |      |     |       |      |      |       |      |
      --------------       --------------        --------------

The second cons cell, which previously held the element 'b', still
exists and its CAR is still 'b', but it no longer forms part of this
list.

   It is equally easy to insert a new element by changing CDRs:

     (setq x1 (list 'a 'b 'c))
          => (a b c)
     (setcdr x1 (cons 'd (cdr x1)))
          => (d b c)
     x1
          => (a d b c)

   Here is this result in box notation:

      --------------        -------------       -------------
     | car  | cdr   |      | car  | cdr  |     | car  | cdr  |
     |   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
     |      |   |   |  |   |      |      |     |      |      |
      --------- | --   |    -------------       -------------
                |      |
          -----         --------
         |                      |
         |    ---------------   |
         |   | car   | cdr   |  |
          -->|   d   |   o------
             |       |       |
              ---------------

==============================================================================
File: elisp.info,  Node: |Rearrangement|,  Prev: |Setcdr|,  Up: |Modifying_Lists|
==============================================================================

                                                                 *Rearrangement*

5.6.3 Functions that Rearrange Lists
------------------------------------

Here are some functions that rearrange lists destructively by modifying
the CDRs of their component cons cells.  These functions are destructive
because they chew up the original lists passed to them as arguments,
relinking their cons cells to form a new list that is the returned
value.

   See 'delq', in *note Sets And Lists::, for another function that
modifies cons cells.

 -- Function: nconc &rest lists
     This function returns a list containing all the elements of LISTS.
     Unlike 'append' (*note Building Lists::), the LISTS are _not_
     copied.  Instead, the last CDR of each of the LISTS is changed to
     refer to the following list.  The last of the LISTS is not altered.
     For example:

          (setq x (list 1 2 3))
               => (1 2 3)
          (nconc x '(4 5))
               => (1 2 3 4 5)
          x
               => (1 2 3 4 5)

     Since the last argument of 'nconc' is not itself modified, it is
     reasonable to use a constant list, such as ''(4 5)', as in the
     above example.  For the same reason, the last argument need not be
     a list:

          (setq x (list 1 2 3))
               => (1 2 3)
          (nconc x 'z)
               => (1 2 3 . z)
          x
               => (1 2 3 . z)

     However, the other arguments (all but the last) should be mutable
     lists.

     A common pitfall is to use a constant list as a non-last argument
     to 'nconc'.  If you do this, the resulting behavior is undefined.
     It is possible that your program will change each time you run it!
     Here is what might happen (though this is not guaranteed to
     happen):

          (defun add-foo (x)            ; We want this function to add
            (nconc '(foo) x))           ;   'foo' to the front of its arg.

          (symbol-function 'add-foo)
               => (lambda (x) (nconc '(foo) x))

          (setq xx (add-foo '(1 2)))    ; It seems to work.
               => (foo 1 2)
          (setq xy (add-foo '(3 4)))    ; What happened?
               => (foo 1 2 3 4)
          (eq xx xy)
               => t

          (symbol-function 'add-foo)
               => (lambda (x) (nconc '(foo 1 2 3 4) x))

==============================================================================
File: elisp.info,  Node: |Sets_And_Lists|,  Next: |Association_Lists|,  Prev: |Modifying_Lists|,  Up: |Lists|
==============================================================================

                                                                *Sets_And_Lists*

5.7 Using Lists as Sets
-----------------------

A list can represent an unordered mathematical set--simply consider a
value an element of a set if it appears in the list, and ignore the
order of the list.  To form the union of two sets, use 'append' (as long
as you don't mind having duplicate elements).  You can remove 'equal'
duplicates using 'delete-dups'.  Other useful functions for sets include
'memq' and 'delq', and their 'equal' versions, 'member' and 'delete'.

     Common Lisp note: Common Lisp has functions 'union' (which avoids
     duplicate elements) and 'intersection' for set operations.  In
     Emacs Lisp, variants of these facilities are provided by the
     'cl-lib' library.  *Note (cl)Lists as Sets::.

 -- Function: memq object list
     This function tests to see whether OBJECT is a member of LIST.  If
     it is, 'memq' returns a list starting with the first occurrence of
     OBJECT.  Otherwise, it returns 'nil'.  The letter 'q' in 'memq'
     says that it uses 'eq' to compare OBJECT against the elements of
     the list.  For example:

          (memq 'b '(a b c b a))
               => (b c b a)
          (memq '(2) '((1) (2)))    ; The two '(2)'s need not be 'eq'.
               => Unspecified; might be 'nil' or '((2))'.

 -- Function: delq object list
     This function destructively removes all elements 'eq' to OBJECT
     from LIST, and returns the resulting list.  The letter 'q' in
     'delq' says that it uses 'eq' to compare OBJECT against the
     elements of the list, like 'memq' and 'remq'.

     Typically, when you invoke 'delq', you should use the return value
     by assigning it to the variable which held the original list.  The
     reason for this is explained below.

   The 'delq' function deletes elements from the front of the list by
simply advancing down the list, and returning a sublist that starts
after those elements.  For example:

     (delq 'a '(a b c)) ??? (cdr '(a b c))

When an element to be deleted appears in the middle of the list,
removing it involves changing the CDRs (*note Setcdr::).

     (setq sample-list (list 'a 'b 'c '(4)))
          => (a b c (4))
     (delq 'a sample-list)
          => (b c (4))
     sample-list
          => (a b c (4))
     (delq 'c sample-list)
          => (a b (4))
     sample-list
          => (a b (4))

   Note that '(delq 'c sample-list)' modifies 'sample-list' to splice
out the third element, but '(delq 'a sample-list)' does not splice
anything--it just returns a shorter list.  Don't assume that a variable
which formerly held the argument LIST now has fewer elements, or that it
still holds the original list!  Instead, save the result of 'delq' and
use that.  Most often we store the result back into the variable that
held the original list:

     (setq flowers (delq 'rose flowers))

   In the following example, the '(list 4)' that 'delq' attempts to
match and the '(4)' in the 'sample-list' are 'equal' but not 'eq':

     (delq (list 4) sample-list)
          => (a c (4))

   If you want to delete elements that are 'equal' to a given value, use
'delete' (see below).

 -- Function: remq object list
     This function returns a copy of LIST, with all elements removed
     which are 'eq' to OBJECT.  The letter 'q' in 'remq' says that it
     uses 'eq' to compare OBJECT against the elements of 'list'.

          (setq sample-list (list 'a 'b 'c 'a 'b 'c))
               => (a b c a b c)
          (remq 'a sample-list)
               => (b c b c)
          sample-list
               => (a b c a b c)

 -- Function: memql object list
     The function 'memql' tests to see whether OBJECT is a member of
     LIST, comparing members with OBJECT using 'eql', so floating-point
     elements are compared by value.  If OBJECT is a member, 'memql'
     returns a list starting with its first occurrence in LIST.
     Otherwise, it returns 'nil'.

     Compare this with 'memq':

          (memql 1.2 '(1.1 1.2 1.3))  ; '1.2' and '1.2' are 'eql'.
               => (1.2 1.3)
          (memq 1.2 '(1.1 1.2 1.3))  ; The two '1.2's need not be 'eq'.
               => Unspecified; might be 'nil' or '(1.2 1.3)'.

   The following three functions are like 'memq', 'delq' and 'remq', but
use 'equal' rather than 'eq' to compare elements.  *Note Equality
Predicates::.

 -- Function: member object list
     The function 'member' tests to see whether OBJECT is a member of
     LIST, comparing members with OBJECT using 'equal'.  If OBJECT is a
     member, 'member' returns a list starting with its first occurrence
     in LIST.  Otherwise, it returns 'nil'.

     Compare this with 'memq':

          (member '(2) '((1) (2)))  ; '(2)' and '(2)' are 'equal'.
               => ((2))
          (memq '(2) '((1) (2)))    ; The two '(2)'s need not be 'eq'.
               => Unspecified; might be 'nil' or '(2)'.
          ;; Two strings with the same contents are 'equal'.
          (member "foo" '("foo" "bar"))
               => ("foo" "bar")

 -- Function: delete object sequence
     This function removes all elements 'equal' to OBJECT from SEQUENCE,
     and returns the resulting sequence.

     If SEQUENCE is a list, 'delete' is to 'delq' as 'member' is to
     'memq': it uses 'equal' to compare elements with OBJECT, like
     'member'; when it finds an element that matches, it cuts the
     element out just as 'delq' would.  As with 'delq', you should
     typically use the return value by assigning it to the variable
     which held the original list.

     If 'sequence' is a vector or string, 'delete' returns a copy of
     'sequence' with all elements 'equal' to 'object' removed.

     For example:

          (setq l (list '(2) '(1) '(2)))
          (delete '(2) l)
               => ((1))
          l
               => ((2) (1))
          ;; If you want to change 'l' reliably,
          ;; write '(setq l (delete '(2) l))'.
          (setq l (list '(2) '(1) '(2)))
          (delete '(1) l)
               => ((2) (2))
          l
               => ((2) (2))
          ;; In this case, it makes no difference whether you set 'l',
          ;; but you should do so for the sake of the other case.
          (delete '(2) [(2) (1) (2)])
               => [(1)]

 -- Function: remove object sequence
     This function is the non-destructive counterpart of 'delete'.  It
     returns a copy of 'sequence', a list, vector, or string, with
     elements 'equal' to 'object' removed.  For example:

          (remove '(2) '((2) (1) (2)))
               => ((1))
          (remove '(2) [(2) (1) (2)])
               => [(1)]

     Common Lisp note: The functions 'member', 'delete' and 'remove' in
     GNU Emacs Lisp are derived from Maclisp, not Common Lisp.  The
     Common Lisp versions do not use 'equal' to compare elements.

 -- Function: member-ignore-case object list
     This function is like 'member', except that OBJECT should be a
     string and that it ignores differences in letter-case and text
     representation: upper-case and lower-case letters are treated as
     equal, and unibyte strings are converted to multibyte prior to
     comparison.

 -- Function: delete-dups list
     This function destructively removes all 'equal' duplicates from
     LIST, stores the result in LIST and returns it.  Of several 'equal'
     occurrences of an element in LIST, 'delete-dups' keeps the first
     one.

   See also the function 'add-to-list', in *note List Variables::, for a
way to add an element to a list stored in a variable and used as a set.

==============================================================================
File: elisp.info,  Node: |Association_Lists|,  Next: |Property_Lists|,  Prev: |Sets_And_Lists|,  Up: |Lists|
==============================================================================

                                                             *Association_Lists*

5.8 Association Lists
---------------------

An "association list", or "alist" for short, records a mapping from keys
to values.  It is a list of cons cells called "associations": the CAR of
each cons cell is the "key", and the CDR is the "associated value".(1)

   Here is an example of an alist.  The key 'pine' is associated with
the value 'cones'; the key 'oak' is associated with 'acorns'; and the
key 'maple' is associated with 'seeds'.

     ((pine . cones)
      (oak . acorns)
      (maple . seeds))

   Both the values and the keys in an alist may be any Lisp objects.
For example, in the following alist, the symbol 'a' is associated with
the number '1', and the string '"b"' is associated with the _list_ '(2
3)', which is the CDR of the alist element:

     ((a . 1) ("b" 2 3))

   Sometimes it is better to design an alist to store the associated
value in the CAR of the CDR of the element.  Here is an example of such
an alist:

     ((rose red) (lily white) (buttercup yellow))

Here we regard 'red' as the value associated with 'rose'.  One advantage
of this kind of alist is that you can store other related
information--even a list of other items--in the CDR of the CDR.  One
disadvantage is that you cannot use 'rassq' (see below) to find the
element containing a given value.  When neither of these considerations
is important, the choice is a matter of taste, as long as you are
consistent about it for any given alist.

   The same alist shown above could be regarded as having the associated
value in the CDR of the element; the value associated with 'rose' would
be the list '(red)'.

   Association lists are often used to record information that you might
otherwise keep on a stack, since new associations may be added easily to
the front of the list.  When searching an association list for an
association with a given key, the first one found is returned, if there
is more than one.

   In Emacs Lisp, it is _not_ an error if an element of an association
list is not a cons cell.  The alist search functions simply ignore such
elements.  Many other versions of Lisp signal errors in such cases.

   Note that property lists are similar to association lists in several
respects.  A property list behaves like an association list in which
each key can occur only once.  *Note Property Lists::, for a comparison
of property lists and association lists.

 -- Function: assoc key alist &optional testfn
     This function returns the first association for KEY in ALIST,
     comparing KEY against the alist elements using TESTFN if it is
     non-'nil' and 'equal' otherwise (*note Equality Predicates::).  It
     returns 'nil' if no association in ALIST has a CAR equal to KEY.
     For example:

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               => ((pine . cones) (oak . acorns) (maple . seeds))
          (assoc 'oak trees)
               => (oak . acorns)
          (cdr (assoc 'oak trees))
               => acorns
          (assoc 'birch trees)
               => nil

     Here is another example, in which the keys and values are not
     symbols:

          (setq needles-per-cluster
                '((2 "Austrian Pine" "Red Pine")
                  (3 "Pitch Pine")
                  (5 "White Pine")))

          (cdr (assoc 3 needles-per-cluster))
               => ("Pitch Pine")
          (cdr (assoc 2 needles-per-cluster))
               => ("Austrian Pine" "Red Pine")

   The function 'assoc-string' is much like 'assoc' except that it
ignores certain differences between strings.  *Note Text Comparison::.

 -- Function: rassoc value alist
     This function returns the first association with value VALUE in
     ALIST.  It returns 'nil' if no association in ALIST has a CDR
     'equal' to VALUE.

     'rassoc' is like 'assoc' except that it compares the CDR of each
     ALIST association instead of the CAR.  You can think of this as
     reverse 'assoc', finding the key for a given value.

 -- Function: assq key alist
     This function is like 'assoc' in that it returns the first
     association for KEY in ALIST, but it makes the comparison using
     'eq'.  'assq' returns 'nil' if no association in ALIST has a CAR
     'eq' to KEY.  This function is used more often than 'assoc', since
     'eq' is faster than 'equal' and most alists use symbols as keys.
     *Note Equality Predicates::.

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               => ((pine . cones) (oak . acorns) (maple . seeds))
          (assq 'pine trees)
               => (pine . cones)

     On the other hand, 'assq' is not usually useful in alists where the
     keys may not be symbols:

          (setq leaves
                '(("simple leaves" . oak)
                  ("compound leaves" . horsechestnut)))

          (assq "simple leaves" leaves)
               => Unspecified; might be 'nil' or '("simple leaves" . oak)'.
          (assoc "simple leaves" leaves)
               => ("simple leaves" . oak)

 -- Function: alist-get key alist &optional default remove testfn
     This function is similar to 'assq'.  It finds the first association
     '(KEY . VALUE)' by comparing KEY with ALIST elements, and, if
     found, returns the VALUE of that association.  If no association is
     found, the function returns DEFAULT.  Comparison of KEY against
     ALIST elements uses the function specified by TESTFN, defaulting to
     'eq'.

     This is a generalized variable (*note Generalized Variables::) that
     can be used to change a value with 'setf'.  When using it to set a
     value, optional argument REMOVE non-'nil' means to remove KEY's
     association from ALIST if the new value is 'eql' to DEFAULT.

 -- Function: rassq value alist
     This function returns the first association with value VALUE in
     ALIST.  It returns 'nil' if no association in ALIST has a CDR 'eq'
     to VALUE.

     'rassq' is like 'assq' except that it compares the CDR of each
     ALIST association instead of the CAR.  You can think of this as
     reverse 'assq', finding the key for a given value.

     For example:

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

          (rassq 'acorns trees)
               => (oak . acorns)
          (rassq 'spores trees)
               => nil

     'rassq' cannot search for a value stored in the CAR of the CDR of
     an element:

          (setq colors '((rose red) (lily white) (buttercup yellow)))

          (rassq 'white colors)
               => nil

     In this case, the CDR of the association '(lily white)' is not the
     symbol 'white', but rather the list '(white)'.  This becomes
     clearer if the association is written in dotted pair notation:

          (lily white) ??? (lily . (white))

 -- Function: assoc-default key alist &optional test default
     This function searches ALIST for a match for KEY.  For each element
     of ALIST, it compares the element (if it is an atom) or the
     element's CAR (if it is a cons) against KEY, by calling TEST with
     two arguments: the element or its CAR, and KEY.  The arguments are
     passed in that order so that you can get useful results using
     'string-match' with an alist that contains regular expressions
     (*note Regexp Search::).  If TEST is omitted or 'nil', 'equal' is
     used for comparison.

     If an alist element matches KEY by this criterion, then
     'assoc-default' returns a value based on this element.  If the
     element is a cons, then the value is the element's CDR.  Otherwise,
     the return value is DEFAULT.

     If no alist element matches KEY, 'assoc-default' returns 'nil'.

 -- Function: copy-alist alist
     This function returns a two-level deep copy of ALIST: it creates a
     new copy of each association, so that you can alter the
     associations of the new alist without changing the old one.

          (setq needles-per-cluster
                '((2 . ("Austrian Pine" "Red Pine"))
                  (3 . ("Pitch Pine"))
                  (5 . ("White Pine"))))
          =>
          ((2 "Austrian Pine" "Red Pine")
           (3 "Pitch Pine")
           (5 "White Pine"))

          (setq copy (copy-alist needles-per-cluster))
          =>
          ((2 "Austrian Pine" "Red Pine")
           (3 "Pitch Pine")
           (5 "White Pine"))

          (eq needles-per-cluster copy)
               => nil
          (equal needles-per-cluster copy)
               => t
          (eq (car needles-per-cluster) (car copy))
               => nil
          (cdr (car (cdr needles-per-cluster)))
               => ("Pitch Pine")
          (eq (cdr (car (cdr needles-per-cluster)))
              (cdr (car (cdr copy))))
               => t

     This example shows how 'copy-alist' makes it possible to change the
     associations of one copy without affecting the other:

          (setcdr (assq 3 copy) '("Martian Vacuum Pine"))
          (cdr (assq 3 needles-per-cluster))
               => ("Pitch Pine")

 -- Function: assq-delete-all key alist
     This function deletes from ALIST all the elements whose CAR is 'eq'
     to KEY, much as if you used 'delq' to delete each such element one
     by one.  It returns the shortened alist, and often modifies the
     original list structure of ALIST.  For correct results, use the
     return value of 'assq-delete-all' rather than looking at the saved
     value of ALIST.

          (setq alist (list '(foo 1) '(bar 2) '(foo 3) '(lose 4)))
               => ((foo 1) (bar 2) (foo 3) (lose 4))
          (assq-delete-all 'foo alist)
               => ((bar 2) (lose 4))
          alist
               => ((foo 1) (bar 2) (lose 4))

 -- Function: assoc-delete-all key alist &optional test
     This function is like 'assq-delete-all' except that it accepts an
     optional argument TEST, a predicate function to compare the keys in
     ALIST.  If omitted or 'nil', TEST defaults to 'equal'.  As
     'assq-delete-all', this function often modifies the original list
     structure of ALIST.

 -- Function: rassq-delete-all value alist
     This function deletes from ALIST all the elements whose CDR is 'eq'
     to VALUE.  It returns the shortened alist, and often modifies the
     original list structure of ALIST.  'rassq-delete-all' is like
     'assq-delete-all' except that it compares the CDR of each ALIST
     association instead of the CAR.

 -- Macro: let-alist alist body
     Creates a binding for each symbol used as keys the association list
     ALIST, prefixed with dot.  This can be useful when accessing
     several items in the same association list, and it's best
     understood through a simple example:

          (setq colors '((rose . red) (lily . white) (buttercup . yellow)))
          (let-alist colors
            (if (eq .rose 'red)
                .lily))
          => white

     The BODY is inspected at compilation time, and only the symbols
     that appear in BODY with a '.' as the first character in the symbol
     name will be bound.  Finding the keys is done with 'assq', and the
     'cdr' of the return value of this 'assq' is assigned as the value
     for the binding.

     Nested association lists is supported:

          (setq colors '((rose . red) (lily (belladonna . yellow) (brindisi . pink))))
          (let-alist colors
            (if (eq .rose 'red)
                .lily.belladonna))
          => yellow

     Nesting 'let-alist' inside each other is allowed, but the code in
     the inner 'let-alist' can't access the variables bound by the outer
     'let-alist'.

   ---------- Footnotes ----------

   (1) This usage of "key" is not related to the term "key sequence"; it
means a value used to look up an item in a table.  In this case, the
table is the alist, and the alist associations are the items.

==============================================================================
File: elisp.info,  Node: |Property_Lists|,  Prev: |Association_Lists|,  Up: |Lists|
==============================================================================

                                                                *Property_Lists*

5.9 Property Lists
------------------

A "property list" ("plist" for short) is a list of paired elements.
Each of the pairs associates a property name (usually a symbol) with a
property or value.  Here is an example of a property list:

     (pine cones numbers (1 2 3) color "blue")

This property list associates 'pine' with 'cones', 'numbers' with '(1 2
3)', and 'color' with '"blue"'.  The property names and values can be
any Lisp objects, but the names are usually symbols (as they are in this
example).

   Property lists are used in several contexts.  For instance, the
function 'put-text-property' takes an argument which is a property list,
specifying text properties and associated values which are to be applied
to text in a string or buffer.  *Note Text Properties::.

   Another prominent use of property lists is for storing symbol
properties.  Every symbol possesses a list of properties, used to record
miscellaneous information about the symbol; these properties are stored
in the form of a property list.  *Note Symbol Properties::.

MENU

* |Plists_and_Alists|::           Comparison of the advantages of property
                                  lists and association lists.
* |Plist_Access|::                Accessing property lists stored elsewhere.

==============================================================================
File: elisp.info,  Node: |Plists_and_Alists|,  Next: |Plist_Access|,  Up: |Property_Lists|
==============================================================================

                                                             *Plists_and_Alists*

5.9.1 Property Lists and Association Lists
------------------------------------------

Association lists (*note Association Lists::) are very similar to
property lists.  In contrast to association lists, the order of the
pairs in the property list is not significant, since the property names
must be distinct.

   Property lists are better than association lists for attaching
information to various Lisp function names or variables.  If your
program keeps all such information in one association list, it will
typically need to search that entire list each time it checks for an
association for a particular Lisp function name or variable, which could
be slow.  By contrast, if you keep the same information in the property
lists of the function names or variables themselves, each search will
scan only the length of one property list, which is usually short.  This
is why the documentation for a variable is recorded in a property named
'variable-documentation'.  The byte compiler likewise uses properties to
record those functions needing special treatment.

   However, association lists have their own advantages.  Depending on
your application, it may be faster to add an association to the front of
an association list than to update a property.  All properties for a
symbol are stored in the same property list, so there is a possibility
of a conflict between different uses of a property name.  (For this
reason, it is a good idea to choose property names that are probably
unique, such as by beginning the property name with the program's usual
name-prefix for variables and functions.)  An association list may be
used like a stack where associations are pushed on the front of the list
and later discarded; this is not possible with a property list.

==============================================================================
File: elisp.info,  Node: |Plist_Access|,  Prev: |Plists_and_Alists|,  Up: |Property_Lists|
==============================================================================

                                                                  *Plist_Access*

5.9.2 Property Lists Outside Symbols
------------------------------------

The following functions can be used to manipulate property lists.  They
all compare property names using 'eq'.

 -- Function: plist-get plist property
     This returns the value of the PROPERTY property stored in the
     property list PLIST.  It accepts a malformed PLIST argument.  If
     PROPERTY is not found in the PLIST, it returns 'nil'.  For example,

          (plist-get '(foo 4) 'foo)
               => 4
          (plist-get '(foo 4 bad) 'foo)
               => 4
          (plist-get '(foo 4 bad) 'bad)
               => nil
          (plist-get '(foo 4 bad) 'bar)
               => nil

 -- Function: plist-put plist property value
     This stores VALUE as the value of the PROPERTY property in the
     property list PLIST.  It may modify PLIST destructively, or it may
     construct a new list structure without altering the old.  The
     function returns the modified property list, so you can store that
     back in the place where you got PLIST.  For example,

          (setq my-plist (list 'bar t 'foo 4))
               => (bar t foo 4)
          (setq my-plist (plist-put my-plist 'foo 69))
               => (bar t foo 69)
          (setq my-plist (plist-put my-plist 'quux '(a)))
               => (bar t foo 69 quux (a))

 -- Function: lax-plist-get plist property
     Like 'plist-get' except that it compares properties using 'equal'
     instead of 'eq'.

 -- Function: lax-plist-put plist property value
     Like 'plist-put' except that it compares properties using 'equal'
     instead of 'eq'.

 -- Function: plist-member plist property
     This returns non-'nil' if PLIST contains the given PROPERTY.
     Unlike 'plist-get', this allows you to distinguish between a
     missing property and a property with the value 'nil'.  The value is
     actually the tail of PLIST whose 'car' is PROPERTY.

==============================================================================
File: elisp.info,  Node: |Sequences_Arrays_Vectors|,  Next: |Records|,  Prev: |Lists|,  Up: |Top|
==============================================================================

                                                      *Sequences_Arrays_Vectors*

6 Sequences, Arrays, and Vectors
================================

The "sequence" type is the union of two other Lisp types: lists and
arrays.  In other words, any list is a sequence, and any array is a
sequence.  The common property that all sequences have is that each is
an ordered collection of elements.

   An "array" is a fixed-length object with a slot for each of its
elements.  All the elements are accessible in constant time.  The four
types of arrays are strings, vectors, char-tables and bool-vectors.

   A list is a sequence of elements, but it is not a single primitive
object; it is made of cons cells, one cell per element.  Finding the Nth
element requires looking through N cons cells, so elements farther from
the beginning of the list take longer to access.  But it is possible to
add elements to the list, or remove elements.

   The following diagram shows the relationship between these types:

               _____________________________________________
              |                                             |
              |          Sequence                           |
              |  ______   ________________________________  |
              | |      | |                                | |
              | | List | |             Array              | |
              | |      | |    ________       ________     | |
              | |______| |   |        |     |        |    | |
              |          |   | Vector |     | String |    | |
              |          |   |________|     |________|    | |
              |          |  ____________   _____________  | |
              |          | |            | |             | | |
              |          | | Char-table | | Bool-vector | | |
              |          | |____________| |_____________| | |
              |          |________________________________| |
              |_____________________________________________|

MENU

* |Sequence_Functions|::    Functions that accept any kind of sequence.
* |Arrays|::                Characteristics of arrays in Emacs Lisp.
* |Array_Functions|::       Functions specifically for arrays.
* |Vectors|::               Special characteristics of Emacs Lisp vectors.
* |Vector_Functions|::      Functions specifically for vectors.
* |Char_Tables|::           How to work with char-tables.
* |Bool_Vectors|::          How to work with bool-vectors.
* |Rings|::                 Managing a fixed-size ring of objects.

==============================================================================
File: elisp.info,  Node: |Sequence_Functions|,  Next: |Arrays|,  Up: |Sequences_Arrays_Vectors|
==============================================================================

                                                            *Sequence_Functions*

6.1 Sequences
-------------

This section describes functions that accept any kind of sequence.

 -- Function: sequencep object
     This function returns 't' if OBJECT is a list, vector, string,
     bool-vector, or char-table, 'nil' otherwise.  See also 'seqp'
     below.

 -- Function: length sequence
     This function returns the number of elements in SEQUENCE.  The
     function signals the 'wrong-type-argument' error if the argument is
     not a sequence or is a dotted list; it signals the 'circular-list'
     error if the argument is a circular list.  For a char-table, the
     value returned is always one more than the maximum Emacs character
     code.

     *Note Definition of safe-length::, for the related function
     'safe-length'.

          (length '(1 2 3))
              => 3
          (length ())
              => 0
          (length "foobar")
              => 6
          (length [1 2 3])
              => 3
          (length (make-bool-vector 5 nil))
              => 5

See also 'string-bytes', in *note Text Representations::.

   If you need to compute the width of a string on display, you should
use 'string-width' (*note Size of Displayed Text::), not 'length', since
'length' only counts the number of characters, but does not account for
the display width of each character.

 -- Function: elt sequence index
     This function returns the element of SEQUENCE indexed by INDEX.
     Legitimate values of INDEX are integers ranging from 0 up to one
     less than the length of SEQUENCE.  If SEQUENCE is a list,
     out-of-range values behave as for 'nth'.  *Note Definition of
     nth::.  Otherwise, out-of-range values trigger an
     'args-out-of-range' error.

          (elt [1 2 3 4] 2)
               => 3
          (elt '(1 2 3 4) 2)
               => 3
          ;; We use 'string' to show clearly which character 'elt' returns.
          (string (elt "1234" 2))
               => "3"
          (elt [1 2 3 4] 4)
               error-> Args out of range: [1 2 3 4], 4
          (elt [1 2 3 4] -1)
               error-> Args out of range: [1 2 3 4], -1

     This function generalizes 'aref' (*note Array Functions::) and
     'nth' (*note Definition of nth::).

 -- Function: copy-sequence seqr
     This function returns a copy of SEQR, which should be either a
     sequence or a record.  The copy is the same type of object as the
     original, and it has the same elements in the same order.  However,
     if SEQR is empty, like a string or a vector of zero length, the
     value returned by this function might not be a copy, but an empty
     object of the same type and identical to SEQR.

     Storing a new element into the copy does not affect the original
     SEQR, and vice versa.  However, the elements of the copy are not
     copies; they are identical ('eq') to the elements of the original.
     Therefore, changes made within these elements, as found via the
     copy, are also visible in the original.

     If the argument is a string with text properties, the property list
     in the copy is itself a copy, not shared with the original's
     property list.  However, the actual values of the properties are
     shared.  *Note Text Properties::.

     This function does not work for dotted lists.  Trying to copy a
     circular list may cause an infinite loop.

     See also 'append' in *note Building Lists::, 'concat' in *note
     Creating Strings::, and 'vconcat' in *note Vector Functions::, for
     other ways to copy sequences.

          (setq bar (list 1 2))
               => (1 2)
          (setq x (vector 'foo bar))
               => [foo (1 2)]
          (setq y (copy-sequence x))
               => [foo (1 2)]

          (eq x y)
               => nil
          (equal x y)
               => t
          (eq (elt x 1) (elt y 1))
               => t

          ;; Replacing an element of one sequence.
          (aset x 0 'quux)
          x => [quux (1 2)]
          y => [foo (1 2)]

          ;; Modifying the inside of a shared element.
          (setcar (aref x 1) 69)
          x => [quux (69 2)]
          y => [foo (69 2)]

 -- Function: reverse sequence
     This function creates a new sequence whose elements are the
     elements of SEQUENCE, but in reverse order.  The original argument
     SEQUENCE is _not_ altered.  Note that char-tables cannot be
     reversed.

          (setq x '(1 2 3 4))
               => (1 2 3 4)
          (reverse x)
               => (4 3 2 1)
          x
               => (1 2 3 4)
          (setq x [1 2 3 4])
               => [1 2 3 4]
          (reverse x)
               => [4 3 2 1]
          x
               => [1 2 3 4]
          (setq x "xyzzy")
               => "xyzzy"
          (reverse x)
               => "yzzyx"
          x
               => "xyzzy"

 -- Function: nreverse sequence
     This function reverses the order of the elements of SEQUENCE.
     Unlike 'reverse' the original SEQUENCE may be modified.

     For example:

          (setq x (list 'a 'b 'c))
               => (a b c)
          x
               => (a b c)
          (nreverse x)
               => (c b a)
          ;; The cons cell that was first is now last.
          x
               => (a)

     To avoid confusion, we usually store the result of 'nreverse' back
     in the same variable which held the original list:

          (setq x (nreverse x))

     Here is the 'nreverse' of our favorite example, '(a b c)',
     presented graphically:

          Original list head:                       Reversed list:
           -------------        -------------        ------------
          | car  | cdr  |      | car  | cdr  |      | car | cdr  |
          |   a  |  nil |<--   |   b  |   o  |<--   |   c |   o  |
          |      |      |   |  |      |   |  |   |  |     |   |  |
           -------------    |   --------- | -    |   -------- | -
                            |             |      |            |
                             -------------        ------------

     For the vector, it is even simpler because you don't need setq:

          (setq x (copy-sequence [1 2 3 4]))
               => [1 2 3 4]
          (nreverse x)
               => [4 3 2 1]
          x
               => [4 3 2 1]

     Note that unlike 'reverse', this function doesn't work with
     strings.  Although you can alter string data by using 'aset', it is
     strongly encouraged to treat strings as immutable even when they
     are mutable.  *Note Mutability::.

 -- Function: sort sequence predicate
     This function sorts SEQUENCE stably.  Note that this function
     doesn't work for all sequences; it may be used only for lists and
     vectors.  If SEQUENCE is a list, it is modified destructively.
     This functions returns the sorted SEQUENCE and compares elements
     using PREDICATE.  A stable sort is one in which elements with equal
     sort keys maintain their relative order before and after the sort.
     Stability is important when successive sorts are used to order
     elements according to different criteria.

     The argument PREDICATE must be a function that accepts two
     arguments.  It is called with two elements of SEQUENCE.  To get an
     increasing order sort, the PREDICATE should return non-'nil' if the
     first element is "less" than the second, or 'nil' if not.

     The comparison function PREDICATE must give reliable results for
     any given pair of arguments, at least within a single call to
     'sort'.  It must be "antisymmetric"; that is, if A is less than B,
     B must not be less than A.  It must be "transitive"--that is, if A
     is less than B, and B is less than C, then A must be less than C.
     If you use a comparison function which does not meet these
     requirements, the result of 'sort' is unpredictable.

     The destructive aspect of 'sort' for lists is that it rearranges
     the cons cells forming SEQUENCE by changing CDRs.  A nondestructive
     sort function would create new cons cells to store the elements in
     their sorted order.  If you wish to make a sorted copy without
     destroying the original, copy it first with 'copy-sequence' and
     then sort.

     Sorting does not change the CARs of the cons cells in SEQUENCE; the
     cons cell that originally contained the element 'a' in SEQUENCE
     still has 'a' in its CAR after sorting, but it now appears in a
     different position in the list due to the change of CDRs.  For
     example:

          (setq nums (list 1 3 2 6 5 4 0))
               => (1 3 2 6 5 4 0)
          (sort nums #'<)
               => (0 1 2 3 4 5 6)
          nums
               => (1 2 3 4 5 6)

     Warning: Note that the list in 'nums' no longer contains 0; this
     is the same cons cell that it was before, but it is no longer the
     first one in the list.  Don't assume a variable that formerly held
     the argument now holds the entire sorted list!  Instead, save the
     result of 'sort' and use that.  Most often we store the result back
     into the variable that held the original list:

          (setq nums (sort nums #'<))

     For the better understanding of what stable sort is, consider the
     following vector example.  After sorting, all items whose 'car' is
     8 are grouped at the beginning of 'vector', but their relative
     order is preserved.  All items whose 'car' is 9 are grouped at the
     end of 'vector', but their relative order is also preserved:

          (setq
            vector
            (vector '(8 . "xxx") '(9 . "aaa") '(8 . "bbb") '(9 . "zzz")
                    '(9 . "ppp") '(8 . "ttt") '(8 . "eee") '(9 . "fff")))
               => [(8 . "xxx") (9 . "aaa") (8 . "bbb") (9 . "zzz")
                   (9 . "ppp") (8 . "ttt") (8 . "eee") (9 . "fff")]
          (sort vector (lambda (x y) (< (car x) (car y))))
               => [(8 . "xxx") (8 . "bbb") (8 . "ttt") (8 . "eee")
                   (9 . "aaa") (9 . "zzz") (9 . "ppp") (9 . "fff")]

     *Note Sorting::, for more functions that perform sorting.  See
     'documentation' in *note Accessing Documentation::, for a useful
     example of 'sort'.

   The 'seq.el' library provides the following additional sequence
manipulation macros and functions, prefixed with 'seq-'.  To use them,
you must first load the 'seq' library.

   All functions defined in this library are free of side-effects; i.e.,
they do not modify any sequence (list, vector, or string) that you pass
as an argument.  Unless otherwise stated, the result is a sequence of
the same type as the input.  For those functions that take a predicate,
this should be a function of one argument.

   The 'seq.el' library can be extended to work with additional types of
sequential data-structures.  For that purpose, all functions are defined
using 'cl-defgeneric'.  *Note Generic Functions::, for more details
about using 'cl-defgeneric' for adding extensions.

 -- Function: seq-elt sequence index
     This function returns the element of SEQUENCE at the specified
     INDEX, which is an integer whose valid value range is zero to one
     less than the length of SEQUENCE.  For out-of-range values on
     built-in sequence types, 'seq-elt' behaves like 'elt'.  For the
     details, see *note Definition of elt::.

          (seq-elt [1 2 3 4] 2)
          => 3

     'seq-elt' returns places settable using 'setf' (*note Setting
     Generalized Variables::).

          (setq vec [1 2 3 4])
          (setf (seq-elt vec 2) 5)
          vec
          => [1 2 5 4]

 -- Function: seq-length sequence
     This function returns the number of elements in SEQUENCE.  For
     built-in sequence types, 'seq-length' behaves like 'length'.  *Note
     Definition of length::.

 -- Function: seqp object
     This function returns non-'nil' if OBJECT is a sequence (a list or
     array), or any additional type of sequence defined via 'seq.el'
     generic functions.  This is an extensible variant of 'sequencep'.

          (seqp [1 2])
          => t
          (seqp 2)
          => nil

 -- Function: seq-drop sequence n
     This function returns all but the first N (an integer) elements of
     SEQUENCE.  If N is negative or zero, the result is SEQUENCE.

          (seq-drop [1 2 3 4 5 6] 3)
          => [4 5 6]
          (seq-drop "hello world" -4)
          => "hello world"

 -- Function: seq-take sequence n
     This function returns the first N (an integer) elements of
     SEQUENCE.  If N is negative or zero, the result is 'nil'.

          (seq-take '(1 2 3 4) 3)
          => (1 2 3)
          (seq-take [1 2 3 4] 0)
          => []

 -- Function: seq-take-while predicate sequence
     This function returns the members of SEQUENCE in order, stopping
     before the first one for which PREDICATE returns 'nil'.

          (seq-take-while (lambda (elt) (> elt 0)) '(1 2 3 -1 -2))
          => (1 2 3)
          (seq-take-while (lambda (elt) (> elt 0)) [-1 4 6])
          => []

 -- Function: seq-drop-while predicate sequence
     This function returns the members of SEQUENCE in order, starting
     from the first one for which PREDICATE returns 'nil'.

          (seq-drop-while (lambda (elt) (> elt 0)) '(1 2 3 -1 -2))
          => (-1 -2)
          (seq-drop-while (lambda (elt) (< elt 0)) [1 4 6])
          => [1 4 6]

 -- Function: seq-do function sequence
     This function applies FUNCTION to each element of SEQUENCE in turn
     (presumably for side effects), and returns SEQUENCE.

 -- Function: seq-map function sequence
     This function returns the result of applying FUNCTION to each
     element of SEQUENCE.  The returned value is a list.

          (seq-map #'1+ '(2 4 6))
          => (3 5 7)
          (seq-map #'symbol-name [foo bar])
          => ("foo" "bar")

 -- Function: seq-map-indexed function sequence
     This function returns the result of applying FUNCTION to each
     element of SEQUENCE and its index within SEQ.  The returned value
     is a list.

          (seq-map-indexed (lambda (elt idx)
                             (list idx elt))
                           '(a b c))
          => ((0 a) (b 1) (c 2))

 -- Function: seq-mapn function &rest sequences
     This function returns the result of applying FUNCTION to each
     element of SEQUENCES.  The arity (*note subr-arity: What Is a
     Function.) of FUNCTION must match the number of sequences.  Mapping
     stops at the end of the shortest sequence, and the returned value
     is a list.

          (seq-mapn #'+ '(2 4 6) '(20 40 60))
          => (22 44 66)
          (seq-mapn #'concat '("moskito" "bite") ["bee" "sting"])
          => ("moskitobee" "bitesting")

 -- Function: seq-filter predicate sequence
     This function returns a list of all the elements in SEQUENCE for
     which PREDICATE returns non-'nil'.

          (seq-filter (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
          => (1 3 5)
          (seq-filter (lambda (elt) (> elt 0)) '(-1 -3 -5))
          => nil

 -- Function: seq-remove predicate sequence
     This function returns a list of all the elements in SEQUENCE for
     which PREDICATE returns 'nil'.

          (seq-remove (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
          => (-1 -3)
          (seq-remove (lambda (elt) (< elt 0)) '(-1 -3 -5))
          => nil

 -- Function: seq-reduce function sequence initial-value
     This function returns the result of calling FUNCTION with
     INITIAL-VALUE and the first element of SEQUENCE, then calling
     FUNCTION with that result and the second element of SEQUENCE, then
     with that result and the third element of SEQUENCE, etc.  FUNCTION
     should be a function of two arguments.  If SEQUENCE is empty, this
     returns INITIAL-VALUE without calling FUNCTION.

          (seq-reduce #'+ [1 2 3 4] 0)
          => 10
          (seq-reduce #'+ '(1 2 3 4) 5)
          => 15
          (seq-reduce #'+ '() 3)
          => 3

 -- Function: seq-some predicate sequence
     This function returns the first non-'nil' value returned by
     applying PREDICATE to each element of SEQUENCE in turn.

          (seq-some #'numberp ["abc" 1 nil])
          => t
          (seq-some #'numberp ["abc" "def"])
          => nil
          (seq-some #'null ["abc" 1 nil])
          => t
          (seq-some #'1+ [2 4 6])
          => 3

 -- Function: seq-find predicate sequence &optional default
     This function returns the first element in SEQUENCE for which
     PREDICATE returns non-'nil'.  If no element matches PREDICATE, the
     function returns DEFAULT.

     Note that this function has an ambiguity if the found element is
     identical to DEFAULT, as in that case it cannot be known whether an
     element was found or not.

          (seq-find #'numberp ["abc" 1 nil])
          => 1
          (seq-find #'numberp ["abc" "def"])
          => nil

 -- Function: seq-every-p predicate sequence
     This function returns non-'nil' if applying PREDICATE to every
     element of SEQUENCE returns non-'nil'.

          (seq-every-p #'numberp [2 4 6])
          => t
          (seq-every-p #'numberp [2 4 "6"])
          => nil

 -- Function: seq-empty-p sequence
     This function returns non-'nil' if SEQUENCE is empty.

          (seq-empty-p "not empty")
          => nil
          (seq-empty-p "")
          => t

 -- Function: seq-count predicate sequence
     This function returns the number of elements in SEQUENCE for which
     PREDICATE returns non-'nil'.

          (seq-count (lambda (elt) (> elt 0)) [-1 2 0 3 -2])
          => 2

 -- Function: seq-sort function sequence
     This function returns a copy of SEQUENCE that is sorted according
     to FUNCTION, a function of two arguments that returns non-'nil' if
     the first argument should sort before the second.

 -- Function: seq-sort-by function predicate sequence
     This function is similar to 'seq-sort', but the elements of
     SEQUENCE are transformed by applying FUNCTION on them before being
     sorted.  FUNCTION is a function of one argument.

          (seq-sort-by #'seq-length #'> ["a" "ab" "abc"])
          => ["abc" "ab" "a"]

 -- Function: seq-contains-p sequence elt &optional function
     This function returns non-'nil' if at least one element in SEQUENCE
     is equal to ELT.  If the optional argument FUNCTION is non-'nil',
     it is a function of two arguments to use instead of the default
     'equal'.

          (seq-contains '(symbol1 symbol2) 'symbol1)
          => symbol1
          (seq-contains '(symbol1 symbol2) 'symbol3)
          => nil

 -- Function: seq-set-equal-p sequence1 sequence2 &optional testfn
     This function checks whether SEQUENCE1 and SEQUENCE2 contain the
     same elements, regardless of the order.  If the optional argument
     TESTFN is non-'nil', it is a function of two arguments to use
     instead of the default 'equal'.

          (seq-set-equal-p '(a b c) '(c b a))
          => t
          (seq-set-equal-p '(a b c) '(c b))
          => nil
          (seq-set-equal-p '("a" "b" "c") '("c" "b" "a"))
          => t
          (seq-set-equal-p '("a" "b" "c") '("c" "b" "a") #'eq)
          => nil

 -- Function: seq-position sequence elt &optional function
     This function returns the index of the first element in SEQUENCE
     that is equal to ELT.  If the optional argument FUNCTION is
     non-'nil', it is a function of two arguments to use instead of the
     default 'equal'.

          (seq-position '(a b c) 'b)
          => 1
          (seq-position '(a b c) 'd)
          => nil

 -- Function: seq-uniq sequence &optional function
     This function returns a list of the elements of SEQUENCE with
     duplicates removed.  If the optional argument FUNCTION is
     non-'nil', it is a function of two arguments to use instead of the
     default 'equal'.

          (seq-uniq '(1 2 2 1 3))
          => (1 2 3)
          (seq-uniq '(1 2 2.0 1.0) #'=)
          => (1 2)

 -- Function: seq-subseq sequence start &optional end
     This function returns a subset of SEQUENCE from START to END, both
     integers (END defaults to the last element).  If START or END is
     negative, it counts from the end of SEQUENCE.

          (seq-subseq '(1 2 3 4 5) 1)
          => (2 3 4 5)
          (seq-subseq '[1 2 3 4 5] 1 3)
          => [2 3]
          (seq-subseq '[1 2 3 4 5] -3 -1)
          => [3 4]

 -- Function: seq-concatenate type &rest sequences
     This function returns a sequence of type TYPE made of the
     concatenation of SEQUENCES.  TYPE may be: 'vector', 'list' or
     'string'.

          (seq-concatenate 'list '(1 2) '(3 4) [5 6])
          => (1 2 3 4 5 6)
          (seq-concatenate 'string "Hello " "world")
          => "Hello world"

 -- Function: seq-mapcat function sequence &optional type
     This function returns the result of applying 'seq-concatenate' to
     the result of applying FUNCTION to each element of SEQUENCE.  The
     result is a sequence of type TYPE, or a list if TYPE is 'nil'.

          (seq-mapcat #'seq-reverse '((3 2 1) (6 5 4)))
          => (1 2 3 4 5 6)

 -- Function: seq-partition sequence n
     This function returns a list of the elements of SEQUENCE grouped
     into sub-sequences of length N.  The last sequence may contain less
     elements than N.  N must be an integer.  If N is a negative integer
     or 0, the return value is 'nil'.

          (seq-partition '(0 1 2 3 4 5 6 7) 3)
          => ((0 1 2) (3 4 5) (6 7))

 -- Function: seq-intersection sequence1 sequence2 &optional function
     This function returns a list of the elements that appear both in
     SEQUENCE1 and SEQUENCE2.  If the optional argument FUNCTION is
     non-'nil', it is a function of two arguments to use to compare
     elements instead of the default 'equal'.

          (seq-intersection [2 3 4 5] [1 3 5 6 7])
          => (3 5)

 -- Function: seq-difference sequence1 sequence2 &optional function
     This function returns a list of the elements that appear in
     SEQUENCE1 but not in SEQUENCE2.  If the optional argument FUNCTION
     is non-'nil', it is a function of two arguments to use to compare
     elements instead of the default 'equal'.

          (seq-difference '(2 3 4 5) [1 3 5 6 7])
          => (2 4)

 -- Function: seq-group-by function sequence
     This function separates the elements of SEQUENCE into an alist
     whose keys are the result of applying FUNCTION to each element of
     SEQUENCE.  Keys are compared using 'equal'.

          (seq-group-by #'integerp '(1 2.1 3 2 3.2))
          => ((t 1 3 2) (nil 2.1 3.2))
          (seq-group-by #'car '((a 1) (b 2) (a 3) (c 4)))
          => ((b (b 2)) (a (a 1) (a 3)) (c (c 4)))

 -- Function: seq-into sequence type
     This function converts the sequence SEQUENCE into a sequence of
     type TYPE.  TYPE can be one of the following symbols: 'vector',
     'string' or 'list'.

          (seq-into [1 2 3] 'list)
          => (1 2 3)
          (seq-into nil 'vector)
          => []
          (seq-into "hello" 'vector)
          => [104 101 108 108 111]

 -- Function: seq-min sequence
     This function returns the smallest element of SEQUENCE.  The
     elements of SEQUENCE must be numbers or markers (*note Markers::).

          (seq-min [3 1 2])
          => 1
          (seq-min "Hello")
          => 72

 -- Function: seq-max sequence
     This function returns the largest element of SEQUENCE.  The
     elements of SEQUENCE must be numbers or markers.

          (seq-max [1 3 2])
          => 3
          (seq-max "Hello")
          => 111

 -- Macro: seq-doseq (var sequence) body...
     This macro is like 'dolist' (*note dolist: Iteration.), except that
     SEQUENCE can be a list, vector or string.  This is primarily useful
     for side-effects.

 -- Macro: seq-let var-sequence val-sequence body...
     This macro binds the variables defined in VAR-SEQUENCE to the
     values that are the corresponding elements of VAL-SEQUENCE.  This
     is known as "destructuring binding".  The elements of VAR-SEQUENCE
     can themselves include sequences, allowing for nested
     destructuring.

     The VAR-SEQUENCE sequence can also include the '&rest' marker
     followed by a variable name to be bound to the rest of
     VAL-SEQUENCE.

          (seq-let [first second] [1 2 3 4]
            (list first second))
          => (1 2)
          (seq-let (_ a _ b) '(1 2 3 4)
            (list a b))
          => (2 4)
          (seq-let [a [b [c]]] [1 [2 [3]]]
            (list a b c))
          => (1 2 3)
          (seq-let [a b &rest others] [1 2 3 4]
            others)
          => [3 4]

     The 'pcase' patterns provide an alternative facility for
     destructuring binding, see *note Destructuring with pcase
     Patterns::.

 -- Function: seq-random-elt sequence
     This function returns an element of SEQUENCE taken at random.

          (seq-random-elt [1 2 3 4])
          => 3
          (seq-random-elt [1 2 3 4])
          => 2
          (seq-random-elt [1 2 3 4])
          => 4
          (seq-random-elt [1 2 3 4])
          => 2
          (seq-random-elt [1 2 3 4])
          => 1

     If SEQUENCE is empty, this function signals an error.

==============================================================================
File: elisp.info,  Node: |Arrays|,  Next: |Array_Functions|,  Prev: |Sequence_Functions|,  Up: |Sequences_Arrays_Vectors|
==============================================================================

                                                                        *Arrays*

6.2 Arrays
----------

An "array" object has slots that hold a number of other Lisp objects,
called the elements of the array.  Any element of an array may be
accessed in constant time.  In contrast, the time to access an element
of a list is proportional to the position of that element in the list.

   Emacs defines four types of array, all one-dimensional: "strings"
(*note String Type::), "vectors" (*note Vector Type::), "bool-vectors"
(*note Bool-Vector Type::), and "char-tables" (*note Char-Table Type::).
Vectors and char-tables can hold elements of any type, but strings can
only hold characters, and bool-vectors can only hold 't' and 'nil'.

   All four kinds of array share these characteristics:

   * The first element of an array has index zero, the second element
     has index 1, and so on.  This is called "zero-origin" indexing.
     For example, an array of four elements has indices 0, 1, 2, and 3.

   * The length of the array is fixed once you create it; you cannot
     change the length of an existing array.

   * For purposes of evaluation, the array is a constant--i.e., it
     evaluates to itself.

   * The elements of an array may be referenced or changed with the
     functions 'aref' and 'aset', respectively (*note Array
     Functions::).

   When you create an array, other than a char-table, you must specify
its length.  You cannot specify the length of a char-table, because that
is determined by the range of character codes.

   In principle, if you want an array of text characters, you could use
either a string or a vector.  In practice, we always choose strings for
such applications, for four reasons:

   * They occupy one-fourth the space of a vector of the same elements.

   * Strings are printed in a way that shows the contents more clearly
     as text.

   * Strings can hold text properties.  *Note Text Properties::.

   * Many of the specialized editing and I/O facilities of Emacs accept
     only strings.  For example, you cannot insert a vector of
     characters into a buffer the way you can insert a string.  *Note
     Strings and Characters::.

   By contrast, for an array of keyboard input characters (such as a key
sequence), a vector may be necessary, because many keyboard input
characters are outside the range that will fit in a string.  *Note Key
Sequence Input::.

==============================================================================
File: elisp.info,  Node: |Array_Functions|,  Next: |Vectors|,  Prev: |Arrays|,  Up: |Sequences_Arrays_Vectors|
==============================================================================

                                                               *Array_Functions*

6.3 Functions that Operate on Arrays
------------------------------------

In this section, we describe the functions that accept all types of
arrays.

 -- Function: arrayp object
     This function returns 't' if OBJECT is an array (i.e., a vector, a
     string, a bool-vector or a char-table).

          (arrayp [a])
               => t
          (arrayp "asdf")
               => t
          (arrayp (syntax-table))    ;; A char-table.
               => t

 -- Function: aref arr index
     This function returns the INDEXth element of the array or record
     ARR.  The first element is at index zero.

          (setq primes [2 3 5 7 11 13])
               => [2 3 5 7 11 13]
          (aref primes 4)
               => 11
          (aref "abcdefg" 1)
               => 98           ; 'b' is ASCII code 98.

     See also the function 'elt', in *note Sequence Functions::.

 -- Function: aset array index object
     This function sets the INDEXth element of ARRAY to be OBJECT.  It
     returns OBJECT.

          (setq w (vector 'foo 'bar 'baz))
               => [foo bar baz]
          (aset w 0 'fu)
               => fu
          w
               => [fu bar baz]

          ;; 'copy-sequence' copies the string to be modified later.
          (setq x (copy-sequence "asdfasfd"))
               => "asdfasfd"
          (aset x 3 ?Z)
               => 90
          x
               => "asdZasfd"

     The ARRAY should be mutable.  *Note Mutability::.

     If ARRAY is a string and OBJECT is not a character, a
     'wrong-type-argument' error results.  The function converts a
     unibyte string to multibyte if necessary to insert a character.

 -- Function: fillarray array object
     This function fills the array ARRAY with OBJECT, so that each
     element of ARRAY is OBJECT.  It returns ARRAY.

          (setq a (copy-sequence [a b c d e f g]))
               => [a b c d e f g]
          (fillarray a 0)
               => [0 0 0 0 0 0 0]
          a
               => [0 0 0 0 0 0 0]
          (setq s (copy-sequence "When in the course"))
               => "When in the course"
          (fillarray s ?-)
               => "------------------"

     If ARRAY is a string and OBJECT is not a character, a
     'wrong-type-argument' error results.

   The general sequence functions 'copy-sequence' and 'length' are often
useful for objects known to be arrays.  *Note Sequence Functions::.

==============================================================================
File: elisp.info,  Node: |Vectors|,  Next: |Vector_Functions|,  Prev: |Array_Functions|,  Up: |Sequences_Arrays_Vectors|
==============================================================================

                                                                       *Vectors*

6.4 Vectors
-----------

A "vector" is a general-purpose array whose elements can be any Lisp
objects.  (By contrast, the elements of a string can only be characters.
*Note Strings and Characters::.)  Vectors are used in Emacs for many
purposes: as key sequences (*note Key Sequences::), as symbol-lookup
tables (*note Creating Symbols::), as part of the representation of a
byte-compiled function (*note Byte Compilation::), and more.

   Like other arrays, vectors use zero-origin indexing: the first
element has index 0.

   Vectors are printed with square brackets surrounding the elements.
Thus, a vector whose elements are the symbols 'a', 'b' and 'a' is
printed as '[a b a]'.  You can write vectors in the same way in Lisp
input.

   A vector, like a string or a number, is considered a constant for
evaluation: the result of evaluating it is the same vector.  This does
not evaluate or even examine the elements of the vector.  *Note
Self-Evaluating Forms::.  Vectors written with square brackets should
not be modified via 'aset' or other destructive operations.  *Note
Mutability::.

   Here are examples illustrating these principles:

     (setq avector [1 two '(three) "four" [five]])
          => [1 two '(three) "four" [five]]
     (eval avector)
          => [1 two '(three) "four" [five]]
     (eq avector (eval avector))
          => t

==============================================================================
File: elisp.info,  Node: |Vector_Functions|,  Next: |Char_Tables|,  Prev: |Vectors|,  Up: |Sequences_Arrays_Vectors|
==============================================================================

                                                              *Vector_Functions*

6.5 Functions for Vectors
-------------------------

Here are some functions that relate to vectors:

 -- Function: vectorp object
     This function returns 't' if OBJECT is a vector.

          (vectorp [a])
               => t
          (vectorp "asdf")
               => nil

 -- Function: vector &rest objects
     This function creates and returns a vector whose elements are the
     arguments, OBJECTS.

          (vector 'foo 23 [bar baz] "rats")
               => [foo 23 [bar baz] "rats"]
          (vector)
               => []

 -- Function: make-vector length object
     This function returns a new vector consisting of LENGTH elements,
     each initialized to OBJECT.

          (setq sleepy (make-vector 9 'Z))
               => [Z Z Z Z Z Z Z Z Z]

 -- Function: vconcat &rest sequences
     This function returns a new vector containing all the elements of
     SEQUENCES.  The arguments SEQUENCES may be proper lists, vectors,
     strings or bool-vectors.  If no SEQUENCES are given, the empty
     vector is returned.

     The value is either the empty vector, or is a newly constructed
     nonempty vector that is not 'eq' to any existing vector.

          (setq a (vconcat '(A B C) '(D E F)))
               => [A B C D E F]
          (eq a (vconcat a))
               => nil
          (vconcat)
               => []
          (vconcat [A B C] "aa" '(foo (6 7)))
               => [A B C 97 97 foo (6 7)]

     The 'vconcat' function also allows byte-code function objects as
     arguments.  This is a special feature to make it easy to access the
     entire contents of a byte-code function object.  *Note Byte-Code
     Objects::.

     For other concatenation functions, see 'mapconcat' in *note Mapping
     Functions::, 'concat' in *note Creating Strings::, and 'append' in
     *note Building Lists::.

   The 'append' function also provides a way to convert a vector into a
list with the same elements:

     (setq avector [1 two (quote (three)) "four" [five]])
          => [1 two '(three) "four" [five]]
     (append avector nil)
          => (1 two '(three) "four" [five])

==============================================================================
File: elisp.info,  Node: |Char_Tables|,  Next: |Bool_Vectors|,  Prev: |Vector_Functions|,  Up: |Sequences_Arrays_Vectors|
==============================================================================

                                                                   *Char_Tables*

6.6 Char-Tables
---------------

A char-table is much like a vector, except that it is indexed by
character codes.  Any valid character code, without modifiers, can be
used as an index in a char-table.  You can access a char-table's
elements with 'aref' and 'aset', as with any array.  In addition, a
char-table can have "extra slots" to hold additional data not associated
with particular character codes.  Like vectors, char-tables are
constants when evaluated, and can hold elements of any type.

   Each char-table has a "subtype", a symbol, which serves two purposes:

   * The subtype provides an easy way to tell what the char-table is
     for.  For instance, display tables are char-tables with
     'display-table' as the subtype, and syntax tables are char-tables
     with 'syntax-table' as the subtype.  The subtype can be queried
     using the function 'char-table-subtype', described below.

   * The subtype controls the number of "extra slots" in the char-table.
     This number is specified by the subtype's 'char-table-extra-slots'
     symbol property (*note Symbol Properties::), whose value should be
     an integer between 0 and 10.  If the subtype has no such symbol
     property, the char-table has no extra slots.

   A char-table can have a "parent", which is another char-table.  If it
does, then whenever the char-table specifies 'nil' for a particular
character C, it inherits the value specified in the parent.  In other
words, '(aref CHAR-TABLE C)' returns the value from the parent of
CHAR-TABLE if CHAR-TABLE itself specifies 'nil'.

   A char-table can also have a "default value".  If so, then '(aref
CHAR-TABLE C)' returns the default value whenever the char-table does
not specify any other non-'nil' value.

 -- Function: make-char-table subtype &optional init
     Return a newly-created char-table, with subtype SUBTYPE (a symbol).
     Each element is initialized to INIT, which defaults to 'nil'.  You
     cannot alter the subtype of a char-table after the char-table is
     created.

     There is no argument to specify the length of the char-table,
     because all char-tables have room for any valid character code as
     an index.

     If SUBTYPE has the 'char-table-extra-slots' symbol property, that
     specifies the number of extra slots in the char-table.  This should
     be an integer between 0 and 10; otherwise, 'make-char-table' raises
     an error.  If SUBTYPE has no 'char-table-extra-slots' symbol
     property (*note Property Lists::), the char-table has no extra
     slots.

 -- Function: char-table-p object
     This function returns 't' if OBJECT is a char-table, and 'nil'
     otherwise.

 -- Function: char-table-subtype char-table
     This function returns the subtype symbol of CHAR-TABLE.

   There is no special function to access default values in a
char-table.  To do that, use 'char-table-range' (see below).

 -- Function: char-table-parent char-table
     This function returns the parent of CHAR-TABLE.  The parent is
     always either 'nil' or another char-table.

 -- Function: set-char-table-parent char-table new-parent
     This function sets the parent of CHAR-TABLE to NEW-PARENT.

 -- Function: char-table-extra-slot char-table n
     This function returns the contents of extra slot N (zero based) of
     CHAR-TABLE.  The number of extra slots in a char-table is
     determined by its subtype.

 -- Function: set-char-table-extra-slot char-table n value
     This function stores VALUE in extra slot N (zero based) of
     CHAR-TABLE.

   A char-table can specify an element value for a single character
code; it can also specify a value for an entire character set.

 -- Function: char-table-range char-table range
     This returns the value specified in CHAR-TABLE for a range of
     characters RANGE.  Here are the possibilities for RANGE:

     'nil'
          Refers to the default value.

     CHAR
          Refers to the element for character CHAR (supposing CHAR is a
          valid character code).

     '(FROM . TO)'
          A cons cell refers to all the characters in the inclusive
          range '[FROM..TO]'.

 -- Function: set-char-table-range char-table range value
     This function sets the value in CHAR-TABLE for a range of
     characters RANGE.  Here are the possibilities for RANGE:

     'nil'
          Refers to the default value.

     't'
          Refers to the whole range of character codes.

     CHAR
          Refers to the element for character CHAR (supposing CHAR is a
          valid character code).

     '(FROM . TO)'
          A cons cell refers to all the characters in the inclusive
          range '[FROM..TO]'.

 -- Function: map-char-table function char-table
     This function calls its argument FUNCTION for each element of
     CHAR-TABLE that has a non-'nil' value.  The call to FUNCTION is
     with two arguments, a key and a value.  The key is a possible RANGE
     argument for 'char-table-range'--either a valid character or a cons
     cell '(FROM . TO)', specifying a range of characters that share the
     same value.  The value is what '(char-table-range CHAR-TABLE KEY)'
     returns.

     Overall, the key-value pairs passed to FUNCTION describe all the
     values stored in CHAR-TABLE.

     The return value is always 'nil'; to make calls to 'map-char-table'
     useful, FUNCTION should have side effects.  For example, here is
     how to examine the elements of the syntax table:

          (let (accumulator)
             (map-char-table
              (lambda (key value)
                (setq accumulator
                      (cons (list
                             (if (consp key)
                                 (list (car key) (cdr key))
                               key)
                             value)
                            accumulator)))
              (syntax-table))
             accumulator)
          =>
          (((2597602 4194303) (2)) ((2597523 2597601) (3))
           ... (65379 (5 . 65378)) (65378 (4 . 65379)) (65377 (1))
           ... (12 (0)) (11 (3)) (10 (12)) (9 (0)) ((0 8) (3)))

==============================================================================
File: elisp.info,  Node: |Bool_Vectors|,  Next: |Rings|,  Prev: |Char_Tables|,  Up: |Sequences_Arrays_Vectors|
==============================================================================

                                                                  *Bool_Vectors*

6.7 Bool-vectors
----------------

A bool-vector is much like a vector, except that it stores only the
values 't' and 'nil'.  If you try to store any non-'nil' value into an
element of the bool-vector, the effect is to store 't' there.  As with
all arrays, bool-vector indices start from 0, and the length cannot be
changed once the bool-vector is created.  Bool-vectors are constants
when evaluated.

   Several functions work specifically with bool-vectors; aside from
that, you manipulate them with same functions used for other kinds of
arrays.

 -- Function: make-bool-vector length initial
     Return a new bool-vector of LENGTH elements, each one initialized
     to INITIAL.

 -- Function: bool-vector &rest objects
     This function creates and returns a bool-vector whose elements are
     the arguments, OBJECTS.

 -- Function: bool-vector-p object
     This returns 't' if OBJECT is a bool-vector, and 'nil' otherwise.

   There are also some bool-vector set operation functions, described
below:

 -- Function: bool-vector-exclusive-or a b &optional c
     Return "bitwise exclusive or" of bool vectors A and B.  If optional
     argument C is given, the result of this operation is stored into C.
     All arguments should be bool vectors of the same length.

 -- Function: bool-vector-union a b &optional c
     Return "bitwise or" of bool vectors A and B.  If optional argument
     C is given, the result of this operation is stored into C.  All
     arguments should be bool vectors of the same length.

 -- Function: bool-vector-intersection a b &optional c
     Return "bitwise and" of bool vectors A and B.  If optional argument
     C is given, the result of this operation is stored into C.  All
     arguments should be bool vectors of the same length.

 -- Function: bool-vector-set-difference a b &optional c
     Return "set difference" of bool vectors A and B.  If optional
     argument C is given, the result of this operation is stored into C.
     All arguments should be bool vectors of the same length.

 -- Function: bool-vector-not a &optional b
     Return "set complement" of bool vector A.  If optional argument B
     is given, the result of this operation is stored into B.  All
     arguments should be bool vectors of the same length.

 -- Function: bool-vector-subsetp a b
     Return 't' if every 't' value in A is also 't' in B, 'nil'
     otherwise.  All arguments should be bool vectors of the same
     length.

 -- Function: bool-vector-count-consecutive a b i
     Return the number of consecutive elements in A equal B starting at
     I.  'a' is a bool vector, B is 't' or 'nil', and I is an index into
     'a'.

 -- Function: bool-vector-count-population a
     Return the number of elements that are 't' in bool vector A.

   The printed form represents up to 8 boolean values as a single
character:

     (bool-vector t nil t nil)
          => #&4"^E"
     (bool-vector)
          => #&0""

   You can use 'vconcat' to print a bool-vector like other vectors:

     (vconcat (bool-vector nil t nil t))
          => [nil t nil t]

   Here is another example of creating, examining, and updating a
bool-vector:

     (setq bv (make-bool-vector 5 t))
          => #&5"^_"
     (aref bv 1)
          => t
     (aset bv 3 nil)
          => nil
     bv
          => #&5"^W"

These results make sense because the binary codes for control-_ and
control-W are 11111 and 10111, respectively.

==============================================================================
File: elisp.info,  Node: |Rings|,  Prev: |Bool_Vectors|,  Up: |Sequences_Arrays_Vectors|
==============================================================================

                                                                         *Rings*

6.8 Managing a Fixed-Size Ring of Objects
-----------------------------------------

A "ring" is a fixed-size data structure that supports insertion,
deletion, rotation, and modulo-indexed reference and traversal.  An
efficient ring data structure is implemented by the 'ring' package.  It
provides the functions listed in this section.

   Note that several rings in Emacs, like the kill ring and the mark
ring, are actually implemented as simple lists, _not_ using the 'ring'
package; thus the following functions won't work on them.

 -- Function: make-ring size
     This returns a new ring capable of holding SIZE objects.  SIZE
     should be an integer.

 -- Function: ring-p object
     This returns 't' if OBJECT is a ring, 'nil' otherwise.

 -- Function: ring-size ring
     This returns the maximum capacity of the RING.

 -- Function: ring-length ring
     This returns the number of objects that RING currently contains.
     The value will never exceed that returned by 'ring-size'.

 -- Function: ring-elements ring
     This returns a list of the objects in RING, in order, newest first.

 -- Function: ring-copy ring
     This returns a new ring which is a copy of RING.  The new ring
     contains the same ('eq') objects as RING.

 -- Function: ring-empty-p ring
     This returns 't' if RING is empty, 'nil' otherwise.

   The newest element in the ring always has index 0.  Higher indices
correspond to older elements.  Indices are computed modulo the ring
length.  Index -1 corresponds to the oldest element, -2 to the
next-oldest, and so forth.

 -- Function: ring-ref ring index
     This returns the object in RING found at index INDEX.  INDEX may be
     negative or greater than the ring length.  If RING is empty,
     'ring-ref' signals an error.

 -- Function: ring-insert ring object
     This inserts OBJECT into RING, making it the newest element, and
     returns OBJECT.

     If the ring is full, insertion removes the oldest element to make
     room for the new element.

 -- Function: ring-remove ring &optional index
     Remove an object from RING, and return that object.  The argument
     INDEX specifies which item to remove; if it is 'nil', that means to
     remove the oldest item.  If RING is empty, 'ring-remove' signals an
     error.

 -- Function: ring-insert-at-beginning ring object
     This inserts OBJECT into RING, treating it as the oldest element.
     The return value is not significant.

     If the ring is full, this function removes the newest element to
     make room for the inserted element.

 -- Function: ring-resize ring size
     Set the size of RING to SIZE.  If the new size is smaller, then the
     oldest items in the ring are discarded.

   If you are careful not to exceed the ring size, you can use the ring
as a first-in-first-out queue.  For example:

     (let ((fifo (make-ring 5)))
       (mapc (lambda (obj) (ring-insert fifo obj))
             '(0 one "two"))
       (list (ring-remove fifo) t
             (ring-remove fifo) t
             (ring-remove fifo)))
          => (0 t one t "two")

==============================================================================
File: elisp.info,  Node: |Records|,  Next: |Hash_Tables|,  Prev: |Sequences_Arrays_Vectors|,  Up: |Top|
==============================================================================

                                                                       *Records*

7 Records
=========

The purpose of records is to allow programmers to create objects with
new types that are not built into Emacs.  They are used as the
underlying representation of 'cl-defstruct' and 'defclass' instances.

   Internally, a record object is much like a vector; its slots can be
accessed using 'aref' and it can be copied using 'copy-sequence'.
However, the first slot is used to hold its type as returned by
'type-of'.  Also, in the current implementation records can have at most
4096 slots, whereas vectors can be much larger.  Like arrays, records
use zero-origin indexing: the first slot has index 0.

   The type slot should be a symbol or a type descriptor.  If it's a
type descriptor, the symbol naming its type will be returned; *note Type
Descriptors::.  Any other kind of object is returned as-is.

   The printed representation of records is '#s' followed by a list
specifying the contents.  The first list element must be the record
type.  The following elements are the record slots.

   To avoid conflicts with other type names, Lisp programs that define
new types of records should normally use the naming conventions of the
package where these record types are introduced for the names of the
types.  Note that the names of the types which could possibly conflict
might not be known at the time the package defining a record type is
loaded; they could be loaded at some future point in time.

   A record is considered a constant for evaluation: the result of
evaluating it is the same record.  This does not evaluate or even
examine the slots.  *Note Self-Evaluating Forms::.

MENU

* |Record_Functions|::        Functions for records.
* |Backward_Compatibility|::  Compatibility for cl-defstruct.

==============================================================================
File: elisp.info,  Node: |Record_Functions|,  Next: |Backward_Compatibility|,  Up: |Records|
==============================================================================

                                                              *Record_Functions*

7.1 Record Functions
--------------------

 -- Function: recordp object
     This function returns 't' if OBJECT is a record.

          (recordp #s(a))
               => t

 -- Function: record type &rest objects
     This function creates and returns a record whose type is TYPE and
     remaining slots are the rest of the arguments, OBJECTS.

          (record 'foo 23 [bar baz] "rats")
               => #s(foo 23 [bar baz] "rats")

 -- Function: make-record type length object
     This function returns a new record with type TYPE and LENGTH more
     slots, each initialized to OBJECT.

          (setq sleepy (make-record 'foo 9 'Z))
               => #s(foo Z Z Z Z Z Z Z Z Z)

==============================================================================
File: elisp.info,  Node: |Backward_Compatibility|,  Prev: |Record_Functions|,  Up: |Records|
==============================================================================

                                                        *Backward_Compatibility*

7.2 Backward Compatibility
--------------------------

Code compiled with older versions of 'cl-defstruct' that doesn't use
records may run into problems when used in a new Emacs.  To alleviate
this, Emacs detects when an old 'cl-defstruct' is used, and enables a
mode in which 'type-of' handles old struct objects as if they were
records.

 -- Function: cl-old-struct-compat-mode arg
     If ARG is positive, enable backward compatibility with old-style
     structs.

==============================================================================
File: elisp.info,  Node: |Hash_Tables|,  Next: |Symbols|,  Prev: |Records|,  Up: |Top|
==============================================================================

                                                                   *Hash_Tables*

8 Hash Tables
=============

A hash table is a very fast kind of lookup table, somewhat like an alist
(*note Association Lists::) in that it maps keys to corresponding
values.  It differs from an alist in these ways:

   * Lookup in a hash table is extremely fast for large tables--in fact,
     the time required is essentially _independent_ of how many elements
     are stored in the table.  For smaller tables (a few tens of
     elements) alists may still be faster because hash tables have a
     more-or-less constant overhead.

   * The correspondences in a hash table are in no particular order.

   * There is no way to share structure between two hash tables, the way
     two alists can share a common tail.

   Emacs Lisp provides a general-purpose hash table data type, along
with a series of functions for operating on them.  Hash tables have a
special printed representation, which consists of '#s' followed by a
list specifying the hash table properties and contents.  *Note Creating
Hash::.  (Hash notation, the initial '#' character used in the printed
representations of objects with no read representation, has nothing to
do with hash tables.  *Note Printed Representation::.)

   Obarrays are also a kind of hash table, but they are a different type
of object and are used only for recording interned symbols (*note
Creating Symbols::).

MENU

* |Creating_Hash|::       Functions to create hash tables.
* |Hash_Access|::         Reading and writing the hash table contents.
* |Defining_Hash|::       Defining new comparison methods.
* |Other_Hash|::          Miscellaneous.

==============================================================================
File: elisp.info,  Node: |Creating_Hash|,  Next: |Hash_Access|,  Up: |Hash_Tables|
==============================================================================

                                                                 *Creating_Hash*

8.1 Creating Hash Tables
------------------------

The principal function for creating a hash table is 'make-hash-table'.

 -- Function: make-hash-table &rest keyword-args
     This function creates a new hash table according to the specified
     arguments.  The arguments should consist of alternating keywords
     (particular symbols recognized specially) and values corresponding
     to them.

     Several keywords make sense in 'make-hash-table', but the only two
     that you really need to know about are ':test' and ':weakness'.

     ':test TEST'
          This specifies the method of key lookup for this hash table.
          The default is 'eql'; 'eq' and 'equal' are other alternatives:

          'eql'
               Keys which are numbers are the same if they are 'equal',
               that is, if they are equal in value and either both are
               integers or both are floating point; otherwise, two
               distinct objects are never the same.

          'eq'
               Any two distinct Lisp objects are different as keys.

          'equal'
               Two Lisp objects are the same, as keys, if they are equal
               according to 'equal'.

          You can use 'define-hash-table-test' (*note Defining Hash::)
          to define additional possibilities for TEST.

     ':weakness WEAK'
          The weakness of a hash table specifies whether the presence of
          a key or value in the hash table preserves it from garbage
          collection.

          The value, WEAK, must be one of 'nil', 'key', 'value',
          'key-or-value', 'key-and-value', or 't' which is an alias for
          'key-and-value'.  If WEAK is 'key' then the hash table does
          not prevent its keys from being collected as garbage (if they
          are not referenced anywhere else); if a particular key does
          get collected, the corresponding association is removed from
          the hash table.

          If WEAK is 'value', then the hash table does not prevent
          values from being collected as garbage (if they are not
          referenced anywhere else); if a particular value does get
          collected, the corresponding association is removed from the
          hash table.

          If WEAK is 'key-and-value' or 't', both the key and the value
          must be live in order to preserve the association.  Thus, the
          hash table does not protect either keys or values from garbage
          collection; if either one is collected as garbage, that
          removes the association.

          If WEAK is 'key-or-value', either the key or the value can
          preserve the association.  Thus, associations are removed from
          the hash table when both their key and value would be
          collected as garbage (if not for references from weak hash
          tables).

          The default for WEAK is 'nil', so that all keys and values
          referenced in the hash table are preserved from garbage
          collection.

     ':size SIZE'
          This specifies a hint for how many associations you plan to
          store in the hash table.  If you know the approximate number,
          you can make things a little more efficient by specifying it
          this way.  If you specify too small a size, the hash table
          will grow automatically when necessary, but doing that takes
          some extra time.

          The default size is 65.

     ':rehash-size REHASH-SIZE'
          When you add an association to a hash table and the table is
          full, it grows automatically.  This value specifies how to
          make the hash table larger, at that time.

          If REHASH-SIZE is an integer, it should be positive, and the
          hash table grows by adding approximately that much to the
          nominal size.  If REHASH-SIZE is floating point, it had better
          be greater than 1, and the hash table grows by multiplying the
          old size by approximately that number.

          The default value is 1.5.

     ':rehash-threshold THRESHOLD'
          This specifies the criterion for when the hash table is full
          (so it should be made larger).  The value, THRESHOLD, should
          be a positive floating-point number, no greater than 1.  The
          hash table is full whenever the actual number of entries
          exceeds the nominal size multiplied by an approximation to
          this value.  The default for THRESHOLD is 0.8125.

   You can also create a new hash table using the printed representation
for hash tables.  The Lisp reader can read this printed representation,
provided each element in the specified hash table has a valid read
syntax (*note Printed Representation::).  For instance, the following
specifies a new hash table containing the keys 'key1' and 'key2' (both
symbols) associated with 'val1' (a symbol) and '300' (a number)
respectively.

     #s(hash-table size 30 data (key1 val1 key2 300))

The printed representation for a hash table consists of '#s' followed by
a list beginning with 'hash-table'.  The rest of the list should consist
of zero or more property-value pairs specifying the hash table's
properties and initial contents.  The properties and values are read
literally.  Valid property names are 'size', 'test', 'weakness',
'rehash-size', 'rehash-threshold', and 'data'.  The 'data' property
should be a list of key-value pairs for the initial contents; the other
properties have the same meanings as the matching 'make-hash-table'
keywords (':size', ':test', etc.), described above.

   Note that you cannot specify a hash table whose initial contents
include objects that have no read syntax, such as buffers and frames.
Such objects may be added to the hash table after it is created.

==============================================================================
File: elisp.info,  Node: |Hash_Access|,  Next: |Defining_Hash|,  Prev: |Creating_Hash|,  Up: |Hash_Tables|
==============================================================================

                                                                   *Hash_Access*

8.2 Hash Table Access
---------------------

This section describes the functions for accessing and storing
associations in a hash table.  In general, any Lisp object can be used
as a hash key, unless the comparison method imposes limits.  Any Lisp
object can also be used as the value.

 -- Function: gethash key table &optional default
     This function looks up KEY in TABLE, and returns its associated
     VALUE--or DEFAULT, if KEY has no association in TABLE.

 -- Function: puthash key value table
     This function enters an association for KEY in TABLE, with value
     VALUE.  If KEY already has an association in TABLE, VALUE replaces
     the old associated value.

 -- Function: remhash key table
     This function removes the association for KEY from TABLE, if there
     is one.  If KEY has no association, 'remhash' does nothing.

     Common Lisp note: In Common Lisp, 'remhash' returns non-'nil' if it
     actually removed an association and 'nil' otherwise.  In Emacs
     Lisp, 'remhash' always returns 'nil'.

 -- Function: clrhash table
     This function removes all the associations from hash table TABLE,
     so that it becomes empty.  This is also called "clearing" the hash
     table.

     Common Lisp note: In Common Lisp, 'clrhash' returns the empty
     TABLE.  In Emacs Lisp, it returns 'nil'.

 -- Function: maphash function table
     This function calls FUNCTION once for each of the associations in
     TABLE.  The function FUNCTION should accept two arguments--a KEY
     listed in TABLE, and its associated VALUE.  'maphash' returns
     'nil'.

==============================================================================
File: elisp.info,  Node: |Defining_Hash|,  Next: |Other_Hash|,  Prev: |Hash_Access|,  Up: |Hash_Tables|
==============================================================================

                                                                 *Defining_Hash*

8.3 Defining Hash Comparisons
-----------------------------

You can define new methods of key lookup by means of
'define-hash-table-test'.  In order to use this feature, you need to
understand how hash tables work, and what a "hash code" means.

   You can think of a hash table conceptually as a large array of many
slots, each capable of holding one association.  To look up a key,
'gethash' first computes an integer, the hash code, from the key.  It
can reduce this integer modulo the length of the array, to produce an
index in the array.  Then it looks in that slot, and if necessary in
other nearby slots, to see if it has found the key being sought.

   Thus, to define a new method of key lookup, you need to specify both
a function to compute the hash code from a key, and a function to
compare two keys directly.  The two functions should be consistent with
each other: that is, two keys' hash codes should be the same if the keys
compare as equal.  Also, since the two functions can be called at any
time (such as by the garbage collector), the functions should be free of
side effects and should return quickly, and their behavior should depend
on only on properties of the keys that do not change.

 -- Function: define-hash-table-test name test-fn hash-fn
     This function defines a new hash table test, named NAME.

     After defining NAME in this way, you can use it as the TEST
     argument in 'make-hash-table'.  When you do that, the hash table
     will use TEST-FN to compare key values, and HASH-FN to compute a
     hash code from a key value.

     The function TEST-FN should accept two arguments, two keys, and
     return non-'nil' if they are considered the same.

     The function HASH-FN should accept one argument, a key, and return
     an integer that is the hash code of that key.  For good results,
     the function should use the whole range of fixnums for hash codes,
     including negative fixnums.

     The specified functions are stored in the property list of NAME
     under the property 'hash-table-test'; the property value's form is
     '(TEST-FN HASH-FN)'.

 -- Function: sxhash-equal obj
     This function returns a hash code for Lisp object OBJ.  This is an
     integer that reflects the contents of OBJ and the other Lisp
     objects it points to.

     If two objects OBJ1 and OBJ2 are 'equal', then '(sxhash-equal
     OBJ1)' and '(sxhash-equal OBJ2)' are the same integer.

     If the two objects are not 'equal', the values returned by
     'sxhash-equal' are usually different, but not always; once in a
     rare while, by luck, you will encounter two distinct-looking
     objects that give the same result from 'sxhash-equal'.

     Common Lisp note: In Common Lisp a similar function is called
     'sxhash'.  Emacs provides this name as a compatibility alias for
     'sxhash-equal'.

 -- Function: sxhash-eq obj
     This function returns a hash code for Lisp object OBJ.  Its result
     reflects identity of OBJ, but not its contents.

     If two objects OBJ1 and OBJ2 are 'eq', then '(sxhash-eq OBJ1)' and
     '(sxhash-eq OBJ2)' are the same integer.

 -- Function: sxhash-eql obj
     This function returns a hash code for Lisp object OBJ suitable for
     'eql' comparison.  I.e.  it reflects identity of OBJ except for the
     case where the object is a bignum or a float number, in which case
     a hash code is generated for the value.

     If two objects OBJ1 and OBJ2 are 'eql', then '(sxhash-eql OBJ1)'
     and '(sxhash-eql OBJ2)' are the same integer.

   This example creates a hash table whose keys are strings that are
compared case-insensitively.

     (defun case-fold-string= (a b)
       (eq t (compare-strings a nil nil b nil nil t)))
     (defun case-fold-string-hash (a)
       (sxhash-equal (upcase a)))

     (define-hash-table-test 'case-fold
       'case-fold-string= 'case-fold-string-hash)

     (make-hash-table :test 'case-fold)

   Here is how you could define a hash table test equivalent to the
predefined test value 'equal'.  The keys can be any Lisp object, and
equal-looking objects are considered the same key.

     (define-hash-table-test 'contents-hash 'equal 'sxhash-equal)

     (make-hash-table :test 'contents-hash)

   Lisp programs should _not_ rely on hash codes being preserved between
Emacs sessions, as the implementation of the hash functions uses some
details of the object storage that can change between sessions and
between different architectures.

==============================================================================
File: elisp.info,  Node: |Other_Hash|,  Prev: |Defining_Hash|,  Up: |Hash_Tables|
==============================================================================

                                                                    *Other_Hash*

8.4 Other Hash Table Functions
------------------------------

Here are some other functions for working with hash tables.

 -- Function: hash-table-p table
     This returns non-'nil' if TABLE is a hash table object.

 -- Function: copy-hash-table table
     This function creates and returns a copy of TABLE.  Only the table
     itself is copied--the keys and values are shared.

 -- Function: hash-table-count table
     This function returns the actual number of entries in TABLE.

 -- Function: hash-table-test table
     This returns the TEST value that was given when TABLE was created,
     to specify how to hash and compare keys.  See 'make-hash-table'
     (*note Creating Hash::).

 -- Function: hash-table-weakness table
     This function returns the WEAK value that was specified for hash
     table TABLE.

 -- Function: hash-table-rehash-size table
     This returns the rehash size of TABLE.

 -- Function: hash-table-rehash-threshold table
     This returns the rehash threshold of TABLE.

 -- Function: hash-table-size table
     This returns the current nominal size of TABLE.

==============================================================================
File: elisp.info,  Node: |Symbols|,  Next: |Evaluation|,  Prev: |Hash_Tables|,  Up: |Top|
==============================================================================

                                                                       *Symbols*

9 Symbols
=========

A "symbol" is an object with a unique name.  This chapter describes
symbols, their components, their property lists, and how they are
created and interned.  Separate chapters describe the use of symbols as
variables and as function names; see *note Variables::, and *note
Functions::.  For the precise read syntax for symbols, see *note Symbol
Type::.

   You can test whether an arbitrary Lisp object is a symbol with
'symbolp':

 -- Function: symbolp object
     This function returns 't' if OBJECT is a symbol, 'nil' otherwise.

MENU

* |Symbol_Components|::        Symbols have names, values, function definitions
                               and property lists.
* |Definitions|::              A definition says how a symbol will be used.
* |Creating_Symbols|::         How symbols are kept unique.
* |Symbol_Properties|::        Each symbol has a property list
                               for recording miscellaneous information.

==============================================================================
File: elisp.info,  Node: |Symbol_Components|,  Next: |Definitions|,  Up: |Symbols|
==============================================================================

                                                             *Symbol_Components*

9.1 Symbol Components
---------------------

Each symbol has four components (or "cells"), each of which references
another object:

Print name
     The symbol's name.

Value
     The symbol's current value as a variable.

Function
     The symbol's function definition.  It can also hold a symbol, a
     keymap, or a keyboard macro.

Property list
     The symbol's property list.

The print name cell always holds a string, and cannot be changed.  Each
of the other three cells can be set to any Lisp object.

   The print name cell holds the string that is the name of a symbol.
Since symbols are represented textually by their names, it is important
not to have two symbols with the same name.  The Lisp reader ensures
this: every time it reads a symbol, it looks for an existing symbol with
the specified name before it creates a new one.  To get a symbol's name,
use the function 'symbol-name' (*note Creating Symbols::).

   The value cell holds a symbol's value as a variable, which is what
you get if the symbol itself is evaluated as a Lisp expression.  *Note
Variables::, for details about how values are set and retrieved,
including complications such as "local bindings" and "scoping rules".
Most symbols can have any Lisp object as a value, but certain special
symbols have values that cannot be changed; these include 'nil' and 't',
and any symbol whose name starts with ':' (those are called "keywords").
*Note Constant Variables::.

   The function cell holds a symbol's function definition.  Often, we
refer to "the function 'foo'" when we really mean the function stored in
the function cell of 'foo'; we make the distinction explicit only when
necessary.  Typically, the function cell is used to hold a function
(*note Functions::) or a macro (*note Macros::).  However, it can also
be used to hold a symbol (*note Function Indirection::), keyboard macro
(*note Keyboard Macros::), keymap (*note Keymaps::), or autoload object
(*note Autoloading::).  To get the contents of a symbol's function cell,
use the function 'symbol-function' (*note Function Cells::).

   The property list cell normally should hold a correctly formatted
property list.  To get a symbol's property list, use the function
'symbol-plist'.  *Note Symbol Properties::.

   The function cell or the value cell may be "void", which means that
the cell does not reference any object.  (This is not the same thing as
holding the symbol 'void', nor the same as holding the symbol 'nil'.)
Examining a function or value cell that is void results in an error,
such as 'Symbol's value as variable is void'.

   Because each symbol has separate value and function cells, variables
names and function names do not conflict.  For example, the symbol
'buffer-file-name' has a value (the name of the file being visited in
the current buffer) as well as a function definition (a primitive
function that returns the name of the file):

     buffer-file-name
          => "/gnu/elisp/symbols.texi"
     (symbol-function 'buffer-file-name)
          => #<subr buffer-file-name>

==============================================================================
File: elisp.info,  Node: |Definitions|,  Next: |Creating_Symbols|,  Prev: |Symbol_Components|,  Up: |Symbols|
==============================================================================

                                                                   *Definitions*

9.2 Defining Symbols
--------------------

A "definition" is a special kind of Lisp expression that announces your
intention to use a symbol in a particular way.  It typically specifies a
value or meaning for the symbol for one kind of use, plus documentation
for its meaning when used in this way.  Thus, when you define a symbol
as a variable, you can supply an initial value for the variable, plus
documentation for the variable.

   'defvar' and 'defconst' are special forms that define a symbol as a
"global variable"--a variable that can be accessed at any point in a Lisp
program.  *Note Variables::, for details about variables.  To define a
customizable variable, use the 'defcustom' macro, which also calls
'defvar' as a subroutine (*note Customization::).

   In principle, you can assign a variable value to any symbol with
'setq', whether or not it has first been defined as a variable.
However, you ought to write a variable definition for each global
variable that you want to use; otherwise, your Lisp program may not act
correctly if it is evaluated with lexical scoping enabled (*note
Variable Scoping::).

   'defun' defines a symbol as a function, creating a lambda expression
and storing it in the function cell of the symbol.  This lambda
expression thus becomes the function definition of the symbol.  (The
term "function definition", meaning the contents of the function cell,
is derived from the idea that 'defun' gives the symbol its definition as
a function.)  'defsubst' and 'defalias' are two other ways of defining a
function.  *Note Functions::.

   'defmacro' defines a symbol as a macro.  It creates a macro object
and stores it in the function cell of the symbol.  Note that a given
symbol can be a macro or a function, but not both at once, because both
macro and function definitions are kept in the function cell, and that
cell can hold only one Lisp object at any given time.  *Note Macros::.

   As previously noted, Emacs Lisp allows the same symbol to be defined
both as a variable (e.g., with 'defvar') and as a function or macro
(e.g., with 'defun').  Such definitions do not conflict.

   These definitions also act as guides for programming tools.  For
example, the 'C-h f' and 'C-h v' commands create help buffers containing
links to the relevant variable, function, or macro definitions.  *Note
(emacs)Name Help::.

==============================================================================
File: elisp.info,  Node: |Creating_Symbols|,  Next: |Symbol_Properties|,  Prev: |Definitions|,  Up: |Symbols|
==============================================================================

                                                              *Creating_Symbols*

9.3 Creating and Interning Symbols
----------------------------------

To understand how symbols are created in GNU Emacs Lisp, you must know
how Lisp reads them.  Lisp must ensure that it finds the same symbol
every time it reads the same set of characters.  Failure to do so would
cause complete confusion.

   When the Lisp reader encounters a symbol, it reads all the characters
of the name.  Then it hashes those characters to find an index in a
table called an "obarray".  Hashing is an efficient method of looking
something up.  For example, instead of searching a telephone book cover
to cover when looking up Jan Jones, you start with the J's and go from
there.  That is a simple version of hashing.  Each element of the
obarray is a "bucket" which holds all the symbols with a given hash
code; to look for a given name, it is sufficient to look through all the
symbols in the bucket for that name's hash code.  (The same idea is used
for general Emacs hash tables, but they are a different data type; see
*note Hash Tables::.)

   If a symbol with the desired name is found, the reader uses that
symbol.  If the obarray does not contain a symbol with that name, the
reader makes a new symbol and adds it to the obarray.  Finding or adding
a symbol with a certain name is called "interning" it, and the symbol is
then called an "interned symbol".

   Interning ensures that each obarray has just one symbol with any
particular name.  Other like-named symbols may exist, but not in the
same obarray.  Thus, the reader gets the same symbols for the same
names, as long as you keep reading with the same obarray.

   Interning usually happens automatically in the reader, but sometimes
other programs need to do it.  For example, after the 'M-x' command
obtains the command name as a string using the minibuffer, it then
interns the string, to get the interned symbol with that name.

   No obarray contains all symbols; in fact, some symbols are not in any
obarray.  They are called "uninterned symbols".  An uninterned symbol
has the same four cells as other symbols; however, the only way to gain
access to it is by finding it in some other object or as the value of a
variable.

   Creating an uninterned symbol is useful in generating Lisp code,
because an uninterned symbol used as a variable in the code you generate
cannot clash with any variables used in other Lisp programs.

   In Emacs Lisp, an obarray is actually a vector.  Each element of the
vector is a bucket; its value is either an interned symbol whose name
hashes to that bucket, or 0 if the bucket is empty.  Each interned
symbol has an internal link (invisible to the user) to the next symbol
in the bucket.  Because these links are invisible, there is no way to
find all the symbols in an obarray except using 'mapatoms' (below).  The
order of symbols in a bucket is not significant.

   In an empty obarray, every element is 0, so you can create an obarray
with '(make-vector LENGTH 0)'.  *This is the only valid way to create an
obarray.*  Prime numbers as lengths tend to result in good hashing;
lengths one less than a power of two are also good.

   *Do not try to put symbols in an obarray yourself.*  This does not
work--only 'intern' can enter a symbol in an obarray properly.

     Common Lisp note: Unlike Common Lisp, Emacs Lisp does not provide
     for interning a single symbol in several obarrays.

   Most of the functions below take a name and sometimes an obarray as
arguments.  A 'wrong-type-argument' error is signaled if the name is not
a string, or if the obarray is not a vector.

 -- Function: symbol-name symbol
     This function returns the string that is SYMBOL's name.  For
     example:

          (symbol-name 'foo)
               => "foo"

     Warning: Changing the string by substituting characters does
     change the name of the symbol, but fails to update the obarray, so
     don't do it!

 -- Function: make-symbol name
     This function returns a newly-allocated, uninterned symbol whose
     name is NAME (which must be a string).  Its value and function
     definition are void, and its property list is 'nil'.  In the
     example below, the value of 'sym' is not 'eq' to 'foo' because it
     is a distinct uninterned symbol whose name is also 'foo'.

          (setq sym (make-symbol "foo"))
               => foo
          (eq sym 'foo)
               => nil

 -- Function: gensym &optional prefix
     This function returns a symbol using 'make-symbol', whose name is
     made by appending 'gensym-counter' to PREFIX.  The prefix defaults
     to '"g"'.

 -- Function: intern name &optional obarray
     This function returns the interned symbol whose name is NAME.  If
     there is no such symbol in the obarray OBARRAY, 'intern' creates a
     new one, adds it to the obarray, and returns it.  If OBARRAY is
     omitted, the value of the global variable 'obarray' is used.

          (setq sym (intern "foo"))
               => foo
          (eq sym 'foo)
               => t

          (setq sym1 (intern "foo" other-obarray))
               => foo
          (eq sym1 'foo)
               => nil

     Common Lisp note: In Common Lisp, you can intern an existing symbol
     in an obarray.  In Emacs Lisp, you cannot do this, because the
     argument to 'intern' must be a string, not a symbol.

 -- Function: intern-soft name &optional obarray
     This function returns the symbol in OBARRAY whose name is NAME, or
     'nil' if OBARRAY has no symbol with that name.  Therefore, you can
     use 'intern-soft' to test whether a symbol with a given name is
     already interned.  If OBARRAY is omitted, the value of the global
     variable 'obarray' is used.

     The argument NAME may also be a symbol; in that case, the function
     returns NAME if NAME is interned in the specified obarray, and
     otherwise 'nil'.

          (intern-soft "frazzle")        ; No such symbol exists.
               => nil
          (make-symbol "frazzle")        ; Create an uninterned one.
               => frazzle
          (intern-soft "frazzle")        ; That one cannot be found.
               => nil
          (setq sym (intern "frazzle"))  ; Create an interned one.
               => frazzle
          (intern-soft "frazzle")        ; That one can be found!
               => frazzle
          (eq sym 'frazzle)              ; And it is the same one.
               => t

 -- Variable: obarray
     This variable is the standard obarray for use by 'intern' and
     'read'.

 -- Function: mapatoms function &optional obarray
     This function calls FUNCTION once with each symbol in the obarray
     OBARRAY.  Then it returns 'nil'.  If OBARRAY is omitted, it
     defaults to the value of 'obarray', the standard obarray for
     ordinary symbols.

          (setq count 0)
               => 0
          (defun count-syms (s)
            (setq count (1+ count)))
               => count-syms
          (mapatoms 'count-syms)
               => nil
          count
               => 1871

     See 'documentation' in *note Accessing Documentation::, for another
     example using 'mapatoms'.

 -- Function: unintern symbol obarray
     This function deletes SYMBOL from the obarray OBARRAY.  If 'symbol'
     is not actually in the obarray, 'unintern' does nothing.  If
     OBARRAY is 'nil', the current obarray is used.

     If you provide a string instead of a symbol as SYMBOL, it stands
     for a symbol name.  Then 'unintern' deletes the symbol (if any) in
     the obarray which has that name.  If there is no such symbol,
     'unintern' does nothing.

     If 'unintern' does delete a symbol, it returns 't'.  Otherwise it
     returns 'nil'.

==============================================================================
File: elisp.info,  Node: |Symbol_Properties|,  Prev: |Creating_Symbols|,  Up: |Symbols|
==============================================================================

                                                             *Symbol_Properties*

9.4 Symbol Properties
---------------------

A symbol may possess any number of "symbol properties", which can be
used to record miscellaneous information about the symbol.  For example,
when a symbol has a 'risky-local-variable' property with a non-'nil'
value, that means the variable which the symbol names is a risky
file-local variable (*note File Local Variables::).

   Each symbol's properties and property values are stored in the
symbol's property list cell (*note Symbol Components::), in the form of
a property list (*note Property Lists::).

MENU

* |Symbol_Plists|::        Accessing symbol properties.
* |Standard_Properties|::  Standard meanings of symbol properties.

==============================================================================
File: elisp.info,  Node: |Symbol_Plists|,  Next: |Standard_Properties|,  Up: |Symbol_Properties|
==============================================================================

                                                                 *Symbol_Plists*

9.4.1 Accessing Symbol Properties
---------------------------------

The following functions can be used to access symbol properties.

 -- Function: get symbol property
     This function returns the value of the property named PROPERTY in
     SYMBOL's property list.  If there is no such property, it returns
     'nil'.  Thus, there is no distinction between a value of 'nil' and
     the absence of the property.

     The name PROPERTY is compared with the existing property names
     using 'eq', so any object is a legitimate property.

     See 'put' for an example.

 -- Function: put symbol property value
     This function puts VALUE onto SYMBOL's property list under the
     property name PROPERTY, replacing any previous property value.  The
     'put' function returns VALUE.

          (put 'fly 'verb 'transitive)
               =>'transitive
          (put 'fly 'noun '(a buzzing little bug))
               => (a buzzing little bug)
          (get 'fly 'verb)
               => transitive
          (symbol-plist 'fly)
               => (verb transitive noun (a buzzing little bug))

 -- Function: symbol-plist symbol
     This function returns the property list of SYMBOL.

 -- Function: setplist symbol plist
     This function sets SYMBOL's property list to PLIST.  Normally,
     PLIST should be a well-formed property list, but this is not
     enforced.  The return value is PLIST.

          (setplist 'foo '(a 1 b (2 3) c nil))
               => (a 1 b (2 3) c nil)
          (symbol-plist 'foo)
               => (a 1 b (2 3) c nil)

     For symbols in special obarrays, which are not used for ordinary
     purposes, it may make sense to use the property list cell in a
     nonstandard fashion; in fact, the abbrev mechanism does so (*note
     Abbrevs::).

     You could define 'put' in terms of 'setplist' and 'plist-put', as
     follows:

          (defun put (symbol prop value)
            (setplist symbol
                      (plist-put (symbol-plist symbol) prop value)))

 -- Function: function-get symbol property &optional autoload
     This function is identical to 'get', except that if SYMBOL is the
     name of a function alias, it looks in the property list of the
     symbol naming the actual function.  *Note Defining Functions::.  If
     the optional argument AUTOLOAD is non-'nil', and SYMBOL is
     auto-loaded, this function will try to autoload it, since
     autoloading might set PROPERTY of SYMBOL.  If AUTOLOAD is the
     symbol 'macro', only try autoloading if SYMBOL is an auto-loaded
     macro.

 -- Function: function-put function property value
     This function sets PROPERTY of FUNCTION to VALUE.  FUNCTION should
     be a symbol.  This function is preferred to calling 'put' for
     setting properties of a function, because it will allow us some day
     to implement remapping of old properties to new ones.

==============================================================================
File: elisp.info,  Node: |Standard_Properties|,  Prev: |Symbol_Plists|,  Up: Symbol Properties
==============================================================================

                                                           *Standard_Properties*

9.4.2 Standard Symbol Properties
--------------------------------

Here, we list the symbol properties which are used for special purposes
in Emacs.  In the following table, whenever we say "the named function",
that means the function whose name is the relevant symbol; similarly for
"the named variable" etc.

':advertised-binding'
     This property value specifies the preferred key binding, when
     showing documentation, for the named function.  *Note Keys in
     Documentation::.

'char-table-extra-slots'
     The value, if non-'nil', specifies the number of extra slots in the
     named char-table type.  *Note Char-Tables::.

'customized-face'
'face-defface-spec'
'saved-face'
'theme-face'
     These properties are used to record a face's standard, saved,
     customized, and themed face specs.  Do not set them directly; they
     are managed by 'defface' and related functions.  *Note Defining
     Faces::.

'customized-value'
'saved-value'
'standard-value'
'theme-value'
     These properties are used to record a customizable variable's
     standard value, saved value, customized-but-unsaved value, and
     themed values.  Do not set them directly; they are managed by
     'defcustom' and related functions.  *Note Variable Definitions::.

'disabled'
     If the value is non-'nil', the named function is disabled as a
     command.  *Note Disabling Commands::.

'face-documentation'
     The value stores the documentation string of the named face.  This
     is set automatically by 'defface'.  *Note Defining Faces::.

'history-length'
     The value, if non-'nil', specifies the maximum minibuffer history
     length for the named history list variable.  *Note Minibuffer
     History::.

'interactive-form'
     The value is an interactive form for the named function.  Normally,
     you should not set this directly; use the 'interactive' special
     form instead.  *Note Interactive Call::.

'menu-enable'
     The value is an expression for determining whether the named menu
     item should be enabled in menus.  *Note Simple Menu Items::.

'mode-class'
     If the value is 'special', the named major mode is special.  *Note
     Major Mode Conventions::.

'permanent-local'
     If the value is non-'nil', the named variable is a buffer-local
     variable whose value should not be reset when changing major modes.
     *Note Creating Buffer-Local::.

'permanent-local-hook'
     If the value is non-'nil', the named function should not be deleted
     from the local value of a hook variable when changing major modes.
     *Note Setting Hooks::.

'pure'
     If the value is non-'nil', the named function is considered to be
     pure (*note What Is a Function::).  Calls with constant arguments
     can be evaluated at compile time.  This may shift run time errors
     to compile time.  Not to be confused with pure storage (*note Pure
     Storage::).

'risky-local-variable'
     If the value is non-'nil', the named variable is considered risky
     as a file-local variable.  *Note File Local Variables::.

'safe-function'
     If the value is non-'nil', the named function is considered
     generally safe for evaluation.  *Note Function Safety::.

'safe-local-eval-function'
     If the value is non-'nil', the named function is safe to call in
     file-local evaluation forms.  *Note File Local Variables::.
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
