rectangle.

   'M-x delete-whitespace-rectangle' deletes horizontal whitespace
starting from a particular column.  This applies to each of the lines in
the rectangle, and the column is specified by the left edge of the
rectangle.  The right edge of the rectangle does not make any difference
to this command.

   The command 'C-x r N' ('rectangle-number-lines') inserts line numbers
along the left edge of the region-rectangle.  Normally, the numbering
begins from 1 (for the first line of the rectangle).  With a prefix
argument, the command prompts for a number to begin from, and for a
format string with which to print the numbers (*note (elisp)Formatting
Strings::).

   The command 'C-x r t' ('string-rectangle') replaces the contents of a
region-rectangle with a string on each line.  The string's width need
not be the same as the width of the rectangle.  If the string's width is
less, the text after the rectangle shifts left; if the string is wider
than the rectangle, the text after the rectangle shifts right.

   The command 'M-x string-insert-rectangle' is similar to
'string-rectangle', but inserts the string on each line, shifting the
original text to the right.

   The command 'C-x <SPC>' ('rectangle-mark-mode') toggles whether the
region-rectangle or the standard region is highlighted (first activating
the region if necessary).  When this mode is enabled, commands that
resize the region ('C-f', 'C-n' etc.) do so in a rectangular fashion,
and killing and yanking operate on the rectangle.  *Note Killing::.  The
mode persists only as long as the region is active.

   Unlike the standard region, the region-rectangle can have its corners
extended past the end of buffer, or inside stretches of white space that
point normally cannot enter, like in the middle of a TAB character.

   When the region is in rectangle-mark-mode, 'C-x C-x' runs the command
'rectangle-exchange-point-and-mark', which cycles between the four
corners of the region-rectangle.  This comes in handy if you want to
modify the dimensions of the region-rectangle before invoking an
operation on the marked text.

==============================================================================
File: emacs.info,  Node: |CUA_Bindings|,  Prev: |Rectangles|,  Up: |Killing|
==============================================================================

                                                                  *CUA_Bindings*

12.6 CUA Bindings
-----------------

The command 'M-x cua-mode' sets up key bindings that are compatible with
the Common User Access (CUA) system used in many other applications.

   When CUA mode is enabled, the keys 'C-x', 'C-c', 'C-v', and 'C-z'
invoke commands that cut (kill), copy, paste (yank), and undo
respectively.  The 'C-x' and 'C-c' keys perform cut and copy only if the
region is active.  Otherwise, they still act as prefix keys, so that
standard Emacs commands like 'C-x C-c' still work.  Note that this means
the variable 'mark-even-if-inactive' has no effect for 'C-x' and 'C-c'
(*note Using Region::).

   To enter an Emacs command like 'C-x C-f' while the mark is active,
use one of the following methods: either hold 'Shift' together with the
prefix key, e.g., 'S-C-x C-f', or quickly type the prefix key twice,
e.g., 'C-x C-x C-f'.

   To disable the overriding of standard Emacs binding by CUA mode,
while retaining the other features of CUA mode described below, set the
variable 'cua-enable-cua-keys' to 'nil'.

   CUA mode by default activates Delete-Selection mode (*note Mouse
Commands::) so that typed text replaces the active region.  To use CUA
without this behavior, set the variable 'cua-delete-selection' to 'nil'.

   CUA mode provides enhanced rectangle support with visible rectangle
highlighting.  Use 'C-<RET>' to start a rectangle, extend it using the
movement commands, and cut or copy it using 'C-x' or 'C-c'.  <RET> moves
the cursor to the next (clockwise) corner of the rectangle, so you can
easily expand it in any direction.  Normal text you type is inserted to
the left or right of each line in the rectangle (on the same side as the
cursor).

   You can use this rectangle support without activating CUA by calling
the 'cua-rectangle-mark-mode' command.  There's also the standard
command 'rectangle-mark-mode', see *note Rectangles::.

   With CUA you can easily copy text and rectangles into and out of
registers by providing a one-digit numeric prefix to the kill, copy, and
yank commands, e.g., 'C-1 C-c' copies the region into register '1', and
'C-2 C-v' yanks the contents of register '2'.

   CUA mode also has a global mark feature which allows easy moving and
copying of text between buffers.  Use 'C-S-<SPC>' to toggle the global
mark on and off.  When the global mark is on, all text that you kill or
copy is automatically inserted at the global mark, and text you type is
inserted at the global mark rather than at the current position.

   For example, to copy words from various buffers into a word list in a
given buffer, set the global mark in the target buffer, then navigate to
each of the words you want in the list, mark it (e.g., with 'S-M-f'),
copy it to the list with 'C-c' or 'M-w', and insert a newline after the
word in the target list by pressing <RET>.

==============================================================================
File: emacs.info,  Node: |Registers|,  Next: |Display|,  Prev: |Killing|,  Up: |Top|
==============================================================================

                                                                     *Registers*

13 Registers
============

Emacs "registers" are compartments where you can save text, rectangles,
positions, and other things for later use.  Once you save text or a
rectangle in a register, you can copy it into the buffer once or many
times; once you save a position in a register, you can jump back to that
position once or many times.

   Each register has a name that consists of a single character, which
we will denote by R; R can be a letter (such as 'a') or a number (such
as '1'); case matters, so register 'a' is not the same as register 'A'.
You can also set a register in non-alphanumeric characters, for instance
'*' or 'C-d'.  Note, it's not possible to set a register in 'C-g' or
'ESC', because these keys are reserved for quitting (*note Quitting::).

   A register can store a position, a piece of text, a rectangle, a
number, a window configuration, or a file name, but only one thing at
any given time.  Whatever you store in a register remains there until
you store something else in that register.  To see what register R
contains, use 'M-x view-register':

'M-x view-register <RET> R'
     Display a description of what register R contains.

   All of the commands that prompt for a register will display a preview
window that lists the existing registers (if there are any) after a
short delay.  To change the length of the delay, customize
'register-preview-delay'.  To prevent this display, set that option to
'nil'.  You can explicitly request a preview window by pressing 'C-h' or
<F1>.

   "Bookmarks" record files and positions in them, so you can return to
those positions when you look at the file again.  Bookmarks are similar
in spirit to registers, so they are also documented in this chapter.

MENU

* |Position_Registers|::       Saving positions in registers.
* |Text_Registers|::           Saving text in registers.
* |Rectangle_Registers|::      Saving rectangles in registers.
* |Configuration_Registers|::  Saving window configurations in registers.
* |Number_Registers|::         Numbers in registers.
* |File_Registers|::           File names in registers.
* |Keyboard_Macro_Registers|:: Keyboard macros in registers.
* |Bookmarks|::                Bookmarks are like registers, but persistent.

==============================================================================
File: emacs.info,  Node: |Position_Registers|,  Next: |Text_Registers|,  Up: |Registers|
==============================================================================

                                                            *Position_Registers*

13.1 Saving Positions in Registers
----------------------------------

'C-x r <SPC> R'
     Record the position of point and the current buffer in register R
     ('point-to-register').
'C-x r j R'
     Jump to the position and buffer saved in register R
     ('jump-to-register').

   Typing 'C-x r <SPC>' ('point-to-register'), followed by a character
'R', saves both the position of point and the current buffer in register
R.  The register retains this information until you store something else
in it.

   The command 'C-x r j R' switches to the buffer recorded in register
R, pushes a mark, and moves point to the recorded position.  (The mark
is not pushed if point was already at the recorded position, or in
successive calls to the command.)  The contents of the register are not
changed, so you can jump to the saved position any number of times.

   If you use 'C-x r j' to go to a saved position, but the buffer it was
saved from has been killed, 'C-x r j' tries to create the buffer again
by visiting the same file.  Of course, this works only for buffers that
were visiting files.

==============================================================================
File: emacs.info,  Node: |Text_Registers|,  Next: |Rectangle_Registers|,  Prev: |Position_Registers|,  Up: |Registers|
==============================================================================

                                                                *Text_Registers*

13.2 Saving Text in Registers
-----------------------------

When you want to insert a copy of the same piece of text several times,
it may be inconvenient to yank it from the kill ring, since each
subsequent kill moves that entry further down the ring.  An alternative
is to store the text in a register and later retrieve it.

'C-x r s R'
     Copy region into register R ('copy-to-register').
'C-x r i R'
     Insert text from register R ('insert-register').
'M-x append-to-register <RET> R'
     Append region to text in register R.

     When register R contains text, you can use 'C-x r +'
     ('increment-register') to append to that register.  Note that
     command 'C-x r +' behaves differently if R contains a number.
     *Note Number Registers::.

'M-x prepend-to-register <RET> R'
     Prepend region to text in register R.

   'C-x r s R' stores a copy of the text of the region into the register
named R.  If the mark is inactive, Emacs first reactivates the mark
where it was last set.  The mark is deactivated at the end of this
command.  *Note Mark::.  'C-u C-x r s R', the same command with a prefix
argument, copies the text into register R and deletes the text from the
buffer as well; you can think of this as moving the region text into the
register.

   'M-x append-to-register <RET> R' appends the copy of the text in the
region to the text already stored in the register named R.  If invoked
with a prefix argument, it deletes the region after appending it to the
register.  The command 'prepend-to-register' is similar, except that it
_prepends_ the region text to the text in the register instead of
_appending_ it.

   When you are collecting text using 'append-to-register' and
'prepend-to-register', you may want to separate individual collected
pieces using a separator.  In that case, configure a
'register-separator' and store the separator text in to that register.
For example, to get double newlines as text separator during the
collection process, you can use the following setting.

     (setq register-separator ?+)
     (set-register register-separator "\n\n")

   'C-x r i R' inserts in the buffer the text from register R.  Normally
it leaves point after the text and sets the mark before, without
activating it.  With a prefix argument, it instead puts point before the
text and the mark after.

==============================================================================
File: emacs.info,  Node: |Rectangle_Registers|,  Next: |Configuration_Registers|,  Prev: |Text_Registers|,  Up: |Registers|
==============================================================================

                                                           *Rectangle_Registers*

13.3 Saving Rectangles in Registers
-----------------------------------

A register can contain a rectangle instead of linear text.  *Note
Rectangles::, for basic information on how to specify a rectangle in the
buffer.

'C-x r r R'
     Copy the region-rectangle into register R
     ('copy-rectangle-to-register').  With prefix argument, delete it as
     well.
'C-x r i R'
     Insert the rectangle stored in register R (if it contains a
     rectangle) ('insert-register').

   The 'C-x r i R' ('insert-register') command, previously documented in
*note Text Registers::, inserts a rectangle rather than a text string,
if the register contains a rectangle.

==============================================================================
File: emacs.info,  Node: |Configuration_Registers|,  Next: |Number_Registers|,  Prev: |Rectangle_Registers|,  Up: |Registers|
==============================================================================

                                                       *Configuration_Registers*

13.4 Saving Window Configurations in Registers
----------------------------------------------

You can save the window configuration of the selected frame in a
register, or even the configuration of all windows in all frames, and
restore the configuration later.  *Note Windows::, for information about
window configurations.

'C-x r w R'
     Save the state of the selected frame's windows in register R
     ('window-configuration-to-register').
'C-x r f R'
     Save the state of all frames, including all their windows, in
     register R ('frameset-to-register').

   Use 'C-x r j R' to restore a window or frame configuration.  This is
the same command used to restore a cursor position.  When you restore a
frame configuration, any existing frames not included in the
configuration become invisible.  If you wish to delete these frames
instead, use 'C-u C-x r j R'.

==============================================================================
File: emacs.info,  Node: |Number_Registers|,  Next: |File_Registers|,  Prev: |Configuration_Registers|,  Up: |Registers|
==============================================================================

                                                              *Number_Registers*

13.5 Keeping Numbers in Registers
---------------------------------

There are commands to store a number in a register, to insert the number
in the buffer in decimal, and to increment it.  These commands can be
useful in keyboard macros (*note Keyboard Macros::).

'C-u NUMBER C-x r n R'
     Store NUMBER into register R ('number-to-register').
'C-u NUMBER C-x r + R'
     If R contains a number, increment the number in that register by
     NUMBER.  Note that command 'C-x r +' ('increment-register') behaves
     differently if R contains text.  *Note Text Registers::.
'C-x r i R'
     Insert the number from register R into the buffer.

   'C-x r i' is the same command used to insert any other sort of
register contents into the buffer.  'C-x r +' with no numeric argument
increments the register value by 1; 'C-x r n' with no numeric argument
stores zero in the register.

==============================================================================
File: emacs.info,  Node: |File_Registers|,  Next: |Keyboard_Macro_Registers|,  Prev: |Number_Registers|,  Up: |Registers|
==============================================================================

                                                                *File_Registers*

13.6 Keeping File Names in Registers
------------------------------------

If you visit certain file names frequently, you can visit them more
conveniently if you put their names in registers.  Here's the Lisp code
used to put a file NAME into register R:

     (set-register R '(file . NAME))

For example,

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

puts the file name shown in register 'z'.

   To visit the file whose name is in register R, type 'C-x r j R'.
(This is the same command used to jump to a position or restore a frame
configuration.)

==============================================================================
File: emacs.info,  Node: |Keyboard_Macro_Registers|,  Next: |Bookmarks|,  Prev: |File_Registers|,  Up: |Registers|
==============================================================================

                                                      *Keyboard_Macro_Registers*

13.7 Keyboard Macro Registers
-----------------------------

If you need to execute a keyboard macro (*note Keyboard Macros::)
frequently, it is more convenient to put it in a register or save it
(*note Save Keyboard Macro::).  'C-x C-k x R' ('kmacro-to-register')
stores the last keyboard macro in register R.

   To execute the keyboard macro in register R, type 'C-x r j R'.  (This
is the same command used to jump to a position or restore a frameset.)

==============================================================================
File: emacs.info,  Node: |Bookmarks|,  Prev: |Keyboard_Macro_Registers|,  Up: |Registers|
==============================================================================

                                                                     *Bookmarks*

13.8 Bookmarks
--------------

"Bookmarks" are somewhat like registers in that they record positions
you can jump to.  Unlike registers, they have long names, and they
persist automatically from one Emacs session to the next.  The
prototypical use of bookmarks is to record where you were reading in
various files.

'C-x r m <RET>'
     Set the bookmark for the visited file, at point.

'C-x r m BOOKMARK <RET>'
     Set the bookmark named BOOKMARK at point ('bookmark-set').

'C-x r M BOOKMARK <RET>'
     Like 'C-x r m', but don't overwrite an existing bookmark.

'C-x r b BOOKMARK <RET>'
     Jump to the bookmark named BOOKMARK ('bookmark-jump').

'C-x r l'
     List all bookmarks ('list-bookmarks').

'M-x bookmark-save'
     Save all the current bookmark values in the default bookmark file.

   To record the current position in the visited file, use the command
'C-x r m', which sets a bookmark using the visited file name as the
default for the bookmark name.  If you name each bookmark after the file
it points to, then you can conveniently revisit any of those files with
'C-x r b', and move to the position of the bookmark at the same time.

   The command 'C-x r M' ('bookmark-set-no-overwrite') works like
'C-x r m', but it signals an error if the specified bookmark already
exists, instead of overwriting it.

   To display a list of all your bookmarks in a separate buffer, type
'C-x r l' ('list-bookmarks').  If you switch to that buffer, you can use
it to edit your bookmark definitions or annotate the bookmarks.  Type
'C-h m' in the bookmark buffer for more information about its special
editing commands.

   When you kill Emacs, Emacs saves your bookmarks, if you have changed
any bookmark values.  You can also save the bookmarks at any time with
the 'M-x bookmark-save' command.  Bookmarks are saved to the file
'~/.emacs.d/bookmarks' (for compatibility with older versions of Emacs,
if you have a file named '~/.emacs.bmk', that is used instead).  The
bookmark commands load your default bookmark file automatically.  This
saving and loading is how bookmarks persist from one Emacs session to
the next.

   If you set the variable 'bookmark-save-flag' to 1, each command that
sets a bookmark will also save your bookmarks; this way, you don't lose
any bookmark values even if Emacs crashes.  The value, if a number, says
how many bookmark modifications should go by between saving.  If you set
this variable to 'nil', Emacs only saves bookmarks if you explicitly use
'M-x bookmark-save'.

   The variable 'bookmark-default-file' specifies the file in which to
save bookmarks by default.

   If you set the variable 'bookmark-use-annotations' to 't', setting a
bookmark will query for an annotation.  If a bookmark has an annotation,
it is automatically shown in a separate window when you jump to the
bookmark.

   Bookmark position values are saved with surrounding context, so that
'bookmark-jump' can find the proper position even if the file is
modified slightly.  The variable 'bookmark-search-size' says how many
characters of context to record on each side of the bookmark's position.

   Here are some additional commands for working with bookmarks:

'M-x bookmark-load <RET> FILENAME <RET>'
     Load a file named FILENAME that contains a list of bookmark values.
     You can use this command, as well as 'bookmark-write', to work with
     other files of bookmark values in addition to your default bookmark
     file.

'M-x bookmark-write <RET> FILENAME <RET>'
     Save all the current bookmark values in the file FILENAME.

'M-x bookmark-delete <RET> BOOKMARK <RET>'
     Delete the bookmark named BOOKMARK.

'M-x bookmark-insert-location <RET> BOOKMARK <RET>'
     Insert in the buffer the name of the file that bookmark BOOKMARK
     points to.

'M-x bookmark-insert <RET> BOOKMARK <RET>'
     Insert in the buffer the _contents_ of the file that bookmark
     BOOKMARK points to.

==============================================================================
File: emacs.info,  Node: |Display|,  Next: |Search|,  Prev: |Registers|,  Up: |Top|
==============================================================================

                                                                       *Display*

14 Controlling the Display
==========================

Since only part of a large buffer fits in the window, Emacs has to show
only a part of it.  This chapter describes commands and variables that
let you specify which part of the text you want to see, and how the text
is displayed.

MENU

* |Scrolling|::              Commands to move text up and down in a window.
* |Recentering|::            A scroll command that centers the current line.
* |Auto_Scrolling|::         Redisplay scrolls text automatically when needed.
* |Horizontal_Scrolling|::   Moving text left and right in a window.
* |Narrowing|::              Restricting display and editing to a portion
                             of the buffer.
* |View_Mode|::              Viewing read-only buffers.
* |Follow_Mode|::            Follow mode lets two windows scroll as one.
* |Faces|::                  How to change the display style using faces.
* |Colors|::                 Specifying colors for faces.
* |Standard_Faces|::         The main predefined faces.
* |Text_Scale|::             Increasing or decreasing text size in a buffer.
* |Font_Lock|::              Minor mode for syntactic highlighting using faces.
* |Highlight_Interactively|:: Tell Emacs what text to highlight.
* |Fringes|::                Enabling or disabling window fringes.
* |Displaying_Boundaries|::  Displaying top and bottom of the buffer.
* |Useless_Whitespace|::     Showing possibly spurious trailing whitespace.
* |Selective_Display|::      Hiding lines with lots of indentation.
* |Optional_Mode_Line|::     Optional mode line display features.
* |Text_Display|::           How text characters are normally displayed.
* |Cursor_Display|::         Features for displaying the cursor.
* |Line_Truncation|::        Truncating lines to fit the screen width instead
                             of continuing them to multiple screen lines.
* |Visual_Line_Mode|::       Word wrap and screen line-based editing.
* |Display_Custom|::         Information on variables for customizing display.

==============================================================================
File: emacs.info,  Node: |Scrolling|,  Next: |Recentering|,  Up: |Display|
==============================================================================

                                                                     *Scrolling*

14.1 Scrolling
--------------

If a window is too small to display all the text in its buffer, it
displays only a portion of it.  "Scrolling" commands change which
portion of the buffer is displayed.

   Scrolling forward or up advances the portion of the buffer displayed
in the window; equivalently, it moves the buffer text upwards relative
to the window.  Scrolling backward or down displays an earlier portion
of the buffer, and moves the text downwards relative to the window.

   In Emacs, scrolling up or down refers to the direction that the text
moves in the window, _not_ the direction that the window moves relative
to the text.  This terminology was adopted by Emacs before the modern
meaning of "scrolling up" and "scrolling down" became widespread.
Hence, the strange result that <PageDown> scrolls up in the Emacs sense.

   The portion of a buffer displayed in a window always contains point.
If you move point past the bottom or top of the window, scrolling occurs
automatically to bring it back onscreen (*note Auto Scrolling::).  You
can also scroll explicitly with these commands:

'C-v'
'<PageDown>'
'<next>'
     Scroll forward by nearly a full window ('scroll-up-command').
'M-v'
'<PageUp>'
'<prior>'
     Scroll backward ('scroll-down-command').

   'C-v' ('scroll-up-command') scrolls forward by nearly the whole
window height.  The effect is to take the two lines at the bottom of the
window and put them at the top, followed by lines that were not
previously visible.  If point was in the text that scrolled off the top,
it ends up on the window's new topmost line.  The <PageDown> (or <next>)
key is equivalent to 'C-v'.

   'M-v' ('scroll-down-command') scrolls backward in a similar way.  The
<PageUp> (or <prior>) key is equivalent to 'M-v'.

   The number of lines of overlap left by these scroll commands is
controlled by the variable 'next-screen-context-lines', whose default
value is 2.  You can supply the commands with a numeric prefix argument,
N, to scroll by N lines; Emacs attempts to leave point unchanged, so
that the text and point move up or down together.  'C-v' with a negative
argument is like 'M-v' and vice versa.

   By default, these commands signal an error (by beeping or flashing
the screen) if no more scrolling is possible, because the window has
reached the beginning or end of the buffer.  If you change the variable
'scroll-error-top-bottom' to 't', these commands move point to the
farthest possible position.  If point is already there, the commands
signal an error.

   Some users like scroll commands to keep point at the same screen
position, so that scrolling back to the same screen conveniently returns
point to its original position.  You can enable this behavior via the
variable 'scroll-preserve-screen-position'.  If the value is 't', Emacs
adjusts point to keep the cursor at the same screen position whenever a
scroll command moves it off-window, rather than moving it to the topmost
or bottommost line.  With any other non-'nil' value, Emacs adjusts point
this way even if the scroll command leaves point in the window.  This
variable affects all the scroll commands documented in this section, as
well as scrolling with the mouse wheel (*note Mouse Commands::); in
general, it affects any command that has a non-'nil' 'scroll-command'
property.  *Note (elisp)Property Lists::.

   Sometimes, particularly when you hold down keys such as 'C-v' and
'M-v', activating keyboard auto-repeat, Emacs fails to keep up with the
rapid rate of scrolling requested; the display doesn't update and Emacs
can become unresponsive to input for quite a long time.  You can counter
this sluggishness by setting the variable 'fast-but-imprecise-scrolling'
to a non-'nil' value.  This instructs the scrolling commands not to
fontify (*note Font Lock::) any unfontified text they scroll over,
instead to assume it has the default face.  This can cause Emacs to
scroll to somewhat wrong buffer positions when the faces in use are not
all the same size, even with single (i.e., without auto-repeat)
scrolling operations.

   As an alternative to setting 'fast-but-imprecise-scrolling' you might
prefer to enable jit-lock deferred fontification (*note Font Lock::).
To do this, customize 'jit-lock-defer-time' to a small positive number
such as 0.25, or even 0.1 if you type quickly.  This gives you less
jerky scrolling when you hold down 'C-v', but the window contents after
any action which scrolls into a fresh portion of the buffer will be
momentarily unfontified.

   The commands 'M-x scroll-up' and 'M-x scroll-down' behave similarly
to 'scroll-up-command' and 'scroll-down-command', except they do not
obey 'scroll-error-top-bottom'.  Prior to Emacs 24, these were the
default commands for scrolling up and down.  The commands 'M-x
scroll-up-line' and 'M-x scroll-down-line' scroll the current window by
one line at a time.  If you intend to use any of these commands, you
might want to give them key bindings (*note Init Rebinding::).

==============================================================================
File: emacs.info,  Node: |Recentering|,  Next: |Auto_Scrolling|,  Prev: |Scrolling|,  Up: |Display|
==============================================================================

                                                                   *Recentering*

14.2 Recentering
----------------

'C-l'
     Scroll the selected window so the current line is the center-most
     text line; on subsequent consecutive invocations, make the current
     line the top line, the bottom line, and so on in cyclic order.
     Possibly redisplay the screen too ('recenter-top-bottom').

'M-x recenter'
     Scroll the selected window so the current line is the center-most
     text line.  Possibly redisplay the screen too.

'C-M-l'
     Scroll heuristically to bring useful information onto the screen
     ('reposition-window').

   The 'C-l' ('recenter-top-bottom') command "recenters" the selected
window, scrolling it so that the current screen line is exactly in the
center of the window, or as close to the center as possible.

   Typing 'C-l' twice in a row ('C-l C-l') scrolls the window so that
point is on the topmost screen line.  Typing a third 'C-l' scrolls the
window so that point is on the bottom-most screen line.  Each successive
'C-l' cycles through these three positions.

   You can change the cycling order by customizing the list variable
'recenter-positions'.  Each list element should be the symbol 'top',
'middle', or 'bottom', or a number; an integer means to move the line to
the specified screen line, while a floating-point number between 0.0 and
1.0 specifies a percentage of the screen space from the top of the
window.  The default, '(middle top bottom)', is the cycling order
described above.  Furthermore, if you change the variable
'scroll-margin' to a non-zero value N, 'C-l' always leaves at least N
screen lines between point and the top or bottom of the window (*note
Auto Scrolling::).

   You can also give 'C-l' a prefix argument.  A plain prefix argument,
'C-u C-l', simply recenters the line showing point.  A positive argument
N moves line showing point N lines down from the top of the window.  An
argument of zero moves point's line to the top of the window.  A
negative argument -N moves point's line N lines from the bottom of the
window.  When given an argument, 'C-l' does not clear the screen or
cycle through different screen positions.

   If the variable 'recenter-redisplay' has a non-'nil' value, each
invocation of 'C-l' also clears and redisplays the screen; the special
value 'tty' (the default) says to do this on text-terminal frames only.
Redisplaying is useful in case the screen becomes garbled for any reason
(*note Screen Garbled::).

   The more primitive command 'M-x recenter' behaves like
'recenter-top-bottom', but does not cycle among screen positions.

   'C-M-l' ('reposition-window') scrolls the current window
heuristically in a way designed to get useful information onto the
screen.  For example, in a Lisp file, this command tries to get the
entire current defun onto the screen if possible.

==============================================================================
File: emacs.info,  Node: |Auto_Scrolling|,  Next: |Horizontal_Scrolling|,  Prev: |Recentering|,  Up: |Display|
==============================================================================

                                                                *Auto_Scrolling*

14.3 Automatic Scrolling
------------------------

Emacs performs "automatic scrolling" when point moves out of the visible
portion of the text.  Normally, automatic scrolling centers point
vertically in the window, but there are several ways to alter this
behavior.

   If you set 'scroll-conservatively' to a small number N, then moving
point just a little off the screen (no more than N lines) causes Emacs
to scroll just enough to bring point back on screen; if doing so fails
to make point visible, Emacs scrolls just far enough to center point in
the window.  If you set 'scroll-conservatively' to a large number
(larger than 100), automatic scrolling never centers point, no matter
how far point moves; Emacs always scrolls text just enough to bring
point into view, either at the top or bottom of the window depending on
the scroll direction.  By default, 'scroll-conservatively' is 0, which
means to always center point in the window.

   Another way to control automatic scrolling is to customize the
variable 'scroll-step'.  Its value determines the number of lines by
which to automatically scroll, when point moves off the screen.  If
scrolling by that number of lines fails to bring point back into view,
point is centered instead.  The default value is zero, which (by
default) causes point to always be centered after scrolling.

   A third way to control automatic scrolling is to customize the
variables 'scroll-up-aggressively' and 'scroll-down-aggressively', which
directly specify the vertical position of point after scrolling.  The
value of 'scroll-up-aggressively' should be either 'nil' (the default),
or a floating point number F between 0 and 1.  The latter means that
when point goes below the bottom window edge (i.e., scrolling forward),
Emacs scrolls the window so that point is F parts of the window height
from the bottom window edge.  Thus, larger F means more aggressive
scrolling: more new text is brought into view.  The default value,
'nil', is equivalent to 0.5.

   Likewise, 'scroll-down-aggressively' is used when point goes above
the top window edge (i.e., scrolling backward).  The value specifies how
far point should be from the top margin of the window after scrolling.
Thus, as with 'scroll-up-aggressively', a larger value is more
aggressive.

   Note that the variables 'scroll-conservatively', 'scroll-step', and
'scroll-up-aggressively' / 'scroll-down-aggressively' control automatic
scrolling in contradictory ways.  Therefore, you should pick no more
than one of these methods to customize automatic scrolling.  In case you
customize multiple variables, the order of priority is:
'scroll-conservatively', then 'scroll-step', and finally
'scroll-up-aggressively' / 'scroll-down-aggressively'.

   The variable 'scroll-margin' restricts how close point can come to
the top or bottom of a window (even if aggressive scrolling specifies a
fraction F that is larger than the window portion between the top and
the bottom margins).  Its value is a number of screen lines; if point
comes within that many lines of the top or bottom of the window, Emacs
performs automatic scrolling.  By default, 'scroll-margin' is 0.  The
effective margin size is limited to a quarter of the window height by
default, but this limit can be increased up to half (or decreased down
to zero) by customizing 'maximum-scroll-margin'.

==============================================================================
File: emacs.info,  Node: |Horizontal_Scrolling|,  Next: |Narrowing|,  Prev: |Auto_Scrolling|,  Up: |Display|
==============================================================================

                                                          *Horizontal_Scrolling*

14.4 Horizontal Scrolling
-------------------------

"Horizontal scrolling" means shifting all the lines sideways within a
window, so that some of the text near the left margin is not displayed.
When the text in a window is scrolled horizontally, text lines are
truncated rather than continued (*note Line Truncation::).  If a window
shows truncated lines, Emacs performs automatic horizontal scrolling
whenever point moves off the left or right edge of the screen.  By
default, all the lines in the window are scrolled horizontally together,
but if you set the variable 'auto-hscroll-mode' to the special value of
'current-line', only the line showing the cursor will be scrolled.  To
disable automatic horizontal scrolling entirely, set the variable
'auto-hscroll-mode' to 'nil'.  Note that when the automatic horizontal
scrolling is turned off, if point moves off the edge of the screen, the
cursor disappears to indicate that.  (On text terminals, the cursor is
left at the edge instead.)

   The variable 'hscroll-margin' controls how close point can get to the
window's left and right edges before automatic scrolling occurs.  It is
measured in columns.  For example, if the value is 5, then moving point
within 5 columns of an edge causes horizontal scrolling away from that
edge.

   The variable 'hscroll-step' determines how many columns to scroll the
window when point gets too close to the edge.  Zero, the default value,
means to center point horizontally within the window.  A positive
integer value specifies the number of columns to scroll by.  A
floating-point number (whose value should be between 0 and 1) specifies
the fraction of the window's width to scroll by.

   You can also perform explicit horizontal scrolling with the following
commands:

'C-x <'
     Scroll text in current window to the left ('scroll-left').
'C-x >'
     Scroll to the right ('scroll-right').

   'C-x <' ('scroll-left') scrolls text in the selected window to the
left by the full width of the window, less two columns.  (In other
words, the text in the window moves left relative to the window.)  With
a numeric argument N, it scrolls by N columns.

   If the text is scrolled to the left, and point moves off the left
edge of the window, the cursor will freeze at the left edge of the
window, until point moves back to the displayed portion of the text.
This is independent of the current setting of 'auto-hscroll-mode',
which, for text scrolled to the left, only affects the behavior at the
right edge of the window.

   'C-x >' ('scroll-right') scrolls similarly to the right.  The window
cannot be scrolled any farther to the right once it is displayed
normally, with each line starting at the window's left margin;
attempting to do so has no effect.  This means that you don't have to
calculate the argument precisely for 'C-x >'; any sufficiently large
argument will restore the normal display.

   If you use those commands to scroll a window horizontally, that sets
a lower bound for automatic horizontal scrolling.  Automatic scrolling
will continue to scroll the window, but never farther to the right than
the amount you previously set by 'scroll-left'.  When
'auto-hscroll-mode' is set to 'current-line', all the lines other than
the one showing the cursor will be scrolled by that minimal amount.

==============================================================================
File: emacs.info,  Node: |Narrowing|,  Next: |View_Mode|,  Prev: |Horizontal_Scrolling|,  Up: |Display|
==============================================================================

                                                                     *Narrowing*

14.5 Narrowing
--------------

"Narrowing" means focusing in on some portion of the buffer, making the
rest temporarily inaccessible.  The portion which you can still get to
is called the "accessible portion".  Canceling the narrowing, which
makes the entire buffer once again accessible, is called "widening".
The bounds of narrowing in effect in a buffer are called the buffer's
"restriction".

   Narrowing can make it easier to concentrate on a single subroutine or
paragraph by eliminating clutter.  It can also be used to limit the
range of operation of a replace command or repeating keyboard macro.

'C-x n n'
     Narrow down to between point and mark ('narrow-to-region').
'C-x n w'
     Widen to make the entire buffer accessible again ('widen').
'C-x n p'
     Narrow down to the current page ('narrow-to-page').
'C-x n d'
     Narrow down to the current defun ('narrow-to-defun').

   When you have narrowed down to a part of the buffer, that part
appears to be all there is.  You can't see the rest, you can't move into
it (motion commands won't go outside the accessible part), you can't
change it in any way.  However, it is not gone, and if you save the file
all the inaccessible text will be saved.  The word 'Narrow' appears in
the mode line whenever narrowing is in effect.

   The primary narrowing command is 'C-x n n' ('narrow-to-region').  It
sets the current buffer's restrictions so that the text in the current
region remains accessible, but all text before the region or after the
region is inaccessible.  Point and mark do not change.

   Alternatively, use 'C-x n p' ('narrow-to-page') to narrow down to the
current page.  *Note Pages::, for the definition of a page.  'C-x n d'
('narrow-to-defun') narrows down to the defun containing point (*note
Defuns::).

   The way to cancel narrowing is to widen with 'C-x n w' ('widen').
This makes all text in the buffer accessible again.

   You can get information on what part of the buffer you are narrowed
down to using the 'C-x =' command.  *Note Position Info::.

   Because narrowing can easily confuse users who do not understand it,
'narrow-to-region' is normally a disabled command.  Attempting to use
this command asks for confirmation and gives you the option of enabling
it; if you enable the command, confirmation will no longer be required
for it.  *Note Disabling::.

==============================================================================
File: emacs.info,  Node: |View_Mode|,  Next: |Follow_Mode|,  Prev: |Narrowing|,  Up: |Display|
==============================================================================

                                                                     *View_Mode*

14.6 View Mode
--------------

View mode is a minor mode that lets you scan a buffer by sequential
screenfuls.  It provides commands for scrolling through the buffer
conveniently but not for changing it.  Apart from the usual Emacs cursor
motion commands, you can type <SPC> to scroll forward one windowful,
'S-<SPC>' or <DEL> to scroll backward, and 's' to start an incremental
search.

   Typing 'q' ('View-quit') disables View mode, and switches back to the
buffer and position before View mode was enabled.  Typing 'e'
('View-exit') disables View mode, keeping the current buffer and
position.

   'M-x view-buffer' prompts for an existing Emacs buffer, switches to
it, and enables View mode.  'M-x view-file' prompts for a file and
visits it with View mode enabled.

==============================================================================
File: emacs.info,  Node: |Follow_Mode|,  Next: |Faces|,  Prev: |View_Mode|,  Up: |Display|
==============================================================================

                                                                   *Follow_Mode*

14.7 Follow Mode
----------------

"Follow mode" is a minor mode that makes two windows, both showing the
same buffer, scroll as a single tall virtual window.  To use Follow
mode, go to a frame with just one window, split it into two side-by-side
windows using 'C-x 3', and then type 'M-x follow-mode'.  From then on,
you can edit the buffer in either of the two windows, or scroll either
one; the other window follows it.

   In Follow mode, if you move point outside the portion visible in one
window and into the portion visible in the other window, that selects
the other window--again, treating the two as if they were parts of one
large window.

   To turn off Follow mode, type 'M-x follow-mode' a second time.

==============================================================================
File: emacs.info,  Node: |Faces|,  Next: |Colors|,  Prev: |Follow_Mode|,  Up: |Display|
==============================================================================

                                                                         *Faces*

14.8 Text Faces
---------------

Emacs can display text in several different styles, called "faces".
Each face can specify various "face attributes", such as the font,
height, weight, slant, foreground and background color, and underlining
or overlining.  Most major modes assign faces to the text automatically,
via Font Lock mode.  *Note Font Lock::, for more information about how
these faces are assigned.

   To see what faces are currently defined, and what they look like,
type 'M-x list-faces-display'.  With a prefix argument, this prompts for
a regular expression, and displays only faces with names matching that
regular expression (*note Regexps::).

   It's possible for a given face to look different in different frames.
For instance, some text terminals do not support all face attributes,
particularly font, height, and width, and some support a limited range
of colors.  In addition, most Emacs faces are defined so that their
attributes are different on light and dark frame backgrounds, for
reasons of legibility.  By default, Emacs automatically chooses which
set of face attributes to display on each frame, based on the frame's
current background color.  However, you can override this by giving the
variable 'frame-background-mode' a non-'nil' value.  A value of 'dark'
makes Emacs treat all frames as if they have a dark background, whereas
a value of 'light' makes it treat all frames as if they have a light
background.

   You can customize a face to alter its attributes, and save those
customizations for future Emacs sessions.  *Note Face Customization::,
for details.

   The 'default' face is the default for displaying text, and all of its
attributes are specified.  Its background color is also used as the
frame's background color.  *Note Colors::.

   Another special face is the 'cursor' face.  On graphical displays,
the background color of this face is used to draw the text cursor.  None
of the other attributes of this face have any effect; the foreground
color for text under the cursor is taken from the background color of
the underlying text.  On text terminals, the appearance of the text
cursor is determined by the terminal, not by the 'cursor' face.

   You can also use X resources to specify attributes of any particular
face.  *Note Resources::.

   Emacs can display variable-width fonts, but some Emacs commands,
particularly indentation commands, do not account for variable character
display widths.  Therefore, we recommend not using variable-width fonts
for most faces, particularly those assigned by Font Lock mode.

==============================================================================
File: emacs.info,  Node: |Colors|,  Next: |Standard_Faces|,  Prev: |Faces|,  Up: |Display|
==============================================================================

                                                                        *Colors*

14.9 Colors for Faces
---------------------

Faces can have various foreground and background colors.  When you
specify a color for a face--for instance, when customizing the face
(*note Face Customization::)--you can use either a "color name" or an
"RGB triplet".

14.9.1 Color Names
------------------

A color name is a pre-defined name, such as 'dark orange' or 'medium sea
green'.  To view a list of color names, type 'M-x list-colors-display'.
To control the order in which colors are shown, customize
'list-colors-sort'.  If you run this command on a graphical display, it
shows the full range of color names known to Emacs (these are the
standard X11 color names, defined in X's 'rgb.txt' file).  If you run
the command on a text terminal, it shows only a small subset of colors
that can be safely displayed on such terminals.  However, Emacs
understands X11 color names even on text terminals; if a face is given a
color specified by an X11 color name, it is displayed using the
closest-matching terminal color.

14.9.2 RGB Triplets
-------------------

An RGB triplet is a string of the form '#RRGGBB'.  Each of the primary
color components is represented by a hexadecimal number between '00'
(intensity 0) and 'FF' (the maximum intensity).  It is also possible to
use one, three, or four hex digits for each component, so 'red' can be
represented as '#F00', '#fff000000', or '#ffff00000000'.  The components
must have the same number of digits.  For hexadecimal values A to F,
either upper or lower case are acceptable.

   The 'M-x list-colors-display' command also shows the equivalent RGB
triplet for each named color.  For instance, 'medium sea green' is
equivalent to '#3CB371'.

   You can change the foreground and background colors of a face with
'M-x set-face-foreground' and 'M-x set-face-background'.  These commands
prompt in the minibuffer for a face name and a color, with completion,
and then set that face to use the specified color.  They affect the face
colors on all frames, but their effects do not persist for future Emacs
sessions, unlike using the customization buffer or X resources.  You can
also use frame parameters to set foreground and background colors for a
specific frame; *Note Frame Parameters::.

==============================================================================
File: emacs.info,  Node: |Standard_Faces|,  Next: |Text_Scale|,  Prev: |Colors|,  Up: |Display|
==============================================================================

                                                                *Standard_Faces*

14.10 Standard Faces
--------------------

Here are the standard faces for specifying text appearance.  You can
apply them to specific text when you want the effects they produce.

'default'
     This face is used for ordinary text that doesn't specify any face.
     Its background color is used as the frame's background color.
'bold'
     This face uses a bold variant of the default font.
'italic'
     This face uses an italic variant of the default font.
'bold-italic'
     This face uses a bold italic variant of the default font.
'underline'
     This face underlines text.
'fixed-pitch'
     This face forces use of a fixed-width font.  It's reasonable to
     customize this face to use a different fixed-width font, if you
     like, but you should not make it a variable-width font.
'fixed-pitch-serif'
     This face is like 'fixed-pitch', except the font has serifs and
     looks more like traditional typewriting.
'variable-pitch'
     This face forces use of a variable-width font.
'shadow'
     This face is used for making the text less noticeable than the
     surrounding ordinary text.  Usually this can be achieved by using
     shades of gray in contrast with either black or white default
     foreground color.

   Here's an incomplete list of faces used to highlight parts of the
text temporarily for specific purposes.  (Many other modes define their
own faces for this purpose.)

'highlight'
     This face is used for text highlighting in various contexts, such
     as when the mouse cursor is moved over a hyperlink.
'isearch'
     This face is used to highlight the current Isearch match (*note
     Incremental Search::).
'query-replace'
     This face is used to highlight the current Query Replace match
     (*note Replace::).
'lazy-highlight'
     This face is used to highlight lazy matches for Isearch and Query
     Replace (matches other than the current one).
'region'
     This face is used for displaying an active region (*note Mark::).
     When Emacs is built with GTK+ support, its colors are taken from
     the current GTK+ theme.
'secondary-selection'
     This face is used for displaying a secondary X selection (*note
     Secondary Selection::).
'trailing-whitespace'
     The face for highlighting excess spaces and tabs at the end of a
     line when 'show-trailing-whitespace' is non-'nil' (*note Useless
     Whitespace::).
'escape-glyph'
     The face for displaying control characters and escape sequences
     (*note Text Display::).
'homoglyph'
     The face for displaying lookalike characters, i.e., characters that
     look like but are not the characters being represented (*note Text
     Display::).
'nobreak-space'
     The face for displaying no-break space characters (*note Text
     Display::).
'nobreak-hyphen'
     The face for displaying no-break hyphen characters (*note Text
     Display::).

   The following faces control the appearance of parts of the Emacs
frame:

'mode-line'
     This face is used for the mode line of the currently selected
     window, and for menu bars when toolkit menus are not used.  By
     default, it's drawn with shadows for a raised effect on graphical
     displays, and drawn as the inverse of the default face on
     non-windowed terminals.
'mode-line-inactive'
     Like 'mode-line', but used for mode lines of the windows other than
     the selected one (if 'mode-line-in-non-selected-windows' is
     non-'nil').  This face inherits from 'mode-line', so changes in
     that face affect mode lines in all windows.
'mode-line-highlight'
     Like 'highlight', but used for mouse-sensitive portions of text on
     mode lines.  Such portions of text typically pop up tooltips (*note
     Tooltips::) when the mouse pointer hovers above them.
'mode-line-buffer-id'
     This face is used for buffer identification parts in the mode line.
'header-line'
     Similar to 'mode-line' for a window's header line, which appears at
     the top of a window just as the mode line appears at the bottom.
     Most windows do not have a header line--only some special modes,
     such Info mode, create one.
'header-line-highlight'
     Similar to 'highlight' and 'mode-line-highlight', but used for
     mouse-sensitive portions of text on header lines.  This is a
     separate face because the 'header-line' face might be customized in
     a way that does not interact well with 'highlight'.
'tab-line'
     Similar to 'mode-line' for a window's tab line, which appears at
     the top of a window with tabs representing window buffers.  *Note
     Tab Line::.
'vertical-border'
     This face is used for the vertical divider between windows on text
     terminals.
'minibuffer-prompt'
     This face is used for the prompt strings displayed in the
     minibuffer.  By default, Emacs automatically adds this face to the
     value of 'minibuffer-prompt-properties', which is a list of text
     properties (*note (elisp)Text Properties::) used to display the
     prompt text.  (This variable takes effect when you enter the
     minibuffer.)
'fringe'
     The face for the fringes to the left and right of windows on
     graphic displays.  (The fringes are the narrow portions of the
     Emacs frame between the text area and the window's right and left
     borders.)  *Note Fringes::.
'cursor'
     The ':background' attribute of this face specifies the color of the
     text cursor.  *Note Cursor Display::.
'tooltip'
     This face is used for tooltip text.  By default, if Emacs is built
     with GTK+ support, tooltips are drawn via GTK+ and this face has no
     effect.  *Note Tooltips::.
'mouse'
     This face determines the color of the mouse pointer.

   The following faces likewise control the appearance of parts of the
Emacs frame, but only on text terminals, or when Emacs is built on X
with no toolkit support.  (For all other cases, the appearance of the
respective frame elements is determined by system-wide settings.)

'scroll-bar'
     This face determines the visual appearance of the scroll bar.
     *Note Scroll Bars::.
'tool-bar'
     This face determines the color of tool bar icons.  *Note Tool
     Bars::.
'tab-bar'
     This face determines the color of tab bar icons.  *Note Tab Bars::.
'menu'
     This face determines the colors and font of Emacs's menus.  *Note
     Menu Bars::.
'tty-menu-enabled-face'
     This face is used to display enabled menu items on text-mode
     terminals.
'tty-menu-disabled-face'
     This face is used to display disabled menu items on text-mode
     terminals.
'tty-menu-selected-face'
     This face is used to display on text-mode terminals the menu item
     that would be selected if you click a mouse or press <RET>.

==============================================================================
File: emacs.info,  Node: |Text_Scale|,  Next: |Font_Lock|,  Prev: |Standard_Faces|,  Up: |Display|
==============================================================================

                                                                    *Text_Scale*

14.11 Text Scale
----------------

To increase the height of the default face in the current buffer, type
'C-x C-+' or 'C-x C-='.  To decrease it, type 'C-x C--'.  To restore the
default (global) face height, type 'C-x C-0'.  These keys are all bound
to the same command, 'text-scale-adjust', which looks at the last key
typed to determine which action to take.

   Similarly, scrolling the mouse wheel with the 'Ctrl' modifier
pressed, when the mouse pointer is above buffer text, will increase or
decrease the height of the default face, depending on the direction of
the scrolling.

   The final key of these commands may be repeated without the leading
'C-x'.  For instance, 'C-x C-= C-= C-=' increases the face height by
three steps.  Each step scales the text height by a factor of 1.2; to
change this factor, customize the variable 'text-scale-mode-step'.  A
numeric argument of 0 to the 'text-scale-adjust' command restores the
default height, the same as typing 'C-x C-0'.

   The commands 'text-scale-increase' and 'text-scale-decrease' increase
or decrease the height of the default face, just like 'C-x C-+' and 'C-x
C--' respectively.  You may find it convenient to bind to these
commands, rather than 'text-scale-adjust'.

   The command 'text-scale-set' scales the height of the default face in
the current buffer to an absolute level specified by its prefix
argument.

   The above commands automatically enable the minor mode
'text-scale-mode' if the current font scaling is other than 1, and
disable it otherwise.

==============================================================================
File: emacs.info,  Node: |Font_Lock|,  Next: |Highlight_Interactively|,  Prev: |Text_Scale|,  Up: |Display|
==============================================================================

                                                                     *Font_Lock*

14.12 Font Lock mode
--------------------

Font Lock mode is a minor mode, always local to a particular buffer,
which assigns faces to (or "fontifies") the text in the buffer.  Each
buffer's major mode tells Font Lock mode which text to fontify; for
instance, programming language modes fontify syntactically relevant
constructs like comments, strings, and function names.

   Font Lock mode is enabled by default in major modes that support it.
To toggle it in the current buffer, type 'M-x font-lock-mode'.  A
positive numeric argument unconditionally enables Font Lock mode, and a
negative or zero argument disables it.

   Type 'M-x global-font-lock-mode' to toggle Font Lock mode in all
buffers.  To impose this setting for future Emacs sessions, customize
the variable 'global-font-lock-mode' (*note Easy Customization::), or
add the following line to your init file:

     (global-font-lock-mode 0)

If you have disabled Global Font Lock mode, you can still enable Font
Lock for specific major modes by adding the function 'font-lock-mode' to
the mode hooks (*note Hooks::).  For example, to enable Font Lock mode
for editing C files, you can do this:

     (add-hook 'c-mode-hook 'font-lock-mode)

   Font Lock mode uses several specifically named faces to do its job,
including 'font-lock-string-face', 'font-lock-comment-face', and others.
The easiest way to find them all is to use 'M-x customize-group <RET>
font-lock-faces <RET>'.  You can then use that customization buffer to
customize the appearance of these faces.  *Note Face Customization::.

   You can customize the variable 'font-lock-maximum-decoration' to
alter the amount of fontification applied by Font Lock mode, for major
modes that support this feature.  The value should be a number (with 1
representing a minimal amount of fontification; some modes support
levels as high as 3); or 't', meaning "as high as possible" (the
default).  To be effective for a given file buffer, the customization of
'font-lock-maximum-decoration' should be done _before_ the file is
visited; if you already have the file visited in a buffer when you
customize this variable, kill the buffer and visit the file again after
the customization.

   You can also specify different numbers for particular major modes;
for example, to use level 1 for C/C++ modes, and the default level
otherwise, use the value

     '((c-mode . 1) (c++-mode . 1)))

   Comment and string fontification (or "syntactic" fontification)
relies on analysis of the syntactic structure of the buffer text.  For
the sake of speed, some modes, including Lisp mode, rely on a special
convention: an open-parenthesis or open-brace in the leftmost column
always defines the beginning of a defun, and is thus always outside any
string or comment.  Therefore, you should avoid placing an
open-parenthesis or open-brace in the leftmost column, if it is inside a
string or comment.  *Note Left Margin Paren::, for details.

   Font Lock highlighting patterns already exist for most modes, but you
may want to fontify additional patterns.  You can use the function
'font-lock-add-keywords', to add your own highlighting patterns for a
particular mode.  For example, to highlight 'FIXME:' words in C
comments, use this:

     (add-hook 'c-mode-hook
               (lambda ()
                (font-lock-add-keywords nil
                 '(("\\<\\(FIXME\\):" 1
                    font-lock-warning-face t)))))

To remove keywords from the font-lock highlighting patterns, use the
function 'font-lock-remove-keywords'.  *Note (elisp)Search-based
Fontification::.

   Fontifying large buffers can take a long time.  To avoid large delays
when a file is visited, Emacs initially fontifies only the visible
portion of a buffer.  As you scroll through the buffer, each portion
that becomes visible is fontified as soon as it is displayed; this type
of Font Lock is called "Just-In-Time" (or "JIT") Lock.  You can control
how JIT Lock behaves, including telling it to perform fontification
while idle, by customizing variables in the customization group
'jit-lock'.  *Note Specific Customization::.

==============================================================================
File: emacs.info,  Node: |Highlight_Interactively|,  Next: |Fringes|,  Prev: |Font_Lock|,  Up: |Display|
==============================================================================

                                                       *Highlight_Interactively*

14.13 Interactive Highlighting
------------------------------

Highlight Changes mode is a minor mode that "highlights" the parts of
the buffer that were changed most recently, by giving that text a
different face.  To enable or disable Highlight Changes mode, use 'M-x
highlight-changes-mode'.

   Hi Lock mode is a minor mode that highlights text that matches
regular expressions you specify.  For example, you can use it to
highlight all the references to a certain variable in a program source
file, highlight certain parts in a voluminous output of some program, or
highlight certain names in an article.  To enable or disable Hi Lock
mode, use the command 'M-x hi-lock-mode'.  To enable Hi Lock mode for
all buffers, use 'M-x global-hi-lock-mode' or place
'(global-hi-lock-mode 1)' in your '.emacs' file.

   Hi Lock mode works like Font Lock mode (*note Font Lock::), except
that you specify explicitly the regular expressions to highlight.  You
can control them with the following commands.  (The key bindings below
that begin with 'C-x w' are deprecated in favor of the global 'M-s h'
bindings, and will be removed in some future Emacs version.)

'M-s h r REGEXP <RET> FACE <RET>'
'C-x w h REGEXP <RET> FACE <RET>'
     Highlight text that matches REGEXP using face FACE
     ('highlight-regexp').  The highlighting will remain as long as the
     buffer is loaded.  For example, to highlight all occurrences of the
     word "whim" using the default face (a yellow background), type 'M-s
     h r whim <RET> <RET>'.  Any face can be used for highlighting, Hi
     Lock provides several of its own and these are pre-loaded into a
     list of default values.  While being prompted for a face use 'M-n'
     and 'M-p' to cycle through them.  A prefix numeric argument limits
     the highlighting to the corresponding subexpression.

     Setting the option 'hi-lock-auto-select-face' to a non-'nil' value
     causes this command (and other Hi Lock commands that read faces) to
     automatically choose the next face from the default list without
     prompting.

     You can use this command multiple times, specifying various regular
     expressions to highlight in different ways.

'M-s h u REGEXP <RET>'
'C-x w r REGEXP <RET>'
     Unhighlight REGEXP ('unhighlight-regexp').  If you invoke this from
     the menu, you select the expression to unhighlight from a list.  If
     you invoke this from the keyboard, you use the minibuffer.  It will
     show the most recently added regular expression; use 'M-n' to show
     the next older expression and 'M-p' to select the next newer
     expression.  (You can also type the expression by hand, with
     completion.)  When the expression you want to unhighlight appears
     in the minibuffer, press '<RET>' to exit the minibuffer and
     unhighlight it.

'M-s h l REGEXP <RET> FACE <RET>'
'C-x w l REGEXP <RET> FACE <RET>'
     Highlight entire lines containing a match for REGEXP, using face
     FACE ('highlight-lines-matching-regexp').

'M-s h p PHRASE <RET> FACE <RET>'
'C-x w p PHRASE <RET> FACE <RET>'
     Highlight matches of PHRASE, using face FACE ('highlight-phrase').
     PHRASE can be any regexp, but spaces will be replaced by matches to
     whitespace and initial lower-case letters will become case
     insensitive.

'M-s h .'
'C-x w .'
     Highlight the symbol found near point, using the next available
     face ('highlight-symbol-at-point').

'M-s h w'
'C-x w b'
     Insert all the current highlighting regexp/face pairs into the
     buffer at point, with comment delimiters to prevent them from
     changing your program.  (This key binding runs the
     'hi-lock-write-interactive-patterns' command.)

     These patterns are extracted from the comments, if appropriate, if
     you invoke 'M-x hi-lock-find-patterns', or if you visit the file
     while Hi Lock mode is enabled (since that runs
     'hi-lock-find-patterns').

'M-s h f'
'C-x w i'
     Extract regexp/face pairs from comments in the current buffer
     ('hi-lock-find-patterns').  Thus, you can enter patterns
     interactively with 'highlight-regexp', store them into the file
     with 'hi-lock-write-interactive-patterns', edit them (perhaps
     including different faces for different parenthesized parts of the
     match), and finally use this command ('hi-lock-find-patterns') to
     have Hi Lock highlight the edited patterns.

     The variable 'hi-lock-file-patterns-policy' controls whether Hi
     Lock mode should automatically extract and highlight patterns found
     in a file when it is visited.  Its value can be 'nil' (never
     highlight), 'ask' (query the user), or a function.  If it is a
     function, 'hi-lock-find-patterns' calls it with the patterns as
     argument; if the function returns non-'nil', the patterns are used.
     The default is 'ask'.  Note that patterns are always highlighted if
     you call 'hi-lock-find-patterns' directly, regardless of the value
     of this variable.

     Also, 'hi-lock-find-patterns' does nothing if the current major
     mode's symbol is a member of the list 'hi-lock-exclude-modes'.

==============================================================================
File: emacs.info,  Node: |Fringes|,  Next: |Displaying_Boundaries|,  Prev: |Highlight_Interactively|,  Up: |Display|
==============================================================================

                                                                       *Fringes*

14.14 Window Fringes
--------------------

On graphical displays, each Emacs window normally has narrow "fringes"
on the left and right edges.  The fringes are used to display symbols
that provide information about the text in the window.  You can type
'M-x fringe-mode' to toggle display of the fringes or to modify their
width.  This command affects fringes in all frames; to modify fringes on
the selected frame only, use 'M-x set-fringe-style'.  You can make your
changes to the fringes permanent by customizing the variable
'fringe-mode'.

   The most common use of the fringes is to indicate a continuation line
(*note Continuation Lines::).  When one line of text is split into
multiple screen lines, the left fringe shows a curving arrow for each
screen line except the first, indicating that this is not the real
beginning.  The right fringe shows a curving arrow for each screen line
except the last, indicating that this is not the real end.  If the
line's direction is right-to-left (*note Bidirectional Editing::), the
meanings of the curving arrows in the fringes are swapped.

   The fringes indicate line truncation (*note Line Truncation::) with
short horizontal arrows meaning there's more text on this line which is
scrolled horizontally out of view.  Clicking the mouse on one of the
arrows scrolls the display horizontally in the direction of the arrow.

   The fringes can also indicate other things, such as buffer boundaries
(*note Displaying Boundaries::), unused lines near the end of the window
(*note indicate-empty-lines::), and where a program you are debugging is
executing (*note Debuggers::).

   The fringe is also used for drawing the cursor, if the current line
is exactly as wide as the window and point is at the end of the line.
To disable this, change the variable 'overflow-newline-into-fringe' to
'nil'; this causes Emacs to continue or truncate lines that are exactly
as wide as the window.

   If you customize 'fringe-mode' to remove the fringes on one or both
sides of the window display, the features that display on the fringe are
not available.  Indicators of line continuation and truncation are an
exception: when fringes are not available, Emacs uses the leftmost and
rightmost character cells to indicate continuation and truncation with
special ASCII characters, see *note Continuation Lines::, and *note Line
Truncation::.  This reduces the width available for displaying text on
each line, because the character cells used for truncation and
continuation indicators are reserved for that purpose.  Since buffer
text can include bidirectional text, and thus both left-to-right and
right-to-left paragraphs (*note Bidirectional Editing::), removing only
one of the fringes still reserves two character cells, one on each side
of the window, for truncation and continuation indicators, because these
indicators are displayed on opposite sides of the window in
right-to-left paragraphs.

==============================================================================
File: emacs.info,  Node: |Displaying_Boundaries|,  Next: |Useless_Whitespace|,  Prev: |Fringes|,  Up: |Display|
==============================================================================

                                                         *Displaying_Boundaries*

14.15 Displaying Boundaries
---------------------------

Emacs can add an indicator to display a fill column position.  The fill
column indicator is a useful functionality especially in 'prog-mode' to
indicate the position of a specific column.

   You can set the buffer-local variables
'display-fill-column-indicator' and
'display-fill-column-indicator-character' to activate the indicator and
control how it looks, respectively.

   Alternatively you can type 'M-x display-fill-column-indicator-mode'
or 'M-x global-display-fill-column-indicator-mode' which enables the
indicator locally or globally, respectively, and also chooses the
character to use if none is already set.  It is possible to use the
first one to activate the indicator in a hook and the second one to
enable it globally.

   There are 2 buffer local variables and 1 face to customize this mode:

'display-fill-column-indicator-column'
     Specifies the column number where the indicator should be set.  It
     can take positive numerical values for the column or the special
     value 't' which means that the variable 'fill-column' will be used.

     Any other value disables the indicator.  The default value is 't'.

'display-fill-column-indicator-character'
     Specifies the character used for the indicator.  This character can
     be any valid character including Unicode ones if the font supports
     them.

     When the mode is enabled through the functions
     'display-fill-column-indicator-mode' or
     'global-display-fill-column-indicator-mode', the initialization
     functions check if this variable is non-'nil', otherwise the
     initialization tries to set it to 'U+2502' or '|'.

'fill-column-indicator'
     Specifies the face used to display the indicator.  It inherits its
     default values from the face 'shadow' but without background color.
     To change the indicator color you need only set the foreground
     color of this face.

   On graphical displays, Emacs can indicate the buffer boundaries in
the fringes.  If you enable this feature, the first line and the last
line are marked with angle images in the fringes.  This can be combined
with up and down arrow images which say whether it is possible to scroll
the window.

   The buffer-local variable 'indicate-buffer-boundaries' controls how
the buffer boundaries and window scrolling is indicated in the fringes.
If the value is 'left' or 'right', both angle and arrow bitmaps are
displayed in the left or right fringe, respectively.

   If value is an alist (*note (elisp)Association Lists::), each element
'(INDICATOR . POSITION)' specifies the position of one of the
indicators.  The INDICATOR must be one of 'top', 'bottom', 'up', 'down',
or 't' which specifies the default position for the indicators not
present in the alist.  The POSITION is one of 'left', 'right', or 'nil'
which specifies not to show this indicator.

   For example, '((top . left) (t . right))' places the top angle bitmap
in left fringe, the bottom angle bitmap in right fringe, and both arrow
bitmaps in right fringe.  To show just the angle bitmaps in the left
fringe, but no arrow bitmaps, use '((top . left) (bottom . left))'.

==============================================================================
File: emacs.info,  Node: |Useless_Whitespace|,  Next: |Selective_Display|,  Prev: |Displaying_Boundaries|,  Up: |Display|
==============================================================================

                                                            *Useless_Whitespace*

14.16 Useless Whitespace
------------------------

It is easy to leave unnecessary spaces at the end of a line, or empty
lines at the end of a buffer, without realizing it.  In most cases, this
"trailing whitespace" has no effect, but sometimes it can be a nuisance.

   You can make trailing whitespace at the end of a line visible by
setting the buffer-local variable 'show-trailing-whitespace' to 't'.
Then Emacs displays trailing whitespace, using the face
'trailing-whitespace'.

   This feature does not apply when point is at the end of the line
containing the whitespace.  Strictly speaking, that is trailing
whitespace nonetheless, but displaying it specially in that case looks
ugly while you are typing in new text.  In this special case, the
location of point is enough to show you that the spaces are present.

   Type 'M-x delete-trailing-whitespace' to delete all trailing
whitespace.  This command deletes all extra spaces at the end of each
line in the buffer, and all empty lines at the end of the buffer; to
ignore the latter, change the variable 'delete-trailing-lines' to 'nil'.
If the region is active, the command instead deletes extra spaces at the
end of each line in the region.

   On graphical displays, Emacs can indicate unused lines at the end of
the window with a small image in the left fringe (*note Fringes::).  The
image appears for screen lines that do not correspond to any buffer
text, so blank lines at the end of the buffer stand out because they
lack this image.  To enable this feature, set the buffer-local variable
'indicate-empty-lines' to a non-'nil' value.  You can enable or disable
this feature for all new buffers by setting the default value of this
variable, e.g., '(setq-default indicate-empty-lines t)'.

   Whitespace mode is a buffer-local minor mode that lets you visualize
many kinds of whitespace in the buffer, by either drawing the whitespace
characters with a special face or displaying them as special glyphs.  To
toggle this mode, type 'M-x whitespace-mode'.  The kinds of whitespace
visualized are determined by the list variable 'whitespace-style'.
Individual elements in that list can be toggled on or off in the current
buffer by typing 'M-x whitespace-toggle-options'.  Here is a partial
list of possible elements (see the variable's documentation for the full
list):

'face'
     Enable all visualizations which use special faces.  This element
     has a special meaning: if it is absent from the list, none of the
     other visualizations take effect except 'space-mark', 'tab-mark',
     and 'newline-mark'.

'trailing'
     Highlight trailing whitespace.

'tabs'
     Highlight tab characters.

'spaces'
     Highlight space and non-breaking space characters.

'lines'
     Highlight lines longer than 80 columns.  To change the column
     limit, customize the variable 'whitespace-line-column'.

'newline'
     Highlight newlines.

'empty'
     Highlight empty lines at the beginning and/or end of the buffer.

'big-indent'
     Highlight too-deep indentation.  By default any sequence of at
     least 4 consecutive tab characters or 32 consecutive space
     characters is highlighted.  To change that, customize the regular
     expression 'whitespace-big-indent-regexp'.

'space-mark'
     Draw space and non-breaking characters with a special glyph.

'tab-mark'
     Draw tab characters with a special glyph.

'newline-mark'
     Draw newline characters with a special glyph.

   Global Whitespace mode is a global minor mode that lets you visualize
whitespace in all buffers.  To toggle individual features, use 'M-x
global-whitespace-toggle-options'.

==============================================================================
File: emacs.info,  Node: |Selective_Display|,  Next: |Optional_Mode_Line|,  Prev: |Useless_Whitespace|,  Up: |Display|
==============================================================================

                                                             *Selective_Display*

14.17 Selective Display
-----------------------

Emacs has the ability to hide lines indented more than a given number of
columns.  You can use this to get an overview of a part of a program.

   To hide lines in the current buffer, type 'C-x $'
('set-selective-display') with a numeric argument N.  Then lines with at
least N columns of indentation disappear from the screen.  The only
indication of their presence is that three dots ('...') appear at the
end of each visible line that is followed by one or more hidden ones.

   The commands 'C-n' and 'C-p' move across the hidden lines as if they
were not there.

   The hidden lines are still present in the buffer, and most editing
commands see them as usual, so you may find point in the middle of the
hidden text.  When this happens, the cursor appears at the end of the
previous line, after the three dots.  If point is at the end of the
visible line, before the newline that ends it, the cursor appears before
the three dots.

   To make all lines visible again, type 'C-x $' with no argument.

   If you set the variable 'selective-display-ellipses' to 'nil', the
three dots do not appear at the end of a line that precedes hidden
lines.  Then there is no visible indication of the hidden lines.  This
variable becomes local automatically when set.

   See also *note Outline Mode:: for another way to hide part of the
text in a buffer.

==============================================================================
File: emacs.info,  Node: |Optional_Mode_Line|,  Next: |Text_Display|,  Prev: |Selective_Display|,  Up: |Display|
==============================================================================

                                                            *Optional_Mode_Line*

14.18 Optional Mode Line Features
---------------------------------

The buffer percentage POS indicates the percentage of the buffer above
the top of the window.  You can additionally display the size of the
buffer by typing 'M-x size-indication-mode' to turn on Size Indication
mode.  The size will be displayed immediately following the buffer
percentage like this:

     POS of SIZE

Here SIZE is the human readable representation of the number of
characters in the buffer, which means that 'k' for 10^3, 'M' for 10^6,
'G' for 10^9, etc., are used to abbreviate.

   The current line number of point appears in the mode line when Line
Number mode is enabled.  Use the command 'M-x line-number-mode' to turn
this mode on and off; normally it is on.  The line number appears after
the buffer percentage POS, with the letter 'L' to indicate what it is.

   Similarly, you can display the current column number by turning on
Column Number mode with 'M-x column-number-mode'.  The column number is
indicated by the letter 'C'.  However, when both of these modes are
enabled, the line and column numbers are displayed in parentheses, the
line number first, rather than with 'L' and 'C'.  For example:
'(561,2)'.  *Note Minor Modes::, for more information about minor modes
and about how to use these commands.

   In Column Number mode, the displayed column number counts from zero
starting at the left margin of the window.  If you would prefer for the
displayed column number to count from one, you may set
'column-number-indicator-zero-based' to 'nil'.

   If you have narrowed the buffer (*note Narrowing::), the displayed
line number is relative to the accessible portion of the buffer.  Thus,
it isn't suitable as an argument to 'goto-line'.  (Use 'what-line'
command to see the line number relative to the whole file.)

   If the buffer is very large (larger than the value of
'line-number-display-limit'), Emacs won't compute the line number,
because that would be too slow; therefore, the line number won't appear
on the mode-line.  To remove this limit, set 'line-number-display-limit'
to 'nil'.

   Line-number computation can also be slow if the lines in the buffer
are too long.  For this reason, Emacs doesn't display line numbers if
the average width, in characters, of lines near point is larger than the
value of 'line-number-display-limit-width'.  The default value is 200
characters.

   Emacs can optionally display the time and system load in all mode
lines.  To enable this feature, type 'M-x display-time' or customize the
option 'display-time-mode'.  The information added to the mode line
looks like this:

     HH:MMPM L.LL

Here HH and MM are the hour and minute, followed always by 'AM' or 'PM'.
L.LL is the average number, collected for the last few minutes, of
processes in the whole system that were either running or ready to run
(i.e., were waiting for an available processor).  (Some fields may be
missing if your operating system cannot support them.)  If you prefer
time display in 24-hour format, set the variable
'display-time-24hr-format' to 't'.

   The word 'Mail' appears after the load level if there is mail for you
that you have not read yet.  On graphical displays, you can use an icon
instead of 'Mail' by customizing 'display-time-use-mail-icon'; this may
save some space on the mode line.  You can customize
'display-time-mail-face' to make the mail indicator prominent.  Use
'display-time-mail-file' to specify the mail file to check, or set
'display-time-mail-directory' to specify the directory to check for
incoming mail (any nonempty regular file in the directory is considered
to be newly arrived mail).

   When running Emacs on a laptop computer, you can display the battery
charge on the mode-line, by using the command 'display-battery-mode' or
customizing the variable 'display-battery-mode'.  The variable
'battery-mode-line-format' determines the way the battery charge is
displayed; the exact mode-line message depends on the operating system,
and it usually shows the current battery charge as a percentage of the
total charge.

   On graphical displays, the mode line is drawn as a 3D box.  If you
don't like this effect, you can disable it by customizing the
'mode-line' face and setting its 'box' attribute to 'nil'.  *Note Face
Customization::.

   By default, the mode line of nonselected windows is displayed in a
different face, called 'mode-line-inactive'.  Only the selected window
is displayed in the 'mode-line' face.  This helps show which window is
selected.  When the minibuffer is selected, since it has no mode line,
the window from which you activated the minibuffer has its mode line
displayed using 'mode-line'; as a result, ordinary entry to the
minibuffer does not change any mode lines.

   You can disable use of 'mode-line-inactive' by setting variable
'mode-line-in-non-selected-windows' to 'nil'; then all mode lines are
displayed in the 'mode-line' face.

   You can customize the mode line display for each of the end-of-line
formats by setting each of the variables 'eol-mnemonic-unix',
'eol-mnemonic-dos', 'eol-mnemonic-mac', and 'eol-mnemonic-undecided' to
the strings you prefer.

==============================================================================
File: emacs.info,  Node: |Text_Display|,  Next: |Cursor_Display|,  Prev: |Optional_Mode_Line|,  Up: |Display|
==============================================================================

                                                                  *Text_Display*

14.19 How Text Is Displayed
---------------------------

Most characters are "printing characters": when they appear in a buffer,
they are displayed literally on the screen.  Printing characters include
ASCII numbers, letters, and punctuation characters, as well as many
non-ASCII characters.

   The ASCII character set contains non-printing "control characters".
Two of these are displayed specially: the newline character (Unicode
code point 'U+000A') is displayed by starting a new line, while the tab
character ('U+0009') is displayed as a space that extends to the next
tab stop column (normally every 8 columns).  The number of spaces per
tab is controlled by the buffer-local variable 'tab-width', which must
have an integer value between 1 and 1000, inclusive.  Note that the way
the tab character in the buffer is displayed has nothing to do with the
definition of <TAB> as a command.

   Other ASCII control characters, whose codes are below 'U+0020' (octal
40, decimal 32), are displayed as a caret ('^') followed by the
non-control version of the character, with the 'escape-glyph' face.  For
instance, the 'control-A' character, 'U+0001', is displayed as '^A'.

   The raw bytes with codes 'U+0080' (octal 200) through 'U+009F' (octal
237) are displayed as "octal escape sequences", with the 'escape-glyph'
face.  For instance, character code 'U+0098' (octal 230) is displayed as
'\230'.  If you change the buffer-local variable 'ctl-arrow' to 'nil',
the ASCII control characters are also displayed as octal escape
sequences instead of caret escape sequences.  (You can also request that
raw bytes be shown in hex, *note display-raw-bytes-as-hex: Display
Custom.)

   Some non-ASCII characters have the same appearance as an ASCII space
or hyphen (minus) character.  Such characters can cause problems if they
are entered into a buffer without your realization, e.g., by yanking;
for instance, source code compilers typically do not treat non-ASCII
spaces as whitespace characters.  To deal with this problem, Emacs
displays such characters specially: it displays 'U+00A0' (no-break
space) with the 'nobreak-space' face, and it displays 'U+00AD' (soft
hyphen), 'U+2010' (hyphen), and 'U+2011' (non-breaking hyphen) with the
'nobreak-hyphen' face.  To disable this, change the variable
'nobreak-char-display' to 'nil'.  If you give this variable a non-'nil'
and non-'t' value, Emacs instead displays such characters as a
highlighted backslash followed by a space or hyphen.

   You can customize the way any particular character code is displayed
by means of a display table.  *Note Display Tables: (elisp)Display
Tables.

   On graphical displays, some characters may have no glyphs in any of
the fonts available to Emacs.  These "glyphless characters" are normally
displayed as boxes containing the hexadecimal character code.
Similarly, on text terminals, characters that cannot be displayed using
the terminal encoding (*note Terminal Coding::) are normally displayed
as question signs.  You can control the display method by customizing
the variable 'glyphless-char-display-control'.  You can also customize
the 'glyphless-char' face to make these characters more prominent on
display.  *Note Glyphless Character Display: (elisp)Glyphless Chars, for
details.

   Emacs tries to determine if the curved quotes ''' and ''' can be
displayed on the current display.  By default, if this seems to be so,
then Emacs will translate the ASCII quotes ('`' and '''), when they
appear in messages and help texts, to these curved quotes.  You can
influence or inhibit this translation by customizing the user option
'text-quoting-style' (*note (elisp)Keys in Documentation::).

   If the curved quotes ', ', ", and " are known to look just like ASCII
characters, they are shown with the 'homoglyph' face.  Curved quotes
that are known not to be displayable are shown as their ASCII
approximations `, ', and " with the 'homoglyph' face.

==============================================================================
File: emacs.info,  Node: |Cursor_Display|,  Next: |Line_Truncation|,  Prev: |Text_Display|,  Up: |Display|
==============================================================================

                                                                *Cursor_Display*

14.20 Displaying the Cursor
---------------------------

On a text terminal, the cursor's appearance is controlled by the
terminal, largely out of the control of Emacs.  Some terminals offer two
different cursors: a visible static cursor, and a very visible blinking
cursor.  By default, Emacs uses the very visible cursor, and switches to
it when you start or resume Emacs.  If the variable 'visible-cursor' is
'nil' when Emacs starts or resumes, it uses the normal cursor.

   On a graphical display, many more properties of the text cursor can
be altered.  To customize its color, change the ':background' attribute
of the face named 'cursor' (*note Face Customization::).  (The other
attributes of this face have no effect; the text shown under the cursor
is drawn using the frame's background color.)  To change its shape,
customize the buffer-local variable 'cursor-type'; possible values are
'box' (the default), 'hollow' (a hollow box), 'bar' (a vertical bar),
'(bar . N)' (a vertical bar N pixels wide), 'hbar' (a horizontal bar),
'(hbar . N)' (a horizontal bar N pixels tall), or 'nil' (no cursor at
all).

   By default, the cursor stops blinking after 10 blinks, if Emacs does
not get any input during that time; any input event restarts the count.
You can customize the variable 'blink-cursor-blinks' to control that:
its value says how many times to blink without input before stopping.
Setting that variable to a zero or negative value will make the cursor
blink forever.  To disable cursor blinking altogether, change the
variable 'blink-cursor-mode' to 'nil' (*note Easy Customization::), or
add the line

       (blink-cursor-mode 0)

to your init file.  Alternatively, you can change how the cursor looks
when it blinks off by customizing the list variable
'blink-cursor-alist'.  Each element in the list should have the form
'(ON-TYPE . OFF-TYPE)'; this means that if the cursor is displayed as
ON-TYPE when it blinks on (where ON-TYPE is one of the cursor types
described above), then it is displayed as OFF-TYPE when it blinks off.

   Some characters, such as tab characters, are extra wide.  When the
cursor is positioned over such a character, it is normally drawn with
the default character width.  You can make the cursor stretch to cover
wide characters, by changing the variable 'x-stretch-cursor' to a
non-'nil' value.

   The cursor normally appears in non-selected windows as a non-blinking
hollow box.  (For a bar cursor, it instead appears as a thinner bar.)
To turn off cursors in non-selected windows, change the variable
'cursor-in-non-selected-windows' to 'nil'.

   To make the cursor even more visible, you can use HL Line mode, a
minor mode that highlights the line containing point.  Use 'M-x
hl-line-mode' to enable or disable it in the current buffer.  'M-x
global-hl-line-mode' enables or disables the same mode globally.

==============================================================================
File: emacs.info,  Node: |Line_Truncation|,  Next: |Visual_Line_Mode|,  Prev: |Cursor_Display|,  Up: |Display|
==============================================================================

                                                               *Line_Truncation*

14.21 Line Truncation
---------------------

As an alternative to continuation (*note Continuation Lines::), Emacs
can display long lines by "truncation".  This means that all the
characters that do not fit in the width of the screen or window do not
appear at all.  On graphical displays, a small straight arrow in the
fringe indicates truncation at either end of the line.  On text
terminals, this is indicated with '$' signs in the rightmost and/or
leftmost columns.

   Horizontal scrolling automatically causes line truncation (*note
Horizontal Scrolling::).  You can explicitly enable line truncation for
a particular buffer with the command 'M-x toggle-truncate-lines'.  This
works by locally changing the variable 'truncate-lines'.  If that
variable is non-'nil', long lines are truncated; if it is 'nil', they
are continued onto multiple screen lines.  Setting the variable
'truncate-lines' in any way makes it local to the current buffer; until
that time, the default value, which is normally 'nil', is in effect.

   If a split window becomes too narrow, Emacs may automatically enable
line truncation.  *Note Split Window::, for the variable
'truncate-partial-width-windows' which controls this.

==============================================================================
File: emacs.info,  Node: |Visual_Line_Mode|,  Next: |Display_Custom|,  Prev: |Line_Truncation|,  Up: |Display|
==============================================================================

                                                              *Visual_Line_Mode*

14.22 Visual Line Mode
----------------------

Another alternative to ordinary line continuation is to use "word wrap".
Here, each long logical line is divided into two or more screen lines,
like in ordinary line continuation.  However, Emacs attempts to wrap the
line at word boundaries near the right window edge.  (If the line's
direction is right-to-left, it is wrapped at the left window edge
instead.)  This makes the text easier to read, as wrapping does not
occur in the middle of words.

   Word wrap is enabled by Visual Line mode, an optional minor mode.  To
turn on Visual Line mode in the current buffer, type 'M-x
visual-line-mode'; repeating this command turns it off.  You can also
turn on Visual Line mode using the menu bar: in the Options menu, select
the 'Line Wrapping in this Buffer' submenu, followed by the 'Word Wrap
(Visual Line mode)' menu item.  While Visual Line mode is enabled, the
mode line shows the string 'wrap' in the mode display.  The command 'M-x
global-visual-line-mode' toggles Visual Line mode in all buffers.

   In Visual Line mode, some editing commands work on screen lines
instead of logical lines: 'C-a' ('beginning-of-visual-line') moves to
the beginning of the screen line, 'C-e' ('end-of-visual-line') moves to
the end of the screen line, and 'C-k' ('kill-visual-line') kills text to
the end of the screen line.

   To move by logical lines, use the commands 'M-x next-logical-line'
and 'M-x previous-logical-line'.  These move point to the next logical
line and the previous logical line respectively, regardless of whether
Visual Line mode is enabled.  If you use these commands frequently, it
may be convenient to assign key bindings to them.  *Note Init
Rebinding::.

   By default, word-wrapped lines do not display fringe indicators.
Visual Line mode is often used to edit files that contain many long
logical lines, so having a fringe indicator for each wrapped line would
be visually distracting.  You can change this by customizing the
variable 'visual-line-fringe-indicators'.

==============================================================================
File: emacs.info,  Node: |Display_Custom|,  Prev: |Visual_Line_Mode|,  Up: |Display|
==============================================================================

                                                                *Display_Custom*

14.23 Customization of Display
------------------------------

This section describes variables that control miscellaneous aspects of
the appearance of the Emacs screen.  Beginning users can skip it.

   If you want to have Emacs display line numbers for every line in the
buffer, customize the buffer-local variable 'display-line-numbers'; it
is 'nil' by default.  This variable can have several different values to
support various modes of line-number display:

't'
     Display (an absolute) line number before each non-continuation
     screen line that displays buffer text.  If the line is a
     continuation line, or if the entire screen line displays a display
     or an overlay string, that line will not be numbered.

'relative'
     Display relative line numbers before non-continuation lines which
     show buffer text.  The line numbers are relative to the line
     showing point, so the numbers grow both up and down as lines become
     farther from the current line.

'visual'
     This value causes Emacs to count lines visually: only lines
     actually shown on the display will be counted (disregarding any
     lines in invisible parts of text), and lines which wrap to consume
     more than one screen line will be numbered that many times.  The
     displayed numbers are relative, as with 'relative' value above.
     This is handy in modes that fold text, such as Outline mode (*note
     Outline Mode::), and when you need to move by exact number of
     screen lines.

anything else
     Any other non-'nil' value is treated as 't'.

   The command 'M-x display-line-numbers-mode' provides a convenient way
to turn on display of line numbers.  This mode has a globalized variant,
'global-display-line-numbers-mode'.  The user option
'display-line-numbers-type' controls which sub-mode of line-number
display, described above, will these modes activate.

Note that line numbers are not displayed in the minibuffer and in the
tooltips, even if you turn on 'display-line-numbers-mode' globally.

   When Emacs displays relative line numbers, you can control the number
displayed before the current line, the line showing point.  By default,
Emacs displays the absolute number of the current line there, even
though all the other line numbers are relative.  If you customize the
variable 'display-line-numbers-current-absolute' to a 'nil' value, the
number displayed for the current line will be zero.  This is handy if
you don't care about the number of the current line, and want to leave
more horizontal space for text in large buffers.

   In a narrowed buffer (*note Narrowing::) lines are normally numbered
starting at the beginning of the narrowing.  However, if you customize
the variable 'display-line-numbers-widen' to a non-'nil' value, line
numbers will disregard any narrowing and will start at the first
character of the buffer.

   If the value of 'display-line-numbers-offset' is non-zero, it is
added to each absolute line number, and lines are counted from the
beginning of the buffer, as if 'display-line-numbers-widen' were
non-'nil'.  It has no effect when set to zero, or when line numbers are
not absolute.

   In selective display mode (*note Selective Display::), and other
modes that hide many lines from display (such as Outline and Org modes),
you may wish to customize the variables
'display-line-numbers-width-start' and 'display-line-numbers-grow-only',
or set 'display-line-numbers-width' to a large enough value, to avoid
occasional miscalculations of space reserved for the line numbers.

   The line numbers are displayed in a special face 'line-number'.  The
current line number is displayed in a different face,
'line-number-current-line', so you can make the current line's number
have a distinct appearance, which will help locating the line showing
point.  Additional faces 'line-number-major-tick' and
'line-number-minor-tick' can be used to highlight the line numbers of
lines which are a multiple of certain numbers.  Customize
'display-line-numbers-major-tick' and 'display-line-numbers-minor-tick'
respectively to set those numbers.

   If the variable 'visible-bell' is non-'nil', Emacs attempts to make
the whole screen blink when it would normally make an audible bell
sound.  This variable has no effect if your terminal does not have a way
to make the screen blink.

   The variable 'echo-keystrokes' controls the echoing of
multi-character keys; its value is the number of seconds of pause
required to cause echoing to start, or zero, meaning don't echo at all.
The value takes effect when there is something to echo.  *Note Echo
Area::.

   On graphical displays, Emacs displays the mouse pointer as an
hourglass if Emacs is busy.  To disable this feature, set the variable
'display-hourglass' to 'nil'.  The variable 'hourglass-delay' determines
the number of seconds of busy time before the hourglass is shown; the
default is 1.

   If the mouse pointer lies inside an Emacs frame, Emacs makes it
invisible each time you type a character to insert text, to prevent it
from obscuring the text.  (To be precise, the hiding occurs when you
type a self-inserting character.  *Note Inserting Text::.)  Moving the
mouse pointer makes it visible again.  To disable this feature, set the
variable 'make-pointer-invisible' to 'nil'.

   On graphical displays, the variable 'underline-minimum-offset'
determines the minimum distance between the baseline and underline, in
pixels, for underlined text.  By default, the value is 1; increasing it
may improve the legibility of underlined text for certain fonts.
(However, Emacs will never draw the underline below the current line
area.)  The variable 'x-underline-at-descent-line' determines how to
draw underlined text.  The default is 'nil', which means to draw it at
the baseline level of the font; if you change it to 't', Emacs draws the
underline at the same height as the font's descent line.  (If
non-default line spacing was specified for the underlined text, see
*note (elisp)Line Height::, Emacs draws the underline below the
additional spacing.)

   The variable 'overline-margin' specifies the vertical position of an
overline above the text, including the height of the overline itself, in
pixels; the default is 2.

   On some text terminals, bold face and inverse video together result
in text that is hard to read.  Call the function
'tty-suppress-bold-inverse-default-colors' with a non-'nil' argument to
suppress the effect of bold-face in this case.

   Raw bytes are displayed in octal format by default, for example a
byte with a decimal value of 128 is displayed as '\200'.  To change
display to the hexadecimal format of '\x80', set the variable
'display-raw-bytes-as-hex' to 't'.

==============================================================================
File: emacs.info,  Node: |Search|,  Next: |Fixit|,  Prev: |Display|,  Up: |Top|
==============================================================================

                                                                        *Search*

15 Searching and Replacement
============================

Like other editors, Emacs has commands to search for occurrences of a
string.  Emacs also has commands to replace occurrences of a string with
a different string.  There are also commands that do the same thing, but
search for patterns instead of fixed strings.

   You can also search multiple files under the control of 'xref' (*note
Identifier Search::) or through the Dired 'A' command (*note Operating
on Files::), or ask the 'grep' program to do it (*note Grep
Searching::).

MENU

* |Incremental_Search|::        Search happens as you type the string.
* |Nonincremental_Search|::     Specify entire string and then search.
* |Word_Search|::               Search for sequence of words.
* |Symbol_Search|::             Search for a source code symbol.
* |Regexp_Search|::             Search for match for a regexp.
* |Regexps|::                   Syntax of regular expressions.
* |Regexp_Backslash|::          Regular expression constructs starting with '\'.
* |Regexp_Example|::            A complex regular expression explained.
* |Lax_Search|::                Search ignores some distinctions among
                                similar characters, like letter-case.
* |Replace|::                   Search, and replace some or all matches.
* |Other_Repeating_Search|::    Operating on all matches for some regexp.
* |Search_Customizations|::     Various search customizations.

==============================================================================
File: emacs.info,  Node: |Incremental_Search|,  Next: |Nonincremental_Search|,  Up: |Search|
==============================================================================

                                                            *Incremental_Search*

15.1 Incremental Search
-----------------------

The principal search command in Emacs is "incremental": it begins
searching as soon as you type the first character of the search string.
As you type in the search string, Emacs shows you where the string (as
you have typed it so far) would be found.  When you have typed enough
characters to identify the place you want, you can stop.  Depending on
what you plan to do next, you may or may not need to terminate the
search explicitly with <RET>.

'C-s'
     Incremental search forward ('isearch-forward').
'C-r'
     Incremental search backward ('isearch-backward').

   You can also invoke incremental search from the menu bar's
'Edit->Search' menu.

MENU

* |Basic_Isearch|::        Basic incremental search commands.
* |Repeat_Isearch|::       Searching for the same string again.
* |Isearch_Yank|::         Commands that grab text into the search string
                           or else edit the search string.
* |Error_in_Isearch|::     When your string is not found.
* |Special_Isearch|::      Special input in incremental search.
* |Not_Exiting_Isearch|::  Prefix argument and scrolling commands.
* |Isearch_Minibuffer|::   Incremental search of the minibuffer history.

==============================================================================
File: emacs.info,  Node: |Basic_Isearch|,  Next: |Repeat_Isearch|,  Up: Incremental Search
==============================================================================

                                                                 *Basic_Isearch*

15.1.1 Basics of Incremental Search
-----------------------------------

'C-s'
     Begin incremental search ('isearch-forward').
'C-r'
     Begin reverse incremental search ('isearch-backward').

   'C-s' ('isearch-forward') starts a forward incremental search.  It
reads characters from the keyboard, and moves point just past the end of
the next occurrence of those characters in the buffer.

   For instance, if you type 'C-s' and then 'F', that puts the cursor
after the first 'F' that occurs in the buffer after the starting point.
If you then type 'O', the cursor moves to just after the first 'FO'; the
'F' in that 'FO' might not be the first 'F' previously found.  After
another 'O', the cursor moves to just after the first 'FOO'.

   At each step, Emacs highlights the "current match"--the buffer text
that matches the search string--using the 'isearch' face (*note Faces::).
*Note Search Customizations::, for various options that customize this
highlighting.  The current search string is also displayed in the echo
area.

   If you make a mistake typing the search string, type <DEL>
('isearch-delete-char').  Each <DEL> cancels the last input item entered
during the search.  Emacs records a new "input item" whenever you type a
command that changes the search string, the position of point, the
success or failure of the search, the direction of the search, the
position of the other end of the current search result, or the
"wrappedness" of the search.  *Note Error in Isearch::, for more about
dealing with unsuccessful search.

   When you are satisfied with the place you have reached, type <RET>
('isearch-exit').  This stops searching, leaving the cursor where the
search brought it.  Also, any command not specially meaningful in
searches stops the searching and is then executed.  Thus, typing 'C-a'
exits the search and then moves to the beginning of the line; typing one
of the arrow keys exits the search and performs the respective movement
command; etc.  <RET> is necessary only if the next command you want to
type is a printing character, <DEL>, <RET>, or another character that is
special within searches ('C-q', 'C-w', 'C-r', 'C-s', 'C-y', 'M-y',
'M-r', 'M-c', 'M-e', and some others described below).  You can
fine-tune the commands that exit the search; see *note Not Exiting
Isearch::.

   As a special exception, entering <RET> when the search string is
empty launches nonincremental search (*note Nonincremental Search::).
(This can be customized; see *note Search Customizations::.)

   To abandon the search and return to the place where you started, type
'<ESC> <ESC> <ESC>' ('isearch-cancel') or 'C-g C-g' ('isearch-abort').

   When you exit the incremental search, it adds the original value of
point to the mark ring, without activating the mark; you can thus use
'C-u C-<SPC>' or 'C-x C-x' to return to where you were before beginning
the search.  *Note Mark Ring::.  (Emacs only does this if the mark was
not already active; if the mark was active when you started the search,
both 'C-u C-<SPC>' and 'C-x C-x' will go to the mark.)

   To search backwards, use 'C-r' ('isearch-backward') instead of 'C-s'
to start the search.  A backward search finds matches that end before
the starting point, just as a forward search finds matches that begin
after it.

==============================================================================
File: emacs.info,  Node: |Repeat_Isearch|,  Next: |Isearch_Yank|,  Prev: |Basic_Isearch|,  Up: |Incremental_Search|
==============================================================================

                                                                *Repeat_Isearch*

15.1.2 Repeating Incremental Search
-----------------------------------

Suppose you search forward for 'FOO' and find a match, but not the one
you expected to find: the 'FOO' you were aiming for occurs later in the
buffer.  In this event, type another 'C-s' ('isearch-repeat-forward') to
move to the next occurrence of the search string, or 'C-r'
('isearch-repeat-backward') to move to the previous occurrence.  You can
repeat these commands any number of times.  Alternatively, you can
supply a numeric prefix argument of N to 'C-s' and 'C-r' to find the Nth
next or previous occurrence.  If you overshoot, you can cancel some
'C-s' commands with <DEL>.  Similarly, each 'C-r'
('isearch-repeat-backward') in a backward incremental search repeats the
backward search.

   If you pause for a little while during incremental search, Emacs
highlights all the other possible matches for the search string that are
present on the screen.  This helps you anticipate where you can get to
by typing 'C-s' or 'C-r' to repeat the search.  The other matches are
highlighted differently from the current match, using the customizable
face 'lazy-highlight' (*note Faces::).  If you don't like this feature,
you can disable it by setting 'isearch-lazy-highlight' to 'nil'.  For
other customizations related to highlighting matches, see *note Search
Customizations::.

   After exiting a search, you can search for the same string again by
typing just 'C-s C-s'.  The first 'C-s' is the key that invokes
incremental search, and the second 'C-s' means to search again for the
last search string.  Similarly, 'C-r C-r' searches backward for the last
search string.  In determining the last search string, it doesn't matter
whether that string was searched for with 'C-s' or 'C-r'.

   If you are searching forward but you realize you were looking for
something before the starting point, type 'C-r' to switch to a backward
search, leaving the search string unchanged.  Similarly, 'C-s' in a
backward search switches to a forward search.

   If a search is failing and you ask to repeat it by typing another
'C-s', it starts again from the beginning of the buffer.  Repeating a
failing reverse search with 'C-r' starts again from the end.  This is
called "wrapping around", and 'Wrapped' appears in the search prompt
once this has happened.  If you keep on going past the original starting
point of the search, it changes to 'Overwrapped', which means that you
are revisiting matches that you have already seen.

   To reuse earlier search strings, use the "search ring".  The commands
'M-p' ('isearch-ring-retreat') and 'M-n' ('isearch-ring-advance') move
through the ring to pick a search string to reuse.  These commands leave
the selected search ring element in the minibuffer, where you can edit
it.  Type 'C-s'/'C-r' or <RET> to accept the string and start searching
for it.  The number of most recently used search strings saved in the
search ring is specified by the variable 'search-ring-max', 16 by
default.

   To edit the current search string in the minibuffer without replacing
it with items from the search ring, type 'M-e' ('isearch-edit-string')
or click 'mouse-1' in the minibuffer.  Type <RET>, 'C-s' or 'C-r' to
finish editing the string and search for it.  Type 'C-f' or '<RIGHT>' to
add to the search string characters following point from the buffer from
which you started the search.

==============================================================================
File: emacs.info,  Node: |Isearch_Yank|,  Next: |Error_in_Isearch|,  Prev: |Repeat_Isearch|,  Up: |Incremental_Search|
==============================================================================

                                                                  *Isearch_Yank*

15.1.3 Isearch Yanking
----------------------

In many cases, you will want to use text at or near point as your search
string.  The commands described in this subsection let you do that
conveniently.

   'C-w' ('isearch-yank-word-or-char') appends the next character or
word at point to the search string.  This is an easy way to search for
another occurrence of the text at point.  (The decision of whether to
copy a character or a word is heuristic.)  With a prefix numeric
argument of N, append the next N characters or words.

   'C-M-w' ('isearch-yank-symbol-or-char') appends the next character or
symbol at point to the search string.  This is an easy way to search for
another occurrence of the symbol at point.  (The decision of whether to
copy a character or a symbol is heuristic.)  With a prefix numeric
argument of N, append the next N characters or symbols.

   'M-s C-e' ('isearch-yank-line') appends the rest of the current line
to the search string.  If point is already at the end of a line, it
appends the next line.  With a prefix argument N, it appends the next N
lines.

   Similarly, 'C-M-z' ('isearch-yank-until-char') appends to the search
string everything from point until the next occurrence of a specified
character (not including that character).  This is especially useful for
keyboard macros, for example in programming languages or markup
languages in which that character marks a token boundary.  With a prefix
numeric argument of N, the command appends everything from point to the
Nth occurrence of the specified character.

   Within incremental search, 'C-y' ('isearch-yank-kill') appends the
current kill to the search string.  'M-y' ('isearch-yank-pop'), if
called after 'C-y', replaces that appended text with an earlier kill,
similar to the usual 'M-y' ('yank-pop') command (*note Yanking::).
Clicking 'mouse-2' in the echo area appends the current X selection
(*note Primary Selection::) to the search string
('isearch-yank-x-selection').

   'C-M-d' ('isearch-del-char') deletes the last character from the
search string, and 'C-M-y' ('isearch-yank-char') appends the character
after point to the search string.  An alternative method to add the
character after point is to enter the minibuffer with 'M-e' (*note
Repeat Isearch::) and type 'C-f' or '<RIGHT>' at the end of the search
string in the minibuffer.  Each 'C-f' or '<RIGHT>' you type adds another
character following point to the search string.

   Normally, when the search is case-insensitive, text yanked into the
search string is converted to lower case, so that the search remains
case-insensitive (*note case folding: Lax Search.).  However, if the
value of the variable 'search-upper-case' (*note search-upper-case: Lax
Search.) is other than 'not-yanks', that disables this down-casing.

==============================================================================
File: emacs.info,  Node: |Error_in_Isearch|,  Next: |Special_Isearch|,  Prev: |Isearch_Yank|,  Up: |Incremental_Search|
==============================================================================

                                                              *Error_in_Isearch*

15.1.4 Errors in Incremental Search
-----------------------------------

If your string is not found at all, the echo area says 'Failing
I-Search', and the cursor moves past the place where Emacs found as much
of your string as it could.  Thus, if you search for 'FOOT', and there
is no 'FOOT', you might see the cursor after the 'FOO' in 'FOOL'.  In
the echo area, the part of the search string that failed to match is
highlighted using the face 'isearch-fail'.

   At this point, there are several things you can do.  If your string
was mistyped, use <DEL> to cancel a previous input item (*note Basic
Isearch::), 'C-M-d' to erase one character at a time, or 'M-e' to edit
it.  If you like the place you have found, you can type <RET> to remain
there.  Or you can type 'C-g', which removes from the search string the
characters that could not be found (the 'T' in 'FOOT'), leaving those
that were found (the 'FOO' in 'FOOT').  A second 'C-g' at that point
cancels the search entirely, returning point to where it was when the
search started.

   The quit command, 'C-g', does special things during searches; just
what it does depends on the status of the search.  If the search has
found what you specified and is waiting for input, 'C-g' cancels the
entire search, moving the cursor back to where you started the search.
If 'C-g' is typed when there are characters in the search string that
have not been found--because Emacs is still searching for them, or
because it has failed to find them--then the search string characters
which have not been found are discarded from the search string.  With
them gone, the search is now successful and waiting for more input, so a
second 'C-g' will cancel the entire search.

==============================================================================
File: emacs.info,  Node: |Special_Isearch|,  Next: |Not_Exiting_Isearch|,  Prev: |Error_in_Isearch|,  Up: |Incremental_Search|
==============================================================================

                                                               *Special_Isearch*

15.1.5 Special Input for Incremental Search
-------------------------------------------

In addition to characters described in the previous subsections, some of
the other characters you type during incremental search have special
effects.  They are described here.

   To toggle lax space matching (*note lax space matching: Lax Search.),
type 'M-s <SPC>'.

   To toggle case sensitivity of the search, type 'M-c' or 'M-s c'.
*Note case folding: Lax Search.  If the search string includes
upper-case letters, the search is case-sensitive by default.

   To toggle whether or not the search will consider similar and
equivalent characters as a match, type 'M-s ''.  *Note character
folding: Lax Search.  If the search string includes accented characters,
that disables character folding during that search.

   To toggle whether or not invisible text is searched, type 'M-s i'
('isearch-toggle-invisible').  *Note Outline Search::.

   To toggle between non-regexp and regexp incremental search, type
'M-r' or 'M-s r' ('isearch-toggle-regexp').  *Note Regexp Search::.

   To toggle symbol mode, type 'M-s _'.  *Note Symbol Search::.

   To search for a newline character, type 'C-j' as part of the search
string.

   To search for non-ASCII characters, use one of the following methods:

   * Type 'C-q' ('isearch-quote-char'), followed by a non-graphic
     character or a sequence of octal digits.  This adds a character to
     the search string, similar to inserting into a buffer using 'C-q'
     (*note Inserting Text::).  For example, 'C-q C-s' during
     incremental search adds the 'control-S' character to the search
     string.

   * Type 'C-x 8 <RET>' ('isearch-char-by-name'), followed by a Unicode
     name or code-point in hex.  This adds the specified character into
     the search string, similar to the usual 'insert-char' command
     (*note Inserting Text::).

   * Use an input method (*note Input Methods::).  If an input method is
     enabled in the current buffer when you start the search, the same
     method will be active in the minibuffer when you type the search
     string.  While typing the search string, you can toggle the input
     method with 'C-\' ('isearch-toggle-input-method').  You can also
     turn on a non-default input method with 'C-^'
     ('isearch-toggle-specified-input-method'), which prompts for the
     name of the input method.  When an input method is active during
     incremental search, the search prompt includes the input method
     mnemonic, like this:

          I-search [IM]:

     where IM is the mnemonic of the active input method.  Any input
     method you enable during incremental search remains enabled in the
     current buffer afterwards.

   Typing 'M-s o' in incremental search invokes 'isearch-occur', which
runs 'occur' with the current search string.  *Note occur: Other
Repeating Search.

   Typing 'M-%' ('isearch-query-replace') in incremental search invokes
'query-replace' or 'query-replace-regexp' (depending on search mode)
with the current search string used as the string to replace.  A
negative prefix argument means to replace backward.  *Note Query
Replace::.  Typing 'C-M-%' ('isearch-query-replace-regexp') invokes
'query-replace-regexp' with the current search string used as the regexp
to replace.

   Typing 'M-<TAB>' in incremental search invokes 'isearch-complete',
which attempts to complete the search string using the search ring (the
previous search strings you used) as a list of completion alternatives.
*Note Completion::.  In many operating systems, the 'M-<TAB>' key
sequence is captured by the window manager; you then need to rebind
'isearch-complete' to another key sequence if you want to use it (*note
Rebinding::).

   You can exit the search while leaving the matches highlighted by
typing 'M-s h r' ('isearch-highlight-regexp').  This runs
'highlight-regexp' (*note Highlight Interactively::), passing it the
regexp derived from the search string and prompting you for the face to
use for highlighting.  To highlight _whole lines_ containing matches
(rather than _just_ the matches), type 'M-s h l'
('isearch-highlight-lines-matching-regexp').  In either case, to remove
the highlighting, type 'M-s h u' ('unhighlight-regexp').

   When incremental search is active, you can type 'C-h C-h'
('isearch-help-map') to access interactive help options, including a
list of special key bindings.  These key bindings are part of the keymap
'isearch-mode-map' (*note Keymaps::).

   When incremental search is active, typing 'M-s M->' will go to the
last occurrence of the search string, and 'M-s M-<' will go to the first
occurrence.  With a prefix numeric argument of N, these commands will go
to the Nth occurrence of the search string counting from the beginning
or end of the buffer, respectively.

==============================================================================
File: emacs.info,  Node: |Not_Exiting_Isearch|,  Next: |Isearch_Minibuffer|,  Prev: |Special_Isearch|,  Up: |Incremental_Search|
==============================================================================

                                                           *Not_Exiting_Isearch*

15.1.6 Not Exiting Incremental Search
-------------------------------------

This subsection describes how to control whether typing a command not
specifically meaningful in searches exits the search before executing
the command.  It also describes three categories of commands which you
can type without exiting the current incremental search, even though
they are not themselves part of incremental search.

   Normally, typing a command that is not bound by the incremental
search exits the search before executing the command.  Thus, the command
operates on the buffer from which you invoked the search.  However, if
you customize the variable 'search-exit-option' to 'append', the
characters which you type that are not interpreted by the incremental
search are simply appended to the search string.  This is so you could
include in the search string control characters, such as 'C-a', that
would normally exit the search and invoke the command bound to them on
the buffer.

Prefix Arguments
     In incremental search, when you type a command that specifies a
     prefix argument (*note Arguments::), by default it will apply
     either to the next action in the search or to the command that
     exits the search.  In other words, entering a prefix argument will
     not by itself terminate the search.

     In previous versions of Emacs, entering a prefix argument always
     terminated the search.  You can revert to this behavior by setting
     the variable 'isearch-allow-prefix' to 'nil'.

     When 'isearch-allow-scroll' is non-'nil' (see below), prefix
     arguments always have the default behavior described above, i.e.,
     they don't terminate the search, even if 'isearch-allow-prefix' is
     'nil'.

Scrolling Commands
     Normally, scrolling commands exit incremental search.  If you
     change the variable 'isearch-allow-scroll' to a non-'nil' value,
     that enables the use of the scroll-bar, as well as keyboard
     scrolling commands like 'C-v', 'M-v', and 'C-l' (*note
     Scrolling::).  This applies only to calling these commands via
     their bound key sequences--typing 'M-x' will still exit the search.
     You can give prefix arguments to these commands in the usual way.
     This feature normally won't let you scroll the current match out of
     visibility; but if you customize 'isearch-allow-scroll' to the
     special value 'unlimited', that restriction is lifted.

     The 'isearch-allow-scroll' feature also affects some other
     commands, such as 'C-x 2' ('split-window-below') and 'C-x ^'
     ('enlarge-window'), which don't exactly scroll but do affect where
     the text appears on the screen.  It applies to any command whose
     name has a non-'nil' 'isearch-scroll' property.  So you can control
     which commands are affected by changing these properties.

     For example, to make 'C-h l' usable within an incremental search in
     all future Emacs sessions, use 'C-h c' to find what command it runs
     (*note Key Help::), which is 'view-lossage'.  Then you can put the
     following line in your init file (*note Init File::):

          (put 'view-lossage 'isearch-scroll t)

     This feature can be applied to any command that doesn't permanently
     change point, the buffer contents, the match data, the current
     buffer, or the selected window and frame.  The command must not
     itself attempt an incremental search.  This feature is disabled if
     'isearch-allow-scroll' is 'nil' (which it is by default).

Motion Commands
     When 'isearch-yank-on-move' is customized to 'shift', you can
     extend the search string by holding down the shift key while typing
     cursor motion commands.  It will yank text that ends at the new
     position after moving point in the current buffer.

     When 'isearch-yank-on-move' is 't', you can extend the search
     string without using the shift key for cursor motion commands, but
     it applies only for certain motion command that have the
     'isearch-move' property on their symbols.

==============================================================================
File: emacs.info,  Node: |Isearch_Minibuffer|,  Prev: |Not_Exiting_Isearch|,  Up: |Incremental_Search|
==============================================================================

                                                            *Isearch_Minibuffer*

15.1.7 Searching the Minibuffer
-------------------------------

If you start an incremental search while the minibuffer is active, Emacs
searches the contents of the minibuffer.  Unlike searching an ordinary
buffer, the search string is not shown in the echo area, because that is
used to display the minibuffer.

   If an incremental search fails in the minibuffer, it tries searching
the minibuffer history.  *Note Minibuffer History::.  You can visualize
the minibuffer and its history as a series of pages, with the earliest
history element on the first page and the current minibuffer on the last
page.  A forward search, 'C-s', searches forward to later pages; a
reverse search, 'C-r', searches backwards to earlier pages.  Like in
ordinary buffer search, a failing search can wrap around, going from the
last page to the first page or vice versa.

   When the current match is on a history element, that history element
is pulled into the minibuffer.  If you exit the incremental search
normally (e.g., by typing <RET>), it remains in the minibuffer
afterwards.  Canceling the search, with 'C-g', restores the contents of
the minibuffer when you began the search.

==============================================================================
File: emacs.info,  Node: |Nonincremental_Search|,  Next: |Word_Search|,  Prev: |Incremental_Search|,  Up: |Search|
==============================================================================

                                                         *Nonincremental_Search*

15.2 Nonincremental Search
--------------------------

Emacs also has conventional nonincremental search commands, which
require you to type the entire search string before searching begins.

'C-s <RET> STRING <RET>'
     Search for STRING.
'C-r <RET> STRING <RET>'
     Search backward for STRING.

   To start a nonincremental search, first type 'C-s <RET>'.  This
enters the minibuffer to read the search string; terminate the string
with <RET>, and then the search takes place.  If the string is not
found, the search command signals an error.

   When you type 'C-s <RET>', the 'C-s' invokes incremental search as
usual.  That command is specially programmed to invoke the command for
nonincremental search, if the string you specify is empty.  (Such an
empty argument would otherwise be useless.)  'C-r <RET>' does likewise,
invoking the nonincremental backward-searching command.

   Nonincremental search can also be invoked from the menu bar's
'Edit->Search' menu.

   You can also use two simpler commands, 'M-x search-forward' and 'M-x
search-backward'.  These commands look for the literal strings you
specify, and don't support any of the lax-search features (*note Lax
Search::) except case folding.

==============================================================================
File: emacs.info,  Node: |Word_Search|,  Next: |Symbol_Search|,  Prev: |Nonincremental_Search|,  Up: |Search|
==============================================================================

                                                                   *Word_Search*

15.3 Word Search
----------------

A "word search" finds a sequence of words without regard to the type of
punctuation between them.  For instance, if you enter a search string
that consists of two words separated by a single space, the search
matches any sequence of those two words separated by one or more spaces,
newlines, or other punctuation characters.  This is particularly useful
for searching text documents, because you don't have to worry whether
the words you are looking for are separated by newlines or spaces.  Note
that major modes for programming languages or other specialized modes
can modify the definition of a word to suit their syntactic needs.

'M-s w'
     If incremental search is active, toggle word search mode
     ('isearch-toggle-word'); otherwise, begin an incremental forward
     word search ('isearch-forward-word').
'M-s w <RET> WORDS <RET>'
     Search for WORDS, using a forward nonincremental word search.
'M-s w C-r <RET> WORDS <RET>'
     Search backward for WORDS, using a nonincremental word search.
'M-s M-w'
     Search the Web for the text in region.

   To begin a forward incremental word search, type 'M-s w'.  If
incremental search is not already active, this runs the command
'isearch-forward-word'.  If incremental search is already active
(whether a forward or backward search), 'M-s w' runs the command
'isearch-toggle-word', which switches to a word search while keeping the
direction of the search and the current search string unchanged.  You
can toggle word search back off by typing 'M-s w' again.

   To begin a nonincremental word search, type 'M-s w <RET>' for a
forward search, or 'M-s w C-r <RET>' for a backward search.  These run
the commands 'word-search-forward' and 'word-search-backward'
respectively.

   Incremental and nonincremental word searches differ slightly in the
way they find a match.  In a nonincremental word search, each word in
the search string must exactly match a whole word.  In an incremental
word search, the matching is more lax: while you are typing the search
string, its first and last words need not match whole words.  This is so
that the matching can proceed incrementally as you type.  This
additional laxity does not apply to the lazy highlight (*note
Incremental Search::), which always matches whole words.  While you are
typing the search string, 'Pending' appears in the search prompt until
you use a search repeating key like 'C-s'.

   The word search commands don't perform character folding, and
toggling lax whitespace matching (*note lax space matching: Lax Search.)
has no effect on them.

   To search the Web for the text in region, type 'M-s M-w'.  This
command performs an Internet search for the words in region using the
search engine whose URL is specified by the variable 'eww-search-prefix'
(*note EWW: (eww)Basics.).  If the region is not active, or doesn't
contain any words, this command prompts the user for a URL or keywords
to search.

==============================================================================
File: emacs.info,  Node: |Symbol_Search|,  Next: |Regexp_Search|,  Prev: |Word_Search|,  Up: |Search|
==============================================================================

                                                                 *Symbol_Search*

15.4 Symbol Search
------------------

A "symbol search" is much like an ordinary search, except that the
boundaries of the search must match the boundaries of a symbol.  The
meaning of "symbol" in this context depends on the major mode, and
usually refers to a source code token, such as a Lisp symbol in Emacs
Lisp mode.  For instance, if you perform an incremental symbol search
for the Lisp symbol 'forward-word', it would not match
'isearch-forward-word'.  This feature is thus mainly useful for
searching source code.

'M-s _'
     If incremental search is active, toggle symbol search mode
     ('isearch-toggle-symbol'); otherwise, begin an incremental forward
     symbol search ('isearch-forward-symbol').
'M-s .'
     Start a symbol incremental search forward with the symbol found
     near point added to the search string initially.
'M-s _ <RET> SYMBOL <RET>'
     Search forward for SYMBOL, nonincrementally.
'M-s _ C-r <RET> SYMBOL <RET>'
     Search backward for SYMBOL, nonincrementally.

   To begin a forward incremental symbol search, type 'M-s _' (or 'M-s
.' if the symbol to search is near point).  If incremental search is not
already active, 'M-s _' runs the command 'isearch-forward-symbol' and
'M-s .' runs the command 'isearch-forward-symbol-at-point'.  With a
numeric prefix argument of N, 'M-s .' will search for the Nthe next
occurrence of the symbol at point; negative values of N search
backwards.  If incremental search is already active, 'M-s _' switches to
a symbol search, preserving the direction of the search and the current
search string; you can disable symbol search by typing 'M-s _' again.
In incremental symbol search, while you are typing the search string,
only the beginning of the search string is required to match the
beginning of a symbol, and 'Pending' appears in the search prompt until
you use a search repeating key like 'C-s'.

   To begin a nonincremental symbol search, type 'M-s _ <RET>' for a
forward search, or 'M-s _ C-r <RET>' or a backward search.  In
nonincremental symbol searches, the beginning and end of the search
string are required to match the beginning and end of a symbol,
respectively.

   The symbol search commands don't perform character folding, and
toggling lax whitespace matching (*note lax space matching: Lax Search.)
has no effect on them.

==============================================================================
File: emacs.info,  Node: |Regexp_Search|,  Next: |Regexps|,  Prev: |Symbol_Search|,  Up: |Search|
==============================================================================

                                                                 *Regexp_Search*

15.5 Regular Expression Search
------------------------------

A "regular expression" (or "regexp" for short) is a pattern that denotes
a class of alternative strings to match.  Emacs provides both
incremental and nonincremental ways to search for a match for a regexp.
The syntax of regular expressions is explained in the next section.

'C-M-s'
     Begin incremental regexp search ('isearch-forward-regexp').
'C-M-r'
     Begin reverse incremental regexp search
     ('isearch-backward-regexp').

   Incremental search for a regexp is done by typing 'C-M-s'
('isearch-forward-regexp'), by invoking 'C-s' with a prefix argument
(whose value does not matter), or by typing 'M-r' within a forward
incremental search.  This command reads a search string incrementally
just like 'C-s', but it treats the search string as a regexp rather than
looking for an exact match against the text in the buffer.  Each time
you add text to the search string, you make the regexp longer, and the
new regexp is searched for.  To search backward for a regexp, use
'C-M-r' ('isearch-backward-regexp'), 'C-r' with a prefix argument, or
'M-r' within a backward incremental search.

   All of the special key sequences in an ordinary incremental search
(*note Special Isearch::) do similar things in an incremental regexp
search.  For instance, typing 'C-s' immediately after starting the
search retrieves the last incremental search regexp used and searches
forward for it.  Incremental regexp and non-regexp searches have
independent defaults.  They also have separate search rings, which you
can access with 'M-p' and 'M-n'.  The maximum number of search regexps
saved in the search ring is determined by the value of
'regexp-search-ring-max', 16 by default.

   Unlike ordinary incremental search, incremental regexp search does
not use lax space matching by default.  To toggle this feature use 'M-s
<SPC>' ('isearch-toggle-lax-whitespace').  Then any <SPC> typed in
incremental regexp search will match any sequence of one or more
whitespace characters.  The variable 'search-whitespace-regexp'
specifies the regexp for the lax space matching.  *Note Special
Isearch::.

   Also unlike ordinary incremental search, incremental regexp search
cannot use character folding (*note Lax Search::).  (If you toggle
character folding during incremental regexp search with 'M-s '', the
search becomes a non-regexp search and the search pattern you typed is
interpreted as a literal string.)

   In some cases, adding characters to the regexp in an incremental
regexp search can make the cursor move back and start again.  For
example, if you have searched for 'foo' and you add '\|bar', the cursor
backs up in case the first 'bar' precedes the first 'foo'.  *Note
Regexps::.

   Forward and backward regexp search are not symmetrical, because
regexp matching in Emacs always operates forward, starting with the
beginning of the regexp.  Thus, forward regexp search scans forward,
trying a forward match at each possible starting position.  Backward
regexp search scans backward, trying a forward match at each possible
starting position.  These search methods are not mirror images.

   Nonincremental search for a regexp is done with the commands
're-search-forward' and 're-search-backward'.  You can invoke these with
'M-x', or by way of incremental regexp search with 'C-M-s <RET>' and
'C-M-r <RET>'.  When you invoke these commands with 'M-x', they search
for the exact regexp you specify, and thus don't support any lax-search
features (*note Lax Search::) except case folding.

   If you use the incremental regexp search commands with a prefix
argument, they perform ordinary string search, like 'isearch-forward'
and 'isearch-backward'.  *Note Incremental Search::.

==============================================================================
File: emacs.info,  Node: |Regexps|,  Next: |Regexp_Backslash|,  Prev: |Regexp_Search|,  Up: |Search|
==============================================================================

                                                                       *Regexps*

15.6 Syntax of Regular Expressions
----------------------------------

This section (and this manual in general) describes regular expression
features that users typically use.  *Note (elisp)Regular Expressions::,
for additional features used mainly in Lisp programs.

   Regular expressions have a syntax in which a few characters are
"special constructs" and the rest are "ordinary".  An ordinary character
matches that same character and nothing else.  The special characters
are '$^.*+?[\'.  The character ']' is special if it ends a character
alternative (see below).  The character '-' is special inside a
character alternative.  Any other character appearing in a regular
expression is ordinary, unless a '\' precedes it.  (When you use regular
expressions in a Lisp program, each '\' must be doubled, see the example
near the end of this section.)

   For example, 'f' is not a special character, so it is ordinary, and
therefore 'f' is a regular expression that matches the string 'f' and no
other string.  (It does _not_ match the string 'ff'.)  Likewise, 'o' is
a regular expression that matches only 'o'.  (When case distinctions are
being ignored, these regexps also match 'F' and 'O', but we consider
this a generalization of "the same string", rather than an exception.)

   Any two regular expressions A and B can be concatenated.  The result
is a regular expression which matches a string if A matches some amount
of the beginning of that string and B matches the rest of the string.
As a trivial example, concatenating the regular expressions 'f' and 'o'
gives the regular expression 'fo', which matches only the string 'fo'.
To do something less trivial, you need to use one of the special
characters.  Here is a list of them.

'.' (Period)
     is a special character that matches any single character except a
     newline.  For example, the regular expressions 'a.b' matches any
     three-character string that begins with 'a' and ends with 'b'.

'*'
     is not a construct by itself; it is a postfix operator that means
     to match the preceding regular expression repetitively any number
     of times, as many times as possible.  Thus, 'o*' matches any number
     of 'o's, including no 'o's.

     '*' always applies to the _smallest_ possible preceding expression.
     Thus, 'fo*' has a repeating 'o', not a repeating 'fo'.  It matches
     'f', 'fo', 'foo', and so on.

     The matcher processes a '*' construct by matching, immediately, as
     many repetitions as can be found.  Then it continues with the rest
     of the pattern.  If that fails, backtracking occurs, discarding
     some of the matches of the '*'-modified construct in case that
     makes it possible to match the rest of the pattern.  For example,
     in matching 'ca*ar' against the string 'caaar', the 'a*' first
     tries to match all three 'a's; but the rest of the pattern is 'ar'
     and there is only 'r' left to match, so this try fails.  The next
     alternative is for 'a*' to match only two 'a's.  With this choice,
     the rest of the regexp matches successfully.

'+'
     is a postfix operator, similar to '*' except that it must match the
     preceding expression at least once.  Thus, 'ca+r' matches the
     strings 'car' and 'caaaar' but not the string 'cr', whereas 'ca*r'
     matches all three strings.

'?'
     is a postfix operator, similar to '*' except that it can match the
     preceding expression either once or not at all.  Thus, 'ca?r'
     matches 'car' or 'cr', and nothing else.

'*?', '+?', '??'
     are non-"greedy" variants of the operators above.  The normal
     operators '*', '+', '?' match as much as they can, as long as the
     overall regexp can still match.  With a following '?', they will
     match as little as possible.

     Thus, both 'ab*' and 'ab*?' can match the string 'a' and the string
     'abbbb'; but if you try to match them both against the text 'abbb',
     'ab*' will match it all (the longest valid match), while 'ab*?'
     will match just 'a' (the shortest valid match).

     Non-greedy operators match the shortest possible string starting at
     a given starting point; in a forward search, though, the earliest
     possible starting point for match is always the one chosen.  Thus,
     if you search for 'a.*?$' against the text 'abbab' followed by a
     newline, it matches the whole string.  Since it _can_ match
     starting at the first 'a', it does.

'\{N\}'
     is a postfix operator specifying N repetitions--that is, the
     preceding regular expression must match exactly N times in a row.
     For example, 'x\{4\}' matches the string 'xxxx' and nothing else.

'\{N,M\}'
     is a postfix operator specifying between N and M repetitions--that
     is, the preceding regular expression must match at least N times,
     but no more than M times.  If M is omitted, then there is no upper
     limit, but the preceding regular expression must match at least N
     times.
     '\{0,1\}' is equivalent to '?'.
     '\{0,\}' is equivalent to '*'.
     '\{1,\}' is equivalent to '+'.

'[ ... ]'
     is a "character set", beginning with '[' and terminated by ']'.

     In the simplest case, the characters between the two brackets are
     what this set can match.  Thus, '[ad]' matches either one 'a' or
     one 'd', and '[ad]*' matches any string composed of just 'a's and
     'd's (including the empty string).  It follows that 'c[ad]*r'
     matches 'cr', 'car', 'cdr', 'caddaar', etc.

     You can also include character ranges in a character set, by
     writing the starting and ending characters with a '-' between them.
     Thus, '[a-z]' matches any lower-case ASCII letter.  Ranges may be
     intermixed freely with individual characters, as in '[a-z$%.]',
     which matches any lower-case ASCII letter or '$', '%' or period.
     As another example, '[??-????]' matches all lower-case Greek letters.

     You can also include certain special "character classes" in a
     character set.  A '[:' and balancing ':]' enclose a character class
     inside a character alternative.  For instance, '[[:alnum:]]'
     matches any letter or digit.  *Note (elisp)Char Classes::, for a
     list of character classes.

     To include a ']' in a character set, you must make it the first
     character.  For example, '[]a]' matches ']' or 'a'.  To include a
     '-', write '-' as the last character of the set, tho you can also
     put it first or after a range.  Thus, '[]-]' matches both ']' and
     '-'.

     To include '^' in a set, put it anywhere but at the beginning of
     the set.  (At the beginning, it complements the set--see below.)

     When you use a range in case-insensitive search, you should write
     both ends of the range in upper case, or both in lower case, or
     both should be non-letters.  The behavior of a mixed-case range
     such as 'A-z' is somewhat ill-defined, and it may change in future
     Emacs versions.

'[^ ... ]'
     '[^' begins a "complemented character set", which matches any
     character except the ones specified.  Thus, '[^a-z0-9A-Z]' matches
     all characters _except_ ASCII letters and digits.

     '^' is not special in a character set unless it is the first
     character.  The character following the '^' is treated as if it
     were first (in other words, '-' and ']' are not special there).

     A complemented character set can match a newline, unless newline is
     mentioned as one of the characters not to match.  This is in
     contrast to the handling of regexps in programs such as 'grep'.

'^'
     is a special character that matches the empty string, but only at
     the beginning of a line in the text being matched.  Otherwise it
     fails to match anything.  Thus, '^foo' matches a 'foo' that occurs
     at the beginning of a line.

     For historical compatibility reasons, '^' can be used with this
     meaning only at the beginning of the regular expression, or after
     '\(' or '\|'.

'$'
     is similar to '^' but matches only at the end of a line.  Thus,
     'x+$' matches a string of one 'x' or more at the end of a line.

     For historical compatibility reasons, '$' can be used with this
     meaning only at the end of the regular expression, or before '\)'
     or '\|'.

'\'
     has two functions: it quotes the special characters (including
     '\'), and it introduces additional special constructs.

     Because '\' quotes special characters, '\$' is a regular expression
     that matches only '$', and '\[' is a regular expression that
     matches only '[', and so on.

     See the following section for the special constructs that begin
     with '\'.

   Note: for historical compatibility, special characters are treated as
ordinary ones if they are in contexts where their special meanings make
no sense.  For example, '*foo' treats '*' as ordinary since there is no
preceding expression on which the '*' can act.  It is poor practice to
depend on this behavior; it is better to quote the special character
anyway, regardless of where it appears.

   As a '\' is not special inside a character alternative, it can never
remove the special meaning of '-' or ']'.  So you should not quote these
characters when they have no special meaning either.  This would not
clarify anything, since backslashes can legitimately precede these
characters where they _have_ special meaning, as in '[^\]' ('"[^\\]"'
for Lisp string syntax), which matches any single character except a
backslash.

==============================================================================
File: emacs.info,  Node: |Regexp_Backslash|,  Next: |Regexp_Example|,  Prev: |Regexps|,  Up: |Search|
==============================================================================

                                                              *Regexp_Backslash*

15.7 Backslash in Regular Expressions
-------------------------------------

For the most part, '\' followed by any character matches only that
character.  However, there are several exceptions: two-character
sequences starting with '\' that have special meanings.  The second
character in the sequence is always an ordinary character when used on
its own.  Here is a table of '\' constructs.

'\|'
     specifies an alternative.  Two regular expressions A and B with
     '\|' in between form an expression that matches some text if either
     A matches it or B matches it.  It works by trying to match A, and
     if that fails, by trying to match B.

     Thus, 'foo\|bar' matches either 'foo' or 'bar' but no other string.

     '\|' applies to the largest possible surrounding expressions.  Only
     a surrounding '\( ... \)' grouping can limit the grouping power of
     '\|'.

     Full backtracking capability exists to handle multiple uses of
     '\|'.

'\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of '\|' alternatives for other operations.
          Thus, '\(foo\|bar\)x' matches either 'foox' or 'barx'.

       2. To enclose a complicated expression for the postfix operators
          '*', '+' and '?' to operate on.  Thus, 'ba\(na\)*' matches
          'bananana', etc., with any (zero or more) number of 'na'
          strings.

       3. To record a matched substring for future reference.

     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature that is assigned
     as a second meaning to the same '\( ... \)' construct.  In practice
     there is usually no conflict between the two meanings; when there
     is a conflict, you can use a shy group, described below.

'\(?: ... \)'
     specifies a "shy group" that does not record the matched substring;
     you can't refer back to it with '\D' (see below).  This is useful
     in mechanically combining regular expressions, so that you can add
     groups for syntactic purposes without interfering with the
     numbering of the groups that are meant to be referred to.

'\D'
     matches the same text that matched the Dth occurrence of a '\( ...
     \)' construct.  This is called a "back reference".

     After the end of a '\( ... \)' construct, the matcher remembers the
     beginning and end of the text matched by that construct.  Then,
     later on in the regular expression, you can use '\' followed by the
     digit D to mean "match the same text matched the Dth time by the
     '\( ... \)' construct".

     The strings matching the first nine '\( ... \)' constructs
     appearing in a regular expression are assigned numbers 1 through 9
     in the order that the open-parentheses appear in the regular
     expression.  So you can use '\1' through '\9' to refer to the text
     matched by the corresponding '\( ... \)' constructs.

     For example, '\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The '\(.*\)' matches the first
     half, which may be anything, but the '\1' that follows must match
     the same exact text.

     If a particular '\( ... \)' construct matches more than once (which
     can easily happen if it is followed by '*'), only the last match is
     recorded.

'\`'
     matches the empty string, but only at the beginning of the string
     or buffer (or its accessible portion) being matched against.

'\''
     matches the empty string, but only at the end of the string or
     buffer (or its accessible portion) being matched against.

'\='
     matches the empty string, but only at point.

'\b'
     matches the empty string, but only at the beginning or end of a
     word.  Thus, '\bfoo\b' matches any occurrence of 'foo' as a
     separate word.  '\bballs?\b' matches 'ball' or 'balls' as a
     separate word.

     '\b' matches at the beginning or end of the buffer regardless of
     what text appears next to it.

'\B'
     matches the empty string, but _not_ at the beginning or end of a
     word.

'\<'
     matches the empty string, but only at the beginning of a word.
     '\<' matches at the beginning of the buffer only if a
     word-constituent character follows.

'\>'
     matches the empty string, but only at the end of a word.  '\>'
     matches at the end of the buffer only if the contents end with a
     word-constituent character.

'\w'
     matches any word-constituent character.  The syntax table
     determines which characters these are.  *Note Syntax Tables:
     (elisp)Syntax Tables.

'\W'
     matches any character that is not a word-constituent.

'\_<'
     matches the empty string, but only at the beginning of a symbol.  A
     symbol is a sequence of one or more symbol-constituent characters.
     A symbol-constituent character is a character whose syntax is
     either 'w' or '_'.  '\_<' matches at the beginning of the buffer
     only if a symbol-constituent character follows.  As with words, the
     syntax table determines which characters are symbol-constituent.

'\_>'
     matches the empty string, but only at the end of a symbol.  '\_>'
     matches at the end of the buffer only if the contents end with a
     symbol-constituent character.

'\sC'
     matches any character whose syntax is C.  Here C is a character
     that designates a particular syntax class: thus, 'w' for word
     constituent, '-' or ' ' for whitespace, '.' for ordinary
     punctuation, etc.  *Note Syntax Class Table: (elisp)Syntax Class
     Table.

'\SC'
     matches any character whose syntax is not C.

'\cC'
     matches any character that belongs to the category C.  For example,
     '\cc' matches Chinese characters, '\cg' matches Greek characters,
     etc.  For the description of the known categories, type 'M-x
     describe-categories <RET>'.

'\CC'
     matches any character that does _not_ belong to category C.

   The constructs that pertain to words and syntax are controlled by the
setting of the syntax table.  *Note Syntax Tables: (elisp)Syntax Tables.

==============================================================================
File: emacs.info,  Node: |Regexp_Example|,  Next: |Lax_Search|,  Prev: |Regexp_Backslash|,  Up: |Search|
==============================================================================

                                                                *Regexp_Example*

15.8 Regular Expression Example
-------------------------------

Here is an example of a regexp--similar to the regexp that Emacs uses, by
default, to recognize the end of a sentence, not including the following
space (i.e., the variable 'sentence-end-base'):

     [.?!][]\"')}]*

This contains two parts in succession: a character set matching period,
'?', or '!', and a character set matching close-brackets, quotes, or
parentheses, repeated zero or more times.

==============================================================================
File: emacs.info,  Node: |Lax_Search|,  Next: |Replace|,  Prev: |Regexp_Example|,  Up: |Search|
==============================================================================

                                                                    *Lax_Search*

15.9 Lax Matching During Searching
----------------------------------

Normally, you'd want search commands to disregard certain minor
differences between the search string you type and the text being
searched.  For example, sequences of whitespace characters of different
length are usually perceived as equivalent; letter-case differences
usually don't matter; etc.  This is known as "character equivalence".

   This section describes the Emacs lax search features, and how to
tailor them to your needs.

   By default, search commands perform "lax space matching": each space,
or sequence of spaces, matches any sequence of one or more whitespace
characters in the text.  (Incremental regexp search has a separate
default; see *note Regexp Search::.)  Hence, 'foo bar' matches
'foo bar', 'foo  bar', 'foo   bar', and so on (but not 'foobar').  More
precisely, Emacs matches each sequence of space characters in the search
string to a regular expression specified by the variable
'search-whitespace-regexp'.  For example, to make spaces match sequences
of newlines as well as spaces, set it to '"[[:space:]\n]+"'.  The
default value of this variable depends on the buffer's major mode; most
major modes classify spaces, tabs, and formfeed characters as
whitespace.

   If you want whitespace characters to match exactly, you can turn lax
space matching off by typing 'M-s <SPC>'
('isearch-toggle-lax-whitespace') within an incremental search.  Another
'M-s <SPC>' turns lax space matching back on.  To disable lax whitespace
matching for all searches, change 'search-whitespace-regexp' to 'nil';
then each space in the search string matches exactly one space.

   Searches in Emacs by default ignore the case of the text they are
searching through, if you specify the search string in lower case.
Thus, if you specify searching for 'foo', then 'Foo' and 'fOO' also
match.  Regexps, and in particular character sets, behave likewise:
'[ab]' matches 'a' or 'A' or 'b' or 'B'.  This feature is known as "case
folding", and it is supported in both incremental and non-incremental
search modes.

   An upper-case letter anywhere in the search string makes the search
case-sensitive.  Thus, searching for 'Foo' does not find 'foo' or 'FOO'.
This applies to regular expression search as well as to literal string
search.  The effect ceases if you delete the upper-case letter from the
search string.  The variable 'search-upper-case' controls this: if it is
non-'nil', an upper-case character in the search string makes the search
case-sensitive; setting it to 'nil' disables this effect of upper-case
characters.  The default value of this variable is 'not-yanks', which
makes search case-sensitive if there are upper-case letters in the
search string, and also causes text yanked into the search string (*note
Isearch Yank::) to be down-cased, so that such searches are
case-insensitive by default.

   If you set the variable 'case-fold-search' to 'nil', then all letters
must match exactly, including case.  This is a per-buffer variable;
altering the variable normally affects only the current buffer, unless
you change its default value.  *Note Locals::.  This variable applies to
nonincremental searches also, including those performed by the replace
commands (*note Replace::) and the minibuffer history matching commands
(*note Minibuffer History::).

   Typing 'M-c' or 'M-s c' ('isearch-toggle-case-fold') within an
incremental search toggles the case sensitivity of that search.  The
effect does not extend beyond the current incremental search, but it
does override the effect of adding or removing an upper-case letter in
the current search.

   Several related variables control case-sensitivity of searching and
matching for specific commands or activities.  For instance,
'tags-case-fold-search' controls case sensitivity for 'find-tag'.  To
find these variables, do 'M-x apropos-variable <RET> case-fold-search
<RET>'.

   Case folding disregards case distinctions among characters, making
upper-case characters match lower-case variants, and vice versa.  A
generalization of case folding is "character folding", which disregards
wider classes of distinctions among similar characters.  For instance,
under character folding the letter 'a' matches all of its accented
cousins like 'a"' and '??', i.e., the match disregards the diacritics that
distinguish these variants.  In addition, 'a' matches other characters
that resemble it, or have it as part of their graphical representation,
such as U+249C PARENTHESIZED LATIN SMALL LETTER A and U+2100 ACCOUNT OF
(which looks like a small 'a' over 'c').  Similarly, the ASCII
double-quote character '"' matches all the other variants of double
quotes defined by the Unicode standard.  Finally, character folding can
make a sequence of one or more characters match another sequence of a
different length: for example, the sequence of two characters 'ff'
matches U+FB00 LATIN SMALL LIGATURE FF.  Character sequences that are
not identical, but match under character folding are known as
"equivalent character sequences".

   Generally, search commands in Emacs do not by default perform
character folding in order to match equivalent character sequences.  You
can enable this behavior by customizing the variable
'search-default-mode' to 'char-fold-to-regexp'.  *Note Search
Customizations::.  Within an incremental search, typing 'M-s ''
('isearch-toggle-char-fold') toggles character folding, but only for
that search.  (Replace commands have a different default, controlled by
a separate option; see *note Replacement and Lax Matches::.)

   By default, typing an explicit variant of a character, such as 'a"',
as part of the search string doesn't match its base character, such as
'a'.  But if you customize the variable 'char-fold-symmetric' to 't',
then search commands treat equivalent characters the same and use of any
of a set of equivalent characters in a search string finds any of them
in the text being searched, so typing an accented character 'a"' matches
the letter 'a' as well as all the other variants like '??'.

   You can add new foldings using the customizable variable
'char-fold-include', or remove the existing ones using the customizable
variable 'char-fold-exclude'.

==============================================================================
File: emacs.info,  Node: |Replace|,  Next: |Other_Repeating_Search|,  Prev: |Lax_Search|,  Up: |Search|
==============================================================================

                                                                       *Replace*

15.10 Replacement Commands
--------------------------

Emacs provides several commands for performing search-and-replace
operations.  In addition to the simple 'M-x replace-string' command,
there is 'M-%' ('query-replace'), which presents each occurrence of the
search pattern and asks you whether to replace it.

   The replace commands normally operate on the text from point to the
end of the buffer.  When the region is active, they operate on it
instead (*note Mark::).  The basic replace commands replace one "search
string" (or regexp) with one "replacement string".  It is possible to
perform several replacements in parallel, using the command
'expand-region-abbrevs' (*note Expanding Abbrevs::).

MENU

* |Unconditional_Replace|::   Replacing all matches for a string.
* |Regexp_Replace|::          Replacing all matches for a regexp.
* |Replacement_and_Lax_Matches|::
                            Lax searching for text to replace.
* |Query_Replace|::           How to use querying.

==============================================================================
File: emacs.info,  Node: |Unconditional_Replace|,  Next: |Regexp_Replace|,  Up: |Replace|
==============================================================================

                                                         *Unconditional_Replace*

15.10.1 Unconditional Replacement
---------------------------------

'M-x replace-string <RET> STRING <RET> NEWSTRING <RET>'
     Replace every occurrence of STRING with NEWSTRING.

   To replace every instance of 'foo' after point with 'bar', use the
command 'M-x replace-string' with the two arguments 'foo' and 'bar'.
Replacement happens only in the text after point, so if you want to
cover the whole buffer you must go to the beginning first.  All
occurrences up to the end of the buffer are replaced; to limit
replacement to part of the buffer, activate the region around that part.
When the region is active, replacement is limited to the region (*note
Mark::).

   When 'replace-string' exits, it leaves point at the last occurrence
replaced.  It adds the prior position of point (where the
'replace-string' command was issued) to the mark ring, without
activating the mark; use 'C-u C-<SPC>' to move back there.  *Note Mark
Ring::.

   A prefix argument restricts replacement to matches that are
surrounded by word boundaries.

   *Note Replacement and Lax Matches::, for details about
case-sensitivity and character folding in replace commands.

==============================================================================
File: emacs.info,  Node: |Regexp_Replace|,  Next: |Replacement_and_Lax_Matches|,  Prev: |Unconditional_Replace|,  Up: |Replace|
==============================================================================

                                                                *Regexp_Replace*

15.10.2 Regexp Replacement
--------------------------

The 'M-x replace-string' command replaces exact matches for a single
string.  The similar command 'M-x replace-regexp' replaces any match for
a specified regular expression pattern (*note Regexps::).

'M-x replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>'
     Replace every match for REGEXP with NEWSTRING.

   In 'replace-regexp', the NEWSTRING need not be constant: it can refer
to all or part of what is matched by the REGEXP.  '\&' in NEWSTRING
stands for the entire match being replaced.  '\D' in NEWSTRING, where D
is a digit starting from 1, stands for whatever matched the Dth
parenthesized grouping in REGEXP.  (This is called a "back reference".)
'\#' refers to the count of replacements already made in this command,
as a decimal number.  In the first replacement, '\#' stands for '0'; in
the second, for '1'; and so on.  For example,

     M-x replace-regexp <RET> c[ad]+r <RET> \&-safe <RET>

replaces (for example) 'cadr' with 'cadr-safe' and 'cddr' with
'cddr-safe'.

     M-x replace-regexp <RET> \(c[ad]+r\)-safe <RET> \1 <RET>

performs the inverse transformation.  To include a '\' in the text to
replace with, you must enter '\\'.

   If you want to enter part of the replacement string by hand each
time, use '\?' in the replacement string.  Each replacement will ask you
to edit the replacement string in the minibuffer, putting point where
the '\?' was.

   The remainder of this subsection is intended for specialized tasks
and requires knowledge of Lisp.  Most readers can skip it.

   You can use Lisp expressions to calculate parts of the replacement
string.  To do this, write '\,' followed by the expression in the
replacement string.  Each replacement calculates the value of the
expression and converts it to text without quoting (if it's a string,
this means using the string's contents), and uses it in the replacement
string in place of the expression itself.  If the expression is a
symbol, one space in the replacement string after the symbol name goes
with the symbol name, so the value replaces them both.

   Inside such an expression, you can use some special sequences.  '\&'
and '\D' refer here, as usual, to the entire match as a string, and to a
submatch as a string.  D may be multiple digits, and the value of '\D'
is 'nil' if the D'th parenthesized grouping did not match.  You can also
use '\#&' and '\#D' to refer to those matches as numbers (this is valid
when the match or submatch has the form of a numeral).  '\#' here too
stands for the number of already-completed replacements.

   For example, we can exchange 'x' and 'y' this way:

     M-x replace-regexp <RET> \(x\)\|y <RET>
     \,(if \1 "y" "x") <RET>

   For computing replacement strings for '\,', the 'format' function is
often useful (*note (elisp)Formatting Strings::).  For example, to add
consecutively numbered strings like 'ABC00042' to columns 73 to 80
(unless they are already occupied), you can use

     M-x replace-regexp <RET> ^.\{0,72\}$ <RET>
     \,(format "%-72sABC%05d" \& \#) <RET>

==============================================================================
File: emacs.info,  Node: |Replacement_and_Lax_Matches|,  Next: |Query_Replace|,  Prev: |Regexp_Replace|,  Up: |Replace|
==============================================================================

                                                   *Replacement_and_Lax_Matches*

15.10.3 Replace Commands and Lax Matches
----------------------------------------

This subsection describes the behavior of replace commands with respect
to lax matches (*note Lax Search::) and how to customize it.  In
general, replace commands mostly default to stricter matching than their
search counterparts.

   Unlike incremental search, the replacement commands do not use lax
space matching (*note lax space matching: Lax Search.) by default.  To
enable lax space matching for replacement, change the variable
'replace-lax-whitespace' to non-'nil'.  (This only affects how Emacs
finds the text to replace, not the replacement text.)

   A companion variable 'replace-regexp-lax-whitespace' controls whether
'query-replace-regexp' uses lax whitespace matching when searching for
patterns.

   If the first argument of a replace command is all lower case, the
command ignores case while searching for occurrences to replace--provided
'case-fold-search' is non-'nil' and 'search-upper-case' is also
non-'nil'.  If 'search-upper-case' (*note search-upper-case: Lax
Search.) is 'nil', whether searching ignores case is determined by
'case-fold-search' alone, regardless of letter-case of the command's
first argument.  If 'case-fold-search' is set to 'nil', case is always
significant in all searches.

   In addition, when the NEWSTRING argument is all or partly lower case,
replacement commands try to preserve the case pattern of each
occurrence.  Thus, the command

     M-x replace-string <RET> foo <RET> bar <RET>

replaces a lower case 'foo' with a lower case 'bar', an all-caps 'FOO'
with 'BAR', and a capitalized 'Foo' with 'Bar'.  (These three
alternatives--lower case, all caps, and capitalized, are the only ones
that 'replace-string' can distinguish.)

   If upper-case letters are used in the replacement string, they remain
upper case every time that text is inserted.  If upper-case letters are
used in the first argument, the second argument is always substituted
exactly as given, with no case conversion.  Likewise, if either
'case-replace' or 'case-fold-search' is set to 'nil', replacement is
done without case conversion.

   The replacement commands by default do not use character folding
(*note character folding: Lax Search.) when looking for the text to
replace.  To enable character folding for matching in 'query-replace'
and 'replace-string', set the variable 'replace-char-fold' to a
non-'nil' value.  (This setting does not affect the replacement text,
only how Emacs finds the text to replace.  It also doesn't affect
'replace-regexp'.)

==============================================================================
File: emacs.info,  Node: |Query_Replace|,  Prev: |Replacement_and_Lax_Matches|,  Up: |Replace|
==============================================================================

                                                                 *Query_Replace*

15.10.4 Query Replace
---------------------

'M-% STRING <RET> NEWSTRING <RET>'
     Replace some occurrences of STRING with NEWSTRING.
'C-M-% REGEXP <RET> NEWSTRING <RET>'
     Replace some matches for REGEXP with NEWSTRING.

   If you want to change only some of the occurrences of 'foo' to 'bar',
not all of them, use 'M-%' ('query-replace').  This command finds
occurrences of 'foo' one by one, displays each occurrence and asks you
whether to replace it.  Aside from querying, 'query-replace' works just
like 'replace-string' (*note Unconditional Replace::).  In particular,
it preserves case provided 'case-replace' is non-'nil', as it normally
is (*note Replacement and Lax Matches::).  A numeric argument means to
consider only occurrences that are bounded by word-delimiter characters.
A negative prefix argument replaces backward.

   'C-M-%' performs regexp search and replace ('query-replace-regexp').
It works like 'replace-regexp' except that it queries like
'query-replace'.

   You can reuse earlier replacements with these commands.  When
'query-replace' or 'query-replace-regexp' prompts for the search string,
use 'M-p' and 'M-n' to show previous replacements in the form 'FROM ->
TO', where FROM is the search pattern, TO is its replacement, and the
separator between them is determined by the value of the variable
'query-replace-from-to-separator'.  Type <RET> to select the desired
replacement.  If the value of this variable is 'nil', replacements are
not added to the command history, and cannot be reused.

   These commands highlight the current match using the face
'query-replace'.  You can disable this highlight by setting the variable
'query-replace-highlight' to 'nil'.  They highlight other matches using
'lazy-highlight' just like incremental search (*note Incremental
Search::); this can be disabled by setting
'query-replace-lazy-highlight' to 'nil'.  By default,
'query-replace-regexp' will show the substituted replacement string for
the current match in the minibuffer.  If you want to keep special
sequences '\&' and '\N' unexpanded, customize
'query-replace-show-replacement' variable.

   The variable 'query-replace-skip-read-only', if set non-'nil', will
cause replacement commands to ignore matches in read-only text.  The
default is not to ignore them.

   The characters you can type when you are shown a match for the string
or regexp are:

'<SPC>'
'y'
     to replace the occurrence with NEWSTRING.

'<DEL>'
'<Delete>'
'<BACKSPACE>'
'n'
     to skip to the next occurrence without replacing this one.

', (Comma)'
     to replace this occurrence and display the result.  You are then
     asked for another input character to say what to do next.  Since
     the replacement has already been made, <DEL> and <SPC> are
     equivalent in this situation; both move to the next occurrence.

     You can type 'C-r' at this point (see below) to alter the replaced
     text.  You can also undo the replacement with the 'undo' command
     (e.g., type 'C-x u'; *note Undo::); this exits the 'query-replace',
     so if you want to do further replacement you must use 'C-x <ESC>
     <ESC> <RET>' to restart (*note Repetition::).

'<RET>'
'q'
     to exit without doing any more replacements.

'. (Period)'
     to replace this occurrence and then exit without searching for more
     occurrences.

'!'
     to replace all remaining occurrences without asking again.

'^'
     to go back to the position of the previous occurrence (or what used
     to be an occurrence), in case you changed it by mistake or want to
     reexamine it.

'u'
     to undo the last replacement and go back to where that replacement
     was made.

'U'
     to undo all the replacements and go back to where the first
     replacement was made.

'C-r'
     to enter a recursive editing level, in case the occurrence needs to
     be edited rather than just replaced with NEWSTRING.  When you are
     done, exit the recursive editing level with 'C-M-c' to proceed to
     the next occurrence.  *Note Recursive Edit::.

'C-w'
     to delete the occurrence, and then enter a recursive editing level
     as in 'C-r'.  Use the recursive edit to insert text to replace the
     deleted occurrence of STRING.  When done, exit the recursive
     editing level with 'C-M-c' to proceed to the next occurrence.

'e'
     to edit the replacement string in the minibuffer.  When you exit
     the minibuffer by typing <RET>, the minibuffer contents replace the
     current occurrence of the pattern.  They also become the new
     replacement string for any further occurrences.

'C-l'
     to redisplay the screen.  Then you must type another character to
     specify what to do with this occurrence.

'Y (Upper-case)'
     to replace all remaining occurrences in all remaining buffers in
     multi-buffer replacements (like the Dired 'Q' command that performs
     query replace on selected files).  It answers this question and all
     subsequent questions in the series with "yes", without further user
     interaction.

'N (Upper-case)'
     to skip to the next buffer in multi-buffer replacements without
     replacing remaining occurrences in the current buffer.  It answers
     this question "no", gives up on the questions for the current
     buffer, and continues to the next buffer in the sequence.

'C-h'
'?'
'<F1>'
     to display a message summarizing these options.  Then you must type
     another character to specify what to do with this occurrence.

   Aside from this, any other character exits the 'query-replace', and
is then reread as part of a key sequence.  Thus, if you type 'C-k', it
exits the 'query-replace' and then kills to end of line.  In particular,
'C-g' simply exits the 'query-replace'.

   To restart a 'query-replace' once it is exited, use 'C-x <ESC>
<ESC>', which repeats the 'query-replace' because it used the minibuffer
to read its arguments.  *Note C-x <ESC> <ESC>: Repetition.

   The option 'search-invisible' determines how 'query-replace' treats
invisible text.  *Note Outline Search::.

   *Note Operating on Files::, for the Dired 'Q' command which performs
query replace on selected files.  See also *note Transforming File
Names::, for Dired commands to rename, copy, or link files by replacing
regexp matches in file names.

==============================================================================
File: emacs.info,  Node: |Other_Repeating_Search|,  Next: |Search_Customizations|,  Prev: |Replace|,  Up: |Search|
==============================================================================

                                                        *Other_Repeating_Search*

15.11 Other Search-and-Loop Commands
------------------------------------

Here are some other commands that find matches for a regular expression.
They all ignore case in matching, if the pattern contains no upper-case
letters and 'case-fold-search' is non-'nil'.  Aside from 'multi-occur'
and 'multi-occur-in-matching-buffers', which always search the whole
buffer, all operate on the text from point to the end of the buffer, or
on the region if it is active.

'M-x multi-isearch-buffers'
     Prompt for one or more buffer names, ending with <RET>; then, begin
     a multi-buffer incremental search in those buffers.  (If the search
     fails in one buffer, the next 'C-s' tries searching the next
     specified buffer, and so forth.)  With a prefix argument, prompt
     for a regexp and begin a multi-buffer incremental search in buffers
     matching that regexp.

'M-x multi-isearch-buffers-regexp'
     This command is just like 'multi-isearch-buffers', except it
     performs an incremental regexp search.

'M-x multi-isearch-files'
     Prompt for one or more file names, ending with <RET>; then, begin a
     multi-file incremental search in those files.  (If the search fails
     in one file, the next 'C-s' tries searching the next specified
     file, and so forth.)  With a prefix argument, prompt for a regexp
     and begin a multi-file incremental search in files matching that
     regexp.

'M-x multi-isearch-files-regexp'
     This command is just like 'multi-isearch-files', except it performs
     an incremental regexp search.

     In some modes that set the buffer-local variable
     'multi-isearch-next-buffer-function' (e.g., in Change Log mode) a
     multi-file incremental search is activated automatically.

'M-x occur'
'M-s o'
     Prompt for a regexp, and display a list showing each line in the
     buffer that contains a match for it.  If you type 'M-n' at the
     prompt, you can reuse search strings from previous incremental
     searches.  The text that matched is highlighted using the 'match'
     face.  A numeric argument N specifies that N lines of context are
     to be displayed before and after each matching line.

     The default number of context lines is specified by the variable
     'list-matching-lines-default-context-lines'.  When
     'list-matching-lines-jump-to-current-line' is non-'nil' the current
     line is shown highlighted with face
     'list-matching-lines-current-line-face' and the point is set at the
     first match after such line.

     You can also run 'M-s o' when an incremental search is active; this
     uses the current search string.

     Note that matches for the regexp you type are extended to include
     complete lines, and a match that starts before the previous match
     ends is not considered a match.

     In the 'Occur' buffer, you can click on each entry, or move point
     there and type <RET>, to visit the corresponding position in the
     buffer that was searched.  'o' and 'C-o' display the match in
     another window; 'C-o' does not select it.  Alternatively, you can
     use the 'M-g M-n' ('next-error') command to visit the occurrences
     one by one (*note Compilation Mode::).

     Typing 'e' in the 'Occur' buffer switches to Occur Edit mode, in
     which edits made to the entries are also applied to the text in the
     originating buffer.  Type 'C-c C-c' to return to Occur mode.

     The command 'M-x list-matching-lines' is a synonym for 'M-x occur'.

'M-x multi-occur'
     This command is just like 'occur', except it is able to search
     through multiple buffers.  It asks you to specify the buffer names
     one by one.

'M-x multi-occur-in-matching-buffers'
     This command is similar to 'multi-occur', except the buffers to
     search are specified by a regular expression that matches visited
     file names.  With a prefix argument, it uses the regular expression
     to match buffer names instead.

'M-x how-many'
     Prompt for a regexp, and print the number of matches for it in the
     buffer after point.  If the region is active, this operates on the
     region instead.

'M-x flush-lines'
     Prompt for a regexp, and delete each line that contains a match for
     it, operating on the text after point.  When the command finishes,
     it prints the number of deleted matching lines.

     This command deletes the current line if it contains a match
     starting after point.  If the region is active, it operates on the
     region instead; if a line partially contained in the region
     contains a match entirely contained in the region, it is deleted.

     If a match is split across lines, 'flush-lines' deletes all those
     lines.  It deletes the lines before starting to look for the next
     match; hence, it ignores a match starting on the same line at which
     another match ended.

'M-x keep-lines'
     Prompt for a regexp, and delete each line that _does not_ contain a
     match for it, operating on the text after point.  If point is not
     at the beginning of a line, this command always keeps the current
     line.  If the region is active, the command operates on the region
     instead; it never deletes lines that are only partially contained
     in the region (a newline that ends a line counts as part of that
     line).

     If a match is split across lines, this command keeps all those
     lines.

==============================================================================
File: emacs.info,  Node: |Search_Customizations|,  Prev: |Other_Repeating_Search|,  Up: |Search|
==============================================================================

                                                         *Search_Customizations*

15.12 Tailoring Search to Your Needs
------------------------------------

This section describes miscellaneous search-related customizations not
described elsewhere.

   The default search mode for the incremental search is specified by
the variable 'search-default-mode'.  It can be 'nil', 't', or a
function.  If it is 'nil', the default mode is to do literal searches
without character folding, but with case folding and lax-whitespace
matches as determined by 'case-fold-search' and
'search-whitespace-regexp', respectively (*note Lax Search::).  If the
value is 't', incremental search defaults to regexp searches.  The
default value specifies a function that only performs case folding and
lax-whitespace matching.

   The current match of an on-going incremental search is highlighted
using the 'isearch' face.  This highlighting can be disabled by setting
the variable 'search-highlight' to 'nil'.

   The other matches for the search string that are visible on display
are highlighted using the 'lazy-highlight' face.  Setting the variable
'isearch-lazy-highlight' to 'nil' disables this highlighting.  Here are
some other variables that customize the lazy highlighting:

'lazy-highlight-initial-delay'
     Time in seconds to wait before highlighting visible matches.

'lazy-highlight-interval'
     Time in seconds between highlighting successive matches.

'lazy-highlight-max-at-a-time'
     The maximum number of matches to highlight before checking for
     input.  A large number can take some time to highlight, so if you
     want to continue searching and type 'C-s' or 'C-r' during that
     time, Emacs will not respond until it finishes highlighting all
     those matches.  Thus, smaller values make Emacs more responsive.

'isearch-lazy-count'
     Show the current match number and the total number of matches in
     the search prompt.

'lazy-count-prefix-format'
'lazy-count-suffix-format'
     These two variables determine the format of showing the current and
     the total number of matches for 'isearch-lazy-count'.

   Normally, entering <RET> within incremental search when the search
string is empty launches a nonincremental search.  (Actually, it lets
you edit the search string, and the next <RET> does the search.)
However, if you customize the variable 'search-nonincremental-instead'
to 'nil', typing <RET> will always exit the incremental search, even if
the search string is empty.

   By default, incremental search and query-replace commands match
invisible text, but hide any such matches as soon as the current match
moves off the invisible text.  If you customize the variable
'isearch-hide-immediately' to 'nil', any invisible text where matches
were found stays on display until the search or the replace command
exits.

   Searching incrementally on slow terminals, such as displays connected
to remote machines over slow connection, could be annoying due to the
need to redraw large portions of the display as the search proceeds.
Emacs provides a special display mode for slow terminals, whereby search
pops up a separate small window and displays the text surrounding the
match in that window.  Small windows display faster, so the annoying
effect of slow speed is alleviated.  The variable 'search-slow-speed'
determines the baud rate threshold below which Emacs will use this
display mode.  The variable 'search-slow-window-lines' controls the
number of lines in the window Emacs pops up for displaying the search
results; the default is 1 line.  Normally, this window will pop up at
the bottom of the window that displays the buffer where you start
searching, but if the value of 'search-slow-window-lines' is negative,
that means to put the window at the top and give it the number of lines
that is the absolute value of 'search-slow-window-lines'.

==============================================================================
File: emacs.info,  Node: |Fixit|,  Next: |Keyboard_Macros|,  Prev: |Search|,  Up: |Top|
==============================================================================

                                                                         *Fixit*

16 Commands for Fixing Typos
============================

In this chapter we describe commands that are useful when you catch a
mistake while editing.  The most fundamental of these commands is the
undo command 'C-/' (also bound to 'C-x u' and 'C-_').  This undoes a
single command, or a part of a command (as in the case of
'query-replace'), or several consecutive character insertions.
Consecutive repetitions of 'C-/' undo earlier and earlier changes, back
to the limit of the undo information available.

   Aside from the commands described here, you can erase text using
deletion commands such as <DEL> ('delete-backward-char').  These were
described earlier in this manual.  *Note Erasing::.

MENU

* |Undo|::        The Undo commands.
* |Transpose|::   Exchanging two characters, words, lines, lists...
* |Fixing_Case|:: Correcting case of last word entered.
* |Spelling|::    Apply spelling checker to a word, or a whole file.

==============================================================================
File: emacs.info,  Node: |Undo|,  Next: |Transpose|,  Up: |Fixit|
==============================================================================

                                                                          *Undo*

16.1 Undo
---------

The "undo" command reverses recent changes in the buffer's text.  Each
buffer records changes individually, and the undo command always applies
to the current buffer.  You can undo all the changes in a buffer for as
far back as the buffer's records go.  Usually, each editing command
makes a separate entry in the undo records, but some commands such as
'query-replace' divide their changes into multiple entries for
flexibility in undoing.  Consecutive character insertion commands are
usually grouped together into a single undo record, to make undoing less
tedious.

'C-/'
'C-x u'
'C-_'
     Undo one entry in the current buffer's undo records ('undo').

   To begin to undo, type 'C-/' (or its aliases, 'C-_' or 'C-x u')(1).
This undoes the most recent change in the buffer, and moves point back
to where it was before that change.  Consecutive repetitions of 'C-/'
(or its aliases) undo earlier and earlier changes in the current buffer.
If all the recorded changes have already been undone, the undo command
signals an error.

   Any command other than an undo command breaks the sequence of undo
commands.  Starting from that moment, the entire sequence of undo
commands that you have just performed are themselves placed into the
undo record.  Therefore, to re-apply changes you have undone, type 'C-f'
or any other command that harmlessly breaks the sequence of undoing;
then type 'C-/' one or more times to undo some of the undo commands.

   Alternatively, if you want to resume undoing, without redoing
previous undo commands, use 'M-x undo-only'.  This is like 'undo', but
will not redo changes you have just undone.

   If you notice that a buffer has been modified accidentally, the
easiest way to recover is to type 'C-/' repeatedly until the stars
disappear from the front of the mode line (*note Mode Line::).  Whenever
an undo command makes the stars disappear from the mode line, it means
that the buffer contents are the same as they were when the file was
last read in or saved.  If you do not remember whether you changed the
buffer deliberately, type 'C-/' once.  When you see the last change you
made undone, you will see whether it was an intentional change.  If it
was an accident, leave it undone.  If it was deliberate, redo the change
as described above.

   Alternatively, you can discard all the changes since the buffer was
last visited or saved with 'M-x revert-buffer' (*note Reverting::).

   When there is an active region, any use of 'undo' performs "selective
undo": it undoes the most recent change within the region, instead of
the entire buffer.  However, when Transient Mark mode is off (*note
Disabled Transient Mark::), 'C-/' always operates on the entire buffer,
ignoring the region.  In this case, you can perform selective undo by
supplying a prefix argument to the 'undo' command: 'C-u C-/'.  To undo
further changes in the same region, repeat the 'undo' command (no prefix
argument is needed).

   Some specialized buffers do not make undo records.  Buffers whose
names start with spaces never do; these buffers are used internally by
Emacs to hold text that users don't normally look at or edit.

   When the undo information for a buffer becomes too large, Emacs
discards the oldest records from time to time (during "garbage
collection").  You can specify how much undo information to keep by
setting the variables 'undo-limit', 'undo-strong-limit', and
'undo-outer-limit'.  Their values are expressed in bytes.

   The variable 'undo-limit' sets a soft limit: Emacs keeps undo data
for enough commands to reach this size, and perhaps exceed it, but does
not keep data for any earlier commands beyond that.  Its default value
is 160000.  The variable 'undo-strong-limit' sets a stricter limit: any
previous command (though not the most recent one) that pushes the size
past this amount is forgotten.  The default value of 'undo-strong-limit'
is 240000.

   Regardless of the values of those variables, the most recent change
is never discarded unless it gets bigger than 'undo-outer-limit'
(normally 24,000,000).  At that point, Emacs discards the undo data and
warns you about it.  This is the only situation in which you cannot undo
the last command.  If this happens, you can increase the value of
'undo-outer-limit' to make it even less likely to happen in the future.
But if you didn't expect the command to create such large undo data,
then it is probably a bug and you should report it.  *Note Reporting
Bugs: Bugs.

   ---------- Footnotes ----------

   (1) Aside from 'C-/', the 'undo' command is also bound to 'C-x u'
because that is more straightforward for beginners to remember: 'u'
stands for "undo".  It is also bound to 'C-_' because typing 'C-/' on
some text terminals actually enters 'C-_'.

==============================================================================
File: emacs.info,  Node: |Transpose|,  Next: |Fixing_Case|,  Prev: |Undo|,  Up: |Fixit|
==============================================================================

                                                                     *Transpose*

16.2 Transposing Text
---------------------

'C-t'
     Transpose two characters ('transpose-chars').
'M-t'
     Transpose two words ('transpose-words').
'C-M-t'
     Transpose two balanced expressions ('transpose-sexps').
'C-x C-t'
     Transpose two lines ('transpose-lines').
'M-x transpose-sentences'
     Transpose two sentences ('transpose-sentences').
'M-x transpose-paragraphs'
     Transpose two paragraphs ('transpose-paragraphs').
'M-x transpose-regions'
     Transpose two regions.

   The common error of transposing two characters can be fixed, when
they are adjacent, with the 'C-t' command ('transpose-chars').
Normally, 'C-t' transposes the two characters on either side of point.
When given at the end of a line, rather than transposing the last
character of the line with the newline, which would be useless, 'C-t'
transposes the last two characters on the line.  So, if you catch your
transposition error right away, you can fix it with just a 'C-t'.  If
you don't catch it so fast, you must move the cursor back between the
two transposed characters before you type 'C-t'.  If you transposed a
space with the last character of the word before it, the word motion
commands ('M-f', 'M-b', etc.)  are a good way of getting there.
Otherwise, a reverse search ('C-r') is often the best way.  *Note
Search::.

   'M-t' transposes the word before point with the word after point
('transpose-words').  It moves point forward over a word, dragging the
word preceding or containing point forward as well.  The punctuation
characters between the words do not move.  For example, 'FOO, BAR'
transposes into 'BAR, FOO' rather than 'BAR FOO,'.  When point is at the
end of the line, it will transpose the word before point with the first
word on the next line.

   'C-M-t' ('transpose-sexps') is a similar command for transposing two
expressions (*note Expressions::), and 'C-x C-t' ('transpose-lines')
exchanges lines.  'M-x transpose-sentences' and 'M-x
transpose-paragraphs' transpose sentences and paragraphs, respectively.
These commands work like 'M-t' except as regards the units of text they
transpose.

   A numeric argument to a transpose command serves as a repeat count:
it tells the transpose command to move the character (or word or
expression or line) before or containing point across several other
characters (or words or expressions or lines).  For example, 'C-u 3 C-t'
moves the character before point forward across three other characters.
It would change 'f-!-oobar' into 'oobf-!-ar'.  This is equivalent to
repeating 'C-t' three times.  'C-u - 4 M-t' moves the word before point
backward across four words.  'C-u - C-M-t' would cancel the effect of
plain 'C-M-t'.

   A numeric argument of zero is assigned a special meaning (because
otherwise a command with a repeat count of zero would do nothing): to
transpose the character (or word or expression or line) ending after
point with the one ending after the mark.

   'M-x transpose-regions' transposes the text between point and mark
with the text between the last two marks pushed to the mark ring (*note
Setting Mark::).  With a numeric prefix argument, it transposes the text
between point and mark with the text between two successive marks that
many entries back in the mark ring.  This command is best used for
transposing multiple characters (or words or sentences or paragraphs) in
one go.

==============================================================================
File: emacs.info,  Node: |Fixing_Case|,  Next: |Spelling|,  Prev: |Transpose|,  Up: |Fixit|
==============================================================================

                                                                   *Fixing_Case*

16.3 Case Conversion
--------------------

'M-- M-l'
     Convert last word to lower case.  Note 'Meta--' is Meta-minus.
'M-- M-u'
     Convert last word to all upper case.
'M-- M-c'
     Convert last word to lower case with capital initial.

   A very common error is to type words in the wrong case.  Because of
this, the word case-conversion commands 'M-l', 'M-u', and 'M-c' have a
special feature when used with a negative argument: they do not move the
cursor.  As soon as you see you have mistyped the last word, you can
simply case-convert it and go on typing.  *Note Case::.

==============================================================================
File: emacs.info,  Node: |Spelling|,  Prev: |Fixing_Case|,  Up: |Fixit|
==============================================================================

                                                                      *Spelling*

16.4 Checking and Correcting Spelling
-------------------------------------

This section describes the commands to check the spelling of a single
word or of a portion of a buffer.  These commands only work if a
spelling checker program, one of Hunspell, Aspell, Ispell or Enchant, is
installed.  These programs are not part of Emacs, but one of them is
usually installed on GNU/Linux and other free operating systems.  *Note
Aspell: (aspell)Top.

'M-$'
     Check and correct spelling of the word at point ('ispell-word').
     If the region is active, do it for all words in the region instead.
'M-x ispell'
     Check and correct spelling of all words in the buffer.  If the
     region is active, do it for all words in the region instead.
'M-x ispell-buffer'
     Check and correct spelling in the buffer.
'M-x ispell-region'
     Check and correct spelling in the region.
'M-x ispell-message'
     Check and correct spelling in a draft mail message, excluding cited
     material.
'M-x ispell-change-dictionary <RET> DICT <RET>'
     Restart the spell-checker process, using DICT as the dictionary.
'M-x ispell-kill-ispell'
     Kill the spell-checker subprocess.
'M-<TAB>'
'<ESC> <TAB>'
'C-M-i'
     Complete the word before point based on the spelling dictionary
     ('ispell-complete-word').
'M-x flyspell-mode'
     Enable Flyspell mode, which highlights all misspelled words.
'M-x flyspell-prog-mode'
     Enable Flyspell mode for comments and strings only.

   To check the spelling of the word around or before point, and
optionally correct it as well, type 'M-$' ('ispell-word').  If a region
is active, 'M-$' checks the spelling of all words within the region.
*Note Mark::.  (When Transient Mark mode is off, 'M-$' always acts on
the word around or before point, ignoring the region; *note Disabled
Transient Mark::.)

   Similarly, the command 'M-x ispell' performs spell-checking in the
region if one is active, or in the entire buffer otherwise.  The
commands 'M-x ispell-buffer' and 'M-x ispell-region' explicitly perform
spell-checking on the entire buffer or the region respectively.  To
check spelling in an email message you are writing, use
'M-x ispell-message'; that command checks the whole buffer, except for
material that is indented or appears to be cited from other messages.
*Note Sending Mail::.

   When one of these commands encounters what appears to be an incorrect
word, it asks you what to do.  It usually displays a list of numbered
"near-misses"--words that are close to the incorrect word.  Then you must
type a single-character response.  Here are the valid responses:

'DIGIT'
     Replace the word, just this time, with one of the displayed
     near-misses.  Each near-miss is listed with a digit; type that
     digit to select it.

'<SPC>'
     Skip this word--continue to consider it incorrect, but don't change
     it here.

'r NEW <RET>'
     Replace the word, just this time, with NEW.  (The replacement
     string will be rescanned for more spelling errors.)

'R NEW <RET>'
     Replace the word with NEW, and do a 'query-replace' so you can
     replace it elsewhere in the buffer if you wish.  (The replacements
     will be rescanned for more spelling errors.)

'a'
     Accept the incorrect word--treat it as correct, but only in this
     editing session.

'A'
     Accept the incorrect word--treat it as correct, but only in this
     editing session and for this buffer.

'i'
     Insert this word in your private dictionary file so that it will be
     considered correct from now on, even in future sessions.

'm'
     Like 'i', but you can also specify dictionary completion
     information.

'u'
     Insert the lower-case version of this word in your private
     dictionary file.

'l WORD <RET>'
     Look in the dictionary for words that match WORD.  These words
     become the new list of near-misses; you can select one of them as
     the replacement by typing a digit.  You can use '*' in WORD as a
     wildcard.

'C-g'
'X'
     Quit interactive spell-checking, leaving point at the word that was
     being checked.  You can restart checking again afterward with
     'C-u M-$'.

'x'
     Quit interactive spell-checking and move point back to where it was
     when you started spell-checking.

'q'
     Quit interactive spell-checking and kill the spell-checker
     subprocess.

'?'
     Show the list of options.

   In Text mode and related modes, 'M-<TAB>' ('ispell-complete-word')
performs in-buffer completion based on spelling correction.  Insert the
beginning of a word, and then type 'M-<TAB>'; this shows a list of
completions.  (If your window manager intercepts 'M-<TAB>', type
'<ESC> <TAB>' or 'C-M-i'.)  Each completion is listed with a digit or
character; type that digit or character to choose it.

   Once started, the spell-checker subprocess continues to run, waiting
for something to do, so that subsequent spell-checking commands complete
more quickly.  If you want to get rid of the process, use
'M-x ispell-kill-ispell'.  This is not usually necessary, since the
process uses no processor time except when you do spelling correction.

   Spell-checkers look up spelling in two dictionaries: the standard
dictionary and your personal dictionary.  The standard dictionary is
specified by the variable 'ispell-local-dictionary' or, if that is
'nil', by the variable 'ispell-dictionary'.  If both are 'nil', the
spelling program's default dictionary is used.  The command
'M-x ispell-change-dictionary' sets the standard dictionary for the
buffer and then restarts the subprocess, so that it will use a different
standard dictionary.  Your personal dictionary is specified by the
variable 'ispell-personal-dictionary'.  If that is 'nil', the spelling
program looks for a personal dictionary in a default location, which is
specific to each spell-checker.

   A separate dictionary is used for word completion.  The variable
'ispell-complete-word-dict' specifies the file name of this dictionary.
The completion dictionary must be different because it cannot use the
information about roots and affixes of the words, which spell-checking
uses to detect variations of words.  For some languages, there is a
spell-checking dictionary but no word completion dictionary.

   Flyspell mode is a minor mode that performs automatic spell-checking
of the text you type as you type it.  When it finds a word that it does
not recognize, it highlights that word.  Type 'M-x flyspell-mode' to
toggle Flyspell mode in the current buffer.  To enable Flyspell mode in
all text mode buffers, add 'flyspell-mode' to 'text-mode-hook'.  *Note
Hooks::.  Note that, as Flyspell mode needs to check each word across
which you move, it will slow down cursor motion and scrolling commands.
It also doesn't automatically check the text you didn't type or move
across; use 'flyspell-region' or 'flyspell-buffer' for that.

   When Flyspell mode highlights a word as misspelled, you can click on
it with 'mouse-2' ('flyspell-correct-word') to display a menu of
possible corrections and actions.  In addition, 'C-.' or '<ESC>-<TAB>'
('flyspell-auto-correct-word') will propose various successive
corrections for the word at point, and 'C-c $'
('flyspell-correct-word-before-point') will pop up a menu of possible
corrections.  Of course, you can always correct the misspelled word by
editing it manually in any way you like.

   Flyspell Prog mode works just like ordinary Flyspell mode, except
that it only checks words in comments and string constants.  This
feature is useful for editing programs.  Type 'M-x flyspell-prog-mode'
to enable or disable this mode in the current buffer.  To enable this
mode in all programming mode buffers, add 'flyspell-prog-mode' to
'prog-mode-hook' (*note Hooks::).

==============================================================================
File: emacs.info,  Node: |Keyboard_Macros|,  Next: |Files|,  Prev: |Fixit|,  Up: |Top|
==============================================================================

                                                               *Keyboard_Macros*

17 Keyboard Macros
==================

In this chapter we describe how to record a sequence of editing commands
so you can repeat it conveniently later.

   A "keyboard macro" is a command defined by an Emacs user to stand for
another sequence of keys.  For example, if you discover that you are
about to type 'C-n M-d C-d' forty times, you can speed your work by
defining a keyboard macro to do 'C-n M-d C-d', and then executing it 39
more times.

   You define a keyboard macro by executing and recording the commands
which are its definition.  Put differently, as you define a keyboard
macro, the definition is being executed for the first time.  This way,
you can see the effects of your commands, so that you don't have to
figure them out in your head.  When you close the definition, the
keyboard macro is defined and also has been, in effect, executed once.
You can then do the whole thing over again by invoking the macro.

   Keyboard macros differ from ordinary Emacs commands in that they are
written in the Emacs command language rather than in Lisp.  This makes
it easier for the novice to write them, and makes them more convenient
as temporary hacks.  However, the Emacs command language is not powerful
enough as a programming language to be useful for writing anything
intelligent or general.  For such things, Lisp must be used.

MENU

* |Basic_Keyboard_Macro|::     Defining and running keyboard macros.
* |Keyboard_Macro_Ring|::      Where previous keyboard macros are saved.
* |Keyboard_Macro_Counter|::   Inserting incrementing numbers in macros.
* |Keyboard_Macro_Query|::     Making keyboard macros do different things each
                               time.
* |Save_Keyboard_Macro|::      Giving keyboard macros names; saving them in
                               files.
* |Edit_Keyboard_Macro|::      Editing keyboard macros.
* |Keyboard_Macro_Step_Edit|:: Interactively executing and editing a keyboard
                               macro.

==============================================================================
File: emacs.info,  Node: |Basic_Keyboard_Macro|,  Next: |Keyboard_Macro_Ring|,  Up: |Keyboard_Macros|
==============================================================================

                                                          *Basic_Keyboard_Macro*

17.1 Basic Use
--------------

'<F3>'
     Start defining a keyboard macro
     ('kmacro-start-macro-or-insert-counter').
'<F4>'
     If a keyboard macro is being defined, end the definition;
     otherwise, execute the most recent keyboard macro
     ('kmacro-end-or-call-macro').
'C-u <F3>'
     Re-execute last keyboard macro, then append keys to its definition.
'C-u C-u <F3>'
     Append keys to the last keyboard macro without re-executing it.
'C-x C-k r'
     Run the last keyboard macro on each line that begins in the region
     ('apply-macro-to-region-lines').
'C-x ('
     Start defining a keyboard macro (old style) ('kmacro-start-macro');
     with a prefix argument, append keys to the last macro.
'C-x )'
     End a macro definition (old style) ('kmacro-end-macro'); prefix
     argument serves as the repeat count for executing the macro.
'C-x e'
     Execute the most recently defined keyboard macro
     ('kmacro-end-and-call-macro'); prefix argument serves as repeat
     count.

   To start defining a keyboard macro, type <F3>.  From then on, your
keys continue to be executed, but also become part of the definition of
the macro.  'Def' appears in the mode line to remind you of what is
going on.  When you are finished, type <F4> ('kmacro-end-or-call-macro')
to terminate the definition.  For example,

     <F3> M-f foo <F4>

defines a macro to move forward a word and then insert 'foo'.  Note that
<F3> and <F4> do not become part of the macro.

   After defining the macro, you can call it with <F4>.  For the above
example, this has the same effect as typing 'M-f foo' again.  (Note the
two roles of the <F4> command: it ends the macro if you are in the
process of defining one, or calls the last macro otherwise.)  You can
also supply <F4> with a numeric prefix argument 'n', which means to
invoke the macro 'n' times.  An argument of zero repeats the macro
indefinitely, until it gets an error or you type 'C-g' (or, on MS-DOS,
'C-<BREAK>').

   The above example demonstrates a handy trick that you can employ with
keyboard macros: if you wish to repeat an operation at regularly spaced
places in the text, include a motion command as part of the macro.  In
this case, repeating the macro inserts the string 'foo' after each
successive word.

   After terminating the definition of a keyboard macro, you can append
more keystrokes to its definition by typing 'C-u <F3>'.  This is
equivalent to plain <F3> followed by retyping the whole definition so
far.  As a consequence, it re-executes the macro as previously defined.
If you change the variable 'kmacro-execute-before-append' to 'nil', the
existing macro will not be re-executed before appending to it (the
default is 't').  You can also add to the end of the definition of the
last keyboard macro without re-executing it by typing 'C-u C-u <F3>'.

   When a command reads an argument with the minibuffer, your minibuffer
input becomes part of the macro along with the command.  So when you
replay the macro, the command gets the same argument as when you entered
the macro.  For example,

     <F3> C-a C-k C-x b foo <RET> C-y C-x b <RET> <F4>

defines a macro that kills the current line, yanks it into the buffer
'foo', then returns to the original buffer.

   Most keyboard commands work as usual in a keyboard macro definition,
with some exceptions.  Typing 'C-g' ('keyboard-quit') quits the keyboard
macro definition.  Typing 'C-M-c' ('exit-recursive-edit') can be
unreliable: it works as you'd expect if exiting a recursive edit that
started within the macro, but if it exits a recursive edit that started
before you invoked the keyboard macro, it also necessarily exits the
keyboard macro too.  Mouse events are also unreliable, even though you
can use them in a keyboard macro: when the macro replays the mouse
event, it uses the original mouse position of that event, the position
that the mouse had while you were defining the macro.  The effect of
this may be hard to predict.

   The command 'C-x C-k r' ('apply-macro-to-region-lines') repeats the
last defined keyboard macro on each line that begins in the region.  It
does this line by line, by moving point to the beginning of the line and
then executing the macro.

   In addition to the <F3> and <F4> commands described above, Emacs also
supports an older set of key bindings for defining and executing
keyboard macros.  To begin a macro definition, type 'C-x ('
('kmacro-start-macro'); as with <F3>, a prefix argument appends this
definition to the last keyboard macro.  To end a macro definition, type
'C-x )' ('kmacro-end-macro').  To execute the most recent macro, type
'C-x e' ('kmacro-end-and-call-macro').  If you enter 'C-x e' while
defining a macro, the macro is terminated and executed immediately.
Immediately after typing 'C-x e', you can type 'e' repeatedly to
immediately repeat the macro one or more times.  You can also give 'C-x
e' a repeat argument, just like <F4> (when it is used to execute a
macro).

   'C-x )' can be given a repeat count as an argument.  This means to
repeat the macro right after defining it.  The macro definition itself
counts as the first repetition, since it is executed as you define it,
so 'C-u 4 C-x )' executes the macro immediately 3 additional times.

==============================================================================
File: emacs.info,  Node: |Keyboard_Macro_Ring|,  Next: |Keyboard_Macro_Counter|,  Prev: |Basic_Keyboard_Macro|,  Up: |Keyboard_Macros|
==============================================================================

                                                           *Keyboard_Macro_Ring*

17.2 The Keyboard Macro Ring
----------------------------

All defined keyboard macros are recorded in the "keyboard macro ring".
There is only one keyboard macro ring, shared by all buffers.

'C-x C-k C-k'
     Execute the keyboard macro at the head of the ring
     ('kmacro-end-or-call-macro-repeat').
'C-x C-k C-n'
     Rotate the keyboard macro ring to the next macro (defined earlier)
     ('kmacro-cycle-ring-next').
'C-x C-k C-p'
     Rotate the keyboard macro ring to the previous macro (defined
     later) ('kmacro-cycle-ring-previous').

   All commands which operate on the keyboard macro ring use the same
'C-x C-k' prefix.  Most of these commands can be executed and repeated
immediately after each other without repeating the 'C-x C-k' prefix.
For example,

     C-x C-k C-p C-p C-k C-k C-k C-n C-n C-k C-p C-k C-d

will rotate the keyboard macro ring to the second-previous macro,
execute the resulting head macro three times, rotate back to the
original head macro, execute that once, rotate to the previous macro,
execute that, and finally delete it from the macro ring.

   The command 'C-x C-k C-k' ('kmacro-end-or-call-macro-repeat')
executes the keyboard macro at the head of the macro ring.  You can
repeat the macro immediately by typing another 'C-k', or you can rotate
the macro ring immediately by typing 'C-n' or 'C-p'.

   When a keyboard macro is being defined, 'C-x C-k C-k' behaves like
<F4> except that, immediately afterward, you can use most key bindings
of this section without the 'C-x C-k' prefix.  For instance, another
'C-k' will re-execute the macro.

   The commands 'C-x C-k C-n' ('kmacro-cycle-ring-next') and 'C-x C-k
C-p' ('kmacro-cycle-ring-previous') rotate the macro ring, bringing the
next or previous keyboard macro to the head of the macro ring.  The
definition of the new head macro is displayed in the echo area.  You can
continue to rotate the macro ring immediately by repeating just 'C-n'
and 'C-p' until the desired macro is at the head of the ring.  To
execute the new macro ring head immediately, just type 'C-k'.

   Note that Emacs treats the head of the macro ring as the last defined
keyboard macro.  For instance, <F4> will execute that macro, and 'C-x
C-k n' will give it a name.

   The maximum number of macros stored in the keyboard macro ring is
determined by the customizable variable 'kmacro-ring-max'.

==============================================================================
File: emacs.info,  Node: |Keyboard_Macro_Counter|,  Next: |Keyboard_Macro_Query|,  Prev: |Keyboard_Macro_Ring|,  Up: |Keyboard_Macros|
==============================================================================

                                                        *Keyboard_Macro_Counter*

17.3 The Keyboard Macro Counter
-------------------------------

Each keyboard macro has an associated counter, which is initialized to 0
when you start defining the macro.  This "current counter" allows you to
insert a number into the buffer that depends on the number of times the
macro has been called.  The counter is normally incremented each time
its value is inserted into the buffer.

   In addition to the current counter, keyboard macros also maintain the
"previous counter", which records the value the current counter had last
time it was incremented or set.  Note that incrementing the current
counter by zero, e.g., with 'C-u 0 C-x C-k C-i', also records the value
of the current counter as the previous counter value.

'<F3>'
     In a keyboard macro definition, insert the keyboard macro counter
     value in the buffer ('kmacro-start-macro-or-insert-counter').
'C-x C-k C-i'
     Insert the keyboard macro counter value in the buffer
     ('kmacro-insert-counter').
'C-x C-k C-c'
     Set the keyboard macro counter ('kmacro-set-counter').
'C-x C-k C-a'
     Add the prefix arg to the keyboard macro counter
     ('kmacro-add-counter').
'C-x C-k C-f'
     Specify the format for inserting the keyboard macro counter
     ('kmacro-set-format').

   When you are defining a keyboard macro, the command <F3>
('kmacro-start-macro-or-insert-counter') inserts the current value of
the keyboard macro's counter into the buffer, and increments the counter
by 1.  (If you are not defining a macro, <F3> begins a macro definition
instead.  *Note Basic Keyboard Macro::.)  You can use a numeric prefix
argument to specify a different increment.  If you just specify a 'C-u'
prefix, that inserts the previous counter value, and doesn't change the
current value.

   As an example, let us show how the keyboard macro counter can be used
to build a numbered list.  Consider the following key sequence:

     <F3> C-a <F3> . <SPC> <F4>

As part of this keyboard macro definition, the string '0. ' was inserted
into the beginning of the current line.  If you now move somewhere else
in the buffer and type <F4> to invoke the macro, the string '1. ' is
inserted at the beginning of that line.  Subsequent invocations insert
'2. ', '3. ', and so forth.

   The command 'C-x C-k C-i' ('kmacro-insert-counter') does the same
thing as <F3>, but it can be used outside a keyboard macro definition.
When no keyboard macro is being defined or executed, it inserts and
increments the counter of the macro at the head of the keyboard macro
ring.

   The command 'C-x C-k C-c' ('kmacro-set-counter') sets the current
macro counter to the value of the numeric argument.  If you use it
inside the macro, it operates on each repetition of the macro.  If you
specify just 'C-u' as the prefix, while executing the macro, that resets
the counter to the value it had at the beginning of the current
repetition of the macro (undoing any increments so far in this
repetition).

   The command 'C-x C-k C-a' ('kmacro-add-counter') adds the prefix
argument to the current macro counter.  With just 'C-u' as argument, it
resets the counter to the last value inserted by any keyboard macro.
(Normally, when you use this, the last insertion will be in the same
macro and it will be the same counter.)

   The command 'C-x C-k C-f' ('kmacro-set-format') prompts for the
format to use when inserting the macro counter.  The default format is
'%d', which means to insert the number in decimal without any padding.
You can exit with empty minibuffer to reset the format to this default.
You can specify any format string that the 'format' function accepts and
that makes sense with a single integer extra argument (*note
(elisp)Formatting Strings::).  Do not put the format string inside
double quotes when you insert it in the minibuffer.

   If you use this command while no keyboard macro is being defined or
executed, the new format affects all subsequent macro definitions.
Existing macros continue to use the format in effect when they were
defined.  If you set the format while defining a keyboard macro, this
affects the macro being defined from that point on, but it does not
affect subsequent macros.  Execution of the macro will, at each step,
use the format in effect at that step during its definition.  Changes to
the macro format during execution of a macro, like the corresponding
changes during its definition, have no effect on subsequent macros.

   The format set by 'C-x C-k C-f' does not affect insertion of numbers
stored in registers.

   If you use a register as a counter, incrementing it on each
repetition of the macro, that accomplishes the same thing as a keyboard
macro counter.  *Note Number Registers::.  For most purposes, it is
simpler to use a keyboard macro counter.

==============================================================================
File: emacs.info,  Node: |Keyboard_Macro_Query|,  Next: |Save_Keyboard_Macro|,  Prev: |Keyboard_Macro_Counter|,  Up: |Keyboard_Macros|
==============================================================================

                                                          *Keyboard_Macro_Query*

17.4 Executing Macros with Variations
-------------------------------------

In a keyboard macro, you can create an effect similar to that of
'query-replace', in that the macro asks you each time around whether to
make a change.

'C-x q'
     When this point is reached during macro execution, ask for
     confirmation ('kbd-macro-query').

   While defining the macro, type 'C-x q' at the point where you want
the query to occur.  During macro definition, the 'C-x q' does nothing,
but when you run the macro later, 'C-x q' asks you interactively whether
to continue.

   The valid responses when 'C-x q' asks are:

<SPC> (or 'y')
     Continue executing the keyboard macro.

<DEL> (or 'n')
     Skip the remainder of this repetition of the macro, and start right
     away with the next repetition.

<RET> (or 'q')
     Skip the remainder of this repetition and cancel further
     repetitions.

'C-r'
     Enter a recursive editing level, in which you can perform editing
     which is not part of the macro.  When you exit the recursive edit
     using 'C-M-c', you are asked again how to continue with the
     keyboard macro.  If you type a <SPC> at this time, the rest of the
     macro definition is executed.  It is up to you to leave point and
     the text in a state such that the rest of the macro will do what
     you want.

   'C-u C-x q', which is 'C-x q' with a prefix argument, performs a
completely different function.  It enters a recursive edit reading input
from the keyboard, both when you type it during the definition of the
macro, and when it is executed from the macro.  During definition, the
editing you do inside the recursive edit does not become part of the
macro.  During macro execution, the recursive edit gives you a chance to
do some particularized editing on each repetition.  *Note Recursive
Edit::.

==============================================================================
File: emacs.info,  Node: |Save_Keyboard_Macro|,  Next: |Edit_Keyboard_Macro|,  Prev: |Keyboard_Macro_Query|,  Up: |Keyboard_Macros|
==============================================================================

                                                           *Save_Keyboard_Macro*

17.5 Naming and Saving Keyboard Macros
--------------------------------------

'C-x C-k n'
     Give a command name (for the duration of the Emacs session) to the
     most recently defined keyboard macro ('kmacro-name-last-macro').
'C-x C-k b'
     Bind the most recently defined keyboard macro to a key sequence
     (for the duration of the session) ('kmacro-bind-to-key').
'M-x insert-kbd-macro'
     Insert in the buffer a keyboard macro's definition, as Lisp code.

   If you wish to save a keyboard macro for later use, you can give it a
name using 'C-x C-k n' ('kmacro-name-last-macro').  This reads a name as
an argument using the minibuffer and defines that name to execute the
last keyboard macro, in its current form.  (If you later add to the
definition of this macro, that does not alter the name's definition as a
macro.)  The macro name is a Lisp symbol, and defining it in this way
makes it a valid command name for calling with 'M-x' or for binding a
key to with 'global-set-key' (*note Keymaps::).  If you specify a name
that has a prior definition other than a keyboard macro, an error
message is shown and nothing is changed.

   You can also bind the last keyboard macro (in its current form) to a
key, using 'C-x C-k b' ('kmacro-bind-to-key') followed by the key
sequence you want to bind.  You can bind to any key sequence in the
global keymap, but since most key sequences already have other bindings,
you should select the key sequence carefully.  If you try to bind to a
key sequence with an existing binding (in any keymap), this command asks
you for confirmation before replacing the existing binding.

   To avoid problems caused by overriding existing bindings, the key
sequences 'C-x C-k 0' through 'C-x C-k 9' and 'C-x C-k A' through 'C-x
C-k Z' are reserved for your own keyboard macro bindings.  In fact, to
bind to one of these key sequences, you only need to type the digit or
letter rather than the whole key sequences.  For example,

     C-x C-k b 4

will bind the last keyboard macro to the key sequence 'C-x C-k 4'.

   Once a macro has a command name, you can save its definition in a
file.  Then it can be used in another editing session.  First, visit the
file you want to save the definition in.  Then use this command:

     M-x insert-kbd-macro <RET> MACRONAME <RET>

This inserts some Lisp code that, when executed later, will define the
same macro with the same definition it has now.  (You don't need to
understand Lisp code to do this, because 'insert-kbd-macro' writes the
Lisp code for you.)  Then save the file.  You can load the file later
with 'load-file' (*note Lisp Libraries::).  If the file you save in is
your init file '~/.emacs' (*note Init File::) then the macro will be
defined each time you run Emacs.

   If you give 'insert-kbd-macro' a prefix argument, it makes additional
Lisp code to record the keys (if any) that you have bound to MACRONAME,
so that the macro will be reassigned the same keys when you load the
file.

==============================================================================
File: emacs.info,  Node: |Edit_Keyboard_Macro|,  Next: |Keyboard_Macro_Step_Edit|,  Prev: |Save_Keyboard_Macro|,  Up: |Keyboard_Macros|
==============================================================================

                                                           *Edit_Keyboard_Macro*

17.6 Editing a Keyboard Macro
-----------------------------

'C-x C-k C-e'
     Edit the last defined keyboard macro ('kmacro-edit-macro').
'C-x C-k e NAME <RET>'
     Edit a previously defined keyboard macro NAME ('edit-kbd-macro').
'C-x C-k l'
     Edit the last 300 keystrokes as a keyboard macro
     ('kmacro-edit-lossage').

   You can edit the last keyboard macro by typing 'C-x C-k C-e' or 'C-x
C-k <RET>' ('kmacro-edit-macro').  This formats the macro definition in
a buffer and enters a specialized major mode for editing it.  Type 'C-h
m' once in that buffer to display details of how to edit the macro.
When you are finished editing, type 'C-c C-c'.

   You can edit a named keyboard macro or a macro bound to a key by
typing 'C-x C-k e' ('edit-kbd-macro').  Follow that with the keyboard
input that you would use to invoke the macro--'C-x e' or 'M-x NAME' or
some other key sequence.

   You can edit the last 300 keystrokes as a macro by typing 'C-x C-k l'
('kmacro-edit-lossage').

==============================================================================
File: emacs.info,  Node: |Keyboard_Macro_Step_Edit|,  Prev: |Edit_Keyboard_Macro|,  Up: |Keyboard_Macros|
==============================================================================

                                                      *Keyboard_Macro_Step_Edit*

17.7 Stepwise Editing a Keyboard Macro
--------------------------------------

You can interactively replay and edit the last keyboard macro, one
command at a time, by typing 'C-x C-k <SPC>' ('kmacro-step-edit-macro').
Unless you quit the macro using 'q' or 'C-g', the edited macro replaces
the last macro on the macro ring.

   This macro editing feature shows the last macro in the minibuffer
together with the first (or next) command to be executed, and prompts
you for an action.  You can enter '?' to get a summary of your options.
These actions are available:

   * <SPC> and 'y' execute the current command, and advance to the next
     command in the keyboard macro.
   * 'n', 'd', and <DEL> skip and delete the current command.
   * 'f' skips the current command in this execution of the keyboard
     macro, but doesn't delete it from the macro.
   * <TAB> executes the current command, as well as all similar commands
     immediately following the current command; for example, <TAB> may
     be used to insert a sequence of characters (corresponding to a
     sequence of 'self-insert-command' commands).
   * 'c' continues execution (without further editing) until the end of
     the keyboard macro.  If execution terminates normally, the edited
     macro replaces the original keyboard macro.
   * 'C-k' skips and deletes the rest of the keyboard macro, terminates
     step-editing, and replaces the original keyboard macro with the
     edited macro.
   * 'q' and 'C-g' cancels the step-editing of the keyboard macro;
     discarding any changes made to the keyboard macro.
   * 'i KEY... C-j' reads and executes a series of key sequences (not
     including the final 'C-j'), and inserts them before the current
     command in the keyboard macro, without advancing over the current
     command.
   * 'I KEY...' reads one key sequence, executes it, and inserts it
     before the current command in the keyboard macro, without advancing
     over the current command.
   * 'r KEY... C-j' reads and executes a series of key sequences (not
     including the final 'C-j'), and replaces the current command in the
     keyboard macro with them, advancing over the inserted key
     sequences.
   * 'R KEY...' reads one key sequence, executes it, and replaces the
     current command in the keyboard macro with that key sequence,
     advancing over the inserted key sequence.
   * 'a KEY... C-j' executes the current command, then reads and
     executes a series of key sequences (not including the final 'C-j'),
     and inserts them after the current command in the keyboard macro;
     it then advances over the current command and the inserted key
     sequences.
   * 'A KEY... C-j' executes the rest of the commands in the keyboard
     macro, then reads and executes a series of key sequences (not
     including the final 'C-j'), and appends them at the end of the
     keyboard macro; it then terminates the step-editing and replaces
     the original keyboard macro with the edited macro.

==============================================================================
File: emacs.info,  Node: |Files|,  Next: |Buffers|,  Prev: |Keyboard_Macros|,  Up: |Top|
==============================================================================

                                                                         *Files*

18 File Handling
================

The operating system stores data permanently in named "files", so most
of the text you edit with Emacs comes from a file and is ultimately
stored in a file.

   To edit a file, you must tell Emacs to read the file and prepare a
buffer containing a copy of the file's text.  This is called "visiting"
the file.  Editing commands apply directly to text in the buffer; that
is, to the copy inside Emacs.  Your changes appear in the file itself
only when you "save" the buffer back into the file.

   In addition to visiting and saving files, Emacs can delete, copy,
rename, and append to files, keep multiple versions of them, and operate
on file directories.

MENU

* |File_Names|::          How to type and edit file-name arguments.
* |Visiting|::            Visiting a file prepares Emacs to edit the file.
* |Saving|::              Saving makes your changes permanent.
* |Reverting|::           Reverting cancels all the changes not saved.
* |Auto_Revert|::         Keeping buffers automatically up-to-date.
* |Auto_Save|::           Auto Save periodically protects against loss of data.
* |File_Aliases|::        Handling multiple names for one file.
* |Directories|::         Creating, deleting, and listing file directories.
* |Comparing_Files|::     Finding where two files differ.
* |Diff_Mode|::           Mode for editing file differences.
* |Copying_and_Naming|::  Copying, naming and renaming files.
* |Misc_File_Ops|::       Other things you can do on files.
* |Compressed_Files|::    Accessing compressed files.
* |File_Archives|::       Operating on tar, zip, jar etc. archive files.
* |Remote_Files|::        Accessing files on other machines.
* |Quoted_File_Names|::   Quoting special characters in file names.
* |File_Name_Cache|::     Completion against a list of files you often use.
* |File_Conveniences|::   Convenience features for finding files.
* |Image_Mode|::          Viewing image files.
* |Filesets|::            Handling sets of files.

==============================================================================
File: emacs.info,  Node: |File_Names|,  Next: |Visiting|,  Up: |Files|
==============================================================================

                                                                    *File_Names*

18.1 File Names
---------------

Many Emacs commands that operate on a file require you to specify the
file name, using the minibuffer (*note Minibuffer File::).

   While in the minibuffer, you can use the usual completion and history
commands (*note Minibuffer::).  Note that file name completion ignores
file names whose extensions appear in the variable
'completion-ignored-extensions' (*note Completion Options::).  Note also
that most commands use permissive completion with confirmation for
reading file names: you are allowed to submit a nonexistent file name,
but if you type <RET> immediately after completing up to a nonexistent
file name, Emacs prints '[Confirm]' and you must type a second <RET> to
confirm.  *Note Completion Exit::, for details.

   Minibuffer history commands offer some special features for reading
file names, see *note Minibuffer History::.

   Each buffer has a "default directory", stored in the buffer-local
variable 'default-directory'.  Whenever Emacs reads a file name using
the minibuffer, it usually inserts the default directory into the
minibuffer as the initial contents.  You can inhibit this insertion by
changing the variable 'insert-default-directory' to 'nil' (*note
Minibuffer File::).  Regardless, Emacs always assumes that any relative
file name is relative to the default directory, e.g., entering a file
name without a directory specifies a file in the default directory.

   When you visit a file, Emacs sets 'default-directory' in the visiting
buffer to the directory of its file.  When you create a new buffer that
is not visiting a file, via a command like 'C-x b', its default
directory is usually copied from the buffer that was current at the time
(*note Select Buffer::).  You can use the command 'M-x pwd' to see the
value of 'default-directory' in the current buffer.  The command 'M-x
cd' prompts for a directory's name, and sets the buffer's
'default-directory' to that directory (doing this does not change the
buffer's file name, if any).

   As an example, when you visit the file '/u/rms/gnu/gnu.tasks', the
default directory is set to '/u/rms/gnu/'.  If you invoke a command that
reads a file name, entering just 'foo' in the minibuffer, with a
directory omitted, specifies the file '/u/rms/gnu/foo'; entering
'../.login' specifies '/u/rms/.login'; and entering 'new/foo' specifies
'/u/rms/gnu/new/foo'.

   When typing a file name into the minibuffer, you can make use of a
couple of shortcuts: a double slash ignores everything before the second
slash in the pair, and '~/' is your home directory.  *Note Minibuffer
File::.

   The character '$' is used to substitute an environment variable into
a file name.  The name of the environment variable consists of all the
alphanumeric characters after the '$'; alternatively, it can be enclosed
in braces after the '$'.  For example, if you have used the shell
command 'export FOO=rms/hacks' to set up an environment variable named
'FOO', then both '/u/$FOO/test.c' and '/u/${FOO}/test.c' are
abbreviations for '/u/rms/hacks/test.c'.  If the environment variable is
not defined, no substitution occurs, so that the character '$' stands
for itself.  Note that environment variables set outside Emacs affect
Emacs only if they are applied before Emacs is started.

   To access a file with '$' in its name, if the '$' causes expansion,
type '$$'.  This pair is converted to a single '$' at the same time that
variable substitution is performed for a single '$'.  Alternatively,
quote the whole file name with '/:' (*note Quoted File Names::).  File
names which begin with a literal '~' should also be quoted with '/:'.

   You can include non-ASCII characters in file names.  *Note File Name
Coding::.

==============================================================================
File: emacs.info,  Node: |Visiting|,  Next: |Saving|,  Prev: |File_Names|,  Up: |Files|
==============================================================================

                                                                      *Visiting*

18.2 Visiting Files
-------------------

'C-x C-f'
     Visit a file ('find-file').
'C-x C-r'
     Visit a file for viewing, without allowing changes to it
     ('find-file-read-only').
'C-x C-v'
     Visit a different file instead of the one visited last
     ('find-alternate-file').
'C-x 4 f'
     Visit a file, in another window ('find-file-other-window').  Don't
     alter what is displayed in the selected window.
'C-x 5 f'
     Visit a file, in a new frame ('find-file-other-frame').  Don't
     alter what is displayed in the selected frame.
'M-x find-file-literally'
     Visit a file with no conversion of the contents.

   "Visiting" a file means reading its contents into an Emacs buffer so
you can edit them.  Emacs makes a new buffer for each file that you
visit.

   To visit a file, type 'C-x C-f' ('find-file') and use the minibuffer
to enter the name of the desired file.  While in the minibuffer, you can
abort the command by typing 'C-g'.  *Note File Names::, for details
about entering file names into minibuffers.

   If the specified file exists but the system does not allow you to
read it, an error message is displayed in the echo area (on GNU and Unix
systems you might be able to visit such a file using the 'su' or 'sudo'
methods; *note Remote Files::).  Otherwise, you can tell that 'C-x C-f'
has completed successfully by the appearance of new text on the screen,
and by the buffer name shown in the mode line (*note Mode Line::).
Emacs normally constructs the buffer name from the file name, omitting
the directory name.  For example, a file named '/usr/rms/emacs.tex' is
visited in a buffer named 'emacs.tex'.  If there is already a buffer
with that name, Emacs constructs a unique name; the normal method is to
add a suffix based on the directory name (e.g., '<rms>', '<tmp>', and so
on), but you can select other methods.  *Note Uniquify::.

   To create a new file, just visit it using the same command, 'C-x
C-f'.  Emacs displays '(New file)' in the echo area, but in other
respects behaves as if you had visited an existing empty file.

   After visiting a file, the changes you make with editing commands are
made in the Emacs buffer.  They do not take effect in the visited file,
until you "save" the buffer (*note Saving::).  If a buffer contains
changes that have not been saved, we say the buffer is "modified".  This
implies that some changes will be lost if the buffer is not saved.  The
mode line displays two stars near the left margin to indicate that the
buffer is modified.

   If you visit a file that is already in Emacs, 'C-x C-f' switches to
the existing buffer instead of making another copy.  Before doing so, it
checks whether the file has changed since you last visited or saved it.
If the file has changed, Emacs offers to reread it.

   If you try to visit a file larger than 'large-file-warning-threshold'
(the default is 10000000, which is about 10 megabytes), Emacs asks you
for confirmation first.  You can answer 'y' to proceed with visiting the
file or 'l' to visit the file literally (see below).  Visiting large
files literally speeds up navigation and editing of such files, because
various potentially-expensive features are turned off.  Note, however,
that Emacs cannot visit files that are larger than the maximum Emacs
buffer size, which is limited by the amount of memory Emacs can allocate
and by the integers that Emacs can represent (*note Buffers::).  If you
try, Emacs displays an error message saying that the maximum buffer size
has been exceeded.

   If the file name you specify contains shell-style wildcard
characters, Emacs visits all the files that match it.  (On
case-insensitive filesystems, Emacs matches the wildcards disregarding
the letter case.)  Wildcards include '?', '*', and '[...]' sequences.
To enter the wild card '?' in a file name in the minibuffer, you need to
type 'C-q ?'.  *Note Quoted File Names::, for information on how to
visit a file whose name actually contains wildcard characters.  You can
disable the wildcard feature by customizing 'find-file-wildcards'.

   If you visit the wrong file unintentionally by typing its name
incorrectly, type 'C-x C-v' ('find-alternate-file') to visit the file
you really wanted.  'C-x C-v' is similar to 'C-x C-f', but it kills the
current buffer (after first offering to save it if it is modified).
When 'C-x C-v' reads the file name to visit, it inserts the entire
default file name in the buffer, with point just after the directory
part; this is convenient if you made a slight error in typing the name.

   If you visit a file that is actually a directory, Emacs invokes
Dired, the Emacs directory browser.  *Note Dired::.  You can disable
this behavior by setting the variable 'find-file-run-dired' to 'nil'; in
that case, it is an error to try to visit a directory.

   Files which are actually collections of other files, or "file
archives", are visited in special modes which invoke a Dired-like
environment to allow operations on archive members.  *Note File
Archives::, for more about these features.

   If you visit a file that the operating system won't let you modify,
or that is marked read-only, Emacs makes the buffer read-only too, so
that you won't go ahead and make changes that you'll have trouble saving
afterward.  You can make the buffer writable with 'C-x C-q'
('read-only-mode').  *Note Misc Buffer::.

   If you want to visit a file as read-only in order to protect yourself
from entering changes accidentally, visit it with the command 'C-x C-r'
('find-file-read-only') instead of 'C-x C-f'.

   'C-x 4 f' ('find-file-other-window') is like 'C-x C-f' except that
the buffer containing the specified file is selected in another window.
The window that was selected before 'C-x 4 f' continues to show the same
buffer it was already showing.  If this command is used when only one
window is being displayed, that window is split in two, with one window
showing the same buffer as before, and the other one showing the newly
requested file.  *Note Windows::.

   'C-x 5 f' ('find-file-other-frame') is similar, but opens a new
frame, or selects any existing frame showing the specified file.  *Note
Frames::.

   On graphical displays, there are two additional methods for visiting
files.  Firstly, when Emacs is built with a suitable GUI toolkit,
commands invoked with the mouse (by clicking on the menu bar or tool
bar) use the toolkit's standard file selection dialog instead of
prompting for the file name in the minibuffer.  On GNU/Linux and Unix
platforms, Emacs does this when built with GTK+, LessTif, and Motif
toolkits; on MS-Windows and Mac, the GUI version does that by default.
For information on how to customize this, see *note Dialog Boxes::.

   Secondly, Emacs supports drag and drop: dropping a file into an
ordinary Emacs window visits the file using that window.  As an
exception, dropping a file into a window displaying a Dired buffer moves
or copies the file into the displayed directory.  For details, see *note
Drag and Drop::, and *note Misc Dired Features::.

   On text-mode terminals and on graphical displays when Emacs was built
without a GUI toolkit, you can visit files via the menu-bar 'File' menu,
which has the 'Visit New File' and the 'Open File' items.

   Each time you visit a file, Emacs automatically scans its contents to
detect what character encoding and end-of-line convention it uses, and
converts these to Emacs's internal encoding and end-of-line convention
within the buffer.  When you save the buffer, Emacs performs the inverse
conversion, writing the file to disk with its original encoding and
end-of-line convention.  *Note Coding Systems::.

   If you wish to edit a file as a sequence of ASCII characters with no
special encoding or conversion, use the 'M-x find-file-literally'
command.  This visits a file, like 'C-x C-f', but does not do format
conversion (*note Format Conversion: (elisp)Format Conversion.),
character code conversion (*note Coding Systems::), or automatic
uncompression (*note Compressed Files::), and does not add a final
newline because of 'require-final-newline' (*note Customize Save::).  If
you have already visited the same file in the usual (non-literal)
manner, this command asks you whether to visit it literally instead.

   Two special hook variables allow extensions to modify the operation
of visiting files.  Visiting a file that does not exist runs the
functions in 'find-file-not-found-functions'; this variable holds a list
of functions, which are called one by one (with no arguments) until one
of them returns non-'nil'.  This is not a normal hook, and the name ends
in '-functions' rather than '-hook' to indicate that fact.

   Successful visiting of any file, whether existing or not, calls the
functions in 'find-file-hook', with no arguments.  This variable is a
normal hook.  In the case of a nonexistent file, the
'find-file-not-found-functions' are run first.  *Note Hooks::.

   There are several ways to specify automatically the major mode for
editing the file (*note Choosing Modes::), and to specify local
variables defined for that file (*note File Variables::).

==============================================================================
File: emacs.info,  Node: |Saving|,  Next: |Reverting|,  Prev: |Visiting|,  Up: |Files|
==============================================================================

                                                                        *Saving*

18.3 Saving Files
-----------------

"Saving" a buffer in Emacs means writing its contents back into the file
that was visited in the buffer.

MENU

* |Save_Commands|::       Commands for saving files.
* |Backup|::              How Emacs saves the old version of your file.
* |Customize_Save|::      Customizing the saving of files.
* |Interlocking|::        How Emacs protects against simultaneous editing
                          of one file by two users.
* Shadowing: File Shadowing.  Copying files to "shadows" automatically.
* |Time_Stamps|::         Emacs can update time stamps on saved files.

==============================================================================
File: emacs.info,  Node: |Save_Commands|,  Next: |Backup|,  Up: Saving
==============================================================================

                                                                 *Save_Commands*

18.3.1 Commands for Saving Files
--------------------------------

These are the commands that relate to saving and writing files.

'C-x C-s'
     Save the current buffer to its file ('save-buffer').
'C-x s'
     Save any or all buffers to their files ('save-some-buffers').
'M-~'
     Forget that the current buffer has been changed ('not-modified').
     With prefix argument ('C-u'), mark the current buffer as changed.
'C-x C-w'
     Save the current buffer with a specified file name ('write-file').
'M-x set-visited-file-name'
     Change the file name under which the current buffer will be saved.

   When you wish to save the file and make your changes permanent, type
'C-x C-s' ('save-buffer').  After saving is finished, 'C-x C-s' displays
a message like this:

     Wrote /u/rms/gnu/gnu.tasks

If the current buffer is not modified (no changes have been made in it
since the buffer was created or last saved), saving is not really done,
because it would have no effect.  Instead, 'C-x C-s' displays a message
like this in the echo area:

     (No changes need to be saved)

   With a prefix argument, 'C-u C-x C-s', Emacs also marks the buffer to
be backed up when the next save is done.  *Note Backup::.

   The command 'C-x s' ('save-some-buffers') offers to save any or all
modified buffers.  It asks you what to do with each buffer.  The
possible responses are analogous to those of 'query-replace':

'y'
'<SPC>'
     Save this buffer and ask about the rest of the buffers.
'n'
'<DEL>'
     Don't save this buffer, but ask about the rest of the buffers.
'!'
     Save this buffer and all the rest with no more questions.
'q'
'<RET>'
vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
