     this macro with the value zero.  You can override the default
     splitting-length by defining this macro as an expression for the
     length you desire.

 -- Macro: DBX_CONTIN_CHAR
     Normally continuation is indicated by adding a '\' character to the
     end of a '.stabs' string when a continuation follows.  To use a
     different character instead, define this macro as a character
     constant for the character you want to use.  Do not define this
     macro if backslash is correct for your system.

 -- Macro: DBX_STATIC_STAB_DATA_SECTION
     Define this macro if it is necessary to go to the data section
     before outputting the '.stabs' pseudo-op for a non-global static
     variable.

 -- Macro: DBX_TYPE_DECL_STABS_CODE
     The value to use in the "code" field of the '.stabs' directive for
     a typedef.  The default is 'N_LSYM'.

 -- Macro: DBX_STATIC_CONST_VAR_CODE
     The value to use in the "code" field of the '.stabs' directive for
     a static variable located in the text section.  DBX format does not
     provide any "right" way to do this.  The default is 'N_FUN'.

 -- Macro: DBX_REGPARM_STABS_CODE
     The value to use in the "code" field of the '.stabs' directive for
     a parameter passed in registers.  DBX format does not provide any
     "right" way to do this.  The default is 'N_RSYM'.

 -- Macro: DBX_REGPARM_STABS_LETTER
     The letter to use in DBX symbol data to identify a symbol as a
     parameter passed in registers.  DBX format does not customarily
     provide any way to do this.  The default is ''P''.

 -- Macro: DBX_FUNCTION_FIRST
     Define this macro if the DBX information for a function and its
     arguments should precede the assembler code for the function.
     Normally, in DBX format, the debugging information entirely follows
     the assembler code.

 -- Macro: DBX_BLOCKS_FUNCTION_RELATIVE
     Define this macro, with value 1, if the value of a symbol
     describing the scope of a block ('N_LBRAC' or 'N_RBRAC') should be
     relative to the start of the enclosing function.  Normally, GCC
     uses an absolute address.

 -- Macro: DBX_LINES_FUNCTION_RELATIVE
     Define this macro, with value 1, if the value of a symbol
     indicating the current line number ('N_SLINE') should be relative
     to the start of the enclosing function.  Normally, GCC uses an
     absolute address.

 -- Macro: DBX_USE_BINCL
     Define this macro if GCC should generate 'N_BINCL' and 'N_EINCL'
     stabs for included header files, as on Sun systems.  This macro
     also directs GCC to output a type number as a pair of a file number
     and a type number within the file.  Normally, GCC does not generate
     'N_BINCL' or 'N_EINCL' stabs, and it outputs a single number for a
     type number.

==============================================================================
File: gccint.info,  Node: |DBX_Hooks|,  Next: |File_Names_and_DBX|,  Prev: |DBX_Options|,  Up: |Debugging_Info|
==============================================================================

                                                                     *DBX_Hooks*

18.21.3 Open-Ended Hooks for DBX Format
---------------------------------------

These are hooks for DBX format.

 -- Macro: DBX_OUTPUT_SOURCE_LINE (STREAM, LINE, COUNTER)
     A C statement to output DBX debugging information before code for
     line number LINE of the current source file to the stdio stream
     STREAM.  COUNTER is the number of time the macro was invoked,
     including the current invocation; it is intended to generate unique
     labels in the assembly output.

     This macro should not be defined if the default output is correct,
     or if it can be made correct by defining
     'DBX_LINES_FUNCTION_RELATIVE'.

 -- Macro: NO_DBX_FUNCTION_END
     Some stabs encapsulation formats (in particular ECOFF), cannot
     handle the '.stabs "",N_FUN,,0,0,Lscope-function-1' gdb dbx
     extension construct.  On those machines, define this macro to turn
     this feature off without disturbing the rest of the gdb extensions.

 -- Macro: NO_DBX_BNSYM_ENSYM
     Some assemblers cannot handle the '.stabd BNSYM/ENSYM,0,0' gdb dbx
     extension construct.  On those machines, define this macro to turn
     this feature off without disturbing the rest of the gdb extensions.

==============================================================================
File: gccint.info,  Node: |File_Names_and_DBX|,  Next: |DWARF|,  Prev: |DBX_Hooks|,  Up: |Debugging_Info|
==============================================================================

                                                            *File_Names_and_DBX*

18.21.4 File Names in DBX Format
--------------------------------

This describes file names in DBX format.

 -- Macro: DBX_OUTPUT_MAIN_SOURCE_FILENAME (STREAM, NAME)
     A C statement to output DBX debugging information to the stdio
     stream STREAM, which indicates that file NAME is the main source
     file--the file specified as the input file for compilation.  This
     macro is called only once, at the beginning of compilation.

     This macro need not be defined if the standard form of output for
     DBX debugging information is appropriate.

     It may be necessary to refer to a label equal to the beginning of
     the text section.  You can use 'assemble_name (stream,
     ltext_label_name)' to do so.  If you do this, you must also set the
     variable USED_LTEXT_LABEL_NAME to 'true'.

 -- Macro: NO_DBX_MAIN_SOURCE_DIRECTORY
     Define this macro, with value 1, if GCC should not emit an
     indication of the current directory for compilation and current
     source language at the beginning of the file.

 -- Macro: NO_DBX_GCC_MARKER
     Define this macro, with value 1, if GCC should not emit an
     indication that this object file was compiled by GCC.  The default
     is to emit an 'N_OPT' stab at the beginning of every source file,
     with 'gcc2_compiled.' for the string and value 0.

 -- Macro: DBX_OUTPUT_MAIN_SOURCE_FILE_END (STREAM, NAME)
     A C statement to output DBX debugging information at the end of
     compilation of the main source file NAME.  Output should be written
     to the stdio stream STREAM.

     If you don't define this macro, nothing special is output at the
     end of compilation, which is correct for most machines.

 -- Macro: DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END
     Define this macro _instead of_ defining
     'DBX_OUTPUT_MAIN_SOURCE_FILE_END', if what needs to be output at
     the end of compilation is an 'N_SO' stab with an empty string,
     whose value is the highest absolute text address in the file.

==============================================================================
File: gccint.info,  Node: |DWARF|,  Next: |VMS_Debug|,  Prev: |File_Names_and_DBX|,  Up: |Debugging_Info|
==============================================================================

                                                                         *DWARF*

18.21.5 Macros for DWARF Output
-------------------------------

Here are macros for DWARF output.

 -- Macro: DWARF2_DEBUGGING_INFO
     Define this macro if GCC should produce dwarf version 2 format
     debugging output in response to the '-g' option.

      -- Target Hook: int TARGET_DWARF_CALLING_CONVENTION (const_tree
               FUNCTION)
          Define this to enable the dwarf attribute
          'DW_AT_calling_convention' to be emitted for each function.
          Instead of an integer return the enum value for the 'DW_CC_'
          tag.

     To support optional call frame debugging information, you must also
     define 'INCOMING_RETURN_ADDR_RTX' and either set
     'RTX_FRAME_RELATED_P' on the prologue insns if you use RTL for the
     prologue, or call 'dwarf2out_def_cfa' and 'dwarf2out_reg_save' as
     appropriate from 'TARGET_ASM_FUNCTION_PROLOGUE' if you don't.

 -- Macro: DWARF2_FRAME_INFO
     Define this macro to a nonzero value if GCC should always output
     Dwarf 2 frame information.  If 'TARGET_EXCEPT_UNWIND_INFO' (*note
     Exception Region Output::) returns 'UI_DWARF2', and exceptions are
     enabled, GCC will output this information not matter how you define
     'DWARF2_FRAME_INFO'.

 -- Target Hook: enum unwind_info_type TARGET_DEBUG_UNWIND_INFO (void)
     This hook defines the mechanism that will be used for describing
     frame unwind information to the debugger.  Normally the hook will
     return 'UI_DWARF2' if DWARF 2 debug information is enabled, and
     return 'UI_NONE' otherwise.

     A target may return 'UI_DWARF2' even when DWARF 2 debug information
     is disabled in order to always output DWARF 2 frame information.

     A target may return 'UI_TARGET' if it has ABI specified unwind
     tables.  This will suppress generation of the normal debug frame
     unwind information.

 -- Macro: DWARF2_ASM_LINE_DEBUG_INFO
     Define this macro to be a nonzero value if the assembler can
     generate Dwarf 2 line debug info sections.  This will result in
     much more compact line number tables, and hence is desirable if it
     works.

 -- Macro: DWARF2_ASM_VIEW_DEBUG_INFO
     Define this macro to be a nonzero value if the assembler supports
     view assignment and verification in '.loc'.  If it does not, but
     the user enables location views, the compiler may have to fallback
     to internal line number tables.

 -- Target Hook: int TARGET_RESET_LOCATION_VIEW (rtx_insn *)
     This hook, if defined, enables -ginternal-reset-location-views, and
     uses its result to override cases in which the estimated min insn
     length might be nonzero even when a PC advance (i.e., a view reset)
     cannot be taken for granted.

     If the hook is defined, it must return a positive value to indicate
     the insn definitely advances the PC, and so the view number can be
     safely assumed to be reset; a negative value to mean the insn
     definitely does not advance the PC, and os the view number must not
     be reset; or zero to decide based on the estimated insn length.

     If insn length is to be regarded as reliable, set the hook to
     'hook_int_rtx_insn_0'.

 -- Target Hook: bool TARGET_WANT_DEBUG_PUB_SECTIONS
     True if the '.debug_pubtypes' and '.debug_pubnames' sections should
     be emitted.  These sections are not used on most platforms, and in
     particular GDB does not use them.

 -- Target Hook: bool TARGET_DELAY_SCHED2
     True if sched2 is not to be run at its normal place.  This usually
     means it will be run as part of machine-specific reorg.

 -- Target Hook: bool TARGET_DELAY_VARTRACK
     True if vartrack is not to be run at its normal place.  This
     usually means it will be run as part of machine-specific reorg.

 -- Target Hook: bool TARGET_NO_REGISTER_ALLOCATION
     True if register allocation and the passes following it should not
     be run.  Usually true only for virtual assembler targets.

 -- Macro: ASM_OUTPUT_DWARF_DELTA (STREAM, SIZE, LABEL1, LABEL2)
     A C statement to issue assembly directives that create a difference
     LAB1 minus LAB2, using an integer of the given SIZE.

 -- Macro: ASM_OUTPUT_DWARF_VMS_DELTA (STREAM, SIZE, LABEL1, LABEL2)
     A C statement to issue assembly directives that create a difference
     between the two given labels in system defined units, e.g.
     instruction slots on IA64 VMS, using an integer of the given size.

 -- Macro: ASM_OUTPUT_DWARF_OFFSET (STREAM, SIZE, LABEL, OFFSET,
          SECTION)
     A C statement to issue assembly directives that create a
     section-relative reference to the given LABEL plus OFFSET, using an
     integer of the given SIZE.  The label is known to be defined in the
     given SECTION.

 -- Macro: ASM_OUTPUT_DWARF_PCREL (STREAM, SIZE, LABEL)
     A C statement to issue assembly directives that create a
     self-relative reference to the given LABEL, using an integer of the
     given SIZE.

 -- Macro: ASM_OUTPUT_DWARF_DATAREL (STREAM, SIZE, LABEL)
     A C statement to issue assembly directives that create a reference
     to the given LABEL relative to the dbase, using an integer of the
     given SIZE.

 -- Macro: ASM_OUTPUT_DWARF_TABLE_REF (LABEL)
     A C statement to issue assembly directives that create a reference
     to the DWARF table identifier LABEL from the current section.  This
     is used on some systems to avoid garbage collecting a DWARF table
     which is referenced by a function.

 -- Target Hook: void TARGET_ASM_OUTPUT_DWARF_DTPREL (FILE *FILE, int
          SIZE, rtx X)
     If defined, this target hook is a function which outputs a
     DTP-relative reference to the given TLS symbol of the specified
     size.

==============================================================================
File: gccint.info,  Node: |VMS_Debug|,  Prev: |DWARF|,  Up: |Debugging_Info|
==============================================================================

                                                                     *VMS_Debug*

18.21.6 Macros for VMS Debug Format
-----------------------------------

Here are macros for VMS debug format.

 -- Macro: VMS_DEBUGGING_INFO
     Define this macro if GCC should produce debugging output for VMS in
     response to the '-g' option.  The default behavior for VMS is to
     generate minimal debug info for a traceback in the absence of '-g'
     unless explicitly overridden with '-g0'.  This behavior is
     controlled by 'TARGET_OPTION_OPTIMIZATION' and
     'TARGET_OPTION_OVERRIDE'.

==============================================================================
File: gccint.info,  Node: |Floating_Point|,  Next: |Mode_Switching|,  Prev: |Debugging_Info|,  Up: |Target_Macros|
==============================================================================

                                                                *Floating_Point*

18.22 Cross Compilation and Floating Point
=====-------------------------------------

While all modern machines use twos-complement representation for
integers, there are a variety of representations for floating point
numbers.  This means that in a cross-compiler the representation of
floating point numbers in the compiled program may be different from
that used in the machine doing the compilation.

 Because different representation systems may offer different amounts of
range and precision, all floating point constants must be represented in
the target machine's format.  Therefore, the cross compiler cannot
safely use the host machine's floating point arithmetic; it must emulate
the target's arithmetic.  To ensure consistency, GCC always uses
emulation to work with floating point values, even when the host and
target floating point formats are identical.

 The following macros are provided by 'real.h' for the compiler to use.
All parts of the compiler which generate or optimize floating-point
calculations must use these macros.  They may evaluate their operands
more than once, so operands must not have side effects.

 -- Macro: REAL_VALUE_TYPE
     The C data type to be used to hold a floating point value in the
     target machine's format.  Typically this is a 'struct' containing
     an array of 'HOST_WIDE_INT', but all code should treat it as an
     opaque quantity.

 -- Macro: HOST_WIDE_INT REAL_VALUE_FIX (REAL_VALUE_TYPE X)
     Truncates X to a signed integer, rounding toward zero.

 -- Macro: unsigned HOST_WIDE_INT REAL_VALUE_UNSIGNED_FIX
          (REAL_VALUE_TYPE X)
     Truncates X to an unsigned integer, rounding toward zero.  If X is
     negative, returns zero.

 -- Macro: REAL_VALUE_TYPE REAL_VALUE_ATOF (const char *STRING,
          machine_mode MODE)
     Converts STRING into a floating point number in the target
     machine's representation for mode MODE.  This routine can handle
     both decimal and hexadecimal floating point constants, using the
     syntax defined by the C language for both.

 -- Macro: int REAL_VALUE_NEGATIVE (REAL_VALUE_TYPE X)
     Returns 1 if X is negative (including negative zero), 0 otherwise.

 -- Macro: int REAL_VALUE_ISINF (REAL_VALUE_TYPE X)
     Determines whether X represents infinity (positive or negative).

 -- Macro: int REAL_VALUE_ISNAN (REAL_VALUE_TYPE X)
     Determines whether X represents a "NaN" (not-a-number).

 -- Macro: REAL_VALUE_TYPE REAL_VALUE_NEGATE (REAL_VALUE_TYPE X)
     Returns the negative of the floating point value X.

 -- Macro: REAL_VALUE_TYPE REAL_VALUE_ABS (REAL_VALUE_TYPE X)
     Returns the absolute value of X.

==============================================================================
File: gccint.info,  Node: |Mode_Switching|,  Next: |Target_Attributes|,  Prev: |Floating_Point|,  Up: |Target_Macros|
==============================================================================

                                                                *Mode_Switching*

18.23 Mode Switching Instructions
=====----------------------------

The following macros control mode switching optimizations:

 -- Macro: OPTIMIZE_MODE_SWITCHING (ENTITY)
     Define this macro if the port needs extra instructions inserted for
     mode switching in an optimizing compilation.

     For an example, the SH4 can perform both single and double
     precision floating point operations, but to perform a single
     precision operation, the FPSCR PR bit has to be cleared, while for
     a double precision operation, this bit has to be set.  Changing the
     PR bit requires a general purpose register as a scratch register,
     hence these FPSCR sets have to be inserted before reload, i.e. you
     cannot put this into instruction emitting or
     'TARGET_MACHINE_DEPENDENT_REORG'.

     You can have multiple entities that are mode-switched, and select
     at run time which entities actually need it.
     'OPTIMIZE_MODE_SWITCHING' should return nonzero for any ENTITY that
     needs mode-switching.  If you define this macro, you also have to
     define 'NUM_MODES_FOR_MODE_SWITCHING', 'TARGET_MODE_NEEDED',
     'TARGET_MODE_PRIORITY' and 'TARGET_MODE_EMIT'.
     'TARGET_MODE_AFTER', 'TARGET_MODE_ENTRY', and 'TARGET_MODE_EXIT'
     are optional.

 -- Macro: NUM_MODES_FOR_MODE_SWITCHING
     If you define 'OPTIMIZE_MODE_SWITCHING', you have to define this as
     initializer for an array of integers.  Each initializer element N
     refers to an entity that needs mode switching, and specifies the
     number of different modes that might need to be set for this
     entity.  The position of the initializer in the
     initializer--starting counting at zero--determines the integer that
     is used to refer to the mode-switched entity in question.  In
     macros that take mode arguments / yield a mode result, modes are
     represented as numbers 0 ... N - 1.  N is used to specify that no
     mode switch is needed / supplied.

 -- Target Hook: void TARGET_MODE_EMIT (int ENTITY, int MODE, int
          PREV_MODE, HARD_REG_SET REGS_LIVE)
     Generate one or more insns to set ENTITY to MODE.  HARD_REG_LIVE is
     the set of hard registers live at the point where the insn(s) are
     to be inserted.  PREV_MOXDE indicates the mode to switch from.
     Sets of a lower numbered entity will be emitted before sets of a
     higher numbered entity to a mode of the same or lower priority.

 -- Target Hook: int TARGET_MODE_NEEDED (int ENTITY, rtx_insn *INSN)
     ENTITY is an integer specifying a mode-switched entity.  If
     'OPTIMIZE_MODE_SWITCHING' is defined, you must define this macro to
     return an integer value not larger than the corresponding element
     in 'NUM_MODES_FOR_MODE_SWITCHING', to denote the mode that ENTITY
     must be switched into prior to the execution of INSN.

 -- Target Hook: int TARGET_MODE_AFTER (int ENTITY, int MODE, rtx_insn
          *INSN)
     ENTITY is an integer specifying a mode-switched entity.  If this
     macro is defined, it is evaluated for every INSN during mode
     switching.  It determines the mode that an insn results in (if
     different from the incoming mode).

 -- Target Hook: int TARGET_MODE_ENTRY (int ENTITY)
     If this macro is defined, it is evaluated for every ENTITY that
     needs mode switching.  It should evaluate to an integer, which is a
     mode that ENTITY is assumed to be switched to at function entry.
     If 'TARGET_MODE_ENTRY' is defined then 'TARGET_MODE_EXIT' must be
     defined.

 -- Target Hook: int TARGET_MODE_EXIT (int ENTITY)
     If this macro is defined, it is evaluated for every ENTITY that
     needs mode switching.  It should evaluate to an integer, which is a
     mode that ENTITY is assumed to be switched to at function exit.  If
     'TARGET_MODE_EXIT' is defined then 'TARGET_MODE_ENTRY' must be
     defined.

 -- Target Hook: int TARGET_MODE_PRIORITY (int ENTITY, int N)
     This macro specifies the order in which modes for ENTITY are
     processed.  0 is the highest priority,
     'NUM_MODES_FOR_MODE_SWITCHING[ENTITY] - 1' the lowest.  The value
     of the macro should be an integer designating a mode for ENTITY.
     For any fixed ENTITY, 'mode_priority' (ENTITY, N) shall be a
     bijection in 0 ... 'num_modes_for_mode_switching[ENTITY] - 1'.

==============================================================================
File: gccint.info,  Node: |Target_Attributes|,  Next: |Emulated_TLS|,  Prev: |Mode_Switching|,  Up: |Target_Macros|
==============================================================================

                                                             *Target_Attributes*

18.24 Defining target-specific uses of '__attribute__'
=====-------------------------------------------------

Target-specific attributes may be defined for functions, data and types.
These are described using the following target hooks; they also need to
be documented in 'extend.texi'.

 -- Target Hook: const struct attribute_spec * TARGET_ATTRIBUTE_TABLE
     If defined, this target hook points to an array of 'struct
     attribute_spec' (defined in 'tree-core.h') specifying the machine
     specific attributes for this target and some of the restrictions on
     the entities to which these attributes are applied and the
     arguments they take.

 -- Target Hook: bool TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P (const_tree
          NAME)
     If defined, this target hook is a function which returns true if
     the machine-specific attribute named NAME expects an identifier
     given as its first argument to be passed on as a plain identifier,
     not subjected to name lookup.  If this is not defined, the default
     is false for all machine-specific attributes.

 -- Target Hook: int TARGET_COMP_TYPE_ATTRIBUTES (const_tree TYPE1,
          const_tree TYPE2)
     If defined, this target hook is a function which returns zero if
     the attributes on TYPE1 and TYPE2 are incompatible, one if they are
     compatible, and two if they are nearly compatible (which causes a
     warning to be generated).  If this is not defined, machine-specific
     attributes are supposed always to be compatible.

 -- Target Hook: void TARGET_SET_DEFAULT_TYPE_ATTRIBUTES (tree TYPE)
     If defined, this target hook is a function which assigns default
     attributes to the newly defined TYPE.

 -- Target Hook: tree TARGET_MERGE_TYPE_ATTRIBUTES (tree TYPE1, tree
          TYPE2)
     Define this target hook if the merging of type attributes needs
     special handling.  If defined, the result is a list of the combined
     'TYPE_ATTRIBUTES' of TYPE1 and TYPE2.  It is assumed that
     'comptypes' has already been called and returned 1.  This function
     may call 'merge_attributes' to handle machine-independent merging.

 -- Target Hook: tree TARGET_MERGE_DECL_ATTRIBUTES (tree OLDDECL, tree
          NEWDECL)
     Define this target hook if the merging of decl attributes needs
     special handling.  If defined, the result is a list of the combined
     'DECL_ATTRIBUTES' of OLDDECL and NEWDECL.  NEWDECL is a duplicate
     declaration of OLDDECL.  Examples of when this is needed are when
     one attribute overrides another, or when an attribute is nullified
     by a subsequent definition.  This function may call
     'merge_attributes' to handle machine-independent merging.

     If the only target-specific handling you require is 'dllimport' for
     Microsoft Windows targets, you should define the macro
     'TARGET_DLLIMPORT_DECL_ATTRIBUTES' to '1'.  The compiler will then
     define a function called 'merge_dllimport_decl_attributes' which
     can then be defined as the expansion of
     'TARGET_MERGE_DECL_ATTRIBUTES'.  You can also add
     'handle_dll_attribute' in the attribute table for your port to
     perform initial processing of the 'dllimport' and 'dllexport'
     attributes.  This is done in 'i386/cygwin.h' and 'i386/i386.c', for
     example.

 -- Target Hook: bool TARGET_VALID_DLLIMPORT_ATTRIBUTE_P (const_tree
          DECL)
     DECL is a variable or function with '__attribute__((dllimport))'
     specified.  Use this hook if the target needs to add extra
     validation checks to 'handle_dll_attribute'.

 -- Macro: TARGET_DECLSPEC
     Define this macro to a nonzero value if you want to treat
     '__declspec(X)' as equivalent to '__attribute((X))'.  By default,
     this behavior is enabled only for targets that define
     'TARGET_DLLIMPORT_DECL_ATTRIBUTES'.  The current implementation of
     '__declspec' is via a built-in macro, but you should not rely on
     this implementation detail.

 -- Target Hook: void TARGET_INSERT_ATTRIBUTES (tree NODE, tree
          *ATTR_PTR)
     Define this target hook if you want to be able to add attributes to
     a decl when it is being created.  This is normally useful for back
     ends which wish to implement a pragma by using the attributes which
     correspond to the pragma's effect.  The NODE argument is the decl
     which is being created.  The ATTR_PTR argument is a pointer to the
     attribute list for this decl.  The list itself should not be
     modified, since it may be shared with other decls, but attributes
     may be chained on the head of the list and '*ATTR_PTR' modified to
     point to the new attributes, or a copy of the list may be made if
     further changes are needed.

 -- Target Hook: tree TARGET_HANDLE_GENERIC_ATTRIBUTE (tree *NODE, tree
          NAME, tree ARGS, int FLAGS, bool *NO_ADD_ATTRS)
     Define this target hook if you want to be able to perform
     additional target-specific processing of an attribute which is
     handled generically by a front end.  The arguments are the same as
     those which are passed to attribute handlers.  So far this only
     affects the NOINIT and SECTION attribute.

 -- Target Hook: bool TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P (const_tree
          FNDECL)
     This target hook returns 'true' if it is OK to inline FNDECL into
     the current function, despite its having target-specific
     attributes, 'false' otherwise.  By default, if a function has a
     target specific attribute attached to it, it will not be inlined.

 -- Target Hook: bool TARGET_OPTION_VALID_ATTRIBUTE_P (tree FNDECL, tree
          NAME, tree ARGS, int FLAGS)
     This hook is called to parse 'attribute(target("..."))', which
     allows setting target-specific options on individual functions.
     These function-specific options may differ from the options
     specified on the command line.  The hook should return 'true' if
     the options are valid.

     The hook should set the 'DECL_FUNCTION_SPECIFIC_TARGET' field in
     the function declaration to hold a pointer to a target-specific
     'struct cl_target_option' structure.

 -- Target Hook: void TARGET_OPTION_SAVE (struct cl_target_option *PTR,
          struct gcc_options *OPTS)
     This hook is called to save any additional target-specific
     information in the 'struct cl_target_option' structure for
     function-specific options from the 'struct gcc_options' structure.
     *Note Option file format::.

 -- Target Hook: void TARGET_OPTION_RESTORE (struct gcc_options *OPTS,
          struct cl_target_option *PTR)
     This hook is called to restore any additional target-specific
     information in the 'struct cl_target_option' structure for
     function-specific options to the 'struct gcc_options' structure.

 -- Target Hook: void TARGET_OPTION_POST_STREAM_IN (struct
          cl_target_option *PTR)
     This hook is called to update target-specific information in the
     'struct cl_target_option' structure after it is streamed in from
     LTO bytecode.

 -- Target Hook: void TARGET_OPTION_PRINT (FILE *FILE, int INDENT,
          struct cl_target_option *PTR)
     This hook is called to print any additional target-specific
     information in the 'struct cl_target_option' structure for
     function-specific options.

 -- Target Hook: bool TARGET_OPTION_PRAGMA_PARSE (tree ARGS, tree
          POP_TARGET)
     This target hook parses the options for '#pragma GCC target', which
     sets the target-specific options for functions that occur later in
     the input stream.  The options accepted should be the same as those
     handled by the 'TARGET_OPTION_VALID_ATTRIBUTE_P' hook.

 -- Target Hook: void TARGET_OPTION_OVERRIDE (void)
     Sometimes certain combinations of command options do not make sense
     on a particular target machine.  You can override the hook
     'TARGET_OPTION_OVERRIDE' to take account of this.  This hooks is
     called once just after all the command options have been parsed.

     Don't use this hook to turn on various extra optimizations for
     '-O'.  That is what 'TARGET_OPTION_OPTIMIZATION' is for.

     If you need to do something whenever the optimization level is
     changed via the optimize attribute or pragma, see
     'TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE'

 -- Target Hook: bool TARGET_OPTION_FUNCTION_VERSIONS (tree DECL1, tree
          DECL2)
     This target hook returns 'true' if DECL1 and DECL2 are versions of
     the same function.  DECL1 and DECL2 are function versions if and
     only if they have the same function signature and different target
     specific attributes, that is, they are compiled for different
     target machines.

 -- Target Hook: bool TARGET_CAN_INLINE_P (tree CALLER, tree CALLEE)
     This target hook returns 'false' if the CALLER function cannot
     inline CALLEE, based on target specific information.  By default,
     inlining is not allowed if the callee function has function
     specific target options and the caller does not use the same
     options.

 -- Target Hook: void TARGET_RELAYOUT_FUNCTION (tree FNDECL)
     This target hook fixes function FNDECL after attributes are
     processed.  Default does nothing.  On ARM, the default function's
     alignment is updated with the attribute target.

==============================================================================
File: gccint.info,  Node: |Emulated_TLS|,  Next: |MIPS_Coprocessors|,  Prev: |Target_Attributes|,  Up: |Target_Macros|
==============================================================================

                                                                  *Emulated_TLS*

18.25 Emulating TLS
=====--------------

For targets whose psABI does not provide Thread Local Storage via
specific relocations and instruction sequences, an emulation layer is
used.  A set of target hooks allows this emulation layer to be
configured for the requirements of a particular target.  For instance
the psABI may in fact specify TLS support in terms of an emulation
layer.

 The emulation layer works by creating a control object for every TLS
object.  To access the TLS object, a lookup function is provided which,
when given the address of the control object, will return the address of
the current thread's instance of the TLS object.

 -- Target Hook: const char * TARGET_EMUTLS_GET_ADDRESS
     Contains the name of the helper function that uses a TLS control
     object to locate a TLS instance.  The default causes libgcc's
     emulated TLS helper function to be used.

 -- Target Hook: const char * TARGET_EMUTLS_REGISTER_COMMON
     Contains the name of the helper function that should be used at
     program startup to register TLS objects that are implicitly
     initialized to zero.  If this is 'NULL', all TLS objects will have
     explicit initializers.  The default causes libgcc's emulated TLS
     registration function to be used.

 -- Target Hook: const char * TARGET_EMUTLS_VAR_SECTION
     Contains the name of the section in which TLS control variables
     should be placed.  The default of 'NULL' allows these to be placed
     in any section.

 -- Target Hook: const char * TARGET_EMUTLS_TMPL_SECTION
     Contains the name of the section in which TLS initializers should
     be placed.  The default of 'NULL' allows these to be placed in any
     section.

 -- Target Hook: const char * TARGET_EMUTLS_VAR_PREFIX
     Contains the prefix to be prepended to TLS control variable names.
     The default of 'NULL' uses a target-specific prefix.

 -- Target Hook: const char * TARGET_EMUTLS_TMPL_PREFIX
     Contains the prefix to be prepended to TLS initializer objects.
     The default of 'NULL' uses a target-specific prefix.

 -- Target Hook: tree TARGET_EMUTLS_VAR_FIELDS (tree TYPE, tree *NAME)
     Specifies a function that generates the FIELD_DECLs for a TLS
     control object type.  TYPE is the RECORD_TYPE the fields are for
     and NAME should be filled with the structure tag, if the default of
     '__emutls_object' is unsuitable.  The default creates a type
     suitable for libgcc's emulated TLS function.

 -- Target Hook: tree TARGET_EMUTLS_VAR_INIT (tree VAR, tree DECL, tree
          TMPL_ADDR)
     Specifies a function that generates the CONSTRUCTOR to initialize a
     TLS control object.  VAR is the TLS control object, DECL is the TLS
     object and TMPL_ADDR is the address of the initializer.  The
     default initializes libgcc's emulated TLS control object.

 -- Target Hook: bool TARGET_EMUTLS_VAR_ALIGN_FIXED
     Specifies whether the alignment of TLS control variable objects is
     fixed and should not be increased as some backends may do to
     optimize single objects.  The default is false.

 -- Target Hook: bool TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS
     Specifies whether a DWARF 'DW_OP_form_tls_address' location
     descriptor may be used to describe emulated TLS control objects.

==============================================================================
File: gccint.info,  Node: |MIPS_Coprocessors|,  Next: |PCH_Target|,  Prev: |Emulated_TLS|,  Up: |Target_Macros|
==============================================================================

                                                             *MIPS_Coprocessors*

18.26 Defining coprocessor specifics for MIPS targets.
=====-------------------------------------------------

The MIPS specification allows MIPS implementations to have as many as 4
coprocessors, each with as many as 32 private registers.  GCC supports
accessing these registers and transferring values between the registers
and memory using asm-ized variables.  For example:

       register unsigned int cp0count asm ("c0r1");
       unsigned int d;

       d = cp0count + 3;

 ("c0r1" is the default name of register 1 in coprocessor 0; alternate
names may be added as described below, or the default names may be
overridden entirely in 'SUBTARGET_CONDITIONAL_REGISTER_USAGE'.)

 Coprocessor registers are assumed to be epilogue-used; sets to them
will be preserved even if it does not appear that the register is used
again later in the function.

 Another note: according to the MIPS spec, coprocessor 1 (if present) is
the FPU.  One accesses COP1 registers through standard mips
floating-point support; they are not included in this mechanism.

==============================================================================
File: gccint.info,  Node: |PCH_Target|,  Next: |C++_ABI|,  Prev: |MIPS_Coprocessors|,  Up: |Target_Macros|
==============================================================================

                                                                    *PCH_Target*

18.27 Parameters for Precompiled Header Validity Checking
=====----------------------------------------------------

 -- Target Hook: void * TARGET_GET_PCH_VALIDITY (size_t *SZ)
     This hook returns a pointer to the data needed by
     'TARGET_PCH_VALID_P' and sets '*SZ' to the size of the data in
     bytes.

 -- Target Hook: const char * TARGET_PCH_VALID_P (const void *DATA,
          size_t SZ)
     This hook checks whether the options used to create a PCH file are
     compatible with the current settings.  It returns 'NULL' if so and
     a suitable error message if not.  Error messages will be presented
     to the user and must be localized using '_(MSG)'.

     DATA is the data that was returned by 'TARGET_GET_PCH_VALIDITY'
     when the PCH file was created and SZ is the size of that data in
     bytes.  It's safe to assume that the data was created by the same
     version of the compiler, so no format checking is needed.

     The default definition of 'default_pch_valid_p' should be suitable
     for most targets.

 -- Target Hook: const char * TARGET_CHECK_PCH_TARGET_FLAGS (int
          PCH_FLAGS)
     If this hook is nonnull, the default implementation of
     'TARGET_PCH_VALID_P' will use it to check for compatible values of
     'target_flags'.  PCH_FLAGS specifies the value that 'target_flags'
     had when the PCH file was created.  The return value is the same as
     for 'TARGET_PCH_VALID_P'.

 -- Target Hook: void TARGET_PREPARE_PCH_SAVE (void)
     Called before writing out a PCH file.  If the target has some
     garbage-collected data that needs to be in a particular state on
     PCH loads, it can use this hook to enforce that state.  Very few
     targets need to do anything here.

==============================================================================
File: gccint.info,  Node: |C++_ABI|,  Next: |D_Language_and_ABI|,  Prev: |PCH_Target|,  Up: |Target_Macros|
==============================================================================

                                                                       *C++_ABI*

18.28 C++ ABI parameters
=====-------------------

 -- Target Hook: tree TARGET_CXX_GUARD_TYPE (void)
     Define this hook to override the integer type used for guard
     variables.  These are used to implement one-time construction of
     static objects.  The default is long_long_integer_type_node.

 -- Target Hook: bool TARGET_CXX_GUARD_MASK_BIT (void)
     This hook determines how guard variables are used.  It should
     return 'false' (the default) if the first byte should be used.  A
     return value of 'true' indicates that only the least significant
     bit should be used.

 -- Target Hook: tree TARGET_CXX_GET_COOKIE_SIZE (tree TYPE)
     This hook returns the size of the cookie to use when allocating an
     array whose elements have the indicated TYPE.  Assumes that it is
     already known that a cookie is needed.  The default is 'max(sizeof
     (size_t), alignof(type))', as defined in section 2.7 of the
     IA64/Generic C++ ABI.

 -- Target Hook: bool TARGET_CXX_COOKIE_HAS_SIZE (void)
     This hook should return 'true' if the element size should be stored
     in array cookies.  The default is to return 'false'.

 -- Target Hook: int TARGET_CXX_IMPORT_EXPORT_CLASS (tree TYPE, int
          IMPORT_EXPORT)
     If defined by a backend this hook allows the decision made to
     export class TYPE to be overruled.  Upon entry IMPORT_EXPORT will
     contain 1 if the class is going to be exported, -1 if it is going
     to be imported and 0 otherwise.  This function should return the
     modified value and perform any other actions necessary to support
     the backend's targeted operating system.

 -- Target Hook: bool TARGET_CXX_CDTOR_RETURNS_THIS (void)
     This hook should return 'true' if constructors and destructors
     return the address of the object created/destroyed.  The default is
     to return 'false'.

 -- Target Hook: bool TARGET_CXX_KEY_METHOD_MAY_BE_INLINE (void)
     This hook returns true if the key method for a class (i.e., the
     method which, if defined in the current translation unit, causes
     the virtual table to be emitted) may be an inline function.  Under
     the standard Itanium C++ ABI the key method may be an inline
     function so long as the function is not declared inline in the
     class definition.  Under some variants of the ABI, an inline
     function can never be the key method.  The default is to return
     'true'.

 -- Target Hook: void TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY (tree
          DECL)
     DECL is a virtual table, virtual table table, typeinfo object, or
     other similar implicit class data object that will be emitted with
     external linkage in this translation unit.  No ELF visibility has
     been explicitly specified.  If the target needs to specify a
     visibility other than that of the containing class, use this hook
     to set 'DECL_VISIBILITY' and 'DECL_VISIBILITY_SPECIFIED'.

 -- Target Hook: bool TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT (void)
     This hook returns true (the default) if virtual tables and other
     similar implicit class data objects are always COMDAT if they have
     external linkage.  If this hook returns false, then class data for
     classes whose virtual table will be emitted in only one translation
     unit will not be COMDAT.

 -- Target Hook: bool TARGET_CXX_LIBRARY_RTTI_COMDAT (void)
     This hook returns true (the default) if the RTTI information for
     the basic types which is defined in the C++ runtime should always
     be COMDAT, false if it should not be COMDAT.

 -- Target Hook: bool TARGET_CXX_USE_AEABI_ATEXIT (void)
     This hook returns true if '__aeabi_atexit' (as defined by the ARM
     EABI) should be used to register static destructors when
     '-fuse-cxa-atexit' is in effect.  The default is to return false to
     use '__cxa_atexit'.

 -- Target Hook: bool TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT (void)
     This hook returns true if the target 'atexit' function can be used
     in the same manner as '__cxa_atexit' to register C++ static
     destructors.  This requires that 'atexit'-registered functions in
     shared libraries are run in the correct order when the libraries
     are unloaded.  The default is to return false.

 -- Target Hook: void TARGET_CXX_ADJUST_CLASS_AT_DEFINITION (tree TYPE)
     TYPE is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that has just
     been defined.  Use this hook to make adjustments to the class (eg,
     tweak visibility or perform any other required target
     modifications).

 -- Target Hook: tree TARGET_CXX_DECL_MANGLING_CONTEXT (const_tree DECL)
     Return target-specific mangling context of DECL or 'NULL_TREE'.

==============================================================================
File: gccint.info,  Node: |D_Language_and_ABI|,  Next: |Named_Address_Spaces|,  Prev: |C++_ABI|,  Up: |Target_Macros|
==============================================================================

                                                            *D_Language_and_ABI*

18.29 D ABI parameters
=====-----------------

 -- D Target Hook: void TARGET_D_CPU_VERSIONS (void)
     Declare all environmental version identifiers relating to the
     target CPU using the function 'builtin_version', which takes a
     string representing the name of the version.  Version identifiers
     predefined by this hook apply to all modules that are being
     compiled and imported.

 -- D Target Hook: void TARGET_D_OS_VERSIONS (void)
     Similarly to 'TARGET_D_CPU_VERSIONS', but is used for versions
     relating to the target operating system.

 -- D Target Hook: unsigned TARGET_D_CRITSEC_SIZE (void)
     Returns the size of the data structure used by the target operating
     system for critical sections and monitors.  For example, on
     Microsoft Windows this would return the 'sizeof(CRITICAL_SECTION)',
     while other platforms that implement pthreads would return
     'sizeof(pthread_mutex_t)'.

==============================================================================
File: gccint.info,  Node: |Named_Address_Spaces|,  Next: |Misc|,  Prev: |D_Language_and_ABI|,  Up: |Target_Macros|
==============================================================================

                                                          *Named_Address_Spaces*

18.30 Adding support for named address spaces
=====----------------------------------------

The draft technical report of the ISO/IEC JTC1 S22 WG14 N1275 standards
committee, 'Programming Languages - C - Extensions to support embedded
processors', specifies a syntax for embedded processors to specify
alternate address spaces.  You can configure a GCC port to support
section 5.1 of the draft report to add support for address spaces other
than the default address space.  These address spaces are new keywords
that are similar to the 'volatile' and 'const' type attributes.

 Pointers to named address spaces can have a different size than
pointers to the generic address space.

 For example, the SPU port uses the '__ea' address space to refer to
memory in the host processor, rather than memory local to the SPU
processor.  Access to memory in the '__ea' address space involves
issuing DMA operations to move data between the host processor and the
local processor memory address space.  Pointers in the '__ea' address
space are either 32 bits or 64 bits based on the '-mea32' or '-mea64'
switches (native SPU pointers are always 32 bits).

 Internally, address spaces are represented as a small integer in the
range 0 to 15 with address space 0 being reserved for the generic
address space.

 To register a named address space qualifier keyword with the C front
end, the target may call the 'c_register_addr_space' routine.  For
example, the SPU port uses the following to declare '__ea' as the
keyword for named address space #1:
     #define ADDR_SPACE_EA 1
     c_register_addr_space ("__ea", ADDR_SPACE_EA);

 -- Target Hook: scalar_int_mode TARGET_ADDR_SPACE_POINTER_MODE
          (addr_space_t ADDRESS_SPACE)
     Define this to return the machine mode to use for pointers to
     ADDRESS_SPACE if the target supports named address spaces.  The
     default version of this hook returns 'ptr_mode'.

 -- Target Hook: scalar_int_mode TARGET_ADDR_SPACE_ADDRESS_MODE
          (addr_space_t ADDRESS_SPACE)
     Define this to return the machine mode to use for addresses in
     ADDRESS_SPACE if the target supports named address spaces.  The
     default version of this hook returns 'Pmode'.

 -- Target Hook: bool TARGET_ADDR_SPACE_VALID_POINTER_MODE
          (scalar_int_mode MODE, addr_space_t AS)
     Define this to return nonzero if the port can handle pointers with
     machine mode MODE to address space AS.  This target hook is the
     same as the 'TARGET_VALID_POINTER_MODE' target hook, except that it
     includes explicit named address space support.  The default version
     of this hook returns true for the modes returned by either the
     'TARGET_ADDR_SPACE_POINTER_MODE' or
     'TARGET_ADDR_SPACE_ADDRESS_MODE' target hooks for the given address
     space.

 -- Target Hook: bool TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P
          (machine_mode MODE, rtx EXP, bool STRICT, addr_space_t AS)
     Define this to return true if EXP is a valid address for mode MODE
     in the named address space AS.  The STRICT parameter says whether
     strict addressing is in effect after reload has finished.  This
     target hook is the same as the 'TARGET_LEGITIMATE_ADDRESS_P' target
     hook, except that it includes explicit named address space support.

 -- Target Hook: rtx TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS (rtx X, rtx
          OLDX, machine_mode MODE, addr_space_t AS)
     Define this to modify an invalid address X to be a valid address
     with mode MODE in the named address space AS.  This target hook is
     the same as the 'TARGET_LEGITIMIZE_ADDRESS' target hook, except
     that it includes explicit named address space support.

 -- Target Hook: bool TARGET_ADDR_SPACE_SUBSET_P (addr_space_t SUBSET,
          addr_space_t SUPERSET)
     Define this to return whether the SUBSET named address space is
     contained within the SUPERSET named address space.  Pointers to a
     named address space that is a subset of another named address space
     will be converted automatically without a cast if used together in
     arithmetic operations.  Pointers to a superset address space can be
     converted to pointers to a subset address space via explicit casts.

 -- Target Hook: bool TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID (addr_space_t
          AS)
     Define this to modify the default handling of address 0 for the
     address space.  Return true if 0 should be considered a valid
     address.

 -- Target Hook: rtx TARGET_ADDR_SPACE_CONVERT (rtx OP, tree FROM_TYPE,
          tree TO_TYPE)
     Define this to convert the pointer expression represented by the
     RTL OP with type FROM_TYPE that points to a named address space to
     a new pointer expression with type TO_TYPE that points to a
     different named address space.  When this hook it called, it is
     guaranteed that one of the two address spaces is a subset of the
     other, as determined by the 'TARGET_ADDR_SPACE_SUBSET_P' target
     hook.

 -- Target Hook: int TARGET_ADDR_SPACE_DEBUG (addr_space_t AS)
     Define this to define how the address space is encoded in dwarf.
     The result is the value to be used with 'DW_AT_address_class'.

 -- Target Hook: void TARGET_ADDR_SPACE_DIAGNOSE_USAGE (addr_space_t AS,
          location_t LOC)
     Define this hook if the availability of an address space depends on
     command line options and some diagnostics should be printed when
     the address space is used.  This hook is called during parsing and
     allows to emit a better diagnostic compared to the case where the
     address space was not registered with 'c_register_addr_space'.  AS
     is the address space as registered with 'c_register_addr_space'.
     LOC is the location of the address space qualifier token.  The
     default implementation does nothing.

==============================================================================
File: gccint.info,  Node: |Misc|,  Prev: |Named_Address_Spaces|,  Up: |Target_Macros|
==============================================================================

                                                                          *Misc*

18.31 Miscellaneous Parameters
=====-------------------------

Here are several miscellaneous parameters.

 -- Macro: HAS_LONG_COND_BRANCH
     Define this boolean macro to indicate whether or not your
     architecture has conditional branches that can span all of memory.
     It is used in conjunction with an optimization that partitions hot
     and cold basic blocks into separate sections of the executable.  If
     this macro is set to false, gcc will convert any conditional
     branches that attempt to cross between sections into unconditional
     branches or indirect jumps.

 -- Macro: HAS_LONG_UNCOND_BRANCH
     Define this boolean macro to indicate whether or not your
     architecture has unconditional branches that can span all of
     memory.  It is used in conjunction with an optimization that
     partitions hot and cold basic blocks into separate sections of the
     executable.  If this macro is set to false, gcc will convert any
     unconditional branches that attempt to cross between sections into
     indirect jumps.

 -- Macro: CASE_VECTOR_MODE
     An alias for a machine mode name.  This is the machine mode that
     elements of a jump-table should have.

 -- Macro: CASE_VECTOR_SHORTEN_MODE (MIN_OFFSET, MAX_OFFSET, BODY)
     Optional: return the preferred mode for an 'addr_diff_vec' when the
     minimum and maximum offset are known.  If you define this, it
     enables extra code in branch shortening to deal with
     'addr_diff_vec'.  To make this work, you also have to define
     'INSN_ALIGN' and make the alignment for 'addr_diff_vec' explicit.
     The BODY argument is provided so that the offset_unsigned and scale
     flags can be updated.

 -- Macro: CASE_VECTOR_PC_RELATIVE
     Define this macro to be a C expression to indicate when jump-tables
     should contain relative addresses.  You need not define this macro
     if jump-tables never contain relative addresses, or jump-tables
     should contain relative addresses only when '-fPIC' or '-fPIC' is
     in effect.

 -- Target Hook: unsigned int TARGET_CASE_VALUES_THRESHOLD (void)
     This function return the smallest number of different values for
     which it is best to use a jump-table instead of a tree of
     conditional branches.  The default is four for machines with a
     'casesi' instruction and five otherwise.  This is best for most
     machines.

 -- Macro: WORD_REGISTER_OPERATIONS
     Define this macro to 1 if operations between registers with
     integral mode smaller than a word are always performed on the
     entire register.  To be more explicit, if you start with a pair of
     'word_mode' registers with known values and you do a subword, for
     example 'QImode', addition on the low part of the registers, then
     the compiler may consider that the result has a known value in
     'word_mode' too if the macro is defined to 1.  Most RISC machines
     have this property and most CISC machines do not.

 -- Target Hook: unsigned int TARGET_MIN_ARITHMETIC_PRECISION (void)
     On some RISC architectures with 64-bit registers, the processor
     also maintains 32-bit condition codes that make it possible to do
     real 32-bit arithmetic, although the operations are performed on
     the full registers.

     On such architectures, defining this hook to 32 tells the compiler
     to try using 32-bit arithmetical operations setting the condition
     codes instead of doing full 64-bit arithmetic.

     More generally, define this hook on RISC architectures if you want
     the compiler to try using arithmetical operations setting the
     condition codes with a precision lower than the word precision.

     You need not define this hook if 'WORD_REGISTER_OPERATIONS' is not
     defined to 1.

 -- Macro: LOAD_EXTEND_OP (MEM_MODE)
     Define this macro to be a C expression indicating when insns that
     read memory in MEM_MODE, an integral mode narrower than a word, set
     the bits outside of MEM_MODE to be either the sign-extension or the
     zero-extension of the data read.  Return 'SIGN_EXTEND' for values
     of MEM_MODE for which the insn sign-extends, 'ZERO_EXTEND' for
     which it zero-extends, and 'UNKNOWN' for other modes.

     This macro is not called with MEM_MODE non-integral or with a width
     greater than or equal to 'BITS_PER_WORD', so you may return any
     value in this case.  Do not define this macro if it would always
     return 'UNKNOWN'.  On machines where this macro is defined, you
     will normally define it as the constant 'SIGN_EXTEND' or
     'ZERO_EXTEND'.

     You may return a non-'UNKNOWN' value even if for some hard
     registers the sign extension is not performed, if for the
     'REGNO_REG_CLASS' of these hard registers
     'TARGET_CAN_CHANGE_MODE_CLASS' returns false when the FROM mode is
     MEM_MODE and the TO mode is any integral mode larger than this but
     not larger than 'word_mode'.

     You must return 'UNKNOWN' if for some hard registers that allow
     this mode, 'TARGET_CAN_CHANGE_MODE_CLASS' says that they cannot
     change to 'word_mode', but that they can change to another integral
     mode that is larger then MEM_MODE but still smaller than
     'word_mode'.

 -- Macro: SHORT_IMMEDIATES_SIGN_EXTEND
     Define this macro to 1 if loading short immediate values into
     registers sign extends.

 -- Target Hook: unsigned int TARGET_MIN_DIVISIONS_FOR_RECIP_MUL
          (machine_mode MODE)
     When '-ffast-math' is in effect, GCC tries to optimize divisions by
     the same divisor, by turning them into multiplications by the
     reciprocal.  This target hook specifies the minimum number of
     divisions that should be there for GCC to perform the optimization
     for a variable of mode MODE.  The default implementation returns 3
     if the machine has an instruction for the division, and 2 if it
     does not.

 -- Macro: MOVE_MAX
     The maximum number of bytes that a single instruction can move
     quickly between memory and registers or between two memory
     locations.

 -- Macro: MAX_MOVE_MAX
     The maximum number of bytes that a single instruction can move
     quickly between memory and registers or between two memory
     locations.  If this is undefined, the default is 'MOVE_MAX'.
     Otherwise, it is the constant value that is the largest value that
     'MOVE_MAX' can have at run-time.

 -- Macro: SHIFT_COUNT_TRUNCATED
     A C expression that is nonzero if on this machine the number of
     bits actually used for the count of a shift operation is equal to
     the number of bits needed to represent the size of the object being
     shifted.  When this macro is nonzero, the compiler will assume that
     it is safe to omit a sign-extend, zero-extend, and certain bitwise
     'and' instructions that truncates the count of a shift operation.
     On machines that have instructions that act on bit-fields at
     variable positions, which may include 'bit test' instructions, a
     nonzero 'SHIFT_COUNT_TRUNCATED' also enables deletion of
     truncations of the values that serve as arguments to bit-field
     instructions.

     If both types of instructions truncate the count (for shifts) and
     position (for bit-field operations), or if no variable-position
     bit-field instructions exist, you should define this macro.

     However, on some machines, such as the 80386 and the 680x0,
     truncation only applies to shift operations and not the (real or
     pretended) bit-field operations.  Define 'SHIFT_COUNT_TRUNCATED' to
     be zero on such machines.  Instead, add patterns to the 'md' file
     that include the implied truncation of the shift instructions.

     You need not define this macro if it would always have the value of
     zero.

 -- Target Hook: unsigned HOST_WIDE_INT TARGET_SHIFT_TRUNCATION_MASK
          (machine_mode MODE)
     This function describes how the standard shift patterns for MODE
     deal with shifts by negative amounts or by more than the width of
     the mode.  *Note shift patterns::.

     On many machines, the shift patterns will apply a mask M to the
     shift count, meaning that a fixed-width shift of X by Y is
     equivalent to an arbitrary-width shift of X by Y & M.  If this is
     true for mode MODE, the function should return M, otherwise it
     should return 0.  A return value of 0 indicates that no particular
     behavior is guaranteed.

     Note that, unlike 'SHIFT_COUNT_TRUNCATED', this function does _not_
     apply to general shift rtxes; it applies only to instructions that
     are generated by the named shift patterns.

     The default implementation of this function returns
     'GET_MODE_BITSIZE (MODE) - 1' if 'SHIFT_COUNT_TRUNCATED' and 0
     otherwise.  This definition is always safe, but if
     'SHIFT_COUNT_TRUNCATED' is false, and some shift patterns
     nevertheless truncate the shift count, you may get better code by
     overriding it.

 -- Target Hook: bool TARGET_TRULY_NOOP_TRUNCATION (poly_uint64 OUTPREC,
          poly_uint64 INPREC)
     This hook returns true if it is safe to "convert" a value of INPREC
     bits to one of OUTPREC bits (where OUTPREC is smaller than INPREC)
     by merely operating on it as if it had only OUTPREC bits.  The
     default returns true unconditionally, which is correct for most
     machines.

     If 'TARGET_MODES_TIEABLE_P' returns false for a pair of modes,
     suboptimal code can result if this hook returns true for the
     corresponding mode sizes.  Making this hook return false in such
     cases may improve things.

 -- Target Hook: int TARGET_MODE_REP_EXTENDED (scalar_int_mode MODE,
          scalar_int_mode REP_MODE)
     The representation of an integral mode can be such that the values
     are always extended to a wider integral mode.  Return 'SIGN_EXTEND'
     if values of MODE are represented in sign-extended form to
     REP_MODE.  Return 'UNKNOWN' otherwise.  (Currently, none of the
     targets use zero-extended representation this way so unlike
     'LOAD_EXTEND_OP', 'TARGET_MODE_REP_EXTENDED' is expected to return
     either 'SIGN_EXTEND' or 'UNKNOWN'.  Also no target extends MODE to
     REP_MODE so that REP_MODE is not the next widest integral mode and
     currently we take advantage of this fact.)

     Similarly to 'LOAD_EXTEND_OP' you may return a non-'UNKNOWN' value
     even if the extension is not performed on certain hard registers as
     long as for the 'REGNO_REG_CLASS' of these hard registers
     'TARGET_CAN_CHANGE_MODE_CLASS' returns false.

     Note that 'TARGET_MODE_REP_EXTENDED' and 'LOAD_EXTEND_OP' describe
     two related properties.  If you define 'TARGET_MODE_REP_EXTENDED
     (mode, word_mode)' you probably also want to define 'LOAD_EXTEND_OP
     (mode)' to return the same type of extension.

     In order to enforce the representation of 'mode',
     'TARGET_TRULY_NOOP_TRUNCATION' should return false when truncating
     to 'mode'.

 -- Target Hook: bool TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P (void)
     On some targets, it is assumed that the compiler will spill all
     pseudos that are live across a call to 'setjmp', while other
     targets treat 'setjmp' calls as normal function calls.

     This hook returns false if 'setjmp' calls do not preserve all
     non-volatile registers so that gcc that must spill all pseudos that
     are live across 'setjmp' calls.  Define this to return true if the
     target does not need to spill all pseudos live across 'setjmp'
     calls.  The default implementation conservatively assumes all
     pseudos must be spilled across 'setjmp' calls.

 -- Macro: STORE_FLAG_VALUE
     A C expression describing the value returned by a comparison
     operator with an integral mode and stored by a store-flag
     instruction ('cstoreMODE4') when the condition is true.  This
     description must apply to _all_ the 'cstoreMODE4' patterns and all
     the comparison operators whose results have a 'MODE_INT' mode.

     A value of 1 or -1 means that the instruction implementing the
     comparison operator returns exactly 1 or -1 when the comparison is
     true and 0 when the comparison is false.  Otherwise, the value
     indicates which bits of the result are guaranteed to be 1 when the
     comparison is true.  This value is interpreted in the mode of the
     comparison operation, which is given by the mode of the first
     operand in the 'cstoreMODE4' pattern.  Either the low bit or the
     sign bit of 'STORE_FLAG_VALUE' be on.  Presently, only those bits
     are used by the compiler.

     If 'STORE_FLAG_VALUE' is neither 1 or -1, the compiler will
     generate code that depends only on the specified bits.  It can also
     replace comparison operators with equivalent operations if they
     cause the required bits to be set, even if the remaining bits are
     undefined.  For example, on a machine whose comparison operators
     return an 'SImode' value and where 'STORE_FLAG_VALUE' is defined as
     '0x80000000', saying that just the sign bit is relevant, the
     expression

          (ne:SI (and:SI X (const_int POWER-OF-2)) (const_int 0))

     can be converted to

          (ashift:SI X (const_int N))

     where N is the appropriate shift count to move the bit being tested
     into the sign bit.

     There is no way to describe a machine that always sets the
     low-order bit for a true value, but does not guarantee the value of
     any other bits, but we do not know of any machine that has such an
     instruction.  If you are trying to port GCC to such a machine,
     include an instruction to perform a logical-and of the result with
     1 in the pattern for the comparison operators and let us know at
     <gcc@gcc.gnu.org>.

     Often, a machine will have multiple instructions that obtain a
     value from a comparison (or the condition codes).  Here are rules
     to guide the choice of value for 'STORE_FLAG_VALUE', and hence the
     instructions to be used:

        * Use the shortest sequence that yields a valid definition for
          'STORE_FLAG_VALUE'.  It is more efficient for the compiler to
          "normalize" the value (convert it to, e.g., 1 or 0) than for
          the comparison operators to do so because there may be
          opportunities to combine the normalization with other
          operations.

        * For equal-length sequences, use a value of 1 or -1, with -1
          being slightly preferred on machines with expensive jumps and
          1 preferred on other machines.

        * As a second choice, choose a value of '0x80000001' if
          instructions exist that set both the sign and low-order bits
          but do not define the others.

        * Otherwise, use a value of '0x80000000'.

     Many machines can produce both the value chosen for
     'STORE_FLAG_VALUE' and its negation in the same number of
     instructions.  On those machines, you should also define a pattern
     for those cases, e.g., one matching

          (set A (neg:M (ne:M B C)))

     Some machines can also perform 'and' or 'plus' operations on
     condition code values with less instructions than the corresponding
     'cstoreMODE4' insn followed by 'and' or 'plus'.  On those machines,
     define the appropriate patterns.  Use the names 'incscc' and
     'decscc', respectively, for the patterns which perform 'plus' or
     'minus' operations on condition code values.  See 'rs6000.md' for
     some examples.  The GNU Superoptimizer can be used to find such
     instruction sequences on other machines.

     If this macro is not defined, the default value, 1, is used.  You
     need not define 'STORE_FLAG_VALUE' if the machine has no store-flag
     instructions, or if the value generated by these instructions is 1.

 -- Macro: FLOAT_STORE_FLAG_VALUE (MODE)
     A C expression that gives a nonzero 'REAL_VALUE_TYPE' value that is
     returned when comparison operators with floating-point results are
     true.  Define this macro on machines that have comparison
     operations that return floating-point values.  If there are no such
     operations, do not define this macro.

 -- Macro: VECTOR_STORE_FLAG_VALUE (MODE)
     A C expression that gives a rtx representing the nonzero true
     element for vector comparisons.  The returned rtx should be valid
     for the inner mode of MODE which is guaranteed to be a vector mode.
     Define this macro on machines that have vector comparison
     operations that return a vector result.  If there are no such
     operations, do not define this macro.  Typically, this macro is
     defined as 'const1_rtx' or 'constm1_rtx'.  This macro may return
     'NULL_RTX' to prevent the compiler optimizing such vector
     comparison operations for the given mode.

 -- Macro: CLZ_DEFINED_VALUE_AT_ZERO (MODE, VALUE)
 -- Macro: CTZ_DEFINED_VALUE_AT_ZERO (MODE, VALUE)
     A C expression that indicates whether the architecture defines a
     value for 'clz' or 'ctz' with a zero operand.  A result of '0'
     indicates the value is undefined.  If the value is defined for only
     the RTL expression, the macro should evaluate to '1'; if the value
     applies also to the corresponding optab entry (which is normally
     the case if it expands directly into the corresponding RTL), then
     the macro should evaluate to '2'.  In the cases where the value is
     defined, VALUE should be set to this value.

     If this macro is not defined, the value of 'clz' or 'ctz' at zero
     is assumed to be undefined.

     This macro must be defined if the target's expansion for 'ffs'
     relies on a particular value to get correct results.  Otherwise it
     is not necessary, though it may be used to optimize some corner
     cases, and to provide a default expansion for the 'ffs' optab.

     Note that regardless of this macro the "definedness" of 'clz' and
     'ctz' at zero do _not_ extend to the builtin functions visible to
     the user.  Thus one may be free to adjust the value at will to
     match the target expansion of these operations without fear of
     breaking the API.

 -- Macro: Pmode
     An alias for the machine mode for pointers.  On most machines,
     define this to be the integer mode corresponding to the width of a
     hardware pointer; 'SImode' on 32-bit machine or 'DImode' on 64-bit
     machines.  On some machines you must define this to be one of the
     partial integer modes, such as 'PSImode'.

     The width of 'Pmode' must be at least as large as the value of
     'POINTER_SIZE'.  If it is not equal, you must define the macro
     'POINTERS_EXTEND_UNSIGNED' to specify how pointers are extended to
     'Pmode'.

 -- Macro: FUNCTION_MODE
     An alias for the machine mode used for memory references to
     functions being called, in 'call' RTL expressions.  On most CISC
     machines, where an instruction can begin at any byte address, this
     should be 'QImode'.  On most RISC machines, where all instructions
     have fixed size and alignment, this should be a mode with the same
     size and alignment as the machine instruction words - typically
     'SImode' or 'HImode'.

 -- Macro: STDC_0_IN_SYSTEM_HEADERS
     In normal operation, the preprocessor expands '__STDC__' to the
     constant 1, to signify that GCC conforms to ISO Standard C.  On
     some hosts, like Solaris, the system compiler uses a different
     convention, where '__STDC__' is normally 0, but is 1 if the user
     specifies strict conformance to the C Standard.

     Defining 'STDC_0_IN_SYSTEM_HEADERS' makes GNU CPP follows the host
     convention when processing system header files, but when processing
     user files '__STDC__' will always expand to 1.

 -- C Target Hook: const char * TARGET_C_PREINCLUDE (void)
     Define this hook to return the name of a header file to be included
     at the start of all compilations, as if it had been included with
     '#include <FILE>'.  If this hook returns 'NULL', or is not defined,
     or the header is not found, or if the user specifies
     '-ffreestanding' or '-nostdinc', no header is included.

     This hook can be used together with a header provided by the system
     C library to implement ISO C requirements for certain macros to be
     predefined that describe properties of the whole implementation
     rather than just the compiler.

 -- C Target Hook: bool TARGET_CXX_IMPLICIT_EXTERN_C (const char*)
     Define this hook to add target-specific C++ implicit extern C
     functions.  If this function returns true for the name of a
     file-scope function, that function implicitly gets extern "C"
     linkage rather than whatever language linkage the declaration would
     normally have.  An example of such function is WinMain on Win32
     targets.

 -- Macro: SYSTEM_IMPLICIT_EXTERN_C
     Define this macro if the system header files do not support C++.
     This macro handles system header files by pretending that system
     header files are enclosed in 'extern "C" {...}'.

 -- Macro: REGISTER_TARGET_PRAGMAS ()
     Define this macro if you want to implement any target-specific
     pragmas.  If defined, it is a C expression which makes a series of
     calls to 'c_register_pragma' or 'c_register_pragma_with_expansion'
     for each pragma.  The macro may also do any setup required for the
     pragmas.

     The primary reason to define this macro is to provide compatibility
     with other compilers for the same target.  In general, we
     discourage definition of target-specific pragmas for GCC.

     If the pragma can be implemented by attributes then you should
     consider defining the target hook 'TARGET_INSERT_ATTRIBUTES' as
     well.

     Preprocessor macros that appear on pragma lines are not expanded.
     All '#pragma' directives that do not match any registered pragma
     are silently ignored, unless the user specifies
     '-Wunknown-pragmas'.

 -- Function: void c_register_pragma (const char *SPACE, const char
          *NAME, void (*CALLBACK) (struct cpp_reader *))
 -- Function: void c_register_pragma_with_expansion (const char *SPACE,
          const char *NAME, void (*CALLBACK) (struct cpp_reader *))

     Each call to 'c_register_pragma' or
     'c_register_pragma_with_expansion' establishes one pragma.  The
     CALLBACK routine will be called when the preprocessor encounters a
     pragma of the form

          #pragma [SPACE] NAME ...

     SPACE is the case-sensitive namespace of the pragma, or 'NULL' to
     put the pragma in the global namespace.  The callback routine
     receives PFILE as its first argument, which can be passed on to
     cpplib's functions if necessary.  You can lex tokens after the NAME
     by calling 'pragma_lex'.  Tokens that are not read by the callback
     will be silently ignored.  The end of the line is indicated by a
     token of type 'CPP_EOF'.  Macro expansion occurs on the arguments
     of pragmas registered with 'c_register_pragma_with_expansion' but
     not on the arguments of pragmas registered with
     'c_register_pragma'.

     Note that the use of 'pragma_lex' is specific to the C and C++
     compilers.  It will not work in the Java or Fortran compilers, or
     any other language compilers for that matter.  Thus if 'pragma_lex'
     is going to be called from target-specific code, it must only be
     done so when building the C and C++ compilers.  This can be done by
     defining the variables 'c_target_objs' and 'cxx_target_objs' in the
     target entry in the 'config.gcc' file.  These variables should name
     the target-specific, language-specific object file which contains
     the code that uses 'pragma_lex'.  Note it will also be necessary to
     add a rule to the makefile fragment pointed to by 'tmake_file' that
     shows how to build this object file.

 -- Macro: HANDLE_PRAGMA_PACK_WITH_EXPANSION
     Define this macro if macros should be expanded in the arguments of
     '#pragma pack'.

 -- Macro: TARGET_DEFAULT_PACK_STRUCT
     If your target requires a structure packing default other than 0
     (meaning the machine default), define this macro to the necessary
     value (in bytes).  This must be a value that would also be valid to
     use with '#pragma pack()' (that is, a small power of two).

 -- Macro: DOLLARS_IN_IDENTIFIERS
     Define this macro to control use of the character '$' in identifier
     names for the C family of languages.  0 means '$' is not allowed by
     default; 1 means it is allowed.  1 is the default; there is no need
     to define this macro in that case.

 -- Macro: INSN_SETS_ARE_DELAYED (INSN)
     Define this macro as a C expression that is nonzero if it is safe
     for the delay slot scheduler to place instructions in the delay
     slot of INSN, even if they appear to use a resource set or
     clobbered in INSN.  INSN is always a 'jump_insn' or an 'insn'; GCC
     knows that every 'call_insn' has this behavior.  On machines where
     some 'insn' or 'jump_insn' is really a function call and hence has
     this behavior, you should define this macro.

     You need not define this macro if it would always return zero.

 -- Macro: INSN_REFERENCES_ARE_DELAYED (INSN)
     Define this macro as a C expression that is nonzero if it is safe
     for the delay slot scheduler to place instructions in the delay
     slot of INSN, even if they appear to set or clobber a resource
     referenced in INSN.  INSN is always a 'jump_insn' or an 'insn'.  On
     machines where some 'insn' or 'jump_insn' is really a function call
     and its operands are registers whose use is actually in the
     subroutine it calls, you should define this macro.  Doing so allows
     the delay slot scheduler to move instructions which copy arguments
     into the argument registers into the delay slot of INSN.

     You need not define this macro if it would always return zero.

 -- Macro: MULTIPLE_SYMBOL_SPACES
     Define this macro as a C expression that is nonzero if, in some
     cases, global symbols from one translation unit may not be bound to
     undefined symbols in another translation unit without user
     intervention.  For instance, under Microsoft Windows symbols must
     be explicitly imported from shared libraries (DLLs).

     You need not define this macro if it would always evaluate to zero.

 -- Target Hook: rtx_insn * TARGET_MD_ASM_ADJUST (vec<rtx>& OUTPUTS,
          vec<rtx>& INPUTS, vec<const char *>& CONSTRAINTS, vec<rtx>&
          CLOBBERS, HARD_REG_SET& CLOBBERED_REGS)
     This target hook may add "clobbers" to CLOBBERS and CLOBBERED_REGS
     for any hard regs the port wishes to automatically clobber for an
     asm.  The OUTPUTS and INPUTS may be inspected to avoid clobbering a
     register that is already used by the asm.

     It may modify the OUTPUTS, INPUTS, and CONSTRAINTS as necessary for
     other pre-processing.  In this case the return value is a sequence
     of insns to emit after the asm.

 -- Macro: MATH_LIBRARY
     Define this macro as a C string constant for the linker argument to
     link in the system math library, minus the initial '"-l"', or '""'
     if the target does not have a separate math library.

     You need only define this macro if the default of '"m"' is wrong.

 -- Macro: LIBRARY_PATH_ENV
     Define this macro as a C string constant for the environment
     variable that specifies where the linker should look for libraries.

     You need only define this macro if the default of '"LIBRARY_PATH"'
     is wrong.

 -- Macro: TARGET_POSIX_IO
     Define this macro if the target supports the following POSIX file
     functions, access, mkdir and file locking with fcntl / F_SETLKW.
     Defining 'TARGET_POSIX_IO' will enable the test coverage code to
     use file locking when exiting a program, which avoids race
     conditions if the program has forked.  It will also create
     directories at run-time for cross-profiling.

 -- Macro: MAX_CONDITIONAL_EXECUTE

     A C expression for the maximum number of instructions to execute
     via conditional execution instructions instead of a branch.  A
     value of 'BRANCH_COST'+1 is the default if the machine does not use
     cc0, and 1 if it does use cc0.

 -- Macro: IFCVT_MODIFY_TESTS (CE_INFO, TRUE_EXPR, FALSE_EXPR)
     Used if the target needs to perform machine-dependent modifications
     on the conditionals used for turning basic blocks into
     conditionally executed code.  CE_INFO points to a data structure,
     'struct ce_if_block', which contains information about the
     currently processed blocks.  TRUE_EXPR and FALSE_EXPR are the tests
     that are used for converting the then-block and the else-block,
     respectively.  Set either TRUE_EXPR or FALSE_EXPR to a null pointer
     if the tests cannot be converted.

 -- Macro: IFCVT_MODIFY_MULTIPLE_TESTS (CE_INFO, BB, TRUE_EXPR,
          FALSE_EXPR)
     Like 'IFCVT_MODIFY_TESTS', but used when converting more
     complicated if-statements into conditions combined by 'and' and
     'or' operations.  BB contains the basic block that contains the
     test that is currently being processed and about to be turned into
     a condition.

 -- Macro: IFCVT_MODIFY_INSN (CE_INFO, PATTERN, INSN)
     A C expression to modify the PATTERN of an INSN that is to be
     converted to conditional execution format.  CE_INFO points to a
     data structure, 'struct ce_if_block', which contains information
     about the currently processed blocks.

 -- Macro: IFCVT_MODIFY_FINAL (CE_INFO)
     A C expression to perform any final machine dependent modifications
     in converting code to conditional execution.  The involved basic
     blocks can be found in the 'struct ce_if_block' structure that is
     pointed to by CE_INFO.

 -- Macro: IFCVT_MODIFY_CANCEL (CE_INFO)
     A C expression to cancel any machine dependent modifications in
     converting code to conditional execution.  The involved basic
     blocks can be found in the 'struct ce_if_block' structure that is
     pointed to by CE_INFO.

 -- Macro: IFCVT_MACHDEP_INIT (CE_INFO)
     A C expression to initialize any machine specific data for
     if-conversion of the if-block in the 'struct ce_if_block' structure
     that is pointed to by CE_INFO.

 -- Target Hook: void TARGET_MACHINE_DEPENDENT_REORG (void)
     If non-null, this hook performs a target-specific pass over the
     instruction stream.  The compiler will run it at all optimization
     levels, just before the point at which it normally does
     delayed-branch scheduling.

     The exact purpose of the hook varies from target to target.  Some
     use it to do transformations that are necessary for correctness,
     such as laying out in-function constant pools or avoiding hardware
     hazards.  Others use it as an opportunity to do some
     machine-dependent optimizations.

     You need not implement the hook if it has nothing to do.  The
     default definition is null.

 -- Target Hook: void TARGET_INIT_BUILTINS (void)
     Define this hook if you have any machine-specific built-in
     functions that need to be defined.  It should be a function that
     performs the necessary setup.

     Machine specific built-in functions can be useful to expand special
     machine instructions that would otherwise not normally be generated
     because they have no equivalent in the source language (for
     example, SIMD vector instructions or prefetch instructions).

     To create a built-in function, call the function
     'lang_hooks.builtin_function' which is defined by the language
     front end.  You can use any type nodes set up by
     'build_common_tree_nodes'; only language front ends that use those
     two functions will call 'TARGET_INIT_BUILTINS'.

 -- Target Hook: tree TARGET_BUILTIN_DECL (unsigned CODE, bool
          INITIALIZE_P)
     Define this hook if you have any machine-specific built-in
     functions that need to be defined.  It should be a function that
     returns the builtin function declaration for the builtin function
     code CODE.  If there is no such builtin and it cannot be
     initialized at this time if INITIALIZE_P is true the function
     should return 'NULL_TREE'.  If CODE is out of range the function
     should return 'error_mark_node'.

 -- Target Hook: rtx TARGET_EXPAND_BUILTIN (tree EXP, rtx TARGET, rtx
          SUBTARGET, machine_mode MODE, int IGNORE)

     Expand a call to a machine specific built-in function that was set
     up by 'TARGET_INIT_BUILTINS'.  EXP is the expression for the
     function call; the result should go to TARGET if that is
     convenient, and have mode MODE if that is convenient.  SUBTARGET
     may be used as the target for computing one of EXP's operands.
     IGNORE is nonzero if the value is to be ignored.  This function
     should return the result of the call to the built-in function.

 -- Target Hook: tree TARGET_RESOLVE_OVERLOADED_BUILTIN (unsigned int
          LOC, tree FNDECL, void *ARGLIST)
     Select a replacement for a machine specific built-in function that
     was set up by 'TARGET_INIT_BUILTINS'.  This is done _before_
     regular type checking, and so allows the target to implement a
     crude form of function overloading.  FNDECL is the declaration of
     the built-in function.  ARGLIST is the list of arguments passed to
     the built-in function.  The result is a complete expression that
     implements the operation, usually another 'CALL_EXPR'.  ARGLIST
     really has type 'VEC(tree,gc)*'

 -- Target Hook: bool TARGET_CHECK_BUILTIN_CALL (location_t LOC,
          vec<location_t> ARG_LOC, tree FNDECL, tree ORIG_FNDECL,
          unsigned int NARGS, tree *ARGS)
     Perform semantic checking on a call to a machine-specific built-in
     function after its arguments have been constrained to the function
     signature.  Return true if the call is valid, otherwise report an
     error and return false.

     This hook is called after 'TARGET_RESOLVE_OVERLOADED_BUILTIN'.  The
     call was originally to built-in function ORIG_FNDECL, but after the
     optional 'TARGET_RESOLVE_OVERLOADED_BUILTIN' step is now to
     built-in function FNDECL.  LOC is the location of the call and ARGS
     is an array of function arguments, of which there are NARGS.
     ARG_LOC specifies the location of each argument.

 -- Target Hook: tree TARGET_FOLD_BUILTIN (tree FNDECL, int N_ARGS, tree
          *ARGP, bool IGNORE)
     Fold a call to a machine specific built-in function that was set up
     by 'TARGET_INIT_BUILTINS'.  FNDECL is the declaration of the
     built-in function.  N_ARGS is the number of arguments passed to the
     function; the arguments themselves are pointed to by ARGP.  The
     result is another tree, valid for both GIMPLE and GENERIC,
     containing a simplified expression for the call's result.  If
     IGNORE is true the value will be ignored.

 -- Target Hook: bool TARGET_GIMPLE_FOLD_BUILTIN (gimple_stmt_iterator
          *GSI)
     Fold a call to a machine specific built-in function that was set up
     by 'TARGET_INIT_BUILTINS'.  GSI points to the gimple statement
     holding the function call.  Returns true if any change was made to
     the GIMPLE stream.

 -- Target Hook: int TARGET_COMPARE_VERSION_PRIORITY (tree DECL1, tree
          DECL2)
     This hook is used to compare the target attributes in two functions
     to determine which function's features get higher priority.  This
     is used during function multi-versioning to figure out the order in
     which two versions must be dispatched.  A function version with a
     higher priority is checked for dispatching earlier.  DECL1 and
     DECL2 are the two function decls that will be compared.

 -- Target Hook: tree TARGET_GET_FUNCTION_VERSIONS_DISPATCHER (void
          *DECL)
     This hook is used to get the dispatcher function for a set of
     function versions.  The dispatcher function is called to invoke the
     right function version at run-time.  DECL is one version from a set
     of semantically identical versions.

 -- Target Hook: tree TARGET_GENERATE_VERSION_DISPATCHER_BODY (void
          *ARG)
     This hook is used to generate the dispatcher logic to invoke the
     right function version at run-time for a given set of function
     versions.  ARG points to the callgraph node of the dispatcher
     function whose body must be generated.

 -- Target Hook: bool TARGET_PREDICT_DOLOOP_P (class loop *LOOP)
     Return true if we can predict it is possible to use a low-overhead
     loop for a particular loop.  The parameter LOOP is a pointer to the
     loop.  This target hook is required only when the target supports
     low-overhead loops, and will help ivopts to make some decisions.
     The default version of this hook returns false.

 -- Target Hook: bool TARGET_HAVE_COUNT_REG_DECR_P
     Return true if the target supports hardware count register for
     decrement and branch.  The default value is false.

 -- Target Hook: int64_t TARGET_DOLOOP_COST_FOR_GENERIC
     One IV candidate dedicated for doloop is introduced in IVOPTs, we
     can calculate the computation cost of adopting it to any generic IV
     use by function get_computation_cost as before.  But for targets
     which have hardware count register support for decrement and
     branch, it may have to move IV value from hardware count register
     to general purpose register while doloop IV candidate is used for
     generic IV uses.  It probably takes expensive penalty.  This hook
     allows target owners to define the cost for this especially for
     generic IV uses.  The default value is zero.

 -- Target Hook: int64_t TARGET_DOLOOP_COST_FOR_ADDRESS
     One IV candidate dedicated for doloop is introduced in IVOPTs, we
     can calculate the computation cost of adopting it to any address IV
     use by function get_computation_cost as before.  But for targets
     which have hardware count register support for decrement and
     branch, it may have to move IV value from hardware count register
     to general purpose register while doloop IV candidate is used for
     address IV uses.  It probably takes expensive penalty.  This hook
     allows target owners to define the cost for this escpecially for
     address IV uses.  The default value is zero.

 -- Target Hook: bool TARGET_CAN_USE_DOLOOP_P (const widest_int
          &ITERATIONS, const widest_int &ITERATIONS_MAX, unsigned int
          LOOP_DEPTH, bool ENTERED_AT_TOP)
     Return true if it is possible to use low-overhead loops
     ('doloop_end' and 'doloop_begin') for a particular loop.
     ITERATIONS gives the exact number of iterations, or 0 if not known.
     ITERATIONS_MAX gives the maximum number of iterations, or 0 if not
     known.  LOOP_DEPTH is the nesting depth of the loop, with 1 for
     innermost loops, 2 for loops that contain innermost loops, and so
     on.  ENTERED_AT_TOP is true if the loop is only entered from the
     top.

     This hook is only used if 'doloop_end' is available.  The default
     implementation returns true.  You can use
     'can_use_doloop_if_innermost' if the loop must be the innermost,
     and if there are no other restrictions.

 -- Target Hook: const char * TARGET_INVALID_WITHIN_DOLOOP (const
          rtx_insn *INSN)

     Take an instruction in INSN and return NULL if it is valid within a
     low-overhead loop, otherwise return a string explaining why doloop
     could not be applied.

     Many targets use special registers for low-overhead looping.  For
     any instruction that clobbers these this function should return a
     string indicating the reason why the doloop could not be applied.
     By default, the RTL loop optimizer does not use a present doloop
     pattern for loops containing function calls or branch on table
     instructions.

 -- Target Hook: bool TARGET_LEGITIMATE_COMBINED_INSN (rtx_insn *INSN)
     Take an instruction in INSN and return 'false' if the instruction
     is not appropriate as a combination of two or more instructions.
     The default is to accept all instructions.

 -- Target Hook: bool TARGET_CAN_FOLLOW_JUMP (const rtx_insn *FOLLOWER,
          const rtx_insn *FOLLOWEE)
     FOLLOWER and FOLLOWEE are JUMP_INSN instructions; return true if
     FOLLOWER may be modified to follow FOLLOWEE; false, if it can't.
     For example, on some targets, certain kinds of branches can't be
     made to follow through a hot/cold partitioning.

 -- Target Hook: bool TARGET_COMMUTATIVE_P (const_rtx X, int OUTER_CODE)
     This target hook returns 'true' if X is considered to be
     commutative.  Usually, this is just COMMUTATIVE_P (X), but the HP
     PA doesn't consider PLUS to be commutative inside a MEM.
     OUTER_CODE is the rtx code of the enclosing rtl, if known,
     otherwise it is UNKNOWN.

 -- Target Hook: rtx TARGET_ALLOCATE_INITIAL_VALUE (rtx HARD_REG)

     When the initial value of a hard register has been copied in a
     pseudo register, it is often not necessary to actually allocate
     another register to this pseudo register, because the original hard
     register or a stack slot it has been saved into can be used.
     'TARGET_ALLOCATE_INITIAL_VALUE' is called at the start of register
     allocation once for each hard register that had its initial value
     copied by using 'get_func_hard_reg_initial_val' or
     'get_hard_reg_initial_val'.  Possible values are 'NULL_RTX', if you
     don't want to do any special allocation, a 'REG' rtx--that would
     typically be the hard register itself, if it is known not to be
     clobbered--or a 'MEM'.  If you are returning a 'MEM', this is only
     a hint for the allocator; it might decide to use another register
     anyways.  You may use 'current_function_is_leaf' or 'REG_N_SETS' in
     the hook to determine if the hard register in question will not be
     clobbered.  The default value of this hook is 'NULL', which
     disables any special allocation.

 -- Target Hook: int TARGET_UNSPEC_MAY_TRAP_P (const_rtx X, unsigned
          FLAGS)
     This target hook returns nonzero if X, an 'unspec' or
     'unspec_volatile' operation, might cause a trap.  Targets can use
     this hook to enhance precision of analysis for 'unspec' and
     'unspec_volatile' operations.  You may call 'may_trap_p_1' to
     analyze inner elements of X in which case FLAGS should be passed
     along.

 -- Target Hook: void TARGET_SET_CURRENT_FUNCTION (tree DECL)
     The compiler invokes this hook whenever it changes its current
     function context ('cfun').  You can define this function if the
     back end needs to perform any initialization or reset actions on a
     per-function basis.  For example, it may be used to implement
     function attributes that affect register usage or code generation
     patterns.  The argument DECL is the declaration for the new
     function context, and may be null to indicate that the compiler has
     left a function context and is returning to processing at the top
     level.  The default hook function does nothing.

     GCC sets 'cfun' to a dummy function context during initialization
     of some parts of the back end.  The hook function is not invoked in
     this situation; you need not worry about the hook being invoked
     recursively, or when the back end is in a partially-initialized
     state.  'cfun' might be 'NULL' to indicate processing at top level,
     outside of any function scope.

 -- Macro: TARGET_OBJECT_SUFFIX
     Define this macro to be a C string representing the suffix for
     object files on your target machine.  If you do not define this
     macro, GCC will use '.o' as the suffix for object files.

 -- Macro: TARGET_EXECUTABLE_SUFFIX
     Define this macro to be a C string representing the suffix to be
     automatically added to executable files on your target machine.  If
     you do not define this macro, GCC will use the null string as the
     suffix for executable files.

 -- Macro: COLLECT_EXPORT_LIST
     If defined, 'collect2' will scan the individual object files
     specified on its command line and create an export list for the
     linker.  Define this macro for systems like AIX, where the linker
     discards object files that are not referenced from 'main' and uses
     export lists.

 -- Target Hook: bool TARGET_CANNOT_MODIFY_JUMPS_P (void)
     This target hook returns 'true' past the point in which new jump
     instructions could be created.  On machines that require a register
     for every jump such as the SHmedia ISA of SH5, this point would
     typically be reload, so this target hook should be defined to a
     function such as:

          static bool
          cannot_modify_jumps_past_reload_p ()
          {
            return (reload_completed || reload_in_progress);
          }

 -- Target Hook: bool TARGET_HAVE_CONDITIONAL_EXECUTION (void)
     This target hook returns true if the target supports conditional
     execution.  This target hook is required only when the target has
     several different modes and they have different conditional
     execution capability, such as ARM.

 -- Target Hook: rtx TARGET_GEN_CCMP_FIRST (rtx_insn **PREP_SEQ,
          rtx_insn **GEN_SEQ, int CODE, tree OP0, tree OP1)
     This function prepares to emit a comparison insn for the first
     compare in a sequence of conditional comparisions.  It returns an
     appropriate comparison with 'CC' for passing to 'gen_ccmp_next' or
     'cbranch_optab'.  The insns to prepare the compare are saved in
     PREP_SEQ and the compare insns are saved in GEN_SEQ.  They will be
     emitted when all the compares in the conditional comparision are
     generated without error.  CODE is the 'rtx_code' of the compare for
     OP0 and OP1.

 -- Target Hook: rtx TARGET_GEN_CCMP_NEXT (rtx_insn **PREP_SEQ, rtx_insn
          **GEN_SEQ, rtx PREV, int CMP_CODE, tree OP0, tree OP1, int
          BIT_CODE)
     This function prepares to emit a conditional comparison within a
     sequence of conditional comparisons.  It returns an appropriate
     comparison with 'CC' for passing to 'gen_ccmp_next' or
     'cbranch_optab'.  The insns to prepare the compare are saved in
     PREP_SEQ and the compare insns are saved in GEN_SEQ.  They will be
     emitted when all the compares in the conditional comparision are
     generated without error.  The PREV expression is the result of a
     prior call to 'gen_ccmp_first' or 'gen_ccmp_next'.  It may return
     'NULL' if the combination of PREV and this comparison is not
     supported, otherwise the result must be appropriate for passing to
     'gen_ccmp_next' or 'cbranch_optab'.  CODE is the 'rtx_code' of the
     compare for OP0 and OP1.  BIT_CODE is 'AND' or 'IOR', which is the
     op on the compares.

 -- Target Hook: unsigned TARGET_LOOP_UNROLL_ADJUST (unsigned NUNROLL,
          class loop *LOOP)
     This target hook returns a new value for the number of times LOOP
     should be unrolled.  The parameter NUNROLL is the number of times
     the loop is to be unrolled.  The parameter LOOP is a pointer to the
     loop, which is going to be checked for unrolling.  This target hook
     is required only when the target has special constraints like
     maximum number of memory accesses.

 -- Macro: POWI_MAX_MULTS
     If defined, this macro is interpreted as a signed integer C
     expression that specifies the maximum number of floating point
     multiplications that should be emitted when expanding
     exponentiation by an integer constant inline.  When this value is
     defined, exponentiation requiring more than this number of
     multiplications is implemented by calling the system library's
     'pow', 'powf' or 'powl' routines.  The default value places no
     upper bound on the multiplication count.

 -- Macro: void TARGET_EXTRA_INCLUDES (const char *SYSROOT, const char
          *IPREFIX, int STDINC)
     This target hook should register any extra include files for the
     target.  The parameter STDINC indicates if normal include files are
     present.  The parameter SYSROOT is the system root directory.  The
     parameter IPREFIX is the prefix for the gcc directory.

 -- Macro: void TARGET_EXTRA_PRE_INCLUDES (const char *SYSROOT, const
          char *IPREFIX, int STDINC)
     This target hook should register any extra include files for the
     target before any standard headers.  The parameter STDINC indicates
     if normal include files are present.  The parameter SYSROOT is the
     system root directory.  The parameter IPREFIX is the prefix for the
     gcc directory.

 -- Macro: void TARGET_OPTF (char *PATH)
     This target hook should register special include paths for the
     target.  The parameter PATH is the include to register.  On Darwin
     systems, this is used for Framework includes, which have semantics
     that are different from '-I'.

 -- Macro: bool TARGET_USE_LOCAL_THUNK_ALIAS_P (tree FNDECL)
     This target macro returns 'true' if it is safe to use a local alias
     for a virtual function FNDECL when constructing thunks, 'false'
     otherwise.  By default, the macro returns 'true' for all functions,
     if a target supports aliases (i.e. defines 'ASM_OUTPUT_DEF'),
     'false' otherwise,

 -- Macro: TARGET_FORMAT_TYPES
     If defined, this macro is the name of a global variable containing
     target-specific format checking information for the '-Wformat'
     option.  The default is to have no target-specific format checks.

 -- Macro: TARGET_N_FORMAT_TYPES
     If defined, this macro is the number of entries in
     'TARGET_FORMAT_TYPES'.

 -- Macro: TARGET_OVERRIDES_FORMAT_ATTRIBUTES
     If defined, this macro is the name of a global variable containing
     target-specific format overrides for the '-Wformat' option.  The
     default is to have no target-specific format overrides.  If
     defined, 'TARGET_FORMAT_TYPES' must be defined, too.

 -- Macro: TARGET_OVERRIDES_FORMAT_ATTRIBUTES_COUNT
     If defined, this macro specifies the number of entries in
     'TARGET_OVERRIDES_FORMAT_ATTRIBUTES'.

 -- Macro: TARGET_OVERRIDES_FORMAT_INIT
     If defined, this macro specifies the optional initialization
     routine for target specific customizations of the system printf and
     scanf formatter settings.

 -- Target Hook: const char * TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN
          (const_tree TYPELIST, const_tree FUNCDECL, const_tree VAL)
     If defined, this macro returns the diagnostic message when it is
     illegal to pass argument VAL to function FUNCDECL with prototype
     TYPELIST.

 -- Target Hook: const char * TARGET_INVALID_CONVERSION (const_tree
          FROMTYPE, const_tree TOTYPE)
     If defined, this macro returns the diagnostic message when it is
     invalid to convert from FROMTYPE to TOTYPE, or 'NULL' if validity
     should be determined by the front end.

 -- Target Hook: const char * TARGET_INVALID_UNARY_OP (int OP,
          const_tree TYPE)
     If defined, this macro returns the diagnostic message when it is
     invalid to apply operation OP (where unary plus is denoted by
     'CONVERT_EXPR') to an operand of type TYPE, or 'NULL' if validity
     should be determined by the front end.

 -- Target Hook: const char * TARGET_INVALID_BINARY_OP (int OP,
          const_tree TYPE1, const_tree TYPE2)
     If defined, this macro returns the diagnostic message when it is
     invalid to apply operation OP to operands of types TYPE1 and TYPE2,
     or 'NULL' if validity should be determined by the front end.

 -- Target Hook: tree TARGET_PROMOTED_TYPE (const_tree TYPE)
     If defined, this target hook returns the type to which values of
     TYPE should be promoted when they appear in expressions, analogous
     to the integer promotions, or 'NULL_TREE' to use the front end's
     normal promotion rules.  This hook is useful when there are
     target-specific types with special promotion rules.  This is
     currently used only by the C and C++ front ends.

 -- Target Hook: tree TARGET_CONVERT_TO_TYPE (tree TYPE, tree EXPR)
     If defined, this hook returns the result of converting EXPR to
     TYPE.  It should return the converted expression, or 'NULL_TREE' to
     apply the front end's normal conversion rules.  This hook is useful
     when there are target-specific types with special conversion rules.
     This is currently used only by the C and C++ front ends.

 -- Target Hook: bool TARGET_VERIFY_TYPE_CONTEXT (location_t LOC,
          type_context_kind CONTEXT, const_tree TYPE, bool SILENT_P)
     If defined, this hook returns false if there is a target-specific
     reason why type TYPE cannot be used in the source language context
     described by CONTEXT.  When SILENT_P is false, the hook also
     reports an error against LOC for invalid uses of TYPE.

     Calls to this hook should be made through the global function
     'verify_type_context', which makes the SILENT_P parameter default
     to false and also handles 'error_mark_node'.

     The default implementation always returns true.

 -- Macro: OBJC_JBLEN
     This macro determines the size of the objective C jump buffer for
     the NeXT runtime.  By default, OBJC_JBLEN is defined to an
     innocuous value.

 -- Macro: LIBGCC2_UNWIND_ATTRIBUTE
     Define this macro if any target-specific attributes need to be
     attached to the functions in 'libgcc' that provide low-level
     support for call stack unwinding.  It is used in declarations in
     'unwind-generic.h' and the associated definitions of those
     functions.

 -- Target Hook: void TARGET_UPDATE_STACK_BOUNDARY (void)
     Define this macro to update the current function stack boundary if
     necessary.

 -- Target Hook: rtx TARGET_GET_DRAP_RTX (void)
     This hook should return an rtx for Dynamic Realign Argument Pointer
     (DRAP) if a different argument pointer register is needed to access
     the function's argument list due to stack realignment.  Return
     'NULL' if no DRAP is needed.

 -- Target Hook: bool TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS (void)
     When optimization is disabled, this hook indicates whether or not
     arguments should be allocated to stack slots.  Normally, GCC
     allocates stacks slots for arguments when not optimizing in order
     to make debugging easier.  However, when a function is declared
     with '__attribute__((naked))', there is no stack frame, and the
     compiler cannot safely move arguments from the registers in which
     they are passed to the stack.  Therefore, this hook should return
     true in general, but false for naked functions.  The default
     implementation always returns true.

 -- Target Hook: unsigned HOST_WIDE_INT TARGET_CONST_ANCHOR
     On some architectures it can take multiple instructions to
     synthesize a constant.  If there is another constant already in a
     register that is close enough in value then it is preferable that
     the new constant is computed from this register using immediate
     addition or subtraction.  We accomplish this through CSE. Besides
     the value of the constant we also add a lower and an upper constant
     anchor to the available expressions.  These are then queried when
     encountering new constants.  The anchors are computed by rounding
     the constant up and down to a multiple of the value of
     'TARGET_CONST_ANCHOR'.  'TARGET_CONST_ANCHOR' should be the maximum
     positive value accepted by immediate-add plus one.  We currently
     assume that the value of 'TARGET_CONST_ANCHOR' is a power of 2.
     For example, on MIPS, where add-immediate takes a 16-bit signed
     value, 'TARGET_CONST_ANCHOR' is set to '0x8000'.  The default value
     is zero, which disables this optimization.

 -- Target Hook: unsigned HOST_WIDE_INT TARGET_ASAN_SHADOW_OFFSET (void)
     Return the offset bitwise ored into shifted address to get
     corresponding Address Sanitizer shadow memory address.  NULL if
     Address Sanitizer is not supported by the target.

 -- Target Hook: unsigned HOST_WIDE_INT TARGET_MEMMODEL_CHECK (unsigned
          HOST_WIDE_INT VAL)
     Validate target specific memory model mask bits.  When NULL no
     target specific memory model bits are allowed.

 -- Target Hook: unsigned char TARGET_ATOMIC_TEST_AND_SET_TRUEVAL
     This value should be set if the result written by
     'atomic_test_and_set' is not exactly 1, i.e. the 'bool' 'true'.

 -- Target Hook: bool TARGET_HAS_IFUNC_P (void)
     It returns true if the target supports GNU indirect functions.  The
     support includes the assembler, linker and dynamic linker.  The
     default value of this hook is based on target's libc.

 -- Target Hook: unsigned int TARGET_ATOMIC_ALIGN_FOR_MODE (machine_mode
          MODE)
     If defined, this function returns an appropriate alignment in bits
     for an atomic object of machine_mode MODE.  If 0 is returned then
     the default alignment for the specified mode is used.

 -- Target Hook: void TARGET_ATOMIC_ASSIGN_EXPAND_FENV (tree *HOLD, tree
          *CLEAR, tree *UPDATE)
     ISO C11 requires atomic compound assignments that may raise
     floating-point exceptions to raise exceptions corresponding to the
     arithmetic operation whose result was successfully stored in a
     compare-and-exchange sequence.  This requires code equivalent to
     calls to 'feholdexcept', 'feclearexcept' and 'feupdateenv' to be
     generated at appropriate points in the compare-and-exchange
     sequence.  This hook should set '*HOLD' to an expression equivalent
     to the call to 'feholdexcept', '*CLEAR' to an expression equivalent
     to the call to 'feclearexcept' and '*UPDATE' to an expression
     equivalent to the call to 'feupdateenv'.  The three expressions are
     'NULL_TREE' on entry to the hook and may be left as 'NULL_TREE' if
     no code is required in a particular place.  The default
     implementation leaves all three expressions as 'NULL_TREE'.  The
     '__atomic_feraiseexcept' function from 'libatomic' may be of use as
     part of the code generated in '*UPDATE'.

 -- Target Hook: void TARGET_RECORD_OFFLOAD_SYMBOL (tree)
     Used when offloaded functions are seen in the compilation unit and
     no named sections are available.  It is called once for each symbol
     that must be recorded in the offload function and variable table.

 -- Target Hook: char * TARGET_OFFLOAD_OPTIONS (void)
     Used when writing out the list of options into an LTO file.  It
     should translate any relevant target-specific options (such as the
     ABI in use) into one of the '-foffload' options that exist as a
     common interface to express such options.  It should return a
     string containing these options, separated by spaces, which the
     caller will free.

 -- Macro: TARGET_SUPPORTS_WIDE_INT

     On older ports, large integers are stored in 'CONST_DOUBLE' rtl
     objects.  Newer ports define 'TARGET_SUPPORTS_WIDE_INT' to be
     nonzero to indicate that large integers are stored in
     'CONST_WIDE_INT' rtl objects.  The 'CONST_WIDE_INT' allows very
     large integer constants to be represented.  'CONST_DOUBLE' is
     limited to twice the size of the host's 'HOST_WIDE_INT'
     representation.

     Converting a port mostly requires looking for the places where
     'CONST_DOUBLE's are used with 'VOIDmode' and replacing that code
     with code that accesses 'CONST_WIDE_INT's.  '"grep -i
     const_double"' at the port level gets you to 95% of the changes
     that need to be made.  There are a few places that require a deeper
     look.

        * There is no equivalent to 'hval' and 'lval' for
          'CONST_WIDE_INT's.  This would be difficult to express in the
          md language since there are a variable number of elements.

          Most ports only check that 'hval' is either 0 or -1 to see if
          the value is small.  As mentioned above, this will no longer
          be necessary since small constants are always 'CONST_INT'.  Of
          course there are still a few exceptions, the alpha's
          constraint used by the zap instruction certainly requires
          careful examination by C code.  However, all the current code
          does is pass the hval and lval to C code, so evolving the c
          code to look at the 'CONST_WIDE_INT' is not really a large
          change.

        * Because there is no standard template that ports use to
          materialize constants, there is likely to be some futzing that
          is unique to each port in this code.

        * The rtx costs may have to be adjusted to properly account for
          larger constants that are represented as 'CONST_WIDE_INT'.

     All and all it does not take long to convert ports that the
     maintainer is familiar with.

 -- Target Hook: bool TARGET_HAVE_SPECULATION_SAFE_VALUE (bool ACTIVE)
     This hook is used to determine the level of target support for
     '__builtin_speculation_safe_value'.  If called with an argument of
     false, it returns true if the target has been modified to support
     this builtin.  If called with an argument of true, it returns true
     if the target requires active mitigation execution might be
     speculative.

     The default implementation returns false if the target does not
     define a pattern named 'speculation_barrier'.  Else it returns true
     for the first case and whether the pattern is enabled for the
     current compilation for the second case.

     For targets that have no processors that can execute instructions
     speculatively an alternative implemenation of this hook is
     available: simply redefine this hook to
     'speculation_safe_value_not_needed' along with your other target
     hooks.

 -- Target Hook: rtx TARGET_SPECULATION_SAFE_VALUE (machine_mode MODE,
          rtx RESULT, rtx VAL, rtx FAILVAL)
     This target hook can be used to generate a target-specific code
     sequence that implements the '__builtin_speculation_safe_value'
     built-in function.  The function must always return VAL in RESULT
     in mode MODE when the cpu is not executing speculatively, but must
     never return that when speculating until it is known that the
     speculation will not be unwound.  The hook supports two primary
     mechanisms for implementing the requirements.  The first is to emit
     a speculation barrier which forces the processor to wait until all
     prior speculative operations have been resolved; the second is to
     use a target-specific mechanism that can track the speculation
     state and to return FAILVAL if it can determine that speculation
     must be unwound at a later time.

     The default implementation simply copies VAL to RESULT and emits a
     'speculation_barrier' instruction if that is defined.

 -- Target Hook: void TARGET_RUN_TARGET_SELFTESTS (void)
     If selftests are enabled, run any selftests for this target.

==============================================================================
File: gccint.info,  Node: |Host_Config|,  Next: |Fragments|,  Prev: |Target_Macros|,  Up: |Top|
==============================================================================

                                                                   *Host_Config*

19 Host Configuration
*****================

Most details about the machine and system on which the compiler is
actually running are detected by the 'configure' script.  Some things
are impossible for 'configure' to detect; these are described in two
ways, either by macros defined in a file named 'xm-MACHINE.h' or by hook
functions in the file specified by the OUT_HOST_HOOK_OBJ variable in
'config.gcc'.  (The intention is that very few hosts will need a header
file but nearly every fully supported host will need to override some
hooks.)

 If you need to define only a few macros, and they have simple
definitions, consider using the 'xm_defines' variable in your
'config.gcc' entry instead of creating a host configuration header.
*Note System Config::.

MENU

* |Host_Common|::         Things every host probably needs implemented.
* |Filesystem|::          Your host cannot have the letter 'a' in filenames?
* |Host_Misc|::           Rare configuration options for hosts.

==============================================================================
File: gccint.info,  Node: |Host_Common|,  Next: |Filesystem|,  Up: |Host_Config|
==============================================================================

                                                                   *Host_Common*

19.1 Host Common
=====-----------

Some things are just not portable, even between similar operating
systems, and are too difficult for autoconf to detect.  They get
implemented using hook functions in the file specified by the
HOST_HOOK_OBJ variable in 'config.gcc'.

 -- Host Hook: void HOST_HOOKS_EXTRA_SIGNALS (void)
     This host hook is used to set up handling for extra signals.  The
     most common thing to do in this hook is to detect stack overflow.

 -- Host Hook: void * HOST_HOOKS_GT_PCH_GET_ADDRESS (size_t SIZE, int
          FD)
     This host hook returns the address of some space that is likely to
     be free in some subsequent invocation of the compiler.  We intend
     to load the PCH data at this address such that the data need not be
     relocated.  The area should be able to hold SIZE bytes.  If the
     host uses 'mmap', FD is an open file descriptor that can be used
     for probing.

 -- Host Hook: int HOST_HOOKS_GT_PCH_USE_ADDRESS (void * ADDRESS, size_t
          SIZE, int FD, size_t OFFSET)
     This host hook is called when a PCH file is about to be loaded.  We
     want to load SIZE bytes from FD at OFFSET into memory at ADDRESS.
     The given address will be the result of a previous invocation of
     'HOST_HOOKS_GT_PCH_GET_ADDRESS'.  Return -1 if we couldn't allocate
     SIZE bytes at ADDRESS.  Return 0 if the memory is allocated but the
     data is not loaded.  Return 1 if the hook has performed everything.

     If the implementation uses reserved address space, free any
     reserved space beyond SIZE, regardless of the return value.  If no
     PCH will be loaded, this hook may be called with SIZE zero, in
     which case all reserved address space should be freed.

     Do not try to handle values of ADDRESS that could not have been
     returned by this executable; just return -1.  Such values usually
     indicate an out-of-date PCH file (built by some other GCC
     executable), and such a PCH file won't work.

 -- Host Hook: size_t HOST_HOOKS_GT_PCH_ALLOC_GRANULARITY (void);
     This host hook returns the alignment required for allocating
     virtual memory.  Usually this is the same as getpagesize, but on
     some hosts the alignment for reserving memory differs from the
     pagesize for committing memory.

==============================================================================
File: gccint.info,  Node: |Filesystem|,  Next: |Host_Misc|,  Prev: |Host_Common|,  Up: |Host_Config|
==============================================================================

                                                                    *Filesystem*

19.2 Host Filesystem
=====---------------

GCC needs to know a number of things about the semantics of the host
machine's filesystem.  Filesystems with Unix and MS-DOS semantics are
automatically detected.  For other systems, you can define the following
macros in 'xm-MACHINE.h'.

'HAVE_DOS_BASED_FILE_SYSTEM'
     This macro is automatically defined by 'system.h' if the host file
     system obeys the semantics defined by MS-DOS instead of Unix.  DOS
     file systems are case insensitive, file specifications may begin
     with a drive letter, and both forward slash and backslash ('/' and
     '\') are directory separators.

'DIR_SEPARATOR'
'DIR_SEPARATOR_2'
     If defined, these macros expand to character constants specifying
     separators for directory names within a file specification.
     'system.h' will automatically give them appropriate values on Unix
     and MS-DOS file systems.  If your file system is neither of these,
     define one or both appropriately in 'xm-MACHINE.h'.

     However, operating systems like VMS, where constructing a pathname
     is more complicated than just stringing together directory names
     separated by a special character, should not define either of these
     macros.

'PATH_SEPARATOR'
     If defined, this macro should expand to a character constant
     specifying the separator for elements of search paths.  The default
     value is a colon (':').  DOS-based systems usually, but not always,
     use semicolon (';').

'VMS'
     Define this macro if the host system is VMS.

'HOST_OBJECT_SUFFIX'
     Define this macro to be a C string representing the suffix for
     object files on your host machine.  If you do not define this
     macro, GCC will use '.o' as the suffix for object files.

'HOST_EXECUTABLE_SUFFIX'
     Define this macro to be a C string representing the suffix for
     executable files on your host machine.  If you do not define this
     macro, GCC will use the null string as the suffix for executable
     files.

'HOST_BIT_BUCKET'
     A pathname defined by the host operating system, which can be
     opened as a file and written to, but all the information written is
     discarded.  This is commonly known as a "bit bucket" or "null
     device".  If you do not define this macro, GCC will use '/dev/null'
     as the bit bucket.  If the host does not support a bit bucket,
     define this macro to an invalid filename.

'UPDATE_PATH_HOST_CANONICALIZE (PATH)'
     If defined, a C statement (sans semicolon) that performs
     host-dependent canonicalization when a path used in a compilation
     driver or preprocessor is canonicalized.  PATH is a malloc-ed path
     to be canonicalized.  If the C statement does canonicalize PATH
     into a different buffer, the old path should be freed and the new
     buffer should have been allocated with malloc.

'DUMPFILE_FORMAT'
     Define this macro to be a C string representing the format to use
     for constructing the index part of debugging dump file names.  The
     resultant string must fit in fifteen bytes.  The full filename will
     be the concatenation of: the prefix of the assembler file name, the
     string resulting from applying this format to an index number, and
     a string unique to each dump file kind, e.g. 'rtl'.

     If you do not define this macro, GCC will use '.%02d.'.  You should
     define this macro if using the default will create an invalid file
     name.

'DELETE_IF_ORDINARY'
     Define this macro to be a C statement (sans semicolon) that
     performs host-dependent removal of ordinary temp files in the
     compilation driver.

     If you do not define this macro, GCC will use the default version.
     You should define this macro if the default version does not
     reliably remove the temp file as, for example, on VMS which allows
     multiple versions of a file.

'HOST_LACKS_INODE_NUMBERS'
     Define this macro if the host filesystem does not report meaningful
     inode numbers in struct stat.

==============================================================================
File: gccint.info,  Node: |Host_Misc|,  Prev: |Filesystem|,  Up: |Host_Config|
==============================================================================

                                                                     *Host_Misc*

19.3 Host Misc
=====---------

'FATAL_EXIT_CODE'
     A C expression for the status code to be returned when the compiler
     exits after serious errors.  The default is the system-provided
     macro 'EXIT_FAILURE', or '1' if the system doesn't define that
     macro.  Define this macro only if these defaults are incorrect.

'SUCCESS_EXIT_CODE'
     A C expression for the status code to be returned when the compiler
     exits without serious errors.  (Warnings are not serious errors.)
     The default is the system-provided macro 'EXIT_SUCCESS', or '0' if
     the system doesn't define that macro.  Define this macro only if
     these defaults are incorrect.

'USE_C_ALLOCA'
     Define this macro if GCC should use the C implementation of
     'alloca' provided by 'libiberty.a'.  This only affects how some
     parts of the compiler itself allocate memory.  It does not change
     code generation.

     When GCC is built with a compiler other than itself, the C 'alloca'
     is always used.  This is because most other implementations have
     serious bugs.  You should define this macro only on a system where
     no stack-based 'alloca' can possibly work.  For instance, if a
     system has a small limit on the size of the stack, GCC's builtin
     'alloca' will not work reliably.

'COLLECT2_HOST_INITIALIZATION'
     If defined, a C statement (sans semicolon) that performs
     host-dependent initialization when 'collect2' is being initialized.

'GCC_DRIVER_HOST_INITIALIZATION'
     If defined, a C statement (sans semicolon) that performs
     host-dependent initialization when a compilation driver is being
     initialized.

'HOST_LONG_LONG_FORMAT'
     If defined, the string used to indicate an argument of type 'long
     long' to functions like 'printf'.  The default value is '"ll"'.

'HOST_LONG_FORMAT'
     If defined, the string used to indicate an argument of type 'long'
     to functions like 'printf'.  The default value is '"l"'.

'HOST_PTR_PRINTF'
     If defined, the string used to indicate an argument of type 'void
     *' to functions like 'printf'.  The default value is '"%p"'.

 In addition, if 'configure' generates an incorrect definition of any of
the macros in 'auto-host.h', you can override that definition in a host
configuration header.  If you need to do this, first see if it is
possible to fix 'configure'.

==============================================================================
File: gccint.info,  Node: |Fragments|,  Next: |Collect2|,  Prev: |Host_Config|,  Up: |Top|
==============================================================================

                                                                     *Fragments*

20 Makefile Fragments
*****================

When you configure GCC using the 'configure' script, it will construct
the file 'Makefile' from the template file 'Makefile.in'.  When it does
this, it can incorporate makefile fragments from the 'config' directory.
These are used to set Makefile parameters that are not amenable to being
calculated by autoconf.  The list of fragments to incorporate is set by
'config.gcc' (and occasionally 'config.build' and 'config.host'); *Note
System Config::.

 Fragments are named either 't-TARGET' or 'x-HOST', depending on whether
they are relevant to configuring GCC to produce code for a particular
target, or to configuring GCC to run on a particular host.  Here TARGET
and HOST are mnemonics which usually have some relationship to the
canonical system name, but no formal connection.

 If these files do not exist, it means nothing needs to be added for a
given target or host.  Most targets need a few 't-TARGET' fragments, but
needing 'x-HOST' fragments is rare.

MENU

* |Target_Fragment|:: Writing 't-TARGET' files.
* |Host_Fragment|::   Writing 'x-HOST' files.

==============================================================================
File: gccint.info,  Node: |Target_Fragment|,  Next: |Host_Fragment|,  Up: |Fragments|
==============================================================================

                                                               *Target_Fragment*

20.1 Target Makefile Fragments
=====-------------------------

Target makefile fragments can set these Makefile variables.

'LIBGCC2_CFLAGS'
     Compiler flags to use when compiling 'libgcc2.c'.

'LIB2FUNCS_EXTRA'
     A list of source file names to be compiled or assembled and
     inserted into 'libgcc.a'.

'CRTSTUFF_T_CFLAGS'
     Special flags used when compiling 'crtstuff.c'.  *Note
     Initialization::.

'CRTSTUFF_T_CFLAGS_S'
     Special flags used when compiling 'crtstuff.c' for shared linking.
     Used if you use 'crtbeginS.o' and 'crtendS.o' in 'EXTRA-PARTS'.
     *Note Initialization::.

'MULTILIB_OPTIONS'
     For some targets, invoking GCC in different ways produces objects
     that cannot be linked together.  For example, for some targets GCC
     produces both big and little endian code.  For these targets, you
     must arrange for multiple versions of 'libgcc.a' to be compiled,
     one for each set of incompatible options.  When GCC invokes the
     linker, it arranges to link in the right version of 'libgcc.a',
     based on the command line options used.

     The 'MULTILIB_OPTIONS' macro lists the set of options for which
     special versions of 'libgcc.a' must be built.  Write options that
     are mutually incompatible side by side, separated by a slash.
     Write options that may be used together separated by a space.  The
     build procedure will build all combinations of compatible options.

     For example, if you set 'MULTILIB_OPTIONS' to 'm68000/m68020
     msoft-float', 'Makefile' will build special versions of 'libgcc.a'
     using the following sets of options: '-m68000', '-m68020',
     '-msoft-float', '-m68000 -msoft-float', and '-m68020 -msoft-float'.

'MULTILIB_DIRNAMES'
     If 'MULTILIB_OPTIONS' is used, this variable specifies the
     directory names that should be used to hold the various libraries.
     Write one element in 'MULTILIB_DIRNAMES' for each element in
     'MULTILIB_OPTIONS'.  If 'MULTILIB_DIRNAMES' is not used, the
     default value will be 'MULTILIB_OPTIONS', with all slashes treated
     as spaces.

     'MULTILIB_DIRNAMES' describes the multilib directories using GCC
     conventions and is applied to directories that are part of the GCC
     installation.  When multilib-enabled, the compiler will add a
     subdirectory of the form PREFIX/MULTILIB before each directory in
     the search path for libraries and crt files.

     For example, if 'MULTILIB_OPTIONS' is set to 'm68000/m68020
     msoft-float', then the default value of 'MULTILIB_DIRNAMES' is
     'm68000 m68020 msoft-float'.  You may specify a different value if
     you desire a different set of directory names.

'MULTILIB_MATCHES'
     Sometimes the same option may be written in two different ways.  If
     an option is listed in 'MULTILIB_OPTIONS', GCC needs to know about
     any synonyms.  In that case, set 'MULTILIB_MATCHES' to a list of
     items of the form 'option=option' to describe all relevant
     synonyms.  For example, 'm68000=mc68000 m68020=mc68020'.

'MULTILIB_EXCEPTIONS'
     Sometimes when there are multiple sets of 'MULTILIB_OPTIONS' being
     specified, there are combinations that should not be built.  In
     that case, set 'MULTILIB_EXCEPTIONS' to be all of the switch
     exceptions in shell case syntax that should not be built.

     For example the ARM processor cannot execute both hardware floating
     point instructions and the reduced size THUMB instructions at the
     same time, so there is no need to build libraries with both of
     these options enabled.  Therefore 'MULTILIB_EXCEPTIONS' is set to:
          mthumb/mhard-float*

'MULTILIB_REQUIRED'
     Sometimes when there are only a few combinations are required, it
     would be a big effort to come up with a 'MULTILIB_EXCEPTIONS' list
     to cover all undesired ones.  In such a case, just listing all the
     required combinations in 'MULTILIB_REQUIRED' would be more
     straightforward.

     The way to specify the entries in 'MULTILIB_REQUIRED' is same with
     the way used for 'MULTILIB_EXCEPTIONS', only this time what are
     required will be specified.  Suppose there are multiple sets of
     'MULTILIB_OPTIONS' and only two combinations are required, one for
     ARMv7-M and one for ARMv7-R with hard floating-point ABI and FPU,
     the 'MULTILIB_REQUIRED' can be set to:
          MULTILIB_REQUIRED =  mthumb/march=armv7-m
          MULTILIB_REQUIRED += march=armv7-r/mfloat-abi=hard/mfpu=vfpv3-d16

     The 'MULTILIB_REQUIRED' can be used together with
     'MULTILIB_EXCEPTIONS'.  The option combinations generated from
     'MULTILIB_OPTIONS' will be filtered by 'MULTILIB_EXCEPTIONS' and
     then by 'MULTILIB_REQUIRED'.

'MULTILIB_REUSE'
     Sometimes it is desirable to reuse one existing multilib for
     different sets of options.  Such kind of reuse can minimize the
     number of multilib variants.  And for some targets it is better to
     reuse an existing multilib than to fall back to default multilib
     when there is no corresponding multilib.  This can be done by
     adding reuse rules to 'MULTILIB_REUSE'.

     A reuse rule is comprised of two parts connected by equality sign.
     The left part is the option set used to build multilib and the
     right part is the option set that will reuse this multilib.  Both
     parts should only use options specified in 'MULTILIB_OPTIONS' and
     the equality signs found in options name should be replaced with
     periods.  An explicit period in the rule can be escaped by
     preceding it with a backslash.  The order of options in the left
     part matters and should be same with those specified in
     'MULTILIB_REQUIRED' or aligned with the order in
     'MULTILIB_OPTIONS'.  There is no such limitation for options in the
     right part as we don't build multilib from them.

     'MULTILIB_REUSE' is different from 'MULTILIB_MATCHES' in that it
     sets up relations between two option sets rather than two options.
     Here is an example to demo how we reuse libraries built in Thumb
     mode for applications built in ARM mode:
          MULTILIB_REUSE = mthumb/march.armv7-r=marm/march.armv7-r

     Before the advent of 'MULTILIB_REUSE', GCC select multilib by
     comparing command line options with options used to build multilib.
     The 'MULTILIB_REUSE' is complementary to that way.  Only when the
     original comparison matches nothing it will work to see if it is OK
     to reuse some existing multilib.

'MULTILIB_EXTRA_OPTS'
     Sometimes it is desirable that when building multiple versions of
     'libgcc.a' certain options should always be passed on to the
     compiler.  In that case, set 'MULTILIB_EXTRA_OPTS' to be the list
     of options to be used for all builds.  If you set this, you should
     probably set 'CRTSTUFF_T_CFLAGS' to a dash followed by it.

'MULTILIB_OSDIRNAMES'
     If 'MULTILIB_OPTIONS' is used, this variable specifies a list of
     subdirectory names, that are used to modify the search path
     depending on the chosen multilib.  Unlike 'MULTILIB_DIRNAMES',
     'MULTILIB_OSDIRNAMES' describes the multilib directories using
     operating systems conventions, and is applied to the directories
     such as 'lib' or those in the 'LIBRARY_PATH' environment variable.
     The format is either the same as of 'MULTILIB_DIRNAMES', or a set
     of mappings.  When it is the same as 'MULTILIB_DIRNAMES', it
     describes the multilib directories using operating system
     conventions, rather than GCC conventions.  When it is a set of
     mappings of the form GCCDIR=OSDIR, the left side gives the GCC
     convention and the right gives the equivalent OS defined location.
     If the OSDIR part begins with a '!', GCC will not search in the
     non-multilib directory and use exclusively the multilib directory.
     Otherwise, the compiler will examine the search path for libraries
     and crt files twice; the first time it will add MULTILIB to each
     directory in the search path, the second it will not.

     For configurations that support both multilib and multiarch,
     'MULTILIB_OSDIRNAMES' also encodes the multiarch name, thus
     subsuming 'MULTIARCH_DIRNAME'.  The multiarch name is appended to
     each directory name, separated by a colon (e.g.
     '../lib32:i386-linux-gnu').

     Each multiarch subdirectory will be searched before the
     corresponding OS multilib directory, for example
     '/lib/i386-linux-gnu' before '/lib/../lib32'.  The multiarch name
     will also be used to modify the system header search path, as
     explained for 'MULTIARCH_DIRNAME'.

'MULTIARCH_DIRNAME'
     This variable specifies the multiarch name for configurations that
     are multiarch-enabled but not multilibbed configurations.

     The multiarch name is used to augment the search path for
     libraries, crt files and system header files with additional
     locations.  The compiler will add a multiarch subdirectory of the
     form PREFIX/MULTIARCH before each directory in the library and crt
     search path.  It will also add two directories
     'LOCAL_INCLUDE_DIR'/MULTIARCH and
     'NATIVE_SYSTEM_HEADER_DIR'/MULTIARCH) to the system header search
     path, respectively before 'LOCAL_INCLUDE_DIR' and
     'NATIVE_SYSTEM_HEADER_DIR'.

     'MULTIARCH_DIRNAME' is not used for configurations that support
     both multilib and multiarch.  In that case, multiarch names are
     encoded in 'MULTILIB_OSDIRNAMES' instead.

     More documentation about multiarch can be found at
     <https://wiki.debian.org/Multiarch>.

'SPECS'
     Unfortunately, setting 'MULTILIB_EXTRA_OPTS' is not enough, since
     it does not affect the build of target libraries, at least not the
     build of the default multilib.  One possible work-around is to use
     'DRIVER_SELF_SPECS' to bring options from the 'specs' file as if
     they had been passed in the compiler driver command line.  However,
     you don't want to be adding these options after the toolchain is
     installed, so you can instead tweak the 'specs' file that will be
     used during the toolchain build, while you still install the
     original, built-in 'specs'.  The trick is to set 'SPECS' to some
     other filename (say 'specs.install'), that will then be created out
     of the built-in specs, and introduce a 'Makefile' rule to generate
     the 'specs' file that's going to be used at build time out of your
     'specs.install'.

'T_CFLAGS'
     These are extra flags to pass to the C compiler.  They are used
     both when building GCC, and when compiling things with the
     just-built GCC.  This variable is deprecated and should not be
     used.

==============================================================================
File: gccint.info,  Node: |Host_Fragment|,  Prev: |Target_Fragment|,  Up: |Fragments|
==============================================================================

                                                                 *Host_Fragment*

20.2 Host Makefile Fragments
=====-----------------------

The use of 'x-HOST' fragments is discouraged.  You should only use it
for makefile dependencies.

==============================================================================
File: gccint.info,  Node: |Collect2|,  Next: |Header_Dirs|,  Prev: |Fragments|,  Up: |Top|
==============================================================================

                                                                      *Collect2*

21 'collect2'
*****========

GCC uses a utility called 'collect2' on nearly all systems to arrange to
call various initialization functions at start time.

 The program 'collect2' works by linking the program once and looking
through the linker output file for symbols with particular names
indicating they are constructor functions.  If it finds any, it creates
a new temporary '.c' file containing a table of them, compiles it, and
links the program a second time including that file.

 The actual calls to the constructors are carried out by a subroutine
called '__main', which is called (automatically) at the beginning of the
body of 'main' (provided 'main' was compiled with GNU CC).  Calling
'__main' is necessary, even when compiling C code, to allow linking C
and C++ object code together.  (If you use '-nostdlib', you get an
unresolved reference to '__main', since it's defined in the standard GCC
library.  Include '-lgcc' at the end of your compiler command line to
resolve this reference.)

 The program 'collect2' is installed as 'ld' in the directory where the
passes of the compiler are installed.  When 'collect2' needs to find the
_real_ 'ld', it tries the following file names:

   * a hard coded linker file name, if GCC was configured with the
     '--with-ld' option.

   * 'real-ld' in the directories listed in the compiler's search
     directories.

   * 'real-ld' in the directories listed in the environment variable
     'PATH'.

   * The file specified in the 'REAL_LD_FILE_NAME' configuration macro,
     if specified.

   * 'ld' in the compiler's search directories, except that 'collect2'
     will not execute itself recursively.

   * 'ld' in 'PATH'.

 "The compiler's search directories" means all the directories where
'gcc' searches for passes of the compiler.  This includes directories
that you specify with '-B'.

 Cross-compilers search a little differently:

   * 'real-ld' in the compiler's search directories.

   * 'TARGET-real-ld' in 'PATH'.

   * The file specified in the 'REAL_LD_FILE_NAME' configuration macro,
     if specified.

   * 'ld' in the compiler's search directories.

   * 'TARGET-ld' in 'PATH'.

 'collect2' explicitly avoids running 'ld' using the file name under
which 'collect2' itself was invoked.  In fact, it remembers up a list of
such names--in case one copy of 'collect2' finds another copy (or
version) of 'collect2' installed as 'ld' in a second place in the search
path.

 'collect2' searches for the utilities 'nm' and 'strip' using the same
algorithm as above for 'ld'.

==============================================================================
File: gccint.info,  Node: |Header_Dirs|,  Next: |Type_Information|,  Prev: |Collect2|,  Up: |Top|
==============================================================================

                                                                   *Header_Dirs*

22 Standard Header File Directories
*****==============================

'GCC_INCLUDE_DIR' means the same thing for native and cross.  It is
where GCC stores its private include files, and also where GCC stores
the fixed include files.  A cross compiled GCC runs 'fixincludes' on the
header files in '$(tooldir)/include'.  (If the cross compilation header
files need to be fixed, they must be installed before GCC is built.  If
the cross compilation header files are already suitable for GCC, nothing
special need be done).

 'GPLUSPLUS_INCLUDE_DIR' means the same thing for native and cross.  It
is where 'g++' looks first for header files.  The C++ library installs
only target independent header files in that directory.

 'LOCAL_INCLUDE_DIR' is used only by native compilers.  GCC doesn't
install anything there.  It is normally '/usr/local/include'.  This is
where local additions to a packaged system should place header files.

 'CROSS_INCLUDE_DIR' is used only by cross compilers.  GCC doesn't
install anything there.

 'TOOL_INCLUDE_DIR' is used for both native and cross compilers.  It is
the place for other packages to install header files that GCC will use.
For a cross-compiler, this is the equivalent of '/usr/include'.  When
you build a cross-compiler, 'fixincludes' processes any header files in
this directory.

==============================================================================
File: gccint.info,  Node: |Type_Information|,  Next: |Plugins|,  Prev: |Header_Dirs|,  Up: |Top|
==============================================================================

                                                              *Type_Information*

23 Memory Management and Type Information
*****====================================

GCC uses some fairly sophisticated memory management techniques, which
involve determining information about GCC's data structures from GCC's
source code and using this information to perform garbage collection and
implement precompiled headers.

 A full C++ parser would be too complicated for this task, so a limited
subset of C++ is interpreted and special markers are used to determine
what parts of the source to look at.  All 'struct', 'union' and
'template' structure declarations that define data structures that are
allocated under control of the garbage collector must be marked.  All
global variables that hold pointers to garbage-collected memory must
also be marked.  Finally, all global variables that need to be saved and
restored by a precompiled header must be marked.  (The precompiled
header mechanism can only save static variables if they're scalar.
Complex data structures must be allocated in garbage-collected memory to
be saved in a precompiled header.)

 The full format of a marker is
     GTY (([OPTION] [(PARAM)], [OPTION] [(PARAM)] ...))
but in most cases no options are needed.  The outer double parentheses
are still necessary, though: 'GTY(())'.  Markers can appear:

   * In a structure definition, before the open brace;
   * In a global variable declaration, after the keyword 'static' or
     'extern'; and
   * In a structure field definition, before the name of the field.

 Here are some examples of marking simple data structures and globals.

     struct GTY(()) TAG
     {
       FIELDS...
     };

     typedef struct GTY(()) TAG
     {
       FIELDS...
     } *TYPENAME;

     static GTY(()) struct TAG *LIST;   /* points to GC memory */
     static GTY(()) int COUNTER;        /* save counter in a PCH */

 The parser understands simple typedefs such as 'typedef struct TAG
*NAME;' and 'typedef int NAME;'.  These don't need to be marked.

 Since 'gengtype''s understanding of C++ is limited, there are several
constructs and declarations that are not supported inside
classes/structures marked for automatic GC code generation.  The
following C++ constructs produce a 'gengtype' error on
structures/classes marked for automatic GC code generation:

   * Type definitions inside classes/structures are not supported.
   * Enumerations inside classes/structures are not supported.

 If you have a class or structure using any of the above constructs, you
need to mark that class as 'GTY ((user))' and provide your own marking
routines (see section *note User GC:: for details).

 It is always valid to include function definitions inside classes.
Those are always ignored by 'gengtype', as it only cares about data
members.

MENU

* |GTY_Options|::         What goes inside a 'GTY(())'.
* |Inheritance_and_GTY|:: Adding GTY to a class hierarchy.
* |User_GC|::		Adding user-provided GC marking routines.
* |GGC_Roots|::           Making global variables GGC roots.
* |Files|::               How the generated files work.
* |Invoking_the_garbage_collector|::   How to invoke the garbage collector.
* |Troubleshooting|::     When something does not work as expected.

==============================================================================
File: gccint.info,  Node: |GTY_Options|,  Next: |Inheritance_and_GTY|,  Up: |Type_Information|
==============================================================================

                                                                   *GTY_Options*

23.1 The Inside of a 'GTY(())'
=====-------------------------

Sometimes the C code is not enough to fully describe the type structure.
Extra information can be provided with 'GTY' options and additional
markers.  Some options take a parameter, which may be either a string or
a type name, depending on the parameter.  If an option takes no
parameter, it is acceptable either to omit the parameter entirely, or to
provide an empty string as a parameter.  For example, 'GTY ((skip))' and
'GTY ((skip ("")))' are equivalent.

 When the parameter is a string, often it is a fragment of C code.  Four
special escapes may be used in these strings, to refer to pieces of the
data structure being marked:

'%h'
     The current structure.
'%1'
     The structure that immediately contains the current structure.
'%0'
     The outermost structure that contains the current structure.
'%a'
     A partial expression of the form '[i1][i2]...' that indexes the
     array item currently being marked.

 For instance, suppose that you have a structure of the form
     struct A {
       ...
     };
     struct B {
       struct A foo[12];
     };
and 'b' is a variable of type 'struct B'.  When marking 'b.foo[11]',
'%h' would expand to 'b.foo[11]', '%0' and '%1' would both expand to
'b', and '%a' would expand to '[11]'.

 As in ordinary C, adjacent strings will be concatenated; this is
helpful when you have a complicated expression.
     GTY ((chain_next ("TREE_CODE (&%h.generic) == INTEGER_TYPE"
                       " ? TYPE_NEXT_VARIANT (&%h.generic)"
                       " : TREE_CHAIN (&%h.generic)")))

 The available options are:

'length ("EXPRESSION")'

     There are two places the type machinery will need to be explicitly
     told the length of an array of non-atomic objects.  The first case
     is when a structure ends in a variable-length array, like this:
          struct GTY(()) rtvec_def {
            int num_elem;         /* number of elements */
            rtx GTY ((length ("%h.num_elem"))) elem[1];
          };

     In this case, the 'length' option is used to override the specified
     array length (which should usually be '1').  The parameter of the
     option is a fragment of C code that calculates the length.

     The second case is when a structure or a global variable contains a
     pointer to an array, like this:
          struct gimple_omp_for_iter * GTY((length ("%h.collapse"))) iter;
     In this case, 'iter' has been allocated by writing something like
            x->iter = ggc_alloc_cleared_vec_gimple_omp_for_iter (collapse);
     and the 'collapse' provides the length of the field.

     This second use of 'length' also works on global variables, like:
     static GTY((length("reg_known_value_size"))) rtx *reg_known_value;

     Note that the 'length' option is only meant for use with arrays of
     non-atomic objects, that is, objects that contain pointers pointing
     to other GTY-managed objects.  For other GC-allocated arrays and
     strings you should use 'atomic'.

'skip'

     If 'skip' is applied to a field, the type machinery will ignore it.
     This is somewhat dangerous; the only safe use is in a union when
     one field really isn't ever used.

'for_user'

     Use this to mark types that need to be marked by user gc routines,
     but are not refered to in a template argument.  So if you have some
     user gc type T1 and a non user gc type T2 you can give T2 the
     for_user option so that the marking functions for T1 can call non
     mangled functions to mark T2.

'desc ("EXPRESSION")'
'tag ("CONSTANT")'
'default'

     The type machinery needs to be told which field of a 'union' is
     currently active.  This is done by giving each field a constant
     'tag' value, and then specifying a discriminator using 'desc'.  The
     value of the expression given by 'desc' is compared against each
     'tag' value, each of which should be different.  If no 'tag' is
     matched, the field marked with 'default' is used if there is one,
     otherwise no field in the union will be marked.

     In the 'desc' option, the "current structure" is the union that it
     discriminates.  Use '%1' to mean the structure containing it.
     There are no escapes available to the 'tag' option, since it is a
     constant.

     For example,
          struct GTY(()) tree_binding
          {
            struct tree_common common;
            union tree_binding_u {
              tree GTY ((tag ("0"))) scope;
              struct cp_binding_level * GTY ((tag ("1"))) level;
            } GTY ((desc ("BINDING_HAS_LEVEL_P ((tree)&%0)"))) xscope;
            tree value;
          };

     In this example, the value of BINDING_HAS_LEVEL_P when applied to a
     'struct tree_binding *' is presumed to be 0 or 1.  If 1, the type
     mechanism will treat the field 'level' as being present and if 0,
     will treat the field 'scope' as being present.

     The 'desc' and 'tag' options can also be used for inheritance to
     denote which subclass an instance is.  See *note Inheritance and
     GTY:: for more information.

'cache'

     When the 'cache' option is applied to a global variable
     gt_clear_cache is called on that variable between the mark and
     sweep phases of garbage collection.  The gt_clear_cache function is
     free to mark blocks as used, or to clear pointers in the variable.

'deletable'

     'deletable', when applied to a global variable, indicates that when
     garbage collection runs, there's no need to mark anything pointed
     to by this variable, it can just be set to 'NULL' instead.  This is
     used to keep a list of free structures around for re-use.

'maybe_undef'

     When applied to a field, 'maybe_undef' indicates that it's OK if
     the structure that this fields points to is never defined, so long
     as this field is always 'NULL'.  This is used to avoid requiring
     backends to define certain optional structures.  It doesn't work
     with language frontends.

'nested_ptr (TYPE, "TO EXPRESSION", "FROM EXPRESSION")'

     The type machinery expects all pointers to point to the start of an
     object.  Sometimes for abstraction purposes it's convenient to have
     a pointer which points inside an object.  So long as it's possible
     to convert the original object to and from the pointer, such
     pointers can still be used.  TYPE is the type of the original
     object, the TO EXPRESSION returns the pointer given the original
     object, and the FROM EXPRESSION returns the original object given
     the pointer.  The pointer will be available using the '%h' escape.

'chain_next ("EXPRESSION")'
'chain_prev ("EXPRESSION")'
'chain_circular ("EXPRESSION")'

     It's helpful for the type machinery to know if objects are often
     chained together in long lists; this lets it generate code that
     uses less stack space by iterating along the list instead of
     recursing down it.  'chain_next' is an expression for the next item
     in the list, 'chain_prev' is an expression for the previous item.
     For singly linked lists, use only 'chain_next'; for doubly linked
     lists, use both.  The machinery requires that taking the next item
     of the previous item gives the original item.  'chain_circular' is
     similar to 'chain_next', but can be used for circular single linked
     lists.

'reorder ("FUNCTION NAME")'

     Some data structures depend on the relative ordering of pointers.
     If the precompiled header machinery needs to change that ordering,
     it will call the function referenced by the 'reorder' option,
     before changing the pointers in the object that's pointed to by the
     field the option applies to.  The function must take four
     arguments, with the signature
     'void *, void *, gt_pointer_operator, void *'.  The first parameter
     is a pointer to the structure that contains the object being
     updated, or the object itself if there is no containing structure.
     The second parameter is a cookie that should be ignored.  The third
     parameter is a routine that, given a pointer, will update it to its
     correct new value.  The fourth parameter is a cookie that must be
     passed to the second parameter.

     PCH cannot handle data structures that depend on the absolute
     values of pointers.  'reorder' functions can be expensive.  When
     possible, it is better to depend on properties of the data, like an
     ID number or the hash of a string instead.

'atomic'

     The 'atomic' option can only be used with pointers.  It informs the
     GC machinery that the memory that the pointer points to does not
     contain any pointers, and hence it should be treated by the GC and
     PCH machinery as an "atomic" block of memory that does not need to
     be examined when scanning memory for pointers.  In particular, the
     machinery will not scan that memory for pointers to mark them as
     reachable (when marking pointers for GC) or to relocate them (when
     writing a PCH file).

     The 'atomic' option differs from the 'skip' option.  'atomic' keeps
     the memory under Garbage Collection, but makes the GC ignore the
     contents of the memory.  'skip' is more drastic in that it causes
     the pointer and the memory to be completely ignored by the Garbage
     Collector.  So, memory marked as 'atomic' is automatically freed
     when no longer reachable, while memory marked as 'skip' is not.

     The 'atomic' option must be used with great care, because all sorts
     of problem can occur if used incorrectly, that is, if the memory
     the pointer points to does actually contain a pointer.

     Here is an example of how to use it:
          struct GTY(()) my_struct {
            int number_of_elements;
            unsigned int * GTY ((atomic)) elements;
          };
     In this case, 'elements' is a pointer under GC, and the memory it
     points to needs to be allocated using the Garbage Collector, and
     will be freed automatically by the Garbage Collector when it is no
     longer referenced.  But the memory that the pointer points to is an
     array of 'unsigned int' elements, and the GC must not try to scan
     it to find pointers to mark or relocate, which is why it is marked
     with the 'atomic' option.

     Note that, currently, global variables cannot be marked with
     'atomic'; only fields of a struct can.  This is a known limitation.
     It would be useful to be able to mark global pointers with 'atomic'
     to make the PCH machinery aware of them so that they are saved and
     restored correctly to PCH files.

'special ("NAME")'

     The 'special' option is used to mark types that have to be dealt
     with by special case machinery.  The parameter is the name of the
     special case.  See 'gengtype.c' for further details.  Avoid adding
     new special cases unless there is no other alternative.

'user'

     The 'user' option indicates that the code to mark structure fields
     is completely handled by user-provided routines.  See section *note
     User GC:: for details on what functions need to be provided.

==============================================================================
File: gccint.info,  Node: |Inheritance_and_GTY|,  Next: |User_GC|,  Prev: |GTY_Options|,  Up: |Type_Information|
==============================================================================

                                                           *Inheritance_and_GTY*

23.2 Support for inheritance
=====-----------------------

gengtype has some support for simple class hierarchies.  You can use
this to have gengtype autogenerate marking routines, provided:

   * There must be a concrete base class, with a discriminator
     expression that can be used to identify which subclass an instance
     is.
   * Only single inheritance is used.
   * None of the classes within the hierarchy are templates.

 If your class hierarchy does not fit in this pattern, you must use
*note User GC:: instead.

 The base class and its discriminator must be identified using the
"desc" option.  Each concrete subclass must use the "tag" option to
identify which value of the discriminator it corresponds to.

 Every class in the hierarchy must have a 'GTY(())' marker, as gengtype
will only attempt to parse classes that have such a marker (1).

     class GTY((desc("%h.kind"), tag("0"))) example_base
     {
     public:
         int kind;
         tree a;
     };

     class GTY((tag("1"))) some_subclass : public example_base
     {
     public:
         tree b;
     };

     class GTY((tag("2"))) some_other_subclass : public example_base
     {
     public:
         tree c;
     };

 The generated marking routines for the above will contain a "switch" on
"kind", visiting all appropriate fields.  For example, if kind is 2, it
will cast to "some_other_subclass" and visit fields a, b, and c.

   ---------- Footnotes ----------

   (1) Classes lacking such a marker will not be identified as being
part of the hierarchy, and so the marking routines will not handle them,
leading to a assertion failure within the marking routines due to an
unknown tag value (assuming that assertions are enabled).

==============================================================================
File: gccint.info,  Node: |User_GC|,  Next: |GGC_Roots|,  Prev: |Inheritance_and_GTY|,  Up: |Type_Information|
==============================================================================

                                                                       *User_GC*

23.3 Support for user-provided GC marking routines
=====---------------------------------------------

The garbage collector supports types for which no automatic marking code
is generated.  For these types, the user is required to provide three
functions: one to act as a marker for garbage collection, and two
functions to act as marker and pointer walker for pre-compiled headers.

 Given a structure 'struct GTY((user)) my_struct', the following
functions should be defined to mark 'my_struct':

     void gt_ggc_mx (my_struct *p)
     {
       /* This marks field 'fld'.  */
       gt_ggc_mx (p->fld);
     }

     void gt_pch_nx (my_struct *p)
     {
       /* This marks field 'fld'.  */
       gt_pch_nx (tp->fld);
     }

     void gt_pch_nx (my_struct *p, gt_pointer_operator op, void *cookie)
     {
       /* For every field 'fld', call the given pointer operator.  */
       op (&(tp->fld), cookie);
     }

 In general, each marker 'M' should call 'M' for every pointer field in
the structure.  Fields that are not allocated in GC or are not pointers
must be ignored.

 For embedded lists (e.g., structures with a 'next' or 'prev' pointer),
the marker must follow the chain and mark every element in it.

 Note that the rules for the pointer walker 'gt_pch_nx (my_struct *,
gt_pointer_operator, void *)' are slightly different.  In this case, the
operation 'op' must be applied to the _address_ of every pointer field.

23.3.1 User-provided marking routines for template types
--------------------------------------------------------

When a template type 'TP' is marked with 'GTY', all instances of that
type are considered user-provided types.  This means that the individual
instances of 'TP' do not need to be marked with 'GTY'.  The user needs
to provide template functions to mark all the fields of the type.

 The following code snippets represent all the functions that need to be
provided.  Note that type 'TP' may reference to more than one type.  In
these snippets, there is only one type 'T', but there could be more.

     template<typename T>
     void gt_ggc_mx (TP<T> *tp)
     {
       extern void gt_ggc_mx (T&);

       /* This marks field 'fld' of type 'T'.  */
       gt_ggc_mx (tp->fld);
     }

     template<typename T>
     void gt_pch_nx (TP<T> *tp)
     {
       extern void gt_pch_nx (T&);

       /* This marks field 'fld' of type 'T'.  */
       gt_pch_nx (tp->fld);
     }

     template<typename T>
     void gt_pch_nx (TP<T *> *tp, gt_pointer_operator op, void *cookie)
     {
       /* For every field 'fld' of 'tp' with type 'T *', call the given
          pointer operator.  */
       op (&(tp->fld), cookie);
     }

     template<typename T>
     void gt_pch_nx (TP<T> *tp, gt_pointer_operator, void *cookie)
     {
       extern void gt_pch_nx (T *, gt_pointer_operator, void *);

       /* For every field 'fld' of 'tp' with type 'T', call the pointer
          walker for all the fields of T.  */
       gt_pch_nx (&(tp->fld), op, cookie);
     }

 Support for user-defined types is currently limited.  The following
restrictions apply:

  1. Type 'TP' and all the argument types 'T' must be marked with 'GTY'.

  2. Type 'TP' can only have type names in its argument list.

  3. The pointer walker functions are different for 'TP<T>' and 'TP<T
     *>'.  In the case of 'TP<T>', references to 'T' must be handled by
     calling 'gt_pch_nx' (which will, in turn, walk all the pointers
     inside fields of 'T').  In the case of 'TP<T *>', references to 'T
     *' must be handled by calling the 'op' function on the address of
     the pointer (see the code snippets above).

==============================================================================
File: gccint.info,  Node: |GGC_Roots|,  Next: |Files|,  Prev: |User_GC|,  Up: |Type_Information|
==============================================================================

                                                                     *GGC_Roots*

23.4 Marking Roots for the Garbage Collector
=====---------------------------------------

In addition to keeping track of types, the type machinery also locates
the global variables ("roots") that the garbage collector starts at.
Roots must be declared using one of the following syntaxes:

   * 'extern GTY(([OPTIONS])) TYPE NAME;'
   * 'static GTY(([OPTIONS])) TYPE NAME;'
The syntax
   * 'GTY(([OPTIONS])) TYPE NAME;'
is _not_ accepted.  There should be an 'extern' declaration of such a
variable in a header somewhere--mark that, not the definition.  Or, if
the variable is only used in one file, make it 'static'.

==============================================================================
File: gccint.info,  Node: |Files|,  Next: |Invoking_the_garbage_collector|,  Prev: |GGC_Roots|,  Up: |Type_Information|
==============================================================================

                                                                         *Files*

23.5 Source Files Containing Type Information
=====----------------------------------------

Whenever you add 'GTY' markers to a source file that previously had
none, or create a new source file containing 'GTY' markers, there are
three things you need to do:

  1. You need to add the file to the list of source files the type
     machinery scans.  There are four cases:

       a. For a back-end file, this is usually done automatically; if
          not, you should add it to 'target_gtfiles' in the appropriate
          port's entries in 'config.gcc'.

       b. For files shared by all front ends, add the filename to the
          'GTFILES' variable in 'Makefile.in'.

       c. For files that are part of one front end, add the filename to
          the 'gtfiles' variable defined in the appropriate
          'config-lang.in'.  Headers should appear before non-headers in
          this list.

       d. For files that are part of some but not all front ends, add
          the filename to the 'gtfiles' variable of _all_ the front ends
          that use it.

  2. If the file was a header file, you'll need to check that it's
     included in the right place to be visible to the generated files.
     For a back-end header file, this should be done automatically.  For
     a front-end header file, it needs to be included by the same file
     that includes 'gtype-LANG.h'.  For other header files, it needs to
     be included in 'gtype-desc.c', which is a generated file, so add it
     to 'ifiles' in 'open_base_file' in 'gengtype.c'.

     For source files that aren't header files, the machinery will
     generate a header file that should be included in the source file
     you just changed.  The file will be called 'gt-PATH.h' where PATH
     is the pathname relative to the 'gcc' directory with slashes
     replaced by -, so for example the header file to be included in
     'cp/parser.c' is called 'gt-cp-parser.c'.  The generated header
     file should be included after everything else in the source file.
     Don't forget to mention this file as a dependency in the
     'Makefile'!

 For language frontends, there is another file that needs to be included
somewhere.  It will be called 'gtype-LANG.h', where LANG is the name of
the subdirectory the language is contained in.

 Plugins can add additional root tables.  Run the 'gengtype' utility in
plugin mode as 'gengtype -P pluginout.h SOURCE-DIR FILE-LIST PLUGIN*.C'
with your plugin files PLUGIN*.C using 'GTY' to generate the PLUGINOUT.H
file.  The GCC build tree is needed to be present in that mode.

==============================================================================
File: gccint.info,  Node: |Invoking_the_garbage_collector|,  Next: |Troubleshooting|,  Prev: |Files|,  Up: |Type_Information|
==============================================================================

                                                *Invoking_the_garbage_collector*

23.6 How to invoke the garbage collector
=====-----------------------------------

The GCC garbage collector GGC is only invoked explicitly.  In contrast
with many other garbage collectors, it is not implicitly invoked by
allocation routines when a lot of memory has been consumed.  So the only
way to have GGC reclaim storage is to call the 'ggc_collect' function
explicitly.  This call is an expensive operation, as it may have to scan
the entire heap.  Beware that local variables (on the GCC call stack)
are not followed by such an invocation (as many other garbage collectors
do): you should reference all your data from static or external 'GTY'-ed
variables, and it is advised to call 'ggc_collect' with a shallow call
stack.  The GGC is an exact mark and sweep garbage collector (so it does
not scan the call stack for pointers).  In practice GCC passes don't
often call 'ggc_collect' themselves, because it is called by the pass
manager between passes.

 At the time of the 'ggc_collect' call all pointers in the GC-marked
structures must be valid or 'NULL'.  In practice this means that there
should not be uninitialized pointer fields in the structures even if
your code never reads or writes those fields at a particular instance.
One way to ensure this is to use cleared versions of allocators unless
all the fields are initialized manually immediately after allocation.

==============================================================================
File: gccint.info,  Node: |Troubleshooting|,  Prev: |Invoking_the_garbage_collector|,  Up: |Type_Information|
==============================================================================

                                                               *Troubleshooting*

23.7 Troubleshooting the garbage collector
=====-------------------------------------

With the current garbage collector implementation, most issues should
show up as GCC compilation errors.  Some of the most commonly
encountered issues are described below.

   * Gengtype does not produce allocators for a 'GTY'-marked type.
     Gengtype checks if there is at least one possible path from GC
     roots to at least one instance of each type before outputting
     allocators.  If there is no such path, the 'GTY' markers will be
     ignored and no allocators will be output.  Solve this by making
     sure that there exists at least one such path.  If creating it is
     unfeasible or raises a "code smell", consider if you really must
     use GC for allocating such type.

   * Link-time errors about undefined 'gt_ggc_r_foo_bar' and
     similarly-named symbols.  Check if your 'foo_bar' source file has
     '#include "gt-foo_bar.h"' as its very last line.

==============================================================================
File: gccint.info,  Node: |Plugins|,  Next: |LTO|,  Prev: |Type_Information|,  Up: |Top|
==============================================================================

                                                                       *Plugins*

24 Plugins
*****=====

GCC plugins are loadable modules that provide extra features to the
compiler.  Like GCC itself they can be distributed in source and binary
forms.

 GCC plugins provide developers with a rich subset of the GCC API to
allow them to extend GCC as they see fit.  Whether it is writing an
additional optimization pass, transforming code, or analyzing
information, plugins can be quite useful.

MENU

* |Plugins_loading|::      How can we load plugins.
* |Plugin_API|::           The APIs for plugins.
* |Plugins_pass|::         How a plugin interact with the pass manager.
* |Plugins_GC|::           How a plugin Interact with GCC Garbage Collector.
* |Plugins_description|::  Giving information about a plugin itself.
* |Plugins_attr|::         Registering custom attributes or pragmas.
* |Plugins_recording|::    Recording information about pass execution.
* |Plugins_gate|::         Controlling which passes are being run.
* |Plugins_tracking|::     Keeping track of available passes.
* |Plugins_building|::     How can we build a plugin.

==============================================================================
File: gccint.info,  Node: |Plugins_loading|,  Next: |Plugin_API|,  Up: |Plugins|
==============================================================================

                                                               *Plugins_loading*

24.1 Loading Plugins
=====---------------

Plugins are supported on platforms that support '-ldl -rdynamic' as well
as Windows/MinGW. They are loaded by the compiler using 'dlopen' or
equivalent and invoked at pre-determined locations in the compilation
process.

 Plugins are loaded with

 '-fplugin=/path/to/NAME.EXT' '-fplugin-arg-NAME-KEY1[=VALUE1]'

 Where NAME is the plugin name and EXT is the platform-specific dynamic
library extension.  It should be 'dll' on Windows/MinGW, 'dylib' on
Darwin/Mac OS X, and 'so' on all other platforms.  The plugin arguments
are parsed by GCC and passed to respective plugins as key-value pairs.
Multiple plugins can be invoked by specifying multiple '-fplugin'
arguments.

 A plugin can be simply given by its short name (no dots or slashes).
When simply passing '-fplugin=NAME', the plugin is loaded from the
'plugin' directory, so '-fplugin=NAME' is the same as '-fplugin=`gcc
-print-file-name=plugin`/NAME.EXT', using backquote shell syntax to
query the 'plugin' directory.

==============================================================================
File: gccint.info,  Node: |Plugin_API|,  Next: |Plugins_pass|,  Prev: |Plugins_loading|,  Up: |Plugins|
==============================================================================

                                                                    *Plugin_API*

24.2 Plugin API
=====----------

Plugins are activated by the compiler at specific events as defined in
'gcc-plugin.h'.  For each event of interest, the plugin should call
'register_callback' specifying the name of the event and address of the
callback function that will handle that event.

 The header 'gcc-plugin.h' must be the first gcc header to be included.

24.2.1 Plugin license check
---------------------------

Every plugin should define the global symbol 'plugin_is_GPL_compatible'
to assert that it has been licensed under a GPL-compatible license.  If
this symbol does not exist, the compiler will emit a fatal error and
exit with the error message:

     fatal error: plugin NAME is not licensed under a GPL-compatible license
     NAME: undefined symbol: plugin_is_GPL_compatible
     compilation terminated

 The declared type of the symbol should be int, to match a forward
declaration in 'gcc-plugin.h' that suppresses C++ mangling.  It does not
need to be in any allocated section, though.  The compiler merely
asserts that the symbol exists in the global scope.  Something like this
is enough:

     int plugin_is_GPL_compatible;

24.2.2 Plugin initialization
----------------------------

Every plugin should export a function called 'plugin_init' that is
called right after the plugin is loaded.  This function is responsible
for registering all the callbacks required by the plugin and do any
other required initialization.

 This function is called from 'compile_file' right before invoking the
parser.  The arguments to 'plugin_init' are:

   * 'plugin_info': Plugin invocation information.
   * 'version': GCC version.

 The 'plugin_info' struct is defined as follows:

     struct plugin_name_args
     {
       char *base_name;              /* Short name of the plugin
                                        (filename without .so suffix). */
       const char *full_name;        /* Path to the plugin as specified with
                                        -fplugin=. */
       int argc;                     /* Number of arguments specified with
                                        -fplugin-arg-.... */
       struct plugin_argument *argv; /* Array of ARGC key-value pairs. */
       const char *version;          /* Version string provided by plugin. */
       const char *help;             /* Help string provided by plugin. */
     }

 If initialization fails, 'plugin_init' must return a non-zero value.
Otherwise, it should return 0.

 The version of the GCC compiler loading the plugin is described by the
following structure:

     struct plugin_gcc_version
     {
       const char *basever;
       const char *datestamp;
       const char *devphase;
       const char *revision;
       const char *configuration_arguments;
     };

 The function 'plugin_default_version_check' takes two pointers to such
structure and compare them field by field.  It can be used by the
plugin's 'plugin_init' function.

 The version of GCC used to compile the plugin can be found in the
symbol 'gcc_version' defined in the header 'plugin-version.h'.  The
recommended version check to perform looks like

     #include "plugin-version.h"
     ...

     int
     plugin_init (struct plugin_name_args *plugin_info,
                  struct plugin_gcc_version *version)
     {
       if (!plugin_default_version_check (version, &gcc_version))
         return 1;

     }

 but you can also check the individual fields if you want a less strict
check.

24.2.3 Plugin callbacks
-----------------------

Callback functions have the following prototype:

     /* The prototype for a plugin callback function.
          gcc_data  - event-specific data provided by GCC
          user_data - plugin-specific data provided by the plug-in.  */
     typedef void (*plugin_callback_func)(void *gcc_data, void *user_data);

 Callbacks can be invoked at the following pre-determined events:

     enum plugin_event
     {
       PLUGIN_START_PARSE_FUNCTION,  /* Called before parsing the body of a function. */
       PLUGIN_FINISH_PARSE_FUNCTION, /* After finishing parsing a function. */
       PLUGIN_PASS_MANAGER_SETUP,    /* To hook into pass manager.  */
       PLUGIN_FINISH_TYPE,           /* After finishing parsing a type.  */
       PLUGIN_FINISH_DECL,           /* After finishing parsing a declaration. */
       PLUGIN_FINISH_UNIT,           /* Useful for summary processing.  */
       PLUGIN_PRE_GENERICIZE,        /* Allows to see low level AST in C and C++ frontends.  */
       PLUGIN_FINISH,                /* Called before GCC exits.  */
       PLUGIN_INFO,                  /* Information about the plugin. */
       PLUGIN_GGC_START,             /* Called at start of GCC Garbage Collection. */
       PLUGIN_GGC_MARKING,           /* Extend the GGC marking. */
       PLUGIN_GGC_END,               /* Called at end of GGC. */
       PLUGIN_REGISTER_GGC_ROOTS,    /* Register an extra GGC root table. */
       PLUGIN_ATTRIBUTES,            /* Called during attribute registration */
       PLUGIN_START_UNIT,            /* Called before processing a translation unit.  */
       PLUGIN_PRAGMAS,               /* Called during pragma registration. */
       /* Called before first pass from all_passes.  */
       PLUGIN_ALL_PASSES_START,
       /* Called after last pass from all_passes.  */
       PLUGIN_ALL_PASSES_END,
       /* Called before first ipa pass.  */
       PLUGIN_ALL_IPA_PASSES_START,
       /* Called after last ipa pass.  */
       PLUGIN_ALL_IPA_PASSES_END,
       /* Allows to override pass gate decision for current_pass.  */
       PLUGIN_OVERRIDE_GATE,
       /* Called before executing a pass.  */
       PLUGIN_PASS_EXECUTION,
       /* Called before executing subpasses of a GIMPLE_PASS in
          execute_ipa_pass_list.  */
       PLUGIN_EARLY_GIMPLE_PASSES_START,
       /* Called after executing subpasses of a GIMPLE_PASS in
          execute_ipa_pass_list.  */
       PLUGIN_EARLY_GIMPLE_PASSES_END,
       /* Called when a pass is first instantiated.  */
       PLUGIN_NEW_PASS,
     /* Called when a file is #include-d or given via the #line directive.
        This could happen many times.  The event data is the included file path,
        as a const char* pointer.  */
       PLUGIN_INCLUDE_FILE,

       PLUGIN_EVENT_FIRST_DYNAMIC    /* Dummy event used for indexing callback
                                        array.  */
     };

 In addition, plugins can also look up the enumerator of a named event,
and / or generate new events dynamically, by calling the function
'get_named_event_id'.

 To register a callback, the plugin calls 'register_callback' with the
arguments:

   * 'char *name': Plugin name.
   * 'int event': The event code.
   * 'plugin_callback_func callback': The function that handles 'event'.
   * 'void *user_data': Pointer to plugin-specific data.

 For the PLUGIN_PASS_MANAGER_SETUP, PLUGIN_INFO, and
PLUGIN_REGISTER_GGC_ROOTS pseudo-events the 'callback' should be null,
and the 'user_data' is specific.

 When the PLUGIN_PRAGMAS event is triggered (with a null pointer as data
from GCC), plugins may register their own pragmas.  Notice that pragmas
are not available from 'lto1', so plugins used with '-flto' option to
GCC during link-time optimization cannot use pragmas and do not even see
functions like 'c_register_pragma' or 'pragma_lex'.

 The PLUGIN_INCLUDE_FILE event, with a 'const char*' file path as GCC
data, is triggered for processing of '#include' or '#line' directives.

 The PLUGIN_FINISH event is the last time that plugins can call GCC
functions, notably emit diagnostics with 'warning', 'error' etc.

==============================================================================
File: gccint.info,  Node: |Plugins_pass|,  Next: |Plugins_GC|,  Prev: |Plugin_API|,  Up: |Plugins|
==============================================================================

                                                                  *Plugins_pass*

24.3 Interacting with the pass manager
=====---------------------------------

There needs to be a way to add/reorder/remove passes dynamically.  This
is useful for both analysis plugins (plugging in after a certain pass
such as CFG or an IPA pass) and optimization plugins.

 Basic support for inserting new passes or replacing existing passes is
provided.  A plugin registers a new pass with GCC by calling
'register_callback' with the 'PLUGIN_PASS_MANAGER_SETUP' event and a
pointer to a 'struct register_pass_info' object defined as follows

     enum pass_positioning_ops
     {
       PASS_POS_INSERT_AFTER,  // Insert after the reference pass.
       PASS_POS_INSERT_BEFORE, // Insert before the reference pass.
       PASS_POS_REPLACE        // Replace the reference pass.
     };

     struct register_pass_info
     {
       struct opt_pass *pass;            /* New pass provided by the plugin.  */
       const char *reference_pass_name;  /* Name of the reference pass for hooking
                                            up the new pass.  */
       int ref_pass_instance_number;     /* Insert the pass at the specified
                                            instance number of the reference pass.  */
                                         /* Do it for every instance if it is 0.  */
       enum pass_positioning_ops pos_op; /* how to insert the new pass.  */
     };


     /* Sample plugin code that registers a new pass.  */
     int
     plugin_init (struct plugin_name_args *plugin_info,
                  struct plugin_gcc_version *version)
     {
       struct register_pass_info pass_info;

       ...

       /* Code to fill in the pass_info object with new pass information.  */

       ...

       /* Register the new pass.  */
       register_callback (plugin_info->base_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &pass_info);

       ...
     }

==============================================================================
File: gccint.info,  Node: |Plugins_GC|,  Next: |Plugins_description|,  Prev: |Plugins_pass|,  Up: |Plugins|
==============================================================================

                                                                    *Plugins_GC*

24.4 Interacting with the GCC Garbage Collector
=====------------------------------------------

Some plugins may want to be informed when GGC (the GCC Garbage
Collector) is running.  They can register callbacks for the
'PLUGIN_GGC_START' and 'PLUGIN_GGC_END' events (for which the callback
is called with a null 'gcc_data') to be notified of the start or end of
the GCC garbage collection.

 Some plugins may need to have GGC mark additional data.  This can be
done by registering a callback (called with a null 'gcc_data') for the
'PLUGIN_GGC_MARKING' event.  Such callbacks can call the 'ggc_set_mark'
routine, preferably through the 'ggc_mark' macro (and conversely, these
routines should usually not be used in plugins outside of the
'PLUGIN_GGC_MARKING' event).  Plugins that wish to hold weak references
to gc data may also use this event to drop weak references when the
object is about to be collected.  The 'ggc_marked_p' function can be
used to tell if an object is marked, or is about to be collected.  The
'gt_clear_cache' overloads which some types define may also be of use in
managing weak references.

 Some plugins may need to add extra GGC root tables, e.g. to handle
their own 'GTY'-ed data.  This can be done with the
'PLUGIN_REGISTER_GGC_ROOTS' pseudo-event with a null callback and the
extra root table (of type 'struct ggc_root_tab*') as 'user_data'.
Running the 'gengtype -p SOURCE-DIR FILE-LIST PLUGIN*.C ...' utility
generates these extra root tables.

 You should understand the details of memory management inside GCC
before using 'PLUGIN_GGC_MARKING' or 'PLUGIN_REGISTER_GGC_ROOTS'.

==============================================================================
File: gccint.info,  Node: |Plugins_description|,  Next: |Plugins_attr|,  Prev: |Plugins_GC|,  Up: |Plugins|
==============================================================================

                                                           *Plugins_description*

24.5 Giving information about a plugin
=====---------------------------------

A plugin should give some information to the user about itself.  This
uses the following structure:

     struct plugin_info
     {
       const char *version;
       const char *help;
     };

 Such a structure is passed as the 'user_data' by the plugin's init
routine using 'register_callback' with the 'PLUGIN_INFO' pseudo-event
and a null callback.

==============================================================================
File: gccint.info,  Node: |Plugins_attr|,  Next: |Plugins_recording|,  Prev: |Plugins_description|,  Up: |Plugins|
==============================================================================

                                                                  *Plugins_attr*

24.6 Registering custom attributes or pragmas
=====----------------------------------------

For analysis (or other) purposes it is useful to be able to add custom
attributes or pragmas.

 The 'PLUGIN_ATTRIBUTES' callback is called during attribute
registration.  Use the 'register_attribute' function to register custom
attributes.

     /* Attribute handler callback */
     static tree
     handle_user_attribute (tree *node, tree name, tree args,
                            int flags, bool *no_add_attrs)
     {
       return NULL_TREE;
     }

     /* Attribute definition */
     static struct attribute_spec user_attr =
       { "user", 1, 1, false,  false, false, false, handle_user_attribute, NULL };

     /* Plugin callback called during attribute registration.
     Registered with register_callback (plugin_name, PLUGIN_ATTRIBUTES, register_attributes, NULL)
     */
     static void
     register_attributes (void *event_data, void *data)
     {
       warning (0, G_("Callback to register attributes"));
       register_attribute (&user_attr);
     }


 The PLUGIN_PRAGMAS callback is called once during pragmas registration.
Use the 'c_register_pragma', 'c_register_pragma_with_data',
'c_register_pragma_with_expansion',
'c_register_pragma_with_expansion_and_data' functions to register custom
pragmas and their handlers (which often want to call 'pragma_lex') from
'c-family/c-pragma.h'.

     /* Plugin callback called during pragmas registration. Registered with
          register_callback (plugin_name, PLUGIN_PRAGMAS,
                             register_my_pragma, NULL);
     */
     static void
     register_my_pragma (void *event_data, void *data)
     {
       warning (0, G_("Callback to register pragmas"));
       c_register_pragma ("GCCPLUGIN", "sayhello", handle_pragma_sayhello);
     }

 It is suggested to pass '"GCCPLUGIN"' (or a short name identifying your
plugin) as the "space" argument of your pragma.

 Pragmas registered with 'c_register_pragma_with_expansion' or
'c_register_pragma_with_expansion_and_data' support preprocessor
expansions.  For example:

     #define NUMBER 10
     #pragma GCCPLUGIN foothreshold (NUMBER)

==============================================================================
File: gccint.info,  Node: |Plugins_recording|,  Next: |Plugins_gate|,  Prev: |Plugins_attr|,  Up: |Plugins|
==============================================================================

                                                             *Plugins_recording*

24.7 Recording information about pass execution
=====------------------------------------------

The event PLUGIN_PASS_EXECUTION passes the pointer to the executed pass
(the same as current_pass) as 'gcc_data' to the callback.  You can also
inspect cfun to find out about which function this pass is executed for.
Note that this event will only be invoked if the gate check (if
applicable, modified by PLUGIN_OVERRIDE_GATE) succeeds.  You can use
other hooks, like 'PLUGIN_ALL_PASSES_START', 'PLUGIN_ALL_PASSES_END',
'PLUGIN_ALL_IPA_PASSES_START', 'PLUGIN_ALL_IPA_PASSES_END',
'PLUGIN_EARLY_GIMPLE_PASSES_START', and/or
'PLUGIN_EARLY_GIMPLE_PASSES_END' to manipulate global state in your
plugin(s) in order to get context for the pass execution.

==============================================================================
File: gccint.info,  Node: |Plugins_gate|,  Next: |Plugins_tracking|,  Prev: |Plugins_recording|,  Up: |Plugins|
==============================================================================

                                                                  *Plugins_gate*

24.8 Controlling which passes are being run
=====--------------------------------------

After the original gate function for a pass is called, its result - the
gate status - is stored as an integer.  Then the event
'PLUGIN_OVERRIDE_GATE' is invoked, with a pointer to the gate status in
the 'gcc_data' parameter to the callback function.  A nonzero value of
the gate status means that the pass is to be executed.  You can both
read and write the gate status via the passed pointer.

==============================================================================
File: gccint.info,  Node: |Plugins_tracking|,  Next: |Plugins_building|,  Prev: |Plugins_gate|,  Up: |Plugins|
==============================================================================

                                                              *Plugins_tracking*

24.9 Keeping track of available passes
=====---------------------------------

When your plugin is loaded, you can inspect the various pass lists to
determine what passes are available.  However, other plugins might add
new passes.  Also, future changes to GCC might cause generic passes to
be added after plugin loading.  When a pass is first added to one of the
pass lists, the event 'PLUGIN_NEW_PASS' is invoked, with the callback
parameter 'gcc_data' pointing to the new pass.

==============================================================================
File: gccint.info,  Node: |Plugins_building|,  Prev: |Plugins_tracking|,  Up: |Plugins|
==============================================================================

                                                              *Plugins_building*

24.10 Building GCC plugins
=====---------------------

If plugins are enabled, GCC installs the headers needed to build a
plugin (somewhere in the installation tree, e.g. under '/usr/local').
In particular a 'plugin/include' directory is installed, containing all
the header files needed to build plugins.

 On most systems, you can query this 'plugin' directory by invoking 'gcc
-print-file-name=plugin' (replace if needed 'gcc' with the appropriate
program path).

 Inside plugins, this 'plugin' directory name can be queried by calling
'default_plugin_dir_name ()'.

 Plugins may know, when they are compiled, the GCC version for which
'plugin-version.h' is provided.  The constant macros
'GCCPLUGIN_VERSION_MAJOR', 'GCCPLUGIN_VERSION_MINOR',
'GCCPLUGIN_VERSION_PATCHLEVEL', 'GCCPLUGIN_VERSION' are integer numbers,
so a plugin could ensure it is built for GCC 4.7 with
     #if GCCPLUGIN_VERSION != 4007
     #error this GCC plugin is for GCC 4.7
     #endif

 The following GNU Makefile excerpt shows how to build a simple plugin:

     HOST_GCC=g++
     TARGET_GCC=gcc
     PLUGIN_SOURCE_FILES= plugin1.c plugin2.cc
     GCCPLUGINS_DIR:= $(shell $(TARGET_GCC) -print-file-name=plugin)
     CXXFLAGS+= -I$(GCCPLUGINS_DIR)/include -fPIC -fno-rtti -O2

     plugin.so: $(PLUGIN_SOURCE_FILES)
        $(HOST_GCC) -shared $(CXXFLAGS) $^ -o $@

 A single source file plugin may be built with 'g++ -I`gcc
-print-file-name=plugin`/include -fPIC -shared -fno-rtti -O2 plugin.c -o
plugin.so', using backquote shell syntax to query the 'plugin'
directory.

 Plugin support on Windows/MinGW has a number of limitations and
additional requirements.  When building a plugin on Windows we have to
link an import library for the corresponding backend executable, for
example, 'cc1.exe', 'cc1plus.exe', etc., in order to gain access to the
symbols provided by GCC. This means that on Windows a plugin is
language-specific, for example, for C, C++, etc.  If you wish to use
your plugin with multiple languages, then you will need to build
multiple plugin libraries and either instruct your users on how to load
the correct version or provide a compiler wrapper that does this
automatically.

 Additionally, on Windows the plugin library has to export the
'plugin_is_GPL_compatible' and 'plugin_init' symbols.  If you do not
wish to modify the source code of your plugin, then you can use the
'-Wl,--export-all-symbols' option or provide a suitable DEF file.
Alternatively, you can export just these two symbols by decorating them
with '__declspec(dllexport)', for example:

     #ifdef _WIN32
     __declspec(dllexport)
     #endif
     int plugin_is_GPL_compatible;

     #ifdef _WIN32
     __declspec(dllexport)
     #endif
     int plugin_init (plugin_name_args *, plugin_gcc_version *)

 The import libraries are installed into the 'plugin' directory and
their names are derived by appending the '.a' extension to the backend
executable names, for example, 'cc1.exe.a', 'cc1plus.exe.a', etc.  The
following command line shows how to build the single source file plugin
on Windows to be used with the C++ compiler:

     g++ -I`gcc -print-file-name=plugin`/include -shared -Wl,--export-all-symbols \
     -o plugin.dll plugin.c `gcc -print-file-name=plugin`/cc1plus.exe.a

 When a plugin needs to use 'gengtype', be sure that both 'gengtype' and
'gtype.state' have the same version as the GCC for which the plugin is
built.

==============================================================================
File: gccint.info,  Node: |LTO|,  Next: |Match_and_Simplify|,  Prev: |Plugins|,  Up: |Top|
==============================================================================

                                                                           *LTO*

25 Link Time Optimization
*****====================

Link Time Optimization (LTO) gives GCC the capability of dumping its
internal representation (GIMPLE) to disk, so that all the different
compilation units that make up a single executable can be optimized as a
single module.  This expands the scope of inter-procedural optimizations
to encompass the whole program (or, rather, everything that is visible
at link time).

MENU

* |LTO_Overview|::            Overview of LTO.
* |LTO_object_file_layout|::  LTO file sections in ELF.
* |IPA|::                     Using summary information in IPA passes.
* |WHOPR|::                   Whole program assumptions,
                            linker plugin and symbol visibilities.
* |Internal_flags|::          Internal flags controlling 'lto1'.

==============================================================================
File: gccint.info,  Node: |LTO_Overview|,  Next: |LTO_object_file_layout|,  Up: |LTO|
==============================================================================

                                                                  *LTO_Overview*

25.1 Design Overview
=====---------------

Link time optimization is implemented as a GCC front end for a bytecode
representation of GIMPLE that is emitted in special sections of '.o'
files.  Currently, LTO support is enabled in most ELF-based systems, as
well as darwin, cygwin and mingw systems.

 Since GIMPLE bytecode is saved alongside final object code, object
files generated with LTO support are larger than regular object files.
This "fat" object format makes it easy to integrate LTO into existing
build systems, as one can, for instance, produce archives of the files.
Additionally, one might be able to ship one set of fat objects which
could be used both for development and the production of optimized
builds.  A, perhaps surprising, side effect of this feature is that any
mistake in the toolchain leads to LTO information not being used (e.g.
an older 'libtool' calling 'ld' directly).  This is both an advantage,
as the system is more robust, and a disadvantage, as the user is not
informed that the optimization has been disabled.

 The current implementation only produces "fat" objects, effectively
doubling compilation time and increasing file sizes up to 5x the
original size.  This hides the problem that some tools, such as 'ar' and
'nm', need to understand symbol tables of LTO sections.  These tools
were extended to use the plugin infrastructure, and with these problems
solved, GCC will also support "slim" objects consisting of the
intermediate code alone.

 At the highest level, LTO splits the compiler in two.  The first half
(the "writer") produces a streaming representation of all the internal
data structures needed to optimize and generate code.  This includes
declarations, types, the callgraph and the GIMPLE representation of
function bodies.

 When '-flto' is given during compilation of a source file, the pass
manager executes all the passes in 'all_lto_gen_passes'.  Currently,
this phase is composed of two IPA passes:

   * 'pass_ipa_lto_gimple_out' This pass executes the function
     'lto_output' in 'lto-streamer-out.c', which traverses the call
     graph encoding every reachable declaration, type and function.
     This generates a memory representation of all the file sections
     described below.

   * 'pass_ipa_lto_finish_out' This pass executes the function
     'produce_asm_for_decls' in 'lto-streamer-out.c', which takes the
     memory image built in the previous pass and encodes it in the
     corresponding ELF file sections.

 The second half of LTO support is the "reader".  This is implemented as
the GCC front end 'lto1' in 'lto/lto.c'.  When 'collect2' detects a link
set of '.o'/'.a' files with LTO information and the '-flto' is enabled,
it invokes 'lto1' which reads the set of files and aggregates them into
a single translation unit for optimization.  The main entry point for
the reader is 'lto/lto.c':'lto_main'.

25.1.1 LTO modes of operation
-----------------------------

One of the main goals of the GCC link-time infrastructure was to allow
effective compilation of large programs.  For this reason GCC implements
two link-time compilation modes.

  1. _LTO mode_, in which the whole program is read into the compiler at
     link-time and optimized in a similar way as if it were a single
     source-level compilation unit.

  2. _WHOPR or partitioned mode_, designed to utilize multiple CPUs
     and/or a distributed compilation environment to quickly link large
     applications.  WHOPR stands for WHOle Program optimizeR (not to be
     confused with the semantics of '-fwhole-program').  It partitions
     the aggregated callgraph from many different '.o' files and
     distributes the compilation of the sub-graphs to different CPUs.

     Note that distributed compilation is not implemented yet, but since
     the parallelism is facilitated via generating a 'Makefile', it
     would be easy to implement.

 WHOPR splits LTO into three main stages:
  1. Local generation (LGEN) This stage executes in parallel.  Every
     file in the program is compiled into the intermediate language and
     packaged together with the local call-graph and summary
     information.  This stage is the same for both the LTO and WHOPR
     compilation mode.

  2. Whole Program Analysis (WPA) WPA is performed sequentially.  The
     global call-graph is generated, and a global analysis procedure
     makes transformation decisions.  The global call-graph is
     partitioned to facilitate parallel optimization during phase 3.
     The results of the WPA stage are stored into new object files which
     contain the partitions of program expressed in the intermediate
     language and the optimization decisions.

  3. Local transformations (LTRANS) This stage executes in parallel.
     All the decisions made during phase 2 are implemented locally in
     each partitioned object file, and the final object code is
     generated.  Optimizations which cannot be decided efficiently
     during the phase 2 may be performed on the local call-graph
     partitions.

 WHOPR can be seen as an extension of the usual LTO mode of compilation.
In LTO, WPA and LTRANS are executed within a single execution of the
compiler, after the whole program has been read into memory.

 When compiling in WHOPR mode, the callgraph is partitioned during the
WPA stage.  The whole program is split into a given number of partitions
of roughly the same size.  The compiler tries to minimize the number of
references which cross partition boundaries.  The main advantage of
WHOPR is to allow the parallel execution of LTRANS stages, which are the
most time-consuming part of the compilation process.  Additionally, it
avoids the need to load the whole program into memory.

==============================================================================
File: gccint.info,  Node: |LTO_object_file_layout|,  Next: |IPA|,  Prev: |LTO_Overview|,  Up: |LTO|
==============================================================================

                                                        *LTO_object_file_layout*

25.2 LTO file sections
=====-----------------

LTO information is stored in several ELF sections inside object files.
Data structures and enum codes for sections are defined in
'lto-streamer.h'.

 These sections are emitted from 'lto-streamer-out.c' and mapped in all
at once from 'lto/lto.c':'lto_file_read'.  The individual functions
dealing with the reading/writing of each section are described below.

   * Command line options ('.gnu.lto_.opts')

     This section contains the command line options used to generate the
     object files.  This is used at link time to determine the
     optimization level and other settings when they are not explicitly
     specified at the linker command line.

     Currently, GCC does not support combining LTO object files compiled
     with different set of the command line options into a single
     binary.  At link time, the options given on the command line and
     the options saved on all the files in a link-time set are applied
     globally.  No attempt is made at validating the combination of
     flags (other than the usual validation done by option processing).
     This is implemented in 'lto/lto.c':'lto_read_all_file_options'.

   * Symbol table ('.gnu.lto_.symtab')

     This table replaces the ELF symbol table for functions and
     variables represented in the LTO IL. Symbols used and exported by
     the optimized assembly code of "fat" objects might not match the
     ones used and exported by the intermediate code.  This table is
     necessary because the intermediate code is less optimized and thus
     requires a separate symbol table.

     Additionally, the binary code in the "fat" object will lack a call
     to a function, since the call was optimized out at compilation time
     after the intermediate language was streamed out.  In some special
     cases, the same optimization may not happen during link-time
     optimization.  This would lead to an undefined symbol if only one
     symbol table was used.

     The symbol table is emitted in
     'lto-streamer-out.c':'produce_symtab'.

   * Global declarations and types ('.gnu.lto_.decls')

     This section contains an intermediate language dump of all
     declarations and types required to represent the callgraph, static
     variables and top-level debug info.

     The contents of this section are emitted in
     'lto-streamer-out.c':'produce_asm_for_decls'.  Types and symbols
     are emitted in a topological order that preserves the sharing of
     pointers when the file is read back in
     ('lto.c':'read_cgraph_and_symbols').

   * The callgraph ('.gnu.lto_.cgraph')

     This section contains the basic data structure used by the GCC
     inter-procedural optimization infrastructure.  This section stores
     an annotated multi-graph which represents the functions and call
     sites as well as the variables, aliases and top-level 'asm'
     statements.

     This section is emitted in 'lto-streamer-out.c':'output_cgraph' and
     read in 'lto-cgraph.c':'input_cgraph'.

   * IPA references ('.gnu.lto_.refs')

     This section contains references between function and static
     variables.  It is emitted by 'lto-cgraph.c':'output_refs' and read
     by 'lto-cgraph.c':'input_refs'.

   * Function bodies ('.gnu.lto_.function_body.<name>')

     This section contains function bodies in the intermediate language
     representation.  Every function body is in a separate section to
     allow copying of the section independently to different object
     files or reading the function on demand.

     Functions are emitted in 'lto-streamer-out.c':'output_function' and
     read in 'lto-streamer-in.c':'input_function'.

   * Static variable initializers ('.gnu.lto_.vars')

     This section contains all the symbols in the global variable pool.
     It is emitted by 'lto-cgraph.c':'output_varpool' and read in
     'lto-cgraph.c':'input_cgraph'.

   * Summaries and optimization summaries used by IPA passes
     ('.gnu.lto_.<xxx>', where '<xxx>' is one of 'jmpfuncs', 'pureconst'
     or 'reference')

     These sections are used by IPA passes that need to emit summary
     information during LTO generation to be read and aggregated at link
     time.  Each pass is responsible for implementing two pass manager
     hooks: one for writing the summary and another for reading it in.
     The format of these sections is entirely up to each individual
     pass.  The only requirement is that the writer and reader hooks
     agree on the format.

==============================================================================
File: gccint.info,  Node: |IPA|,  Next: |WHOPR|,  Prev: |LTO_object_file_layout|,  Up: |LTO|
==============================================================================

                                                                           *IPA*

25.3 Using summary information in IPA passes
=====---------------------------------------

Programs are represented internally as a _callgraph_ (a multi-graph
where nodes are functions and edges are call sites) and a _varpool_ (a
list of static and external variables in the program).

 The inter-procedural optimization is organized as a sequence of
individual passes, which operate on the callgraph and the varpool.  To
make the implementation of WHOPR possible, every inter-procedural
optimization pass is split into several stages that are executed at
different times during WHOPR compilation:

   * LGEN time
       1. _Generate summary_ ('generate_summary' in 'struct
          ipa_opt_pass_d').  This stage analyzes every function body and
          variable initializer is examined and stores relevant
          information into a pass-specific data structure.

       2. _Write summary_ ('write_summary' in 'struct ipa_opt_pass_d').
          This stage writes all the pass-specific information generated
          by 'generate_summary'.  Summaries go into their own
          'LTO_section_*' sections that have to be declared in
          'lto-streamer.h':'enum lto_section_type'.  A new section is
          created by calling 'create_output_block' and data can be
          written using the 'lto_output_*' routines.

   * WPA time
       1. _Read summary_ ('read_summary' in 'struct ipa_opt_pass_d').
          This stage reads all the pass-specific information in exactly
          the same order that it was written by 'write_summary'.

       2. _Execute_ ('execute' in 'struct opt_pass').  This performs
          inter-procedural propagation.  This must be done without
          actual access to the individual function bodies or variable
          initializers.  Typically, this results in a transitive closure
          operation over the summary information of all the nodes in the
          callgraph.

       3. _Write optimization summary_ ('write_optimization_summary' in
          'struct ipa_opt_pass_d').  This writes the result of the
          inter-procedural propagation into the object file.  This can
          use the same data structures and helper routines used in
          'write_summary'.

   * LTRANS time
       1. _Read optimization summary_ ('read_optimization_summary' in
          'struct ipa_opt_pass_d').  The counterpart to
          'write_optimization_summary'.  This reads the interprocedural
          optimization decisions in exactly the same format emitted by
          'write_optimization_summary'.

       2. _Transform_ ('function_transform' and 'variable_transform' in
          'struct ipa_opt_pass_d').  The actual function bodies and
          variable initializers are updated based on the information
          passed down from the _Execute_ stage.

 The implementation of the inter-procedural passes are shared between
LTO, WHOPR and classic non-LTO compilation.

   * During the traditional file-by-file mode every pass executes its
     own _Generate summary_, _Execute_, and _Transform_ stages within
     the single execution context of the compiler.

   * In LTO compilation mode, every pass uses _Generate summary_ and
     _Write summary_ stages at compilation time, while the _Read
     summary_, _Execute_, and _Transform_ stages are executed at link
     time.

   * In WHOPR mode all stages are used.

 To simplify development, the GCC pass manager differentiates between
normal inter-procedural passes (*note Regular IPA passes::), small
inter-procedural passes (*note Small IPA passes::) and late
inter-procedural passes (*note Late IPA passes::).  A small or late IPA
pass ('SIMPLE_IPA_PASS') does everything at once and thus cannot be
executed during WPA in WHOPR mode.  It defines only the _Execute_ stage
and during this stage it accesses and modifies the function bodies.
Such passes are useful for optimization at LGEN or LTRANS time and are
used, for example, to implement early optimization before writing object
files.  The simple inter-procedural passes can also be used for easier
prototyping and development of a new inter-procedural pass.

25.3.1 Virtual clones
---------------------

One of the main challenges of introducing the WHOPR compilation mode was
addressing the interactions between optimization passes.  In LTO
compilation mode, the passes are executed in a sequence, each of which
consists of analysis (or _Generate summary_), propagation (or _Execute_)
and _Transform_ stages.  Once the work of one pass is finished, the next
pass sees the updated program representation and can execute.  This
makes the individual passes dependent on each other.

 In WHOPR mode all passes first execute their _Generate summary_ stage.
Then summary writing marks the end of the LGEN stage.  At WPA time, the
summaries are read back into memory and all passes run the _Execute_
stage.  Optimization summaries are streamed and sent to LTRANS, where
all the passes execute the _Transform_ stage.

 Most optimization passes split naturally into analysis, propagation and
transformation stages.  But some do not.  The main problem arises when
one pass performs changes and the following pass gets confused by seeing
different callgraphs between the _Transform_ stage and the _Generate
summary_ or _Execute_ stage.  This means that the passes are required to
communicate their decisions with each other.

 To facilitate this communication, the GCC callgraph infrastructure
implements _virtual clones_, a method of representing the changes
performed by the optimization passes in the callgraph without needing to
update function bodies.

 A _virtual clone_ in the callgraph is a function that has no associated
body, just a description of how to create its body based on a different
function (which itself may be a virtual clone).

 The description of function modifications includes adjustments to the
function's signature (which allows, for example, removing or adding
function arguments), substitutions to perform on the function body, and,
for inlined functions, a pointer to the function that it will be inlined
into.

 It is also possible to redirect any edge of the callgraph from a
function to its virtual clone.  This implies updating of the call site
to adjust for the new function signature.

 Most of the transformations performed by inter-procedural optimizations
can be represented via virtual clones.  For instance, a constant
propagation pass can produce a virtual clone of the function which
replaces one of its arguments by a constant.  The inliner can represent
its decisions by producing a clone of a function whose body will be
later integrated into a given function.

 Using _virtual clones_, the program can be easily updated during the
_Execute_ stage, solving most of pass interactions problems that would
otherwise occur during _Transform_.

 Virtual clones are later materialized in the LTRANS stage and turned
into real functions.  Passes executed after the virtual clone were
introduced also perform their _Transform_ stage on new functions, so for
a pass there is no significant difference between operating on a real
function or a virtual clone introduced before its _Execute_ stage.

 Optimization passes then work on virtual clones introduced before their
_Execute_ stage as if they were real functions.  The only difference is
that clones are not visible during the _Generate Summary_ stage.

 To keep function summaries updated, the callgraph interface allows an
optimizer to register a callback that is called every time a new clone
is introduced as well as when the actual function or variable is
generated or when a function or variable is removed.  These hooks are
registered in the _Generate summary_ stage and allow the pass to keep
its information intact until the _Execute_ stage.  The same hooks can
also be registered during the _Execute_ stage to keep the optimization
summaries updated for the _Transform_ stage.

25.3.2 IPA references
---------------------

GCC represents IPA references in the callgraph.  For a function or
variable 'A', the _IPA reference_ is a list of all locations where the
address of 'A' is taken and, when 'A' is a variable, a list of all
direct stores and reads to/from 'A'.  References represent an oriented
multi-graph on the union of nodes of the callgraph and the varpool.  See
'ipa-reference.c':'ipa_reference_write_optimization_summary' and
'ipa-reference.c':'ipa_reference_read_optimization_summary' for details.

25.3.3 Jump functions
---------------------

Suppose that an optimization pass sees a function 'A' and it knows the
values of (some of) its arguments.  The _jump function_ describes the
value of a parameter of a given function call in function 'A' based on
this knowledge.

 Jump functions are used by several optimizations, such as the
inter-procedural constant propagation pass and the devirtualization
pass.  The inliner also uses jump functions to perform inlining of
callbacks.

==============================================================================
File: gccint.info,  Node: |WHOPR|,  Next: |Internal_flags|,  Prev: |IPA|,  Up: |LTO|
==============================================================================

                                                                         *WHOPR*

25.4 Whole program assumptions, linker plugin and symbol visibilities
=====----------------------------------------------------------------

Link-time optimization gives relatively minor benefits when used alone.
The problem is that propagation of inter-procedural information does not
work well across functions and variables that are called or referenced
by other compilation units (such as from a dynamically linked library).
We say that such functions and variables are _externally visible_.

 To make the situation even more difficult, many applications organize
themselves as a set of shared libraries, and the default ELF visibility
rules allow one to overwrite any externally visible symbol with a
different symbol at runtime.  This basically disables any optimizations
across such functions and variables, because the compiler cannot be sure
that the function body it is seeing is the same function body that will
be used at runtime.  Any function or variable not declared 'static' in
the sources degrades the quality of inter-procedural optimization.

 To avoid this problem the compiler must assume that it sees the whole
program when doing link-time optimization.  Strictly speaking, the whole
program is rarely visible even at link-time.  Standard system libraries
are usually linked dynamically or not provided with the link-time
information.  In GCC, the whole program option ('-fwhole-program')
asserts that every function and variable defined in the current
compilation unit is static, except for function 'main' (note: at link
time, the current unit is the union of all objects compiled with LTO).
Since some functions and variables need to be referenced externally, for
example by another DSO or from an assembler file, GCC also provides the
function and variable attribute 'externally_visible' which can be used
to disable the effect of '-fwhole-program' on a specific symbol.

 The whole program mode assumptions are slightly more complex in C++,
where inline functions in headers are put into _COMDAT_ sections.
COMDAT function and variables can be defined by multiple object files
and their bodies are unified at link-time and dynamic link-time.  COMDAT
functions are changed to local only when their address is not taken and
thus un-sharing them with a library is not harmful.  COMDAT variables
always remain externally visible, however for readonly variables it is
assumed that their initializers cannot be overwritten by a different
value.

 GCC provides the function and variable attribute 'visibility' that can
be used to specify the visibility of externally visible symbols (or
alternatively an '-fdefault-visibility' command line option).  ELF
defines the 'default', 'protected', 'hidden' and 'internal'
visibilities.

 The most commonly used is visibility is 'hidden'.  It specifies that
the symbol cannot be referenced from outside of the current shared
library.  Unfortunately, this information cannot be used directly by the
link-time optimization in the compiler since the whole shared library
also might contain non-LTO objects and those are not visible to the
compiler.

 GCC solves this problem using linker plugins.  A _linker plugin_ is an
interface to the linker that allows an external program to claim the
ownership of a given object file.  The linker then performs the linking
procedure by querying the plugin about the symbol table of the claimed
objects and once the linking decisions are complete, the plugin is
allowed to provide the final object file before the actual linking is
made.  The linker plugin obtains the symbol resolution information which
specifies which symbols provided by the claimed objects are bound from
the rest of a binary being linked.

 GCC is designed to be independent of the rest of the toolchain and aims
to support linkers without plugin support.  For this reason it does not
use the linker plugin by default.  Instead, the object files are
examined by 'collect2' before being passed to the linker and objects
found to have LTO sections are passed to 'lto1' first.  This mode does
not work for library archives.  The decision on what object files from
the archive are needed depends on the actual linking and thus GCC would
have to implement the linker itself.  The resolution information is
missing too and thus GCC needs to make an educated guess based on
'-fwhole-program'.  Without the linker plugin GCC also assumes that
symbols are declared 'hidden' and not referred by non-LTO code by
default.

==============================================================================
File: gccint.info,  Node: |Internal_flags|,  Prev: |WHOPR|,  Up: |LTO|
==============================================================================

                                                                *Internal_flags*

25.5 Internal flags controlling 'lto1'
=====---------------------------------

The following flags are passed into 'lto1' and are not meant to be used
directly from the command line.

   * -fwpa This option runs the serial part of the link-time optimizer
     performing the inter-procedural propagation (WPA mode).  The
     compiler reads in summary information from all inputs and performs
     an analysis based on summary information only.  It generates object
     files for subsequent runs of the link-time optimizer where
     individual object files are optimized using both summary
     information from the WPA mode and the actual function bodies.  It
     then drives the LTRANS phase.

   * -fltrans This option runs the link-time optimizer in the
     local-transformation (LTRANS) mode, which reads in output from a
     previous run of the LTO in WPA mode.  In the LTRANS mode, LTO
     optimizes an object and produces the final assembly.

   * -fltrans-output-list=FILE This option specifies a file to which the
     names of LTRANS output files are written.  This option is only
     meaningful in conjunction with '-fwpa'.

   * -fresolution=FILE This option specifies the linker resolution file.
     This option is only meaningful in conjunction with '-fwpa' and as
     option to pass through to the LTO linker plugin.

==============================================================================
File: gccint.info,  Node: |Match_and_Simplify|,  Next: |Static_Analyzer|,  Prev: |LTO|,  Up: |Top|
==============================================================================

                                                            *Match_and_Simplify*

26 Match and Simplify
*****================

The GIMPLE and GENERIC pattern matching project match-and-simplify tries
to address several issues.

  1. unify expression simplifications currently spread and duplicated
     over separate files like fold-const.c, gimple-fold.c and builtins.c
  2. allow for a cheap way to implement building and simplifying
     non-trivial GIMPLE expressions, avoiding the need to go through
     building and simplifying GENERIC via fold_buildN and then
     gimplifying via force_gimple_operand

 To address these the project introduces a simple domain specific
language to write expression simplifications from which code targeting
GIMPLE and GENERIC is auto-generated.  The GENERIC variant follows the
fold_buildN API while for the GIMPLE variant and to address 2) new APIs
are introduced.

MENU

* |GIMPLE_API|::
* |The_Language|::

==============================================================================
File: gccint.info,  Node: |GIMPLE_API|,  Next: |The_Language|,  Up: |Match_and_Simplify|
==============================================================================

                                                                    *GIMPLE_API*

26.1 GIMPLE API
=====----------

 -- GIMPLE function: tree gimple_simplify (enum tree_code, tree, tree,
          gimple_seq *, tree (*)(tree))
 -- GIMPLE function: tree gimple_simplify (enum tree_code, tree, tree,
          tree, gimple_seq *, tree (*)(tree))
 -- GIMPLE function: tree gimple_simplify (enum tree_code, tree, tree,
          tree, tree, gimple_seq *, tree (*)(tree))
 -- GIMPLE function: tree gimple_simplify (enum built_in_function, tree,
          tree, gimple_seq *, tree (*)(tree))
 -- GIMPLE function: tree gimple_simplify (enum built_in_function, tree,
          tree, tree, gimple_seq *, tree (*)(tree))
 -- GIMPLE function: tree gimple_simplify (enum built_in_function, tree,
          tree, tree, tree, gimple_seq *, tree (*)(tree))
     The main GIMPLE API entry to the expression simplifications
     mimicing that of the GENERIC fold_{unary,binary,ternary} functions.

 thus providing n-ary overloads for operation or function.  The
additional arguments are a gimple_seq where built statements are
inserted on (if 'NULL' then simplifications requiring new statements are
not performed) and a valueization hook that can be used to tie
simplifications to a SSA lattice.

 In addition to those APIs 'fold_stmt' is overloaded with a valueization
hook:

 -- bool: fold_stmt (gimple_stmt_iterator *, tree (*)(tree));

 Ontop of these a 'fold_buildN'-like API for GIMPLE is introduced:

 -- GIMPLE function: tree gimple_build (gimple_seq *, location_t, enum
          tree_code, tree, tree, tree (*valueize) (tree) = NULL);
 -- GIMPLE function: tree gimple_build (gimple_seq *, location_t, enum
          tree_code, tree, tree, tree, tree (*valueize) (tree) = NULL);
 -- GIMPLE function: tree gimple_build (gimple_seq *, location_t, enum
          tree_code, tree, tree, tree, tree, tree (*valueize) (tree) =
          NULL);
 -- GIMPLE function: tree gimple_build (gimple_seq *, location_t, enum
          built_in_function, tree, tree, tree (*valueize) (tree) =
          NULL);
 -- GIMPLE function: tree gimple_build (gimple_seq *, location_t, enum
          built_in_function, tree, tree, tree, tree (*valueize) (tree) =
          NULL);
 -- GIMPLE function: tree gimple_build (gimple_seq *, location_t, enum
          built_in_function, tree, tree, tree, tree, tree (*valueize)
          (tree) = NULL);
 -- GIMPLE function: tree gimple_convert (gimple_seq *, location_t,
          tree, tree);

 which is supposed to replace 'force_gimple_operand (fold_buildN (...),
...)' and calls to 'fold_convert'.  Overloads without the 'location_t'
argument exist.  Built statements are inserted on the provided sequence
and simplification is performed using the optional valueization hook.

==============================================================================
File: gccint.info,  Node: |The_Language|,  Prev: |GIMPLE_API|,  Up: |Match_and_Simplify|
==============================================================================

                                                                  *The_Language*

26.2 The Language
=====------------

The language to write expression simplifications in resembles other
domain-specific languages GCC uses.  Thus it is lispy.  Lets start with
an example from the match.pd file:

     (simplify
       (bit_and @0 integer_all_onesp)
       @0)

 This example contains all required parts of an expression
simplification.  A simplification is wrapped inside a '(simplify ...)'
expression.  That contains at least two operands - an expression that is
matched with the GIMPLE or GENERIC IL and a replacement expression that
is returned if the match was successful.

 Expressions have an operator ID, 'bit_and' in this case.  Expressions
can be lower-case tree codes with '_expr' stripped off or builtin
function code names in all-caps, like 'BUILT_IN_SQRT'.

 '@n' denotes a so-called capture.  It captures the operand and lets you
refer to it in other places of the match-and-simplify.  In the above
example it is refered to in the replacement expression.  Captures are
'@' followed by a number or an identifier.

     (simplify
       (bit_xor @0 @0)
       { build_zero_cst (type); })

 In this example '@0' is mentioned twice which constrains the matched
expression to have two equal operands.  Usually matches are constraint
to equal types.  If operands may be constants and conversions are
involved matching by value might be preferred in which case use '@@0' to
denote a by value match and the specific operand you want to refer to in
the result part.  This example also introduces operands written in C
code.  These can be used in the expression replacements and are supposed
to evaluate to a tree node which has to be a valid GIMPLE operand (so
you cannot generate expressions in C code).

     (simplify
       (trunc_mod integer_zerop@0 @1)
       (if (!integer_zerop (@1))
        @0))

 Here '@0' captures the first operand of the trunc_mod expression which
is also predicated with 'integer_zerop'.  Expression operands may be
either expressions, predicates or captures.  Captures can be
unconstrained or capture expresions or predicates.

 This example introduces an optional operand of simplify, the
if-expression.  This condition is evaluated after the expression matched
in the IL and is required to evaluate to true to enable the replacement
expression in the second operand position.  The expression operand of
the 'if' is a standard C expression which may contain references to
captures.  The 'if' has an optional third operand which may contain the
replacement expression that is enabled when the condition evaluates to
false.

 A 'if' expression can be used to specify a common condition for
multiple simplify patterns, avoiding the need to repeat that multiple
times:

     (if (!TYPE_SATURATING (type)
          && !FLOAT_TYPE_P (type) && !FIXED_POINT_TYPE_P (type))
       (simplify
         (minus (plus @0 @1) @0)
         @1)
       (simplify
         (minus (minus @0 @1) @0)
         (negate @1)))

 Note that 'if's in outer position do not have the optional else clause
but instead have multiple then clauses.

 Ifs can be nested.

 There exists a 'switch' expression which can be used to chain
conditions avoiding nesting 'if's too much:

     (simplify
      (simple_comparison @0 REAL_CST@1)
      (switch
       /* a CMP (-0) -> a CMP 0  */
       (if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (@1)))
        (cmp @0 { build_real (TREE_TYPE (@1), dconst0); }))
       /* x != NaN is always true, other ops are always false.  */
       (if (REAL_VALUE_ISNAN (TREE_REAL_CST (@1))
            && ! HONOR_SNANS (@1))
        { constant_boolean_node (cmp == NE_EXPR, type); })))

 Is equal to

     (simplify
      (simple_comparison @0 REAL_CST@1)
      (switch
       /* a CMP (-0) -> a CMP 0  */
       (if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (@1)))
        (cmp @0 { build_real (TREE_TYPE (@1), dconst0); })
        /* x != NaN is always true, other ops are always false.  */
        (if (REAL_VALUE_ISNAN (TREE_REAL_CST (@1))
             && ! HONOR_SNANS (@1))
         { constant_boolean_node (cmp == NE_EXPR, type); }))))

 which has the second 'if' in the else operand of the first.  The
'switch' expression takes 'if' expressions as operands (which may not
have else clauses) and as a last operand a replacement expression which
should be enabled by default if no other condition evaluated to true.

 Captures can also be used for capturing results of sub-expressions.

     #if GIMPLE
     (simplify
       (pointer_plus (addr@2 @0) INTEGER_CST_P@1)
       (if (is_gimple_min_invariant (@2)))
       {
         poly_int64 off;
         tree base = get_addr_base_and_unit_offset (@0, &off);
         off += tree_to_uhwi (@1);
         /* Now with that we should be able to simply write
            (addr (mem_ref (addr @base) (plus @off @1)))  */
         build1 (ADDR_EXPR, type,
                 build2 (MEM_REF, TREE_TYPE (TREE_TYPE (@2)),
                         build_fold_addr_expr (base),
                         build_int_cst (ptr_type_node, off)));
       })
     #endif

 In the above example, '@2' captures the result of the expression '(addr
@0)'.  For outermost expression only its type can be captured, and the
keyword 'type' is reserved for this purpose.  The above example also
gives a way to conditionalize patterns to only apply to 'GIMPLE' or
'GENERIC' by means of using the pre-defined preprocessor macros 'GIMPLE'
and 'GENERIC' and using preprocessor directives.

     (simplify
       (bit_and:c integral_op_p@0 (bit_ior:c (bit_not @0) @1))
       (bit_and @1 @0))

 Here we introduce flags on match expressions.  The flag used above,
'c', denotes that the expression should be also matched commutated.
Thus the above match expression is really the following four match
expressions:

       (bit_and integral_op_p@0 (bit_ior (bit_not @0) @1))
       (bit_and (bit_ior (bit_not @0) @1) integral_op_p@0)
       (bit_and integral_op_p@0 (bit_ior @1 (bit_not @0)))
       (bit_and (bit_ior @1 (bit_not @0)) integral_op_p@0)

 Usual canonicalizations you know from GENERIC expressions are applied
before matching, so for example constant operands always come second in
commutative expressions.

 The second supported flag is 's' which tells the code generator to fail
the pattern if the expression marked with 's' does have more than one
use and the simplification results in an expression with more than one
operator.  For example in

     (simplify
       (pointer_plus (pointer_plus:s @0 @1) @3)
       (pointer_plus @0 (plus @1 @3)))

 this avoids the association if '(pointer_plus @0 @1)' is used outside
of the matched expression and thus it would stay live and not trivially
removed by dead code elimination.  Now consider '((x + 3) + -3)' with
the temporary holding '(x + 3)' used elsewhere.  This simplifies down to
'x' which is desirable and thus flagging with 's' does not prevent the
transform.  Now consider '((x + 3) + 1)' which simplifies to '(x + 4)'.
Despite being flagged with 's' the simplification will be performed.
The simplification of '((x + a) + 1)' to '(x + (a + 1))' will not
performed in this case though.

 More features exist to avoid too much repetition.

     (for op (plus pointer_plus minus bit_ior bit_xor)
       (simplify
         (op @0 integer_zerop)
         @0))

 A 'for' expression can be used to repeat a pattern for each operator
specified, substituting 'op'.  'for' can be nested and a 'for' can have
multiple operators to iterate.

     (for opa (plus minus)
          opb (minus plus)
       (for opc (plus minus)
         (simplify...

 In this example the pattern will be repeated four times with 'opa, opb,
opc' being 'plus, minus, plus'; 'plus, minus, minus'; 'minus, plus,
plus'; 'minus, plus, minus'.

 To avoid repeating operator lists in 'for' you can name them via

     (define_operator_list pmm plus minus mult)

 and use them in 'for' operator lists where they get expanded.

     (for opa (pmm trunc_div)
      (simplify...

 So this example iterates over 'plus', 'minus', 'mult' and 'trunc_div'.

 Using operator lists can also remove the need to explicitely write a
'for'.  All operator list uses that appear in a 'simplify' or 'match'
pattern in operator positions will implicitely be added to a new 'for'.
For example

     (define_operator_list SQRT BUILT_IN_SQRTF BUILT_IN_SQRT BUILT_IN_SQRTL)
     (define_operator_list POW BUILT_IN_POWF BUILT_IN_POW BUILT_IN_POWL)
     (simplify
      (SQRT (POW @0 @1))
      (POW (abs @0) (mult @1 { built_real (TREE_TYPE (@1), dconsthalf); })))

 is the same as

     (for SQRT (BUILT_IN_SQRTF BUILT_IN_SQRT BUILT_IN_SQRTL)
          POW (BUILT_IN_POWF BUILT_IN_POW BUILT_IN_POWL)
      (simplify
       (SQRT (POW @0 @1))
       (POW (abs @0) (mult @1 { built_real (TREE_TYPE (@1), dconsthalf); }))))

 'for's and operator lists can include the special identifier 'null'
that matches nothing and can never be generated.  This can be used to
pad an operator list so that it has a standard form, even if there isn't
a suitable operator for every form.

 Another building block are 'with' expressions in the result expression
which nest the generated code in a new C block followed by its argument:

     (simplify
      (convert (mult @0 @1))
      (with { tree utype = unsigned_type_for (type); }
       (convert (mult (convert:utype @0) (convert:utype @1)))))

 This allows code nested in the 'with' to refer to the declared
variables.  In the above case we use the feature to specify the type of
a generated expression with the ':type' syntax where 'type' needs to be
an identifier that refers to the desired type.  Usually the types of the
generated result expressions are determined from the context, but
sometimes like in the above case it is required that you specify them
explicitely.

 As intermediate conversions are often optional there is a way to avoid
the need to repeat patterns both with and without such conversions.
Namely you can mark a conversion as being optional with a '?':

     (simplify
      (eq (convert@0 @1) (convert? @2))
      (eq @1 (convert @2)))

 which will match both '(eq (convert @1) (convert @2))' and '(eq
(convert @1) @2)'.  The optional converts are supposed to be all either
present or not, thus '(eq (convert? @1) (convert? @2))' will result in
two patterns only.  If you want to match all four combinations you have
access to two additional conditional converts as in '(eq (convert1? @1)
(convert2? @2))'.

 The support for '?' marking extends to all unary operations including
predicates you declare yourself with 'match'.

 Predicates available from the GCC middle-end need to be made available
explicitely via 'define_predicates':

     (define_predicates
      integer_onep integer_zerop integer_all_onesp)

 You can also define predicates using the pattern matching language and
the 'match' form:

     (match negate_expr_p
      INTEGER_CST
      (if (TYPE_OVERFLOW_WRAPS (type)
           || may_negate_without_overflow_p (t))))
     (match negate_expr_p
      (negate @0))

 This shows that for 'match' expressions there is 't' available which
captures the outermost expression (something not possible in the
'simplify' context).  As you can see 'match' has an identifier as first
operand which is how you refer to the predicate in patterns.  Multiple
'match' for the same identifier add additional cases where the predicate
matches.

 Predicates can also match an expression in which case you need to
provide a template specifying the identifier and where to get its
operands from:

     (match (logical_inverted_value @0)
      (eq @0 integer_zerop))
     (match (logical_inverted_value @0)
      (bit_not truth_valued_p@0))

 You can use the above predicate like

     (simplify
      (bit_and @0 (logical_inverted_value @0))
      { build_zero_cst (type); })

 Which will match a bitwise and of an operand with its logical inverted
value.

==============================================================================
File: gccint.info,  Node: |Static_Analyzer|,  Next: |User_Experience_Guidelines|,  Prev: |Match_and_Simplify|,  Up: |Top|
==============================================================================

                                                               *Static_Analyzer*

27 Static Analyzer
*****=============

MENU

* |Analyzer_Internals|::       Analyzer Internals
* |Debugging_the_Analyzer|::   Useful debugging tips

==============================================================================
File: gccint.info,  Node: |Analyzer_Internals|,  Next: |Debugging_the_Analyzer|,  Up: Static Analyzer
==============================================================================

                                                            *Analyzer_Internals*

27.1 Analyzer Internals
=====------------------

27.1.1 Overview
---------------

The analyzer implementation works on the gimple-SSA representation.  (I
chose this in the hopes of making it easy to work with LTO to do
whole-program analysis).

 The implementation is read-only: it doesn't attempt to change anything,
just emit warnings.

 The gimple representation can be seen using '-fdump-ipa-analyzer'.

 First, we build a 'supergraph' which combines the callgraph and all of
the CFGs into a single directed graph, with both interprocedural and
intraprocedural edges.  The nodes and edges in the supergraph are called
"supernodes" and "superedges", and often referred to in code as 'snodes'
and 'sedges'.  Basic blocks in the CFGs are split at interprocedural
calls, so there can be more than one supernode per basic block.  Most
statements will be in just one supernode, but a call statement can
appear in two supernodes: at the end of one for the call, and again at
the start of another for the return.

 The supergraph can be seen using '-fdump-analyzer-supergraph'.

 We then build an 'analysis_plan' which walks the callgraph to determine
which calls might be suitable for being summarized (rather than fully
explored) and thus in what order to explore the functions.

 Next is the heart of the analyzer: we use a worklist to explore state
within the supergraph, building an "exploded graph".  Nodes in the
exploded graph correspond to <point, state> pairs, as in "Precise
Interprocedural Dataflow Analysis via Graph Reachability" (Thomas Reps,
Susan Horwitz and Mooly Sagiv).

 We reuse nodes for <point, state> pairs we've already seen, and avoid
tracking state too closely, so that (hopefully) we rapidly converge on a
final exploded graph, and terminate the analysis.  We also bail out if
the number of exploded <end-of-basic-block, state> nodes gets larger
than a particular multiple of the total number of basic blocks (to
ensure termination in the face of pathological state-explosion cases, or
bugs).  We also stop exploring a point once we hit a limit of states for
that point.

 We can identify problems directly when processing a <point, state>
instance.  For example, if we're finding the successors of

        <point: before-stmt: "free (ptr);",
         state: {"ptr": freed}>

 then we can detect a double-free of "ptr".  We can then emit a path to
reach the problem by finding the simplest route through the graph.

 Program points in the analysis are much more fine-grained than in the
CFG and supergraph, with points (and thus potentially exploded nodes)
for various events, including before individual statements.  By default
the exploded graph merges multiple consecutive statements in a supernode
into one exploded edge to minimize the size of the exploded graph.  This
can be suppressed via '-fanalyzer-fine-grained'.  The fine-grained
approach seems to make things simpler and more debuggable that other
approaches I tried, in that each point is responsible for one thing.

 Program points in the analysis also have a "call string" identifying
the stack of callsites below them, so that paths in the exploded graph
correspond to interprocedurally valid paths: we always return to the
correct call site, propagating state information accordingly.  We avoid
infinite recursion by stopping the analysis if a callsite appears more
than 'analyzer-max-recursion-depth' in a callstring (defaulting to 2).

27.1.2 Graphs
-------------

Nodes and edges in the exploded graph are called "exploded nodes" and
"exploded edges" and often referred to in the code as 'enodes' and
'eedges' (especially when distinguishing them from the 'snodes' and
'sedges' in the supergraph).

 Each graph numbers its nodes, giving unique identifiers - supernodes
are referred to throughout dumps in the form 'SN': INDEX' and exploded
nodes in the form 'EN: INDEX' (e.g.  'SN: 2' and 'EN:29').

 The supergraph can be seen using '-fdump-analyzer-supergraph-graph'.

 The exploded graph can be seen using '-fdump-analyzer-exploded-graph'
and other dump options.  Exploded nodes are color-coded in the .dot
output based on state-machine states to make it easier to see state
changes at a glance.

27.1.3 State Tracking
---------------------

There's a tension between:
   * precision of analysis in the straight-line case, vs
   * exponential blow-up in the face of control flow.

 For example, in general, given this CFG:

           A
          / \
         B   C
          \ /
           D
          / \
         E   F
          \ /
           G

 we want to avoid differences in state-tracking in B and C from leading
to blow-up.  If we don't prevent state blowup, we end up with
exponential growth of the exploded graph like this:


                1:A
               /   \
              /     \
             /       \
           2:B       3:C
            |         |
           4:D       5:D        (2 exploded nodes for D)
          /   \     /   \
        6:E   7:F 8:E   9:F
         |     |   |     |
        10:G 11:G 12:G  13:G    (4 exploded nodes for G)


 Similar issues arise with loops.

 To prevent this, we follow various approaches:

  a. state pruning: which tries to discard state that won't be relevant
     later on withing the function.  This can be disabled via
     '-fno-analyzer-state-purge'.

  b. state merging.  We can try to find the commonality between two
     program_state instances to make a third, simpler program_state.  We
     have two strategies here:

       1. the worklist keeps new nodes for the same program_point
          together, and tries to merge them before processing, and thus
          before they have successors.  Hence, in the above, the two
          nodes for D (4 and 5) reach the front of the worklist
          together, and we create a node for D with the merger of the
          incoming states.

       2. try merging with the state of existing enodes for the
          program_point (which may have already been explored).  There
          will be duplication, but only one set of duplication;
          subsequent duplicates are more likely to hit the cache.  In
          particular, (hopefully) all merger chains are finite, and so
          we guarantee termination.  This is intended to help with
          loops: we ought to explore the first iteration, and then have
          a "subsequent iterations" exploration, which uses a state
          merged from that of the first, to be more abstract.

     We avoid merging pairs of states that have state-machine
     differences, as these are the kinds of differences that are likely
     to be most interesting.  So, for example, given:

                if (condition)
                  ptr = malloc (size);
                else
                  ptr = local_buf;

                .... do things with 'ptr'
                vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
