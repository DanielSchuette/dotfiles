
 -- Variable: mouse-position-function
     If non-'nil', the value of this variable is a function for
     'mouse-position' to call.  'mouse-position' calls this function
     just before returning, with its normal return value as the sole
     argument, and it returns whatever this function returns to it.

     This abnormal hook exists for the benefit of packages like
     'xt-mouse.el' that need to do mouse handling at the Lisp level.

 -- Function: set-mouse-position frame x y
     This function "warps the mouse" to position X, Y in frame FRAME.
     The arguments X and Y are integers, giving the position in
     multiples of the default character size of FRAME (*note Frame
     Font::) relative to the native position of FRAME (*note Frame
     Geometry::).

     The resulting mouse position is constrained to the native frame of
     FRAME.  If FRAME is not visible, this function does nothing.  The
     return value is not significant.

 -- Function: mouse-pixel-position
     This function is like 'mouse-position' except that it returns
     coordinates in units of pixels rather than units of characters.

 -- Function: set-mouse-pixel-position frame x y
     This function warps the mouse like 'set-mouse-position' except that
     X and Y are in units of pixels rather than units of characters.

     The resulting mouse position is not constrained to the native frame
     of FRAME.  If FRAME is not visible, this function does nothing.
     The return value is not significant.

   On a graphical terminal the following two functions allow the
absolute position of the mouse cursor to be retrieved and set.

 -- Function: mouse-absolute-pixel-position
     This function returns a cons cell (X .  Y) of the coordinates of
     the mouse cursor position in pixels, relative to a position (0, 0)
     of the selected frame's display.

 -- Function: set-mouse-absolute-pixel-position x y
     This function moves the mouse cursor to the position (X, Y).  The
     coordinates X and Y are interpreted in pixels relative to a
     position (0, 0) of the selected frame's display.

   The following function can tell whether the mouse cursor is currently
visible on a frame:

 -- Function: frame-pointer-visible-p &optional frame
     This predicate function returns non-'nil' if the mouse pointer
     displayed on FRAME is visible; otherwise it returns 'nil'.  FRAME
     omitted or 'nil' means the selected frame.  This is useful when
     'make-pointer-invisible' is set to 't': it allows you to know if
     the pointer has been hidden.  *Note (emacs)Mouse Avoidance::.

==============================================================================
File: elisp.info,  Node: |Pop_Up_Menus|,  Next: |Dialog_Boxes|,  Prev: |Mouse_Position|,  Up: |Frames|
==============================================================================

                                                                  *Pop_Up_Menus*

29.17 Pop-Up Menus
------------------

A Lisp program can pop up a menu so that the user can choose an
alternative with the mouse.  On a text terminal, if the mouse is not
available, the user can choose an alternative using the keyboard motion
keys--'C-n', 'C-p', or up- and down-arrow keys.

 -- Function: x-popup-menu position menu
     This function displays a pop-up menu and returns an indication of
     what selection the user makes.

     The argument POSITION specifies where on the screen to put the top
     left corner of the menu.  It can be either a mouse button event
     (which says to put the menu where the user actuated the button) or
     a list of this form:

          ((XOFFSET YOFFSET) WINDOW)

     where XOFFSET and YOFFSET are coordinates, measured in pixels,
     counting from the top left corner of WINDOW.  WINDOW may be a
     window or a frame.

     If POSITION is 't', it means to use the current mouse position (or
     the top-left corner of the frame if the mouse is not available on a
     text terminal).  If POSITION is 'nil', it means to precompute the
     key binding equivalents for the keymaps specified in MENU, without
     actually displaying or popping up the menu.

     The argument MENU says what to display in the menu.  It can be a
     keymap or a list of keymaps (*note Menu Keymaps::).  In this case,
     the return value is the list of events corresponding to the user's
     choice.  This list has more than one element if the choice occurred
     in a submenu.  (Note that 'x-popup-menu' does not actually execute
     the command bound to that sequence of events.)  On text terminals
     and toolkits that support menu titles, the title is taken from the
     prompt string of MENU if MENU is a keymap, or from the prompt
     string of the first keymap in MENU if it is a list of keymaps
     (*note Defining Menus::).

     Alternatively, MENU can have the following form:

          (TITLE PANE1 PANE2...)

     where each pane is a list of form

          (TITLE ITEM1 ITEM2...)

     Each ITEM should be a cons cell, '(LINE . VALUE)', where LINE is a
     string and VALUE is the value to return if that LINE is chosen.
     Unlike in a menu keymap, a 'nil' VALUE does not make the menu item
     non-selectable.  Alternatively, each ITEM can be a string rather
     than a cons cell; this makes a non-selectable menu item.

     If the user gets rid of the menu without making a valid choice, for
     instance by clicking the mouse away from a valid choice or by
     typing 'C-g', then this normally results in a quit and
     'x-popup-menu' does not return.  But if POSITION is a mouse button
     event (indicating that the user invoked the menu with the mouse)
     then no quit occurs and 'x-popup-menu' returns 'nil'.

   *Usage note:* Don't use 'x-popup-menu' to display a menu if you could
do the job with a prefix key defined with a menu keymap.  If you use a
menu keymap to implement a menu, 'C-h c' and 'C-h a' can see the
individual items in that menu and provide help for them.  If instead you
implement the menu by defining a command that calls 'x-popup-menu', the
help facilities cannot know what happens inside that command, so they
cannot give any help for the menu's items.

   The menu bar mechanism, which lets you switch between submenus by
moving the mouse, cannot look within the definition of a command to see
that it calls 'x-popup-menu'.  Therefore, if you try to implement a
submenu using 'x-popup-menu', it cannot work with the menu bar in an
integrated fashion.  This is why all menu bar submenus are implemented
with menu keymaps within the parent menu, and never with 'x-popup-menu'.
*Note Menu Bar::.

   If you want a menu bar submenu to have contents that vary, you should
still use a menu keymap to implement it.  To make the contents vary, add
a hook function to 'menu-bar-update-hook' to update the contents of the
menu keymap as necessary.

==============================================================================
File: elisp.info,  Node: |Dialog_Boxes|,  Next: |Pointer_Shape|,  Prev: |Pop_Up_Menus|,  Up: |Frames|
==============================================================================

                                                                  *Dialog_Boxes*

29.18 Dialog Boxes
------------------

A dialog box is a variant of a pop-up menu--it looks a little different,
it always appears in the center of a frame, and it has just one level
and one or more buttons.  The main use of dialog boxes is for asking
questions that the user can answer with "yes", "no", and a few other
alternatives.  With a single button, they can also force the user to
acknowledge important information.  The functions 'y-or-n-p' and
'yes-or-no-p' use dialog boxes instead of the keyboard, when called from
commands invoked by mouse clicks.

 -- Function: x-popup-dialog position contents &optional header
     This function displays a pop-up dialog box and returns an
     indication of what selection the user makes.  The argument CONTENTS
     specifies the alternatives to offer; it has this format:

          (TITLE (STRING . VALUE)...)

     which looks like the list that specifies a single pane for
     'x-popup-menu'.

     The return value is VALUE from the chosen alternative.

     As for 'x-popup-menu', an element of the list may be just a string
     instead of a cons cell '(STRING . VALUE)'.  That makes a box that
     cannot be selected.

     If 'nil' appears in the list, it separates the left-hand items from
     the right-hand items; items that precede the 'nil' appear on the
     left, and items that follow the 'nil' appear on the right.  If you
     don't include a 'nil' in the list, then approximately half the
     items appear on each side.

     Dialog boxes always appear in the center of a frame; the argument
     POSITION specifies which frame.  The possible values are as in
     'x-popup-menu', but the precise coordinates or the individual
     window don't matter; only the frame matters.

     If HEADER is non-'nil', the frame title for the box is
     'Information', otherwise it is 'Question'.  The former is used for
     'message-box' (*note message-box::).  (On text terminals, the box
     title is not displayed.)

     In some configurations, Emacs cannot display a real dialog box; so
     instead it displays the same items in a pop-up menu in the center
     of the frame.

     If the user gets rid of the dialog box without making a valid
     choice, for instance using the window manager, then this produces a
     quit and 'x-popup-dialog' does not return.

==============================================================================
File: elisp.info,  Node: |Pointer_Shape|,  Next: |Window_System_Selections|,  Prev: |Dialog_Boxes|,  Up: |Frames|
==============================================================================

                                                                 *Pointer_Shape*

29.19 Pointer Shape
-------------------

You can specify the mouse pointer style for particular text or images
using the 'pointer' text property, and for images with the ':pointer'
and ':map' image properties.  The values you can use in these properties
are 'text' (or 'nil'), 'arrow', 'hand', 'vdrag', 'hdrag', 'modeline',
and 'hourglass'.  'text' stands for the usual mouse pointer style used
over text.

   Over void parts of the window (parts that do not correspond to any of
the buffer contents), the mouse pointer usually uses the 'arrow' style,
but you can specify a different style (one of those above) by setting
'void-text-area-pointer'.

 -- User Option: void-text-area-pointer
     This variable specifies the mouse pointer style for void text
     areas.  These include the areas after the end of a line or below
     the last line in the buffer.  The default is to use the 'arrow'
     (non-text) pointer style.

   When using X, you can specify what the 'text' pointer style really
looks like by setting the variable 'x-pointer-shape'.

 -- Variable: x-pointer-shape
     This variable specifies the pointer shape to use ordinarily in the
     Emacs frame, for the 'text' pointer style.

 -- Variable: x-sensitive-text-pointer-shape
     This variable specifies the pointer shape to use when the mouse is
     over mouse-sensitive text.

   These variables affect newly created frames.  They do not normally
affect existing frames; however, if you set the mouse color of a frame,
that also installs the current value of those two variables.  *Note Font
and Color Parameters::.

   The values you can use, to specify either of these pointer shapes,
are defined in the file 'lisp/term/x-win.el'.  Use 'M-x apropos <RET>
x-pointer <RET>' to see a list of them.

==============================================================================
File: elisp.info,  Node: |Window_System_Selections|,  Next: |Drag_and_Drop|,  Prev: |Pointer_Shape|,  Up: |Frames|
==============================================================================

                                                      *Window_System_Selections*

29.20 Window System Selections
------------------------------

In window systems, such as X, data can be transferred between different
applications by means of "selections".  X defines an arbitrary number of
"selection types", each of which can store its own data; however, only
three are commonly used: the "clipboard", "primary selection", and
"secondary selection".  Other window systems support only the clipboard.
*Note Cut and Paste: (emacs)Cut and Paste, for Emacs commands that make
use of these selections.  This section documents the low-level functions
for reading and setting window-system selections.

 -- Command: gui-set-selection type data
     This function sets a window-system selection.  It takes two
     arguments: a selection type TYPE, and the value to assign to it,
     DATA.

     TYPE should be a symbol; it is usually one of 'PRIMARY',
     'SECONDARY' or 'CLIPBOARD'.  These are symbols with upper-case
     names, in accord with X Window System conventions.  If TYPE is
     'nil', that stands for 'PRIMARY'.

     If DATA is 'nil', it means to clear out the selection.  Otherwise,
     DATA may be a string, a symbol, an integer (or a cons of two
     integers or list of two integers), an overlay, or a cons of two
     markers pointing to the same buffer.  An overlay or a pair of
     markers stands for text in the overlay or between the markers.  The
     argument DATA may also be a vector of valid non-vector selection
     values.

     This function returns DATA.

 -- Function: gui-get-selection &optional type data-type
     This function accesses selections set up by Emacs or by other
     programs.  It takes two optional arguments, TYPE and DATA-TYPE.
     The default for TYPE, the selection type, is 'PRIMARY'.

     The DATA-TYPE argument specifies the form of data conversion to
     use, to convert the raw data obtained from another program into
     Lisp data.  Meaningful values include 'TEXT', 'STRING',
     'UTF8_STRING', 'TARGETS', 'LENGTH', 'DELETE', 'FILE_NAME',
     'CHARACTER_POSITION', 'NAME', 'LINE_NUMBER', 'COLUMN_NUMBER',
     'OWNER_OS', 'HOST_NAME', 'USER', 'CLASS', 'ATOM', and 'INTEGER'.
     (These are symbols with upper-case names in accord with X
     conventions.)  The default for DATA-TYPE is 'STRING'.  Window
     systems other than X usually support only a small subset of these
     types, in addition to 'STRING'.

 -- User Option: selection-coding-system
     This variable specifies the coding system to use when reading and
     writing selections or the clipboard.  *Note Coding Systems::.  The
     default is 'compound-text-with-extensions', which converts to the
     text representation that X11 normally uses.

   When Emacs runs on MS-Windows, it does not implement X selections in
general, but it does support the clipboard.  'gui-get-selection' and
'gui-set-selection' on MS-Windows support the text data type only; if
the clipboard holds other types of data, Emacs treats the clipboard as
empty.  The supported data type is 'STRING'.

   For backward compatibility, there are obsolete aliases
'x-get-selection' and 'x-set-selection', which were the names of
'gui-get-selection' and 'gui-set-selection' before Emacs 25.1.

==============================================================================
File: elisp.info,  Node: |Drag_and_Drop|,  Next: |Color_Names|,  Prev: |Window_System_Selections|,  Up: |Frames|
==============================================================================

                                                                 *Drag_and_Drop*

29.21 Drag and Drop
-------------------

When a user drags something from another application over Emacs, that
other application expects Emacs to tell it if Emacs can handle the data
that is dragged.  The variable 'x-dnd-test-function' is used by Emacs to
determine what to reply.  The default value is
'x-dnd-default-test-function' which accepts drops if the type of the
data to be dropped is present in 'x-dnd-known-types'.  You can customize
'x-dnd-test-function' and/or 'x-dnd-known-types' if you want Emacs to
accept or reject drops based on some other criteria.

   If you want to change the way Emacs handles drop of different types
or add a new type, customize 'x-dnd-types-alist'.  This requires
detailed knowledge of what types other applications use for drag and
drop.

   When an URL is dropped on Emacs it may be a file, but it may also be
another URL type (https, etc.).  Emacs first checks 'dnd-protocol-alist'
to determine what to do with the URL.  If there is no match there and if
'browse-url-browser-function' is an alist, Emacs looks for a match
there.  If no match is found the text for the URL is inserted.  If you
want to alter Emacs behavior, you can customize these variables.

==============================================================================
File: elisp.info,  Node: |Color_Names|,  Next: |Text_Terminal_Colors|,  Prev: |Drag_and_Drop|,  Up: |Frames|
==============================================================================

                                                                   *Color_Names*

29.22 Color Names
-----------------

A color name is text (usually in a string) that specifies a color.
Symbolic names such as 'black', 'white', 'red', etc., are allowed; use
'M-x list-colors-display' to see a list of defined names.  You can also
specify colors numerically in forms such as '#RGB' and 'RGB:R/G/B',
where R specifies the red level, G specifies the green level, and B
specifies the blue level.  You can use either one, two, three, or four
hex digits for R; then you must use the same number of hex digits for
all G and B as well, making either 3, 6, 9 or 12 hex digits in all.
(See the documentation of the X Window System for more details about
numerical RGB specification of colors.)

   These functions provide a way to determine which color names are
valid, and what they look like.  In some cases, the value depends on the
"selected frame", as described below; see *note Input Focus::, for the
meaning of the term "selected frame".

   To read user input of color names with completion, use 'read-color'
(*note read-color: High-Level Completion.).

 -- Function: color-defined-p color &optional frame
     This function reports whether a color name is meaningful.  It
     returns 't' if so; otherwise, 'nil'.  The argument FRAME says which
     frame's display to ask about; if FRAME is omitted or 'nil', the
     selected frame is used.

     Note that this does not tell you whether the display you are using
     really supports that color.  When using X, you can ask for any
     defined color on any kind of display, and you will get some
     result--typically, the closest it can do.  To determine whether a
     frame can really display a certain color, use 'color-supported-p'
     (see below).

     This function used to be called 'x-color-defined-p', and that name
     is still supported as an alias.

 -- Function: defined-colors &optional frame
     This function returns a list of the color names that are defined
     and supported on frame FRAME (default, the selected frame).  If
     FRAME does not support colors, the value is 'nil'.

     This function used to be called 'x-defined-colors', and that name
     is still supported as an alias.

 -- Function: color-supported-p color &optional frame background-p
     This returns 't' if FRAME can really display the color COLOR (or at
     least something close to it).  If FRAME is omitted or 'nil', the
     question applies to the selected frame.

     Some terminals support a different set of colors for foreground and
     background.  If BACKGROUND-P is non-'nil', that means you are
     asking whether COLOR can be used as a background; otherwise you are
     asking whether it can be used as a foreground.

     The argument COLOR must be a valid color name.

 -- Function: color-gray-p color &optional frame
     This returns 't' if COLOR is a shade of gray, as defined on FRAME's
     display.  If FRAME is omitted or 'nil', the question applies to the
     selected frame.  If COLOR is not a valid color name, this function
     returns 'nil'.

 -- Function: color-values color &optional frame
     This function returns a value that describes what COLOR should
     ideally look like on FRAME.  If COLOR is defined, the value is a
     list of three integers, which give the amount of red, the amount of
     green, and the amount of blue.  Each integer ranges in principle
     from 0 to 65535, but some displays may not use the full range.
     This three-element list is called the "rgb values" of the color.

     If COLOR is not defined, the value is 'nil'.

          (color-values "black")
               => (0 0 0)
          (color-values "white")
               => (65280 65280 65280)
          (color-values "red")
               => (65280 0 0)
          (color-values "pink")
               => (65280 49152 51968)
          (color-values "hungry")
               => nil

     The color values are returned for FRAME's display.  If FRAME is
     omitted or 'nil', the information is returned for the selected
     frame's display.  If the frame cannot display colors, the value is
     'nil'.

     This function used to be called 'x-color-values', and that name is
     still supported as an alias.

==============================================================================
File: elisp.info,  Node: |Text_Terminal_Colors|,  Next: |Resources|,  Prev: |Color_Names|,  Up: |Frames|
==============================================================================

                                                          *Text_Terminal_Colors*

29.23 Text Terminal Colors
--------------------------

Text terminals usually support only a small number of colors, and the
computer uses small integers to select colors on the terminal.  This
means that the computer cannot reliably tell what the selected color
looks like; instead, you have to inform your application which small
integers correspond to which colors.  However, Emacs does know the
standard set of colors and will try to use them automatically.

   The functions described in this section control how terminal colors
are used by Emacs.

   Several of these functions use or return "rgb values", described in
*note Color Names::.

   These functions accept a display (either a frame or the name of a
terminal) as an optional argument.  We hope in the future to make Emacs
support different colors on different text terminals; then this argument
will specify which terminal to operate on (the default being the
selected frame's terminal; *note Input Focus::).  At present, though,
the FRAME argument has no effect.

 -- Function: tty-color-define name number &optional rgb frame
     This function associates the color name NAME with color number
     NUMBER on the terminal.

     The optional argument RGB, if specified, is an rgb value, a list of
     three numbers that specify what the color actually looks like.  If
     you do not specify RGB, then this color cannot be used by
     'tty-color-approximate' to approximate other colors, because Emacs
     will not know what it looks like.

 -- Function: tty-color-clear &optional frame
     This function clears the table of defined colors for a text
     terminal.

 -- Function: tty-color-alist &optional frame
     This function returns an alist recording the known colors supported
     by a text terminal.

     Each element has the form '(NAME NUMBER . RGB)' or '(NAME NUMBER)'.
     Here, NAME is the color name, NUMBER is the number used to specify
     it to the terminal.  If present, RGB is a list of three color
     values (for red, green, and blue) that says what the color actually
     looks like.

 -- Function: tty-color-approximate rgb &optional frame
     This function finds the closest color, among the known colors
     supported for DISPLAY, to that described by the rgb value RGB (a
     list of color values).  The return value is an element of
     'tty-color-alist'.

 -- Function: tty-color-translate color &optional frame
     This function finds the closest color to COLOR among the known
     colors supported for DISPLAY and returns its index (an integer).
     If the name COLOR is not defined, the value is 'nil'.

==============================================================================
File: elisp.info,  Node: |Resources|,  Next: |Display_Feature_Testing|,  Prev: |Text_Terminal_Colors|,  Up: |Frames|
==============================================================================

                                                                     *Resources*

29.24 X Resources
-----------------

This section describes some of the functions and variables for querying
and using X resources, or their equivalent on your operating system.
*Note X Resources: (emacs)X Resources, for more information about X
resources.

 -- Function: x-get-resource attribute class &optional component
          subclass
     The function 'x-get-resource' retrieves a resource value from the X
     Window defaults database.

     Resources are indexed by a combination of a "key" and a "class".
     This function searches using a key of the form 'INSTANCE.ATTRIBUTE'
     (where INSTANCE is the name under which Emacs was invoked), and
     using 'Emacs.CLASS' as the class.

     The optional arguments COMPONENT and SUBCLASS add to the key and
     the class, respectively.  You must specify both of them or neither.
     If you specify them, the key is 'INSTANCE.COMPONENT.ATTRIBUTE', and
     the class is 'Emacs.CLASS.SUBCLASS'.

 -- Variable: x-resource-class
     This variable specifies the application name that 'x-get-resource'
     should look up.  The default value is '"Emacs"'.  You can examine X
     resources for other application names by binding this variable to
     some other string, around a call to 'x-get-resource'.

 -- Variable: x-resource-name
     This variable specifies the instance name that 'x-get-resource'
     should look up.  The default value is the name Emacs was invoked
     with, or the value specified with the '-name' or '-rn' switches.

   To illustrate some of the above, suppose that you have the line:

     xterm.vt100.background: yellow

in your X resources file (whose name is usually '~/.Xdefaults' or
'~/.Xresources').  Then:

     (let ((x-resource-class "XTerm") (x-resource-name "xterm"))
       (x-get-resource "vt100.background" "VT100.Background"))
          => "yellow"
     (let ((x-resource-class "XTerm") (x-resource-name "xterm"))
       (x-get-resource "background" "VT100" "vt100" "Background"))
          => "yellow"

 -- Variable: inhibit-x-resources
     If this variable is non-'nil', Emacs does not look up X resources,
     and X resources do not have any effect when creating new frames.

==============================================================================
File: elisp.info,  Node: |Display_Feature_Testing|,  Prev: |Resources|,  Up: |Frames|
==============================================================================

                                                       *Display_Feature_Testing*

29.25 Display Feature Testing
-----------------------------

The functions in this section describe the basic capabilities of a
particular display.  Lisp programs can use them to adapt their behavior
to what the display can do.  For example, a program that ordinarily uses
a popup menu could use the minibuffer if popup menus are not supported.

   The optional argument DISPLAY in these functions specifies which
display to ask the question about.  It can be a display name, a frame
(which designates the display that frame is on), or 'nil' (which refers
to the selected frame's display, *note Input Focus::).

   *Note Color Names::, *note Text Terminal Colors::, for other
functions to obtain information about displays.

 -- Function: display-popup-menus-p &optional display
     This function returns 't' if popup menus are supported on DISPLAY,
     'nil' if not.  Support for popup menus requires that the mouse be
     available, since the menu is popped up by clicking the mouse on
     some portion of the Emacs display.

 -- Function: display-graphic-p &optional display
     This function returns 't' if DISPLAY is a graphic display capable
     of displaying several frames and several different fonts at once.
     This is true for displays that use a window system such as X, and
     false for text terminals.

 -- Function: display-mouse-p &optional display
     This function returns 't' if DISPLAY has a mouse available, 'nil'
     if not.

 -- Function: display-color-p &optional display
     This function returns 't' if the screen is a color screen.  It used
     to be called 'x-display-color-p', and that name is still supported
     as an alias.

 -- Function: display-grayscale-p &optional display
     This function returns 't' if the screen can display shades of gray.
     (All color displays can do this.)

 -- Function: display-supports-face-attributes-p attributes &optional
          display
     This function returns non-'nil' if all the face attributes in
     ATTRIBUTES are supported (*note Face Attributes::).

     The definition of "supported" is somewhat heuristic, but basically
     means that a face containing all the attributes in ATTRIBUTES, when
     merged with the default face for display, can be represented in a
     way that's

       1. different in appearance than the default face, and

       2. close in spirit to what the attributes specify, if not exact.

     Point (2) implies that a ':weight black' attribute will be
     satisfied by any display that can display bold, as will
     ':foreground "yellow"' as long as some yellowish color can be
     displayed, but ':slant italic' will _not_ be satisfied by the tty
     display code's automatic substitution of a dim face for italic.

 -- Function: display-selections-p &optional display
     This function returns 't' if DISPLAY supports selections.  Windowed
     displays normally support selections, but they may also be
     supported in some other cases.

 -- Function: display-images-p &optional display
     This function returns 't' if DISPLAY can display images.  Windowed
     displays ought in principle to handle images, but some systems lack
     the support for that.  On a display that does not support images,
     Emacs cannot display a tool bar.

 -- Function: display-screens &optional display
     This function returns the number of screens associated with the
     display.

 -- Function: display-pixel-height &optional display
     This function returns the height of the screen in pixels.  On a
     character terminal, it gives the height in characters.

     For graphical terminals, note that on multi-monitor setups this
     refers to the pixel height for all physical monitors associated
     with DISPLAY.  *Note Multiple Terminals::.

 -- Function: display-pixel-width &optional display
     This function returns the width of the screen in pixels.  On a
     character terminal, it gives the width in characters.

     For graphical terminals, note that on multi-monitor setups this
     refers to the pixel width for all physical monitors associated with
     DISPLAY.  *Note Multiple Terminals::.

 -- Function: display-mm-height &optional display
     This function returns the height of the screen in millimeters, or
     'nil' if Emacs cannot get that information.

     For graphical terminals, note that on multi-monitor setups this
     refers to the height for all physical monitors associated with
     DISPLAY.  *Note Multiple Terminals::.

 -- Function: display-mm-width &optional display
     This function returns the width of the screen in millimeters, or
     'nil' if Emacs cannot get that information.

     For graphical terminals, note that on multi-monitor setups this
     refers to the width for all physical monitors associated with
     DISPLAY.  *Note Multiple Terminals::.

 -- User Option: display-mm-dimensions-alist
     This variable allows the user to specify the dimensions of
     graphical displays returned by 'display-mm-height' and
     'display-mm-width' in case the system provides incorrect values.

 -- Function: display-backing-store &optional display
     This function returns the backing store capability of the display.
     Backing store means recording the pixels of windows (and parts of
     windows) that are not exposed, so that when exposed they can be
     displayed very quickly.

     Values can be the symbols 'always', 'when-mapped', or 'not-useful'.
     The function can also return 'nil' when the question is
     inapplicable to a certain kind of display.

 -- Function: display-save-under &optional display
     This function returns non-'nil' if the display supports the
     SaveUnder feature.  That feature is used by pop-up windows to save
     the pixels they obscure, so that they can pop down quickly.

 -- Function: display-planes &optional display
     This function returns the number of planes the display supports.
     This is typically the number of bits per pixel.  For a tty display,
     it is log to base two of the number of colors supported.

 -- Function: display-visual-class &optional display
     This function returns the visual class for the screen.  The value
     is one of the symbols 'static-gray' (a limited, unchangeable number
     of grays), 'gray-scale' (a full range of grays), 'static-color' (a
     limited, unchangeable number of colors), 'pseudo-color' (a limited
     number of colors), 'true-color' (a full range of colors), and
     'direct-color' (a full range of colors).

 -- Function: display-color-cells &optional display
     This function returns the number of color cells the screen
     supports.

   These functions obtain additional information about the window system
in use where Emacs shows the specified DISPLAY.  (Their names begin with
'x-' for historical reasons.)

 -- Function: x-server-version &optional display
     This function returns the list of version numbers of the GUI window
     system running on DISPLAY, such as the X server on GNU and Unix
     systems.  The value is a list of three integers: the major and
     minor version numbers of the protocol, and the distributor-specific
     release number of the window system software itself.  On GNU and
     Unix systems, these are normally the version of the X protocol and
     the distributor-specific release number of the X server software.
     On MS-Windows, this is the version of the Windows OS.

 -- Function: x-server-vendor &optional display
     This function returns the vendor that provided the window system
     software (as a string).  On GNU and Unix systems this really means
     whoever distributes the X server.  On MS-Windows this is the vendor
     ID string of the Windows OS (Microsoft).

     When the developers of X labeled software distributors as
     "vendors", they showed their false assumption that no system could
     ever be developed and distributed noncommercially.

==============================================================================
File: elisp.info,  Node: |Positions|,  Next: |Markers|,  Prev: |Frames|,  Up: |Top|
==============================================================================

                                                                     *Positions*

30 Positions
============

A "position" is the index of a character in the text of a buffer.  More
precisely, a position identifies the place between two characters (or
before the first character, or after the last character), so we can
speak of the character before or after a given position.  However, we
often speak of the character "at" a position, meaning the character
after that position.

   Positions are usually represented as integers starting from 1, but
can also be represented as "markers"--special objects that relocate
automatically when text is inserted or deleted so they stay with the
surrounding characters.  Functions that expect an argument to be a
position (an integer), but accept a marker as a substitute, normally
ignore which buffer the marker points into; they convert the marker to
an integer, and use that integer, exactly as if you had passed the
integer as the argument, even if the marker points to the wrong buffer.
A marker that points nowhere cannot convert to an integer; using it
instead of an integer causes an error.  *Note Markers::.

   See also the field feature (*note Fields::), which provides functions
that are used by many cursor-motion commands.

MENU

* |Point|::         The special position where editing takes place.
* |Motion|::        Changing point.
* |Excursions|::    Temporary motion and buffer changes.
* |Narrowing|::     Restricting editing to a portion of the buffer.

==============================================================================
File: elisp.info,  Node: |Point|,  Next: |Motion|,  Up: |Positions|
==============================================================================

                                                                         *Point*

30.1 Point
----------

"Point" is a special buffer position used by many editing commands,
including the self-inserting typed characters and text insertion
functions.  Other commands move point through the text to allow editing
and insertion at different places.

   Like other positions, point designates a place between two characters
(or before the first character, or after the last character), rather
than a particular character.  Usually terminals display the cursor over
the character that immediately follows point; point is actually before
the character on which the cursor sits.

   The value of point is a number no less than 1, and no greater than
the buffer size plus 1.  If narrowing is in effect (*note Narrowing::),
then point is constrained to fall within the accessible portion of the
buffer (possibly at one end of it).

   Each buffer has its own value of point, which is independent of the
value of point in other buffers.  Each window also has a value of point,
which is independent of the value of point in other windows on the same
buffer.  This is why point can have different values in various windows
that display the same buffer.  When a buffer appears in only one window,
the buffer's point and the window's point normally have the same value,
so the distinction is rarely important.  *Note Window Point::, for more
details.

 -- Function: point
     This function returns the value of point in the current buffer, as
     an integer.

          (point)
               => 175

 -- Function: point-min
     This function returns the minimum accessible value of point in the
     current buffer.  This is normally 1, but if narrowing is in effect,
     it is the position of the start of the region that you narrowed to.
     (*Note Narrowing::.)

 -- Function: point-max
     This function returns the maximum accessible value of point in the
     current buffer.  This is '(1+ (buffer-size))', unless narrowing is
     in effect, in which case it is the position of the end of the
     region that you narrowed to.  (*Note Narrowing::.)

 -- Function: buffer-end flag
     This function returns '(point-max)' if FLAG is greater than 0,
     '(point-min)' otherwise.  The argument FLAG must be a number.

 -- Function: buffer-size &optional buffer
     This function returns the total number of characters in the current
     buffer.  In the absence of any narrowing (*note Narrowing::),
     'point-max' returns a value one larger than this.

     If you specify a buffer, BUFFER, then the value is the size of
     BUFFER.

          (buffer-size)
               => 35
          (point-max)
               => 36

==============================================================================
File: elisp.info,  Node: |Motion|,  Next: |Excursions|,  Prev: |Point|,  Up: |Positions|
==============================================================================

                                                                        *Motion*

30.2 Motion
-----------

Motion functions change the value of point, either relative to the
current value of point, relative to the beginning or end of the buffer,
or relative to the edges of the selected window.  *Note Point::.

MENU

* |Character_Motion|::       Moving in terms of characters.
* |Word_Motion|::            Moving in terms of words.
* |Buffer_End_Motion|::      Moving to the beginning or end of the buffer.
* |Text_Lines|::             Moving in terms of lines of text.
* |Screen_Lines|::           Moving in terms of lines as displayed.
* |List_Motion|::            Moving by parsing lists and sexps.
* |Skipping_Characters|::    Skipping characters belonging to a certain set.

==============================================================================
File: elisp.info,  Node: |Character_Motion|,  Next: |Word_Motion|,  Up: |Motion|
==============================================================================

                                                              *Character_Motion*

30.2.1 Motion by Characters
---------------------------

These functions move point based on a count of characters.  'goto-char'
is the fundamental primitive; the other functions use that.

 -- Command: goto-char position
     This function sets point in the current buffer to the value
     POSITION.

     If narrowing is in effect, POSITION still counts from the beginning
     of the buffer, but point cannot go outside the accessible portion.
     If POSITION is out of range, 'goto-char' moves point to the
     beginning or the end of the accessible portion.

     When this function is called interactively, POSITION is the numeric
     prefix argument, if provided; otherwise it is read from the
     minibuffer.

     'goto-char' returns POSITION.

 -- Command: forward-char &optional count
     This function moves point COUNT characters forward, towards the end
     of the buffer (or backward, towards the beginning of the buffer, if
     COUNT is negative).  If COUNT is 'nil', the default is 1.

     If this attempts to move past the beginning or end of the buffer
     (or the limits of the accessible portion, when narrowing is in
     effect), it signals an error with error symbol
     'beginning-of-buffer' or 'end-of-buffer'.

     In an interactive call, COUNT is the numeric prefix argument.

 -- Command: backward-char &optional count
     This is just like 'forward-char' except that it moves in the
     opposite direction.

==============================================================================
File: elisp.info,  Node: |Word_Motion|,  Next: |Buffer_End_Motion|,  Prev: |Character_Motion|,  Up: |Motion|
==============================================================================

                                                                   *Word_Motion*

30.2.2 Motion by Words
----------------------

The functions for parsing words described below use the syntax table and
'char-script-table' to decide whether a given character is part of a
word.  *Note Syntax Tables::, and see *note Character Properties::.

 -- Command: forward-word &optional count
     This function moves point forward COUNT words (or backward if COUNT
     is negative).  If COUNT is omitted or 'nil', it defaults to 1.  In
     an interactive call, COUNT is specified by the numeric prefix
     argument.

     "Moving one word" means moving until point crosses a
     word-constituent character, which indicates the beginning of a
     word, and then continue moving until the word ends.  By default,
     characters that begin and end words, known as "word boundaries",
     are defined by the current buffer's syntax table (*note Syntax
     Class Table::), but modes can override that by setting up a
     suitable 'find-word-boundary-function-table', described below.
     Characters that belong to different scripts (as defined by
     'char-script-table'), also define a word boundary (*note Character
     Properties::).  In any case, this function cannot move point past
     the boundary of the accessible portion of the buffer, or across a
     field boundary (*note Fields::).  The most common case of a field
     boundary is the end of the prompt in the minibuffer.

     If it is possible to move COUNT words, without being stopped
     prematurely by the buffer boundary or a field boundary, the value
     is 't'.  Otherwise, the return value is 'nil' and point stops at
     the buffer boundary or field boundary.

     If 'inhibit-field-text-motion' is non-'nil', this function ignores
     field boundaries.

 -- Command: backward-word &optional count
     This function is just like 'forward-word', except that it moves
     backward until encountering the front of a word, rather than
     forward.

 -- User Option: words-include-escapes
     This variable affects the behavior of 'forward-word' and
     'backward-word', and everything that uses them.  If it is
     non-'nil', then characters in the escape and character-quote syntax
     classes count as part of words.  Otherwise, they do not.

 -- Variable: inhibit-field-text-motion
     If this variable is non-'nil', certain motion functions including
     'forward-word', 'forward-sentence', and 'forward-paragraph' ignore
     field boundaries.

 -- Variable: find-word-boundary-function-table
     This variable affects the behavior of 'forward-word' and
     'backward-word', and everything that uses them.  Its value is a
     char-table (*note Char-Tables::) of functions to search for word
     boundaries.  If a character has a non-'nil' entry in this table,
     then when a word starts or ends with that character, the
     corresponding function will be called with 2 arguments: POS and
     LIMIT.  The function should return the position of the other word
     boundary.  Specifically, if POS is smaller than LIMIT, then POS is
     at the beginning of a word, and the function should return the
     position after the last character of the word; otherwise, POS is at
     the last character of a word, and the function should return the
     position of that word's first character.

 -- Function: forward-word-strictly &optional count
     This function is like 'forward-word', but it is not affected by
     'find-word-boundary-function-table'.  Lisp programs that should not
     change behavior when word movement is modified by modes which set
     that table, such as 'subword-mode', should use this function
     instead of 'forward-word'.

 -- Function: backward-word-strictly &optional count
     This function is like 'backward-word', but it is not affected by
     'find-word-boundary-function-table'.  Like with
     'forward-word-strictly', use this function instead of
     'backward-word' when movement by words should only consider syntax
     tables.

==============================================================================
File: elisp.info,  Node: |Buffer_End_Motion|,  Next: |Text_Lines|,  Prev: |Word_Motion|,  Up: |Motion|
==============================================================================

                                                             *Buffer_End_Motion*

30.2.3 Motion to an End of the Buffer
-------------------------------------

To move point to the beginning of the buffer, write:

     (goto-char (point-min))

Likewise, to move to the end of the buffer, use:

     (goto-char (point-max))

   Here are two commands that users use to do these things.  They are
documented here to warn you not to use them in Lisp programs, because
they set the mark and display messages in the echo area.

 -- Command: beginning-of-buffer &optional n
     This function moves point to the beginning of the buffer (or the
     limits of the accessible portion, when narrowing is in effect),
     setting the mark at the previous position (except in Transient Mark
     mode, if the mark is already active, it does not set the mark.)

     If N is non-'nil', then it puts point N tenths of the way from the
     beginning of the accessible portion of the buffer.  In an
     interactive call, N is the numeric prefix argument, if provided;
     otherwise N defaults to 'nil'.

     Warning: Don't use this function in Lisp programs!

 -- Command: end-of-buffer &optional n
     This function moves point to the end of the buffer (or the limits
     of the accessible portion, when narrowing is in effect), setting
     the mark at the previous position (except in Transient Mark mode
     when the mark is already active).  If N is non-'nil', then it puts
     point N tenths of the way from the end of the accessible portion of
     the buffer.

     In an interactive call, N is the numeric prefix argument, if
     provided; otherwise N defaults to 'nil'.

     Warning: Don't use this function in Lisp programs!

==============================================================================
File: elisp.info,  Node: |Text_Lines|,  Next: |Screen_Lines|,  Prev: |Buffer_End_Motion|,  Up: |Motion|
==============================================================================

                                                                    *Text_Lines*

30.2.4 Motion by Text Lines
---------------------------

Text lines are portions of the buffer delimited by newline characters,
which are regarded as part of the previous line.  The first text line
begins at the beginning of the buffer, and the last text line ends at
the end of the buffer whether or not the last character is a newline.
The division of the buffer into text lines is not affected by the width
of the window, by line continuation in display, or by how tabs and
control characters are displayed.

 -- Command: beginning-of-line &optional count
     This function moves point to the beginning of the current line.
     With an argument COUNT not 'nil' or 1, it moves forward COUNT-1
     lines and then to the beginning of the line.

     This function does not move point across a field boundary (*note
     Fields::) unless doing so would move beyond there to a different
     line; therefore, if COUNT is 'nil' or 1, and point starts at a
     field boundary, point does not move.  To ignore field boundaries,
     either bind 'inhibit-field-text-motion' to 't', or use the
     'forward-line' function instead.  For instance, '(forward-line 0)'
     does the same thing as '(beginning-of-line)', except that it
     ignores field boundaries.

     If this function reaches the end of the buffer (or of the
     accessible portion, if narrowing is in effect), it positions point
     there.  No error is signaled.

 -- Function: line-beginning-position &optional count
     Return the position that '(beginning-of-line COUNT)' would move to.

 -- Command: end-of-line &optional count
     This function moves point to the end of the current line.  With an
     argument COUNT not 'nil' or 1, it moves forward COUNT-1 lines and
     then to the end of the line.

     This function does not move point across a field boundary (*note
     Fields::) unless doing so would move beyond there to a different
     line; therefore, if COUNT is 'nil' or 1, and point starts at a
     field boundary, point does not move.  To ignore field boundaries,
     bind 'inhibit-field-text-motion' to 't'.

     If this function reaches the end of the buffer (or of the
     accessible portion, if narrowing is in effect), it positions point
     there.  No error is signaled.

 -- Function: line-end-position &optional count
     Return the position that '(end-of-line COUNT)' would move to.

 -- Command: forward-line &optional count
     This function moves point forward COUNT lines, to the beginning of
     the line following that.  If COUNT is negative, it moves point
     -COUNT lines backward, to the beginning of a line preceding that.
     If COUNT is zero, it moves point to the beginning of the current
     line.  If COUNT is 'nil', that means 1.

     If 'forward-line' encounters the beginning or end of the buffer (or
     of the accessible portion) before finding that many lines, it sets
     point there.  No error is signaled.

     'forward-line' returns the difference between COUNT and the number
     of lines actually moved.  If you attempt to move down five lines
     from the beginning of a buffer that has only three lines, point
     stops at the end of the last line, and the value will be 2.  As an
     explicit exception, if the last accessible line is non-empty, but
     has no newline (e.g., if the buffer ends without a newline), the
     function sets point to the end of that line, and the value returned
     by the function counts that line as one line successfully moved.

     In an interactive call, COUNT is the numeric prefix argument.

 -- Function: count-lines start end
     This function returns the number of lines between the positions
     START and END in the current buffer.  If START and END are equal,
     then it returns 0.  Otherwise it returns at least 1, even if START
     and END are on the same line.  This is because the text between
     them, considered in isolation, must contain at least one line
     unless it is empty.

 -- Command: count-words start end
     This function returns the number of words between the positions
     START and END in the current buffer.

     This function can also be called interactively.  In that case, it
     prints a message reporting the number of lines, words, and
     characters in the buffer, or in the region if the region is active.

 -- Function: line-number-at-pos &optional pos absolute
     This function returns the line number in the current buffer
     corresponding to the buffer position POS.  If POS is 'nil' or
     omitted, the current buffer position is used.  If ABSOLUTE is
     'nil', the default, counting starts at '(point-min)', so the value
     refers to the contents of the accessible portion of the
     (potentially narrowed) buffer.  If ABSOLUTE is non-'nil', ignore
     any narrowing and return the absolute line number.

   Also see the functions 'bolp' and 'eolp' in *note Near Point::.
These functions do not move point, but test whether it is already at the
beginning or end of a line.

==============================================================================
File: elisp.info,  Node: |Screen_Lines|,  Next: |List_Motion|,  Prev: |Text_Lines|,  Up: |Motion|
==============================================================================

                                                                  *Screen_Lines*

30.2.5 Motion by Screen Lines
-----------------------------

The line functions in the previous section count text lines, delimited
only by newline characters.  By contrast, these functions count screen
lines, which are defined by the way the text appears on the screen.  A
text line is a single screen line if it is short enough to fit the width
of the selected window, but otherwise it may occupy several screen
lines.

   In some cases, text lines are truncated on the screen rather than
continued onto additional screen lines.  In these cases,
'vertical-motion' moves point much like 'forward-line'.  *Note
Truncation::.

   Because the width of a given string depends on the flags that control
the appearance of certain characters, 'vertical-motion' behaves
differently, for a given piece of text, depending on the buffer it is
in, and even on the selected window (because the width, the truncation
flag, and display table may vary between windows).  *Note Usual
Display::.

   These functions scan text to determine where screen lines break, and
thus take time proportional to the distance scanned.

 -- Function: vertical-motion count &optional window cur-col
     This function moves point to the start of the screen line COUNT
     screen lines down from the screen line containing point.  If COUNT
     is negative, it moves up instead.

     The COUNT argument can be a cons cell, '(COLS . LINES)', instead of
     an integer.  Then the function moves by LINES screen lines, and
     puts point COLS columns from the visual start of that screen line.
     Note that COLS are counted from the _visual_ start of the line; if
     the window is scrolled horizontally (*note Horizontal Scrolling::),
     the column on which point will end is in addition to the number of
     columns by which the text is scrolled.

     The return value is the number of screen lines over which point was
     moved.  The value may be less in absolute value than COUNT if the
     beginning or end of the buffer was reached.

     The window WINDOW is used for obtaining parameters such as the
     width, the horizontal scrolling, and the display table.  But
     'vertical-motion' always operates on the current buffer, even if
     WINDOW currently displays some other buffer.

     The optional argument CUR-COL specifies the current column when the
     function is called.  This is the window-relative horizontal
     coordinate of point, measured in units of font width of the frame's
     default face.  Providing it speeds up the function, especially in
     very long lines, because the function doesn't have to go back in
     the buffer in order to determine the current column.  Note that
     CUR-COL is also counted from the visual start of the line.

 -- Function: count-screen-lines &optional beg end count-final-newline
          window
     This function returns the number of screen lines in the text from
     BEG to END.  The number of screen lines may be different from the
     number of actual lines, due to line continuation, the display
     table, etc.  If BEG and END are 'nil' or omitted, they default to
     the beginning and end of the accessible portion of the buffer.

     If the region ends with a newline, that is ignored unless the
     optional third argument COUNT-FINAL-NEWLINE is non-'nil'.

     The optional fourth argument WINDOW specifies the window for
     obtaining parameters such as width, horizontal scrolling, and so
     on.  The default is to use the selected window's parameters.

     Like 'vertical-motion', 'count-screen-lines' always uses the
     current buffer, regardless of which buffer is displayed in WINDOW.
     This makes possible to use 'count-screen-lines' in any buffer,
     whether or not it is currently displayed in some window.

 -- Command: move-to-window-line count
     This function moves point with respect to the text currently
     displayed in the selected window.  It moves point to the beginning
     of the screen line COUNT screen lines from the top of the window;
     zero means the topmost line.  If COUNT is negative, that specifies
     a position -COUNT lines from the bottom (or the last line of the
     buffer, if the buffer ends above the specified screen position);
     thus, COUNT of -1 specifies the last fully visible screen line of
     the window.

     If COUNT is 'nil', then point moves to the beginning of the line in
     the middle of the window.  If the absolute value of COUNT is
     greater than the size of the window, then point moves to the place
     that would appear on that screen line if the window were tall
     enough.  This will probably cause the next redisplay to scroll to
     bring that location onto the screen.

     In an interactive call, COUNT is the numeric prefix argument.

     The value returned is the screen line number point has moved to,
     relative to the top line of the window.

 -- Function: move-to-window-group-line count
     This function is like 'move-to-window-line', except that when the
     selected window is a part of a group of windows (*note Window
     Group::), 'move-to-window-group-line' will move to a position with
     respect to the entire group, not just the single window.  This
     condition holds when the buffer local variable
     'move-to-window-group-line-function' is set to a function.  In this
     case, 'move-to-window-group-line' calls the function with the
     argument COUNT, then returns its result.

 -- Function: compute-motion from frompos to topos width offsets window
     This function scans the current buffer, calculating screen
     positions.  It scans the buffer forward from position FROM,
     assuming that is at screen coordinates FROMPOS, to position TO or
     coordinates TOPOS, whichever comes first.  It returns the ending
     buffer position and screen coordinates.

     The coordinate arguments FROMPOS and TOPOS are cons cells of the
     form '(HPOS . VPOS)'.

     The argument WIDTH is the number of columns available to display
     text; this affects handling of continuation lines.  'nil' means the
     actual number of usable text columns in the window, which is
     equivalent to the value returned by '(window-width window)'.

     The argument OFFSETS is either 'nil' or a cons cell of the form
     '(HSCROLL . TAB-OFFSET)'.  Here HSCROLL is the number of columns
     not being displayed at the left margin; most callers get this by
     calling 'window-hscroll'.  Meanwhile, TAB-OFFSET is the offset
     between column numbers on the screen and column numbers in the
     buffer.  This can be nonzero in a continuation line, when the
     previous screen lines' widths do not add up to a multiple of
     'tab-width'.  It is always zero in a non-continuation line.

     The window WINDOW serves only to specify which display table to
     use.  'compute-motion' always operates on the current buffer,
     regardless of what buffer is displayed in WINDOW.

     The return value is a list of five elements:

          (POS HPOS VPOS PREVHPOS CONTIN)

     Here POS is the buffer position where the scan stopped, VPOS is the
     vertical screen position, and HPOS is the horizontal screen
     position.

     The result PREVHPOS is the horizontal position one character back
     from POS.  The result CONTIN is 't' if the last line was continued
     after (or within) the previous character.

     For example, to find the buffer position of column COL of screen
     line LINE of a certain window, pass the window's display start
     location as FROM and the window's upper-left coordinates as
     FROMPOS.  Pass the buffer's '(point-max)' as TO, to limit the scan
     to the end of the accessible portion of the buffer, and pass LINE
     and COL as TOPOS.  Here's a function that does this:

          (defun coordinates-of-position (col line)
            (car (compute-motion (window-start)
                                 '(0 . 0)
                                 (point-max)
                                 (cons col line)
                                 (window-width)
                                 (cons (window-hscroll) 0)
                                 (selected-window))))

     When you use 'compute-motion' for the minibuffer, you need to use
     'minibuffer-prompt-width' to get the horizontal position of the
     beginning of the first screen line.  *Note Minibuffer Contents::.

==============================================================================
File: elisp.info,  Node: |List_Motion|,  Next: |Skipping_Characters|,  Prev: |Screen_Lines|,  Up: |Motion|
==============================================================================

                                                                   *List_Motion*

30.2.6 Moving over Balanced Expressions
---------------------------------------

Here are several functions concerned with balanced-parenthesis
expressions (also called "sexps" in connection with moving across them
in Emacs).  The syntax table controls how these functions interpret
various characters; see *note Syntax Tables::.  *Note Parsing
Expressions::, for lower-level primitives for scanning sexps or parts of
sexps.  For user-level commands, see *note Commands for Editing with
Parentheses: (emacs)Parentheses.

 -- Command: forward-list &optional arg
     This function moves forward across ARG (default 1) balanced groups
     of parentheses.  (Other syntactic entities such as words or paired
     string quotes are ignored.)

 -- Command: backward-list &optional arg
     This function moves backward across ARG (default 1) balanced groups
     of parentheses.  (Other syntactic entities such as words or paired
     string quotes are ignored.)

 -- Command: up-list &optional arg escape-strings no-syntax-crossing
     This function moves forward out of ARG (default 1) levels of
     parentheses.  A negative argument means move backward but still to
     a less deep spot.  If ESCAPE-STRINGS is non-'nil' (as it is
     interactively), move out of enclosing strings as well.  If
     NO-SYNTAX-CROSSING is non-'nil' (as it is interactively), prefer to
     break out of any enclosing string instead of moving to the start of
     a list broken across multiple strings.  On error, location of point
     is unspecified.

 -- Command: backward-up-list &optional arg escape-strings
          no-syntax-crossing
     This function is just like 'up-list', but with a negated argument.

 -- Command: down-list &optional arg
     This function moves forward into ARG (default 1) levels of
     parentheses.  A negative argument means move backward but still go
     deeper in parentheses (-ARG levels).

 -- Command: forward-sexp &optional arg
     This function moves forward across ARG (default 1) balanced
     expressions.  Balanced expressions include both those delimited by
     parentheses and other kinds, such as words and string constants.
     *Note Parsing Expressions::.  For example,

          ---------- Buffer: foo ----------
          (concat-!- "foo " (car x) y z)
          ---------- Buffer: foo ----------

          (forward-sexp 3)
               => nil

          ---------- Buffer: foo ----------
          (concat "foo " (car x) y-!- z)
          ---------- Buffer: foo ----------

 -- Command: backward-sexp &optional arg
     This function moves backward across ARG (default 1) balanced
     expressions.

 -- Command: beginning-of-defun &optional arg
     This function moves back to the ARGth beginning of a defun.  If ARG
     is negative, this actually moves forward, but it still moves to the
     beginning of a defun, not to the end of one.  ARG defaults to 1.

 -- Command: end-of-defun &optional arg
     This function moves forward to the ARGth end of a defun.  If ARG is
     negative, this actually moves backward, but it still moves to the
     end of a defun, not to the beginning of one.  ARG defaults to 1.

 -- User Option: defun-prompt-regexp
     If non-'nil', this buffer-local variable holds a regular expression
     that specifies what text can appear before the open-parenthesis
     that starts a defun.  That is to say, a defun begins on a line that
     starts with a match for this regular expression, followed by a
     character with open-parenthesis syntax.

 -- User Option: open-paren-in-column-0-is-defun-start
     If this variable's value is non-'nil', an open parenthesis in
     column 0 is considered to be the start of a defun.  If it is 'nil',
     an open parenthesis in column 0 has no special meaning.  The
     default is 't'.  If a string literal happens to have a parenthesis
     in column 0, escape it with a backslash to avoid a false positive.

 -- Variable: beginning-of-defun-function
     If non-'nil', this variable holds a function for finding the
     beginning of a defun.  The function 'beginning-of-defun' calls this
     function instead of using its normal method, passing it its
     optional argument.  If the argument is non-'nil', the function
     should move back by that many functions, like 'beginning-of-defun'
     does.

 -- Variable: end-of-defun-function
     If non-'nil', this variable holds a function for finding the end of
     a defun.  The function 'end-of-defun' calls this function instead
     of using its normal method.

==============================================================================
File: elisp.info,  Node: |Skipping_Characters|,  Prev: |List_Motion|,  Up: |Motion|
==============================================================================

                                                           *Skipping_Characters*

30.2.7 Skipping Characters
--------------------------

The following two functions move point over a specified set of
characters.  For example, they are often used to skip whitespace.  For
related functions, see *note Motion and Syntax::.

   These functions convert the set string to multibyte if the buffer is
multibyte, and they convert it to unibyte if the buffer is unibyte, as
the search functions do (*note Searching and Matching::).

 -- Function: skip-chars-forward character-set &optional limit
     This function moves point in the current buffer forward, skipping
     over a given set of characters.  It examines the character
     following point, then advances point if the character matches
     CHARACTER-SET.  This continues until it reaches a character that
     does not match.  The function returns the number of characters
     moved over.

     The argument CHARACTER-SET is a string, like the inside of a
     '[...]' in a regular expression except that ']' does not terminate
     it, and '\' quotes '^', '-' or '\'.  Thus, '"a-zA-Z"' skips over
     all letters, stopping before the first nonletter, and '"^a-zA-Z"'
     skips nonletters stopping before the first letter (*note Regular
     Expressions::).  Character classes can also be used, e.g.,
     '"[:alnum:]"' (*note Char Classes::).

     If LIMIT is supplied (it must be a number or a marker), it
     specifies the maximum position in the buffer that point can be
     skipped to.  Point will stop at or before LIMIT.

     In the following example, point is initially located directly
     before the 'T'.  After the form is evaluated, point is located at
     the end of that line (between the 't' of 'hat' and the newline).
     The function skips all letters and spaces, but not newlines.

          ---------- Buffer: foo ----------
          I read "-!-The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (skip-chars-forward "a-zA-Z ")
               => 18

          ---------- Buffer: foo ----------
          I read "The cat in the hat-!-
          comes back" twice.
          ---------- Buffer: foo ----------

 -- Function: skip-chars-backward character-set &optional limit
     This function moves point backward, skipping characters that match
     CHARACTER-SET, until LIMIT.  It is just like 'skip-chars-forward'
     except for the direction of motion.

     The return value indicates the distance traveled.  It is an integer
     that is zero or less.

==============================================================================
File: elisp.info,  Node: |Excursions|,  Next: |Narrowing|,  Prev: |Motion|,  Up: |Positions|
==============================================================================

                                                                    *Excursions*

30.3 Excursions
---------------

It is often useful to move point temporarily within a localized portion
of the program.  This is called an "excursion", and it is done with the
'save-excursion' special form.  This construct remembers the initial
identity of the current buffer, and its value of point, and restores
them after the excursion completes.  It is the standard way to move
point within one part of a program and avoid affecting the rest of the
program, and is used thousands of times in the Lisp sources of Emacs.

   If you only need to save and restore the identity of the current
buffer, use 'save-current-buffer' or 'with-current-buffer' instead
(*note Current Buffer::).  If you need to save or restore window
configurations, see the forms described in *note Window Configurations::
and in *note Frame Configurations::.

 -- Special Form: save-excursion body...
     This special form saves the identity of the current buffer and the
     value of point in it, evaluates BODY, and finally restores the
     buffer and its saved value of point.  Both saved values are
     restored even in case of an abnormal exit via 'throw' or error
     (*note Nonlocal Exits::).

     The value returned by 'save-excursion' is the result of the last
     form in BODY, or 'nil' if no body forms were given.

   Because 'save-excursion' only saves point for the buffer that was
current at the start of the excursion, any changes made to point in
other buffers, during the excursion, will remain in effect afterward.
This frequently leads to unintended consequences, so the byte compiler
warns if you call 'set-buffer' during an excursion:

     Warning: Use 'with-current-buffer' rather than
              save-excursion+set-buffer

To avoid such problems, you should call 'save-excursion' only after
setting the desired current buffer, as in the following example:

     (defun append-string-to-buffer (string buffer)
       "Append STRING to the end of BUFFER."
       (with-current-buffer buffer
         (save-excursion
           (goto-char (point-max))
           (insert string))))

   Likewise, 'save-excursion' does not restore window-buffer
correspondences altered by functions such as 'switch-to-buffer'.

   Warning: Ordinary insertion of text adjacent to the saved point
value relocates the saved value, just as it relocates all markers.  More
precisely, the saved value is a marker with insertion type 'nil'.  *Note
Marker Insertion Types::.  Therefore, when the saved point value is
restored, it normally comes before the inserted text.

 -- Macro: save-mark-and-excursion body...
     This macro is like 'save-excursion', but also saves and restores
     the mark location and 'mark-active'.  This macro does what
     'save-excursion' did before Emacs 25.1.

==============================================================================
File: elisp.info,  Node: |Narrowing|,  Prev: |Excursions|,  Up: |Positions|
==============================================================================

                                                                     *Narrowing*

30.4 Narrowing
--------------

"Narrowing" means limiting the text addressable by Emacs editing
commands to a limited range of characters in a buffer.  The text that
remains addressable is called the "accessible portion" of the buffer.

   Narrowing is specified with two buffer positions, which become the
beginning and end of the accessible portion.  For most editing commands
and primitives, these positions replace the values of the beginning and
end of the buffer.  While narrowing is in effect, no text outside the
accessible portion is displayed, and point cannot move outside the
accessible portion.  Note that narrowing does not alter actual buffer
positions (*note Point::); it only determines which positions are
considered the accessible portion of the buffer.  Most functions refuse
to operate on text that is outside the accessible portion.

   Commands for saving buffers are unaffected by narrowing; they save
the entire buffer regardless of any narrowing.

   If you need to display in a single buffer several very different
types of text, consider using an alternative facility described in *note
Swapping Text::.

 -- Command: narrow-to-region start end
     This function sets the accessible portion of the current buffer to
     start at START and end at END.  Both arguments should be character
     positions.

     In an interactive call, START and END are set to the bounds of the
     current region (point and the mark, with the smallest first).

 -- Command: narrow-to-page &optional move-count
     This function sets the accessible portion of the current buffer to
     include just the current page.  An optional first argument
     MOVE-COUNT non-'nil' means to move forward or backward by
     MOVE-COUNT pages and then narrow to one page.  The variable
     'page-delimiter' specifies where pages start and end (*note
     Standard Regexps::).

     In an interactive call, MOVE-COUNT is set to the numeric prefix
     argument.

 -- Command: widen
     This function cancels any narrowing in the current buffer, so that
     the entire contents are accessible.  This is called "widening".  It
     is equivalent to the following expression:

          (narrow-to-region 1 (1+ (buffer-size)))

 -- Function: buffer-narrowed-p
     This function returns non-'nil' if the buffer is narrowed, and
     'nil' otherwise.

 -- Special Form: save-restriction body...
     This special form saves the current bounds of the accessible
     portion, evaluates the BODY forms, and finally restores the saved
     bounds, thus restoring the same state of narrowing (or absence
     thereof) formerly in effect.  The state of narrowing is restored
     even in the event of an abnormal exit via 'throw' or error (*note
     Nonlocal Exits::).  Therefore, this construct is a clean way to
     narrow a buffer temporarily.

     The value returned by 'save-restriction' is that returned by the
     last form in BODY, or 'nil' if no body forms were given.

     Caution: it is easy to make a mistake when using the
     'save-restriction' construct.  Read the entire description here
     before you try it.

     If BODY changes the current buffer, 'save-restriction' still
     restores the restrictions on the original buffer (the buffer whose
     restrictions it saved from), but it does not restore the identity
     of the current buffer.

     'save-restriction' does _not_ restore point; use 'save-excursion'
     for that.  If you use both 'save-restriction' and 'save-excursion'
     together, 'save-excursion' should come first (on the outside).
     Otherwise, the old point value would be restored with temporary
     narrowing still in effect.  If the old point value were outside the
     limits of the temporary narrowing, this would fail to restore it
     accurately.

     Here is a simple example of correct use of 'save-restriction':

          ---------- Buffer: foo ----------
          This is the contents of foo
          This is the contents of foo
          This is the contents of foo-!-
          ---------- Buffer: foo ----------

          (save-excursion
            (save-restriction
              (goto-char 1)
              (forward-line 2)
              (narrow-to-region 1 (point))
              (goto-char (point-min))
              (replace-string "foo" "bar")))

          ---------- Buffer: foo ----------
          This is the contents of bar
          This is the contents of bar
          This is the contents of foo-!-
          ---------- Buffer: foo ----------

==============================================================================
File: elisp.info,  Node: |Markers|,  Next: |Text|,  Prev: |Positions|,  Up: |Top|
==============================================================================

                                                                       *Markers*

31 Markers
==========

A "marker" is a Lisp object used to specify a position in a buffer
relative to the surrounding text.  A marker changes its offset from the
beginning of the buffer automatically whenever text is inserted or
deleted, so that it stays with the two characters on either side of it.

MENU

* |Overview_of_Markers|::      The components of a marker, and how it relocates.
* |Predicates_on_Markers|::    Testing whether an object is a marker.
* |Creating_Markers|::         Making empty markers or markers at certain places.
* |Information_from_Markers|:: Finding the marker's buffer or character position.
* |Marker_Insertion_Types|::   Two ways a marker can relocate when you
                               insert where it points.
* |Moving_Markers|::           Moving the marker to a new buffer or position.
* |The_Mark|::                 How the mark is implemented with a marker.
* |The_Region|::               How to access the region.

==============================================================================
File: elisp.info,  Node: |Overview_of_Markers|,  Next: |Predicates_on_Markers|,  Up: |Markers|
==============================================================================

                                                           *Overview_of_Markers*

31.1 Overview of Markers
------------------------

A marker specifies a buffer and a position in that buffer.  A marker can
be used to represent a position in functions that require one, just as
an integer could be used.  In that case, the marker's buffer is normally
ignored.  Of course, a marker used in this way usually points to a
position in the buffer that the function operates on, but that is
entirely the programmer's responsibility.  *Note Positions::, for a
complete description of positions.

   A marker has three attributes: the marker position, the marker
buffer, and the insertion type.  The marker position is an integer that
is equivalent (at a given time) to the marker as a position in that
buffer.  But the marker's position value can change during the life of
the marker, and often does.  Insertion and deletion of text in the
buffer relocate the marker.  The idea is that a marker positioned
between two characters remains between those two characters despite
insertion and deletion elsewhere in the buffer.  Relocation changes the
integer equivalent of the marker.

   Deleting text around a marker's position leaves the marker between
the characters immediately before and after the deleted text.  Inserting
text at the position of a marker normally leaves the marker either in
front of or after the new text, depending on the marker's "insertion
type" (*note Marker Insertion Types::)--unless the insertion is done with
'insert-before-markers' (*note Insertion::).

   Insertion and deletion in a buffer must check all the markers and
relocate them if necessary.  This slows processing in a buffer with a
large number of markers.  For this reason, it is a good idea to make a
marker point nowhere if you are sure you don't need it any more.
Markers that can no longer be accessed are eventually removed (*note
Garbage Collection::).

   Because it is common to perform arithmetic operations on a marker
position, most of these operations (including '+' and '-') accept
markers as arguments.  In such cases, the marker stands for its current
position.

   Here are examples of creating markers, setting markers, and moving
point to markers:

     ;; Make a new marker that initially does not point anywhere:
     (setq m1 (make-marker))
          => #<marker in no buffer>

     ;; Set 'm1' to point between the 99th and 100th characters
     ;;   in the current buffer:
     (set-marker m1 100)
          => #<marker at 100 in markers.texi>

     ;; Now insert one character at the beginning of the buffer:
     (goto-char (point-min))
          => 1
     (insert "Q")
          => nil

     ;; 'm1' is updated appropriately.
     m1
          => #<marker at 101 in markers.texi>

     ;; Two markers that point to the same position
     ;;   are not 'eq', but they are 'equal'.
     (setq m2 (copy-marker m1))
          => #<marker at 101 in markers.texi>
     (eq m1 m2)
          => nil
     (equal m1 m2)
          => t

     ;; When you are finished using a marker, make it point nowhere.
     (set-marker m1 nil)
          => #<marker in no buffer>

==============================================================================
File: elisp.info,  Node: |Predicates_on_Markers|,  Next: |Creating_Markers|,  Prev: |Overview_of_Markers|,  Up: |Markers|
==============================================================================

                                                         *Predicates_on_Markers*

31.2 Predicates on Markers
--------------------------

You can test an object to see whether it is a marker, or whether it is
either an integer or a marker.  The latter test is useful in connection
with the arithmetic functions that work with both markers and integers.

 -- Function: markerp object
     This function returns 't' if OBJECT is a marker, 'nil' otherwise.
     Note that integers are not markers, even though many functions will
     accept either a marker or an integer.

 -- Function: integer-or-marker-p object
     This function returns 't' if OBJECT is an integer or a marker,
     'nil' otherwise.

 -- Function: number-or-marker-p object
     This function returns 't' if OBJECT is a number (either integer or
     floating point) or a marker, 'nil' otherwise.

==============================================================================
File: elisp.info,  Node: |Creating_Markers|,  Next: |Information_from_Markers|,  Prev: |Predicates_on_Markers|,  Up: |Markers|
==============================================================================

                                                              *Creating_Markers*

31.3 Functions that Create Markers
----------------------------------

When you create a new marker, you can make it point nowhere, or point to
the present position of point, or to the beginning or end of the
accessible portion of the buffer, or to the same place as another given
marker.

   The next four functions all return markers with insertion type 'nil'.
*Note Marker Insertion Types::.

 -- Function: make-marker
     This function returns a newly created marker that does not point
     anywhere.

          (make-marker)
               => #<marker in no buffer>

 -- Function: point-marker
     This function returns a new marker that points to the present
     position of point in the current buffer.  *Note Point::.  For an
     example, see 'copy-marker', below.

 -- Function: point-min-marker
     This function returns a new marker that points to the beginning of
     the accessible portion of the buffer.  This will be the beginning
     of the buffer unless narrowing is in effect.  *Note Narrowing::.

 -- Function: point-max-marker
     This function returns a new marker that points to the end of the
     accessible portion of the buffer.  This will be the end of the
     buffer unless narrowing is in effect.  *Note Narrowing::.

     Here are examples of this function and 'point-min-marker', shown in
     a buffer containing a version of the source file for the text of
     this chapter.

          (point-min-marker)
               => #<marker at 1 in markers.texi>
          (point-max-marker)
               => #<marker at 24080 in markers.texi>

          (narrow-to-region 100 200)
               => nil
          (point-min-marker)
               => #<marker at 100 in markers.texi>
          (point-max-marker)
               => #<marker at 200 in markers.texi>

 -- Function: copy-marker &optional marker-or-integer insertion-type
     If passed a marker as its argument, 'copy-marker' returns a new
     marker that points to the same place and the same buffer as does
     MARKER-OR-INTEGER.  If passed an integer as its argument,
     'copy-marker' returns a new marker that points to position
     MARKER-OR-INTEGER in the current buffer.

     The new marker's insertion type is specified by the argument
     INSERTION-TYPE.  *Note Marker Insertion Types::.

          (copy-marker 0)
               => #<marker at 1 in markers.texi>

          (copy-marker 90000)
               => #<marker at 24080 in markers.texi>

     An error is signaled if MARKER is neither a marker nor an integer.

   Two distinct markers are considered 'equal' (even though not 'eq') to
each other if they have the same position and buffer, or if they both
point nowhere.

     (setq p (point-marker))
          => #<marker at 2139 in markers.texi>

     (setq q (copy-marker p))
          => #<marker at 2139 in markers.texi>

     (eq p q)
          => nil

     (equal p q)
          => t

==============================================================================
File: elisp.info,  Node: |Information_from_Markers|,  Next: |Marker_Insertion_Types|,  Prev: |Creating_Markers|,  Up: |Markers|
==============================================================================

                                                      *Information_from_Markers*

31.4 Information from Markers
-----------------------------

This section describes the functions for accessing the components of a
marker object.

 -- Function: marker-position marker
     This function returns the position that MARKER points to, or 'nil'
     if it points nowhere.

 -- Function: marker-buffer marker
     This function returns the buffer that MARKER points into, or 'nil'
     if it points nowhere.

          (setq m (make-marker))
               => #<marker in no buffer>
          (marker-position m)
               => nil
          (marker-buffer m)
               => nil

          (set-marker m 3770 (current-buffer))
               => #<marker at 3770 in markers.texi>
          (marker-buffer m)
               => #<buffer markers.texi>
          (marker-position m)
               => 3770

==============================================================================
File: elisp.info,  Node: |Marker_Insertion_Types|,  Next: |Moving_Markers|,  Prev: |Information_from_Markers|,  Up: |Markers|
==============================================================================

                                                        *Marker_Insertion_Types*

31.5 Marker Insertion Types
---------------------------

When you insert text directly at the place where a marker points, there
are two possible ways to relocate that marker: it can point before the
inserted text, or point after it.  You can specify which one a given
marker should do by setting its "insertion type".  Note that use of
'insert-before-markers' ignores markers' insertion types, always
relocating a marker to point after the inserted text.

 -- Function: set-marker-insertion-type marker type
     This function sets the insertion type of marker MARKER to TYPE.  If
     TYPE is 't', MARKER will advance when text is inserted at its
     position.  If TYPE is 'nil', MARKER does not advance when text is
     inserted there.

 -- Function: marker-insertion-type marker
     This function reports the current insertion type of MARKER.

   All functions that create markers without accepting an argument that
specifies the insertion type, create them with insertion type 'nil'
(*note Creating Markers::).  Also, the mark has, by default, insertion
type 'nil'.

==============================================================================
File: elisp.info,  Node: |Moving_Markers|,  Next: |The_Mark|,  Prev: |Marker_Insertion_Types|,  Up: |Markers|
==============================================================================

                                                                *Moving_Markers*

31.6 Moving Marker Positions
----------------------------

This section describes how to change the position of an existing marker.
When you do this, be sure you know whether the marker is used outside of
your program, and, if so, what effects will result from moving
it--otherwise, confusing things may happen in other parts of Emacs.

 -- Function: set-marker marker position &optional buffer
     This function moves MARKER to POSITION in BUFFER.  If BUFFER is not
     provided, it defaults to the current buffer.

     If POSITION is 'nil' or a marker that points nowhere, then MARKER
     is set to point nowhere.

     The value returned is MARKER.

          (setq m (point-marker))
               => #<marker at 4714 in markers.texi>
          (set-marker m 55)
               => #<marker at 55 in markers.texi>
          (setq b (get-buffer "foo"))
               => #<buffer foo>
          (set-marker m 0 b)
               => #<marker at 1 in foo>

 -- Function: move-marker marker position &optional buffer
     This is another name for 'set-marker'.

==============================================================================
File: elisp.info,  Node: |The_Mark|,  Next: |The_Region|,  Prev: |Moving_Markers|,  Up: |Markers|
==============================================================================

                                                                      *The_Mark*

31.7 The Mark
-------------

Each buffer has a special marker, which is designated "the mark".  When
a buffer is newly created, this marker exists but does not point
anywhere; this means that the mark doesn't exist in that buffer yet.
Subsequent commands can set the mark.

   The mark specifies a position to bound a range of text for many
commands, such as 'kill-region' and 'indent-rigidly'.  These commands
typically act on the text between point and the mark, which is called
the "region".  If you are writing a command that operates on the region,
don't examine the mark directly; instead, use 'interactive' with the 'r'
specification.  This provides the values of point and the mark as
arguments to the command in an interactive call, but permits other Lisp
programs to specify arguments explicitly.  *Note Interactive Codes::.

   Some commands set the mark as a side-effect.  Commands should do this
only if it has a potential use to the user, and never for their own
internal purposes.  For example, the 'replace-regexp' command sets the
mark to the value of point before doing any replacements, because this
enables the user to move back there conveniently after the replace is
finished.

   Once the mark exists in a buffer, it normally never ceases to exist.
However, it may become "inactive", if Transient Mark mode is enabled.
The buffer-local variable 'mark-active', if non-'nil', means that the
mark is active.  A command can call the function 'deactivate-mark' to
deactivate the mark directly, or it can request deactivation of the mark
upon return to the editor command loop by setting the variable
'deactivate-mark' to a non-'nil' value.

   If Transient Mark mode is enabled, certain editing commands that
normally apply to text near point, apply instead to the region when the
mark is active.  This is the main motivation for using Transient Mark
mode.  (Another is that this enables highlighting of the region when the
mark is active.  *Note Display::.)

   In addition to the mark, each buffer has a "mark ring" which is a
list of markers containing previous values of the mark.  When editing
commands change the mark, they should normally save the old value of the
mark on the mark ring.  The variable 'mark-ring-max' specifies the
maximum number of entries in the mark ring; once the list becomes this
long, adding a new element deletes the last element.

   There is also a separate global mark ring, but that is used only in a
few particular user-level commands, and is not relevant to Lisp
programming.  So we do not describe it here.

 -- Function: mark &optional force
     This function returns the current buffer's mark position as an
     integer, or 'nil' if no mark has ever been set in this buffer.

     If Transient Mark mode is enabled, and 'mark-even-if-inactive' is
     'nil', 'mark' signals an error if the mark is inactive.  However,
     if FORCE is non-'nil', then 'mark' disregards inactivity of the
     mark, and returns the mark position (or 'nil') anyway.

 -- Function: mark-marker
     This function returns the marker that represents the current
     buffer's mark.  It is not a copy, it is the marker used internally.
     Therefore, changing this marker's position will directly affect the
     buffer's mark.  Don't do that unless that is the effect you want.

          (setq m (mark-marker))
               => #<marker at 3420 in markers.texi>
          (set-marker m 100)
               => #<marker at 100 in markers.texi>
          (mark-marker)
               => #<marker at 100 in markers.texi>

     Like any marker, this marker can be set to point at any buffer you
     like.  If you make it point at any buffer other than the one of
     which it is the mark, it will yield perfectly consistent, but
     rather odd, results.  We recommend that you not do it!

 -- Function: set-mark position
     This function sets the mark to POSITION, and activates the mark.
     The old value of the mark is _not_ pushed onto the mark ring.

     *Please note:* Use this function only if you want the user to see
     that the mark has moved, and you want the previous mark position to
     be lost.  Normally, when a new mark is set, the old one should go
     on the 'mark-ring'.  For this reason, most applications should use
     'push-mark' and 'pop-mark', not 'set-mark'.

     Novice Emacs Lisp programmers often try to use the mark for the
     wrong purposes.  The mark saves a location for the user's
     convenience.  An editing command should not alter the mark unless
     altering the mark is part of the user-level functionality of the
     command.  (And, in that case, this effect should be documented.)
     To remember a location for internal use in the Lisp program, store
     it in a Lisp variable.  For example:

          (let ((beg (point)))
            (forward-line 1)
            (delete-region beg (point))).

 -- Function: push-mark &optional position nomsg activate
     This function sets the current buffer's mark to POSITION, and
     pushes a copy of the previous mark onto 'mark-ring'.  If POSITION
     is 'nil', then the value of point is used.

     The function 'push-mark' normally _does not_ activate the mark.  To
     do that, specify 't' for the argument ACTIVATE.

     A 'Mark set' message is displayed unless NOMSG is non-'nil'.

 -- Function: pop-mark
     This function pops off the top element of 'mark-ring' and makes
     that mark become the buffer's actual mark.  This does not move
     point in the buffer, and it does nothing if 'mark-ring' is empty.
     It deactivates the mark.

 -- User Option: transient-mark-mode
     This variable, if non-'nil', enables Transient Mark mode.  In
     Transient Mark mode, every buffer-modifying primitive sets
     'deactivate-mark'.  As a consequence, most commands that modify the
     buffer also deactivate the mark.

     When Transient Mark mode is enabled and the mark is active, many
     commands that normally apply to the text near point instead apply
     to the region.  Such commands should use the function
     'use-region-p' to test whether they should operate on the region.
     *Note The Region::.

     Lisp programs can set 'transient-mark-mode' to non-'nil', non-'t'
     values to enable Transient Mark mode temporarily.  If the value is
     'lambda', Transient Mark mode is automatically turned off after any
     action, such as buffer modification, that would normally deactivate
     the mark.  If the value is '(only . OLDVAL)', then
     'transient-mark-mode' is set to the value OLDVAL after any
     subsequent command that moves point and is not shift-translated
     (*note shift-translation: Key Sequence Input.), or after any other
     action that would normally deactivate the mark.

 -- User Option: mark-even-if-inactive
     If this is non-'nil', Lisp programs and the Emacs user can use the
     mark even when it is inactive.  This option affects the behavior of
     Transient Mark mode.  When the option is non-'nil', deactivation of
     the mark turns off region highlighting, but commands that use the
     mark behave as if the mark were still active.

 -- Variable: deactivate-mark
     If an editor command sets this variable non-'nil', then the editor
     command loop deactivates the mark after the command returns (if
     Transient Mark mode is enabled).  All the primitives that change
     the buffer set 'deactivate-mark', to deactivate the mark when the
     command is finished.  Setting this variable makes it buffer-local.

     To write Lisp code that modifies the buffer without causing
     deactivation of the mark at the end of the command, bind
     'deactivate-mark' to 'nil' around the code that does the
     modification.  For example:

          (let (deactivate-mark)
            (insert " "))

 -- Function: deactivate-mark &optional force
     If Transient Mark mode is enabled or FORCE is non-'nil', this
     function deactivates the mark and runs the normal hook
     'deactivate-mark-hook'.  Otherwise, it does nothing.

 -- Variable: mark-active
     The mark is active when this variable is non-'nil'.  This variable
     is always buffer-local in each buffer.  Do _not_ use the value of
     this variable to decide whether a command that normally operates on
     text near point should operate on the region instead.  Use the
     function 'use-region-p' for that (*note The Region::).

 -- Variable: activate-mark-hook
 -- Variable: deactivate-mark-hook
     These normal hooks are run, respectively, when the mark becomes
     active and when it becomes inactive.  The hook 'activate-mark-hook'
     is also run at the end of the command loop if the mark is active
     and it is possible that the region may have changed.

 -- Function: handle-shift-selection
     This function implements the shift-selection behavior of
     point-motion commands.  *Note (emacs)Shift Selection::.  It is
     called automatically by the Emacs command loop whenever a command
     with a '^' character in its 'interactive' spec is invoked, before
     the command itself is executed (*note ^: Interactive Codes.).

     If 'shift-select-mode' is non-'nil' and the current command was
     invoked via shift translation (*note shift-translation: Key
     Sequence Input.), this function sets the mark and temporarily
     activates the region, unless the region was already temporarily
     activated in this way.  Otherwise, if the region has been activated
     temporarily, it deactivates the mark and restores the variable
     'transient-mark-mode' to its earlier value.

 -- Variable: mark-ring
     The value of this buffer-local variable is the list of saved former
     marks of the current buffer, most recent first.

          mark-ring
          => (#<marker at 11050 in markers.texi>
              #<marker at 10832 in markers.texi>
              ...)

 -- User Option: mark-ring-max
     The value of this variable is the maximum size of 'mark-ring'.  If
     more marks than this are pushed onto the 'mark-ring', 'push-mark'
     discards an old mark when it adds a new one.

   When Delete Selection mode (*note Delete Selection: (emacs)Using
Region.) is enabled, commands that operate on the active region (a.k.a.
"selection") behave slightly differently.  This works by adding the
function 'delete-selection-pre-hook' to the 'pre-command-hook' (*note
Command Overview::).  That function calls 'delete-selection-helper' to
delete the selection as appropriate for the command.  If you want to
adapt a command to Delete Selection mode, put the 'delete-selection'
property on the function's symbol (*note Symbol Plists::); commands that
don't have this property on their symbol won't delete the selection.
This property can have one of several values to tailor the behavior to
what the command is supposed to do; see the doc strings of
'delete-selection-pre-hook' and 'delete-selection-helper' for the
details.

==============================================================================
File: elisp.info,  Node: |The_Region|,  Prev: |The_Mark|,  Up: |Markers|
==============================================================================

                                                                    *The_Region*

31.8 The Region
---------------

The text between point and the mark is known as "the region".  Various
functions operate on text delimited by point and the mark, but only
those functions specifically related to the region itself are described
here.

   The next two functions signal an error if the mark does not point
anywhere.  If Transient Mark mode is enabled and 'mark-even-if-inactive'
is 'nil', they also signal an error if the mark is inactive.

 -- Function: region-beginning
     This function returns the position of the beginning of the region
     (as an integer).  This is the position of either point or the mark,
     whichever is smaller.

 -- Function: region-end
     This function returns the position of the end of the region (as an
     integer).  This is the position of either point or the mark,
     whichever is larger.

   Instead of using 'region-beginning' and 'region-end', a command
designed to operate on a region should normally use 'interactive' with
the 'r' specification to find the beginning and end of the region.  This
lets other Lisp programs specify the bounds explicitly as arguments.
*Note Interactive Codes::.

 -- Function: use-region-p
     This function returns 't' if Transient Mark mode is enabled, the
     mark is active, and there is a valid region in the buffer.  This
     function is intended to be used by commands that operate on the
     region, instead of on text near point, when the mark is active.

     A region is valid if it has a non-zero size, or if the user option
     'use-empty-active-region' is non-'nil' (by default, it is 'nil').
     The function 'region-active-p' is similar to 'use-region-p', but
     considers all regions as valid.  In most cases, you should not use
     'region-active-p', since if the region is empty it is often more
     appropriate to operate on point.

==============================================================================
File: elisp.info,  Node: |Text|,  Next: |Non_ASCII_Characters|,  Prev: |Markers|,  Up: |Top|
==============================================================================

                                                                          *Text*

32 Text
=======

This chapter describes the functions that deal with the text in a
buffer.  Most examine, insert, or delete text in the current buffer,
often operating at point or on text adjacent to point.  Many are
interactive.  All the functions that change the text provide for undoing
the changes (*note Undo::).

   Many text-related functions operate on a region of text defined by
two buffer positions passed in arguments named START and END.  These
arguments should be either markers (*note Markers::) or numeric
character positions (*note Positions::).  The order of these arguments
does not matter; it is all right for START to be the end of the region
and END the beginning.  For example, '(delete-region 1 10)' and
'(delete-region 10 1)' are equivalent.  An 'args-out-of-range' error is
signaled if either START or END is outside the accessible portion of the
buffer.  In an interactive call, point and the mark are used for these
arguments.

   Throughout this chapter, "text" refers to the characters in the
buffer, together with their properties (when relevant).  Keep in mind
that point is always between two characters, and the cursor appears on
the character after point.

MENU

* |Near_Point|::       Examining text in the vicinity of point.
* |Buffer_Contents|::  Examining text in a general fashion.
* |Comparing_Text|::   Comparing substrings of buffers.
* |Insertion|::        Adding new text to a buffer.
* |Commands_for_Insertion|::  User-level commands to insert text.
* |Deletion|::         Removing text from a buffer.
* |User_Level_Deletion|::     User-level commands to delete text.
* |The_Kill_Ring|::    Where removed text sometimes is saved for later use.
* |Undo|::             Undoing changes to the text of a buffer.
* |Maintaining_Undo|:: How to enable and disable undo information.
                        How to control how much information is kept.
* |Filling|::          Functions for explicit filling.
* |Margins|::          How to specify margins for filling commands.
* |Adaptive_Fill|::    Adaptive Fill mode chooses a fill prefix from context.
* |Auto_Filling|::     How auto-fill mode is implemented to break lines.
* |Sorting|::          Functions for sorting parts of the buffer.
* |Columns|::          Computing horizontal positions, and using them.
* |Indentation|::      Functions to insert or adjust indentation.
* |Case_Changes|::     Case conversion of parts of the buffer.
* |Text_Properties|::  Assigning Lisp property lists to text characters.
* |Substitution|::     Replacing a given character wherever it appears.
* |Registers|::        How registers are implemented.  Accessing the text or
                       position stored in a register.
* |Transposition|::    Swapping two portions of a buffer.
* |Replacing|::        Replacing the text of one buffer with the text
                       of another buffer.
* |Decompression|::    Dealing with compressed data.
* |Base_64|::          Conversion to or from base 64 encoding.
* |Checksum/Hash|::    Computing cryptographic hashes.
* |GnuTLS_Cryptography|:: Cryptographic algorithms imported from GnuTLS.
* |Parsing_HTML/XML|:: Parsing HTML and XML.
* |Parsing_JSON|::     Parsing and generating JSON values.
* |JSONRPC|::          JSON Remote Procedure Call protocol
* |Atomic_Changes|::   Installing several buffer changes atomically.
* |Change_Hooks|::     Supplying functions to be run when text is changed.

==============================================================================
File: elisp.info,  Node: |Near_Point|,  Next: |Buffer_Contents|,  Up: |Text|
==============================================================================

                                                                    *Near_Point*

32.1 Examining Text Near Point
------------------------------

Many functions are provided to look at the characters around point.
Several simple functions are described here.  See also 'looking-at' in
*note Regexp Search::.

   In the following four functions, "beginning" or "end" of buffer
refers to the beginning or end of the accessible portion.

 -- Function: char-after &optional position
     This function returns the character in the current buffer at (i.e.,
     immediately after) position POSITION.  If POSITION is out of range
     for this purpose, either before the beginning of the buffer, or at
     or beyond the end, then the value is 'nil'.  The default for
     POSITION is point.

     In the following example, assume that the first character in the
     buffer is '@':

          (string (char-after 1))
               => "@"

 -- Function: char-before &optional position
     This function returns the character in the current buffer
     immediately before position POSITION.  If POSITION is out of range
     for this purpose, either at or before the beginning of the buffer,
     or beyond the end, then the value is 'nil'.  The default for
     POSITION is point.

 -- Function: following-char
     This function returns the character following point in the current
     buffer.  This is similar to '(char-after (point))'.  However, if
     point is at the end of the buffer, then 'following-char' returns 0.

     Remember that point is always between characters, and the cursor
     normally appears over the character following point.  Therefore,
     the character returned by 'following-char' is the character the
     cursor is over.

     In this example, point is between the 'a' and the 'c'.

          ---------- Buffer: foo ----------
          Gentlemen may cry ``Pea-!-ce! Peace!,''
          but there is no peace.
          ---------- Buffer: foo ----------

          (string (preceding-char))
               => "a"
          (string (following-char))
               => "c"

 -- Function: preceding-char
     This function returns the character preceding point in the current
     buffer.  See above, under 'following-char', for an example.  If
     point is at the beginning of the buffer, 'preceding-char' returns
     0.

 -- Function: bobp
     This function returns 't' if point is at the beginning of the
     buffer.  If narrowing is in effect, this means the beginning of the
     accessible portion of the text.  See also 'point-min' in *note
     Point::.

 -- Function: eobp
     This function returns 't' if point is at the end of the buffer.  If
     narrowing is in effect, this means the end of accessible portion of
     the text.  See also 'point-max' in *Note Point::.

 -- Function: bolp
     This function returns 't' if point is at the beginning of a line.
     *Note Text Lines::.  The beginning of the buffer (or of its
     accessible portion) always counts as the beginning of a line.

 -- Function: eolp
     This function returns 't' if point is at the end of a line.  The
     end of the buffer (or of its accessible portion) is always
     considered the end of a line.

==============================================================================
File: elisp.info,  Node: |Buffer_Contents|,  Next: |Comparing_Text|,  Prev: |Near_Point|,  Up: |Text|
==============================================================================

                                                               *Buffer_Contents*

32.2 Examining Buffer Contents
------------------------------

This section describes functions that allow a Lisp program to convert
any portion of the text in the buffer into a string.

 -- Function: buffer-substring start end
     This function returns a string containing a copy of the text of the
     region defined by positions START and END in the current buffer.
     If the arguments are not positions in the accessible portion of the
     buffer, 'buffer-substring' signals an 'args-out-of-range' error.

     Here's an example which assumes Font-Lock mode is not enabled:

          ---------- Buffer: foo ----------
          This is the contents of buffer foo

          ---------- Buffer: foo ----------

          (buffer-substring 1 10)
               => "This is t"
          (buffer-substring (point-max) 10)
               => "he contents of buffer foo\n"

     If the text being copied has any text properties, these are copied
     into the string along with the characters they belong to.  *Note
     Text Properties::.  However, overlays (*note Overlays::) in the
     buffer and their properties are ignored, not copied.

     For example, if Font-Lock mode is enabled, you might get results
     like these:

          (buffer-substring 1 10)
               => #("This is t" 0 1 (fontified t) 1 9 (fontified t))

 -- Function: buffer-substring-no-properties start end
     This is like 'buffer-substring', except that it does not copy text
     properties, just the characters themselves.  *Note Text
     Properties::.

 -- Function: buffer-string
     This function returns the contents of the entire accessible portion
     of the current buffer, as a string.

   If you need to make sure the resulting string, when copied to a
different location, will not change its visual appearance due to
reordering of bidirectional text, use the
'buffer-substring-with-bidi-context' function (*note
buffer-substring-with-bidi-context: Bidirectional Display.).

 -- Function: filter-buffer-substring start end &optional delete
     This function filters the buffer text between START and END using a
     function specified by the variable
     'filter-buffer-substring-function', and returns the result.

     The default filter function consults the obsolete wrapper hook
     'filter-buffer-substring-functions' (see the documentation string
     of the macro 'with-wrapper-hook' for the details about this
     obsolete facility), and the obsolete variable
     'buffer-substring-filters'.  If both of these are 'nil', it returns
     the unaltered text from the buffer, i.e., what 'buffer-substring'
     would return.

     If DELETE is non-'nil', the function deletes the text between START
     and END after copying it, like 'delete-and-extract-region'.

     Lisp code should use this function instead of 'buffer-substring',
     'buffer-substring-no-properties', or 'delete-and-extract-region'
     when copying into user-accessible data structures such as the
     kill-ring, X clipboard, and registers.  Major and minor modes can
     modify 'filter-buffer-substring-function' to alter such text as it
     is copied out of the buffer.

 -- Variable: filter-buffer-substring-function
     The value of this variable is a function that
     'filter-buffer-substring' will call to do the actual work.  The
     function receives three arguments, the same as those of
     'filter-buffer-substring', which it should treat as per the
     documentation of that function.  It should return the filtered text
     (and optionally delete the source text).

The following two variables are obsoleted by
'filter-buffer-substring-function', but are still supported for backward
compatibility.

 -- Variable: filter-buffer-substring-functions
     This obsolete variable is a wrapper hook, whose members should be
     functions that accept four arguments: FUN, START, END, and DELETE.
     FUN is a function that takes three arguments (START, END, and
     DELETE), and returns a string.  In both cases, the START, END, and
     DELETE arguments are the same as those of
     'filter-buffer-substring'.

     The first hook function is passed a FUN that is equivalent to the
     default operation of 'filter-buffer-substring', i.e., it returns
     the buffer-substring between START and END (processed by any
     'buffer-substring-filters') and optionally deletes the original
     text from the buffer.  In most cases, the hook function will call
     FUN once, and then do its own processing of the result.  The next
     hook function receives a FUN equivalent to this, and so on.  The
     actual return value is the result of all the hook functions acting
     in sequence.

 -- Variable: buffer-substring-filters
     The value of this obsolete variable should be a list of functions
     that accept a single string argument and return another string.
     The default 'filter-buffer-substring' function passes the buffer
     substring to the first function in this list, and the return value
     of each function is passed to the next function.  The return value
     of the last function is passed to
     'filter-buffer-substring-functions'.

 -- Function: current-word &optional strict really-word
     This function returns the symbol (or word) at or near point, as a
     string.  The return value includes no text properties.

     If the optional argument REALLY-WORD is non-'nil', it finds a word;
     otherwise, it finds a symbol (which includes both word characters
     and symbol constituent characters).

     If the optional argument STRICT is non-'nil', then point must be in
     or next to the symbol or word--if no symbol or word is there, the
     function returns 'nil'.  Otherwise, a nearby symbol or word on the
     same line is acceptable.

 -- Function: thing-at-point thing &optional no-properties
     Return the THING around or next to point, as a string.

     The argument THING is a symbol which specifies a kind of syntactic
     entity.  Possibilities include 'symbol', 'list', 'sexp', 'defun',
     'filename', 'url', 'word', 'sentence', 'whitespace', 'line',
     'page', and others.

     When the optional argument NO-PROPERTIES is non-'nil', this
     function strips text properties from the return value.

          ---------- Buffer: foo ----------
          Gentlemen may cry ``Pea-!-ce! Peace!,''
          but there is no peace.
          ---------- Buffer: foo ----------

          (thing-at-point 'word)
               => "Peace"
          (thing-at-point 'line)
               => "Gentlemen may cry ``Peace! Peace!,''\n"
          (thing-at-point 'whitespace)
               => nil

==============================================================================
File: elisp.info,  Node: |Comparing_Text|,  Next: |Insertion|,  Prev: |Buffer_Contents|,  Up: |Text|
==============================================================================

                                                                *Comparing_Text*

32.3 Comparing Text
-------------------

This function lets you compare portions of the text in a buffer, without
copying them into strings first.

 -- Function: compare-buffer-substrings buffer1 start1 end1 buffer2
          start2 end2
     This function lets you compare two substrings of the same buffer or
     two different buffers.  The first three arguments specify one
     substring, giving a buffer (or a buffer name) and two positions
     within the buffer.  The last three arguments specify the other
     substring in the same way.  You can use 'nil' for BUFFER1, BUFFER2,
     or both to stand for the current buffer.

     The value is negative if the first substring is less, positive if
     the first is greater, and zero if they are equal.  The absolute
     value of the result is one plus the index of the first differing
     characters within the substrings.

     This function ignores case when comparing characters if
     'case-fold-search' is non-'nil'.  It always ignores text
     properties.

     Suppose you have the text 'foobarbar haha!rara!' in the current
     buffer; then in this example the two substrings are 'rbar ' and
     'rara!'.  The value is 2 because the first substring is greater at
     the second character.

          (compare-buffer-substrings nil 6 11 nil 16 21)
               => 2

==============================================================================
File: elisp.info,  Node: |Insertion|,  Next: |Commands_for_Insertion|,  Prev: |Comparing_Text|,  Up: |Text|
==============================================================================

                                                                     *Insertion*

32.4 Inserting Text
-------------------

"Insertion" means adding new text to a buffer.  The inserted text goes
at point--between the character before point and the character after
point.  Some insertion functions leave point before the inserted text,
while other functions leave it after.  We call the former insertion
"after point" and the latter insertion "before point".

   Insertion moves markers located at positions after the insertion
point, so that they stay with the surrounding text (*note Markers::).
When a marker points at the place of insertion, insertion may or may not
relocate the marker, depending on the marker's insertion type (*note
Marker Insertion Types::).  Certain special functions such as
'insert-before-markers' relocate all such markers to point after the
inserted text, regardless of the markers' insertion type.

   Insertion functions signal an error if the current buffer is
read-only (*note Read Only Buffers::) or if they insert within read-only
text (*note Special Properties::).

   These functions copy text characters from strings and buffers along
with their properties.  The inserted characters have exactly the same
properties as the characters they were copied from.  By contrast,
characters specified as separate arguments, not part of a string or
buffer, inherit their text properties from the neighboring text.

   The insertion functions convert text from unibyte to multibyte in
order to insert in a multibyte buffer, and vice versa--if the text comes
from a string or from a buffer.  However, they do not convert unibyte
character codes 128 through 255 to multibyte characters, not even if the
current buffer is a multibyte buffer.  *Note Converting
Representations::.

 -- Function: insert &rest args
     This function inserts the strings and/or characters ARGS into the
     current buffer, at point, moving point forward.  In other words, it
     inserts the text before point.  An error is signaled unless all
     ARGS are either strings or characters.  The value is 'nil'.

 -- Function: insert-before-markers &rest args
     This function inserts the strings and/or characters ARGS into the
     current buffer, at point, moving point forward.  An error is
     signaled unless all ARGS are either strings or characters.  The
     value is 'nil'.

     This function is unlike the other insertion functions in that it
     relocates markers initially pointing at the insertion point, to
     point after the inserted text.  If an overlay begins at the
     insertion point, the inserted text falls outside the overlay; if a
     nonempty overlay ends at the insertion point, the inserted text
     falls inside that overlay.

 -- Command: insert-char character &optional count inherit
     This command inserts COUNT instances of CHARACTER into the current
     buffer before point.  The argument COUNT must be an integer, and
     CHARACTER must be a character.

     If called interactively, this command prompts for CHARACTER using
     its Unicode name or its code point.  *Note (emacs)Inserting Text::.

     This function does not convert unibyte character codes 128 through
     255 to multibyte characters, not even if the current buffer is a
     multibyte buffer.  *Note Converting Representations::.

     If INHERIT is non-'nil', the inserted characters inherit sticky
     text properties from the two characters before and after the
     insertion point.  *Note Sticky Properties::.

 -- Function: insert-buffer-substring from-buffer-or-name &optional
          start end
     This function inserts a portion of buffer FROM-BUFFER-OR-NAME into
     the current buffer before point.  The text inserted is the region
     between START (inclusive) and END (exclusive).  (These arguments
     default to the beginning and end of the accessible portion of that
     buffer.)  This function returns 'nil'.

     In this example, the form is executed with buffer 'bar' as the
     current buffer.  We assume that buffer 'bar' is initially empty.

          ---------- Buffer: foo ----------
          We hold these truths to be self-evident, that all
          ---------- Buffer: foo ----------

          (insert-buffer-substring "foo" 1 20)
               => nil

          ---------- Buffer: bar ----------
          We hold these truth-!-
          ---------- Buffer: bar ----------

 -- Function: insert-buffer-substring-no-properties from-buffer-or-name
          &optional start end
     This is like 'insert-buffer-substring' except that it does not copy
     any text properties.

   *Note Sticky Properties::, for other insertion functions that inherit
text properties from the nearby text in addition to inserting it.
Whitespace inserted by indentation functions also inherits text
properties.

==============================================================================
File: elisp.info,  Node: |Commands_for_Insertion|,  Next: |Deletion|,  Prev: |Insertion|,  Up: |Text|
==============================================================================

                                                        *Commands_for_Insertion*

32.5 User-Level Insertion Commands
----------------------------------

This section describes higher-level commands for inserting text,
commands intended primarily for the user but useful also in Lisp
programs.

 -- Command: insert-buffer from-buffer-or-name
     This command inserts the entire accessible contents of
     FROM-BUFFER-OR-NAME (which must exist) into the current buffer
     after point.  It leaves the mark after the inserted text.  The
     value is 'nil'.

 -- Command: self-insert-command count &optional char
     This command inserts the character CHAR (the last character typed);
     it does so COUNT times, before point, and returns 'nil'.  Most
     printing characters are bound to this command.  In routine use,
     'self-insert-command' is the most frequently called function in
     Emacs, but programs rarely use it except to install it on a keymap.

     In an interactive call, COUNT is the numeric prefix argument.

     Self-insertion translates the input character through
     'translation-table-for-input'.  *Note Translation of Characters::.

     This command calls 'auto-fill-function' whenever that is non-'nil'
     and the character inserted is in the table 'auto-fill-chars' (*note
     Auto Filling::).

     This command performs abbrev expansion if Abbrev mode is enabled
     and the inserted character does not have word-constituent syntax.
     (*Note Abbrevs::, and *note Syntax Class Table::.)  It is also
     responsible for calling 'blink-paren-function' when the inserted
     character has close parenthesis syntax (*note Blinking::).

     The final thing this command does is to run the hook
     'post-self-insert-hook'.  You could use this to automatically
     reindent text as it is typed, for example.  If any function on this
     hook needs to act on the region (*note The Region::), it should
     make sure Delete Selection mode (*note Delete Selection:
     (emacs)Using Region.) doesn't delete the region before
     'post-self-insert-hook' functions are invoked.  The way to do so is
     to add a function that returns 'nil' to
     'self-insert-uses-region-functions', a special hook that tells
     Delete Selection mode it should not delete the region.

     Do not try substituting your own definition of
     'self-insert-command' for the standard one.  The editor command
     loop handles this function specially.

 -- Command: newline &optional number-of-newlines interactive
     This command inserts newlines into the current buffer before point.
     If NUMBER-OF-NEWLINES is supplied, that many newline characters are
     inserted.  In an interactive call, NUMBER-OF-NEWLINES is the
     numeric prefix argument.

     This command calls 'self-insert-command' to insert newlines, which
     may subsequently break the preceding line by calling
     'auto-fill-function' (*note Auto Filling::).  Typically what
     'auto-fill-function' does is insert a newline; thus, the overall
     result in this case is to insert two newlines at different places:
     one at point, and another earlier in the line.  'newline' does not
     auto-fill if NUMBER-OF-NEWLINES is non-'nil'.

     This command does not run the hook 'post-self-insert-hook' unless
     called interactively or INTERACTIVE is non-'nil'.

     This command indents to the left margin if that is not zero.  *Note
     Margins::.

     The value returned is 'nil'.

 -- Variable: overwrite-mode
     This variable controls whether overwrite mode is in effect.  The
     value should be 'overwrite-mode-textual', 'overwrite-mode-binary',
     or 'nil'.  'overwrite-mode-textual' specifies textual overwrite
     mode (treats newlines and tabs specially), and
     'overwrite-mode-binary' specifies binary overwrite mode (treats
     newlines and tabs like any other characters).

==============================================================================
File: elisp.info,  Node: |Deletion|,  Next: |User_Level_Deletion|,  Prev: |Commands_for_Insertion|,  Up: |Text|
==============================================================================

                                                                      *Deletion*

32.6 Deleting Text
------------------

Deletion means removing part of the text in a buffer, without saving it
in the kill ring (*note The Kill Ring::).  Deleted text can't be yanked,
but can be reinserted using the undo mechanism (*note Undo::).  Some
deletion functions do save text in the kill ring in some special cases.

   All of the deletion functions operate on the current buffer.

 -- Command: erase-buffer
     This function deletes the entire text of the current buffer (_not_
     just the accessible portion), leaving it empty.  If the buffer is
     read-only, it signals a 'buffer-read-only' error; if some of the
     text in it is read-only, it signals a 'text-read-only' error.
     Otherwise, it deletes the text without asking for any confirmation.
     It returns 'nil'.

     Normally, deleting a large amount of text from a buffer inhibits
     further auto-saving of that buffer because it has shrunk.  However,
     'erase-buffer' does not do this, the idea being that the future
     text is not really related to the former text, and its size should
     not be compared with that of the former text.

 -- Command: delete-region start end
     This command deletes the text between positions START and END in
     the current buffer, and returns 'nil'.  If point was inside the
     deleted region, its value afterward is START.  Otherwise, point
     relocates with the surrounding text, as markers do.

 -- Function: delete-and-extract-region start end
     This function deletes the text between positions START and END in
     the current buffer, and returns a string containing the text just
     deleted.

     If point was inside the deleted region, its value afterward is
     START.  Otherwise, point relocates with the surrounding text, as
     markers do.

 -- Command: delete-char count &optional killp
     This command deletes COUNT characters directly after point, or
     before point if COUNT is negative.  If KILLP is non-'nil', then it
     saves the deleted characters in the kill ring.

     In an interactive call, COUNT is the numeric prefix argument, and
     KILLP is the unprocessed prefix argument.  Therefore, if a prefix
     argument is supplied, the text is saved in the kill ring.  If no
     prefix argument is supplied, then one character is deleted, but not
     saved in the kill ring.

     The value returned is always 'nil'.

 -- Command: delete-backward-char count &optional killp
     This command deletes COUNT characters directly before point, or
     after point if COUNT is negative.  If KILLP is non-'nil', then it
     saves the deleted characters in the kill ring.

     In an interactive call, COUNT is the numeric prefix argument, and
     KILLP is the unprocessed prefix argument.  Therefore, if a prefix
     argument is supplied, the text is saved in the kill ring.  If no
     prefix argument is supplied, then one character is deleted, but not
     saved in the kill ring.

     The value returned is always 'nil'.

 -- Command: backward-delete-char-untabify count &optional killp
     This command deletes COUNT characters backward, changing tabs into
     spaces.  When the next character to be deleted is a tab, it is
     first replaced with the proper number of spaces to preserve
     alignment and then one of those spaces is deleted instead of the
     tab.  If KILLP is non-'nil', then the command saves the deleted
     characters in the kill ring.

     Conversion of tabs to spaces happens only if COUNT is positive.  If
     it is negative, exactly -COUNT characters after point are deleted.

     In an interactive call, COUNT is the numeric prefix argument, and
     KILLP is the unprocessed prefix argument.  Therefore, if a prefix
     argument is supplied, the text is saved in the kill ring.  If no
     prefix argument is supplied, then one character is deleted, but not
     saved in the kill ring.

     The value returned is always 'nil'.

 -- User Option: backward-delete-char-untabify-method
     This option specifies how 'backward-delete-char-untabify' should
     deal with whitespace.  Possible values include 'untabify', the
     default, meaning convert a tab to many spaces and delete one;
     'hungry', meaning delete all tabs and spaces before point with one
     command; 'all' meaning delete all tabs, spaces and newlines before
     point, and 'nil', meaning do nothing special for whitespace
     characters.

==============================================================================
File: elisp.info,  Node: |User_Level_Deletion|,  Next: |The_Kill_Ring|,  Prev: |Deletion|,  Up: |Text|
==============================================================================

                                                           *User_Level_Deletion*

32.7 User-Level Deletion Commands
---------------------------------

This section describes higher-level commands for deleting text, commands
intended primarily for the user but useful also in Lisp programs.

 -- Command: delete-horizontal-space &optional backward-only
     This function deletes all spaces and tabs around point.  It returns
     'nil'.

     If BACKWARD-ONLY is non-'nil', the function deletes spaces and tabs
     before point, but not after point.

     In the following examples, we call 'delete-horizontal-space' four
     times, once on each line, with point between the second and third
     characters on the line each time.

          ---------- Buffer: foo ----------
          I -!-thought
          I -!-     thought
          We-!- thought
          Yo-!-u thought
          ---------- Buffer: foo ----------

          (delete-horizontal-space)   ; Four times.
               => nil

          ---------- Buffer: foo ----------
          Ithought
          Ithought
          Wethought
          You thought
          ---------- Buffer: foo ----------

 -- Command: delete-indentation &optional join-following-p beg end
     This function joins the line point is on to the previous line,
     deleting any whitespace at the join and in some cases replacing it
     with one space.  If JOIN-FOLLOWING-P is non-'nil',
     'delete-indentation' joins this line to the following line instead.
     Otherwise, if BEG and END are non-'nil', this function joins all
     lines in the region they define.

     In an interactive call, JOIN-FOLLOWING-P is the prefix argument,
     and BEG and END are, respectively, the start and end of the region
     if it is active, else 'nil'.  The function returns 'nil'.

     If there is a fill prefix, and the second of the lines being joined
     starts with the prefix, then 'delete-indentation' deletes the fill
     prefix before joining the lines.  *Note Margins::.

     In the example below, point is located on the line starting
     'events', and it makes no difference if there are trailing spaces
     in the preceding line.

          ---------- Buffer: foo ----------
          When in the course of human
          -!-    events, it becomes necessary
          ---------- Buffer: foo ----------

          (delete-indentation)
               => nil

          ---------- Buffer: foo ----------
          When in the course of human-!- events, it becomes necessary
          ---------- Buffer: foo ----------

     After the lines are joined, the function 'fixup-whitespace' is
     responsible for deciding whether to leave a space at the junction.

 -- Command: fixup-whitespace
     This function replaces all the horizontal whitespace surrounding
     point with either one space or no space, according to the context.
     It returns 'nil'.

     At the beginning or end of a line, the appropriate amount of space
     is none.  Before a character with close parenthesis syntax, or
     after a character with open parenthesis or expression-prefix
     syntax, no space is also appropriate.  Otherwise, one space is
     appropriate.  *Note Syntax Class Table::.

     In the example below, 'fixup-whitespace' is called the first time
     with point before the word 'spaces' in the first line.  For the
     second invocation, point is directly after the '('.

          ---------- Buffer: foo ----------
          This has too many     -!-spaces
          This has too many spaces at the start of (-!-   this list)
          ---------- Buffer: foo ----------

          (fixup-whitespace)
               => nil
          (fixup-whitespace)
               => nil

          ---------- Buffer: foo ----------
          This has too many spaces
          This has too many spaces at the start of (this list)
          ---------- Buffer: foo ----------

 -- Command: just-one-space &optional n
     This command replaces any spaces and tabs around point with a
     single space, or N spaces if N is specified.  It returns 'nil'.

 -- Command: delete-blank-lines
     This function deletes blank lines surrounding point.  If point is
     on a blank line with one or more blank lines before or after it,
     then all but one of them are deleted.  If point is on an isolated
     blank line, then it is deleted.  If point is on a nonblank line,
     the command deletes all blank lines immediately following it.

     A blank line is defined as a line containing only tabs and spaces.

     'delete-blank-lines' returns 'nil'.

 -- Command: delete-trailing-whitespace &optional start end
     Delete trailing whitespace in the region defined by START and END.

     This command deletes whitespace characters after the last
     non-whitespace character in each line in the region.

     If this command acts on the entire buffer (i.e., if called
     interactively with the mark inactive, or called from Lisp with END
     'nil'), it also deletes all trailing lines at the end of the buffer
     if the variable 'delete-trailing-lines' is non-'nil'.

==============================================================================
File: elisp.info,  Node: |The_Kill_Ring|,  Next: |Undo|,  Prev: |User_Level_Deletion|,  Up: |Text|
==============================================================================

                                                                 *The_Kill_Ring*

32.8 The Kill Ring
------------------

"Kill functions" delete text like the deletion functions, but save it so
that the user can reinsert it by "yanking".  Most of these functions
have 'kill-' in their name.  By contrast, the functions whose names
start with 'delete-' normally do not save text for yanking (though they
can still be undone); these are deletion functions.

   Most of the kill commands are primarily for interactive use, and are
not described here.  What we do describe are the functions provided for
use in writing such commands.  You can use these functions to write
commands for killing text.  When you need to delete text for internal
purposes within a Lisp function, you should normally use deletion
functions, so as not to disturb the kill ring contents.  *Note
Deletion::.

   Killed text is saved for later yanking in the "kill ring".  This is a
list that holds a number of recent kills, not just the last text kill.
We call this a "ring" because yanking treats it as having elements in a
cyclic order.  The list is kept in the variable 'kill-ring', and can be
operated on with the usual functions for lists; there are also
specialized functions, described in this section, that treat it as a
ring.

   Some people think this use of the word "kill" is unfortunate, since
it refers to operations that specifically _do not_ destroy the entities
killed.  This is in sharp contrast to ordinary life, in which death is
permanent and killed entities do not come back to life.  Therefore,
other metaphors have been proposed.  For example, the term "cut ring"
makes sense to people who, in pre-computer days, used scissors and paste
to cut up and rearrange manuscripts.  However, it would be difficult to
change the terminology now.

MENU

* |Kill_Ring_Concepts|::     What text looks like in the kill ring.
* |Kill_Functions|::         Functions that kill text.
* |Yanking|::                How yanking is done.
* |Yank_Commands|::          Commands that access the kill ring.
* |Low_Level_Kill_Ring|::    Functions and variables for kill ring access.
* |Internals_of_Kill_Ring|:: Variables that hold kill ring data.

==============================================================================
File: elisp.info,  Node: |Kill_Ring_Concepts|,  Next: |Kill_Functions|,  Up: |The_Kill_Ring|
==============================================================================

                                                            *Kill_Ring_Concepts*

32.8.1 Kill Ring Concepts
-------------------------

The kill ring records killed text as strings in a list, most recent
first.  A short kill ring, for example, might look like this:

     ("some text" "a different piece of text" "even older text")

When the list reaches 'kill-ring-max' entries in length, adding a new
entry automatically deletes the last entry.

   When kill commands are interwoven with other commands, each kill
command makes a new entry in the kill ring.  Multiple kill commands in
succession build up a single kill ring entry, which would be yanked as a
unit; the second and subsequent consecutive kill commands add text to
the entry made by the first one.

   For yanking, one entry in the kill ring is designated the front of
the ring.  Some yank commands rotate the ring by designating a different
element as the front.  But this virtual rotation doesn't change the list
itself--the most recent entry always comes first in the list.

==============================================================================
File: elisp.info,  Node: |Kill_Functions|,  Next: |Yanking|,  Prev: |Kill_Ring_Concepts|,  Up: |The_Kill_Ring|
==============================================================================

                                                                *Kill_Functions*

32.8.2 Functions for Killing
----------------------------

'kill-region' is the usual subroutine for killing text.  Any command
that calls this function is a kill command (and should probably have
'kill' in its name).  'kill-region' puts the newly killed text in a new
element at the beginning of the kill ring or adds it to the most recent
element.  It determines automatically (using 'last-command') whether the
previous command was a kill command, and if so appends the killed text
to the most recent entry.

   The commands described below can filter the killed text before they
save it in the kill ring.  They call 'filter-buffer-substring' (*note
Buffer Contents::) to perform the filtering.  By default, there's no
filtering, but major and minor modes and hook functions can set up
filtering, so that text saved in the kill ring is different from what
was in the buffer.

 -- Command: kill-region start end &optional region
     This function kills the stretch of text between START and END; but
     if the optional argument REGION is non-'nil', it ignores START and
     END, and kills the text in the current region instead.  The text is
     deleted but saved in the kill ring, along with its text properties.
     The value is always 'nil'.

     In an interactive call, START and END are point and the mark, and
     REGION is always non-'nil', so the command always kills the text in
     the current region.

     If the buffer or text is read-only, 'kill-region' modifies the kill
     ring just the same, then signals an error without modifying the
     buffer.  This is convenient because it lets the user use a series
     of kill commands to copy text from a read-only buffer into the kill
     ring.

 -- User Option: kill-read-only-ok
     If this option is non-'nil', 'kill-region' does not signal an error
     if the buffer or text is read-only.  Instead, it simply returns,
     updating the kill ring but not changing the buffer.

 -- Command: copy-region-as-kill start end &optional region
     This function saves the stretch of text between START and END on
     the kill ring (including text properties), but does not delete the
     text from the buffer.  However, if the optional argument REGION is
     non-'nil', the function ignores START and END, and saves the
     current region instead.  It always returns 'nil'.

     In an interactive call, START and END are point and the mark, and
     REGION is always non-'nil', so the command always saves the text in
     the current region.

     The command does not set 'this-command' to 'kill-region', so a
     subsequent kill command does not append to the same kill ring
     entry.

==============================================================================
File: elisp.info,  Node: |Yanking|,  Next: |Yank_Commands|,  Prev: |Kill_Functions|,  Up: |The_Kill_Ring|
==============================================================================

                                                                       *Yanking*

32.8.3 Yanking
--------------

Yanking means inserting text from the kill ring, but it does not insert
the text blindly.  The 'yank' command, and related commands, use
'insert-for-yank' to perform special processing on the text before it is
inserted.

 -- Function: insert-for-yank string
     This function works like 'insert', except that it processes the
     text in STRING according to the 'yank-handler' text property, as
     well as the variables 'yank-handled-properties' and
     'yank-excluded-properties' (see below), before inserting the result
     into the current buffer.

 -- Function: insert-buffer-substring-as-yank buf &optional start end
     This function resembles 'insert-buffer-substring', except that it
     processes the text according to 'yank-handled-properties' and
     'yank-excluded-properties'.  (It does not handle the 'yank-handler'
     property, which does not normally occur in buffer text anyway.)

   If you put a 'yank-handler' text property on all or part of a string,
that alters how 'insert-for-yank' inserts the string.  If different
parts of the string have different 'yank-handler' values (comparison
being done with 'eq'), each substring is handled separately.  The
property value must be a list of one to four elements, with the
following format (where elements after the first may be omitted):

     (FUNCTION PARAM NOEXCLUDE UNDO)

   Here is what the elements do:

FUNCTION
     When FUNCTION is non-'nil', it is called instead of 'insert' to
     insert the string, with one argument--the string to insert.

PARAM
     If PARAM is present and non-'nil', it replaces STRING (or the
     substring of STRING being processed) as the object passed to
     FUNCTION (or 'insert').  For example, if FUNCTION is
     'yank-rectangle', PARAM should be a list of strings to insert as a
     rectangle.

NOEXCLUDE
     If NOEXCLUDE is present and non-'nil', that disables the normal
     action of 'yank-handled-properties' and 'yank-excluded-properties'
     on the inserted string.

UNDO
     If UNDO is present and non-'nil', it is a function that will be
     called by 'yank-pop' to undo the insertion of the current object.
     It is called with two arguments, the start and end of the current
     region.  FUNCTION can set 'yank-undo-function' to override the UNDO
     value.

 -- User Option: yank-handled-properties
     This variable specifies special text property handling conditions
     for yanked text.  It takes effect after the text has been inserted
     (either normally, or via the 'yank-handler' property), and prior to
     'yank-excluded-properties' taking effect.

     The value should be an alist of elements '(PROP . FUN)'.  Each
     alist element is handled in order.  The inserted text is scanned
     for stretches of text having text properties 'eq' to PROP; for each
     such stretch, FUN is called with three arguments: the value of the
     property, and the start and end positions of the text.

 -- User Option: yank-excluded-properties
     The value of this variable is the list of properties to remove from
     inserted text.  Its default value contains properties that might
     lead to annoying results, such as causing the text to respond to
     the mouse or specifying key bindings.  It takes effect after
     'yank-handled-properties'.

==============================================================================
File: elisp.info,  Node: |Yank_Commands|,  Next: |Low_Level_Kill_Ring|,  Prev: |Yanking|,  Up: |The_Kill_Ring|
==============================================================================

                                                                 *Yank_Commands*

32.8.4 Functions for Yanking
----------------------------

This section describes higher-level commands for yanking, which are
intended primarily for the user but useful also in Lisp programs.  Both
'yank' and 'yank-pop' honor the 'yank-excluded-properties' variable and
'yank-handler' text property (*note Yanking::).

 -- Command: yank &optional arg
     This command inserts before point the text at the front of the kill
     ring.  It sets the mark at the beginning of that text, using
     'push-mark' (*note The Mark::), and puts point at the end.

     If ARG is a non-'nil' list (which occurs interactively when the
     user types 'C-u' with no digits), then 'yank' inserts the text as
     described above, but puts point before the yanked text and sets the
     mark after it.

     If ARG is a number, then 'yank' inserts the ARGth most recently
     killed text--the ARGth element of the kill ring list, counted
     cyclically from the front, which is considered the first element
     for this purpose.

     'yank' does not alter the contents of the kill ring, unless it used
     text provided by another program, in which case it pushes that text
     onto the kill ring.  However if ARG is an integer different from
     one, it rotates the kill ring to place the yanked string at the
     front.

     'yank' returns 'nil'.

 -- Command: yank-pop &optional arg
     This command replaces the just-yanked entry from the kill ring with
     a different entry from the kill ring.

     This is allowed only immediately after a 'yank' or another
     'yank-pop'.  At such a time, the region contains text that was just
     inserted by yanking.  'yank-pop' deletes that text and inserts in
     its place a different piece of killed text.  It does not add the
     deleted text to the kill ring, since it is already in the kill ring
     somewhere.  It does however rotate the kill ring to place the newly
     yanked string at the front.

     If ARG is 'nil', then the replacement text is the previous element
     of the kill ring.  If ARG is numeric, the replacement is the ARGth
     previous kill.  If ARG is negative, a more recent kill is the
     replacement.

     The sequence of kills in the kill ring wraps around, so that after
     the oldest one comes the newest one, and before the newest one goes
     the oldest.

     The return value is always 'nil'.

 -- Variable: yank-undo-function
     If this variable is non-'nil', the function 'yank-pop' uses its
     value instead of 'delete-region' to delete the text inserted by the
     previous 'yank' or 'yank-pop' command.  The value must be a
     function of two arguments, the start and end of the current region.

     The function 'insert-for-yank' automatically sets this variable
     according to the UNDO element of the 'yank-handler' text property,
     if there is one.

==============================================================================
File: elisp.info,  Node: |Low_Level_Kill_Ring|,  Next: |Internals_of_Kill_Ring|,  Prev: |Yank_Commands|,  Up: |The_Kill_Ring|
==============================================================================

                                                           *Low_Level_Kill_Ring*

32.8.5 Low-Level Kill Ring
--------------------------

These functions and variables provide access to the kill ring at a lower
level, but are still convenient for use in Lisp programs, because they
take care of interaction with window system selections (*note Window
System Selections::).

 -- Function: current-kill n &optional do-not-move
     The function 'current-kill' rotates the yanking pointer, which
     designates the front of the kill ring, by N places (from newer
     kills to older ones), and returns the text at that place in the
     ring.

     If the optional second argument DO-NOT-MOVE is non-'nil', then
     'current-kill' doesn't alter the yanking pointer; it just returns
     the Nth kill, counting from the current yanking pointer.

     If N is zero, indicating a request for the latest kill,
     'current-kill' calls the value of 'interprogram-paste-function'
     (documented below) before consulting the kill ring.  If that value
     is a function and calling it returns a string or a list of several
     strings, 'current-kill' pushes the strings onto the kill ring and
     returns the first string.  It also sets the yanking pointer to
     point to the kill-ring entry of the first string returned by
     'interprogram-paste-function', regardless of the value of
     DO-NOT-MOVE.  Otherwise, 'current-kill' does not treat a zero value
     for N specially: it returns the entry pointed at by the yanking
     pointer and does not move the yanking pointer.

 -- Function: kill-new string &optional replace
     This function pushes the text STRING onto the kill ring and makes
     the yanking pointer point to it.  It discards the oldest entry if
     appropriate.  It also invokes the values of
     'interprogram-paste-function' (subject to the user option
     'save-interprogram-paste-before-kill') and
     'interprogram-cut-function' (see below).

     If REPLACE is non-'nil', then 'kill-new' replaces the first element
     of the kill ring with STRING, rather than pushing STRING onto the
     kill ring.

 -- Function: kill-append string before-p
     This function appends the text STRING to the first entry in the
     kill ring and makes the yanking pointer point to the combined
     entry.  Normally STRING goes at the end of the entry, but if
     BEFORE-P is non-'nil', it goes at the beginning.  This function
     calls 'kill-new' as a subroutine, thus causing the values of
     'interprogram-cut-function' and possibly
     'interprogram-paste-function' (see below) to be invoked by
     extension.

 -- Variable: interprogram-paste-function
     This variable provides a way of transferring killed text from other
     programs, when you are using a window system.  Its value should be
     'nil' or a function of no arguments.

     If the value is a function, 'current-kill' calls it to get the most
     recent kill.  If the function returns a non-'nil' value, then that
     value is used as the most recent kill.  If it returns 'nil', then
     the front of the kill ring is used.

     To facilitate support for window systems that support multiple
     selections, this function may also return a list of strings.  In
     that case, the first string is used as the most recent kill, and
     all the other strings are pushed onto the kill ring, for easy
     access by 'yank-pop'.

     The normal use of this function is to get the window system's
     clipboard as the most recent kill, even if the selection belongs to
     another application.  *Note Window System Selections::.  However,
     if the clipboard contents come from the current Emacs session, this
     function should return 'nil'.

 -- Variable: interprogram-cut-function
     This variable provides a way of communicating killed text to other
     programs, when you are using a window system.  Its value should be
     'nil' or a function of one required argument.

     If the value is a function, 'kill-new' and 'kill-append' call it
     with the new first element of the kill ring as the argument.

     The normal use of this function is to put newly killed text in the
     window system's clipboard.  *Note Window System Selections::.

==============================================================================
File: elisp.info,  Node: |Internals_of_Kill_Ring|,  Prev: |Low_Level_Kill_Ring|,  Up: |The_Kill_Ring|
==============================================================================

                                                        *Internals_of_Kill_Ring*

32.8.6 Internals of the Kill Ring
---------------------------------

The variable 'kill-ring' holds the kill ring contents, in the form of a
list of strings.  The most recent kill is always at the front of the
list.

   The 'kill-ring-yank-pointer' variable points to a link in the kill
ring list, whose CAR is the text to yank next.  We say it identifies the
front of the ring.  Moving 'kill-ring-yank-pointer' to a different link
is called "rotating the kill ring".  We call the kill ring a "ring"
because the functions that move the yank pointer wrap around from the
end of the list to the beginning, or vice-versa.  Rotation of the kill
ring is virtual; it does not change the value of 'kill-ring'.

   Both 'kill-ring' and 'kill-ring-yank-pointer' are Lisp variables
whose values are normally lists.  The word "pointer" in the name of the
'kill-ring-yank-pointer' indicates that the variable's purpose is to
identify one element of the list for use by the next yank command.

   The value of 'kill-ring-yank-pointer' is always 'eq' to one of the
links in the kill ring list.  The element it identifies is the CAR of
that link.  Kill commands, which change the kill ring, also set this
variable to the value of 'kill-ring'.  The effect is to rotate the ring
so that the newly killed text is at the front.

   Here is a diagram that shows the variable 'kill-ring-yank-pointer'
pointing to the second entry in the kill ring '("some text" "a different
piece of text" "yet older text")'.

     kill-ring                  ---- kill-ring-yank-pointer
       |                       |
       |                       v
       |     --- ---          --- ---      --- ---
        --> |   |   |------> |   |   |--> |   |   |--> nil
             --- ---          --- ---      --- ---
              |                |            |
              |                |            |
              |                |             -->"yet older text"
              |                |
              |                 --> "a different piece of text"
              |
               --> "some text"

This state of affairs might occur after 'C-y' ('yank') immediately
followed by 'M-y' ('yank-pop').

 -- Variable: kill-ring
     This variable holds the list of killed text sequences, most
     recently killed first.

 -- Variable: kill-ring-yank-pointer
     This variable's value indicates which element of the kill ring is
     at the front of the ring for yanking.  More precisely, the value is
     a tail of the value of 'kill-ring', and its CAR is the kill string
     that 'C-y' should yank.

 -- User Option: kill-ring-max
     The value of this variable is the maximum length to which the kill
     ring can grow, before elements are thrown away at the end.  The
     default value for 'kill-ring-max' is 60.

==============================================================================
File: elisp.info,  Node: |Undo|,  Next: |Maintaining_Undo|,  Prev: |The_Kill_Ring|,  Up: |Text|
==============================================================================

                                                                          *Undo*

32.9 Undo
---------

Most buffers have an "undo list", which records all changes made to the
buffer's text so that they can be undone.  (The buffers that don't have
one are usually special-purpose buffers for which Emacs assumes that
undoing is not useful.  In particular, any buffer whose name begins with
a space has its undo recording off by default; see *note Buffer
Names::.)  All the primitives that modify the text in the buffer
automatically add elements to the front of the undo list, which is in
the variable 'buffer-undo-list'.

 -- Variable: buffer-undo-list
     This buffer-local variable's value is the undo list of the current
     buffer.  A value of 't' disables the recording of undo information.

   Here are the kinds of elements an undo list can have:

'POSITION'
     This kind of element records a previous value of point; undoing
     this element moves point to POSITION.  Ordinary cursor motion does
     not make any sort of undo record, but deletion operations use these
     entries to record where point was before the command.

'(BEG . END)'
     This kind of element indicates how to delete text that was
     inserted.  Upon insertion, the text occupied the range BEG-END in
     the buffer.

'(TEXT . POSITION)'
     This kind of element indicates how to reinsert text that was
     deleted.  The deleted text itself is the string TEXT.  The place to
     reinsert it is '(abs POSITION)'.  If POSITION is positive, point
     was at the beginning of the deleted text, otherwise it was at the
     end.  Zero or more (MARKER .  ADJUSTMENT) elements follow
     immediately after this element.

'(t . TIME-FLAG)'
     This kind of element indicates that an unmodified buffer became
     modified.  A TIME-FLAG that is a non-integer Lisp timestamp
     represents the visited file's modification time as of when it was
     previously visited or saved, using the same format as
     'current-time'; see *note Time of Day::.  A TIME-FLAG of 0 means
     the buffer does not correspond to any file; -1 means the visited
     file previously did not exist.  'primitive-undo' uses these values
     to determine whether to mark the buffer as unmodified once again;
     it does so only if the file's status matches that of TIME-FLAG.

'(nil PROPERTY VALUE BEG . END)'
     This kind of element records a change in a text property.  Here's
     how you might undo the change:

          (put-text-property BEG END PROPERTY VALUE)

'(MARKER . ADJUSTMENT)'
     This kind of element records the fact that the marker MARKER was
     relocated due to deletion of surrounding text, and that it moved
     ADJUSTMENT character positions.  If the marker's location is
     consistent with the (TEXT .  POSITION) element preceding it in the
     undo list, then undoing this element moves MARKER - ADJUSTMENT
     characters.

'(apply FUNNAME . ARGS)'
     This is an extensible undo item, which is undone by calling FUNNAME
     with arguments ARGS.

'(apply DELTA BEG END FUNNAME . ARGS)'
     This is an extensible undo item, which records a change limited to
     the range BEG to END, which increased the size of the buffer by
     DELTA characters.  It is undone by calling FUNNAME with arguments
     ARGS.

     This kind of element enables undo limited to a region to determine
     whether the element pertains to that region.

'nil'
     This element is a boundary.  The elements between two boundaries
     are called a "change group"; normally, each change group
     corresponds to one keyboard command, and undo commands normally
     undo an entire group as a unit.

 -- Function: undo-boundary
     This function places a boundary element in the undo list.  The undo
     command stops at such a boundary, and successive undo commands undo
     to earlier and earlier boundaries.  This function returns 'nil'.

     Calling this function explicitly is useful for splitting the
     effects of a command into more than one unit.  For example,
     'query-replace' calls 'undo-boundary' after each replacement, so
     that the user can undo individual replacements one by one.

     Mostly, however, this function is called automatically at an
     appropriate time.

 -- Function: undo-auto-amalgamate
     The editor command loop automatically calls 'undo-boundary' just
     before executing each key sequence, so that each undo normally
     undoes the effects of one command.  A few exceptional commands are
     "amalgamating": these commands generally cause small changes to
     buffers, so with these a boundary is inserted only every 20th
     command, allowing the changes to be undone as a group.  By default,
     the commands 'self-insert-command', which produces self-inserting
     input characters (*note Commands for Insertion::), and
     'delete-char', which deletes characters (*note Deletion::), are
     amalgamating.  Where a command affects the contents of several
     buffers, as may happen, for example, when a function on the
     'post-command-hook' affects a buffer other than the
     'current-buffer', then 'undo-boundary' will be called in each of
     the affected buffers.

     This function can be called before an amalgamating command.  It
     removes the previous 'undo-boundary' if a series of such calls have
     been made.

     The maximum number of changes that can be amalgamated is controlled
     by the 'amalgamating-undo-limit' variable.  If this variable is 1,
     no changes are amalgamated.

 -- Variable: undo-auto-current-boundary-timer
     Some buffers, such as process buffers, can change even when no
     commands are executing.  In these cases, 'undo-boundary' is
     normally called periodically by the timer in this variable.
     Setting this variable to non-'nil' prevents this behavior.

 -- Variable: undo-in-progress
     This variable is normally 'nil', but the undo commands bind it to
     't'.  This is so that various kinds of change hooks can tell when
     they're being called for the sake of undoing.

 -- Function: primitive-undo count list
     This is the basic function for undoing elements of an undo list.
     It undoes the first COUNT elements of LIST, returning the rest of
     LIST.

     'primitive-undo' adds elements to the buffer's undo list when it
     changes the buffer.  Undo commands avoid confusion by saving the
     undo list value at the beginning of a sequence of undo operations.
     Then the undo operations use and update the saved value.  The new
     elements added by undoing are not part of this saved value, so they
     don't interfere with continuing to undo.

     This function does not bind 'undo-in-progress'.

   Some commands leave the region active after execution in such a way
that it interferes with selective undo of that command.  To make 'undo'
ignore the active region when invoked immediately after such a command,
set the property 'undo-inhibit-region' of the command's function symbol
to a non-nil value.  *Note Standard Properties::.

==============================================================================
File: elisp.info,  Node: |Maintaining_Undo|,  Next: |Filling|,  Prev: |Undo|,  Up: |Text|
==============================================================================

                                                              *Maintaining_Undo*

32.10 Maintaining Undo Lists
----------------------------

This section describes how to enable and disable undo information for a
given buffer.  It also explains how the undo list is truncated
automatically so it doesn't get too big.

   Recording of undo information in a newly created buffer is normally
enabled to start with; but if the buffer name starts with a space, the
undo recording is initially disabled.  You can explicitly enable or
disable undo recording with the following two functions, or by setting
'buffer-undo-list' yourself.

 -- Command: buffer-enable-undo &optional buffer-or-name
     This command enables recording undo information for buffer
     BUFFER-OR-NAME, so that subsequent changes can be undone.  If no
     argument is supplied, then the current buffer is used.  This
     function does nothing if undo recording is already enabled in the
     buffer.  It returns 'nil'.

     In an interactive call, BUFFER-OR-NAME is the current buffer.  You
     cannot specify any other buffer.

 -- Command: buffer-disable-undo &optional buffer-or-name
     This function discards the undo list of BUFFER-OR-NAME, and
     disables further recording of undo information.  As a result, it is
     no longer possible to undo either previous changes or any
     subsequent changes.  If the undo list of BUFFER-OR-NAME is already
     disabled, this function has no effect.

     In an interactive call, BUFFER-OR-NAME is the current buffer.  You
     cannot specify any other buffer.  This function returns 'nil'.

   As editing continues, undo lists get longer and longer.  To prevent
them from using up all available memory space, garbage collection trims
them back to size limits you can set.  (For this purpose, the size of an
undo list measures the cons cells that make up the list, plus the
strings of deleted text.)  Three variables control the range of
acceptable sizes: 'undo-limit', 'undo-strong-limit' and
'undo-outer-limit'.  In these variables, size is counted as the number
of bytes occupied, which includes both saved text and other data.

 -- User Option: undo-limit
     This is the soft limit for the acceptable size of an undo list.
     The change group at which this size is exceeded is the last one
     kept.

 -- User Option: undo-strong-limit
     This is the upper limit for the acceptable size of an undo list.
     The change group at which this size is exceeded is discarded itself
     (along with all older change groups).  There is one exception: the
     very latest change group is only discarded if it exceeds
     'undo-outer-limit'.

 -- User Option: undo-outer-limit
     If at garbage collection time the undo info for the current command
     exceeds this limit, Emacs discards the info and displays a warning.
     This is a last ditch limit to prevent memory overflow.

 -- User Option: undo-ask-before-discard
     If this variable is non-'nil', when the undo info exceeds
     'undo-outer-limit', Emacs asks in the echo area whether to discard
     the info.  The default value is 'nil', which means to discard it
     automatically.

     This option is mainly intended for debugging.  Garbage collection
     is inhibited while the question is asked, which means that Emacs
     might leak memory if the user waits too long before answering the
     question.

==============================================================================
File: elisp.info,  Node: |Filling|,  Next: |Margins|,  Prev: |Maintaining_Undo|,  Up: |Text|
==============================================================================

                                                                       *Filling*

32.11 Filling
-------------

"Filling" means adjusting the lengths of lines (by moving the line
breaks) so that they are nearly (but no greater than) a specified
maximum width.  Additionally, lines can be "justified", which means
inserting spaces to make the left and/or right margins line up
precisely.  The width is controlled by the variable 'fill-column'.  For
ease of reading, lines should be no longer than 70 or so columns.

   You can use Auto Fill mode (*note Auto Filling::) to fill text
automatically as you insert it, but changes to existing text may leave
it improperly filled.  Then you must fill the text explicitly.

   Most of the commands in this section return values that are not
meaningful.  All the functions that do filling take note of the current
left margin, current right margin, and current justification style
(*note Margins::).  If the current justification style is 'none', the
filling functions don't actually do anything.

   Several of the filling functions have an argument JUSTIFY.  If it is
non-'nil', that requests some kind of justification.  It can be 'left',
'right', 'full', or 'center', to request a specific style of
justification.  If it is 't', that means to use the current
justification style for this part of the text (see
'current-justification', below).  Any other value is treated as 'full'.

   When you call the filling functions interactively, using a prefix
argument implies the value 'full' for JUSTIFY.

 -- Command: fill-paragraph &optional justify region
     This command fills the paragraph at or after point.  If JUSTIFY is
     non-'nil', each line is justified as well.  It uses the ordinary
     paragraph motion commands to find paragraph boundaries.  *Note
     (emacs)Paragraphs::.

     When REGION is non-'nil', then if Transient Mark mode is enabled
     and the mark is active, this command calls 'fill-region' to fill
     all the paragraphs in the region, instead of filling only the
     current paragraph.  When this command is called interactively,
     REGION is 't'.

 -- Command: fill-region start end &optional justify nosqueeze to-eop
     This command fills each of the paragraphs in the region from START
     to END.  It justifies as well if JUSTIFY is non-'nil'.

     If NOSQUEEZE is non-'nil', that means to leave whitespace other
     than line breaks untouched.  If TO-EOP is non-'nil', that means to
     keep filling to the end of the paragraph--or the next hard newline,
     if 'use-hard-newlines' is enabled (see below).

     The variable 'paragraph-separate' controls how to distinguish
     paragraphs.  *Note Standard Regexps::.

 -- Command: fill-individual-paragraphs start end &optional justify
          citation-regexp
     This command fills each paragraph in the region according to its
     individual fill prefix.  Thus, if the lines of a paragraph were
     indented with spaces, the filled paragraph will remain indented in
     the same fashion.

     The first two arguments, START and END, are the beginning and end
     of the region to be filled.  The third and fourth arguments,
     JUSTIFY and CITATION-REGEXP, are optional.  If JUSTIFY is
     non-'nil', the paragraphs are justified as well as filled.  If
     CITATION-REGEXP is non-'nil', it means the function is operating on
     a mail message and therefore should not fill the header lines.  If
     CITATION-REGEXP is a string, it is used as a regular expression; if
     it matches the beginning of a line, that line is treated as a
     citation marker.

     Ordinarily, 'fill-individual-paragraphs' regards each change in
     indentation as starting a new paragraph.  If
     'fill-individual-varying-indent' is non-'nil', then only separator
     lines separate paragraphs.  That mode can handle indented
     paragraphs with additional indentation on the first line.

 -- User Option: fill-individual-varying-indent
     This variable alters the action of 'fill-individual-paragraphs' as
     described above.

 -- Command: fill-region-as-paragraph start end &optional justify
          nosqueeze squeeze-after
     This command considers a region of text as a single paragraph and
     fills it.  If the region was made up of many paragraphs, the blank
     lines between paragraphs are removed.  This function justifies as
     well as filling when JUSTIFY is non-'nil'.

     If NOSQUEEZE is non-'nil', that means to leave whitespace other
     than line breaks untouched.  If SQUEEZE-AFTER is non-'nil', it
     specifies a position in the region, and means don't canonicalize
     spaces before that position.

     In Adaptive Fill mode, this command calls 'fill-context-prefix' to
     choose a fill prefix by default.  *Note Adaptive Fill::.

 -- Command: justify-current-line &optional how eop nosqueeze
     This command inserts spaces between the words of the current line
     so that the line ends exactly at 'fill-column'.  It returns 'nil'.

     The argument HOW, if non-'nil' specifies explicitly the style of
     justification.  It can be 'left', 'right', 'full', 'center', or
     'none'.  If it is 't', that means to follow specified justification
     style (see 'current-justification', below).  'nil' means to do full
     justification.

     If EOP is non-'nil', that means do only left-justification if
     'current-justification' specifies full justification.  This is used
     for the last line of a paragraph; even if the paragraph as a whole
     is fully justified, the last line should not be.

     If NOSQUEEZE is non-'nil', that means do not change interior
     whitespace.

 -- User Option: default-justification
     This variable's value specifies the style of justification to use
     for text that doesn't specify a style with a text property.  The
     possible values are 'left', 'right', 'full', 'center', or 'none'.
     The default value is 'left'.

 -- Function: current-justification
     This function returns the proper justification style to use for
     filling the text around point.

     This returns the value of the 'justification' text property at
     point, or the variable 'default-justification' if there is no such
     text property.  However, it returns 'nil' rather than 'none' to
     mean "don't justify".

 -- User Option: sentence-end-double-space
     If this variable is non-'nil', a period followed by just one space
     does not count as the end of a sentence, and the filling functions
     avoid breaking the line at such a place.

 -- User Option: sentence-end-without-period
     If this variable is non-'nil', a sentence can end without a period.
     This is used for languages like Thai, where sentences end with a
     double space but without a period.

 -- User Option: sentence-end-without-space
     If this variable is non-'nil', it should be a string of characters
     that can end a sentence without following spaces.

 -- User Option: fill-separate-heterogeneous-words-with-space
     If this variable is non-'nil', two words of different kind (e.g.,
     English and CJK) will be separated with a space when concatenating
     one that is in the end of a line and the other that is in the
     beginning of the next line for filling.

 -- Variable: fill-paragraph-function
     This variable provides a way to override the filling of paragraphs.
     If its value is non-'nil', 'fill-paragraph' calls this function to
     do the work.  If the function returns a non-'nil' value,
     'fill-paragraph' assumes the job is done, and immediately returns
     that value.

     The usual use of this feature is to fill comments in programming
     language modes.  If the function needs to fill a paragraph in the
     usual way, it can do so as follows:

          (let ((fill-paragraph-function nil))
            (fill-paragraph arg))

 -- Variable: fill-forward-paragraph-function
     This variable provides a way to override how the filling functions,
     such as 'fill-region' and 'fill-paragraph', move forward to the
     next paragraph.  Its value should be a function, which is called
     with a single argument N, the number of paragraphs to move, and
     should return the difference between N and the number of paragraphs
     actually moved.  The default value of this variable is
     'forward-paragraph'.  *Note (emacs)Paragraphs::.

 -- Variable: use-hard-newlines
     If this variable is non-'nil', the filling functions do not delete
     newlines that have the 'hard' text property.  These hard newlines
     act as paragraph separators.  *Note Hard and Soft Newlines:
     (emacs)Hard and Soft Newlines.

==============================================================================
File: elisp.info,  Node: |Margins|,  Next: |Adaptive_Fill|,  Prev: |Filling|,  Up: |Text|
==============================================================================

                                                                       *Margins*

32.12 Margins for Filling
-------------------------

 -- User Option: fill-prefix
     This buffer-local variable, if non-'nil', specifies a string of
     text that appears at the beginning of normal text lines and should
     be disregarded when filling them.  Any line that fails to start
     with the fill prefix is considered the start of a paragraph; so is
     any line that starts with the fill prefix followed by additional
     whitespace.  Lines that start with the fill prefix but no
     additional whitespace are ordinary text lines that can be filled
     together.  The resulting filled lines also start with the fill
     prefix.

     The fill prefix follows the left margin whitespace, if any.

 -- User Option: fill-column
     This buffer-local variable specifies the maximum width of filled
     lines.  Its value should be an integer, which is a number of
     columns.  All the filling, justification, and centering commands
     are affected by this variable, including Auto Fill mode (*note Auto
     Filling::).

     As a practical matter, if you are writing text for other people to
     read, you should set 'fill-column' to no more than 70.  Otherwise
     the line will be too long for people to read comfortably, and this
     can make the text seem clumsy.

     The default value for 'fill-column' is 70.

 -- Command: set-left-margin from to margin
     This sets the 'left-margin' property on the text from FROM to TO to
     the value MARGIN.  If Auto Fill mode is enabled, this command also
     refills the region to fit the new margin.

 -- Command: set-right-margin from to margin
     This sets the 'right-margin' property on the text from FROM to TO
     to the value MARGIN.  If Auto Fill mode is enabled, this command
     also refills the region to fit the new margin.

 -- Function: current-left-margin
     This function returns the proper left margin value to use for
     filling the text around point.  The value is the sum of the
     'left-margin' property of the character at the start of the current
     line (or zero if none), and the value of the variable
     'left-margin'.

 -- Function: current-fill-column
     This function returns the proper fill column value to use for
     filling the text around point.  The value is the value of the
     'fill-column' variable, minus the value of the 'right-margin'
     property of the character after point.

 -- Command: move-to-left-margin &optional n force
     This function moves point to the left margin of the current line.
     The column moved to is determined by calling the function
     'current-left-margin'.  If the argument N is non-'nil',
     'move-to-left-margin' moves forward N-1 lines first.

     If FORCE is non-'nil', that says to fix the line's indentation if
     that doesn't match the left margin value.

 -- Function: delete-to-left-margin &optional from to
     This function removes left margin indentation from the text between
     FROM and TO.  The amount of indentation to delete is determined by
     calling 'current-left-margin'.  In no case does this function
     delete non-whitespace.  If FROM and TO are omitted, they default to
     the whole buffer.

 -- Function: indent-to-left-margin
     This function adjusts the indentation at the beginning of the
     current line to the value specified by the variable 'left-margin'.
     (That may involve either inserting or deleting whitespace.)  This
     function is value of 'indent-line-function' in Paragraph-Indent
     Text mode.

 -- User Option: left-margin
     This variable specifies the base left margin column.  In
     Fundamental mode, <RET> indents to this column.  This variable
     automatically becomes buffer-local when set in any fashion.

 -- User Option: fill-nobreak-predicate
     This variable gives major modes a way to specify not to break a
     line at certain places.  Its value should be a list of functions.
     Whenever filling considers breaking the line at a certain place in
     the buffer, it calls each of these functions with no arguments and
     with point located at that place.  If any of the functions returns
     non-'nil', then the line won't be broken there.

==============================================================================
File: elisp.info,  Node: |Adaptive_Fill|,  Next: |Auto_Filling|,  Prev: |Margins|,  Up: |Text|
==============================================================================

                                                                 *Adaptive_Fill*

32.13 Adaptive Fill Mode
------------------------

When "Adaptive Fill Mode" is enabled, Emacs determines the fill prefix
automatically from the text in each paragraph being filled rather than
using a predetermined value.  During filling, this fill prefix gets
inserted at the start of the second and subsequent lines of the
paragraph as described in *note Filling::, and in *note Auto Filling::.

 -- User Option: adaptive-fill-mode
     Adaptive Fill mode is enabled when this variable is non-'nil'.  It
     is 't' by default.

 -- Function: fill-context-prefix from to
     This function implements the heart of Adaptive Fill mode; it
     chooses a fill prefix based on the text between FROM and TO,
     typically the start and end of a paragraph.  It does this by
     looking at the first two lines of the paragraph, based on the
     variables described below.

     Usually, this function returns the fill prefix, a string.  However,
     before doing this, the function makes a final check (not specially
     mentioned in the following) that a line starting with this prefix
     wouldn't look like the start of a paragraph.  Should this happen,
     the function signals the anomaly by returning 'nil' instead.

     In detail, 'fill-context-prefix' does this:

       1. It takes a candidate for the fill prefix from the first
          line--it tries first the function in 'adaptive-fill-function'
          (if any), then the regular expression 'adaptive-fill-regexp'
          (see below).  The first non-'nil' result of these, or the
          empty string if they're both 'nil', becomes the first line's
          candidate.
       2. If the paragraph has as yet only one line, the function tests
          the validity of the prefix candidate just found.  The function
          then returns the candidate if it's valid, or a string of
          spaces otherwise.  (see the description of
          'adaptive-fill-first-line-regexp' below).
       3. When the paragraph already has two lines, the function next
          looks for a prefix candidate on the second line, in just the
          same way it did for the first line.  If it doesn't find one,
          it returns 'nil'.
       4. The function now compares the two candidate prefixes
          heuristically: if the non-whitespace characters in the line 2
          candidate occur in the same order in the line 1 candidate, the
          function returns the line 2 candidate.  Otherwise, it returns
          the largest initial substring which is common to both
          candidates (which might be the empty string).

 -- User Option: adaptive-fill-regexp
     Adaptive Fill mode matches this regular expression against the text
     starting after the left margin whitespace (if any) on a line; the
     characters it matches are that line's candidate for the fill
     prefix.

     The default value matches whitespace with certain punctuation
     characters intermingled.

 -- User Option: adaptive-fill-first-line-regexp
     Used only in one-line paragraphs, this regular expression acts as
     an additional check of the validity of the one available candidate
     fill prefix: the candidate must match this regular expression, or
     match 'comment-start-skip'.  If it doesn't, 'fill-context-prefix'
     replaces the candidate with a string of spaces of the same width as
     it.

     The default value of this variable is '"\\`[ \t]*\\'"', which
     matches only a string of whitespace.  The effect of this default is
     to force the fill prefixes found in one-line paragraphs always to
     be pure whitespace.

 -- User Option: adaptive-fill-function
     You can specify more complex ways of choosing a fill prefix
     automatically by setting this variable to a function.  The function
     is called with point after the left margin (if any) of a line, and
     it must preserve point.  It should return either that line's fill
     prefix or 'nil', meaning it has failed to determine a prefix.

==============================================================================
File: elisp.info,  Node: |Auto_Filling|,  Next: |Sorting|,  Prev: |Adaptive_Fill|,  Up: |Text|
==============================================================================

                                                                  *Auto_Filling*

32.14 Auto Filling
------------------

Auto Fill mode is a minor mode that fills lines automatically as text is
inserted.  *Note (emacs)Auto Fill::.  This section describes some
variables used by Auto Fill mode.  For a description of functions that
you can call explicitly to fill and justify existing text, see *note
Filling::.

   Auto Fill mode also enables the functions that change the margins and
justification style to refill portions of the text.  *Note Margins::.

 -- Variable: auto-fill-function
     The value of this buffer-local variable should be a function (of no
     arguments) to be called after self-inserting a character from the
     table 'auto-fill-chars', see below.  It may be 'nil', in which case
     nothing special is done in that case.

     The value of 'auto-fill-function' is 'do-auto-fill' when Auto Fill
     mode is enabled.  That is a function whose sole purpose is to
     implement the usual strategy for breaking a line.

 -- Variable: normal-auto-fill-function
     This variable specifies the function to use for
     'auto-fill-function', if and when Auto Fill is turned on.  Major
     modes can set buffer-local values for this variable to alter how
     Auto Fill works.

 -- Variable: auto-fill-chars
     A char table of characters which invoke 'auto-fill-function' when
     self-inserted--space and newline in most language environments.
     They have an entry 't' in the table.

 -- User Option: comment-auto-fill-only-comments
     This variable, if non-'nil', means to fill lines automatically
     within comments only.  More precisely, this means that if a comment
     syntax was defined for the current buffer, then self-inserting a
     character outside of a comment will not call 'auto-fill-function'.

==============================================================================
File: elisp.info,  Node: |Sorting|,  Next: |Columns|,  Prev: |Auto_Filling|,  Up: |Text|
==============================================================================

                                                                       *Sorting*

32.15 Sorting Text
------------------

The sorting functions described in this section all rearrange text in a
buffer.  This is in contrast to the function 'sort', which rearranges
the order of the elements of a list (*note Rearrangement::).  The values
returned by these functions are not meaningful.

 -- Function: sort-subr reverse nextrecfun endrecfun &optional
          startkeyfun endkeyfun predicate
     This function is the general text-sorting routine that subdivides a
     buffer into records and then sorts them.  Most of the commands in
     this section use this function.

     To understand how 'sort-subr' works, consider the whole accessible
     portion of the buffer as being divided into disjoint pieces called
     "sort records".  The records may or may not be contiguous, but they
     must not overlap.  A portion of each sort record (perhaps all of
     it) is designated as the sort key.  Sorting rearranges the records
     in order by their sort keys.

     Usually, the records are rearranged in order of ascending sort key.
     If the first argument to the 'sort-subr' function, REVERSE, is
     non-'nil', the sort records are rearranged in order of descending
     sort key.

     The next four arguments to 'sort-subr' are functions that are
     called to move point across a sort record.  They are called many
     times from within 'sort-subr'.

       1. NEXTRECFUN is called with point at the end of a record.  This
          function moves point to the start of the next record.  The
          first record is assumed to start at the position of point when
          'sort-subr' is called.  Therefore, you should usually move
          point to the beginning of the buffer before calling
          'sort-subr'.

          This function can indicate there are no more sort records by
          leaving point at the end of the buffer.

       2. ENDRECFUN is called with point within a record.  It moves
          point to the end of the record.

       3. STARTKEYFUN is called to move point from the start of a record
          to the start of the sort key.  This argument is optional; if
          it is omitted, the whole record is the sort key.  If supplied,
          the function should either return a non-'nil' value to be used
          as the sort key, or return 'nil' to indicate that the sort key
          is in the buffer starting at point.  In the latter case,
          ENDKEYFUN is called to find the end of the sort key.

       4. ENDKEYFUN is called to move point from the start of the sort
          key to the end of the sort key.  This argument is optional.
          If STARTKEYFUN returns 'nil' and this argument is omitted (or
          'nil'), then the sort key extends to the end of the record.
          There is no need for ENDKEYFUN if STARTKEYFUN returns a
          non-'nil' value.

     The argument PREDICATE is the function to use to compare keys.  It
     is called with two arguments, the keys to compare, and should
     return non-'nil' if the first key should come before the second in
     the sorting order.  What exactly are the key arguments depends on
     what STARTKEYFUN and ENDKEYFUN return.  If PREDICATE is omitted or
     'nil', it defaults to '<' if the keys are numbers, to
     'compare-buffer-substrings' if the keys are cons cells (whose 'car'
     and 'cdr' are start and end buffer positions of the key), and to
     'string<' otherwise (with keys assumed to be strings).

     As an example of 'sort-subr', here is the complete function
     definition for 'sort-lines':

          ;; Note that the first two lines of doc string
          ;; are effectively one line when viewed by a user.
          (defun sort-lines (reverse beg end)
            "Sort lines in region alphabetically;\
           argument means descending order.
          Called from a program, there are three arguments:
          REVERSE (non-nil means reverse order),\
           BEG and END (region to sort).
          The variable `sort-fold-case' determines\
           whether alphabetic case affects
          the sort order."
            (interactive "P\nr")
            (save-excursion
              (save-restriction
                (narrow-to-region beg end)
                (goto-char (point-min))
                (let ((inhibit-field-text-motion t))
                  (sort-subr reverse 'forward-line 'end-of-line)))))

     Here 'forward-line' moves point to the start of the next record,
     and 'end-of-line' moves point to the end of record.  We do not pass
     the arguments STARTKEYFUN and ENDKEYFUN, because the entire record
     is used as the sort key.

     The 'sort-paragraphs' function is very much the same, except that
     its 'sort-subr' call looks like this:

          (sort-subr reverse
                     (lambda ()
                       (while (and (not (eobp))
                                   (looking-at paragraph-separate))
                         (forward-line 1)))
                     'forward-paragraph)

     Markers pointing into any sort records are left with no useful
     position after 'sort-subr' returns.

 -- User Option: sort-fold-case
     If this variable is non-'nil', 'sort-subr' and the other buffer
     sorting functions ignore case when comparing strings.

 -- Command: sort-regexp-fields reverse record-regexp key-regexp start
          end
     This command sorts the region between START and END alphabetically
     as specified by RECORD-REGEXP and KEY-REGEXP.  If REVERSE is a
     negative integer, then sorting is in reverse order.

     Alphabetical sorting means that two sort keys are compared by
     comparing the first characters of each, the second characters of
     each, and so on.  If a mismatch is found, it means that the sort
     keys are unequal; the sort key whose character is less at the point
     of first mismatch is the lesser sort key.  The individual
     characters are compared according to their numerical character
     codes in the Emacs character set.

     The value of the RECORD-REGEXP argument specifies how to divide the
     buffer into sort records.  At the end of each record, a search is
     done for this regular expression, and the text that matches it is
     taken as the next record.  For example, the regular expression
     '^.+$', which matches lines with at least one character besides a
     newline, would make each such line into a sort record.  *Note
     Regular Expressions::, for a description of the syntax and meaning
     of regular expressions.

     The value of the KEY-REGEXP argument specifies what part of each
     record is the sort key.  The KEY-REGEXP could match the whole
     record, or only a part.  In the latter case, the rest of the record
     has no effect on the sorted order of records, but it is carried
     along when the record moves to its new position.

     The KEY-REGEXP argument can refer to the text matched by a
     subexpression of RECORD-REGEXP, or it can be a regular expression
     on its own.

     If KEY-REGEXP is:

     '\DIGIT'
          then the text matched by the DIGITth '\(...\)' parenthesis
          grouping in RECORD-REGEXP is the sort key.

     '\&'
          then the whole record is the sort key.

     a regular expression
          then 'sort-regexp-fields' searches for a match for the regular
          expression within the record.  If such a match is found, it is
          the sort key.  If there is no match for KEY-REGEXP within a
          record then that record is ignored, which means its position
          in the buffer is not changed.  (The other records may move
          around it.)

     For example, if you plan to sort all the lines in the region by the
     first word on each line starting with the letter 'f', you should
     set RECORD-REGEXP to '^.*$' and set KEY-REGEXP to '\<f\w*\>'.  The
     resulting expression looks like this:

          (sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                              (region-beginning)
                              (region-end))

     If you call 'sort-regexp-fields' interactively, it prompts for
     RECORD-REGEXP and KEY-REGEXP in the minibuffer.

 -- Command: sort-lines reverse start end
     This command alphabetically sorts lines in the region between START
     and END.  If REVERSE is non-'nil', the sort is in reverse order.

 -- Command: sort-paragraphs reverse start end
     This command alphabetically sorts paragraphs in the region between
     START and END.  If REVERSE is non-'nil', the sort is in reverse
     order.

 -- Command: sort-pages reverse start end
     This command alphabetically sorts pages in the region between START
     and END.  If REVERSE is non-'nil', the sort is in reverse order.

 -- Command: sort-fields field start end
     This command sorts lines in the region between START and END,
     comparing them alphabetically by the FIELDth field of each line.
     Fields are separated by whitespace and numbered starting from 1.
     If FIELD is negative, sorting is by the -FIELDth field from the end
     of the line.  This command is useful for sorting tables.

 -- Command: sort-numeric-fields field start end
     This command sorts lines in the region between START and END,
     comparing them numerically by the FIELDth field of each line.
     Fields are separated by whitespace and numbered starting from 1.
     The specified field must contain a number in each line of the
     region.  Numbers starting with 0 are treated as octal, and numbers
     starting with '0x' are treated as hexadecimal.

     If FIELD is negative, sorting is by the -FIELDth field from the end
     of the line.  This command is useful for sorting tables.

 -- User Option: sort-numeric-base
     This variable specifies the default radix for 'sort-numeric-fields'
     to parse numbers.

 -- Command: sort-columns reverse &optional beg end
     This command sorts the lines in the region between BEG and END,
     comparing them alphabetically by a certain range of columns.  The
     column positions of BEG and END bound the range of columns to sort
     on.

     If REVERSE is non-'nil', the sort is in reverse order.

     One unusual thing about this command is that the entire line
     containing position BEG, and the entire line containing position
     END, are included in the region sorted.

     Note that 'sort-columns' rejects text that contains tabs, because
     tabs could be split across the specified columns.  Use 'M-x
     untabify' to convert tabs to spaces before sorting.

     When possible, this command actually works by calling the 'sort'
     utility program.

==============================================================================
File: elisp.info,  Node: |Columns|,  Next: |Indentation|,  Prev: |Sorting|,  Up: |Text|
==============================================================================

                                                                       *Columns*

32.16 Counting Columns
----------------------

The column functions convert between a character position (counting
characters from the beginning of the buffer) and a column position
(counting screen characters from the beginning of a line).

   These functions count each character according to the number of
columns it occupies on the screen.  This means control characters count
as occupying 2 or 4 columns, depending upon the value of 'ctl-arrow',
and tabs count as occupying a number of columns that depends on the
value of 'tab-width' and on the column where the tab begins.  *Note
Usual Display::.

   Column number computations ignore the width of the window and the
amount of horizontal scrolling.  Consequently, a column value can be
arbitrarily high.  The first (or leftmost) column is numbered 0.  They
also ignore overlays and text properties, aside from invisibility.

 -- Function: current-column
     This function returns the horizontal position of point, measured in
     columns, counting from 0 at the left margin.  The column position
     is the sum of the widths of all the displayed representations of
     the characters between the start of the current line and point.

 -- Command: move-to-column column &optional force
     This function moves point to COLUMN in the current line.  The
     calculation of COLUMN takes into account the widths of the
     displayed representations of the characters between the start of
     the line and point.

     When called interactively, COLUMN is the value of prefix numeric
     argument.  If COLUMN is not an integer, an error is signaled.

     If it is impossible to move to column COLUMN because that is in the
     middle of a multicolumn character such as a tab, point moves to the
     end of that character.  However, if FORCE is non-'nil', and COLUMN
     is in the middle of a tab, then 'move-to-column' either converts
     the tab into spaces (when 'indent-tabs-mode' is 'nil'), or inserts
     enough spaces before it (otherwise), so that point can move
     precisely to column COLUMN.  Other multicolumn characters can cause
     anomalies despite FORCE, since there is no way to split them.

     The argument FORCE also has an effect if the line isn't long enough
     to reach column COLUMN; if it is 't', that means to add whitespace
     at the end of the line to reach that column.

     The return value is the column number actually moved to.

==============================================================================
File: elisp.info,  Node: |Indentation|,  Next: |Case_Changes|,  Prev: |Columns|,  Up: |Text|
==============================================================================

                                                                   *Indentation*

32.17 Indentation
-----------------

The indentation functions are used to examine, move to, and change
whitespace that is at the beginning of a line.  Some of the functions
can also change whitespace elsewhere on a line.  Columns and indentation
count from zero at the left margin.

MENU

* |Primitive_Indent|::      Functions used to count and insert indentation.
* |Mode_Specific_Indent|::  Customize indentation for different modes.
* |Region_Indent|::         Indent all the lines in a region.
* |Relative_Indent|::       Indent the current line based on previous lines.
* |Indent_Tabs|::           Adjustable, typewriter-like tab stops.
* |Motion_by_Indent|::      Move to first non-blank character.

==============================================================================
File: elisp.info,  Node: |Primitive_Indent|,  Next: |Mode_Specific_Indent|,  Up: |Indentation|
==============================================================================

                                                              *Primitive_Indent*

32.17.1 Indentation Primitives
------------------------------

This section describes the primitive functions used to count and insert
indentation.  The functions in the following sections use these
primitives.  *Note Size of Displayed Text::, for related functions.

 -- Function: current-indentation
     This function returns the indentation of the current line, which is
     the horizontal position of the first nonblank character.  If the
     contents are entirely blank, then this is the horizontal position
     of the end of the line.

 -- Command: indent-to column &optional minimum
     This function indents from point with tabs and spaces until COLUMN
     is reached.  If MINIMUM is specified and non-'nil', then at least
     that many spaces are inserted even if this requires going beyond
     COLUMN.  Otherwise the function does nothing if point is already
     beyond COLUMN.  The value is the column at which the inserted
     indentation ends.

     The inserted whitespace characters inherit text properties from the
     surrounding text (usually, from the preceding text only).  *Note
     Sticky Properties::.

 -- User Option: indent-tabs-mode
     If this variable is non-'nil', indentation functions can insert
     tabs as well as spaces.  Otherwise, they insert only spaces.
     Setting this variable automatically makes it buffer-local in the
     current buffer.

==============================================================================
File: elisp.info,  Node: |Mode_Specific_Indent|,  Next: |Region_Indent|,  Prev: |Primitive_Indent|,  Up: |Indentation|
==============================================================================

                                                          *Mode_Specific_Indent*

32.17.2 Indentation Controlled by Major Mode
--------------------------------------------

An important function of each major mode is to customize the <TAB> key
to indent properly for the language being edited.  This section
describes the mechanism of the <TAB> key and how to control it.  The
functions in this section return unpredictable values.

 -- Command: indent-for-tab-command &optional rigid
     This is the command bound to <TAB> in most editing modes.  Its
     usual action is to indent the current line, but it can
     alternatively insert a tab character or indent a region.

     Here is what it does:

        * First, it checks whether Transient Mark mode is enabled and
          the region is active.  If so, it calls 'indent-region' to
          indent all the text in the region (*note Region Indent::).

        * Otherwise, if the indentation function in
          'indent-line-function' is 'indent-to-left-margin' (a trivial
          command that inserts a tab character), or if the variable
          'tab-always-indent' specifies that a tab character ought to be
          inserted (see below), then it inserts a tab character.

        * Otherwise, it indents the current line; this is done by
          calling the function in 'indent-line-function'.  If the line
          is already indented, and the value of 'tab-always-indent' is
          'complete' (see below), it tries completing the text at point.

     If RIGID is non-'nil' (interactively, with a prefix argument), then
     after this command indents a line or inserts a tab, it also rigidly
     indents the entire balanced expression which starts at the
     beginning of the current line, in order to reflect the new
     indentation.  This argument is ignored if the command indents the
     region.

 -- Variable: indent-line-function
     This variable's value is the function to be used by
     'indent-for-tab-command', and various other indentation commands,
     to indent the current line.  It is usually assigned by the major
     mode; for instance, Lisp mode sets it to 'lisp-indent-line', C mode
     sets it to 'c-indent-line', and so on.  The default value is
     'indent-relative'.  *Note Auto-Indentation::.

 -- Command: indent-according-to-mode
     This command calls the function in 'indent-line-function' to indent
     the current line in a way appropriate for the current major mode.

 -- Command: newline-and-indent
     This function inserts a newline, then indents the new line (the one
     following the newline just inserted) according to the major mode.
     It does indentation by calling 'indent-according-to-mode'.

 -- Command: reindent-then-newline-and-indent
     This command reindents the current line, inserts a newline at
     point, and then indents the new line (the one following the newline
     just inserted).  It does indentation on both lines by calling
     'indent-according-to-mode'.

 -- User Option: tab-always-indent
     This variable can be used to customize the behavior of the <TAB>
     ('indent-for-tab-command') command.  If the value is 't' (the
     default), the command normally just indents the current line.  If
     the value is 'nil', the command indents the current line only if
     point is at the left margin or in the line's indentation;
     otherwise, it inserts a tab character.  If the value is 'complete',
     the command first tries to indent the current line, and if the line
     was already indented, it calls 'completion-at-point' to complete
     the text at point (*note Completion in Buffers::).

   Some major modes need to support embedded regions of text whose
syntax belongs to a different major mode.  Examples include "literate
programming" source files that combine documentation and snippets of
source code, Yacc/Bison programs that include snippets of Python or JS
code, etc.  To correctly indent the embedded chunks, the primary mode
needs to delegate the indentation to another mode's indentation engine
(e.g., call 'js-indent-line' for JS code or 'python-indent-line' for
Python), while providing it with some context to guide the indentation.
Major modes, for their part, should avoid calling 'widen' in their
indentation code and obey 'prog-first-column'.

 -- Variable: prog-indentation-context
     This variable, when non-'nil', holds the indentation context for
     the sub-mode's indentation engine provided by the superior major
     mode.  The value should be a list of the form '(FIRST-COLUMN .
     REST'.  The members of the list have the following meaning:

     FIRST-COLUMN
          The column to be used for top-level constructs.  This replaces
          the default value of the top-level column used by the
          sub-mode, usually zero.
     REST
          This value is currently unused.

   The following convenience function should be used by major mode's
indentation engine in support of invocations as sub-modes of another
major mode.

 -- Function: prog-first-column
     Call this function instead of using a literal value (usually, zero)
     of the column number for indenting top-level program constructs.
     The function's value is the column number to use for top-level
     constructs.  When no superior mode is in effect, this function
     returns zero.

==============================================================================
File: elisp.info,  Node: |Region_Indent|,  Next: |Relative_Indent|,  Prev: |Mode_Specific_Indent|,  Up: |Indentation|
==============================================================================

                                                                 *Region_Indent*

32.17.3 Indenting an Entire Region
----------------------------------

This section describes commands that indent all the lines in the region.
They return unpredictable values.

 -- Command: indent-region start end &optional to-column
     This command indents each nonblank line starting between START
     (inclusive) and END (exclusive).  If TO-COLUMN is 'nil',
     'indent-region' indents each nonblank line by calling the current
     mode's indentation function, the value of 'indent-line-function'.

     If TO-COLUMN is non-'nil', it should be an integer specifying the
     number of columns of indentation; then this function gives each
     line exactly that much indentation, by either adding or deleting
     whitespace.

     If there is a fill prefix, 'indent-region' indents each line by
     making it start with the fill prefix.

 -- Variable: indent-region-function
     The value of this variable is a function that can be used by
     'indent-region' as a short cut.  It should take two arguments, the
     start and end of the region.  You should design the function so
     that it will produce the same results as indenting the lines of the
     region one by one, but presumably faster.

     If the value is 'nil', there is no short cut, and 'indent-region'
     actually works line by line.

     A short-cut function is useful in modes such as C mode and Lisp
     mode, where the 'indent-line-function' must scan from the beginning
     of the function definition: applying it to each line would be
     quadratic in time.  The short cut can update the scan information
     as it moves through the lines indenting them; this takes linear
     time.  In a mode where indenting a line individually is fast, there
     is no need for a short cut.

     'indent-region' with a non-'nil' argument TO-COLUMN has a different
     meaning and does not use this variable.

 -- Command: indent-rigidly start end count
     This function indents all lines starting between START (inclusive)
     and END (exclusive) sideways by COUNT columns.  This preserves the
     shape of the affected region, moving it as a rigid unit.

     This is useful not only for indenting regions of unindented text,
     but also for indenting regions of formatted code.  For example, if
     COUNT is 3, this command adds 3 columns of indentation to every
     line that begins in the specified region.

     If called interactively with no prefix argument, this command
     invokes a transient mode for adjusting indentation rigidly.  *Note
     (emacs)Indentation Commands::.

 -- Command: indent-code-rigidly start end columns &optional
          nochange-regexp
     This is like 'indent-rigidly', except that it doesn't alter lines
     that start within strings or comments.

     In addition, it doesn't alter a line if NOCHANGE-REGEXP matches at
     the beginning of the line (if NOCHANGE-REGEXP is non-'nil').

==============================================================================
File: elisp.info,  Node: |Relative_Indent|,  Next: |Indent_Tabs|,  Prev: |Region_Indent|,  Up: |Indentation|
==============================================================================

                                                               *Relative_Indent*

32.17.4 Indentation Relative to Previous Lines
----------------------------------------------

This section describes two commands that indent the current line based
on the contents of previous lines.

 -- Command: indent-relative &optional unindented-ok
     This command inserts whitespace at point, extending to the same
     column as the next "indent point" of the previous nonblank line.
     An indent point is a non-whitespace character following whitespace.
     The next indent point is the first one at a column greater than the
     current column of point.  For example, if point is underneath and
     to the left of the first non-blank character of a line of text, it
     moves to that column by inserting whitespace.

     If the previous nonblank line has no next indent point (i.e., none
     at a great enough column position), 'indent-relative' either does
     nothing (if UNINDENTED-OK is non-'nil') or calls 'tab-to-tab-stop'.
     Thus, if point is underneath and to the right of the last column of
     a short line of text, this command ordinarily moves point to the
     next tab stop by inserting whitespace.

     The return value of 'indent-relative' is unpredictable.

     In the following example, point is at the beginning of the second
     line:

                      This line is indented twelve spaces.
          -!-The quick brown fox jumped.

     Evaluation of the expression '(indent-relative nil)' produces the
     following:

                      This line is indented twelve spaces.
                      -!-The quick brown fox jumped.

     In this next example, point is between the 'm' and 'p' of 'jumped':

                      This line is indented twelve spaces.
          The quick brown fox jum-!-ped.

     Evaluation of the expression '(indent-relative nil)' produces the
     following:

                      This line is indented twelve spaces.
          The quick brown fox jum  -!-ped.

 -- Command: indent-relative-first-indent-point
     This command indents the current line like the previous nonblank
     line, by calling 'indent-relative' with 't' as the FIRST-ONLY
     argument.  The return value is unpredictable.

     If the previous nonblank line has no indent points beyond the
     current column, this command does nothing.

==============================================================================
File: elisp.info,  Node: |Indent_Tabs|,  Next: |Motion_by_Indent|,  Prev: |Relative_Indent|,  Up: |Indentation|
==============================================================================

                                                                   *Indent_Tabs*

32.17.5 Adjustable Tab Stops
----------------------------

This section explains the mechanism for user-specified tab stops and the
mechanisms that use and set them.  The name "tab stops" is used because
the feature is similar to that of the tab stops on a typewriter.  The
feature works by inserting an appropriate number of spaces and tab
characters to reach the next tab stop column; it does not affect the
display of tab characters in the buffer (*note Usual Display::).  Note
that the <TAB> character as input uses this tab stop feature only in a
few major modes, such as Text mode.  *Note (emacs)Tab Stops::.

 -- Command: tab-to-tab-stop
     This command inserts spaces or tabs before point, up to the next
     tab stop column defined by 'tab-stop-list'.

 -- User Option: tab-stop-list
     This variable defines the tab stop columns used by
     'tab-to-tab-stop'.  It should be either 'nil', or a list of
     increasing integers, which need not be evenly spaced.  The list is
     implicitly extended to infinity through repetition of the interval
     between the last and penultimate elements (or 'tab-width' if the
     list has fewer than two elements).  A value of 'nil' means a tab
     stop every 'tab-width' columns.

     Use 'M-x edit-tab-stops' to edit the location of tab stops
     interactively.

==============================================================================
File: elisp.info,  Node: |Motion_by_Indent|,  Prev: |Indent_Tabs|,  Up: |Indentation|
==============================================================================

                                                              *Motion_by_Indent*

32.17.6 Indentation-Based Motion Commands
-----------------------------------------

These commands, primarily for interactive use, act based on the
indentation in the text.

 -- Command: back-to-indentation
     This command moves point to the first non-whitespace character in
     the current line (which is the line in which point is located).  It
     returns 'nil'.

 -- Command: backward-to-indentation &optional arg
     This command moves point backward ARG lines and then to the first
     nonblank character on that line.  It returns 'nil'.  If ARG is
     omitted or 'nil', it defaults to 1.

 -- Command: forward-to-indentation &optional arg
     This command moves point forward ARG lines and then to the first
     nonblank character on that line.  It returns 'nil'.  If ARG is
     omitted or 'nil', it defaults to 1.

==============================================================================
File: elisp.info,  Node: |Case_Changes|,  Next: |Text_Properties|,  Prev: |Indentation|,  Up: |Text|
==============================================================================

                                                                  *Case_Changes*

32.18 Case Changes
------------------

The case change commands described here work on text in the current
buffer.  *Note Case Conversion::, for case conversion functions that
work on strings and characters.  *Note Case Tables::, for how to
customize which characters are upper or lower case and how to convert
them.

 -- Command: capitalize-region start end
     This function capitalizes all words in the region defined by START
     and END.  To capitalize means to convert each word's first
     character to upper case and convert the rest of each word to lower
     case.  The function returns 'nil'.

     If one end of the region is in the middle of a word, the part of
     the word within the region is treated as an entire word.

     When 'capitalize-region' is called interactively, START and END are
     point and the mark, with the smallest first.

          ---------- Buffer: foo ----------
          This is the contents of the 5th foo.
          ---------- Buffer: foo ----------

          (capitalize-region 1 37)
          => nil

          ---------- Buffer: foo ----------
          This Is The Contents Of The 5th Foo.
          ---------- Buffer: foo ----------

 -- Command: downcase-region start end
     This function converts all of the letters in the region defined by
     START and END to lower case.  The function returns 'nil'.

     When 'downcase-region' is called interactively, START and END are
     point and the mark, with the smallest first.

 -- Command: upcase-region start end
     This function converts all of the letters in the region defined by
     START and END to upper case.  The function returns 'nil'.

     When 'upcase-region' is called interactively, START and END are
     point and the mark, with the smallest first.

 -- Command: capitalize-word count
     This function capitalizes COUNT words after point, moving point
     over as it does.  To capitalize means to convert each word's first
     character to upper case and convert the rest of each word to lower
     case.  If COUNT is negative, the function capitalizes the -COUNT
     previous words but does not move point.  The value is 'nil'.

     If point is in the middle of a word, the part of the word before
     point is ignored when moving forward.  The rest is treated as an
     entire word.

     When 'capitalize-word' is called interactively, COUNT is set to the
     numeric prefix argument.

 -- Command: downcase-word count
     This function converts the COUNT words after point to all lower
     case, moving point over as it does.  If COUNT is negative, it
     converts the -COUNT previous words but does not move point.  The
     value is 'nil'.

     When 'downcase-word' is called interactively, COUNT is set to the
     numeric prefix argument.

 -- Command: upcase-word count
     This function converts the COUNT words after point to all upper
     case, moving point over as it does.  If COUNT is negative, it
     converts the -COUNT previous words but does not move point.  The
     value is 'nil'.

     When 'upcase-word' is called interactively, COUNT is set to the
     numeric prefix argument.

==============================================================================
File: elisp.info,  Node: |Text_Properties|,  Next: |Substitution|,  Prev: |Case_Changes|,  Up: |Text|
==============================================================================

                                                               *Text_Properties*

32.19 Text Properties
---------------------

Each character position in a buffer or a string can have a "text
property list", much like the property list of a symbol (*note Property
Lists::).  The properties belong to a particular character at a
particular place, such as, the letter 'T' at the beginning of this
sentence or the first 'o' in 'foo'--if the same character occurs in two
different places, the two occurrences in general have different
properties.

   Each property has a name and a value.  Both of these can be any Lisp
object, but the name is normally a symbol.  Typically each property name
symbol is used for a particular purpose; for instance, the text property
'face' specifies the faces for displaying the character (*note Special
Properties::).  The usual way to access the property list is to specify
a name and ask what value corresponds to it.

   If a character has a 'category' property, we call it the "property
category" of the character.  It should be a symbol.  The properties of
the symbol serve as defaults for the properties of the character.

   Copying text between strings and buffers preserves the properties
along with the characters; this includes such diverse functions as
'substring', 'insert', and 'buffer-substring'.

MENU

* |Examining_Properties|::   Looking at the properties of one character.
* |Changing_Properties|::    Setting the properties of a range of text.
* |Property_Search|::        Searching for where a property changes value.
* |Special_Properties|::     Particular properties with special meanings.
* |Format_Properties|::      Properties for representing formatting of text.
* |Sticky_Properties|::      How inserted text gets properties from
                             neighboring text.
* |Lazy_Properties|::        Computing text properties in a lazy fashion
                             only when text is examined.
* |Clickable_Text|::         Using text properties to make regions of text
                             do something when you click on them.
* |Fields|::                 The 'field' property defines
                             fields within the buffer.
* |Not_Intervals|::          Why text properties do not use
                             Lisp-visible text intervals.

==============================================================================
File: elisp.info,  Node: |Examining_Properties|,  Next: |Changing_Properties|,  Up: |Text_Properties|
==============================================================================

                                                          *Examining_Properties*

32.19.1 Examining Text Properties
---------------------------------

The simplest way to examine text properties is to ask for the value of a
particular property of a particular character.  For that, use
'get-text-property'.  Use 'text-properties-at' to get the entire
property list of a character.  *Note Property Search::, for functions to
examine the properties of a number of characters at once.

   These functions handle both strings and buffers.  Keep in mind that
positions in a string start from 0, whereas positions in a buffer start
from 1.  Passing a buffer other than the current buffer may be slow.

 -- Function: get-text-property pos prop &optional object
     This function returns the value of the PROP property of the
     character after position POS in OBJECT (a buffer or string).  The
     argument OBJECT is optional and defaults to the current buffer.

     If there is no PROP property strictly speaking, but the character
     has a property category that is a symbol, then 'get-text-property'
     returns the PROP property of that symbol.

 -- Function: get-char-property position prop &optional object
     This function is like 'get-text-property', except that it checks
     overlays first and then text properties.  *Note Overlays::.

     The argument OBJECT may be a string, a buffer, or a window.  If it
     is a window, then the buffer displayed in that window is used for
     text properties and overlays, but only the overlays active for that
     window are considered.  If OBJECT is a buffer, then overlays in
     that buffer are considered first, in order of decreasing priority,
     followed by the text properties.  If OBJECT is a string, only text
     properties are considered, since strings never have overlays.

 -- Function: get-pos-property position prop &optional object
     This function is like 'get-char-property', except that it pays
     attention to properties' stickiness and overlays' advancement
     settings instead of the property of the character at (i.e., right
     after) POSITION.

 -- Function: get-char-property-and-overlay position prop &optional
          object
     This is like 'get-char-property', but gives extra information about
     the overlay that the property value comes from.

     Its value is a cons cell whose CAR is the property value, the same
     value 'get-char-property' would return with the same arguments.
     Its CDR is the overlay in which the property was found, or 'nil',
     if it was found as a text property or not found at all.

     If POSITION is at the end of OBJECT, both the CAR and the CDR of
     the value are 'nil'.

 -- Variable: char-property-alias-alist
     This variable holds an alist which maps property names to a list of
     alternative property names.  If a character does not specify a
     direct value for a property, the alternative property names are
     consulted in order; the first non-'nil' value is used.  This
     variable takes precedence over 'default-text-properties', and
     'category' properties take precedence over this variable.

 -- Function: text-properties-at position &optional object
     This function returns the entire property list of the character at
     POSITION in the string or buffer OBJECT.  If OBJECT is 'nil', it
     defaults to the current buffer.

 -- Variable: default-text-properties
     This variable holds a property list giving default values for text
     properties.  Whenever a character does not specify a value for a
     property, neither directly, through a category symbol, or through
     'char-property-alias-alist', the value stored in this list is used
     instead.  Here is an example:

          (setq default-text-properties '(foo 69)
                char-property-alias-alist nil)
          ;; Make sure character 1 has no properties of its own.
          (set-text-properties 1 2 nil)
          ;; What we get, when we ask, is the default value.
          (get-text-property 1 'foo)
               => 69

==============================================================================
File: elisp.info,  Node: |Changing_Properties|,  Next: |Property_Search|,  Prev: |Examining_Properties|,  Up: |Text_Properties|
==============================================================================

                                                           *Changing_Properties*

32.19.2 Changing Text Properties
--------------------------------

The primitives for changing properties apply to a specified range of
text in a buffer or string.  The function 'set-text-properties' (see end
of section) sets the entire property list of the text in that range;
more often, it is useful to add, change, or delete just certain
properties specified by name.

   Since text properties are considered part of the contents of the
buffer (or string), and can affect how a buffer looks on the screen, any
change in buffer text properties marks the buffer as modified.  Buffer
text property changes are undoable also (*note Undo::).  Positions in a
string start from 0, whereas positions in a buffer start from 1.

 -- Function: put-text-property start end prop value &optional object
     This function sets the PROP property to VALUE for the text between
     START and END in the string or buffer OBJECT.  If OBJECT is 'nil',
     it defaults to the current buffer.

 -- Function: add-text-properties start end props &optional object
     This function adds or overrides text properties for the text
     between START and END in the string or buffer OBJECT.  If OBJECT is
     'nil', it defaults to the current buffer.

     The argument PROPS specifies which properties to add.  It should
     have the form of a property list (*note Property Lists::): a list
     whose elements include the property names followed alternately by
     the corresponding values.

     The return value is 't' if the function actually changed some
     property's value; 'nil' otherwise (if PROPS is 'nil' or its values
     agree with those in the text).

     For example, here is how to set the 'comment' and 'face' properties
     of a range of text:

          (add-text-properties START END
                               '(comment t face highlight))

 -- Function: remove-text-properties start end props &optional object
     This function deletes specified text properties from the text
     between START and END in the string or buffer OBJECT.  If OBJECT is
     'nil', it defaults to the current buffer.

     The argument PROPS specifies which properties to delete.  It should
     have the form of a property list (*note Property Lists::): a list
     whose elements are property names alternating with corresponding
     values.  But only the names matter--the values that accompany them
     are ignored.  For example, here's how to remove the 'face'
     property.

          (remove-text-properties START END '(face nil))

     The return value is 't' if the function actually changed some
     property's value; 'nil' otherwise (if PROPS is 'nil' or if no
     character in the specified text had any of those properties).

     To remove all text properties from certain text, use
     'set-text-properties' and specify 'nil' for the new property list.

 -- Function: remove-list-of-text-properties start end
          list-of-properties &optional object
     Like 'remove-text-properties' except that LIST-OF-PROPERTIES is a
     list of property names only, not an alternating list of property
     names and values.

 -- Function: set-text-properties start end props &optional object
     This function completely replaces the text property list for the
     text between START and END in the string or buffer OBJECT.  If
     OBJECT is 'nil', it defaults to the current buffer.

     The argument PROPS is the new property list.  It should be a list
     whose elements are property names alternating with corresponding
     values.

     After 'set-text-properties' returns, all the characters in the
     specified range have identical properties.

     If PROPS is 'nil', the effect is to get rid of all properties from
     the specified range of text.  Here's an example:

          (set-text-properties START END nil)

     Do not rely on the return value of this function.

 -- Function: add-face-text-property start end face &optional appendp
          object
     This function acts on the text between START and END, adding the
     face FACE to the 'face' text property.  FACE should be a valid
     value for the 'face' property (*note Special Properties::), such as
     a face name or an anonymous face (*note Faces::).

     If any text in the region already has a non-'nil' 'face' property,
     those face(s) are retained.  This function sets the 'face' property
     to a list of faces, with FACE as the first element (by default) and
     the pre-existing faces as the remaining elements.  If the optional
     argument APPENDP is non-'nil', FACE is appended to the end of the
     list instead.  Note that in a face list, the first occurring value
     for each attribute takes precedence.

     For example, the following code would assign an italicized green
     face to the text between START and END:

          (add-face-text-property START END 'italic)
          (add-face-text-property START END '(:foreground "red"))
          (add-face-text-property START END '(:foreground "green"))

     The optional argument OBJECT, if non-'nil', specifies a buffer or
     string to act on, rather than the current buffer.  If OBJECT is a
     string, then START and END are zero-based indices into the string.

   The easiest way to make a string with text properties is with
'propertize':

 -- Function: propertize string &rest properties
     This function returns a copy of STRING with the text properties
     PROPERTIES added.  These properties apply to all the characters in
     the string that is returned.  Here is an example that constructs a
     string with a 'face' property and a 'mouse-face' property:

          (propertize "foo" 'face 'italic
                      'mouse-face 'bold-italic)
               => #("foo" 0 3 (mouse-face bold-italic face italic))

     To put different properties on various parts of a string, you can
     construct each part with 'propertize' and then combine them with
     'concat':

          (concat
           (propertize "foo" 'face 'italic
                       'mouse-face 'bold-italic)
           " and "
           (propertize "bar" 'face 'italic
                       'mouse-face 'bold-italic))
               => #("foo and bar"
                           0 3 (face italic mouse-face bold-italic)
                           3 8 nil
                           8 11 (face italic mouse-face bold-italic))

   *Note Buffer Contents::, for the function
'buffer-substring-no-properties', which copies text from the buffer but
does not copy its properties.

   If you wish to add text properties to a buffer or remove them without
marking the buffer as modified, you can wrap the calls above in the
'with-silent-modifications' macro.  *Note Buffer Modification::.

==============================================================================
File: elisp.info,  Node: |Property_Search|,  Next: |Special_Properties|,  Prev: |Changing_Properties|,  Up: |Text_Properties|
==============================================================================

                                                               *Property_Search*

32.19.3 Text Property Search Functions
--------------------------------------

In typical use of text properties, most of the time several or many
consecutive characters have the same value for a property.  Rather than
writing your programs to examine characters one by one, it is much
faster to process chunks of text that have the same property value.

   Here are functions you can use to do this.  They use 'eq' for
comparing property values.  In all cases, OBJECT defaults to the current
buffer.

   For good performance, it's very important to use the LIMIT argument
to these functions, especially the ones that search for a single
property--otherwise, they may spend a long time scanning to the end of
the buffer, if the property you are interested in does not change.

   These functions do not move point; instead, they return a position
(or 'nil').  Remember that a position is always between two characters;
the position returned by these functions is between two characters with
different properties.

 -- Function: next-property-change pos &optional object limit
     The function scans the text forward from position POS in the string
     or buffer OBJECT until it finds a change in some text property,
     then returns the position of the change.  In other words, it
     returns the position of the first character beyond POS whose
     properties are not identical to those of the character just after
     POS.

     If LIMIT is non-'nil', then the scan ends at position LIMIT.  If
     there is no property change before that point, this function
     returns LIMIT.

     The value is 'nil' if the properties remain unchanged all the way
     to the end of OBJECT and LIMIT is 'nil'.  If the value is
     non-'nil', it is a position greater than or equal to POS.  The
     value equals POS only when LIMIT equals POS.

     Here is an example of how to scan the buffer by chunks of text
     within which all properties are constant:

          (while (not (eobp))
            (let ((plist (text-properties-at (point)))
                  (next-change
                   (or (next-property-change (point) (current-buffer))
                       (point-max))))
              Process text from point to NEXT-CHANGE...
              (goto-char next-change)))

 -- Function: previous-property-change pos &optional object limit
     This is like 'next-property-change', but scans back from POS
     instead of forward.  If the value is non-'nil', it is a position
     less than or equal to POS; it equals POS only if LIMIT equals POS.

 -- Function: next-single-property-change pos prop &optional object
          limit
     The function scans text for a change in the PROP property, then
     returns the position of the change.  The scan goes forward from
     position POS in the string or buffer OBJECT.  In other words, this
     function returns the position of the first character beyond POS
     whose PROP property differs from that of the character just after
     POS.

     If LIMIT is non-'nil', then the scan ends at position LIMIT.  If
     there is no property change before that point,
     'next-single-property-change' returns LIMIT.

     The value is 'nil' if the property remains unchanged all the way to
     the end of OBJECT and LIMIT is 'nil'.  If the value is non-'nil',
     it is a position greater than or equal to POS; it equals POS only
     if LIMIT equals POS.

 -- Function: previous-single-property-change pos prop &optional object
          limit
     This is like 'next-single-property-change', but scans back from POS
     instead of forward.  If the value is non-'nil', it is a position
     less than or equal to POS; it equals POS only if LIMIT equals POS.

 -- Function: next-char-property-change pos &optional limit
     This is like 'next-property-change' except that it considers
     overlay properties as well as text properties, and if no change is
     found before the end of the buffer, it returns the maximum buffer
     position rather than 'nil' (in this sense, it resembles the
     corresponding overlay function 'next-overlay-change', rather than
     'next-property-change').  There is no OBJECT operand because this
     function operates only on the current buffer.  It returns the next
     address at which either kind of property changes.

 -- Function: previous-char-property-change pos &optional limit
     This is like 'next-char-property-change', but scans back from POS
     instead of forward, and returns the minimum buffer position if no
     change is found.

 -- Function: next-single-char-property-change pos prop &optional object
          limit
     This is like 'next-single-property-change' except that it considers
     overlay properties as well as text properties, and if no change is
     found before the end of the OBJECT, it returns the maximum valid
     position in OBJECT rather than 'nil'.  Unlike
     'next-char-property-change', this function _does_ have an OBJECT
     operand; if OBJECT is not a buffer, only text-properties are
     considered.
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
