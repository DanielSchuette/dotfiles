     'DECL_SIZE' and 'DECL_ALIGN' on a 'RESULT_DECL', just as with a
     'VAR_DECL'.

'TYPE_DECL'
     These nodes represent 'typedef' declarations.  The 'TREE_TYPE' is
     the type declared to have the name given by 'DECL_NAME'.  In some
     cases, there is no associated name.

'VAR_DECL'
     These nodes represent variables with namespace or block scope, as
     well as static data members.  The 'DECL_SIZE' and 'DECL_ALIGN' are
     analogous to 'TYPE_SIZE' and 'TYPE_ALIGN'.  For a declaration, you
     should always use the 'DECL_SIZE' and 'DECL_ALIGN' rather than the
     'TYPE_SIZE' and 'TYPE_ALIGN' given by the 'TREE_TYPE', since
     special attributes may have been applied to the variable to give it
     a particular size and alignment.  You may use the predicates
     'DECL_THIS_STATIC' or 'DECL_THIS_EXTERN' to test whether the
     storage class specifiers 'static' or 'extern' were used to declare
     a variable.

     If this variable is initialized (but does not require a
     constructor), the 'DECL_INITIAL' will be an expression for the
     initializer.  The initializer should be evaluated, and a bitwise
     copy into the variable performed.  If the 'DECL_INITIAL' is the
     'error_mark_node', there is an initializer, but it is given by an
     explicit statement later in the code; no bitwise copy is required.

     GCC provides an extension that allows either automatic variables,
     or global variables, to be placed in particular registers.  This
     extension is being used for a particular 'VAR_DECL' if
     'DECL_REGISTER' holds for the 'VAR_DECL', and if
     'DECL_ASSEMBLER_NAME' is not equal to 'DECL_NAME'.  In that case,
     'DECL_ASSEMBLER_NAME' is the name of the register into which the
     variable will be placed.

'PARM_DECL'
     Used to represent a parameter to a function.  Treat these nodes
     similarly to 'VAR_DECL' nodes.  These nodes only appear in the
     'DECL_ARGUMENTS' for a 'FUNCTION_DECL'.

     The 'DECL_ARG_TYPE' for a 'PARM_DECL' is the type that will
     actually be used when a value is passed to this function.  It may
     be a wider type than the 'TREE_TYPE' of the parameter; for example,
     the ordinary type might be 'short' while the 'DECL_ARG_TYPE' is
     'int'.

'DEBUG_EXPR_DECL'
     Used to represent an anonymous debug-information temporary created
     to hold an expression as it is optimized away, so that its value
     can be referenced in debug bind statements.

'FIELD_DECL'
     These nodes represent non-static data members.  The 'DECL_SIZE' and
     'DECL_ALIGN' behave as for 'VAR_DECL' nodes.  The position of the
     field within the parent record is specified by a combination of
     three attributes.  'DECL_FIELD_OFFSET' is the position, counting in
     bytes, of the 'DECL_OFFSET_ALIGN'-bit sized word containing the bit
     of the field closest to the beginning of the structure.
     'DECL_FIELD_BIT_OFFSET' is the bit offset of the first bit of the
     field within this word; this may be nonzero even for fields that
     are not bit-fields, since 'DECL_OFFSET_ALIGN' may be greater than
     the natural alignment of the field's type.

     If 'DECL_C_BIT_FIELD' holds, this field is a bit-field.  In a
     bit-field, 'DECL_BIT_FIELD_TYPE' also contains the type that was
     originally specified for it, while DECL_TYPE may be a modified type
     with lesser precision, according to the size of the bit field.

'NAMESPACE_DECL'
     Namespaces provide a name hierarchy for other declarations.  They
     appear in the 'DECL_CONTEXT' of other '_DECL' nodes.

==============================================================================
File: gccint.info,  Node: |Internal_structure|,  Prev: |Working_with_declarations|,  Up: |Declarations|
==============================================================================

                                                            *Internal_structure*

11.4.2 Internal structure
-------------------------

'DECL' nodes are represented internally as a hierarchy of structures.

MENU

* |Current_structure_hierarchy|::  The current DECL node structure
hierarchy.
* |Adding_new_DECL_node_types|:: How to add a new DECL node to a
frontend.

==============================================================================
File: gccint.info,  Node: |Current_structure_hierarchy|,  Next: |Adding_new_DECL_node_types|,  Up: |Internal_structure|
==============================================================================

                                                   *Current_structure_hierarchy*

11.4.2.1 Current structure hierarchy
.....-------------------------------

'struct tree_decl_minimal'
     This is the minimal structure to inherit from in order for common
     'DECL' macros to work.  The fields it contains are a unique ID,
     source location, context, and name.

'struct tree_decl_common'
     This structure inherits from 'struct tree_decl_minimal'.  It
     contains fields that most 'DECL' nodes need, such as a field to
     store alignment, machine mode, size, and attributes.

'struct tree_field_decl'
     This structure inherits from 'struct tree_decl_common'.  It is used
     to represent 'FIELD_DECL'.

'struct tree_label_decl'
     This structure inherits from 'struct tree_decl_common'.  It is used
     to represent 'LABEL_DECL'.

'struct tree_translation_unit_decl'
     This structure inherits from 'struct tree_decl_common'.  It is used
     to represent 'TRANSLATION_UNIT_DECL'.

'struct tree_decl_with_rtl'
     This structure inherits from 'struct tree_decl_common'.  It
     contains a field to store the low-level RTL associated with a
     'DECL' node.

'struct tree_result_decl'
     This structure inherits from 'struct tree_decl_with_rtl'.  It is
     used to represent 'RESULT_DECL'.

'struct tree_const_decl'
     This structure inherits from 'struct tree_decl_with_rtl'.  It is
     used to represent 'CONST_DECL'.

'struct tree_parm_decl'
     This structure inherits from 'struct tree_decl_with_rtl'.  It is
     used to represent 'PARM_DECL'.

'struct tree_decl_with_vis'
     This structure inherits from 'struct tree_decl_with_rtl'.  It
     contains fields necessary to store visibility information, as well
     as a section name and assembler name.

'struct tree_var_decl'
     This structure inherits from 'struct tree_decl_with_vis'.  It is
     used to represent 'VAR_DECL'.

'struct tree_function_decl'
     This structure inherits from 'struct tree_decl_with_vis'.  It is
     used to represent 'FUNCTION_DECL'.

==============================================================================
File: gccint.info,  Node: |Adding_new_DECL_node_types|,  Prev: |Current_structure_hierarchy|,  Up: |Internal_structure|
==============================================================================

                                                    *Adding_new_DECL_node_types*

11.4.2.2 Adding new DECL node types
.....------------------------------

Adding a new 'DECL' tree consists of the following steps

Add a new tree code for the 'DECL' node
     For language specific 'DECL' nodes, there is a '.def' file in each
     frontend directory where the tree code should be added.  For 'DECL'
     nodes that are part of the middle-end, the code should be added to
     'tree.def'.

Create a new structure type for the 'DECL' node
     These structures should inherit from one of the existing structures
     in the language hierarchy by using that structure as the first
     member.

          struct tree_foo_decl
          {
             struct tree_decl_with_vis common;
          }

     Would create a structure name 'tree_foo_decl' that inherits from
     'struct tree_decl_with_vis'.

     For language specific 'DECL' nodes, this new structure type should
     go in the appropriate '.h' file.  For 'DECL' nodes that are part of
     the middle-end, the structure type should go in 'tree.h'.

Add a member to the tree structure enumerator for the node
     For garbage collection and dynamic checking purposes, each 'DECL'
     node structure type is required to have a unique enumerator value
     specified with it.  For language specific 'DECL' nodes, this new
     enumerator value should go in the appropriate '.def' file.  For
     'DECL' nodes that are part of the middle-end, the enumerator values
     are specified in 'treestruct.def'.

Update 'union tree_node'
     In order to make your new structure type usable, it must be added
     to 'union tree_node'.  For language specific 'DECL' nodes, a new
     entry should be added to the appropriate '.h' file of the form
            struct tree_foo_decl GTY ((tag ("TS_VAR_DECL"))) foo_decl;
     For 'DECL' nodes that are part of the middle-end, the additional
     member goes directly into 'union tree_node' in 'tree.h'.

Update dynamic checking info
     In order to be able to check whether accessing a named portion of
     'union tree_node' is legal, and whether a certain 'DECL' node
     contains one of the enumerated 'DECL' node structures in the
     hierarchy, a simple lookup table is used.  This lookup table needs
     to be kept up to date with the tree structure hierarchy, or else
     checking and containment macros will fail inappropriately.

     For language specific 'DECL' nodes, their is an 'init_ts' function
     in an appropriate '.c' file, which initializes the lookup table.
     Code setting up the table for new 'DECL' nodes should be added
     there.  For each 'DECL' tree code and enumerator value representing
     a member of the inheritance hierarchy, the table should contain 1
     if that tree code inherits (directly or indirectly) from that
     member.  Thus, a 'FOO_DECL' node derived from 'struct
     decl_with_rtl', and enumerator value 'TS_FOO_DECL', would be set up
     as follows
          tree_contains_struct[FOO_DECL][TS_FOO_DECL] = 1;
          tree_contains_struct[FOO_DECL][TS_DECL_WRTL] = 1;
          tree_contains_struct[FOO_DECL][TS_DECL_COMMON] = 1;
          tree_contains_struct[FOO_DECL][TS_DECL_MINIMAL] = 1;

     For 'DECL' nodes that are part of the middle-end, the setup code
     goes into 'tree.c'.

Add macros to access any new fields and flags

     Each added field or flag should have a macro that is used to access
     it, that performs appropriate checking to ensure only the right
     type of 'DECL' nodes access the field.

     These macros generally take the following form
          #define FOO_DECL_FIELDNAME(NODE) FOO_DECL_CHECK(NODE)->foo_decl.fieldname
     However, if the structure is simply a base class for further
     structures, something like the following should be used
          #define BASE_STRUCT_CHECK(T) CONTAINS_STRUCT_CHECK(T, TS_BASE_STRUCT)
          #define BASE_STRUCT_FIELDNAME(NODE) \
             (BASE_STRUCT_CHECK(NODE)->base_struct.fieldname

     Reading them from the generated 'all-tree.def' file (which in turn
     includes all the 'tree.def' files), 'gencheck.c' is used during
     GCC's build to generate the '*_CHECK' macros for all tree codes.

==============================================================================
File: gccint.info,  Node: |Attributes|,  Next: |Expression_trees|,  Prev: |Declarations|,  Up: |GENERIC|
==============================================================================

                                                                    *Attributes*

11.5 Attributes in trees
=====-------------------

Attributes, as specified using the '__attribute__' keyword, are
represented internally as a 'TREE_LIST'.  The 'TREE_PURPOSE' is the name
of the attribute, as an 'IDENTIFIER_NODE'.  The 'TREE_VALUE' is a
'TREE_LIST' of the arguments of the attribute, if any, or 'NULL_TREE' if
there are no arguments; the arguments are stored as the 'TREE_VALUE' of
successive entries in the list, and may be identifiers or expressions.
The 'TREE_CHAIN' of the attribute is the next attribute in a list of
attributes applying to the same declaration or type, or 'NULL_TREE' if
there are no further attributes in the list.

 Attributes may be attached to declarations and to types; these
attributes may be accessed with the following macros.  All attributes
are stored in this way, and many also cause other changes to the
declaration or type or to other internal compiler data structures.

 -- Tree Macro: tree DECL_ATTRIBUTES (tree DECL)
     This macro returns the attributes on the declaration DECL.

 -- Tree Macro: tree TYPE_ATTRIBUTES (tree TYPE)
     This macro returns the attributes on the type TYPE.

==============================================================================
File: gccint.info,  Node: |Expression_trees|,  Next: |Statements|,  Prev: |Attributes|,  Up: |GENERIC|
==============================================================================

                                                              *Expression_trees*

11.6 Expressions
=====-----------

The internal representation for expressions is for the most part quite
straightforward.  However, there are a few facts that one must bear in
mind.  In particular, the expression "tree" is actually a directed
acyclic graph.  (For example there may be many references to the integer
constant zero throughout the source program; many of these will be
represented by the same expression node.)  You should not rely on
certain kinds of node being shared, nor should you rely on certain kinds
of nodes being unshared.

 The following macros can be used with all expression nodes:

'TREE_TYPE'
     Returns the type of the expression.  This value may not be
     precisely the same type that would be given the expression in the
     original program.

 In what follows, some nodes that one might expect to always have type
'bool' are documented to have either integral or boolean type.  At some
point in the future, the C front end may also make use of this same
intermediate representation, and at this point these nodes will
certainly have integral type.  The previous sentence is not meant to
imply that the C++ front end does not or will not give these nodes
integral type.

 Below, we list the various kinds of expression nodes.  Except where
noted otherwise, the operands to an expression are accessed using the
'TREE_OPERAND' macro.  For example, to access the first operand to a
binary plus expression 'expr', use:

     TREE_OPERAND (expr, 0)

 As this example indicates, the operands are zero-indexed.

MENU

* Constants: Constant expressions.
* |Storage_References|::
* |Unary_and_Binary_Expressions|::
* |Vectors|::

==============================================================================
File: gccint.info,  Node: |Constant_expressions|,  Next: |Storage_References|,  Up: |Expression_trees|
==============================================================================

                                                          *Constant_expressions*

11.6.1 Constant expressions
---------------------------

The table below begins with constants, moves on to unary expressions,
then proceeds to binary expressions, and concludes with various other
kinds of expressions:

'INTEGER_CST'
     These nodes represent integer constants.  Note that the type of
     these constants is obtained with 'TREE_TYPE'; they are not always
     of type 'int'.  In particular, 'char' constants are represented
     with 'INTEGER_CST' nodes.  The value of the integer constant 'e' is
     represented in an array of HOST_WIDE_INT. There are enough elements
     in the array to represent the value without taking extra elements
     for redundant 0s or -1.  The number of elements used to represent
     'e' is available via 'TREE_INT_CST_NUNITS'.  Element 'i' can be
     extracted by using 'TREE_INT_CST_ELT (e, i)'.  'TREE_INT_CST_LOW'
     is a shorthand for 'TREE_INT_CST_ELT (e, 0)'.

     The functions 'tree_fits_shwi_p' and 'tree_fits_uhwi_p' can be used
     to tell if the value is small enough to fit in a signed
     HOST_WIDE_INT or an unsigned HOST_WIDE_INT respectively.  The value
     can then be extracted using 'tree_to_shwi' and 'tree_to_uhwi'.

'REAL_CST'

     FIXME: Talk about how to obtain representations of this constant,
     do comparisons, and so forth.

'FIXED_CST'

     These nodes represent fixed-point constants.  The type of these
     constants is obtained with 'TREE_TYPE'.  'TREE_FIXED_CST_PTR'
     points to a 'struct fixed_value'; 'TREE_FIXED_CST' returns the
     structure itself.  'struct fixed_value' contains 'data' with the
     size of two 'HOST_BITS_PER_WIDE_INT' and 'mode' as the associated
     fixed-point machine mode for 'data'.

'COMPLEX_CST'
     These nodes are used to represent complex number constants, that is
     a '__complex__' whose parts are constant nodes.  The
     'TREE_REALPART' and 'TREE_IMAGPART' return the real and the
     imaginary parts respectively.

'VECTOR_CST'
     These nodes are used to represent vector constants.  Each vector
     constant V is treated as a specific instance of an arbitrary-length
     sequence that itself contains 'VECTOR_CST_NPATTERNS (V)'
     interleaved patterns.  Each pattern has the form:

          { BASE0, BASE1, BASE1 + STEP, BASE1 + STEP * 2, ... }

     The first three elements in each pattern are enough to determine
     the values of the other elements.  However, if all STEPs are zero,
     only the first two elements are needed.  If in addition each BASE1
     is equal to the corresponding BASE0, only the first element in each
     pattern is needed.  The number of encoded elements per pattern is
     given by 'VECTOR_CST_NELTS_PER_PATTERN (V)'.

     For example, the constant:

          { 0, 1, 2, 6, 3, 8, 4, 10, 5, 12, 6, 14, 7, 16, 8, 18 }

     is interpreted as an interleaving of the sequences:

          { 0, 2, 3, 4, 5, 6, 7, 8 }
          { 1, 6, 8, 10, 12, 14, 16, 18 }

     where the sequences are represented by the following patterns:

          BASE0 == 0, BASE1 == 2, STEP == 1
          BASE0 == 1, BASE1 == 6, STEP == 2

     In this case:

          VECTOR_CST_NPATTERNS (V) == 2
          VECTOR_CST_NELTS_PER_PATTERN (V) == 3

     The vector is therefore encoded using the first 6 elements ('{ 0,
     1, 2, 6, 3, 8 }'), with the remaining 10 elements being implicit
     extensions of them.

     Sometimes this scheme can create two possible encodings of the same
     vector.  For example { 0, 1 } could be seen as two patterns with
     one element each or one pattern with two elements (BASE0 and
     BASE1).  The canonical encoding is always the one with the fewest
     patterns or (if both encodings have the same number of petterns)
     the one with the fewest encoded elements.

     'vector_cst_encoding_nelts (V)' gives the total number of encoded
     elements in V, which is 6 in the example above.
     'VECTOR_CST_ENCODED_ELTS (V)' gives a pointer to the elements
     encoded in V and 'VECTOR_CST_ENCODED_ELT (V, I)' accesses the value
     of encoded element I.

     'VECTOR_CST_DUPLICATE_P (V)' is true if V simply contains repeated
     instances of 'VECTOR_CST_NPATTERNS (V)' values.  This is a
     shorthand for testing 'VECTOR_CST_NELTS_PER_PATTERN (V) == 1'.

     'VECTOR_CST_STEPPED_P (V)' is true if at least one pattern in V has
     a nonzero step.  This is a shorthand for testing
     'VECTOR_CST_NELTS_PER_PATTERN (V) == 3'.

     The utility function 'vector_cst_elt' gives the value of an
     arbitrary index as a 'tree'.  'vector_cst_int_elt' gives the same
     value as a 'wide_int'.

'STRING_CST'
     These nodes represent string-constants.  The 'TREE_STRING_LENGTH'
     returns the length of the string, as an 'int'.  The
     'TREE_STRING_POINTER' is a 'char*' containing the string itself.
     The string may not be 'NUL'-terminated, and it may contain embedded
     'NUL' characters.  Therefore, the 'TREE_STRING_LENGTH' includes the
     trailing 'NUL' if it is present.

     For wide string constants, the 'TREE_STRING_LENGTH' is the number
     of bytes in the string, and the 'TREE_STRING_POINTER' points to an
     array of the bytes of the string, as represented on the target
     system (that is, as integers in the target endianness).  Wide and
     non-wide string constants are distinguished only by the 'TREE_TYPE'
     of the 'STRING_CST'.

     FIXME: The formats of string constants are not well-defined when
     the target system bytes are not the same width as host system
     bytes.

'POLY_INT_CST'
     These nodes represent invariants that depend on some
     target-specific runtime parameters.  They consist of
     'NUM_POLY_INT_COEFFS' coefficients, with the first coefficient
     being the constant term and the others being multipliers that are
     applied to the runtime parameters.

     'POLY_INT_CST_ELT (X, I)' references coefficient number I of
     'POLY_INT_CST' node X.  Each coefficient is an 'INTEGER_CST'.

==============================================================================
File: gccint.info,  Node: |Storage_References|,  Next: |Unary_and_Binary_Expressions|,  Prev: |Constant_expressions|,  Up: |Expression_trees|
==============================================================================

                                                            *Storage_References*

11.6.2 References to storage
----------------------------

'ARRAY_REF'
     These nodes represent array accesses.  The first operand is the
     array; the second is the index.  To calculate the address of the
     memory accessed, you must scale the index by the size of the type
     of the array elements.  The type of these expressions must be the
     type of a component of the array.  The third and fourth operands
     are used after gimplification to represent the lower bound and
     component size but should not be used directly; call
     'array_ref_low_bound' and 'array_ref_element_size' instead.

'ARRAY_RANGE_REF'
     These nodes represent access to a range (or "slice") of an array.
     The operands are the same as that for 'ARRAY_REF' and have the same
     meanings.  The type of these expressions must be an array whose
     component type is the same as that of the first operand.  The range
     of that array type determines the amount of data these expressions
     access.

'TARGET_MEM_REF'
     These nodes represent memory accesses whose address directly map to
     an addressing mode of the target architecture.  The first argument
     is 'TMR_SYMBOL' and must be a 'VAR_DECL' of an object with a fixed
     address.  The second argument is 'TMR_BASE' and the third one is
     'TMR_INDEX'.  The fourth argument is 'TMR_STEP' and must be an
     'INTEGER_CST'.  The fifth argument is 'TMR_OFFSET' and must be an
     'INTEGER_CST'.  Any of the arguments may be NULL if the appropriate
     component does not appear in the address.  Address of the
     'TARGET_MEM_REF' is determined in the following way.

          &TMR_SYMBOL + TMR_BASE + TMR_INDEX * TMR_STEP + TMR_OFFSET

     The sixth argument is the reference to the original memory access,
     which is preserved for the purposes of the RTL alias analysis.  The
     seventh argument is a tag representing the results of tree level
     alias analysis.

'ADDR_EXPR'
     These nodes are used to represent the address of an object.  (These
     expressions will always have pointer or reference type.)  The
     operand may be another expression, or it may be a declaration.

     As an extension, GCC allows users to take the address of a label.
     In this case, the operand of the 'ADDR_EXPR' will be a
     'LABEL_DECL'.  The type of such an expression is 'void*'.

     If the object addressed is not an lvalue, a temporary is created,
     and the address of the temporary is used.

'INDIRECT_REF'
     These nodes are used to represent the object pointed to by a
     pointer.  The operand is the pointer being dereferenced; it will
     always have pointer or reference type.

'MEM_REF'
     These nodes are used to represent the object pointed to by a
     pointer offset by a constant.  The first operand is the pointer
     being dereferenced; it will always have pointer or reference type.
     The second operand is a pointer constant.  Its type is specifying
     the type to be used for type-based alias analysis.

'COMPONENT_REF'
     These nodes represent non-static data member accesses.  The first
     operand is the object (rather than a pointer to it); the second
     operand is the 'FIELD_DECL' for the data member.  The third operand
     represents the byte offset of the field, but should not be used
     directly; call 'component_ref_field_offset' instead.

==============================================================================
File: gccint.info,  Node: |Unary_and_Binary_Expressions|,  Next: |Vectors|,  Prev: |Storage_References|,  Up: |Expression_trees|
==============================================================================

                                                  *Unary_and_Binary_Expressions*

11.6.3 Unary and Binary Expressions
-----------------------------------

'NEGATE_EXPR'
     These nodes represent unary negation of the single operand, for
     both integer and floating-point types.  The type of negation can be
     determined by looking at the type of the expression.

     The behavior of this operation on signed arithmetic overflow is
     controlled by the 'flag_wrapv' and 'flag_trapv' variables.

'ABS_EXPR'
     These nodes represent the absolute value of the single operand, for
     both integer and floating-point types.  This is typically used to
     implement the 'abs', 'labs' and 'llabs' builtins for integer types,
     and the 'fabs', 'fabsf' and 'fabsl' builtins for floating point
     types.  The type of abs operation can be determined by looking at
     the type of the expression.

     This node is not used for complex types.  To represent the modulus
     or complex abs of a complex value, use the 'BUILT_IN_CABS',
     'BUILT_IN_CABSF' or 'BUILT_IN_CABSL' builtins, as used to implement
     the C99 'cabs', 'cabsf' and 'cabsl' built-in functions.

'ABSU_EXPR'
     These nodes represent the absolute value of the single operand in
     equivalent unsigned type such that 'ABSU_EXPR' of 'TYPE_MIN' is
     well defined.

'BIT_NOT_EXPR'
     These nodes represent bitwise complement, and will always have
     integral type.  The only operand is the value to be complemented.

'TRUTH_NOT_EXPR'
     These nodes represent logical negation, and will always have
     integral (or boolean) type.  The operand is the value being
     negated.  The type of the operand and that of the result are always
     of 'BOOLEAN_TYPE' or 'INTEGER_TYPE'.

'PREDECREMENT_EXPR'
'PREINCREMENT_EXPR'
'POSTDECREMENT_EXPR'
'POSTINCREMENT_EXPR'
     These nodes represent increment and decrement expressions.  The
     value of the single operand is computed, and the operand
     incremented or decremented.  In the case of 'PREDECREMENT_EXPR' and
     'PREINCREMENT_EXPR', the value of the expression is the value
     resulting after the increment or decrement; in the case of
     'POSTDECREMENT_EXPR' and 'POSTINCREMENT_EXPR' is the value before
     the increment or decrement occurs.  The type of the operand, like
     that of the result, will be either integral, boolean, or
     floating-point.

'FIX_TRUNC_EXPR'
     These nodes represent conversion of a floating-point value to an
     integer.  The single operand will have a floating-point type, while
     the complete expression will have an integral (or boolean) type.
     The operand is rounded towards zero.

'FLOAT_EXPR'
     These nodes represent conversion of an integral (or boolean) value
     to a floating-point value.  The single operand will have integral
     type, while the complete expression will have a floating-point
     type.

     FIXME: How is the operand supposed to be rounded?  Is this
     dependent on '-mieee'?

'COMPLEX_EXPR'
     These nodes are used to represent complex numbers constructed from
     two expressions of the same (integer or real) type.  The first
     operand is the real part and the second operand is the imaginary
     part.

'CONJ_EXPR'
     These nodes represent the conjugate of their operand.

'REALPART_EXPR'
'IMAGPART_EXPR'
     These nodes represent respectively the real and the imaginary parts
     of complex numbers (their sole argument).

'NON_LVALUE_EXPR'
     These nodes indicate that their one and only operand is not an
     lvalue.  A back end can treat these identically to the single
     operand.

'NOP_EXPR'
     These nodes are used to represent conversions that do not require
     any code-generation.  For example, conversion of a 'char*' to an
     'int*' does not require any code be generated; such a conversion is
     represented by a 'NOP_EXPR'.  The single operand is the expression
     to be converted.  The conversion from a pointer to a reference is
     also represented with a 'NOP_EXPR'.

'CONVERT_EXPR'
     These nodes are similar to 'NOP_EXPR's, but are used in those
     situations where code may need to be generated.  For example, if an
     'int*' is converted to an 'int' code may need to be generated on
     some platforms.  These nodes are never used for C++-specific
     conversions, like conversions between pointers to different classes
     in an inheritance hierarchy.  Any adjustments that need to be made
     in such cases are always indicated explicitly.  Similarly, a
     user-defined conversion is never represented by a 'CONVERT_EXPR';
     instead, the function calls are made explicit.

'FIXED_CONVERT_EXPR'
     These nodes are used to represent conversions that involve
     fixed-point values.  For example, from a fixed-point value to
     another fixed-point value, from an integer to a fixed-point value,
     from a fixed-point value to an integer, from a floating-point value
     to a fixed-point value, or from a fixed-point value to a
     floating-point value.

'LSHIFT_EXPR'
'RSHIFT_EXPR'
     These nodes represent left and right shifts, respectively.  The
     first operand is the value to shift; it will always be of integral
     type.  The second operand is an expression for the number of bits
     by which to shift.  Right shift should be treated as arithmetic,
     i.e., the high-order bits should be zero-filled when the expression
     has unsigned type and filled with the sign bit when the expression
     has signed type.  Note that the result is undefined if the second
     operand is larger than or equal to the first operand's type size.
     Unlike most nodes, these can have a vector as first operand and a
     scalar as second operand.

'BIT_IOR_EXPR'
'BIT_XOR_EXPR'
'BIT_AND_EXPR'
     These nodes represent bitwise inclusive or, bitwise exclusive or,
     and bitwise and, respectively.  Both operands will always have
     integral type.

'TRUTH_ANDIF_EXPR'
'TRUTH_ORIF_EXPR'
     These nodes represent logical "and" and logical "or", respectively.
     These operators are not strict; i.e., the second operand is
     evaluated only if the value of the expression is not determined by
     evaluation of the first operand.  The type of the operands and that
     of the result are always of 'BOOLEAN_TYPE' or 'INTEGER_TYPE'.

'TRUTH_AND_EXPR'
'TRUTH_OR_EXPR'
'TRUTH_XOR_EXPR'
     These nodes represent logical and, logical or, and logical
     exclusive or.  They are strict; both arguments are always
     evaluated.  There are no corresponding operators in C or C++, but
     the front end will sometimes generate these expressions anyhow, if
     it can tell that strictness does not matter.  The type of the
     operands and that of the result are always of 'BOOLEAN_TYPE' or
     'INTEGER_TYPE'.

'POINTER_PLUS_EXPR'
     This node represents pointer arithmetic.  The first operand is
     always a pointer/reference type.  The second operand is always an
     unsigned integer type compatible with sizetype.  This and
     POINTER_DIFF_EXPR are the only binary arithmetic operators that can
     operate on pointer types.

'POINTER_DIFF_EXPR'
     This node represents pointer subtraction.  The two operands always
     have pointer/reference type.  It returns a signed integer of the
     same precision as the pointers.  The behavior is undefined if the
     difference of the two pointers, seen as infinite precision
     non-negative integers, does not fit in the result type.  The result
     does not depend on the pointer type, it is not divided by the size
     of the pointed-to type.

'PLUS_EXPR'
'MINUS_EXPR'
'MULT_EXPR'
     These nodes represent various binary arithmetic operations.
     Respectively, these operations are addition, subtraction (of the
     second operand from the first) and multiplication.  Their operands
     may have either integral or floating type, but there will never be
     case in which one operand is of floating type and the other is of
     integral type.

     The behavior of these operations on signed arithmetic overflow is
     controlled by the 'flag_wrapv' and 'flag_trapv' variables.

'MULT_HIGHPART_EXPR'
     This node represents the "high-part" of a widening multiplication.
     For an integral type with B bits of precision, the result is the
     most significant B bits of the full 2B product.

'RDIV_EXPR'
     This node represents a floating point division operation.

'TRUNC_DIV_EXPR'
'FLOOR_DIV_EXPR'
'CEIL_DIV_EXPR'
'ROUND_DIV_EXPR'
     These nodes represent integer division operations that return an
     integer result.  'TRUNC_DIV_EXPR' rounds towards zero,
     'FLOOR_DIV_EXPR' rounds towards negative infinity, 'CEIL_DIV_EXPR'
     rounds towards positive infinity and 'ROUND_DIV_EXPR' rounds to the
     closest integer.  Integer division in C and C++ is truncating, i.e.
     'TRUNC_DIV_EXPR'.

     The behavior of these operations on signed arithmetic overflow,
     when dividing the minimum signed integer by minus one, is
     controlled by the 'flag_wrapv' and 'flag_trapv' variables.

'TRUNC_MOD_EXPR'
'FLOOR_MOD_EXPR'
'CEIL_MOD_EXPR'
'ROUND_MOD_EXPR'
     These nodes represent the integer remainder or modulus operation.
     The integer modulus of two operands 'a' and 'b' is defined as 'a -
     (a/b)*b' where the division calculated using the corresponding
     division operator.  Hence for 'TRUNC_MOD_EXPR' this definition
     assumes division using truncation towards zero, i.e.
     'TRUNC_DIV_EXPR'.  Integer remainder in C and C++ uses truncating
     division, i.e. 'TRUNC_MOD_EXPR'.

'EXACT_DIV_EXPR'
     The 'EXACT_DIV_EXPR' code is used to represent integer divisions
     where the numerator is known to be an exact multiple of the
     denominator.  This allows the backend to choose between the faster
     of 'TRUNC_DIV_EXPR', 'CEIL_DIV_EXPR' and 'FLOOR_DIV_EXPR' for the
     current target.

'LT_EXPR'
'LE_EXPR'
'GT_EXPR'
'GE_EXPR'
'LTGT_EXPR'
'EQ_EXPR'
'NE_EXPR'
     These nodes represent the less than, less than or equal to, greater
     than, greater than or equal to, less or greater than, equal, and
     not equal comparison operators.  The first and second operands will
     either be both of integral type, both of floating type or both of
     vector type, except for LTGT_EXPR where they will only be both of
     floating type.  The result type of these expressions will always be
     of integral, boolean or signed integral vector type.  These
     operations return the result type's zero value for false, the
     result type's one value for true, and a vector whose elements are
     zero (false) or minus one (true) for vectors.

     For floating point comparisons, if we honor IEEE NaNs and either
     operand is NaN, then 'NE_EXPR' always returns true and the
     remaining operators always return false.  On some targets,
     comparisons against an IEEE NaN, other than equality and
     inequality, may generate a floating-point exception.

'ORDERED_EXPR'
'UNORDERED_EXPR'
     These nodes represent non-trapping ordered and unordered comparison
     operators.  These operations take two floating point operands and
     determine whether they are ordered or unordered relative to each
     other.  If either operand is an IEEE NaN, their comparison is
     defined to be unordered, otherwise the comparison is defined to be
     ordered.  The result type of these expressions will always be of
     integral or boolean type.  These operations return the result
     type's zero value for false, and the result type's one value for
     true.

'UNLT_EXPR'
'UNLE_EXPR'
'UNGT_EXPR'
'UNGE_EXPR'
'UNEQ_EXPR'
     These nodes represent the unordered comparison operators.  These
     operations take two floating point operands and determine whether
     the operands are unordered or are less than, less than or equal to,
     greater than, greater than or equal to, or equal respectively.  For
     example, 'UNLT_EXPR' returns true if either operand is an IEEE NaN
     or the first operand is less than the second.  All these operations
     are guaranteed not to generate a floating point exception.  The
     result type of these expressions will always be of integral or
     boolean type.  These operations return the result type's zero value
     for false, and the result type's one value for true.

'MODIFY_EXPR'
     These nodes represent assignment.  The left-hand side is the first
     operand; the right-hand side is the second operand.  The left-hand
     side will be a 'VAR_DECL', 'INDIRECT_REF', 'COMPONENT_REF', or
     other lvalue.

     These nodes are used to represent not only assignment with '=' but
     also compound assignments (like '+='), by reduction to '='
     assignment.  In other words, the representation for 'i += 3' looks
     just like that for 'i = i + 3'.

'INIT_EXPR'
     These nodes are just like 'MODIFY_EXPR', but are used only when a
     variable is initialized, rather than assigned to subsequently.
     This means that we can assume that the target of the initialization
     is not used in computing its own value; any reference to the lhs in
     computing the rhs is undefined.

'COMPOUND_EXPR'
     These nodes represent comma-expressions.  The first operand is an
     expression whose value is computed and thrown away prior to the
     evaluation of the second operand.  The value of the entire
     expression is the value of the second operand.

'COND_EXPR'
     These nodes represent '?:' expressions.  The first operand is of
     boolean or integral type.  If it evaluates to a nonzero value, the
     second operand should be evaluated, and returned as the value of
     the expression.  Otherwise, the third operand is evaluated, and
     returned as the value of the expression.

     The second operand must have the same type as the entire
     expression, unless it unconditionally throws an exception or calls
     a noreturn function, in which case it should have void type.  The
     same constraints apply to the third operand.  This allows array
     bounds checks to be represented conveniently as '(i >= 0 && i < 10)
     ? i : abort()'.

     As a GNU extension, the C language front-ends allow the second
     operand of the '?:' operator may be omitted in the source.  For
     example, 'x ? : 3' is equivalent to 'x ? x : 3', assuming that 'x'
     is an expression without side effects.  In the tree representation,
     however, the second operand is always present, possibly protected
     by 'SAVE_EXPR' if the first argument does cause side effects.

'CALL_EXPR'
     These nodes are used to represent calls to functions, including
     non-static member functions.  'CALL_EXPR's are implemented as
     expression nodes with a variable number of operands.  Rather than
     using 'TREE_OPERAND' to extract them, it is preferable to use the
     specialized accessor macros and functions that operate specifically
     on 'CALL_EXPR' nodes.

     'CALL_EXPR_FN' returns a pointer to the function to call; it is
     always an expression whose type is a 'POINTER_TYPE'.

     The number of arguments to the call is returned by
     'call_expr_nargs', while the arguments themselves can be accessed
     with the 'CALL_EXPR_ARG' macro.  The arguments are zero-indexed and
     numbered left-to-right.  You can iterate over the arguments using
     'FOR_EACH_CALL_EXPR_ARG', as in:

          tree call, arg;
          call_expr_arg_iterator iter;
          FOR_EACH_CALL_EXPR_ARG (arg, iter, call)
            /* arg is bound to successive arguments of call.  */
            ...;

     For non-static member functions, there will be an operand
     corresponding to the 'this' pointer.  There will always be
     expressions corresponding to all of the arguments, even if the
     function is declared with default arguments and some arguments are
     not explicitly provided at the call sites.

     'CALL_EXPR's also have a 'CALL_EXPR_STATIC_CHAIN' operand that is
     used to implement nested functions.  This operand is otherwise
     null.

'CLEANUP_POINT_EXPR'
     These nodes represent full-expressions.  The single operand is an
     expression to evaluate.  Any destructor calls engendered by the
     creation of temporaries during the evaluation of that expression
     should be performed immediately after the expression is evaluated.

'CONSTRUCTOR'
     These nodes represent the brace-enclosed initializers for a
     structure or an array.  They contain a sequence of component values
     made out of a vector of constructor_elt, which is a ('INDEX',
     'VALUE') pair.

     If the 'TREE_TYPE' of the 'CONSTRUCTOR' is a 'RECORD_TYPE',
     'UNION_TYPE' or 'QUAL_UNION_TYPE' then the 'INDEX' of each node in
     the sequence will be a 'FIELD_DECL' and the 'VALUE' will be the
     expression used to initialize that field.

     If the 'TREE_TYPE' of the 'CONSTRUCTOR' is an 'ARRAY_TYPE', then
     the 'INDEX' of each node in the sequence will be an 'INTEGER_CST'
     or a 'RANGE_EXPR' of two 'INTEGER_CST's.  A single 'INTEGER_CST'
     indicates which element of the array is being assigned to.  A
     'RANGE_EXPR' indicates an inclusive range of elements to
     initialize.  In both cases the 'VALUE' is the corresponding
     initializer.  It is re-evaluated for each element of a
     'RANGE_EXPR'.  If the 'INDEX' is 'NULL_TREE', then the initializer
     is for the next available array element.

     In the front end, you should not depend on the fields appearing in
     any particular order.  However, in the middle end, fields must
     appear in declaration order.  You should not assume that all fields
     will be represented.  Unrepresented fields will be cleared
     (zeroed), unless the CONSTRUCTOR_NO_CLEARING flag is set, in which
     case their value becomes undefined.

'COMPOUND_LITERAL_EXPR'
     These nodes represent ISO C99 compound literals.  The
     'COMPOUND_LITERAL_EXPR_DECL_EXPR' is a 'DECL_EXPR' containing an
     anonymous 'VAR_DECL' for the unnamed object represented by the
     compound literal; the 'DECL_INITIAL' of that 'VAR_DECL' is a
     'CONSTRUCTOR' representing the brace-enclosed list of initializers
     in the compound literal.  That anonymous 'VAR_DECL' can also be
     accessed directly by the 'COMPOUND_LITERAL_EXPR_DECL' macro.

'SAVE_EXPR'

     A 'SAVE_EXPR' represents an expression (possibly involving side
     effects) that is used more than once.  The side effects should
     occur only the first time the expression is evaluated.  Subsequent
     uses should just reuse the computed value.  The first operand to
     the 'SAVE_EXPR' is the expression to evaluate.  The side effects
     should be executed where the 'SAVE_EXPR' is first encountered in a
     depth-first preorder traversal of the expression tree.

'TARGET_EXPR'
     A 'TARGET_EXPR' represents a temporary object.  The first operand
     is a 'VAR_DECL' for the temporary variable.  The second operand is
     the initializer for the temporary.  The initializer is evaluated
     and, if non-void, copied (bitwise) into the temporary.  If the
     initializer is void, that means that it will perform the
     initialization itself.

     Often, a 'TARGET_EXPR' occurs on the right-hand side of an
     assignment, or as the second operand to a comma-expression which is
     itself the right-hand side of an assignment, etc.  In this case, we
     say that the 'TARGET_EXPR' is "normal"; otherwise, we say it is
     "orphaned".  For a normal 'TARGET_EXPR' the temporary variable
     should be treated as an alias for the left-hand side of the
     assignment, rather than as a new temporary variable.

     The third operand to the 'TARGET_EXPR', if present, is a
     cleanup-expression (i.e., destructor call) for the temporary.  If
     this expression is orphaned, then this expression must be executed
     when the statement containing this expression is complete.  These
     cleanups must always be executed in the order opposite to that in
     which they were encountered.  Note that if a temporary is created
     on one branch of a conditional operator (i.e., in the second or
     third operand to a 'COND_EXPR'), the cleanup must be run only if
     that branch is actually executed.

'VA_ARG_EXPR'
     This node is used to implement support for the C/C++ variable
     argument-list mechanism.  It represents expressions like 'va_arg
     (ap, type)'.  Its 'TREE_TYPE' yields the tree representation for
     'type' and its sole argument yields the representation for 'ap'.

'ANNOTATE_EXPR'
     This node is used to attach markers to an expression.  The first
     operand is the annotated expression, the second is an 'INTEGER_CST'
     with a value from 'enum annot_expr_kind', the third is an
     'INTEGER_CST'.

==============================================================================
File: gccint.info,  Node: |Vectors|,  Prev: |Unary_and_Binary_Expressions|,  Up: |Expression_trees|
==============================================================================

                                                                       *Vectors*

11.6.4 Vectors
--------------

'VEC_DUPLICATE_EXPR'
     This node has a single operand and represents a vector in which
     every element is equal to that operand.

'VEC_SERIES_EXPR'
     This node represents a vector formed from a scalar base and step,
     given as the first and second operands respectively.  Element I of
     the result is equal to 'BASE + I*STEP'.

     This node is restricted to integral types, in order to avoid
     specifying the rounding behavior for floating-point types.

'VEC_LSHIFT_EXPR'
'VEC_RSHIFT_EXPR'
     These nodes represent whole vector left and right shifts,
     respectively.  The first operand is the vector to shift; it will
     always be of vector type.  The second operand is an expression for
     the number of bits by which to shift.  Note that the result is
     undefined if the second operand is larger than or equal to the
     first operand's type size.

'VEC_WIDEN_MULT_HI_EXPR'
'VEC_WIDEN_MULT_LO_EXPR'
     These nodes represent widening vector multiplication of the high
     and low parts of the two input vectors, respectively.  Their
     operands are vectors that contain the same number of elements ('N')
     of the same integral type.  The result is a vector that contains
     half as many elements, of an integral type whose size is twice as
     wide.  In the case of 'VEC_WIDEN_MULT_HI_EXPR' the high 'N/2'
     elements of the two vector are multiplied to produce the vector of
     'N/2' products.  In the case of 'VEC_WIDEN_MULT_LO_EXPR' the low
     'N/2' elements of the two vector are multiplied to produce the
     vector of 'N/2' products.

'VEC_UNPACK_HI_EXPR'
'VEC_UNPACK_LO_EXPR'
     These nodes represent unpacking of the high and low parts of the
     input vector, respectively.  The single operand is a vector that
     contains 'N' elements of the same integral or floating point type.
     The result is a vector that contains half as many elements, of an
     integral or floating point type whose size is twice as wide.  In
     the case of 'VEC_UNPACK_HI_EXPR' the high 'N/2' elements of the
     vector are extracted and widened (promoted).  In the case of
     'VEC_UNPACK_LO_EXPR' the low 'N/2' elements of the vector are
     extracted and widened (promoted).

'VEC_UNPACK_FLOAT_HI_EXPR'
'VEC_UNPACK_FLOAT_LO_EXPR'
     These nodes represent unpacking of the high and low parts of the
     input vector, where the values are converted from fixed point to
     floating point.  The single operand is a vector that contains 'N'
     elements of the same integral type.  The result is a vector that
     contains half as many elements of a floating point type whose size
     is twice as wide.  In the case of 'VEC_UNPACK_FLOAT_HI_EXPR' the
     high 'N/2' elements of the vector are extracted, converted and
     widened.  In the case of 'VEC_UNPACK_FLOAT_LO_EXPR' the low 'N/2'
     elements of the vector are extracted, converted and widened.

'VEC_UNPACK_FIX_TRUNC_HI_EXPR'
'VEC_UNPACK_FIX_TRUNC_LO_EXPR'
     These nodes represent unpacking of the high and low parts of the
     input vector, where the values are truncated from floating point to
     fixed point.  The single operand is a vector that contains 'N'
     elements of the same floating point type.  The result is a vector
     that contains half as many elements of an integral type whose size
     is twice as wide.  In the case of 'VEC_UNPACK_FIX_TRUNC_HI_EXPR'
     the high 'N/2' elements of the vector are extracted and converted
     with truncation.  In the case of 'VEC_UNPACK_FIX_TRUNC_LO_EXPR' the
     low 'N/2' elements of the vector are extracted and converted with
     truncation.

'VEC_PACK_TRUNC_EXPR'
     This node represents packing of truncated elements of the two input
     vectors into the output vector.  Input operands are vectors that
     contain the same number of elements of the same integral or
     floating point type.  The result is a vector that contains twice as
     many elements of an integral or floating point type whose size is
     half as wide.  The elements of the two vectors are demoted and
     merged (concatenated) to form the output vector.

'VEC_PACK_SAT_EXPR'
     This node represents packing of elements of the two input vectors
     into the output vector using saturation.  Input operands are
     vectors that contain the same number of elements of the same
     integral type.  The result is a vector that contains twice as many
     elements of an integral type whose size is half as wide.  The
     elements of the two vectors are demoted and merged (concatenated)
     to form the output vector.

'VEC_PACK_FIX_TRUNC_EXPR'
     This node represents packing of elements of the two input vectors
     into the output vector, where the values are converted from
     floating point to fixed point.  Input operands are vectors that
     contain the same number of elements of a floating point type.  The
     result is a vector that contains twice as many elements of an
     integral type whose size is half as wide.  The elements of the two
     vectors are merged (concatenated) to form the output vector.

'VEC_PACK_FLOAT_EXPR'
     This node represents packing of elements of the two input vectors
     into the output vector, where the values are converted from fixed
     point to floating point.  Input operands are vectors that contain
     the same number of elements of an integral type.  The result is a
     vector that contains twice as many elements of floating point type
     whose size is half as wide.  The elements of the two vectors are
     merged (concatenated) to form the output vector.

'VEC_COND_EXPR'
     These nodes represent '?:' expressions.  The three operands must be
     vectors of the same size and number of elements.  The second and
     third operands must have the same type as the entire expression.
     The first operand is of signed integral vector type.  If an element
     of the first operand evaluates to a zero value, the corresponding
     element of the result is taken from the third operand.  If it
     evaluates to a minus one value, it is taken from the second
     operand.  It should never evaluate to any other value currently,
     but optimizations should not rely on that property.  In contrast
     with a 'COND_EXPR', all operands are always evaluated.

'SAD_EXPR'
     This node represents the Sum of Absolute Differences operation.
     The three operands must be vectors of integral types.  The first
     and second operand must have the same type.  The size of the vector
     element of the third operand must be at lease twice of the size of
     the vector element of the first and second one.  The SAD is
     calculated between the first and second operands, added to the
     third operand, and returned.

==============================================================================
File: gccint.info,  Node: |Statements|,  Next: |Functions|,  Prev: |Expression_trees|,  Up: |GENERIC|
==============================================================================

                                                                    *Statements*

11.7 Statements
=====----------

Most statements in GIMPLE are assignment statements, represented by
'GIMPLE_ASSIGN'.  No other C expressions can appear at statement level;
a reference to a volatile object is converted into a 'GIMPLE_ASSIGN'.

 There are also several varieties of complex statements.

MENU

* |Basic_Statements|::
* |Blocks|::
* |Statement_Sequences|::
* |Empty_Statements|::
* |Jumps|::
* |Cleanups|::
* |OpenMP|::
* |OpenACC|::

==============================================================================
File: gccint.info,  Node: |Basic_Statements|,  Next: |Blocks|,  Up: |Statements|
==============================================================================

                                                              *Basic_Statements*

11.7.1 Basic Statements
-----------------------

'ASM_EXPR'

     Used to represent an inline assembly statement.  For an inline
     assembly statement like:
          asm ("mov x, y");
     The 'ASM_STRING' macro will return a 'STRING_CST' node for '"mov x,
     y"'.  If the original statement made use of the extended-assembly
     syntax, then 'ASM_OUTPUTS', 'ASM_INPUTS', and 'ASM_CLOBBERS' will
     be the outputs, inputs, and clobbers for the statement, represented
     as 'STRING_CST' nodes.  The extended-assembly syntax looks like:
          asm ("fsinx %1,%0" : "=f" (result) : "f" (angle));
     The first string is the 'ASM_STRING', containing the instruction
     template.  The next two strings are the output and inputs,
     respectively; this statement has no clobbers.  As this example
     indicates, "plain" assembly statements are merely a special case of
     extended assembly statements; they have no cv-qualifiers, outputs,
     inputs, or clobbers.  All of the strings will be 'NUL'-terminated,
     and will contain no embedded 'NUL'-characters.

     If the assembly statement is declared 'volatile', or if the
     statement was not an extended assembly statement, and is therefore
     implicitly volatile, then the predicate 'ASM_VOLATILE_P' will hold
     of the 'ASM_EXPR'.

'DECL_EXPR'

     Used to represent a local declaration.  The 'DECL_EXPR_DECL' macro
     can be used to obtain the entity declared.  This declaration may be
     a 'LABEL_DECL', indicating that the label declared is a local
     label.  (As an extension, GCC allows the declaration of labels with
     scope.)  In C, this declaration may be a 'FUNCTION_DECL',
     indicating the use of the GCC nested function extension.  For more
     information, *note Functions::.

'LABEL_EXPR'

     Used to represent a label.  The 'LABEL_DECL' declared by this
     statement can be obtained with the 'LABEL_EXPR_LABEL' macro.  The
     'IDENTIFIER_NODE' giving the name of the label can be obtained from
     the 'LABEL_DECL' with 'DECL_NAME'.

'GOTO_EXPR'

     Used to represent a 'goto' statement.  The 'GOTO_DESTINATION' will
     usually be a 'LABEL_DECL'.  However, if the "computed goto"
     extension has been used, the 'GOTO_DESTINATION' will be an
     arbitrary expression indicating the destination.  This expression
     will always have pointer type.

'RETURN_EXPR'

     Used to represent a 'return' statement.  Operand 0 represents the
     value to return.  It should either be the 'RESULT_DECL' for the
     containing function, or a 'MODIFY_EXPR' or 'INIT_EXPR' setting the
     function's 'RESULT_DECL'.  It will be 'NULL_TREE' if the statement
     was just
          return;

'LOOP_EXPR'
     These nodes represent "infinite" loops.  The 'LOOP_EXPR_BODY'
     represents the body of the loop.  It should be executed forever,
     unless an 'EXIT_EXPR' is encountered.

'EXIT_EXPR'
     These nodes represent conditional exits from the nearest enclosing
     'LOOP_EXPR'.  The single operand is the condition; if it is
     nonzero, then the loop should be exited.  An 'EXIT_EXPR' will only
     appear within a 'LOOP_EXPR'.

'SWITCH_STMT'

     Used to represent a 'switch' statement.  The 'SWITCH_STMT_COND' is
     the expression on which the switch is occurring.  See the
     documentation for an 'IF_STMT' for more information on the
     representation used for the condition.  The 'SWITCH_STMT_BODY' is
     the body of the switch statement.  The 'SWITCH_STMT_TYPE' is the
     original type of switch expression as given in the source, before
     any compiler conversions.

'CASE_LABEL_EXPR'

     Use to represent a 'case' label, range of 'case' labels, or a
     'default' label.  If 'CASE_LOW' is 'NULL_TREE', then this is a
     'default' label.  Otherwise, if 'CASE_HIGH' is 'NULL_TREE', then
     this is an ordinary 'case' label.  In this case, 'CASE_LOW' is an
     expression giving the value of the label.  Both 'CASE_LOW' and
     'CASE_HIGH' are 'INTEGER_CST' nodes.  These values will have the
     same type as the condition expression in the switch statement.

     Otherwise, if both 'CASE_LOW' and 'CASE_HIGH' are defined, the
     statement is a range of case labels.  Such statements originate
     with the extension that allows users to write things of the form:
          case 2 ... 5:
     The first value will be 'CASE_LOW', while the second will be
     'CASE_HIGH'.

'DEBUG_BEGIN_STMT'

     Marks the beginning of a source statement, for purposes of debug
     information generation.

==============================================================================
File: gccint.info,  Node: |Blocks|,  Next: |Statement_Sequences|,  Prev: |Basic_Statements|,  Up: |Statements|
==============================================================================

                                                                        *Blocks*

11.7.2 Blocks
-------------

Block scopes and the variables they declare in GENERIC are expressed
using the 'BIND_EXPR' code, which in previous versions of GCC was
primarily used for the C statement-expression extension.

 Variables in a block are collected into 'BIND_EXPR_VARS' in declaration
order through their 'TREE_CHAIN' field.  Any runtime initialization is
moved out of 'DECL_INITIAL' and into a statement in the controlled
block.  When gimplifying from C or C++, this initialization replaces the
'DECL_STMT'.  These variables will never require cleanups.  The scope of
these variables is just the body

 Variable-length arrays (VLAs) complicate this process, as their size
often refers to variables initialized earlier in the block and their
initialization involves an explicit stack allocation.  To handle this,
we add an indirection and replace them with a pointer to stack space
allocated by means of 'alloca'.  In most cases, we also arrange for this
space to be reclaimed when the enclosing 'BIND_EXPR' is exited, the
exception to this being when there is an explicit call to 'alloca' in
the source code, in which case the stack is left depressed on exit of
the 'BIND_EXPR'.

 A C++ program will usually contain more 'BIND_EXPR's than there are
syntactic blocks in the source code, since several C++ constructs have
implicit scopes associated with them.  On the other hand, although the
C++ front end uses pseudo-scopes to handle cleanups for objects with
destructors, these don't translate into the GIMPLE form; multiple
declarations at the same level use the same 'BIND_EXPR'.

==============================================================================
File: gccint.info,  Node: |Statement_Sequences|,  Next: |Empty_Statements|,  Prev: |Blocks|,  Up: |Statements|
==============================================================================

                                                           *Statement_Sequences*

11.7.3 Statement Sequences
--------------------------

Multiple statements at the same nesting level are collected into a
'STATEMENT_LIST'.  Statement lists are modified and traversed using the
interface in 'tree-iterator.h'.

==============================================================================
File: gccint.info,  Node: |Empty_Statements|,  Next: |Jumps|,  Prev: |Statement_Sequences|,  Up: |Statements|
==============================================================================

                                                              *Empty_Statements*

11.7.4 Empty Statements
-----------------------

Whenever possible, statements with no effect are discarded.  But if they
are nested within another construct which cannot be discarded for some
reason, they are instead replaced with an empty statement, generated by
'build_empty_stmt'.  Initially, all empty statements were shared, after
the pattern of the Java front end, but this caused a lot of trouble in
practice.

 An empty statement is represented as '(void)0'.

==============================================================================
File: gccint.info,  Node: |Jumps|,  Next: |Cleanups|,  Prev: |Empty_Statements|,  Up: |Statements|
==============================================================================

                                                                         *Jumps*

11.7.5 Jumps
------------

Other jumps are expressed by either 'GOTO_EXPR' or 'RETURN_EXPR'.

 The operand of a 'GOTO_EXPR' must be either a label or a variable
containing the address to jump to.

 The operand of a 'RETURN_EXPR' is either 'NULL_TREE', 'RESULT_DECL', or
a 'MODIFY_EXPR' which sets the return value.  It would be nice to move
the 'MODIFY_EXPR' into a separate statement, but the special return
semantics in 'expand_return' make that difficult.  It may still happen
in the future, perhaps by moving most of that logic into
'expand_assignment'.

==============================================================================
File: gccint.info,  Node: |Cleanups|,  Next: |OpenMP|,  Prev: |Jumps|,  Up: |Statements|
==============================================================================

                                                                      *Cleanups*

11.7.6 Cleanups
---------------

Destructors for local C++ objects and similar dynamic cleanups are
represented in GIMPLE by a 'TRY_FINALLY_EXPR'.  'TRY_FINALLY_EXPR' has
two operands, both of which are a sequence of statements to execute.
The first sequence is executed.  When it completes the second sequence
is executed.

 The first sequence may complete in the following ways:

  1. Execute the last statement in the sequence and fall off the end.

  2. Execute a goto statement ('GOTO_EXPR') to an ordinary label outside
     the sequence.

  3. Execute a return statement ('RETURN_EXPR').

  4. Throw an exception.  This is currently not explicitly represented
     in GIMPLE.

 The second sequence is not executed if the first sequence completes by
calling 'setjmp' or 'exit' or any other function that does not return.
The second sequence is also not executed if the first sequence completes
via a non-local goto or a computed goto (in general the compiler does
not know whether such a goto statement exits the first sequence or not,
so we assume that it doesn't).

 After the second sequence is executed, if it completes normally by
falling off the end, execution continues wherever the first sequence
would have continued, by falling off the end, or doing a goto, etc.

 If the second sequence is an 'EH_ELSE_EXPR' selector, then the sequence
in its first operand is used when the first sequence completes normally,
and that in its second operand is used for exceptional cleanups, i.e.,
when an exception propagates out of the first sequence.

 'TRY_FINALLY_EXPR' complicates the flow graph, since the cleanup needs
to appear on every edge out of the controlled block; this reduces the
freedom to move code across these edges.  Therefore, the EH lowering
pass which runs before most of the optimization passes eliminates these
expressions by explicitly adding the cleanup to each edge.  Rethrowing
the exception is represented using 'RESX_EXPR'.

==============================================================================
File: gccint.info,  Node: |OpenMP|,  Next: |OpenACC|,  Prev: |Cleanups|,  Up: |Statements|
==============================================================================

                                                                        *OpenMP*

11.7.7 OpenMP
-------------

All the statements starting with 'OMP_' represent directives and clauses
used by the OpenMP API <https://www.openmp.org>.

'OMP_PARALLEL'

     Represents '#pragma omp parallel [clause1 ... clauseN]'.  It has
     four operands:

     Operand 'OMP_PARALLEL_BODY' is valid while in GENERIC and High
     GIMPLE forms.  It contains the body of code to be executed by all
     the threads.  During GIMPLE lowering, this operand becomes 'NULL'
     and the body is emitted linearly after 'OMP_PARALLEL'.

     Operand 'OMP_PARALLEL_CLAUSES' is the list of clauses associated
     with the directive.

     Operand 'OMP_PARALLEL_FN' is created by 'pass_lower_omp', it
     contains the 'FUNCTION_DECL' for the function that will contain the
     body of the parallel region.

     Operand 'OMP_PARALLEL_DATA_ARG' is also created by
     'pass_lower_omp'.  If there are shared variables to be communicated
     to the children threads, this operand will contain the 'VAR_DECL'
     that contains all the shared values and variables.

'OMP_FOR'

     Represents '#pragma omp for [clause1 ... clauseN]'.  It has six
     operands:

     Operand 'OMP_FOR_BODY' contains the loop body.

     Operand 'OMP_FOR_CLAUSES' is the list of clauses associated with
     the directive.

     Operand 'OMP_FOR_INIT' is the loop initialization code of the form
     'VAR = N1'.

     Operand 'OMP_FOR_COND' is the loop conditional expression of the
     form 'VAR {<,>,<=,>=} N2'.

     Operand 'OMP_FOR_INCR' is the loop index increment of the form 'VAR
     {+=,-=} INCR'.

     Operand 'OMP_FOR_PRE_BODY' contains side effect code from operands
     'OMP_FOR_INIT', 'OMP_FOR_COND' and 'OMP_FOR_INC'.  These side
     effects are part of the 'OMP_FOR' block but must be evaluated
     before the start of loop body.

     The loop index variable 'VAR' must be a signed integer variable,
     which is implicitly private to each thread.  Bounds 'N1' and 'N2'
     and the increment expression 'INCR' are required to be loop
     invariant integer expressions that are evaluated without any
     synchronization.  The evaluation order, frequency of evaluation and
     side effects are unspecified by the standard.

'OMP_SECTIONS'

     Represents '#pragma omp sections [clause1 ... clauseN]'.

     Operand 'OMP_SECTIONS_BODY' contains the sections body, which in
     turn contains a set of 'OMP_SECTION' nodes for each of the
     concurrent sections delimited by '#pragma omp section'.

     Operand 'OMP_SECTIONS_CLAUSES' is the list of clauses associated
     with the directive.

'OMP_SECTION'

     Section delimiter for 'OMP_SECTIONS'.

'OMP_SINGLE'

     Represents '#pragma omp single'.

     Operand 'OMP_SINGLE_BODY' contains the body of code to be executed
     by a single thread.

     Operand 'OMP_SINGLE_CLAUSES' is the list of clauses associated with
     the directive.

'OMP_MASTER'

     Represents '#pragma omp master'.

     Operand 'OMP_MASTER_BODY' contains the body of code to be executed
     by the master thread.

'OMP_ORDERED'

     Represents '#pragma omp ordered'.

     Operand 'OMP_ORDERED_BODY' contains the body of code to be executed
     in the sequential order dictated by the loop index variable.

'OMP_CRITICAL'

     Represents '#pragma omp critical [name]'.

     Operand 'OMP_CRITICAL_BODY' is the critical section.

     Operand 'OMP_CRITICAL_NAME' is an optional identifier to label the
     critical section.

'OMP_RETURN'

     This does not represent any OpenMP directive, it is an artificial
     marker to indicate the end of the body of an OpenMP.  It is used by
     the flow graph ('tree-cfg.c') and OpenMP region building code
     ('omp-low.c').

'OMP_CONTINUE'

     Similarly, this instruction does not represent an OpenMP directive,
     it is used by 'OMP_FOR' (and similar codes) as well as
     'OMP_SECTIONS' to mark the place where the code needs to loop to
     the next iteration, or the next section, respectively.

     In some cases, 'OMP_CONTINUE' is placed right before 'OMP_RETURN'.
     But if there are cleanups that need to occur right after the
     looping body, it will be emitted between 'OMP_CONTINUE' and
     'OMP_RETURN'.

'OMP_ATOMIC'

     Represents '#pragma omp atomic'.

     Operand 0 is the address at which the atomic operation is to be
     performed.

     Operand 1 is the expression to evaluate.  The gimplifier tries
     three alternative code generation strategies.  Whenever possible,
     an atomic update built-in is used.  If that fails, a
     compare-and-swap loop is attempted.  If that also fails, a regular
     critical section around the expression is used.

'OMP_CLAUSE'

     Represents clauses associated with one of the 'OMP_' directives.
     Clauses are represented by separate subcodes defined in 'tree.h'.
     Clauses codes can be one of: 'OMP_CLAUSE_PRIVATE',
     'OMP_CLAUSE_SHARED', 'OMP_CLAUSE_FIRSTPRIVATE',
     'OMP_CLAUSE_LASTPRIVATE', 'OMP_CLAUSE_COPYIN',
     'OMP_CLAUSE_COPYPRIVATE', 'OMP_CLAUSE_IF',
     'OMP_CLAUSE_NUM_THREADS', 'OMP_CLAUSE_SCHEDULE',
     'OMP_CLAUSE_NOWAIT', 'OMP_CLAUSE_ORDERED', 'OMP_CLAUSE_DEFAULT',
     'OMP_CLAUSE_REDUCTION', 'OMP_CLAUSE_COLLAPSE', 'OMP_CLAUSE_UNTIED',
     'OMP_CLAUSE_FINAL', and 'OMP_CLAUSE_MERGEABLE'.  Each code
     represents the corresponding OpenMP clause.

     Clauses associated with the same directive are chained together via
     'OMP_CLAUSE_CHAIN'.  Those clauses that accept a list of variables
     are restricted to exactly one, accessed with 'OMP_CLAUSE_VAR'.
     Therefore, multiple variables under the same clause 'C' need to be
     represented as multiple 'C' clauses chained together.  This
     facilitates adding new clauses during compilation.

==============================================================================
File: gccint.info,  Node: |OpenACC|,  Prev: |OpenMP|,  Up: |Statements|
==============================================================================

                                                                       *OpenACC*

11.7.8 OpenACC
--------------

All the statements starting with 'OACC_' represent directives and
clauses used by the OpenACC API <https://www.openacc.org>.

'OACC_CACHE'

     Represents '#pragma acc cache (var ...)'.

'OACC_DATA'

     Represents '#pragma acc data [clause1 ... clauseN]'.

'OACC_DECLARE'

     Represents '#pragma acc declare [clause1 ... clauseN]'.

'OACC_ENTER_DATA'

     Represents '#pragma acc enter data [clause1 ... clauseN]'.

'OACC_EXIT_DATA'

     Represents '#pragma acc exit data [clause1 ... clauseN]'.

'OACC_HOST_DATA'

     Represents '#pragma acc host_data [clause1 ... clauseN]'.

'OACC_KERNELS'

     Represents '#pragma acc kernels [clause1 ... clauseN]'.

'OACC_LOOP'

     Represents '#pragma acc loop [clause1 ... clauseN]'.

     See the description of the 'OMP_FOR' code.

'OACC_PARALLEL'

     Represents '#pragma acc parallel [clause1 ... clauseN]'.

'OACC_SERIAL'

     Represents '#pragma acc serial [clause1 ... clauseN]'.

'OACC_UPDATE'

     Represents '#pragma acc update [clause1 ... clauseN]'.

==============================================================================
File: gccint.info,  Node: |Functions|,  Next: |Language_dependent_trees|,  Prev: |Statements|,  Up: |GENERIC|
==============================================================================

                                                                     *Functions*

11.8 Functions
=====---------

A function is represented by a 'FUNCTION_DECL' node.  It stores the
basic pieces of the function such as body, parameters, and return type
as well as information on the surrounding context, visibility, and
linkage.

MENU

* |Function_Basics|::     Function names, body, and parameters.
* |Function_Properties|:: Context, linkage, etc.

==============================================================================
File: gccint.info,  Node: |Function_Basics|,  Next: |Function_Properties|,  Up: |Functions|
==============================================================================

                                                               *Function_Basics*

11.8.1 Function Basics
----------------------

A function has four core parts: the name, the parameters, the result,
and the body.  The following macros and functions access these parts of
a 'FUNCTION_DECL' as well as other basic features:
'DECL_NAME'
     This macro returns the unqualified name of the function, as an
     'IDENTIFIER_NODE'.  For an instantiation of a function template,
     the 'DECL_NAME' is the unqualified name of the template, not
     something like 'f<int>'.  The value of 'DECL_NAME' is undefined
     when used on a constructor, destructor, overloaded operator, or
     type-conversion operator, or any function that is implicitly
     generated by the compiler.  See below for macros that can be used
     to distinguish these cases.

'DECL_ASSEMBLER_NAME'
     This macro returns the mangled name of the function, also an
     'IDENTIFIER_NODE'.  This name does not contain leading underscores
     on systems that prefix all identifiers with underscores.  The
     mangled name is computed in the same way on all platforms; if
     special processing is required to deal with the object file format
     used on a particular platform, it is the responsibility of the back
     end to perform those modifications.  (Of course, the back end
     should not modify 'DECL_ASSEMBLER_NAME' itself.)

     Using 'DECL_ASSEMBLER_NAME' will cause additional memory to be
     allocated (for the mangled name of the entity) so it should be used
     only when emitting assembly code.  It should not be used within the
     optimizers to determine whether or not two declarations are the
     same, even though some of the existing optimizers do use it in that
     way.  These uses will be removed over time.

'DECL_ARGUMENTS'
     This macro returns the 'PARM_DECL' for the first argument to the
     function.  Subsequent 'PARM_DECL' nodes can be obtained by
     following the 'TREE_CHAIN' links.

'DECL_RESULT'
     This macro returns the 'RESULT_DECL' for the function.

'DECL_SAVED_TREE'
     This macro returns the complete body of the function.

'TREE_TYPE'
     This macro returns the 'FUNCTION_TYPE' or 'METHOD_TYPE' for the
     function.

'DECL_INITIAL'
     A function that has a definition in the current translation unit
     will have a non-'NULL' 'DECL_INITIAL'.  However, back ends should
     not make use of the particular value given by 'DECL_INITIAL'.

     It should contain a tree of 'BLOCK' nodes that mirrors the scopes
     that variables are bound in the function.  Each block contains a
     list of decls declared in a basic block, a pointer to a chain of
     blocks at the next lower scope level, then a pointer to the next
     block at the same level and a backpointer to the parent 'BLOCK' or
     'FUNCTION_DECL'.  So given a function as follows:

          void foo()
          {
            int a;
            {
              int b;
            }
            int c;
          }

     you would get the following:

          tree foo = FUNCTION_DECL;
          tree decl_a = VAR_DECL;
          tree decl_b = VAR_DECL;
          tree decl_c = VAR_DECL;
          tree block_a = BLOCK;
          tree block_b = BLOCK;
          tree block_c = BLOCK;
          BLOCK_VARS(block_a) = decl_a;
          BLOCK_SUBBLOCKS(block_a) = block_b;
          BLOCK_CHAIN(block_a) = block_c;
          BLOCK_SUPERCONTEXT(block_a) = foo;
          BLOCK_VARS(block_b) = decl_b;
          BLOCK_SUPERCONTEXT(block_b) = block_a;
          BLOCK_VARS(block_c) = decl_c;
          BLOCK_SUPERCONTEXT(block_c) = foo;
          DECL_INITIAL(foo) = block_a;

==============================================================================
File: gccint.info,  Node: |Function_Properties|,  Prev: |Function_Basics|,  Up: |Functions|
==============================================================================

                                                           *Function_Properties*

11.8.2 Function Properties
--------------------------

To determine the scope of a function, you can use the 'DECL_CONTEXT'
macro.  This macro will return the class (either a 'RECORD_TYPE' or a
'UNION_TYPE') or namespace (a 'NAMESPACE_DECL') of which the function is
a member.  For a virtual function, this macro returns the class in which
the function was actually defined, not the base class in which the
virtual declaration occurred.

 In C, the 'DECL_CONTEXT' for a function maybe another function.  This
representation indicates that the GNU nested function extension is in
use.  For details on the semantics of nested functions, see the GCC
Manual.  The nested function can refer to local variables in its
containing function.  Such references are not explicitly marked in the
tree structure; back ends must look at the 'DECL_CONTEXT' for the
referenced 'VAR_DECL'.  If the 'DECL_CONTEXT' for the referenced
'VAR_DECL' is not the same as the function currently being processed,
and neither 'DECL_EXTERNAL' nor 'TREE_STATIC' hold, then the reference
is to a local variable in a containing function, and the back end must
take appropriate action.

'DECL_EXTERNAL'
     This predicate holds if the function is undefined.

'TREE_PUBLIC'
     This predicate holds if the function has external linkage.

'TREE_STATIC'
     This predicate holds if the function has been defined.

'TREE_THIS_VOLATILE'
     This predicate holds if the function does not return normally.

'TREE_READONLY'
     This predicate holds if the function can only read its arguments.

'DECL_PURE_P'
     This predicate holds if the function can only read its arguments,
     but may also read global memory.

'DECL_VIRTUAL_P'
     This predicate holds if the function is virtual.

'DECL_ARTIFICIAL'
     This macro holds if the function was implicitly generated by the
     compiler, rather than explicitly declared.  In addition to
     implicitly generated class member functions, this macro holds for
     the special functions created to implement static initialization
     and destruction, to compute run-time type information, and so
     forth.

'DECL_FUNCTION_SPECIFIC_TARGET'
     This macro returns a tree node that holds the target options that
     are to be used to compile this particular function or 'NULL_TREE'
     if the function is to be compiled with the target options specified
     on the command line.

'DECL_FUNCTION_SPECIFIC_OPTIMIZATION'
     This macro returns a tree node that holds the optimization options
     that are to be used to compile this particular function or
     'NULL_TREE' if the function is to be compiled with the optimization
     options specified on the command line.

==============================================================================
File: gccint.info,  Node: |Language_dependent_trees|,  Next: |C_and_C++_Trees|,  Prev: |Functions|,  Up: |GENERIC|
==============================================================================

                                                      *Language_dependent_trees*

11.9 Language-dependent trees
=====------------------------

Front ends may wish to keep some state associated with various GENERIC
trees while parsing.  To support this, trees provide a set of flags that
may be used by the front end.  They are accessed using
'TREE_LANG_FLAG_n' where 'n' is currently 0 through 6.

 If necessary, a front end can use some language-dependent tree codes in
its GENERIC representation, so long as it provides a hook for converting
them to GIMPLE and doesn't expect them to work with any (hypothetical)
optimizers that run before the conversion to GIMPLE.  The intermediate
representation used while parsing C and C++ looks very little like
GENERIC, but the C and C++ gimplifier hooks are perfectly happy to take
it as input and spit out GIMPLE.

==============================================================================
File: gccint.info,  Node: |C_and_C++_Trees|,  Prev: |Language_dependent_trees|,  Up: |GENERIC|
==============================================================================

                                                               *C_and_C++_Trees*

11.10 C and C++ Trees
=====----------------

This section documents the internal representation used by GCC to
represent C and C++ source programs.  When presented with a C or C++
source program, GCC parses the program, performs semantic analysis
(including the generation of error messages), and then produces the
internal representation described here.  This representation contains a
complete representation for the entire translation unit provided as
input to the front end.  This representation is then typically processed
by a code-generator in order to produce machine code, but could also be
used in the creation of source browsers, intelligent editors, automatic
documentation generators, interpreters, and any other programs needing
the ability to process C or C++ code.

 This section explains the internal representation.  In particular, it
documents the internal representation for C and C++ source constructs,
and the macros, functions, and variables that can be used to access
these constructs.  The C++ representation is largely a superset of the
representation used in the C front end.  There is only one construct
used in C that does not appear in the C++ front end and that is the GNU
"nested function" extension.  Many of the macros documented here do not
apply in C because the corresponding language constructs do not appear
in C.

 The C and C++ front ends generate a mix of GENERIC trees and ones
specific to C and C++.  These language-specific trees are higher-level
constructs than the ones in GENERIC to make the parser's job easier.
This section describes those trees that aren't part of GENERIC as well
as aspects of GENERIC trees that are treated in a language-specific
manner.

 If you are developing a "back end", be it is a code-generator or some
other tool, that uses this representation, you may occasionally find
that you need to ask questions not easily answered by the functions and
macros available here.  If that situation occurs, it is quite likely
that GCC already supports the functionality you desire, but that the
interface is simply not documented here.  In that case, you should ask
the GCC maintainers (via mail to <gcc@gcc.gnu.org>) about documenting
the functionality you require.  Similarly, if you find yourself writing
functions that do not deal directly with your back end, but instead
might be useful to other people using the GCC front end, you should
submit your patches for inclusion in GCC.

MENU

* |Types_for_C++|::               Fundamental and aggregate types.
* |Namespaces|::                  Namespaces.
* |Classes|::                     Classes.
* |Functions_for_C++|::           Overloading and accessors for C++.
* |Statements_for_C++|::          Statements specific to C and C++.
* |C++_Expressions|::    From 'typeid' to 'throw'.

==============================================================================
File: gccint.info,  Node: |Types_for_C++|,  Next: |Namespaces|,  Up: |C_and_C++_Trees|
==============================================================================

                                                                 *Types_for_C++*

11.10.1 Types for C++
---------------------

In C++, an array type is not qualified; rather the type of the array
elements is qualified.  This situation is reflected in the intermediate
representation.  The macros described here will always examine the
qualification of the underlying element type when applied to an array
type.  (If the element type is itself an array, then the recursion
continues until a non-array type is found, and the qualification of this
type is examined.)  So, for example, 'CP_TYPE_CONST_P' will hold of the
type 'const int ()[7]', denoting an array of seven 'int's.

 The following functions and macros deal with cv-qualification of types:
'cp_type_quals'
     This function returns the set of type qualifiers applied to this
     type.  This value is 'TYPE_UNQUALIFIED' if no qualifiers have been
     applied.  The 'TYPE_QUAL_CONST' bit is set if the type is
     'const'-qualified.  The 'TYPE_QUAL_VOLATILE' bit is set if the type
     is 'volatile'-qualified.  The 'TYPE_QUAL_RESTRICT' bit is set if
     the type is 'restrict'-qualified.

'CP_TYPE_CONST_P'
     This macro holds if the type is 'const'-qualified.

'CP_TYPE_VOLATILE_P'
     This macro holds if the type is 'volatile'-qualified.

'CP_TYPE_RESTRICT_P'
     This macro holds if the type is 'restrict'-qualified.

'CP_TYPE_CONST_NON_VOLATILE_P'
     This predicate holds for a type that is 'const'-qualified, but
     _not_ 'volatile'-qualified; other cv-qualifiers are ignored as
     well: only the 'const'-ness is tested.

 A few other macros and functions are usable with all types:
'TYPE_SIZE'
     The number of bits required to represent the type, represented as
     an 'INTEGER_CST'.  For an incomplete type, 'TYPE_SIZE' will be
     'NULL_TREE'.

'TYPE_ALIGN'
     The alignment of the type, in bits, represented as an 'int'.

'TYPE_NAME'
     This macro returns a declaration (in the form of a 'TYPE_DECL') for
     the type.  (Note this macro does _not_ return an 'IDENTIFIER_NODE',
     as you might expect, given its name!)  You can look at the
     'DECL_NAME' of the 'TYPE_DECL' to obtain the actual name of the
     type.  The 'TYPE_NAME' will be 'NULL_TREE' for a type that is not a
     built-in type, the result of a typedef, or a named class type.

'CP_INTEGRAL_TYPE'
     This predicate holds if the type is an integral type.  Notice that
     in C++, enumerations are _not_ integral types.

'ARITHMETIC_TYPE_P'
     This predicate holds if the type is an integral type (in the C++
     sense) or a floating point type.

'CLASS_TYPE_P'
     This predicate holds for a class-type.

'TYPE_BUILT_IN'
     This predicate holds for a built-in type.

'TYPE_PTRDATAMEM_P'
     This predicate holds if the type is a pointer to data member.

'TYPE_PTR_P'
     This predicate holds if the type is a pointer type, and the pointee
     is not a data member.

'TYPE_PTRFN_P'
     This predicate holds for a pointer to function type.

'TYPE_PTROB_P'
     This predicate holds for a pointer to object type.  Note however
     that it does not hold for the generic pointer to object type 'void
     *'.  You may use 'TYPE_PTROBV_P' to test for a pointer to object
     type as well as 'void *'.

 The table below describes types specific to C and C++ as well as
language-dependent info about GENERIC types.

'POINTER_TYPE'
     Used to represent pointer types, and pointer to data member types.
     If 'TREE_TYPE' is a pointer to data member type, then
     'TYPE_PTRDATAMEM_P' will hold.  For a pointer to data member type
     of the form 'T X::*', 'TYPE_PTRMEM_CLASS_TYPE' will be the type
     'X', while 'TYPE_PTRMEM_POINTED_TO_TYPE' will be the type 'T'.

'RECORD_TYPE'
     Used to represent 'struct' and 'class' types in C and C++.  If
     'TYPE_PTRMEMFUNC_P' holds, then this type is a pointer-to-member
     type.  In that case, the 'TYPE_PTRMEMFUNC_FN_TYPE' is a
     'POINTER_TYPE' pointing to a 'METHOD_TYPE'.  The 'METHOD_TYPE' is
     the type of a function pointed to by the pointer-to-member
     function.  If 'TYPE_PTRMEMFUNC_P' does not hold, this type is a
     class type.  For more information, *note Classes::.

'UNKNOWN_TYPE'
     This node is used to represent a type the knowledge of which is
     insufficient for a sound processing.

'TYPENAME_TYPE'
     Used to represent a construct of the form 'typename T::A'.  The
     'TYPE_CONTEXT' is 'T'; the 'TYPE_NAME' is an 'IDENTIFIER_NODE' for
     'A'.  If the type is specified via a template-id, then
     'TYPENAME_TYPE_FULLNAME' yields a 'TEMPLATE_ID_EXPR'.  The
     'TREE_TYPE' is non-'NULL' if the node is implicitly generated in
     support for the implicit typename extension; in which case the
     'TREE_TYPE' is a type node for the base-class.

'TYPEOF_TYPE'
     Used to represent the '__typeof__' extension.  The 'TYPE_FIELDS' is
     the expression the type of which is being represented.

==============================================================================
File: gccint.info,  Node: |Namespaces|,  Next: |Classes|,  Prev: |Types_for_C++|,  Up: |C_and_C++_Trees|
==============================================================================

                                                                    *Namespaces*

11.10.2 Namespaces
------------------

The root of the entire intermediate representation is the variable
'global_namespace'.  This is the namespace specified with '::' in C++
source code.  All other namespaces, types, variables, functions, and so
forth can be found starting with this namespace.

 However, except for the fact that it is distinguished as the root of
the representation, the global namespace is no different from any other
namespace.  Thus, in what follows, we describe namespaces generally,
rather than the global namespace in particular.

 A namespace is represented by a 'NAMESPACE_DECL' node.

 The following macros and functions can be used on a 'NAMESPACE_DECL':

'DECL_NAME'
     This macro is used to obtain the 'IDENTIFIER_NODE' corresponding to
     the unqualified name of the name of the namespace (*note
     Identifiers::).  The name of the global namespace is '::', even
     though in C++ the global namespace is unnamed.  However, you should
     use comparison with 'global_namespace', rather than 'DECL_NAME' to
     determine whether or not a namespace is the global one.  An unnamed
     namespace will have a 'DECL_NAME' equal to
     'anonymous_namespace_name'.  Within a single translation unit, all
     unnamed namespaces will have the same name.

'DECL_CONTEXT'
     This macro returns the enclosing namespace.  The 'DECL_CONTEXT' for
     the 'global_namespace' is 'NULL_TREE'.

'DECL_NAMESPACE_ALIAS'
     If this declaration is for a namespace alias, then
     'DECL_NAMESPACE_ALIAS' is the namespace for which this one is an
     alias.

     Do not attempt to use 'cp_namespace_decls' for a namespace which is
     an alias.  Instead, follow 'DECL_NAMESPACE_ALIAS' links until you
     reach an ordinary, non-alias, namespace, and call
     'cp_namespace_decls' there.

'DECL_NAMESPACE_STD_P'
     This predicate holds if the namespace is the special '::std'
     namespace.

'cp_namespace_decls'
     This function will return the declarations contained in the
     namespace, including types, overloaded functions, other namespaces,
     and so forth.  If there are no declarations, this function will
     return 'NULL_TREE'.  The declarations are connected through their
     'TREE_CHAIN' fields.

     Although most entries on this list will be declarations,
     'TREE_LIST' nodes may also appear.  In this case, the 'TREE_VALUE'
     will be an 'OVERLOAD'.  The value of the 'TREE_PURPOSE' is
     unspecified; back ends should ignore this value.  As with the other
     kinds of declarations returned by 'cp_namespace_decls', the
     'TREE_CHAIN' will point to the next declaration in this list.

     For more information on the kinds of declarations that can occur on
     this list, *Note Declarations::.  Some declarations will not appear
     on this list.  In particular, no 'FIELD_DECL', 'LABEL_DECL', or
     'PARM_DECL' nodes will appear here.

     This function cannot be used with namespaces that have
     'DECL_NAMESPACE_ALIAS' set.

==============================================================================
File: gccint.info,  Node: |Classes|,  Next: |Functions_for_C++|,  Prev: |Namespaces|,  Up: |C_and_C++_Trees|
==============================================================================

                                                                       *Classes*

11.10.3 Classes
---------------

Besides namespaces, the other high-level scoping construct in C++ is the
class.  (Throughout this manual the term "class" is used to mean the
types referred to in the ANSI/ISO C++ Standard as classes; these include
types defined with the 'class', 'struct', and 'union' keywords.)

 A class type is represented by either a 'RECORD_TYPE' or a
'UNION_TYPE'.  A class declared with the 'union' tag is represented by a
'UNION_TYPE', while classes declared with either the 'struct' or the
'class' tag are represented by 'RECORD_TYPE's.  You can use the
'CLASSTYPE_DECLARED_CLASS' macro to discern whether or not a particular
type is a 'class' as opposed to a 'struct'.  This macro will be true
only for classes declared with the 'class' tag.

 Almost all members are available on the 'TYPE_FIELDS' list.  Given one
member, the next can be found by following the 'TREE_CHAIN'.  You should
not depend in any way on the order in which fields appear on this list.
All nodes on this list will be 'DECL' nodes.  A 'FIELD_DECL' is used to
represent a non-static data member, a 'VAR_DECL' is used to represent a
static data member, and a 'TYPE_DECL' is used to represent a type.  Note
that the 'CONST_DECL' for an enumeration constant will appear on this
list, if the enumeration type was declared in the class.  (Of course,
the 'TYPE_DECL' for the enumeration type will appear here as well.)
There are no entries for base classes on this list.  In particular,
there is no 'FIELD_DECL' for the "base-class portion" of an object.  If
a function member is overloaded, each of the overloaded functions
appears; no 'OVERLOAD' nodes appear on the 'TYPE_FIELDS' list.
Implicitly declared functions (including default constructors, copy
constructors, assignment operators, and destructors) will appear on this
list as well.

 The 'TYPE_VFIELD' is a compiler-generated field used to point to
virtual function tables.  It may or may not appear on the 'TYPE_FIELDS'
list.  However, back ends should handle the 'TYPE_VFIELD' just like all
the entries on the 'TYPE_FIELDS' list.

 Every class has an associated "binfo", which can be obtained with
'TYPE_BINFO'.  Binfos are used to represent base-classes.  The binfo
given by 'TYPE_BINFO' is the degenerate case, whereby every class is
considered to be its own base-class.  The base binfos for a particular
binfo are held in a vector, whose length is obtained with
'BINFO_N_BASE_BINFOS'.  The base binfos themselves are obtained with
'BINFO_BASE_BINFO' and 'BINFO_BASE_ITERATE'.  To add a new binfo, use
'BINFO_BASE_APPEND'.  The vector of base binfos can be obtained with
'BINFO_BASE_BINFOS', but normally you do not need to use that.  The
class type associated with a binfo is given by 'BINFO_TYPE'.  It is not
always the case that 'BINFO_TYPE (TYPE_BINFO (x))', because of typedefs
and qualified types.  Neither is it the case that 'TYPE_BINFO
(BINFO_TYPE (y))' is the same binfo as 'y'.  The reason is that if 'y'
is a binfo representing a base-class 'B' of a derived class 'D', then
'BINFO_TYPE (y)' will be 'B', and 'TYPE_BINFO (BINFO_TYPE (y))' will be
'B' as its own base-class, rather than as a base-class of 'D'.

 The access to a base type can be found with 'BINFO_BASE_ACCESS'.  This
will produce 'access_public_node', 'access_private_node' or
'access_protected_node'.  If bases are always public,
'BINFO_BASE_ACCESSES' may be 'NULL'.

 'BINFO_VIRTUAL_P' is used to specify whether the binfo is inherited
virtually or not.  The other flags, 'BINFO_FLAG_0' to 'BINFO_FLAG_6',
can be used for language specific use.

 The following macros can be used on a tree node representing a
class-type.

'LOCAL_CLASS_P'
     This predicate holds if the class is local class _i.e._ declared
     inside a function body.

'TYPE_POLYMORPHIC_P'
     This predicate holds if the class has at least one virtual function
     (declared or inherited).

'TYPE_HAS_DEFAULT_CONSTRUCTOR'
     This predicate holds whenever its argument represents a class-type
     with default constructor.

'CLASSTYPE_HAS_MUTABLE'
'TYPE_HAS_MUTABLE_P'
     These predicates hold for a class-type having a mutable data
     member.

'CLASSTYPE_NON_POD_P'
     This predicate holds only for class-types that are not PODs.

'TYPE_HAS_NEW_OPERATOR'
     This predicate holds for a class-type that defines 'operator new'.

'TYPE_HAS_ARRAY_NEW_OPERATOR'
     This predicate holds for a class-type for which 'operator new[]' is
     defined.

'TYPE_OVERLOADS_CALL_EXPR'
     This predicate holds for class-type for which the function call
     'operator()' is overloaded.

'TYPE_OVERLOADS_ARRAY_REF'
     This predicate holds for a class-type that overloads 'operator[]'

'TYPE_OVERLOADS_ARROW'
     This predicate holds for a class-type for which 'operator->' is
     overloaded.

==============================================================================
File: gccint.info,  Node: |Functions_for_C++|,  Next: |Statements_for_C++|,  Prev: |Classes|,  Up: |C_and_C++_Trees|
==============================================================================

                                                             *Functions_for_C++*

11.10.4 Functions for C++
-------------------------

A function is represented by a 'FUNCTION_DECL' node.  A set of
overloaded functions is sometimes represented by an 'OVERLOAD' node.

 An 'OVERLOAD' node is not a declaration, so none of the 'DECL_' macros
should be used on an 'OVERLOAD'.  An 'OVERLOAD' node is similar to a
'TREE_LIST'.  Use 'OVL_CURRENT' to get the function associated with an
'OVERLOAD' node; use 'OVL_NEXT' to get the next 'OVERLOAD' node in the
list of overloaded functions.  The macros 'OVL_CURRENT' and 'OVL_NEXT'
are actually polymorphic; you can use them to work with 'FUNCTION_DECL'
nodes as well as with overloads.  In the case of a 'FUNCTION_DECL',
'OVL_CURRENT' will always return the function itself, and 'OVL_NEXT'
will always be 'NULL_TREE'.

 To determine the scope of a function, you can use the 'DECL_CONTEXT'
macro.  This macro will return the class (either a 'RECORD_TYPE' or a
'UNION_TYPE') or namespace (a 'NAMESPACE_DECL') of which the function is
a member.  For a virtual function, this macro returns the class in which
the function was actually defined, not the base class in which the
virtual declaration occurred.

 If a friend function is defined in a class scope, the
'DECL_FRIEND_CONTEXT' macro can be used to determine the class in which
it was defined.  For example, in
     class C { friend void f() {} };
the 'DECL_CONTEXT' for 'f' will be the 'global_namespace', but the
'DECL_FRIEND_CONTEXT' will be the 'RECORD_TYPE' for 'C'.

 The following macros and functions can be used on a 'FUNCTION_DECL':
'DECL_MAIN_P'
     This predicate holds for a function that is the program entry point
     '::code'.

'DECL_LOCAL_FUNCTION_P'
     This predicate holds if the function was declared at block scope,
     even though it has a global scope.

'DECL_ANTICIPATED'
     This predicate holds if the function is a built-in function but its
     prototype is not yet explicitly declared.

'DECL_EXTERN_C_FUNCTION_P'
     This predicate holds if the function is declared as an ''extern
     "C"'' function.

'DECL_LINKONCE_P'
     This macro holds if multiple copies of this function may be emitted
     in various translation units.  It is the responsibility of the
     linker to merge the various copies.  Template instantiations are
     the most common example of functions for which 'DECL_LINKONCE_P'
     holds; G++ instantiates needed templates in all translation units
     which require them, and then relies on the linker to remove
     duplicate instantiations.

     FIXME: This macro is not yet implemented.

'DECL_FUNCTION_MEMBER_P'
     This macro holds if the function is a member of a class, rather
     than a member of a namespace.

'DECL_STATIC_FUNCTION_P'
     This predicate holds if the function a static member function.

'DECL_NONSTATIC_MEMBER_FUNCTION_P'
     This macro holds for a non-static member function.

'DECL_CONST_MEMFUNC_P'
     This predicate holds for a 'const'-member function.

'DECL_VOLATILE_MEMFUNC_P'
     This predicate holds for a 'volatile'-member function.

'DECL_CONSTRUCTOR_P'
     This macro holds if the function is a constructor.

'DECL_NONCONVERTING_P'
     This predicate holds if the constructor is a non-converting
     constructor.

'DECL_COMPLETE_CONSTRUCTOR_P'
     This predicate holds for a function which is a constructor for an
     object of a complete type.

'DECL_BASE_CONSTRUCTOR_P'
     This predicate holds for a function which is a constructor for a
     base class sub-object.

'DECL_COPY_CONSTRUCTOR_P'
     This predicate holds for a function which is a copy-constructor.

'DECL_DESTRUCTOR_P'
     This macro holds if the function is a destructor.

'DECL_COMPLETE_DESTRUCTOR_P'
     This predicate holds if the function is the destructor for an
     object a complete type.

'DECL_OVERLOADED_OPERATOR_P'
     This macro holds if the function is an overloaded operator.

'DECL_CONV_FN_P'
     This macro holds if the function is a type-conversion operator.

'DECL_GLOBAL_CTOR_P'
     This predicate holds if the function is a file-scope initialization
     function.

'DECL_GLOBAL_DTOR_P'
     This predicate holds if the function is a file-scope finalization
     function.

'DECL_THUNK_P'
     This predicate holds if the function is a thunk.

     These functions represent stub code that adjusts the 'this' pointer
     and then jumps to another function.  When the jumped-to function
     returns, control is transferred directly to the caller, without
     returning to the thunk.  The first parameter to the thunk is always
     the 'this' pointer; the thunk should add 'THUNK_DELTA' to this
     value.  (The 'THUNK_DELTA' is an 'int', not an 'INTEGER_CST'.)

     Then, if 'THUNK_VCALL_OFFSET' (an 'INTEGER_CST') is nonzero the
     adjusted 'this' pointer must be adjusted again.  The complete
     calculation is given by the following pseudo-code:

          this += THUNK_DELTA
          if (THUNK_VCALL_OFFSET)
            this += (*((ptrdiff_t **) this))[THUNK_VCALL_OFFSET]

     Finally, the thunk should jump to the location given by
     'DECL_INITIAL'; this will always be an expression for the address
     of a function.

'DECL_NON_THUNK_FUNCTION_P'
     This predicate holds if the function is _not_ a thunk function.

'GLOBAL_INIT_PRIORITY'
     If either 'DECL_GLOBAL_CTOR_P' or 'DECL_GLOBAL_DTOR_P' holds, then
     this gives the initialization priority for the function.  The
     linker will arrange that all functions for which
     'DECL_GLOBAL_CTOR_P' holds are run in increasing order of priority
     before 'main' is called.  When the program exits, all functions for
     which 'DECL_GLOBAL_DTOR_P' holds are run in the reverse order.

'TYPE_RAISES_EXCEPTIONS'
     This macro returns the list of exceptions that a (member-)function
     can raise.  The returned list, if non 'NULL', is comprised of nodes
     whose 'TREE_VALUE' represents a type.

'TYPE_NOTHROW_P'
     This predicate holds when the exception-specification of its
     arguments is of the form ''()''.

'DECL_ARRAY_DELETE_OPERATOR_P'
     This predicate holds if the function an overloaded 'operator
     delete[]'.

==============================================================================
File: gccint.info,  Node: |Statements_for_C++|,  Next: |C++_Expressions|,  Prev: |Functions_for_C++|,  Up: |C_and_C++_Trees|
==============================================================================

                                                            *Statements_for_C++*

11.10.5 Statements for C++
--------------------------

A function that has a definition in the current translation unit will
have a non-'NULL' 'DECL_INITIAL'.  However, back ends should not make
use of the particular value given by 'DECL_INITIAL'.

 The 'DECL_SAVED_TREE' macro will give the complete body of the
function.

11.10.5.1 Statements
.....---------------

There are tree nodes corresponding to all of the source-level statement
constructs, used within the C and C++ frontends.  These are enumerated
here, together with a list of the various macros that can be used to
obtain information about them.  There are a few macros that can be used
with all statements:

'STMT_IS_FULL_EXPR_P'
     In C++, statements normally constitute "full expressions";
     temporaries created during a statement are destroyed when the
     statement is complete.  However, G++ sometimes represents
     expressions by statements; these statements will not have
     'STMT_IS_FULL_EXPR_P' set.  Temporaries created during such
     statements should be destroyed when the innermost enclosing
     statement with 'STMT_IS_FULL_EXPR_P' set is exited.

 Here is the list of the various statement nodes, and the macros used to
access them.  This documentation describes the use of these nodes in
non-template functions (including instantiations of template functions).
In template functions, the same nodes are used, but sometimes in
slightly different ways.

 Many of the statements have substatements.  For example, a 'while' loop
will have a body, which is itself a statement.  If the substatement is
'NULL_TREE', it is considered equivalent to a statement consisting of a
single ';', i.e., an expression statement in which the expression has
been omitted.  A substatement may in fact be a list of statements,
connected via their 'TREE_CHAIN's.  So, you should always process the
statement tree by looping over substatements, like this:
     void process_stmt (stmt)
          tree stmt;
     {
       while (stmt)
         {
           switch (TREE_CODE (stmt))
             {
             case IF_STMT:
               process_stmt (THEN_CLAUSE (stmt));
               /* More processing here.  */
               break;

             ...
             }

           stmt = TREE_CHAIN (stmt);
         }
     }
 In other words, while the 'then' clause of an 'if' statement in C++ can
be only one statement (although that one statement may be a compound
statement), the intermediate representation will sometimes use several
statements chained together.

'BREAK_STMT'

     Used to represent a 'break' statement.  There are no additional
     fields.

'CLEANUP_STMT'

     Used to represent an action that should take place upon exit from
     the enclosing scope.  Typically, these actions are calls to
     destructors for local objects, but back ends cannot rely on this
     fact.  If these nodes are in fact representing such destructors,
     'CLEANUP_DECL' will be the 'VAR_DECL' destroyed.  Otherwise,
     'CLEANUP_DECL' will be 'NULL_TREE'.  In any case, the
     'CLEANUP_EXPR' is the expression to execute.  The cleanups executed
     on exit from a scope should be run in the reverse order of the
     order in which the associated 'CLEANUP_STMT's were encountered.

'CONTINUE_STMT'

     Used to represent a 'continue' statement.  There are no additional
     fields.

'CTOR_STMT'

     Used to mark the beginning (if 'CTOR_BEGIN_P' holds) or end (if
     'CTOR_END_P' holds of the main body of a constructor.  See also
     'SUBOBJECT' for more information on how to use these nodes.

'DO_STMT'

     Used to represent a 'do' loop.  The body of the loop is given by
     'DO_BODY' while the termination condition for the loop is given by
     'DO_COND'.  The condition for a 'do'-statement is always an
     expression.

'EMPTY_CLASS_EXPR'

     Used to represent a temporary object of a class with no data whose
     address is never taken.  (All such objects are interchangeable.)
     The 'TREE_TYPE' represents the type of the object.

'EXPR_STMT'

     Used to represent an expression statement.  Use 'EXPR_STMT_EXPR' to
     obtain the expression.

'FOR_STMT'

     Used to represent a 'for' statement.  The 'FOR_INIT_STMT' is the
     initialization statement for the loop.  The 'FOR_COND' is the
     termination condition.  The 'FOR_EXPR' is the expression executed
     right before the 'FOR_COND' on each loop iteration; often, this
     expression increments a counter.  The body of the loop is given by
     'FOR_BODY'.  Note that 'FOR_INIT_STMT' and 'FOR_BODY' return
     statements, while 'FOR_COND' and 'FOR_EXPR' return expressions.

'HANDLER'

     Used to represent a C++ 'catch' block.  The 'HANDLER_TYPE' is the
     type of exception that will be caught by this handler; it is equal
     (by pointer equality) to 'NULL' if this handler is for all types.
     'HANDLER_PARMS' is the 'DECL_STMT' for the catch parameter, and
     'HANDLER_BODY' is the code for the block itself.

'IF_STMT'

     Used to represent an 'if' statement.  The 'IF_COND' is the
     expression.

     If the condition is a 'TREE_LIST', then the 'TREE_PURPOSE' is a
     statement (usually a 'DECL_STMT').  Each time the condition is
     evaluated, the statement should be executed.  Then, the
     'TREE_VALUE' should be used as the conditional expression itself.
     This representation is used to handle C++ code like this:

     C++ distinguishes between this and 'COND_EXPR' for handling
     templates.

          if (int i = 7) ...

     where there is a new local variable (or variables) declared within
     the condition.

     The 'THEN_CLAUSE' represents the statement given by the 'then'
     condition, while the 'ELSE_CLAUSE' represents the statement given
     by the 'else' condition.

'SUBOBJECT'

     In a constructor, these nodes are used to mark the point at which a
     subobject of 'this' is fully constructed.  If, after this point, an
     exception is thrown before a 'CTOR_STMT' with 'CTOR_END_P' set is
     encountered, the 'SUBOBJECT_CLEANUP' must be executed.  The
     cleanups must be executed in the reverse order in which they
     appear.

'SWITCH_STMT'

     Used to represent a 'switch' statement.  The 'SWITCH_STMT_COND' is
     the expression on which the switch is occurring.  See the
     documentation for an 'IF_STMT' for more information on the
     representation used for the condition.  The 'SWITCH_STMT_BODY' is
     the body of the switch statement.  The 'SWITCH_STMT_TYPE' is the
     original type of switch expression as given in the source, before
     any compiler conversions.

'TRY_BLOCK'
     Used to represent a 'try' block.  The body of the try block is
     given by 'TRY_STMTS'.  Each of the catch blocks is a 'HANDLER'
     node.  The first handler is given by 'TRY_HANDLERS'.  Subsequent
     handlers are obtained by following the 'TREE_CHAIN' link from one
     handler to the next.  The body of the handler is given by
     'HANDLER_BODY'.

     If 'CLEANUP_P' holds of the 'TRY_BLOCK', then the 'TRY_HANDLERS'
     will not be a 'HANDLER' node.  Instead, it will be an expression
     that should be executed if an exception is thrown in the try block.
     It must rethrow the exception after executing that code.  And, if
     an exception is thrown while the expression is executing,
     'terminate' must be called.

'USING_STMT'
     Used to represent a 'using' directive.  The namespace is given by
     'USING_STMT_NAMESPACE', which will be a NAMESPACE_DECL.  This node
     is needed inside template functions, to implement using directives
     during instantiation.

'WHILE_STMT'

     Used to represent a 'while' loop.  The 'WHILE_COND' is the
     termination condition for the loop.  See the documentation for an
     'IF_STMT' for more information on the representation used for the
     condition.

     The 'WHILE_BODY' is the body of the loop.

==============================================================================
File: gccint.info,  Node: |C++_Expressions|,  Prev: |Statements_for_C++|,  Up: |C_and_C++_Trees|
==============================================================================

                                                               *C++_Expressions*

11.10.6 C++ Expressions
-----------------------

This section describes expressions specific to the C and C++ front ends.

'TYPEID_EXPR'

     Used to represent a 'typeid' expression.

'NEW_EXPR'
'VEC_NEW_EXPR'

     Used to represent a call to 'new' and 'new[]' respectively.

'DELETE_EXPR'
'VEC_DELETE_EXPR'

     Used to represent a call to 'delete' and 'delete[]' respectively.

'MEMBER_REF'

     Represents a reference to a member of a class.

'THROW_EXPR'

     Represents an instance of 'throw' in the program.  Operand 0, which
     is the expression to throw, may be 'NULL_TREE'.

'AGGR_INIT_EXPR'
     An 'AGGR_INIT_EXPR' represents the initialization as the return
     value of a function call, or as the result of a constructor.  An
     'AGGR_INIT_EXPR' will only appear as a full-expression, or as the
     second operand of a 'TARGET_EXPR'.  'AGGR_INIT_EXPR's have a
     representation similar to that of 'CALL_EXPR's.  You can use the
     'AGGR_INIT_EXPR_FN' and 'AGGR_INIT_EXPR_ARG' macros to access the
     function to call and the arguments to pass.

     If 'AGGR_INIT_VIA_CTOR_P' holds of the 'AGGR_INIT_EXPR', then the
     initialization is via a constructor call.  The address of the
     'AGGR_INIT_EXPR_SLOT' operand, which is always a 'VAR_DECL', is
     taken, and this value replaces the first argument in the argument
     list.

     In either case, the expression is void.

==============================================================================
File: gccint.info,  Node: |GIMPLE|,  Next: |Tree_SSA|,  Prev: |GENERIC|,  Up: |Top|
==============================================================================

                                                                        *GIMPLE*

12 GIMPLE
*****====

GIMPLE is a three-address representation derived from GENERIC by
breaking down GENERIC expressions into tuples of no more than 3 operands
(with some exceptions like function calls).  GIMPLE was heavily
influenced by the SIMPLE IL used by the McCAT compiler project at McGill
University, though we have made some different choices.  For one thing,
SIMPLE doesn't support 'goto'.

 Temporaries are introduced to hold intermediate values needed to
compute complex expressions.  Additionally, all the control structures
used in GENERIC are lowered into conditional jumps, lexical scopes are
removed and exception regions are converted into an on the side
exception region tree.

 The compiler pass which converts GENERIC into GIMPLE is referred to as
the 'gimplifier'.  The gimplifier works recursively, generating GIMPLE
tuples out of the original GENERIC expressions.

 One of the early implementation strategies used for the GIMPLE
representation was to use the same internal data structures used by
front ends to represent parse trees.  This simplified implementation
because we could leverage existing functionality and interfaces.
However, GIMPLE is a much more restrictive representation than abstract
syntax trees (AST), therefore it does not require the full structural
complexity provided by the main tree data structure.

 The GENERIC representation of a function is stored in the
'DECL_SAVED_TREE' field of the associated 'FUNCTION_DECL' tree node.  It
is converted to GIMPLE by a call to 'gimplify_function_tree'.

 If a front end wants to include language-specific tree codes in the
tree representation which it provides to the back end, it must provide a
definition of 'LANG_HOOKS_GIMPLIFY_EXPR' which knows how to convert the
front end trees to GIMPLE.  Usually such a hook will involve much of the
same code for expanding front end trees to RTL.  This function can
return fully lowered GIMPLE, or it can return GENERIC trees and let the
main gimplifier lower them the rest of the way; this is often simpler.
GIMPLE that is not fully lowered is known as "High GIMPLE" and consists
of the IL before the pass 'pass_lower_cf'.  High GIMPLE contains some
container statements like lexical scopes (represented by 'GIMPLE_BIND')
and nested expressions (e.g., 'GIMPLE_TRY'), while "Low GIMPLE" exposes
all of the implicit jumps for control and exception expressions directly
in the IL and EH region trees.

 The C and C++ front ends currently convert directly from front end
trees to GIMPLE, and hand that off to the back end rather than first
converting to GENERIC.  Their gimplifier hooks know about all the
'_STMT' nodes and how to convert them to GENERIC forms.  There was some
work done on a genericization pass which would run first, but the
existence of 'STMT_EXPR' meant that in order to convert all of the C
statements into GENERIC equivalents would involve walking the entire
tree anyway, so it was simpler to lower all the way.  This might change
in the future if someone writes an optimization pass which would work
better with higher-level trees, but currently the optimizers all expect
GIMPLE.

 You can request to dump a C-like representation of the GIMPLE form with
the flag '-fdump-tree-gimple'.

MENU

* |Tuple_representation|::
* |Class_hierarchy_of_GIMPLE_statements|::
* |GIMPLE_instruction_set|::
* |GIMPLE_Exception_Handling|::
* |Temporaries|::
* |Operands|::
* |Manipulating_GIMPLE_statements|::
* |Tuple_specific_accessors|::
* |GIMPLE_sequences|::
* |Sequence_iterators|::
* |Adding_a_new_GIMPLE_statement_code|::
* |Statement_and_operand_traversals|::

==============================================================================
File: gccint.info,  Node: |Tuple_representation|,  Next: |Class_hierarchy_of_GIMPLE_statements|,  Up: |GIMPLE|
==============================================================================

                                                          *Tuple_representation*

12.1 Tuple representation
=====--------------------

GIMPLE instructions are tuples of variable size divided in two groups: a
header describing the instruction and its locations, and a variable
length body with all the operands.  Tuples are organized into a
hierarchy with 3 main classes of tuples.

12.1.1 'gimple' (gsbase)
------------------------

This is the root of the hierarchy, it holds basic information needed by
most GIMPLE statements.  There are some fields that may not be relevant
to every GIMPLE statement, but those were moved into the base structure
to take advantage of holes left by other fields (thus making the
structure more compact).  The structure takes 4 words (32 bytes) on 64
bit hosts:

Field                   Size (bits)
'code'                  8
'subcode'               16
'no_warning'            1
'visited'               1
'nontemporal_move'      1
'plf'                   2
'modified'              1
'has_volatile_ops'      1
'references_memory_p'   1
'uid'                   32
'location'              32
'num_ops'               32
'bb'                    64
'block'                 63
Total size              32 bytes

   * 'code' Main identifier for a GIMPLE instruction.

   * 'subcode' Used to distinguish different variants of the same basic
     instruction or provide flags applicable to a given code.  The
     'subcode' flags field has different uses depending on the code of
     the instruction, but mostly it distinguishes instructions of the
     same family.  The most prominent use of this field is in
     assignments, where subcode indicates the operation done on the RHS
     of the assignment.  For example, a = b + c is encoded as
     'GIMPLE_ASSIGN <PLUS_EXPR, a, b, c>'.

   * 'no_warning' Bitflag to indicate whether a warning has already been
     issued on this statement.

   * 'visited' General purpose "visited" marker.  Set and cleared by
     each pass when needed.

   * 'nontemporal_move' Bitflag used in assignments that represent
     non-temporal moves.  Although this bitflag is only used in
     assignments, it was moved into the base to take advantage of the
     bit holes left by the previous fields.

   * 'plf' Pass Local Flags.  This 2-bit mask can be used as general
     purpose markers by any pass.  Passes are responsible for clearing
     and setting these two flags accordingly.

   * 'modified' Bitflag to indicate whether the statement has been
     modified.  Used mainly by the operand scanner to determine when to
     re-scan a statement for operands.

   * 'has_volatile_ops' Bitflag to indicate whether this statement
     contains operands that have been marked volatile.

   * 'references_memory_p' Bitflag to indicate whether this statement
     contains memory references (i.e., its operands are either global
     variables, or pointer dereferences or anything that must reside in
     memory).

   * 'uid' This is an unsigned integer used by passes that want to
     assign IDs to every statement.  These IDs must be assigned and used
     by each pass.

   * 'location' This is a 'location_t' identifier to specify source code
     location for this statement.  It is inherited from the front end.

   * 'num_ops' Number of operands that this statement has.  This
     specifies the size of the operand vector embedded in the tuple.
     Only used in some tuples, but it is declared in the base tuple to
     take advantage of the 32-bit hole left by the previous fields.

   * 'bb' Basic block holding the instruction.

   * 'block' Lexical block holding this statement.  Also used for debug
     information generation.

12.1.2 'gimple_statement_with_ops'
----------------------------------

This tuple is actually split in two: 'gimple_statement_with_ops_base'
and 'gimple_statement_with_ops'.  This is needed to accommodate the way
the operand vector is allocated.  The operand vector is defined to be an
array of 1 element.  So, to allocate a dynamic number of operands, the
memory allocator ('gimple_alloc') simply allocates enough memory to hold
the structure itself plus 'N - 1' operands which run "off the end" of
the structure.  For example, to allocate space for a tuple with 3
operands, 'gimple_alloc' reserves 'sizeof (struct
gimple_statement_with_ops) + 2 * sizeof (tree)' bytes.

 On the other hand, several fields in this tuple need to be shared with
the 'gimple_statement_with_memory_ops' tuple.  So, these common fields
are placed in 'gimple_statement_with_ops_base' which is then inherited
from the other two tuples.

'gsbase'    256
'def_ops'   64
'use_ops'   64
'op'        'num_ops' * 64
Total       48 + 8 * 'num_ops' bytes
size

   * 'gsbase' Inherited from 'struct gimple'.

   * 'def_ops' Array of pointers into the operand array indicating all
     the slots that contain a variable written-to by the statement.
     This array is also used for immediate use chaining.  Note that it
     would be possible to not rely on this array, but the changes
     required to implement this are pretty invasive.

   * 'use_ops' Similar to 'def_ops' but for variables read by the
     statement.

   * 'op' Array of trees with 'num_ops' slots.

12.1.3 'gimple_statement_with_memory_ops'
-----------------------------------------

This tuple is essentially identical to 'gimple_statement_with_ops',
except that it contains 4 additional fields to hold vectors related
memory stores and loads.  Similar to the previous case, the structure is
split in two to accommodate for the operand vector
('gimple_statement_with_memory_ops_base' and
'gimple_statement_with_memory_ops').

Field        Size (bits)
'gsbase'     256
'def_ops'    64
'use_ops'    64
'vdef_ops'   64
'vuse_ops'   64
'stores'     64
'loads'      64
'op'         'num_ops' * 64
Total size   80 + 8 * 'num_ops' bytes

   * 'vdef_ops' Similar to 'def_ops' but for 'VDEF' operators.  There is
     one entry per memory symbol written by this statement.  This is
     used to maintain the memory SSA use-def and def-def chains.

   * 'vuse_ops' Similar to 'use_ops' but for 'VUSE' operators.  There is
     one entry per memory symbol loaded by this statement.  This is used
     to maintain the memory SSA use-def chains.

   * 'stores' Bitset with all the UIDs for the symbols written-to by the
     statement.  This is different than 'vdef_ops' in that all the
     affected symbols are mentioned in this set.  If memory partitioning
     is enabled, the 'vdef_ops' vector will refer to memory partitions.
     Furthermore, no SSA information is stored in this set.

   * 'loads' Similar to 'stores', but for memory loads.  (Note that
     there is some amount of redundancy here, it should be possible to
     reduce memory utilization further by removing these sets).

 All the other tuples are defined in terms of these three basic ones.
Each tuple will add some fields.

==============================================================================
File: gccint.info,  Node: |Class_hierarchy_of_GIMPLE_statements|,  Next: |GIMPLE_instruction_set|,  Prev: |Tuple_representation|,  Up: |GIMPLE|
==============================================================================

                                          *Class_hierarchy_of_GIMPLE_statements*

12.2 Class hierarchy of GIMPLE statements
=====------------------------------------

The following diagram shows the C++ inheritance hierarchy of statement
kinds, along with their relationships to 'GSS_' values (layouts) and
'GIMPLE_' values (codes):

        gimple
          |    layout: GSS_BASE
          |    used for 4 codes: GIMPLE_ERROR_MARK
          |                      GIMPLE_NOP
          |                      GIMPLE_OMP_SECTIONS_SWITCH
          |                      GIMPLE_PREDICT
          |
          + gimple_statement_with_ops_base
          |   |    (no GSS layout)
          |   |
          |   + gimple_statement_with_ops
          |   |   |    layout: GSS_WITH_OPS
          |   |   |
          |   |   + gcond
          |   |   |     code: GIMPLE_COND
          |   |   |
          |   |   + gdebug
          |   |   |     code: GIMPLE_DEBUG
          |   |   |
          |   |   + ggoto
          |   |   |     code: GIMPLE_GOTO
          |   |   |
          |   |   + glabel
          |   |   |     code: GIMPLE_LABEL
          |   |   |
          |   |   + gswitch
          |   |         code: GIMPLE_SWITCH
          |   |
          |   + gimple_statement_with_memory_ops_base
          |       |    layout: GSS_WITH_MEM_OPS_BASE
          |       |
          |       + gimple_statement_with_memory_ops
          |       |   |    layout: GSS_WITH_MEM_OPS
          |       |   |
          |       |   + gassign
          |       |   |    code GIMPLE_ASSIGN
          |       |   |
          |       |   + greturn
          |       |        code GIMPLE_RETURN
          |       |
          |       + gcall
          |       |        layout: GSS_CALL, code: GIMPLE_CALL
          |       |
          |       + gasm
          |       |        layout: GSS_ASM, code: GIMPLE_ASM
          |       |
          |       + gtransaction
          |                layout: GSS_TRANSACTION, code: GIMPLE_TRANSACTION
          |
          + gimple_statement_omp
          |   |    layout: GSS_OMP.  Used for code GIMPLE_OMP_SECTION
          |   |
          |   + gomp_critical
          |   |        layout: GSS_OMP_CRITICAL, code: GIMPLE_OMP_CRITICAL
          |   |
          |   + gomp_for
          |   |        layout: GSS_OMP_FOR, code: GIMPLE_OMP_FOR
          |   |
          |   + gomp_parallel_layout
          |   |   |    layout: GSS_OMP_PARALLEL_LAYOUT
          |   |   |
          |   |   + gimple_statement_omp_taskreg
          |   |   |   |
          |   |   |   + gomp_parallel
          |   |   |   |        code: GIMPLE_OMP_PARALLEL
          |   |   |   |
          |   |   |   + gomp_task
          |   |   |            code: GIMPLE_OMP_TASK
          |   |   |
          |   |   + gimple_statement_omp_target
          |   |            code: GIMPLE_OMP_TARGET
          |   |
          |   + gomp_sections
          |   |        layout: GSS_OMP_SECTIONS, code: GIMPLE_OMP_SECTIONS
          |   |
          |   + gimple_statement_omp_single_layout
          |       |    layout: GSS_OMP_SINGLE_LAYOUT
          |       |
          |       + gomp_single
          |       |        code: GIMPLE_OMP_SINGLE
          |       |
          |       + gomp_teams
          |                code: GIMPLE_OMP_TEAMS
          |
          + gbind
          |        layout: GSS_BIND, code: GIMPLE_BIND
          |
          + gcatch
          |        layout: GSS_CATCH, code: GIMPLE_CATCH
          |
          + geh_filter
          |        layout: GSS_EH_FILTER, code: GIMPLE_EH_FILTER
          |
          + geh_else
          |        layout: GSS_EH_ELSE, code: GIMPLE_EH_ELSE
          |
          + geh_mnt
          |        layout: GSS_EH_MNT, code: GIMPLE_EH_MUST_NOT_THROW
          |
          + gphi
          |        layout: GSS_PHI, code: GIMPLE_PHI
          |
          + gimple_statement_eh_ctrl
          |   |    layout: GSS_EH_CTRL
          |   |
          |   + gresx
          |   |        code: GIMPLE_RESX
          |   |
          |   + geh_dispatch
          |            code: GIMPLE_EH_DISPATCH
          |
          + gtry
          |        layout: GSS_TRY, code: GIMPLE_TRY
          |
          + gimple_statement_wce
          |        layout: GSS_WCE, code: GIMPLE_WITH_CLEANUP_EXPR
          |
          + gomp_continue
          |        layout: GSS_OMP_CONTINUE, code: GIMPLE_OMP_CONTINUE
          |
          + gomp_atomic_load
          |        layout: GSS_OMP_ATOMIC_LOAD, code: GIMPLE_OMP_ATOMIC_LOAD
          |
          + gimple_statement_omp_atomic_store_layout
              |    layout: GSS_OMP_ATOMIC_STORE_LAYOUT,
              |    code: GIMPLE_OMP_ATOMIC_STORE
              |
              + gomp_atomic_store
              |        code: GIMPLE_OMP_ATOMIC_STORE
              |
              + gomp_return
                       code: GIMPLE_OMP_RETURN

==============================================================================
File: gccint.info,  Node: |GIMPLE_instruction_set|,  Next: |GIMPLE_Exception_Handling|,  Prev: |Class_hierarchy_of_GIMPLE_statements|,  Up: |GIMPLE|
==============================================================================

                                                        *GIMPLE_instruction_set*

12.3 GIMPLE instruction set
=====----------------------

The following table briefly describes the GIMPLE instruction set.

Instruction                    High GIMPLE   Low GIMPLE
'GIMPLE_ASM'                   x             x
'GIMPLE_ASSIGN'                x             x
'GIMPLE_BIND'                  x
'GIMPLE_CALL'                  x             x
'GIMPLE_CATCH'                 x
'GIMPLE_COND'                  x             x
'GIMPLE_DEBUG'                 x             x
'GIMPLE_EH_FILTER'             x
'GIMPLE_GOTO'                  x             x
'GIMPLE_LABEL'                 x             x
'GIMPLE_NOP'                   x             x
'GIMPLE_OMP_ATOMIC_LOAD'       x             x
'GIMPLE_OMP_ATOMIC_STORE'      x             x
'GIMPLE_OMP_CONTINUE'          x             x
'GIMPLE_OMP_CRITICAL'          x             x
'GIMPLE_OMP_FOR'               x             x
'GIMPLE_OMP_MASTER'            x             x
'GIMPLE_OMP_ORDERED'           x             x
'GIMPLE_OMP_PARALLEL'          x             x
'GIMPLE_OMP_RETURN'            x             x
'GIMPLE_OMP_SECTION'           x             x
'GIMPLE_OMP_SECTIONS'          x             x
'GIMPLE_OMP_SECTIONS_SWITCH'   x             x
'GIMPLE_OMP_SINGLE'            x             x
'GIMPLE_PHI'                                 x
'GIMPLE_RESX'                                x
'GIMPLE_RETURN'                x             x
'GIMPLE_SWITCH'                x             x
'GIMPLE_TRY'                   x

==============================================================================
File: gccint.info,  Node: |GIMPLE_Exception_Handling|,  Next: |Temporaries|,  Prev: |GIMPLE_instruction_set|,  Up: |GIMPLE|
==============================================================================

                                                     *GIMPLE_Exception_Handling*

12.4 Exception Handling
=====------------------

Other exception handling constructs are represented using
'GIMPLE_TRY_CATCH'.  'GIMPLE_TRY_CATCH' has two operands.  The first
operand is a sequence of statements to execute.  If executing these
statements does not throw an exception, then the second operand is
ignored.  Otherwise, if an exception is thrown, then the second operand
of the 'GIMPLE_TRY_CATCH' is checked.  The second operand may have the
following forms:

  1. A sequence of statements to execute.  When an exception occurs,
     these statements are executed, and then the exception is rethrown.

  2. A sequence of 'GIMPLE_CATCH' statements.  Each 'GIMPLE_CATCH' has a
     list of applicable exception types and handler code.  If the thrown
     exception matches one of the caught types, the associated handler
     code is executed.  If the handler code falls off the bottom,
     execution continues after the original 'GIMPLE_TRY_CATCH'.

  3. A 'GIMPLE_EH_FILTER' statement.  This has a list of permitted
     exception types, and code to handle a match failure.  If the thrown
     exception does not match one of the allowed types, the associated
     match failure code is executed.  If the thrown exception does
     match, it continues unwinding the stack looking for the next
     handler.

 Currently throwing an exception is not directly represented in GIMPLE,
since it is implemented by calling a function.  At some point in the
future we will want to add some way to express that the call will throw
an exception of a known type.

 Just before running the optimizers, the compiler lowers the high-level
EH constructs above into a set of 'goto's, magic labels, and EH regions.
Continuing to unwind at the end of a cleanup is represented with a
'GIMPLE_RESX'.

==============================================================================
File: gccint.info,  Node: |Temporaries|,  Next: |Operands|,  Prev: |GIMPLE_Exception_Handling|,  Up: |GIMPLE|
==============================================================================

                                                                   *Temporaries*

12.5 Temporaries
=====-----------

When gimplification encounters a subexpression that is too complex, it
creates a new temporary variable to hold the value of the subexpression,
and adds a new statement to initialize it before the current statement.
These special temporaries are known as 'expression temporaries', and are
allocated using 'get_formal_tmp_var'.  The compiler tries to always
evaluate identical expressions into the same temporary, to simplify
elimination of redundant calculations.

 We can only use expression temporaries when we know that it will not be
reevaluated before its value is used, and that it will not be otherwise
modified(1).  Other temporaries can be allocated using
'get_initialized_tmp_var' or 'create_tmp_var'.

 Currently, an expression like 'a = b + 5' is not reduced any further.
We tried converting it to something like
     T1 = b + 5;
     a = T1;
 but this bloated the representation for minimal benefit.  However, a
variable which must live in memory cannot appear in an expression; its
value is explicitly loaded into a temporary first.  Similarly, storing
the value of an expression to a memory variable goes through a
temporary.

   ---------- Footnotes ----------

   (1) These restrictions are derived from those in Morgan 4.8.

==============================================================================
File: gccint.info,  Node: |Operands|,  Next: |Manipulating_GIMPLE_statements|,  Prev: |Temporaries|,  Up: |GIMPLE|
==============================================================================

                                                                      *Operands*

12.6 Operands
=====--------

In general, expressions in GIMPLE consist of an operation and the
appropriate number of simple operands; these operands must either be a
GIMPLE rvalue ('is_gimple_val'), i.e. a constant or a register variable.
More complex operands are factored out into temporaries, so that
     a = b + c + d
 becomes
     T1 = b + c;
     a = T1 + d;

 The same rule holds for arguments to a 'GIMPLE_CALL'.

 The target of an assignment is usually a variable, but can also be a
'MEM_REF' or a compound lvalue as described below.

MENU

* |Compound_Expressions|::
* |Compound_Lvalues|::
* |Conditional_Expressions|::
* |Logical_Operators|::

==============================================================================
File: gccint.info,  Node: |Compound_Expressions|,  Next: |Compound_Lvalues|,  Up: |Operands|
==============================================================================

                                                          *Compound_Expressions*

12.6.1 Compound Expressions
---------------------------

The left-hand side of a C comma expression is simply moved into a
separate statement.

==============================================================================
File: gccint.info,  Node: |Compound_Lvalues|,  Next: |Conditional_Expressions|,  Prev: |Compound_Expressions|,  Up: |Operands|
==============================================================================

                                                              *Compound_Lvalues*

12.6.2 Compound Lvalues
-----------------------

Currently compound lvalues involving array and structure field
references are not broken down; an expression like 'a.b[2] = 42' is not
reduced any further (though complex array subscripts are).  This
restriction is a workaround for limitations in later optimizers; if we
were to convert this to

     T1 = &a.b;
     T1[2] = 42;

 alias analysis would not remember that the reference to 'T1[2]' came by
way of 'a.b', so it would think that the assignment could alias another
member of 'a'; this broke 'struct-alias-1.c'.  Future optimizer
improvements may make this limitation unnecessary.

==============================================================================
File: gccint.info,  Node: |Conditional_Expressions|,  Next: |Logical_Operators|,  Prev: |Compound_Lvalues|,  Up: |Operands|
==============================================================================

                                                       *Conditional_Expressions*

12.6.3 Conditional Expressions
------------------------------

A C '?:' expression is converted into an 'if' statement with each branch
assigning to the same temporary.  So,

     a = b ? c : d;
 becomes
     if (b == 1)
       T1 = c;
     else
       T1 = d;
     a = T1;

 The GIMPLE level if-conversion pass re-introduces '?:' expression, if
appropriate.  It is used to vectorize loops with conditions using vector
conditional operations.

 Note that in GIMPLE, 'if' statements are represented using
'GIMPLE_COND', as described below.

==============================================================================
File: gccint.info,  Node: |Logical_Operators|,  Prev: |Conditional_Expressions|,  Up: |Operands|
==============================================================================

                                                             *Logical_Operators*

12.6.4 Logical Operators
------------------------

Except when they appear in the condition operand of a 'GIMPLE_COND',
logical 'and' and 'or' operators are simplified as follows: 'a = b && c'
becomes

     T1 = (bool)b;
     if (T1 == true)
       T1 = (bool)c;
     a = T1;

 Note that 'T1' in this example cannot be an expression temporary,
because it has two different assignments.

12.6.5 Manipulating operands
----------------------------

All gimple operands are of type 'tree'.  But only certain types of trees
are allowed to be used as operand tuples.  Basic validation is
controlled by the function 'get_gimple_rhs_class', which given a tree
code, returns an 'enum' with the following values of type 'enum
gimple_rhs_class'

   * 'GIMPLE_INVALID_RHS' The tree cannot be used as a GIMPLE operand.

   * 'GIMPLE_TERNARY_RHS' The tree is a valid GIMPLE ternary operation.

   * 'GIMPLE_BINARY_RHS' The tree is a valid GIMPLE binary operation.

   * 'GIMPLE_UNARY_RHS' The tree is a valid GIMPLE unary operation.

   * 'GIMPLE_SINGLE_RHS' The tree is a single object, that cannot be
     split into simpler operands (for instance, 'SSA_NAME', 'VAR_DECL',
     'COMPONENT_REF', etc).

     This operand class also acts as an escape hatch for tree nodes that
     may be flattened out into the operand vector, but would need more
     than two slots on the RHS. For instance, a 'COND_EXPR' expression
     of the form '(a op b) ? x : y' could be flattened out on the
     operand vector using 4 slots, but it would also require additional
     processing to distinguish 'c = a op b' from 'c = a op b ? x : y'.
     Something similar occurs with 'ASSERT_EXPR'.  In time, these
     special case tree expressions should be flattened into the operand
     vector.

 For tree nodes in the categories 'GIMPLE_TERNARY_RHS',
'GIMPLE_BINARY_RHS' and 'GIMPLE_UNARY_RHS', they cannot be stored inside
tuples directly.  They first need to be flattened and separated into
individual components.  For instance, given the GENERIC expression

     a = b + c

 its tree representation is:

     MODIFY_EXPR <VAR_DECL  <a>, PLUS_EXPR <VAR_DECL <b>, VAR_DECL <c>>>

 In this case, the GIMPLE form for this statement is logically identical
to its GENERIC form but in GIMPLE, the 'PLUS_EXPR' on the RHS of the
assignment is not represented as a tree, instead the two operands are
taken out of the 'PLUS_EXPR' sub-tree and flattened into the GIMPLE
tuple as follows:

     GIMPLE_ASSIGN <PLUS_EXPR, VAR_DECL <a>, VAR_DECL <b>, VAR_DECL <c>>

12.6.6 Operand vector allocation
--------------------------------

The operand vector is stored at the bottom of the three tuple structures
that accept operands.  This means, that depending on the code of a given
statement, its operand vector will be at different offsets from the base
of the structure.  To access tuple operands use the following accessors

 -- GIMPLE function: unsigned gimple_num_ops (gimple g)
     Returns the number of operands in statement G.

 -- GIMPLE function: tree gimple_op (gimple g, unsigned i)
     Returns operand 'I' from statement 'G'.

 -- GIMPLE function: tree * gimple_ops (gimple g)
     Returns a pointer into the operand vector for statement 'G'.  This
     is computed using an internal table called 'gimple_ops_offset_'[].
     This table is indexed by the gimple code of 'G'.

     When the compiler is built, this table is filled-in using the sizes
     of the structures used by each statement code defined in
     gimple.def.  Since the operand vector is at the bottom of the
     structure, for a gimple code 'C' the offset is computed as sizeof
     (struct-of 'C') - sizeof (tree).

     This mechanism adds one memory indirection to every access when
     using 'gimple_op'(), if this becomes a bottleneck, a pass can
     choose to memoize the result from 'gimple_ops'() and use that to
     access the operands.

12.6.7 Operand validation
-------------------------

When adding a new operand to a gimple statement, the operand will be
validated according to what each tuple accepts in its operand vector.
These predicates are called by the 'gimple_NAME_set_...()'.  Each tuple
will use one of the following predicates (Note, this list is not
exhaustive):

 -- GIMPLE function: bool is_gimple_val (tree t)
     Returns true if t is a "GIMPLE value", which are all the
     non-addressable stack variables (variables for which
     'is_gimple_reg' returns true) and constants (expressions for which
     'is_gimple_min_invariant' returns true).

 -- GIMPLE function: bool is_gimple_addressable (tree t)
     Returns true if t is a symbol or memory reference whose address can
     be taken.

 -- GIMPLE function: bool is_gimple_asm_val (tree t)
     Similar to 'is_gimple_val' but it also accepts hard registers.

 -- GIMPLE function: bool is_gimple_call_addr (tree t)
     Return true if t is a valid expression to use as the function
     called by a 'GIMPLE_CALL'.

 -- GIMPLE function: bool is_gimple_mem_ref_addr (tree t)
     Return true if t is a valid expression to use as first operand of a
     'MEM_REF' expression.

 -- GIMPLE function: bool is_gimple_constant (tree t)
     Return true if t is a valid gimple constant.

 -- GIMPLE function: bool is_gimple_min_invariant (tree t)
     Return true if t is a valid minimal invariant.  This is different
     from constants, in that the specific value of t may not be known at
     compile time, but it is known that it doesn't change (e.g., the
     address of a function local variable).

 -- GIMPLE function: bool is_gimple_ip_invariant (tree t)
     Return true if t is an interprocedural invariant.  This means that
     t is a valid invariant in all functions (e.g. it can be an address
     of a global variable but not of a local one).

 -- GIMPLE function: bool is_gimple_ip_invariant_address (tree t)
     Return true if t is an 'ADDR_EXPR' that does not change once the
     program is running (and which is valid in all functions).

12.6.8 Statement validation
---------------------------

 -- GIMPLE function: bool is_gimple_assign (gimple g)
     Return true if the code of g is 'GIMPLE_ASSIGN'.

 -- GIMPLE function: bool is_gimple_call (gimple g)
     Return true if the code of g is 'GIMPLE_CALL'.

 -- GIMPLE function: bool is_gimple_debug (gimple g)
     Return true if the code of g is 'GIMPLE_DEBUG'.

 -- GIMPLE function: bool gimple_assign_cast_p (const_gimple g)
     Return true if g is a 'GIMPLE_ASSIGN' that performs a type cast
     operation.

 -- GIMPLE function: bool gimple_debug_bind_p (gimple g)
     Return true if g is a 'GIMPLE_DEBUG' that binds the value of an
     expression to a variable.

 -- GIMPLE function: bool is_gimple_omp (gimple g)
     Return true if g is any of the OpenMP codes.

 -- GIMPLE function: gimple_debug_begin_stmt_p (gimple g)
     Return true if g is a 'GIMPLE_DEBUG' that marks the beginning of a
     source statement.

 -- GIMPLE function: gimple_debug_inline_entry_p (gimple g)
     Return true if g is a 'GIMPLE_DEBUG' that marks the entry point of
     an inlined function.

 -- GIMPLE function: gimple_debug_nonbind_marker_p (gimple g)
     Return true if g is a 'GIMPLE_DEBUG' that marks a program location,
     without any variable binding.

==============================================================================
File: gccint.info,  Node: |Manipulating_GIMPLE_statements|,  Next: |Tuple_specific_accessors|,  Prev: |Operands|,  Up: |GIMPLE|
==============================================================================

                                                *Manipulating_GIMPLE_statements*

12.7 Manipulating GIMPLE statements
=====------------------------------

This section documents all the functions available to handle each of the
GIMPLE instructions.

12.7.1 Common accessors
-----------------------

The following are common accessors for gimple statements.

 -- GIMPLE function: enum gimple_code gimple_code (gimple g)
     Return the code for statement 'G'.

 -- GIMPLE function: basic_block gimple_bb (gimple g)
     Return the basic block to which statement 'G' belongs to.

 -- GIMPLE function: tree gimple_block (gimple g)
     Return the lexical scope block holding statement 'G'.

 -- GIMPLE function: tree gimple_expr_type (gimple stmt)
     Return the type of the main expression computed by 'STMT'.  Return
     'void_type_node' if 'STMT' computes nothing.  This will only return
     something meaningful for 'GIMPLE_ASSIGN', 'GIMPLE_COND' and
     'GIMPLE_CALL'.  For all other tuple codes, it will return
     'void_type_node'.

 -- GIMPLE function: enum tree_code gimple_expr_code (gimple stmt)
     Return the tree code for the expression computed by 'STMT'.  This
     is only meaningful for 'GIMPLE_CALL', 'GIMPLE_ASSIGN' and
     'GIMPLE_COND'.  If 'STMT' is 'GIMPLE_CALL', it will return
     'CALL_EXPR'.  For 'GIMPLE_COND', it returns the code of the
     comparison predicate.  For 'GIMPLE_ASSIGN' it returns the code of
     the operation performed by the 'RHS' of the assignment.

 -- GIMPLE function: void gimple_set_block (gimple g, tree block)
     Set the lexical scope block of 'G' to 'BLOCK'.

 -- GIMPLE function: location_t gimple_locus (gimple g)
     Return locus information for statement 'G'.

 -- GIMPLE function: void gimple_set_locus (gimple g, location_t locus)
     Set locus information for statement 'G'.

 -- GIMPLE function: bool gimple_locus_empty_p (gimple g)
     Return true if 'G' does not have locus information.

 -- GIMPLE function: bool gimple_no_warning_p (gimple stmt)
     Return true if no warnings should be emitted for statement 'STMT'.

 -- GIMPLE function: void gimple_set_visited (gimple stmt, bool
          visited_p)
     Set the visited status on statement 'STMT' to 'VISITED_P'.

 -- GIMPLE function: bool gimple_visited_p (gimple stmt)
     Return the visited status on statement 'STMT'.

 -- GIMPLE function: void gimple_set_plf (gimple stmt, enum plf_mask
          plf, bool val_p)
     Set pass local flag 'PLF' on statement 'STMT' to 'VAL_P'.

 -- GIMPLE function: unsigned int gimple_plf (gimple stmt, enum plf_mask
          plf)
     Return the value of pass local flag 'PLF' on statement 'STMT'.

 -- GIMPLE function: bool gimple_has_ops (gimple g)
     Return true if statement 'G' has register or memory operands.

 -- GIMPLE function: bool gimple_has_mem_ops (gimple g)
     Return true if statement 'G' has memory operands.

 -- GIMPLE function: unsigned gimple_num_ops (gimple g)
     Return the number of operands for statement 'G'.

 -- GIMPLE function: tree * gimple_ops (gimple g)
     Return the array of operands for statement 'G'.

 -- GIMPLE function: tree gimple_op (gimple g, unsigned i)
     Return operand 'I' for statement 'G'.

 -- GIMPLE function: tree * gimple_op_ptr (gimple g, unsigned i)
     Return a pointer to operand 'I' for statement 'G'.

 -- GIMPLE function: void gimple_set_op (gimple g, unsigned i, tree op)
     Set operand 'I' of statement 'G' to 'OP'.

 -- GIMPLE function: bitmap gimple_addresses_taken (gimple stmt)
     Return the set of symbols that have had their address taken by
     'STMT'.

 -- GIMPLE function: struct def_optype_d * gimple_def_ops (gimple g)
     Return the set of 'DEF' operands for statement 'G'.

 -- GIMPLE function: void gimple_set_def_ops (gimple g, struct
          def_optype_d *def)
     Set 'DEF' to be the set of 'DEF' operands for statement 'G'.

 -- GIMPLE function: struct use_optype_d * gimple_use_ops (gimple g)
     Return the set of 'USE' operands for statement 'G'.

 -- GIMPLE function: void gimple_set_use_ops (gimple g, struct
          use_optype_d *use)
     Set 'USE' to be the set of 'USE' operands for statement 'G'.

 -- GIMPLE function: struct voptype_d * gimple_vuse_ops (gimple g)
     Return the set of 'VUSE' operands for statement 'G'.

 -- GIMPLE function: void gimple_set_vuse_ops (gimple g, struct
          voptype_d *ops)
     Set 'OPS' to be the set of 'VUSE' operands for statement 'G'.

 -- GIMPLE function: struct voptype_d * gimple_vdef_ops (gimple g)
     Return the set of 'VDEF' operands for statement 'G'.

 -- GIMPLE function: void gimple_set_vdef_ops (gimple g, struct
          voptype_d *ops)
     Set 'OPS' to be the set of 'VDEF' operands for statement 'G'.

 -- GIMPLE function: bitmap gimple_loaded_syms (gimple g)
     Return the set of symbols loaded by statement 'G'.  Each element of
     the set is the 'DECL_UID' of the corresponding symbol.

 -- GIMPLE function: bitmap gimple_stored_syms (gimple g)
     Return the set of symbols stored by statement 'G'.  Each element of
     the set is the 'DECL_UID' of the corresponding symbol.

 -- GIMPLE function: bool gimple_modified_p (gimple g)
     Return true if statement 'G' has operands and the modified field
     has been set.

 -- GIMPLE function: bool gimple_has_volatile_ops (gimple stmt)
     Return true if statement 'STMT' contains volatile operands.

 -- GIMPLE function: void gimple_set_has_volatile_ops (gimple stmt, bool
          volatilep)
     Return true if statement 'STMT' contains volatile operands.

 -- GIMPLE function: void update_stmt (gimple s)
     Mark statement 'S' as modified, and update it.

 -- GIMPLE function: void update_stmt_if_modified (gimple s)
     Update statement 'S' if it has been marked modified.

 -- GIMPLE function: gimple gimple_copy (gimple stmt)
     Return a deep copy of statement 'STMT'.

==============================================================================
File: gccint.info,  Node: |Tuple_specific_accessors|,  Next: |GIMPLE_sequences|,  Prev: |Manipulating_GIMPLE_statements|,  Up: |GIMPLE|
==============================================================================

                                                      *Tuple_specific_accessors*

12.8 Tuple specific accessors
=====------------------------

MENU

* |GIMPLE_ASM|::
* |GIMPLE_ASSIGN|::
* |GIMPLE_BIND|::
* |GIMPLE_CALL|::
* |GIMPLE_CATCH|::
* |GIMPLE_COND|::
* |GIMPLE_DEBUG|::
* |GIMPLE_EH_FILTER|::
* |GIMPLE_LABEL|::
* |GIMPLE_GOTO|::
* |GIMPLE_NOP|::
* |GIMPLE_OMP_ATOMIC_LOAD|::
* |GIMPLE_OMP_ATOMIC_STORE|::
* |GIMPLE_OMP_CONTINUE|::
* |GIMPLE_OMP_CRITICAL|::
* |GIMPLE_OMP_FOR|::
* |GIMPLE_OMP_MASTER|::
* |GIMPLE_OMP_ORDERED|::
* |GIMPLE_OMP_PARALLEL|::
* |GIMPLE_OMP_RETURN|::
* |GIMPLE_OMP_SECTION|::
* |GIMPLE_OMP_SECTIONS|::
* |GIMPLE_OMP_SINGLE|::
* |GIMPLE_PHI|::
* |GIMPLE_RESX|::
* |GIMPLE_RETURN|::
* |GIMPLE_SWITCH|::
* |GIMPLE_TRY|::
* |GIMPLE_WITH_CLEANUP_EXPR|::

==============================================================================
File: gccint.info,  Node: |GIMPLE_ASM|,  Next: |GIMPLE_ASSIGN|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                    *GIMPLE_ASM*

12.8.1 'GIMPLE_ASM'
-------------------

 -- GIMPLE function: gasm *gimple_build_asm_vec ( const char *string,
          vec<tree, va_gc> *inputs, vec<tree, va_gc> *outputs, vec<tree,
          va_gc> *clobbers, vec<tree, va_gc> *labels)
     Build a 'GIMPLE_ASM' statement.  This statement is used for
     building in-line assembly constructs.  'STRING' is the assembly
     code.  'INPUTS', 'OUTPUTS', 'CLOBBERS' and 'LABELS' are the inputs,
     outputs, clobbered registers and labels.

 -- GIMPLE function: unsigned gimple_asm_ninputs (const gasm *g)
     Return the number of input operands for 'GIMPLE_ASM' 'G'.

 -- GIMPLE function: unsigned gimple_asm_noutputs (const gasm *g)
     Return the number of output operands for 'GIMPLE_ASM' 'G'.

 -- GIMPLE function: unsigned gimple_asm_nclobbers (const gasm *g)
     Return the number of clobber operands for 'GIMPLE_ASM' 'G'.

 -- GIMPLE function: tree gimple_asm_input_op (const gasm *g, unsigned
          index)
     Return input operand 'INDEX' of 'GIMPLE_ASM' 'G'.

 -- GIMPLE function: void gimple_asm_set_input_op (gasm *g, unsigned
          index, tree in_op)
     Set 'IN_OP' to be input operand 'INDEX' in 'GIMPLE_ASM' 'G'.

 -- GIMPLE function: tree gimple_asm_output_op (const gasm *g, unsigned
          index)
     Return output operand 'INDEX' of 'GIMPLE_ASM' 'G'.

 -- GIMPLE function: void gimple_asm_set_output_op (gasm *g, unsigned
          index, tree out_op)
     Set 'OUT_OP' to be output operand 'INDEX' in 'GIMPLE_ASM' 'G'.

 -- GIMPLE function: tree gimple_asm_clobber_op (const gasm *g, unsigned
          index)
     Return clobber operand 'INDEX' of 'GIMPLE_ASM' 'G'.

 -- GIMPLE function: void gimple_asm_set_clobber_op (gasm *g, unsigned
          index, tree clobber_op)
     Set 'CLOBBER_OP' to be clobber operand 'INDEX' in 'GIMPLE_ASM' 'G'.

 -- GIMPLE function: const char * gimple_asm_string (const gasm *g)
     Return the string representing the assembly instruction in
     'GIMPLE_ASM' 'G'.

 -- GIMPLE function: bool gimple_asm_volatile_p (const gasm *g)
     Return true if 'G' is an asm statement marked volatile.

 -- GIMPLE function: void gimple_asm_set_volatile (gasm *g, bool
          volatile_p)
     Mark asm statement 'G' as volatile or non-volatile based on
     'VOLATILE_P'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_ASSIGN|,  Next: |GIMPLE_BIND|,  Prev: |GIMPLE_ASM|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                 *GIMPLE_ASSIGN*

12.8.2 'GIMPLE_ASSIGN'
----------------------

 -- GIMPLE function: gassign *gimple_build_assign (tree lhs, tree rhs)
     Build a 'GIMPLE_ASSIGN' statement.  The left-hand side is an lvalue
     passed in lhs.  The right-hand side can be either a unary or binary
     tree expression.  The expression tree rhs will be flattened and its
     operands assigned to the corresponding operand slots in the new
     statement.  This function is useful when you already have a tree
     expression that you want to convert into a tuple.  However, try to
     avoid building expression trees for the sole purpose of calling
     this function.  If you already have the operands in separate trees,
     it is better to use 'gimple_build_assign' with 'enum tree_code'
     argument and separate arguments for each operand.

 -- GIMPLE function: gassign *gimple_build_assign (tree lhs, enum
          tree_code subcode, tree op1, tree op2, tree op3)
     This function is similar to two operand 'gimple_build_assign', but
     is used to build a 'GIMPLE_ASSIGN' statement when the operands of
     the right-hand side of the assignment are already split into
     different operands.

     The left-hand side is an lvalue passed in lhs.  Subcode is the
     'tree_code' for the right-hand side of the assignment.  Op1, op2
     and op3 are the operands.

 -- GIMPLE function: gassign *gimple_build_assign (tree lhs, enum
          tree_code subcode, tree op1, tree op2)
     Like the above 5 operand 'gimple_build_assign', but with the last
     argument 'NULL' - this overload should not be used for
     'GIMPLE_TERNARY_RHS' assignments.

 -- GIMPLE function: gassign *gimple_build_assign (tree lhs, enum
          tree_code subcode, tree op1)
     Like the above 4 operand 'gimple_build_assign', but with the last
     argument 'NULL' - this overload should be used only for
     'GIMPLE_UNARY_RHS' and 'GIMPLE_SINGLE_RHS' assignments.

 -- GIMPLE function: gimple gimplify_assign (tree dst, tree src,
          gimple_seq *seq_p)
     Build a new 'GIMPLE_ASSIGN' tuple and append it to the end of
     '*SEQ_P'.

 'DST'/'SRC' are the destination and source respectively.  You can pass
ungimplified trees in 'DST' or 'SRC', in which case they will be
converted to a gimple operand if necessary.

 This function returns the newly created 'GIMPLE_ASSIGN' tuple.

 -- GIMPLE function: enum tree_code gimple_assign_rhs_code (gimple g)
     Return the code of the expression computed on the 'RHS' of
     assignment statement 'G'.

 -- GIMPLE function: enum gimple_rhs_class gimple_assign_rhs_class
          (gimple g)
     Return the gimple rhs class of the code for the expression computed
     on the rhs of assignment statement 'G'.  This will never return
     'GIMPLE_INVALID_RHS'.

 -- GIMPLE function: tree gimple_assign_lhs (gimple g)
     Return the 'LHS' of assignment statement 'G'.

 -- GIMPLE function: tree * gimple_assign_lhs_ptr (gimple g)
     Return a pointer to the 'LHS' of assignment statement 'G'.

 -- GIMPLE function: tree gimple_assign_rhs1 (gimple g)
     Return the first operand on the 'RHS' of assignment statement 'G'.

 -- GIMPLE function: tree * gimple_assign_rhs1_ptr (gimple g)
     Return the address of the first operand on the 'RHS' of assignment
     statement 'G'.

 -- GIMPLE function: tree gimple_assign_rhs2 (gimple g)
     Return the second operand on the 'RHS' of assignment statement 'G'.

 -- GIMPLE function: tree * gimple_assign_rhs2_ptr (gimple g)
     Return the address of the second operand on the 'RHS' of assignment
     statement 'G'.

 -- GIMPLE function: tree gimple_assign_rhs3 (gimple g)
     Return the third operand on the 'RHS' of assignment statement 'G'.

 -- GIMPLE function: tree * gimple_assign_rhs3_ptr (gimple g)
     Return the address of the third operand on the 'RHS' of assignment
     statement 'G'.

 -- GIMPLE function: void gimple_assign_set_lhs (gimple g, tree lhs)
     Set 'LHS' to be the 'LHS' operand of assignment statement 'G'.

 -- GIMPLE function: void gimple_assign_set_rhs1 (gimple g, tree rhs)
     Set 'RHS' to be the first operand on the 'RHS' of assignment
     statement 'G'.

 -- GIMPLE function: void gimple_assign_set_rhs2 (gimple g, tree rhs)
     Set 'RHS' to be the second operand on the 'RHS' of assignment
     statement 'G'.

 -- GIMPLE function: void gimple_assign_set_rhs3 (gimple g, tree rhs)
     Set 'RHS' to be the third operand on the 'RHS' of assignment
     statement 'G'.

 -- GIMPLE function: bool gimple_assign_cast_p (const_gimple s)
     Return true if 'S' is a type-cast assignment.

==============================================================================
File: gccint.info,  Node: |GIMPLE_BIND|,  Next: |GIMPLE_CALL|,  Prev: |GIMPLE_ASSIGN|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                   *GIMPLE_BIND*

12.8.3 'GIMPLE_BIND'
--------------------

 -- GIMPLE function: gbind *gimple_build_bind (tree vars, gimple_seq
          body)
     Build a 'GIMPLE_BIND' statement with a list of variables in 'VARS'
     and a body of statements in sequence 'BODY'.

 -- GIMPLE function: tree gimple_bind_vars (const gbind *g)
     Return the variables declared in the 'GIMPLE_BIND' statement 'G'.

 -- GIMPLE function: void gimple_bind_set_vars (gbind *g, tree vars)
     Set 'VARS' to be the set of variables declared in the 'GIMPLE_BIND'
     statement 'G'.

 -- GIMPLE function: void gimple_bind_append_vars (gbind *g, tree vars)
     Append 'VARS' to the set of variables declared in the 'GIMPLE_BIND'
     statement 'G'.

 -- GIMPLE function: gimple_seq gimple_bind_body (gbind *g)
     Return the GIMPLE sequence contained in the 'GIMPLE_BIND' statement
     'G'.

 -- GIMPLE function: void gimple_bind_set_body (gbind *g, gimple_seq
          seq)
     Set 'SEQ' to be sequence contained in the 'GIMPLE_BIND' statement
     'G'.

 -- GIMPLE function: void gimple_bind_add_stmt (gbind *gs, gimple stmt)
     Append a statement to the end of a 'GIMPLE_BIND''s body.

 -- GIMPLE function: void gimple_bind_add_seq (gbind *gs, gimple_seq
          seq)
     Append a sequence of statements to the end of a 'GIMPLE_BIND''s
     body.

 -- GIMPLE function: tree gimple_bind_block (const gbind *g)
     Return the 'TREE_BLOCK' node associated with 'GIMPLE_BIND'
     statement 'G'.  This is analogous to the 'BIND_EXPR_BLOCK' field in
     trees.

 -- GIMPLE function: void gimple_bind_set_block (gbind *g, tree block)
     Set 'BLOCK' to be the 'TREE_BLOCK' node associated with
     'GIMPLE_BIND' statement 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_CALL|,  Next: |GIMPLE_CATCH|,  Prev: |GIMPLE_BIND|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                   *GIMPLE_CALL*

12.8.4 'GIMPLE_CALL'
--------------------

 -- GIMPLE function: gcall *gimple_build_call (tree fn, unsigned nargs,
          ...)
     Build a 'GIMPLE_CALL' statement to function 'FN'.  The argument
     'FN' must be either a 'FUNCTION_DECL' or a gimple call address as
     determined by 'is_gimple_call_addr'.  'NARGS' are the number of
     arguments.  The rest of the arguments follow the argument 'NARGS',
     and must be trees that are valid as rvalues in gimple (i.e., each
     operand is validated with 'is_gimple_operand').

 -- GIMPLE function: gcall *gimple_build_call_from_tree (tree call_expr,
          tree fnptrtype)
     Build a 'GIMPLE_CALL' from a 'CALL_EXPR' node.  The arguments and
     the function are taken from the expression directly.  The type of
     the 'GIMPLE_CALL' is set from the second parameter passed by a
     caller.  This routine assumes that 'call_expr' is already in GIMPLE
     form.  That is, its operands are GIMPLE values and the function
     call needs no further simplification.  All the call flags in
     'call_expr' are copied over to the new 'GIMPLE_CALL'.

 -- GIMPLE function: gcall *gimple_build_call_vec (tree fn, 'vec<tree>'
          args)
     Identical to 'gimple_build_call' but the arguments are stored in a
     'vec<tree>'.

 -- GIMPLE function: tree gimple_call_lhs (gimple g)
     Return the 'LHS' of call statement 'G'.

 -- GIMPLE function: tree * gimple_call_lhs_ptr (gimple g)
     Return a pointer to the 'LHS' of call statement 'G'.

 -- GIMPLE function: void gimple_call_set_lhs (gimple g, tree lhs)
     Set 'LHS' to be the 'LHS' operand of call statement 'G'.

 -- GIMPLE function: tree gimple_call_fn (gimple g)
     Return the tree node representing the function called by call
     statement 'G'.

 -- GIMPLE function: void gimple_call_set_fn (gcall *g, tree fn)
     Set 'FN' to be the function called by call statement 'G'.  This has
     to be a gimple value specifying the address of the called function.

 -- GIMPLE function: tree gimple_call_fndecl (gimple g)
     If a given 'GIMPLE_CALL''s callee is a 'FUNCTION_DECL', return it.
     Otherwise return 'NULL'.  This function is analogous to
     'get_callee_fndecl' in 'GENERIC'.

 -- GIMPLE function: tree gimple_call_set_fndecl (gimple g, tree fndecl)
     Set the called function to 'FNDECL'.

 -- GIMPLE function: tree gimple_call_return_type (const gcall *g)
     Return the type returned by call statement 'G'.

 -- GIMPLE function: tree gimple_call_chain (gimple g)
     Return the static chain for call statement 'G'.

 -- GIMPLE function: void gimple_call_set_chain (gcall *g, tree chain)
     Set 'CHAIN' to be the static chain for call statement 'G'.

 -- GIMPLE function: unsigned gimple_call_num_args (gimple g)
     Return the number of arguments used by call statement 'G'.

 -- GIMPLE function: tree gimple_call_arg (gimple g, unsigned index)
     Return the argument at position 'INDEX' for call statement 'G'.
     The first argument is 0.

 -- GIMPLE function: tree * gimple_call_arg_ptr (gimple g, unsigned
          index)
     Return a pointer to the argument at position 'INDEX' for call
     statement 'G'.

 -- GIMPLE function: void gimple_call_set_arg (gimple g, unsigned index,
          tree arg)
     Set 'ARG' to be the argument at position 'INDEX' for call statement
     'G'.

 -- GIMPLE function: void gimple_call_set_tail (gcall *s)
     Mark call statement 'S' as being a tail call (i.e., a call just
     before the exit of a function).  These calls are candidate for tail
     call optimization.

 -- GIMPLE function: bool gimple_call_tail_p (gcall *s)
     Return true if 'GIMPLE_CALL' 'S' is marked as a tail call.

 -- GIMPLE function: bool gimple_call_noreturn_p (gimple s)
     Return true if 'S' is a noreturn call.

 -- GIMPLE function: gimple gimple_call_copy_skip_args (gcall *stmt,
          bitmap args_to_skip)
     Build a 'GIMPLE_CALL' identical to 'STMT' but skipping the
     arguments in the positions marked by the set 'ARGS_TO_SKIP'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_CATCH|,  Next: |GIMPLE_COND|,  Prev: |GIMPLE_CALL|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                  *GIMPLE_CATCH*

12.8.5 'GIMPLE_CATCH'
---------------------

 -- GIMPLE function: gcatch *gimple_build_catch (tree types, gimple_seq
          handler)
     Build a 'GIMPLE_CATCH' statement.  'TYPES' are the tree types this
     catch handles.  'HANDLER' is a sequence of statements with the code
     for the handler.

 -- GIMPLE function: tree gimple_catch_types (const gcatch *g)
     Return the types handled by 'GIMPLE_CATCH' statement 'G'.

 -- GIMPLE function: tree * gimple_catch_types_ptr (gcatch *g)
     Return a pointer to the types handled by 'GIMPLE_CATCH' statement
     'G'.

 -- GIMPLE function: gimple_seq gimple_catch_handler (gcatch *g)
     Return the GIMPLE sequence representing the body of the handler of
     'GIMPLE_CATCH' statement 'G'.

 -- GIMPLE function: void gimple_catch_set_types (gcatch *g, tree t)
     Set 'T' to be the set of types handled by 'GIMPLE_CATCH' 'G'.

 -- GIMPLE function: void gimple_catch_set_handler (gcatch *g,
          gimple_seq handler)
     Set 'HANDLER' to be the body of 'GIMPLE_CATCH' 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_COND|,  Next: |GIMPLE_DEBUG|,  Prev: |GIMPLE_CATCH|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                   *GIMPLE_COND*

12.8.6 'GIMPLE_COND'
--------------------

 -- GIMPLE function: gcond *gimple_build_cond ( enum tree_code
          pred_code, tree lhs, tree rhs, tree t_label, tree f_label)
     Build a 'GIMPLE_COND' statement.  'A' 'GIMPLE_COND' statement
     compares 'LHS' and 'RHS' and if the condition in 'PRED_CODE' is
     true, jump to the label in 't_label', otherwise jump to the label
     in 'f_label'.  'PRED_CODE' are relational operator tree codes like
     'EQ_EXPR', 'LT_EXPR', 'LE_EXPR', 'NE_EXPR', etc.

 -- GIMPLE function: gcond *gimple_build_cond_from_tree (tree cond, tree
          t_label, tree f_label)
     Build a 'GIMPLE_COND' statement from the conditional expression
     tree 'COND'.  'T_LABEL' and 'F_LABEL' are as in
     'gimple_build_cond'.

 -- GIMPLE function: enum tree_code gimple_cond_code (gimple g)
     Return the code of the predicate computed by conditional statement
     'G'.

 -- GIMPLE function: void gimple_cond_set_code (gcond *g, enum tree_code
          code)
     Set 'CODE' to be the predicate code for the conditional statement
     'G'.

 -- GIMPLE function: tree gimple_cond_lhs (gimple g)
     Return the 'LHS' of the predicate computed by conditional statement
     'G'.

 -- GIMPLE function: void gimple_cond_set_lhs (gcond *g, tree lhs)
     Set 'LHS' to be the 'LHS' operand of the predicate computed by
     conditional statement 'G'.

 -- GIMPLE function: tree gimple_cond_rhs (gimple g)
     Return the 'RHS' operand of the predicate computed by conditional
     'G'.

 -- GIMPLE function: void gimple_cond_set_rhs (gcond *g, tree rhs)
     Set 'RHS' to be the 'RHS' operand of the predicate computed by
     conditional statement 'G'.

 -- GIMPLE function: tree gimple_cond_true_label (const gcond *g)
     Return the label used by conditional statement 'G' when its
     predicate evaluates to true.

 -- GIMPLE function: void gimple_cond_set_true_label (gcond *g, tree
          label)
     Set 'LABEL' to be the label used by conditional statement 'G' when
     its predicate evaluates to true.

 -- GIMPLE function: void gimple_cond_set_false_label (gcond *g, tree
          label)
     Set 'LABEL' to be the label used by conditional statement 'G' when
     its predicate evaluates to false.

 -- GIMPLE function: tree gimple_cond_false_label (const gcond *g)
     Return the label used by conditional statement 'G' when its
     predicate evaluates to false.

 -- GIMPLE function: void gimple_cond_make_false (gcond *g)
     Set the conditional 'COND_STMT' to be of the form 'if (1 == 0)'.

 -- GIMPLE function: void gimple_cond_make_true (gcond *g)
     Set the conditional 'COND_STMT' to be of the form 'if (1 == 1)'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_DEBUG|,  Next: |GIMPLE_EH_FILTER|,  Prev: |GIMPLE_COND|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                  *GIMPLE_DEBUG*

12.8.7 'GIMPLE_DEBUG'
---------------------

 -- GIMPLE function: gdebug *gimple_build_debug_bind (tree var, tree
          value, gimple stmt)
     Build a 'GIMPLE_DEBUG' statement with 'GIMPLE_DEBUG_BIND'
     'subcode'.  The effect of this statement is to tell debug
     information generation machinery that the value of user variable
     'var' is given by 'value' at that point, and to remain with that
     value until 'var' runs out of scope, a dynamically-subsequent debug
     bind statement overrides the binding, or conflicting values reach a
     control flow merge point.  Even if components of the 'value'
     expression change afterwards, the variable is supposed to retain
     the same value, though not necessarily the same location.

     It is expected that 'var' be most often a tree for automatic user
     variables ('VAR_DECL' or 'PARM_DECL') that satisfy the requirements
     for gimple registers, but it may also be a tree for a scalarized
     component of a user variable ('ARRAY_REF', 'COMPONENT_REF'), or a
     debug temporary ('DEBUG_EXPR_DECL').

     As for 'value', it can be an arbitrary tree expression, but it is
     recommended that it be in a suitable form for a gimple assignment
     'RHS'.  It is not expected that user variables that could appear as
     'var' ever appear in 'value', because in the latter we'd have their
     'SSA_NAME's instead, but even if they were not in SSA form, user
     variables appearing in 'value' are to be regarded as part of the
     executable code space, whereas those in 'var' are to be regarded as
     part of the source code space.  There is no way to refer to the
     value bound to a user variable within a 'value' expression.

     If 'value' is 'GIMPLE_DEBUG_BIND_NOVALUE', debug information
     generation machinery is informed that the variable 'var' is
     unbound, i.e., that its value is indeterminate, which sometimes
     means it is really unavailable, and other times that the compiler
     could not keep track of it.

     Block and location information for the newly-created stmt are taken
     from 'stmt', if given.

 -- GIMPLE function: tree gimple_debug_bind_get_var (gimple stmt)
     Return the user variable VAR that is bound at 'stmt'.

 -- GIMPLE function: tree gimple_debug_bind_get_value (gimple stmt)
     Return the value expression that is bound to a user variable at
     'stmt'.

 -- GIMPLE function: tree * gimple_debug_bind_get_value_ptr (gimple
          stmt)
     Return a pointer to the value expression that is bound to a user
     variable at 'stmt'.

 -- GIMPLE function: void gimple_debug_bind_set_var (gimple stmt, tree
          var)
     Modify the user variable bound at 'stmt' to VAR.

 -- GIMPLE function: void gimple_debug_bind_set_value (gimple stmt, tree
          var)
     Modify the value bound to the user variable bound at 'stmt' to
     VALUE.

 -- GIMPLE function: void gimple_debug_bind_reset_value (gimple stmt)
     Modify the value bound to the user variable bound at 'stmt' so that
     the variable becomes unbound.

 -- GIMPLE function: bool gimple_debug_bind_has_value_p (gimple stmt)
     Return 'TRUE' if 'stmt' binds a user variable to a value, and
     'FALSE' if it unbinds the variable.

 -- GIMPLE function: gimple gimple_build_debug_begin_stmt (tree block,
          location_t location)
     Build a 'GIMPLE_DEBUG' statement with 'GIMPLE_DEBUG_BEGIN_STMT'
     'subcode'.  The effect of this statement is to tell debug
     information generation machinery that the user statement at the
     given 'location' and 'block' starts at the point at which the
     statement is inserted.  The intent is that side effects (e.g.
     variable bindings) of all prior user statements are observable, and
     that none of the side effects of subsequent user statements are.

 -- GIMPLE function: gimple gimple_build_debug_inline_entry (tree block,
          location_t location)
     Build a 'GIMPLE_DEBUG' statement with 'GIMPLE_DEBUG_INLINE_ENTRY'
     'subcode'.  The effect of this statement is to tell debug
     information generation machinery that a function call at 'location'
     underwent inline substitution, that 'block' is the enclosing
     lexical block created for the substitution, and that at the point
     of the program in which the stmt is inserted, all parameters for
     the inlined function are bound to the respective arguments, and
     none of the side effects of its stmts are observable.

==============================================================================
File: gccint.info,  Node: |GIMPLE_EH_FILTER|,  Next: |GIMPLE_LABEL|,  Prev: |GIMPLE_DEBUG|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                              *GIMPLE_EH_FILTER*

12.8.8 'GIMPLE_EH_FILTER'
-------------------------

 -- GIMPLE function: geh_filter *gimple_build_eh_filter (tree types,
          gimple_seq failure)
     Build a 'GIMPLE_EH_FILTER' statement.  'TYPES' are the filter's
     types.  'FAILURE' is a sequence with the filter's failure action.

 -- GIMPLE function: tree gimple_eh_filter_types (gimple g)
     Return the types handled by 'GIMPLE_EH_FILTER' statement 'G'.

 -- GIMPLE function: tree * gimple_eh_filter_types_ptr (gimple g)
     Return a pointer to the types handled by 'GIMPLE_EH_FILTER'
     statement 'G'.

 -- GIMPLE function: gimple_seq gimple_eh_filter_failure (gimple g)
     Return the sequence of statement to execute when 'GIMPLE_EH_FILTER'
     statement fails.

 -- GIMPLE function: void gimple_eh_filter_set_types (geh_filter *g,
          tree types)
     Set 'TYPES' to be the set of types handled by 'GIMPLE_EH_FILTER'
     'G'.

 -- GIMPLE function: void gimple_eh_filter_set_failure (geh_filter *g,
          gimple_seq failure)
     Set 'FAILURE' to be the sequence of statements to execute on
     failure for 'GIMPLE_EH_FILTER' 'G'.

 -- GIMPLE function: tree gimple_eh_must_not_throw_fndecl ( geh_mnt
          *eh_mnt_stmt)
     Get the function decl to be called by the MUST_NOT_THROW region.

 -- GIMPLE function: void gimple_eh_must_not_throw_set_fndecl ( geh_mnt
          *eh_mnt_stmt, tree decl)
     Set the function decl to be called by GS to DECL.

==============================================================================
File: gccint.info,  Node: |GIMPLE_LABEL|,  Next: |GIMPLE_GOTO|,  Prev: |GIMPLE_EH_FILTER|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                  *GIMPLE_LABEL*

12.8.9 'GIMPLE_LABEL'
---------------------

 -- GIMPLE function: glabel *gimple_build_label (tree label)
     Build a 'GIMPLE_LABEL' statement with corresponding to the tree
     label, 'LABEL'.

 -- GIMPLE function: tree gimple_label_label (const glabel *g)
     Return the 'LABEL_DECL' node used by 'GIMPLE_LABEL' statement 'G'.

 -- GIMPLE function: void gimple_label_set_label (glabel *g, tree label)
     Set 'LABEL' to be the 'LABEL_DECL' node used by 'GIMPLE_LABEL'
     statement 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_GOTO|,  Next: |GIMPLE_NOP|,  Prev: |GIMPLE_LABEL|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                   *GIMPLE_GOTO*

12.8.10 'GIMPLE_GOTO'
---------------------

 -- GIMPLE function: ggoto *gimple_build_goto (tree dest)
     Build a 'GIMPLE_GOTO' statement to label 'DEST'.

 -- GIMPLE function: tree gimple_goto_dest (gimple g)
     Return the destination of the unconditional jump 'G'.

 -- GIMPLE function: void gimple_goto_set_dest (ggoto *g, tree dest)
     Set 'DEST' to be the destination of the unconditional jump 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_NOP|,  Next: |GIMPLE_OMP_ATOMIC_LOAD|,  Prev: |GIMPLE_GOTO|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                    *GIMPLE_NOP*

12.8.11 'GIMPLE_NOP'
--------------------

 -- GIMPLE function: gimple gimple_build_nop (void)
     Build a 'GIMPLE_NOP' statement.

 -- GIMPLE function: bool gimple_nop_p (gimple g)
     Returns 'TRUE' if statement 'G' is a 'GIMPLE_NOP'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_ATOMIC_LOAD|,  Next: |GIMPLE_OMP_ATOMIC_STORE|,  Prev: |GIMPLE_NOP|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                        *GIMPLE_OMP_ATOMIC_LOAD*

12.8.12 'GIMPLE_OMP_ATOMIC_LOAD'
--------------------------------

 -- GIMPLE function: gomp_atomic_load *gimple_build_omp_atomic_load (
          tree lhs, tree rhs)
     Build a 'GIMPLE_OMP_ATOMIC_LOAD' statement.  'LHS' is the left-hand
     side of the assignment.  'RHS' is the right-hand side of the
     assignment.

 -- GIMPLE function: void gimple_omp_atomic_load_set_lhs (
          gomp_atomic_load *g, tree lhs)
     Set the 'LHS' of an atomic load.

 -- GIMPLE function: tree gimple_omp_atomic_load_lhs ( const
          gomp_atomic_load *g)
     Get the 'LHS' of an atomic load.

 -- GIMPLE function: void gimple_omp_atomic_load_set_rhs (
          gomp_atomic_load *g, tree rhs)
     Set the 'RHS' of an atomic set.

 -- GIMPLE function: tree gimple_omp_atomic_load_rhs ( const
          gomp_atomic_load *g)
     Get the 'RHS' of an atomic set.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_ATOMIC_STORE|,  Next: |GIMPLE_OMP_CONTINUE|,  Prev: |GIMPLE_OMP_ATOMIC_LOAD|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                       *GIMPLE_OMP_ATOMIC_STORE*

12.8.13 'GIMPLE_OMP_ATOMIC_STORE'
---------------------------------

 -- GIMPLE function: gomp_atomic_store *gimple_build_omp_atomic_store (
          tree val)
     Build a 'GIMPLE_OMP_ATOMIC_STORE' statement.  'VAL' is the value to
     be stored.

 -- GIMPLE function: void gimple_omp_atomic_store_set_val (
          gomp_atomic_store *g, tree val)
     Set the value being stored in an atomic store.

 -- GIMPLE function: tree gimple_omp_atomic_store_val ( const
          gomp_atomic_store *g)
     Return the value being stored in an atomic store.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_CONTINUE|,  Next: |GIMPLE_OMP_CRITICAL|,  Prev: |GIMPLE_OMP_ATOMIC_STORE|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                           *GIMPLE_OMP_CONTINUE*

12.8.14 'GIMPLE_OMP_CONTINUE'
-----------------------------

 -- GIMPLE function: gomp_continue *gimple_build_omp_continue ( tree
          control_def, tree control_use)
     Build a 'GIMPLE_OMP_CONTINUE' statement.  'CONTROL_DEF' is the
     definition of the control variable.  'CONTROL_USE' is the use of
     the control variable.

 -- GIMPLE function: tree gimple_omp_continue_control_def ( const
          gomp_continue *s)
     Return the definition of the control variable on a
     'GIMPLE_OMP_CONTINUE' in 'S'.

 -- GIMPLE function: tree gimple_omp_continue_control_def_ptr (
          gomp_continue *s)
     Same as above, but return the pointer.

 -- GIMPLE function: tree gimple_omp_continue_set_control_def (
          gomp_continue *s)
     Set the control variable definition for a 'GIMPLE_OMP_CONTINUE'
     statement in 'S'.

 -- GIMPLE function: tree gimple_omp_continue_control_use ( const
          gomp_continue *s)
     Return the use of the control variable on a 'GIMPLE_OMP_CONTINUE'
     in 'S'.

 -- GIMPLE function: tree gimple_omp_continue_control_use_ptr (
          gomp_continue *s)
     Same as above, but return the pointer.

 -- GIMPLE function: tree gimple_omp_continue_set_control_use (
          gomp_continue *s)
     Set the control variable use for a 'GIMPLE_OMP_CONTINUE' statement
     in 'S'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_CRITICAL|,  Next: |GIMPLE_OMP_FOR|,  Prev: |GIMPLE_OMP_CONTINUE|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                           *GIMPLE_OMP_CRITICAL*

12.8.15 'GIMPLE_OMP_CRITICAL'
-----------------------------

 -- GIMPLE function: gomp_critical *gimple_build_omp_critical (
          gimple_seq body, tree name)
     Build a 'GIMPLE_OMP_CRITICAL' statement.  'BODY' is the sequence of
     statements for which only one thread can execute.  'NAME' is an
     optional identifier for this critical block.

 -- GIMPLE function: tree gimple_omp_critical_name ( const gomp_critical
          *g)
     Return the name associated with 'OMP_CRITICAL' statement 'G'.

 -- GIMPLE function: tree * gimple_omp_critical_name_ptr ( gomp_critical
          *g)
     Return a pointer to the name associated with 'OMP' critical
     statement 'G'.

 -- GIMPLE function: void gimple_omp_critical_set_name ( gomp_critical
          *g, tree name)
     Set 'NAME' to be the name associated with 'OMP' critical statement
     'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_FOR|,  Next: |GIMPLE_OMP_MASTER|,  Prev: |GIMPLE_OMP_CRITICAL|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                *GIMPLE_OMP_FOR*

12.8.16 'GIMPLE_OMP_FOR'
------------------------

 -- GIMPLE function: gomp_for *gimple_build_omp_for (gimple_seq body,
          tree clauses, tree index, tree initial, tree final, tree incr,
          gimple_seq pre_body, enum tree_code omp_for_cond)
     Build a 'GIMPLE_OMP_FOR' statement.  'BODY' is sequence of
     statements inside the for loop.  'CLAUSES', are any of the loop
     construct's clauses.  'PRE_BODY' is the sequence of statements that
     are loop invariant.  'INDEX' is the index variable.  'INITIAL' is
     the initial value of 'INDEX'.  'FINAL' is final value of 'INDEX'.
     OMP_FOR_COND is the predicate used to compare 'INDEX' and 'FINAL'.
     'INCR' is the increment expression.

 -- GIMPLE function: tree gimple_omp_for_clauses (gimple g)
     Return the clauses associated with 'OMP_FOR' 'G'.

 -- GIMPLE function: tree * gimple_omp_for_clauses_ptr (gimple g)
     Return a pointer to the 'OMP_FOR' 'G'.

 -- GIMPLE function: void gimple_omp_for_set_clauses (gimple g, tree
          clauses)
     Set 'CLAUSES' to be the list of clauses associated with 'OMP_FOR'
     'G'.

 -- GIMPLE function: tree gimple_omp_for_index (gimple g)
     Return the index variable for 'OMP_FOR' 'G'.

 -- GIMPLE function: tree * gimple_omp_for_index_ptr (gimple g)
     Return a pointer to the index variable for 'OMP_FOR' 'G'.

 -- GIMPLE function: void gimple_omp_for_set_index (gimple g, tree
          index)
     Set 'INDEX' to be the index variable for 'OMP_FOR' 'G'.

 -- GIMPLE function: tree gimple_omp_for_initial (gimple g)
     Return the initial value for 'OMP_FOR' 'G'.

 -- GIMPLE function: tree * gimple_omp_for_initial_ptr (gimple g)
     Return a pointer to the initial value for 'OMP_FOR' 'G'.

 -- GIMPLE function: void gimple_omp_for_set_initial (gimple g, tree
          initial)
     Set 'INITIAL' to be the initial value for 'OMP_FOR' 'G'.

 -- GIMPLE function: tree gimple_omp_for_final (gimple g)
     Return the final value for 'OMP_FOR' 'G'.

 -- GIMPLE function: tree * gimple_omp_for_final_ptr (gimple g)
     turn a pointer to the final value for 'OMP_FOR' 'G'.

 -- GIMPLE function: void gimple_omp_for_set_final (gimple g, tree
          final)
     Set 'FINAL' to be the final value for 'OMP_FOR' 'G'.

 -- GIMPLE function: tree gimple_omp_for_incr (gimple g)
     Return the increment value for 'OMP_FOR' 'G'.

 -- GIMPLE function: tree * gimple_omp_for_incr_ptr (gimple g)
     Return a pointer to the increment value for 'OMP_FOR' 'G'.

 -- GIMPLE function: void gimple_omp_for_set_incr (gimple g, tree incr)
     Set 'INCR' to be the increment value for 'OMP_FOR' 'G'.

 -- GIMPLE function: gimple_seq gimple_omp_for_pre_body (gimple g)
     Return the sequence of statements to execute before the 'OMP_FOR'
     statement 'G' starts.

 -- GIMPLE function: void gimple_omp_for_set_pre_body (gimple g,
          gimple_seq pre_body)
     Set 'PRE_BODY' to be the sequence of statements to execute before
     the 'OMP_FOR' statement 'G' starts.

 -- GIMPLE function: void gimple_omp_for_set_cond (gimple g, enum
          tree_code cond)
     Set 'COND' to be the condition code for 'OMP_FOR' 'G'.

 -- GIMPLE function: enum tree_code gimple_omp_for_cond (gimple g)
     Return the condition code associated with 'OMP_FOR' 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_MASTER|,  Next: |GIMPLE_OMP_ORDERED|,  Prev: |GIMPLE_OMP_FOR|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                             *GIMPLE_OMP_MASTER*

12.8.17 'GIMPLE_OMP_MASTER'
---------------------------

 -- GIMPLE function: gimple gimple_build_omp_master (gimple_seq body)
     Build a 'GIMPLE_OMP_MASTER' statement.  'BODY' is the sequence of
     statements to be executed by just the master.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_ORDERED|,  Next: |GIMPLE_OMP_PARALLEL|,  Prev: |GIMPLE_OMP_MASTER|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                            *GIMPLE_OMP_ORDERED*

12.8.18 'GIMPLE_OMP_ORDERED'
----------------------------

 -- GIMPLE function: gimple gimple_build_omp_ordered (gimple_seq body)
     Build a 'GIMPLE_OMP_ORDERED' statement.

 'BODY' is the sequence of statements inside a loop that will executed
in sequence.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_PARALLEL|,  Next: |GIMPLE_OMP_RETURN|,  Prev: |GIMPLE_OMP_ORDERED|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                           *GIMPLE_OMP_PARALLEL*

12.8.19 'GIMPLE_OMP_PARALLEL'
-----------------------------

 -- GIMPLE function: gomp_parallel *gimple_build_omp_parallel
          (gimple_seq body, tree clauses, tree child_fn, tree data_arg)
     Build a 'GIMPLE_OMP_PARALLEL' statement.

 'BODY' is sequence of statements which are executed in parallel.
'CLAUSES', are the 'OMP' parallel construct's clauses.  'CHILD_FN' is
the function created for the parallel threads to execute.  'DATA_ARG'
are the shared data argument(s).

 -- GIMPLE function: bool gimple_omp_parallel_combined_p (gimple g)
     Return true if 'OMP' parallel statement 'G' has the
     'GF_OMP_PARALLEL_COMBINED' flag set.

 -- GIMPLE function: void gimple_omp_parallel_set_combined_p (gimple g)
     Set the 'GF_OMP_PARALLEL_COMBINED' field in 'OMP' parallel
     statement 'G'.

 -- GIMPLE function: gimple_seq gimple_omp_body (gimple g)
     Return the body for the 'OMP' statement 'G'.

 -- GIMPLE function: void gimple_omp_set_body (gimple g, gimple_seq
          body)
     Set 'BODY' to be the body for the 'OMP' statement 'G'.

 -- GIMPLE function: tree gimple_omp_parallel_clauses (gimple g)
     Return the clauses associated with 'OMP_PARALLEL' 'G'.

 -- GIMPLE function: tree * gimple_omp_parallel_clauses_ptr (
          gomp_parallel *g)
     Return a pointer to the clauses associated with 'OMP_PARALLEL' 'G'.

 -- GIMPLE function: void gimple_omp_parallel_set_clauses (
          gomp_parallel *g, tree clauses)
     Set 'CLAUSES' to be the list of clauses associated with
     'OMP_PARALLEL' 'G'.

 -- GIMPLE function: tree gimple_omp_parallel_child_fn ( const
          gomp_parallel *g)
     Return the child function used to hold the body of 'OMP_PARALLEL'
     'G'.

 -- GIMPLE function: tree * gimple_omp_parallel_child_fn_ptr (
          gomp_parallel *g)
     Return a pointer to the child function used to hold the body of
     'OMP_PARALLEL' 'G'.

 -- GIMPLE function: void gimple_omp_parallel_set_child_fn (
          gomp_parallel *g, tree child_fn)
     Set 'CHILD_FN' to be the child function for 'OMP_PARALLEL' 'G'.

 -- GIMPLE function: tree gimple_omp_parallel_data_arg ( const
          gomp_parallel *g)
     Return the artificial argument used to send variables and values
     from the parent to the children threads in 'OMP_PARALLEL' 'G'.

 -- GIMPLE function: tree * gimple_omp_parallel_data_arg_ptr (
          gomp_parallel *g)
     Return a pointer to the data argument for 'OMP_PARALLEL' 'G'.

 -- GIMPLE function: void gimple_omp_parallel_set_data_arg (
          gomp_parallel *g, tree data_arg)
     Set 'DATA_ARG' to be the data argument for 'OMP_PARALLEL' 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_RETURN|,  Next: |GIMPLE_OMP_SECTION|,  Prev: |GIMPLE_OMP_PARALLEL|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                             *GIMPLE_OMP_RETURN*

12.8.20 'GIMPLE_OMP_RETURN'
---------------------------

 -- GIMPLE function: gimple gimple_build_omp_return (bool wait_p)
     Build a 'GIMPLE_OMP_RETURN' statement.  'WAIT_P' is true if this is
     a non-waiting return.

 -- GIMPLE function: void gimple_omp_return_set_nowait (gimple s)
     Set the nowait flag on 'GIMPLE_OMP_RETURN' statement 'S'.

 -- GIMPLE function: bool gimple_omp_return_nowait_p (gimple g)
     Return true if 'OMP' return statement 'G' has the
     'GF_OMP_RETURN_NOWAIT' flag set.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_SECTION|,  Next: |GIMPLE_OMP_SECTIONS|,  Prev: |GIMPLE_OMP_RETURN|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                            *GIMPLE_OMP_SECTION*

12.8.21 'GIMPLE_OMP_SECTION'
----------------------------

 -- GIMPLE function: gimple gimple_build_omp_section (gimple_seq body)
     Build a 'GIMPLE_OMP_SECTION' statement for a sections statement.

 'BODY' is the sequence of statements in the section.

 -- GIMPLE function: bool gimple_omp_section_last_p (gimple g)
     Return true if 'OMP' section statement 'G' has the
     'GF_OMP_SECTION_LAST' flag set.

 -- GIMPLE function: void gimple_omp_section_set_last (gimple g)
     Set the 'GF_OMP_SECTION_LAST' flag on 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_SECTIONS|,  Next: |GIMPLE_OMP_SINGLE|,  Prev: |GIMPLE_OMP_SECTION|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                           *GIMPLE_OMP_SECTIONS*

12.8.22 'GIMPLE_OMP_SECTIONS'
-----------------------------

 -- GIMPLE function: gomp_sections *gimple_build_omp_sections (
          gimple_seq body, tree clauses)
     Build a 'GIMPLE_OMP_SECTIONS' statement.  'BODY' is a sequence of
     section statements.  'CLAUSES' are any of the 'OMP' sections
     construct's clauses: private, firstprivate, lastprivate, reduction,
     and nowait.

 -- GIMPLE function: gimple gimple_build_omp_sections_switch (void)
     Build a 'GIMPLE_OMP_SECTIONS_SWITCH' statement.

 -- GIMPLE function: tree gimple_omp_sections_control (gimple g)
     Return the control variable associated with the
     'GIMPLE_OMP_SECTIONS' in 'G'.

 -- GIMPLE function: tree * gimple_omp_sections_control_ptr (gimple g)
     Return a pointer to the clauses associated with the
     'GIMPLE_OMP_SECTIONS' in 'G'.

 -- GIMPLE function: void gimple_omp_sections_set_control (gimple g,
          tree control)
     Set 'CONTROL' to be the set of clauses associated with the
     'GIMPLE_OMP_SECTIONS' in 'G'.

 -- GIMPLE function: tree gimple_omp_sections_clauses (gimple g)
     Return the clauses associated with 'OMP_SECTIONS' 'G'.

 -- GIMPLE function: tree * gimple_omp_sections_clauses_ptr (gimple g)
     Return a pointer to the clauses associated with 'OMP_SECTIONS' 'G'.

 -- GIMPLE function: void gimple_omp_sections_set_clauses (gimple g,
          tree clauses)
     Set 'CLAUSES' to be the set of clauses associated with
     'OMP_SECTIONS' 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_OMP_SINGLE|,  Next: |GIMPLE_PHI|,  Prev: |GIMPLE_OMP_SECTIONS|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                             *GIMPLE_OMP_SINGLE*

12.8.23 'GIMPLE_OMP_SINGLE'
---------------------------

 -- GIMPLE function: gomp_single *gimple_build_omp_single ( gimple_seq
          body, tree clauses)
     Build a 'GIMPLE_OMP_SINGLE' statement.  'BODY' is the sequence of
     statements that will be executed once.  'CLAUSES' are any of the
     'OMP' single construct's clauses: private, firstprivate,
     copyprivate, nowait.

 -- GIMPLE function: tree gimple_omp_single_clauses (gimple g)
     Return the clauses associated with 'OMP_SINGLE' 'G'.

 -- GIMPLE function: tree * gimple_omp_single_clauses_ptr (gimple g)
     Return a pointer to the clauses associated with 'OMP_SINGLE' 'G'.

 -- GIMPLE function: void gimple_omp_single_set_clauses ( gomp_single
          *g, tree clauses)
     Set 'CLAUSES' to be the clauses associated with 'OMP_SINGLE' 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_PHI|,  Next: |GIMPLE_RESX|,  Prev: |GIMPLE_OMP_SINGLE|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                    *GIMPLE_PHI*

12.8.24 'GIMPLE_PHI'
--------------------

 -- GIMPLE function: unsigned gimple_phi_capacity (gimple g)
     Return the maximum number of arguments supported by 'GIMPLE_PHI'
     'G'.

 -- GIMPLE function: unsigned gimple_phi_num_args (gimple g)
     Return the number of arguments in 'GIMPLE_PHI' 'G'.  This must
     always be exactly the number of incoming edges for the basic block
     holding 'G'.

 -- GIMPLE function: tree gimple_phi_result (gimple g)
     Return the 'SSA' name created by 'GIMPLE_PHI' 'G'.

 -- GIMPLE function: tree * gimple_phi_result_ptr (gimple g)
     Return a pointer to the 'SSA' name created by 'GIMPLE_PHI' 'G'.

 -- GIMPLE function: void gimple_phi_set_result (gphi *g, tree result)
     Set 'RESULT' to be the 'SSA' name created by 'GIMPLE_PHI' 'G'.

 -- GIMPLE function: struct phi_arg_d * gimple_phi_arg (gimple g, index)
     Return the 'PHI' argument corresponding to incoming edge 'INDEX'
     for 'GIMPLE_PHI' 'G'.

 -- GIMPLE function: void gimple_phi_set_arg (gphi *g, index, struct
          phi_arg_d * phiarg)
     Set 'PHIARG' to be the argument corresponding to incoming edge
     'INDEX' for 'GIMPLE_PHI' 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_RESX|,  Next: |GIMPLE_RETURN|,  Prev: |GIMPLE_PHI|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                   *GIMPLE_RESX*

12.8.25 'GIMPLE_RESX'
---------------------

 -- GIMPLE function: gresx *gimple_build_resx (int region)
     Build a 'GIMPLE_RESX' statement which is a statement.  This
     statement is a placeholder for _Unwind_Resume before we know if a
     function call or a branch is needed.  'REGION' is the exception
     region from which control is flowing.

 -- GIMPLE function: int gimple_resx_region (const gresx *g)
     Return the region number for 'GIMPLE_RESX' 'G'.

 -- GIMPLE function: void gimple_resx_set_region (gresx *g, int region)
     Set 'REGION' to be the region number for 'GIMPLE_RESX' 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_RETURN|,  Next: |GIMPLE_SWITCH|,  Prev: |GIMPLE_RESX|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                 *GIMPLE_RETURN*

12.8.26 'GIMPLE_RETURN'
-----------------------

 -- GIMPLE function: greturn *gimple_build_return (tree retval)
     Build a 'GIMPLE_RETURN' statement whose return value is retval.

 -- GIMPLE function: tree gimple_return_retval (const greturn *g)
     Return the return value for 'GIMPLE_RETURN' 'G'.

 -- GIMPLE function: void gimple_return_set_retval (greturn *g, tree
          retval)
     Set 'RETVAL' to be the return value for 'GIMPLE_RETURN' 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_SWITCH|,  Next: |GIMPLE_TRY|,  Prev: |GIMPLE_RETURN|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                 *GIMPLE_SWITCH*

12.8.27 'GIMPLE_SWITCH'
-----------------------

 -- GIMPLE function: gswitch *gimple_build_switch (tree index, tree
          default_label, 'vec'<tree> *args)
     Build a 'GIMPLE_SWITCH' statement.  'INDEX' is the index variable
     to switch on, and 'DEFAULT_LABEL' represents the default label.
     'ARGS' is a vector of 'CASE_LABEL_EXPR' trees that contain the
     non-default case labels.  Each label is a tree of code
     'CASE_LABEL_EXPR'.

 -- GIMPLE function: unsigned gimple_switch_num_labels ( const gswitch
          *g)
     Return the number of labels associated with the switch statement
     'G'.

 -- GIMPLE function: void gimple_switch_set_num_labels (gswitch *g,
          unsigned nlabels)
     Set 'NLABELS' to be the number of labels for the switch statement
     'G'.

 -- GIMPLE function: tree gimple_switch_index (const gswitch *g)
     Return the index variable used by the switch statement 'G'.

 -- GIMPLE function: void gimple_switch_set_index (gswitch *g, tree
          index)
     Set 'INDEX' to be the index variable for switch statement 'G'.

 -- GIMPLE function: tree gimple_switch_label (const gswitch *g,
          unsigned index)
     Return the label numbered 'INDEX'.  The default label is 0,
     followed by any labels in a switch statement.

 -- GIMPLE function: void gimple_switch_set_label (gswitch *g, unsigned
          index, tree label)
     Set the label number 'INDEX' to 'LABEL'.  0 is always the default
     label.

 -- GIMPLE function: tree gimple_switch_default_label ( const gswitch
          *g)
     Return the default label for a switch statement.

 -- GIMPLE function: void gimple_switch_set_default_label (gswitch *g,
          tree label)
     Set the default label for a switch statement.

==============================================================================
File: gccint.info,  Node: |GIMPLE_TRY|,  Next: |GIMPLE_WITH_CLEANUP_EXPR|,  Prev: |GIMPLE_SWITCH|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                                    *GIMPLE_TRY*

12.8.28 'GIMPLE_TRY'
--------------------

 -- GIMPLE function: gtry *gimple_build_try (gimple_seq eval, gimple_seq
          cleanup, unsigned int kind)
     Build a 'GIMPLE_TRY' statement.  'EVAL' is a sequence with the
     expression to evaluate.  'CLEANUP' is a sequence of statements to
     run at clean-up time.  'KIND' is the enumeration value
     'GIMPLE_TRY_CATCH' if this statement denotes a try/catch construct
     or 'GIMPLE_TRY_FINALLY' if this statement denotes a try/finally
     construct.

 -- GIMPLE function: enum gimple_try_flags gimple_try_kind (gimple g)
     Return the kind of try block represented by 'GIMPLE_TRY' 'G'.  This
     is either 'GIMPLE_TRY_CATCH' or 'GIMPLE_TRY_FINALLY'.

 -- GIMPLE function: bool gimple_try_catch_is_cleanup (gimple g)
     Return the 'GIMPLE_TRY_CATCH_IS_CLEANUP' flag.

 -- GIMPLE function: gimple_seq gimple_try_eval (gimple g)
     Return the sequence of statements used as the body for 'GIMPLE_TRY'
     'G'.

 -- GIMPLE function: gimple_seq gimple_try_cleanup (gimple g)
     Return the sequence of statements used as the cleanup body for
     'GIMPLE_TRY' 'G'.

 -- GIMPLE function: void gimple_try_set_catch_is_cleanup (gimple g,
          bool catch_is_cleanup)
     Set the 'GIMPLE_TRY_CATCH_IS_CLEANUP' flag.

 -- GIMPLE function: void gimple_try_set_eval (gtry *g, gimple_seq eval)
     Set 'EVAL' to be the sequence of statements to use as the body for
     'GIMPLE_TRY' 'G'.

 -- GIMPLE function: void gimple_try_set_cleanup (gtry *g, gimple_seq
          cleanup)
     Set 'CLEANUP' to be the sequence of statements to use as the
     cleanup body for 'GIMPLE_TRY' 'G'.

==============================================================================
File: gccint.info,  Node: |GIMPLE_WITH_CLEANUP_EXPR|,  Prev: |GIMPLE_TRY|,  Up: |Tuple_specific_accessors|
==============================================================================

                                                      *GIMPLE_WITH_CLEANUP_EXPR*

12.8.29 'GIMPLE_WITH_CLEANUP_EXPR'
----------------------------------

 -- GIMPLE function: gimple gimple_build_wce (gimple_seq cleanup)
     Build a 'GIMPLE_WITH_CLEANUP_EXPR' statement.  'CLEANUP' is the
     clean-up expression.

 -- GIMPLE function: gimple_seq gimple_wce_cleanup (gimple g)
     Return the cleanup sequence for cleanup statement 'G'.

 -- GIMPLE function: void gimple_wce_set_cleanup (gimple g, gimple_seq
          cleanup)
     Set 'CLEANUP' to be the cleanup sequence for 'G'.

 -- GIMPLE function: bool gimple_wce_cleanup_eh_only (gimple g)
     Return the 'CLEANUP_EH_ONLY' flag for a 'WCE' tuple.

 -- GIMPLE function: void gimple_wce_set_cleanup_eh_only (gimple g, bool
          eh_only_p)
     Set the 'CLEANUP_EH_ONLY' flag for a 'WCE' tuple.

==============================================================================
File: gccint.info,  Node: |GIMPLE_sequences|,  Next: |Sequence_iterators|,  Prev: |Tuple_specific_accessors|,  Up: |GIMPLE|
==============================================================================

                                                              *GIMPLE_sequences*

12.9 GIMPLE sequences
=====----------------

GIMPLE sequences are the tuple equivalent of 'STATEMENT_LIST''s used in
'GENERIC'.  They are used to chain statements together, and when used in
conjunction with sequence iterators, provide a framework for iterating
through statements.

 GIMPLE sequences are of type struct 'gimple_sequence', but are more
commonly passed by reference to functions dealing with sequences.  The
type for a sequence pointer is 'gimple_seq' which is the same as struct
'gimple_sequence' *.  When declaring a local sequence, you can define a
local variable of type struct 'gimple_sequence'.  When declaring a
sequence allocated on the garbage collected heap, use the function
'gimple_seq_alloc' documented below.

 There are convenience functions for iterating through sequences in the
section entitled Sequence Iterators.

 Below is a list of functions to manipulate and query sequences.

 -- GIMPLE function: void gimple_seq_add_stmt (gimple_seq *seq, gimple
          g)
     Link a gimple statement to the end of the sequence *'SEQ' if 'G' is
     not 'NULL'.  If *'SEQ' is 'NULL', allocate a sequence before
     linking.

 -- GIMPLE function: void gimple_seq_add_seq (gimple_seq *dest,
          gimple_seq src)
     Append sequence 'SRC' to the end of sequence *'DEST' if 'SRC' is
     not 'NULL'.  If *'DEST' is 'NULL', allocate a new sequence before
     appending.

 -- GIMPLE function: gimple_seq gimple_seq_deep_copy (gimple_seq src)
     Perform a deep copy of sequence 'SRC' and return the result.

 -- GIMPLE function: gimple_seq gimple_seq_reverse (gimple_seq seq)
     Reverse the order of the statements in the sequence 'SEQ'.  Return
     'SEQ'.

 -- GIMPLE function: gimple gimple_seq_first (gimple_seq s)
     Return the first statement in sequence 'S'.

 -- GIMPLE function: gimple gimple_seq_last (gimple_seq s)
     Return the last statement in sequence 'S'.

 -- GIMPLE function: void gimple_seq_set_last (gimple_seq s, gimple
          last)
     Set the last statement in sequence 'S' to the statement in 'LAST'.

 -- GIMPLE function: void gimple_seq_set_first (gimple_seq s, gimple
          first)
     Set the first statement in sequence 'S' to the statement in
     'FIRST'.

 -- GIMPLE function: void gimple_seq_init (gimple_seq s)
     Initialize sequence 'S' to an empty sequence.

 -- GIMPLE function: gimple_seq gimple_seq_alloc (void)
     Allocate a new sequence in the garbage collected store and return
     it.

 -- GIMPLE function: void gimple_seq_copy (gimple_seq dest, gimple_seq
          src)
     Copy the sequence 'SRC' into the sequence 'DEST'.

 -- GIMPLE function: bool gimple_seq_empty_p (gimple_seq s)
     Return true if the sequence 'S' is empty.

 -- GIMPLE function: gimple_seq bb_seq (basic_block bb)
     Returns the sequence of statements in 'BB'.

 -- GIMPLE function: void set_bb_seq (basic_block bb, gimple_seq seq)
     Sets the sequence of statements in 'BB' to 'SEQ'.

 -- GIMPLE function: bool gimple_seq_singleton_p (gimple_seq seq)
     Determine whether 'SEQ' contains exactly one statement.

==============================================================================
File: gccint.info,  Node: |Sequence_iterators|,  Next: |Adding_a_new_GIMPLE_statement_code|,  Prev: |GIMPLE_sequences|,  Up: |GIMPLE|
==============================================================================

                                                            *Sequence_iterators*

12.10 Sequence iterators
=====-------------------

Sequence iterators are convenience constructs for iterating through
statements in a sequence.  Given a sequence 'SEQ', here is a typical use
of gimple sequence iterators:

     gimple_stmt_iterator gsi;

     for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))
       {
         gimple g = gsi_stmt (gsi);
         /* Do something with gimple statement G.  */
       }

 Backward iterations are possible:

             for (gsi = gsi_last (seq); !gsi_end_p (gsi); gsi_prev (&gsi))

 Forward and backward iterations on basic blocks are possible with
'gsi_start_bb' and 'gsi_last_bb'.

 In the documentation below we sometimes refer to enum
'gsi_iterator_update'.  The valid options for this enumeration are:

   * 'GSI_NEW_STMT' Only valid when a single statement is added.  Move
     the iterator to it.

   * 'GSI_SAME_STMT' Leave the iterator at the same statement.

   * 'GSI_CONTINUE_LINKING' Move iterator to whatever position is
     suitable for linking other statements in the same direction.

 Below is a list of the functions used to manipulate and use statement
iterators.

 -- GIMPLE function: gimple_stmt_iterator gsi_start (gimple_seq seq)
     Return a new iterator pointing to the sequence 'SEQ''s first
     statement.  If 'SEQ' is empty, the iterator's basic block is
     'NULL'.  Use 'gsi_start_bb' instead when the iterator needs to
     always have the correct basic block set.

 -- GIMPLE function: gimple_stmt_iterator gsi_start_bb (basic_block bb)
     Return a new iterator pointing to the first statement in basic
     block 'BB'.

 -- GIMPLE function: gimple_stmt_iterator gsi_last (gimple_seq seq)
     Return a new iterator initially pointing to the last statement of
     sequence 'SEQ'.  If 'SEQ' is empty, the iterator's basic block is
     'NULL'.  Use 'gsi_last_bb' instead when the iterator needs to
     always have the correct basic block set.

 -- GIMPLE function: gimple_stmt_iterator gsi_last_bb (basic_block bb)
     Return a new iterator pointing to the last statement in basic block
     'BB'.

 -- GIMPLE function: bool gsi_end_p (gimple_stmt_iterator i)
     Return 'TRUE' if at the end of 'I'.

 -- GIMPLE function: bool gsi_one_before_end_p (gimple_stmt_iterator i)
     Return 'TRUE' if we're one statement before the end of 'I'.

 -- GIMPLE function: void gsi_next (gimple_stmt_iterator *i)
     Advance the iterator to the next gimple statement.

 -- GIMPLE function: void gsi_prev (gimple_stmt_iterator *i)
     Advance the iterator to the previous gimple statement.

 -- GIMPLE function: gimple gsi_stmt (gimple_stmt_iterator i)
     Return the current stmt.

 -- GIMPLE function: gimple_stmt_iterator gsi_after_labels (basic_block
          bb)
     Return a block statement iterator that points to the first
     non-label statement in block 'BB'.

 -- GIMPLE function: gimple * gsi_stmt_ptr (gimple_stmt_iterator *i)
     Return a pointer to the current stmt.

 -- GIMPLE function: basic_block gsi_bb (gimple_stmt_iterator i)
     Return the basic block associated with this iterator.

 -- GIMPLE function: gimple_seq gsi_seq (gimple_stmt_iterator i)
     Return the sequence associated with this iterator.

 -- GIMPLE function: void gsi_remove (gimple_stmt_iterator *i, bool
          remove_eh_info)
     Remove the current stmt from the sequence.  The iterator is updated
     to point to the next statement.  When 'REMOVE_EH_INFO' is true we
     remove the statement pointed to by iterator 'I' from the 'EH'
     tables.  Otherwise we do not modify the 'EH' tables.  Generally,
     'REMOVE_EH_INFO' should be true when the statement is going to be
     removed from the 'IL' and not reinserted elsewhere.

 -- GIMPLE function: void gsi_link_seq_before (gimple_stmt_iterator *i,
          gimple_seq seq, enum gsi_iterator_update mode)
     Links the sequence of statements 'SEQ' before the statement pointed
     by iterator 'I'.  'MODE' indicates what to do with the iterator
     after insertion (see 'enum gsi_iterator_update' above).

 -- GIMPLE function: void gsi_link_before (gimple_stmt_iterator *i,
          gimple g, enum gsi_iterator_update mode)
     Links statement 'G' before the statement pointed-to by iterator
     'I'.  Updates iterator 'I' according to 'MODE'.

 -- GIMPLE function: void gsi_link_seq_after (gimple_stmt_iterator *i,
          gimple_seq seq, enum gsi_iterator_update mode)
     Links sequence 'SEQ' after the statement pointed-to by iterator
     'I'.  'MODE' is as in 'gsi_insert_after'.

 -- GIMPLE function: void gsi_link_after (gimple_stmt_iterator *i,
          gimple g, enum gsi_iterator_update mode)
     Links statement 'G' after the statement pointed-to by iterator 'I'.
     'MODE' is as in 'gsi_insert_after'.

 -- GIMPLE function: gimple_seq gsi_split_seq_after
          (gimple_stmt_iterator i)
     Move all statements in the sequence after 'I' to a new sequence.
     Return this new sequence.

 -- GIMPLE function: gimple_seq gsi_split_seq_before
          (gimple_stmt_iterator *i)
     Move all statements in the sequence before 'I' to a new sequence.
     Return this new sequence.

 -- GIMPLE function: void gsi_replace (gimple_stmt_iterator *i, gimple
          stmt, bool update_eh_info)
     Replace the statement pointed-to by 'I' to 'STMT'.  If
     'UPDATE_EH_INFO' is true, the exception handling information of the
     original statement is moved to the new statement.

 -- GIMPLE function: void gsi_insert_before (gimple_stmt_iterator *i,
          gimple stmt, enum gsi_iterator_update mode)
     Insert statement 'STMT' before the statement pointed-to by iterator
     'I', update 'STMT''s basic block and scan it for new operands.
     'MODE' specifies how to update iterator 'I' after insertion (see
     enum 'gsi_iterator_update').

 -- GIMPLE function: void gsi_insert_seq_before (gimple_stmt_iterator
          *i, gimple_seq seq, enum gsi_iterator_update mode)
     Like 'gsi_insert_before', but for all the statements in 'SEQ'.

 -- GIMPLE function: void gsi_insert_after (gimple_stmt_iterator *i,
          gimple stmt, enum gsi_iterator_update mode)
     Insert statement 'STMT' after the statement pointed-to by iterator
     'I', update 'STMT''s basic block and scan it for new operands.
     'MODE' specifies how to update iterator 'I' after insertion (see
     enum 'gsi_iterator_update').

 -- GIMPLE function: void gsi_insert_seq_after (gimple_stmt_iterator *i,
          gimple_seq seq, enum gsi_iterator_update mode)
     Like 'gsi_insert_after', but for all the statements in 'SEQ'.

 -- GIMPLE function: gimple_stmt_iterator gsi_for_stmt (gimple stmt)
     Finds iterator for 'STMT'.

 -- GIMPLE function: void gsi_move_after (gimple_stmt_iterator *from,
          gimple_stmt_iterator *to)
     Move the statement at 'FROM' so it comes right after the statement
     at 'TO'.

 -- GIMPLE function: void gsi_move_before (gimple_stmt_iterator *from,
          gimple_stmt_iterator *to)
     Move the statement at 'FROM' so it comes right before the statement
     at 'TO'.

 -- GIMPLE function: void gsi_move_to_bb_end (gimple_stmt_iterator
          *from, basic_block bb)
     Move the statement at 'FROM' to the end of basic block 'BB'.

 -- GIMPLE function: void gsi_insert_on_edge (edge e, gimple stmt)
     Add 'STMT' to the pending list of edge 'E'.  No actual insertion is
     made until a call to 'gsi_commit_edge_inserts'() is made.

 -- GIMPLE function: void gsi_insert_seq_on_edge (edge e, gimple_seq
          seq)
     Add the sequence of statements in 'SEQ' to the pending list of edge
     'E'.  No actual insertion is made until a call to
     'gsi_commit_edge_inserts'() is made.

 -- GIMPLE function: basic_block gsi_insert_on_edge_immediate (edge e,
          gimple stmt)
     Similar to 'gsi_insert_on_edge'+'gsi_commit_edge_inserts'.  If a
     new block has to be created, it is returned.

 -- GIMPLE function: void gsi_commit_one_edge_insert (edge e,
          basic_block *new_bb)
     Commit insertions pending at edge 'E'.  If a new block is created,
     set 'NEW_BB' to this block, otherwise set it to 'NULL'.

 -- GIMPLE function: void gsi_commit_edge_inserts (void)
     This routine will commit all pending edge insertions, creating any
     new basic blocks which are necessary.

==============================================================================
File: gccint.info,  Node: |Adding_a_new_GIMPLE_statement_code|,  Next: |Statement_and_operand_traversals|,  Prev: |Sequence_iterators|,  Up: |GIMPLE|
==============================================================================

                                            *Adding_a_new_GIMPLE_statement_code*

12.11 Adding a new GIMPLE statement code
=====-----------------------------------

The first step in adding a new GIMPLE statement code, is modifying the
file 'gimple.def', which contains all the GIMPLE codes.  Then you must
add a corresponding gimple subclass located in 'gimple.h'.  This in
turn, will require you to add a corresponding 'GTY' tag in
'gsstruct.def', and code to handle this tag in 'gss_for_code' which is
located in 'gimple.c'.

 In order for the garbage collector to know the size of the structure
you created in 'gimple.h', you need to add a case to handle your new
GIMPLE statement in 'gimple_size' which is located in 'gimple.c'.

 You will probably want to create a function to build the new gimple
statement in 'gimple.c'.  The function should be called
'gimple_build_NEW-TUPLE-NAME', and should return the new tuple as a
pointer to the appropriate gimple subclass.

 If your new statement requires accessors for any members or operands it
may have, put simple inline accessors in 'gimple.h' and any non-trivial
accessors in 'gimple.c' with a corresponding prototype in 'gimple.h'.

 You should add the new statement subclass to the class hierarchy
diagram in 'gimple.texi'.

==============================================================================
File: gccint.info,  Node: |Statement_and_operand_traversals|,  Prev: |Adding_a_new_GIMPLE_statement_code|,  Up: |GIMPLE|
==============================================================================

                                              *Statement_and_operand_traversals*

12.12 Statement and operand traversals
=====---------------------------------

There are two functions available for walking statements and sequences:
'walk_gimple_stmt' and 'walk_gimple_seq', accordingly, and a third
function for walking the operands in a statement: 'walk_gimple_op'.

 -- GIMPLE function: tree walk_gimple_stmt (gimple_stmt_iterator *gsi,
          walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct
          walk_stmt_info *wi)
     This function is used to walk the current statement in 'GSI',
     optionally using traversal state stored in 'WI'.  If 'WI' is
     'NULL', no state is kept during the traversal.

     The callback 'CALLBACK_STMT' is called.  If 'CALLBACK_STMT' returns
     true, it means that the callback function has handled all the
     operands of the statement and it is not necessary to walk its
     operands.

     If 'CALLBACK_STMT' is 'NULL' or it returns false, 'CALLBACK_OP' is
     called on each operand of the statement via 'walk_gimple_op'.  If
     'walk_gimple_op' returns non-'NULL' for any operand, the remaining
     operands are not scanned.

     The return value is that returned by the last call to
     'walk_gimple_op', or 'NULL_TREE' if no 'CALLBACK_OP' is specified.

 -- GIMPLE function: tree walk_gimple_op (gimple stmt, walk_tree_fn
          callback_op, struct walk_stmt_info *wi)
     Use this function to walk the operands of statement 'STMT'.  Every
     operand is walked via 'walk_tree' with optional state information
     in 'WI'.

     'CALLBACK_OP' is called on each operand of 'STMT' via 'walk_tree'.
     Additional parameters to 'walk_tree' must be stored in 'WI'.  For
     each operand 'OP', 'walk_tree' is called as:

          walk_tree (&OP, CALLBACK_OP, WI, PSET)

     If 'CALLBACK_OP' returns non-'NULL' for an operand, the remaining
     operands are not scanned.  The return value is that returned by the
     last call to 'walk_tree', or 'NULL_TREE' if no 'CALLBACK_OP' is
     specified.

 -- GIMPLE function: tree walk_gimple_seq (gimple_seq seq, walk_stmt_fn
          callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info
          *wi)
     This function walks all the statements in the sequence 'SEQ'
     calling 'walk_gimple_stmt' on each one.  'WI' is as in
     'walk_gimple_stmt'.  If 'walk_gimple_stmt' returns non-'NULL', the
     walk is stopped and the value returned.  Otherwise, all the
     statements are walked and 'NULL_TREE' returned.

==============================================================================
File: gccint.info,  Node: |Tree_SSA|,  Next: |RTL|,  Prev: |GIMPLE|,  Up: |Top|
==============================================================================

                                                                      *Tree_SSA*

13 Analysis and Optimization of GIMPLE tuples
*****========================================

GCC uses three main intermediate languages to represent the program
during compilation: GENERIC, GIMPLE and RTL.  GENERIC is a
language-independent representation generated by each front end.  It is
used to serve as an interface between the parser and optimizer.  GENERIC
is a common representation that is able to represent programs written in
all the languages supported by GCC.

 GIMPLE and RTL are used to optimize the program.  GIMPLE is used for
target and language independent optimizations (e.g., inlining, constant
propagation, tail call elimination, redundancy elimination, etc).  Much
like GENERIC, GIMPLE is a language independent, tree based
representation.  However, it differs from GENERIC in that the GIMPLE
grammar is more restrictive: expressions contain no more than 3 operands
(except function calls), it has no control flow structures and
expressions with side effects are only allowed on the right hand side of
assignments.  See the chapter describing GENERIC and GIMPLE for more
details.

 This chapter describes the data structures and functions used in the
GIMPLE optimizers (also known as "tree optimizers" or "middle end").  In
particular, it focuses on all the macros, data structures, functions and
programming constructs needed to implement optimization passes for
GIMPLE.

MENU

* |Annotations|::         Attributes for variables.
* |SSA_Operands|::        SSA names referenced by GIMPLE statements.
* |SSA|::                 Static Single Assignment representation.
* |Alias_analysis|::      Representing aliased loads and stores.
* |Memory_model|::        Memory model used by the middle-end.

==============================================================================
File: gccint.info,  Node: |Annotations|,  Next: |SSA_Operands|,  Up: |Tree_SSA|
==============================================================================

                                                                   *Annotations*

13.1 Annotations
=====-----------

The optimizers need to associate attributes with variables during the
optimization process.  For instance, we need to know whether a variable
has aliases.  All these attributes are stored in data structures called
annotations which are then linked to the field 'ann' in 'struct
tree_common'.

==============================================================================
File: gccint.info,  Node: |SSA_Operands|,  Next: |SSA|,  Prev: |Annotations|,  Up: |Tree_SSA|
==============================================================================

                                                                  *SSA_Operands*

13.2 SSA Operands
=====------------

Almost every GIMPLE statement will contain a reference to a variable or
memory location.  Since statements come in different shapes and sizes,
their operands are going to be located at various spots inside the
statement's tree.  To facilitate access to the statement's operands,
they are organized into lists associated inside each statement's
annotation.  Each element in an operand list is a pointer to a
'VAR_DECL', 'PARM_DECL' or 'SSA_NAME' tree node.  This provides a very
convenient way of examining and replacing operands.

 Data flow analysis and optimization is done on all tree nodes
representing variables.  Any node for which 'SSA_VAR_P' returns nonzero
is considered when scanning statement operands.  However, not all
'SSA_VAR_P' variables are processed in the same way.  For the purposes
vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
