
     (define_insn ""
       [(match_parallel 0 "load_multiple_operation"
          [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
                (match_operand:SI 2 "memory_operand" "m"))
           (use (reg:SI R_CR))
           (clobber (reg:SI R_CR))])]
       ""
       "loadm 0,0,%1,%2")

 The constants that are defined with a define_constant are also output
in the insn-codes.h header file as #defines.

 You can also use the machine description file to define enumerations.
Like the constants defined by 'define_constant', these enumerations are
visible to both the machine description file and the main C code.

 The syntax is as follows:

     (define_c_enum "NAME" [
       VALUE0
       VALUE1
       ...
       VALUEN
     ])

 This definition causes the equivalent of the following C code to appear
in 'insn-constants.h':

     enum NAME {
       VALUE0 = 0,
       VALUE1 = 1,
       ...
       VALUEN = N
     };
     #define NUM_CNAME_VALUES (N + 1)

 where CNAME is the capitalized form of NAME.  It also makes each VALUEI
available in the machine description file, just as if it had been
declared with:

     (define_constants [(VALUEI I)])

 Each VALUEI is usually an upper-case identifier and usually begins with
CNAME.

 You can split the enumeration definition into as many statements as you
like.  The above example is directly equivalent to:

     (define_c_enum "NAME" [VALUE0])
     (define_c_enum "NAME" [VALUE1])
     ...
     (define_c_enum "NAME" [VALUEN])

 Splitting the enumeration helps to improve the modularity of each
individual '.md' file.  For example, if a port defines its
synchronization instructions in a separate 'sync.md' file, it is
convenient to define all synchronization-specific enumeration values in
'sync.md' rather than in the main '.md' file.

 Some enumeration names have special significance to GCC:

'unspecv'
     If an enumeration called 'unspecv' is defined, GCC will use it when
     printing out 'unspec_volatile' expressions.  For example:

          (define_c_enum "unspecv" [
            UNSPECV_BLOCKAGE
          ])

     causes GCC to print '(unspec_volatile ... 0)' as:

          (unspec_volatile ... UNSPECV_BLOCKAGE)

'unspec'
     If an enumeration called 'unspec' is defined, GCC will use it when
     printing out 'unspec' expressions.  GCC will also use it when
     printing out 'unspec_volatile' expressions unless an 'unspecv'
     enumeration is also defined.  You can therefore decide whether to
     keep separate enumerations for volatile and non-volatile
     expressions or whether to use the same enumeration for both.

 Another way of defining an enumeration is to use 'define_enum':

     (define_enum "NAME" [
       VALUE0
       VALUE1
       ...
       VALUEN
     ])

 This directive implies:

     (define_c_enum "NAME" [
       CNAME_CVALUE0
       CNAME_CVALUE1
       ...
       CNAME_CVALUEN
     ])

 where CVALUEI is the capitalized form of VALUEI.  However, unlike
'define_c_enum', the enumerations defined by 'define_enum' can be used
in attribute specifications (*note define_enum_attr::).

==============================================================================
File: gccint.info,  Node: |Iterators|,  Prev: |Constant_Definitions|,  Up: |Machine_Desc|
==============================================================================

                                                                     *Iterators*

17.23 Iterators
---------------

Ports often need to define similar patterns for more than one machine
mode or for more than one rtx code.  GCC provides some simple iterator
facilities to make this process easier.

MENU

* |Mode_Iterators|::         Generating variations of patterns for different modes.
* |Code_Iterators|::         Doing the same for codes.
* |Int_Iterators|::          Doing the same for integers.
* |Subst_Iterators|::	   Generating variations of patterns for define_subst.
* |Parameterized_Names|::	   Specifying iterator values in C++ code.

==============================================================================
File: gccint.info,  Node: |Mode_Iterators|,  Next: |Code_Iterators|,  Up: |Iterators|
==============================================================================

                                                                *Mode_Iterators*

17.23.1 Mode Iterators
----------------------

Ports often need to define similar patterns for two or more different
modes.  For example:

   * If a processor has hardware support for both single and double
     floating-point arithmetic, the 'SFmode' patterns tend to be very
     similar to the 'DFmode' ones.

   * If a port uses 'SImode' pointers in one configuration and 'DImode'
     pointers in another, it will usually have very similar 'SImode' and
     'DImode' patterns for manipulating pointers.

 Mode iterators allow several patterns to be instantiated from one '.md'
file template.  They can be used with any type of rtx-based construct,
such as a 'define_insn', 'define_split', or 'define_peephole2'.

MENU

* |Defining_Mode_Iterators|:: Defining a new mode iterator.
* |Substitutions|::           Combining mode iterators with substitutions
* |Examples|::                Examples

==============================================================================
File: gccint.info,  Node: |Defining_Mode_Iterators|,  Next: |Substitutions|,  Up: Mode Iterators
==============================================================================

                                                       *Defining_Mode_Iterators*

17.23.1.1 Defining Mode Iterators
---------------------------------

The syntax for defining a mode iterator is:

     (define_mode_iterator NAME [(MODE1 "COND1") ... (MODEN "CONDN")])

 This allows subsequent '.md' file constructs to use the mode suffix
':NAME'.  Every construct that does so will be expanded N times, once
with every use of ':NAME' replaced by ':MODE1', once with every use
replaced by ':MODE2', and so on.  In the expansion for a particular
MODEI, every C condition will also require that CONDI be true.

 For example:

     (define_mode_iterator P [(SI "Pmode == SImode") (DI "Pmode == DImode")])

 defines a new mode suffix ':P'.  Every construct that uses ':P' will be
expanded twice, once with every ':P' replaced by ':SI' and once with
every ':P' replaced by ':DI'.  The ':SI' version will only apply if
'Pmode == SImode' and the ':DI' version will only apply if 'Pmode ==
DImode'.

 As with other '.md' conditions, an empty string is treated as "always
true".  '(MODE "")' can also be abbreviated to 'MODE'.  For example:

     (define_mode_iterator GPR [SI (DI "TARGET_64BIT")])

 means that the ':DI' expansion only applies if 'TARGET_64BIT' but that
the ':SI' expansion has no such constraint.

 Iterators are applied in the order they are defined.  This can be
significant if two iterators are used in a construct that requires
substitutions.  *Note Substitutions::.

==============================================================================
File: gccint.info,  Node: |Substitutions|,  Next: |Examples|,  Prev: |Defining_Mode_Iterators|,  Up: |Mode_Iterators|
==============================================================================

                                                                 *Substitutions*

17.23.1.2 Substitution in Mode Iterators
----------------------------------------

If an '.md' file construct uses mode iterators, each version of the
construct will often need slightly different strings or modes.  For
example:

   * When a 'define_expand' defines several 'addM3' patterns (*note
     Standard Names::), each expander will need to use the appropriate
     mode name for M.

   * When a 'define_insn' defines several instruction patterns, each
     instruction will often use a different assembler mnemonic.

   * When a 'define_insn' requires operands with different modes, using
     an iterator for one of the operand modes usually requires a
     specific mode for the other operand(s).

 GCC supports such variations through a system of "mode attributes".
There are two standard attributes: 'mode', which is the name of the mode
in lower case, and 'MODE', which is the same thing in upper case.  You
can define other attributes using:

     (define_mode_attr NAME [(MODE1 "VALUE1") ... (MODEN "VALUEN")])

 where NAME is the name of the attribute and VALUEI is the value
associated with MODEI.

 When GCC replaces some :ITERATOR with :MODE, it will scan each string
and mode in the pattern for sequences of the form '<ITERATOR:ATTR>',
where ATTR is the name of a mode attribute.  If the attribute is defined
for MODE, the whole '<...>' sequence will be replaced by the appropriate
attribute value.

 For example, suppose an '.md' file has:

     (define_mode_iterator P [(SI "Pmode == SImode") (DI "Pmode == DImode")])
     (define_mode_attr load [(SI "lw") (DI "ld")])

 If one of the patterns that uses ':P' contains the string
'"<P:load>\t%0,%1"', the 'SI' version of that pattern will use
'"lw\t%0,%1"' and the 'DI' version will use '"ld\t%0,%1"'.

 Here is an example of using an attribute for a mode:

     (define_mode_iterator LONG [SI DI])
     (define_mode_attr SHORT [(SI "HI") (DI "SI")])
     (define_insn ...
       (sign_extend:LONG (match_operand:<LONG:SHORT> ...)) ...)

 The 'ITERATOR:' prefix may be omitted, in which case the substitution
will be attempted for every iterator expansion.

==============================================================================
File: gccint.info,  Node: |Examples|,  Prev: |Substitutions|,  Up: |Mode_Iterators|
==============================================================================

                                                                      *Examples*

17.23.1.3 Mode Iterator Examples
--------------------------------

Here is an example from the MIPS port.  It defines the following modes
and attributes (among others):

     (define_mode_iterator GPR [SI (DI "TARGET_64BIT")])
     (define_mode_attr d [(SI "") (DI "d")])

 and uses the following template to define both 'subsi3' and 'subdi3':

     (define_insn "sub<mode>3"
       [(set (match_operand:GPR 0 "register_operand" "=d")
             (minus:GPR (match_operand:GPR 1 "register_operand" "d")
                        (match_operand:GPR 2 "register_operand" "d")))]
       ""
       "<d>subu\t%0,%1,%2"
       [(set_attr "type" "arith")
        (set_attr "mode" "<MODE>")])

 This is exactly equivalent to:

     (define_insn "subsi3"
       [(set (match_operand:SI 0 "register_operand" "=d")
             (minus:SI (match_operand:SI 1 "register_operand" "d")
                       (match_operand:SI 2 "register_operand" "d")))]
       ""
       "subu\t%0,%1,%2"
       [(set_attr "type" "arith")
        (set_attr "mode" "SI")])

     (define_insn "subdi3"
       [(set (match_operand:DI 0 "register_operand" "=d")
             (minus:DI (match_operand:DI 1 "register_operand" "d")
                       (match_operand:DI 2 "register_operand" "d")))]
       ""
       "dsubu\t%0,%1,%2"
       [(set_attr "type" "arith")
        (set_attr "mode" "DI")])

==============================================================================
File: gccint.info,  Node: |Code_Iterators|,  Next: |Int_Iterators|,  Prev: |Mode_Iterators|,  Up: |Iterators|
==============================================================================

                                                                *Code_Iterators*

17.23.2 Code Iterators
----------------------

Code iterators operate in a similar way to mode iterators.  *Note Mode
Iterators::.

 The construct:

     (define_code_iterator NAME [(CODE1 "COND1") ... (CODEN "CONDN")])

 defines a pseudo rtx code NAME that can be instantiated as CODEI if
condition CONDI is true.  Each CODEI must have the same rtx format.
*Note RTL Classes::.

 As with mode iterators, each pattern that uses NAME will be expanded N
times, once with all uses of NAME replaced by CODE1, once with all uses
replaced by CODE2, and so on.  *Note Defining Mode Iterators::.

 It is possible to define attributes for codes as well as for modes.
There are two standard code attributes: 'code', the name of the code in
lower case, and 'CODE', the name of the code in upper case.  Other
attributes are defined using:

     (define_code_attr NAME [(CODE1 "VALUE1") ... (CODEN "VALUEN")])

 Instruction patterns can use code attributes as rtx codes, which can be
useful if two sets of codes act in tandem.  For example, the following
'define_insn' defines two patterns, one calculating a signed absolute
difference and another calculating an unsigned absolute difference:

     (define_code_iterator any_max [smax umax])
     (define_code_attr paired_min [(smax "smin") (umax "umin")])
     (define_insn ...
       [(set (match_operand:SI 0 ...)
             (minus:SI (any_max:SI (match_operand:SI 1 ...)
                                   (match_operand:SI 2 ...))
                       (<paired_min>:SI (match_dup 1) (match_dup 2))))]
       ...)

 The signed version of the instruction uses 'smax' and 'smin' while the
unsigned version uses 'umax' and 'umin'.  There are no versions that
pair 'smax' with 'umin' or 'umax' with 'smin'.

 Here's an example of code iterators in action, taken from the MIPS
port:

     (define_code_iterator any_cond [unordered ordered unlt unge uneq ltgt unle ungt
                                     eq ne gt ge lt le gtu geu ltu leu])

     (define_expand "b<code>"
       [(set (pc)
             (if_then_else (any_cond:CC (cc0)
                                        (const_int 0))
                           (label_ref (match_operand 0 ""))
                           (pc)))]
       ""
     {
       gen_conditional_branch (operands, <CODE>);
       DONE;
     })

 This is equivalent to:

     (define_expand "bunordered"
       [(set (pc)
             (if_then_else (unordered:CC (cc0)
                                         (const_int 0))
                           (label_ref (match_operand 0 ""))
                           (pc)))]
       ""
     {
       gen_conditional_branch (operands, UNORDERED);
       DONE;
     })

     (define_expand "bordered"
       [(set (pc)
             (if_then_else (ordered:CC (cc0)
                                       (const_int 0))
                           (label_ref (match_operand 0 ""))
                           (pc)))]
       ""
     {
       gen_conditional_branch (operands, ORDERED);
       DONE;
     })

     ...

==============================================================================
File: gccint.info,  Node: |Int_Iterators|,  Next: |Subst_Iterators|,  Prev: |Code_Iterators|,  Up: |Iterators|
==============================================================================

                                                                 *Int_Iterators*

17.23.3 Int Iterators
---------------------

Int iterators operate in a similar way to code iterators.  *Note Code
Iterators::.

 The construct:

     (define_int_iterator NAME [(INT1 "COND1") ... (INTN "CONDN")])

 defines a pseudo integer constant NAME that can be instantiated as INTI
if condition CONDI is true.  Each INT must have the same rtx format.
*Note RTL Classes::.  Int iterators can appear in only those rtx fields
that have 'i' as the specifier.  This means that each INT has to be a
constant defined using define_constant or define_c_enum.

 As with mode and code iterators, each pattern that uses NAME will be
expanded N times, once with all uses of NAME replaced by INT1, once with
all uses replaced by INT2, and so on.  *Note Defining Mode Iterators::.

 It is possible to define attributes for ints as well as for codes and
modes.  Attributes are defined using:

     (define_int_attr NAME [(INT1 "VALUE1") ... (INTN "VALUEN")])

 Here's an example of int iterators in action, taken from the ARM port:

     (define_int_iterator QABSNEG [UNSPEC_VQABS UNSPEC_VQNEG])

     (define_int_attr absneg [(UNSPEC_VQABS "abs") (UNSPEC_VQNEG "neg")])

     (define_insn "neon_vq<absneg><mode>"
       [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
     	(unspec:VDQIW [(match_operand:VDQIW 1 "s_register_operand" "w")
     		       (match_operand:SI 2 "immediate_operand" "i")]
     		      QABSNEG))]
       "TARGET_NEON"
       "vq<absneg>.<V_s_elem>\t%<V_reg>0, %<V_reg>1"
       [(set_attr "type" "neon_vqneg_vqabs")]
     )


 This is equivalent to:

     (define_insn "neon_vqabs<mode>"
       [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
     	(unspec:VDQIW [(match_operand:VDQIW 1 "s_register_operand" "w")
     		       (match_operand:SI 2 "immediate_operand" "i")]
     		      UNSPEC_VQABS))]
       "TARGET_NEON"
       "vqabs.<V_s_elem>\t%<V_reg>0, %<V_reg>1"
       [(set_attr "type" "neon_vqneg_vqabs")]
     )

     (define_insn "neon_vqneg<mode>"
       [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
     	(unspec:VDQIW [(match_operand:VDQIW 1 "s_register_operand" "w")
     		       (match_operand:SI 2 "immediate_operand" "i")]
     		      UNSPEC_VQNEG))]
       "TARGET_NEON"
       "vqneg.<V_s_elem>\t%<V_reg>0, %<V_reg>1"
       [(set_attr "type" "neon_vqneg_vqabs")]
     )


==============================================================================
File: gccint.info,  Node: |Subst_Iterators|,  Next: |Parameterized_Names|,  Prev: |Int_Iterators|,  Up: |Iterators|
==============================================================================

                                                               *Subst_Iterators*

17.23.4 Subst Iterators
-----------------------

Subst iterators are special type of iterators with the following
restrictions: they could not be declared explicitly, they always have
only two values, and they do not have explicit dedicated name.
Subst-iterators are triggered only when corresponding subst-attribute is
used in RTL-pattern.

 Subst iterators transform templates in the following way: the templates
are duplicated, the subst-attributes in these templates are replaced
with the corresponding values, and a new attribute is implicitly added
to the given 'define_insn'/'define_expand'.  The name of the added
attribute matches the name of 'define_subst'.  Such attributes are
declared implicitly, and it is not allowed to have a 'define_attr' named
as a 'define_subst'.

 Each subst iterator is linked to a 'define_subst'.  It is declared
implicitly by the first appearance of the corresponding
'define_subst_attr', and it is not allowed to define it explicitly.

 Declarations of subst-attributes have the following syntax:

     (define_subst_attr "NAME"
       "SUBST-NAME"
       "NO-SUBST-VALUE"
       "SUBST-APPLIED-VALUE")

 NAME is a string with which the given subst-attribute could be referred
to.

 SUBST-NAME shows which 'define_subst' should be applied to an
RTL-template if the given subst-attribute is present in the
RTL-template.

 NO-SUBST-VALUE is a value with which subst-attribute would be replaced
in the first copy of the original RTL-template.

 SUBST-APPLIED-VALUE is a value with which subst-attribute would be
replaced in the second copy of the original RTL-template.

==============================================================================
File: gccint.info,  Node: |Parameterized_Names|,  Prev: |Subst_Iterators|,  Up: |Iterators|
==============================================================================

                                                           *Parameterized_Names*

17.23.5 Parameterized Names
---------------------------

Ports sometimes need to apply iterators using C++ code, in order to get
the code or RTL pattern for a specific instruction.  For example,
suppose we have the 'neon_vq<absneg><mode>' pattern given above:

     (define_int_iterator QABSNEG [UNSPEC_VQABS UNSPEC_VQNEG])

     (define_int_attr absneg [(UNSPEC_VQABS "abs") (UNSPEC_VQNEG "neg")])

     (define_insn "neon_vq<absneg><mode>"
       [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
     	(unspec:VDQIW [(match_operand:VDQIW 1 "s_register_operand" "w")
     		       (match_operand:SI 2 "immediate_operand" "i")]
     		      QABSNEG))]
       ...
     )

 A port might need to generate this pattern for a variable 'QABSNEG'
value and a variable 'VDQIW' mode.  There are two ways of doing this.
The first is to build the rtx for the pattern directly from C++ code;
this is a valid technique and avoids any risk of combinatorial
explosion.  The second is to prefix the instruction name with the
special character '@', which tells GCC to generate the four additional
functions below.  In each case, NAME is the name of the instruction
without the leading '@' character, without the '<...>' placeholders, and
with any underscore before a '<...>' placeholder removed if keeping it
would lead to a double or trailing underscore.

'insn_code maybe_code_for_NAME (I1, I2, ...)'
     See whether replacing the first '<...>' placeholder with iterator
     value I1, the second with iterator value I2, and so on, gives a
     valid instruction.  Return its code if so, otherwise return
     'CODE_FOR_nothing'.

'insn_code code_for_NAME (I1, I2, ...)'
     Same, but abort the compiler if the requested instruction does not
     exist.

'rtx maybe_gen_NAME (I1, I2, ..., OP0, OP1, ...)'
     Check for a valid instruction in the same way as
     'maybe_code_for_NAME'.  If the instruction exists, generate an
     instance of it using the operand values given by OP0, OP1, and so
     on, otherwise return null.

'rtx gen_NAME (I1, I2, ..., OP0, OP1, ...)'
     Same, but abort the compiler if the requested instruction does not
     exist, or if the instruction generator invoked the 'FAIL' macro.

 For example, changing the pattern above to:

     (define_insn "@neon_vq<absneg><mode>"
       [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
     	(unspec:VDQIW [(match_operand:VDQIW 1 "s_register_operand" "w")
     		       (match_operand:SI 2 "immediate_operand" "i")]
     		      QABSNEG))]
       ...
     )

 would define the same patterns as before, but in addition would
generate the four functions below:

     insn_code maybe_code_for_neon_vq (int, machine_mode);
     insn_code code_for_neon_vq (int, machine_mode);
     rtx maybe_gen_neon_vq (int, machine_mode, rtx, rtx, rtx);
     rtx gen_neon_vq (int, machine_mode, rtx, rtx, rtx);

 Calling 'code_for_neon_vq (UNSPEC_VQABS, V8QImode)' would then give
'CODE_FOR_neon_vqabsv8qi'.

 It is possible to have multiple '@' patterns with the same name and
same types of iterator.  For example:

     (define_insn "@some_arithmetic_op<mode>"
       [(set (match_operand:INTEGER_MODES 0 "register_operand") ...)]
       ...
     )

     (define_insn "@some_arithmetic_op<mode>"
       [(set (match_operand:FLOAT_MODES 0 "register_operand") ...)]
       ...
     )

 would produce a single set of functions that handles both
'INTEGER_MODES' and 'FLOAT_MODES'.

 It is also possible for these '@' patterns to have different numbers of
operands from each other.  For example, patterns with a binary rtl code
might take three operands (one output and two inputs) while patterns
with a ternary rtl code might take four operands (one output and three
inputs).  This combination would produce separate 'maybe_gen_NAME' and
'gen_NAME' functions for each operand count, but it would still produce
a single 'maybe_code_for_NAME' and a single 'code_for_NAME'.

==============================================================================
File: gccint.info,  Node: |Target_Macros|,  Next: |Host_Config|,  Prev: |Machine_Desc|,  Up: |Top|
==============================================================================

                                                                 *Target_Macros*

18 Target Description Macros and Functions
==========================================

In addition to the file 'MACHINE.md', a machine description includes a C
header file conventionally given the name 'MACHINE.h' and a C source
file named 'MACHINE.c'.  The header file defines numerous macros that
convey the information about the target machine that does not fit into
the scheme of the '.md' file.  The file 'tm.h' should be a link to
'MACHINE.h'.  The header file 'config.h' includes 'tm.h' and most
compiler source files include 'config.h'.  The source file defines a
variable 'targetm', which is a structure containing pointers to
functions and data relating to the target machine.  'MACHINE.c' should
also contain their definitions, if they are not defined elsewhere in
GCC, and other functions called through the macros defined in the '.h'
file.

MENU

* |Target_Structure|::    The 'targetm' variable.
* |Driver|::              Controlling how the driver runs the compilation passes.
* |Run_time_Target|::     Defining '-m' options like '-m68000' and '-m68020'.
* |Per_Function_Data|::   Defining data structures for per-function information.
* |Storage_Layout|::      Defining sizes and alignments of data.
* |Type_Layout|::         Defining sizes and properties of basic user data types.
* |Registers|::           Naming and describing the hardware registers.
* |Register_Classes|::    Defining the classes of hardware registers.
* |Stack_and_Calling|::   Defining which way the stack grows and by how much.
* |Varargs|::             Defining the varargs macros.
* |Trampolines|::         Code set up at run time to enter a nested function.
* |Library_Calls|::       Controlling how library routines are implicitly called.
* |Addressing_Modes|::    Defining addressing modes valid for memory operands.
* |Anchored_Addresses|::  Defining how '-fsection-anchors' should work.
* |Condition_Code|::      Defining how insns update the condition code.
* |Costs|::               Defining relative costs of different operations.
* |Scheduling|::          Adjusting the behavior of the instruction scheduler.
* |Sections|::            Dividing storage into text, data, and other sections.
* |PIC|::                 Macros for position independent code.
* |Assembler_Format|::    Defining how to write insns and pseudo-ops to output.
* |Debugging_Info|::      Defining the format of debugging output.
* |Floating_Point|::      Handling floating point for cross-compilers.
* |Mode_Switching|::      Insertion of mode-switching instructions.
* |Target_Attributes|::   Defining target-specific uses of '__attribute__'.
* |Emulated_TLS|::        Emulated TLS support.
* |MIPS_Coprocessors|::   MIPS coprocessor support and how to customize it.
* |PCH_Target|::          Validity checking for precompiled headers.
* |C++_ABI|::             Controlling C++ ABI changes.
* |D_Language_and_ABI|::  Controlling D ABI changes.
* |Named_Address_Spaces|:: Adding support for named address spaces
* |Misc|::                Everything else.

==============================================================================
File: gccint.info,  Node: |Target_Structure|,  Next: |Driver|,  Up: |Target_Macros|
==============================================================================

                                                              *Target_Structure*

18.1 The Global 'targetm' Variable
----------------------------------

 -- Variable: struct gcc_target targetm
     The target '.c' file must define the global 'targetm' variable
     which contains pointers to functions and data relating to the
     target machine.  The variable is declared in 'target.h';
     'target-def.h' defines the macro 'TARGET_INITIALIZER' which is used
     to initialize the variable, and macros for the default initializers
     for elements of the structure.  The '.c' file should override those
     macros for which the default definition is inappropriate.  For
     example:
          #include "target.h"
          #include "target-def.h"

          /* Initialize the GCC target structure.  */

          #undef TARGET_COMP_TYPE_ATTRIBUTES
          #define TARGET_COMP_TYPE_ATTRIBUTES MACHINE_comp_type_attributes

          struct gcc_target targetm = TARGET_INITIALIZER;

 Where a macro should be defined in the '.c' file in this manner to form
part of the 'targetm' structure, it is documented below as a "Target
Hook" with a prototype.  Many macros will change in future from being
defined in the '.h' file to being part of the 'targetm' structure.

 Similarly, there is a 'targetcm' variable for hooks that are specific
to front ends for C-family languages, documented as "C Target Hook".
This is declared in 'c-family/c-target.h', the initializer
'TARGETCM_INITIALIZER' in 'c-family/c-target-def.h'.  If targets
initialize 'targetcm' themselves, they should set
'target_has_targetcm=yes' in 'config.gcc'; otherwise a default
definition is used.

 Similarly, there is a 'targetm_common' variable for hooks that are
shared between the compiler driver and the compilers proper, documented
as "Common Target Hook".  This is declared in 'common/common-target.h',
the initializer 'TARGETM_COMMON_INITIALIZER' in
'common/common-target-def.h'.  If targets initialize 'targetm_common'
themselves, they should set 'target_has_targetm_common=yes' in
'config.gcc'; otherwise a default definition is used.

 Similarly, there is a 'targetdm' variable for hooks that are specific
to the D language front end, documented as "D Target Hook".  This is
declared in 'd/d-target.h', the initializer 'TARGETDM_INITIALIZER' in
'd/d-target-def.h'.  If targets initialize 'targetdm' themselves, they
should set 'target_has_targetdm=yes' in 'config.gcc'; otherwise a
default definition is used.

==============================================================================
File: gccint.info,  Node: |Driver|,  Next: |Run_time_Target|,  Prev: |Target_Structure|,  Up: |Target_Macros|
==============================================================================

                                                                        *Driver*

18.2 Controlling the Compilation Driver, 'gcc'
----------------------------------------------

You can control the compilation driver.

 -- Macro: DRIVER_SELF_SPECS
     A list of specs for the driver itself.  It should be a suitable
     initializer for an array of strings, with no surrounding braces.

     The driver applies these specs to its own command line between
     loading default 'specs' files (but not command-line specified ones)
     and choosing the multilib directory or running any subcommands.  It
     applies them in the order given, so each spec can depend on the
     options added by earlier ones.  It is also possible to remove
     options using '%<OPTION' in the usual way.

     This macro can be useful when a port has several interdependent
     target options.  It provides a way of standardizing the command
     line so that the other specs are easier to write.

     Do not define this macro if it does not need to do anything.

 -- Macro: OPTION_DEFAULT_SPECS
     A list of specs used to support configure-time default options
     (i.e. '--with' options) in the driver.  It should be a suitable
     initializer for an array of structures, each containing two
     strings, without the outermost pair of surrounding braces.

     The first item in the pair is the name of the default.  This must
     match the code in 'config.gcc' for the target.  The second item is
     a spec to apply if a default with this name was specified.  The
     string '%(VALUE)' in the spec will be replaced by the value of the
     default everywhere it occurs.

     The driver will apply these specs to its own command line between
     loading default 'specs' files and processing 'DRIVER_SELF_SPECS',
     using the same mechanism as 'DRIVER_SELF_SPECS'.

     Do not define this macro if it does not need to do anything.

 -- Macro: CPP_SPEC
     A C string constant that tells the GCC driver program options to
     pass to CPP.  It can also specify how to translate options you give
     to GCC into options for GCC to pass to the CPP.

     Do not define this macro if it does not need to do anything.

 -- Macro: CPLUSPLUS_CPP_SPEC
     This macro is just like 'CPP_SPEC', but is used for C++, rather
     than C.  If you do not define this macro, then the value of
     'CPP_SPEC' (if any) will be used instead.

 -- Macro: CC1_SPEC
     A C string constant that tells the GCC driver program options to
     pass to 'cc1', 'cc1plus', 'f771', and the other language front
     ends.  It can also specify how to translate options you give to GCC
     into options for GCC to pass to front ends.

     Do not define this macro if it does not need to do anything.

 -- Macro: CC1PLUS_SPEC
     A C string constant that tells the GCC driver program options to
     pass to 'cc1plus'.  It can also specify how to translate options
     you give to GCC into options for GCC to pass to the 'cc1plus'.

     Do not define this macro if it does not need to do anything.  Note
     that everything defined in CC1_SPEC is already passed to 'cc1plus'
     so there is no need to duplicate the contents of CC1_SPEC in
     CC1PLUS_SPEC.

 -- Macro: ASM_SPEC
     A C string constant that tells the GCC driver program options to
     pass to the assembler.  It can also specify how to translate
     options you give to GCC into options for GCC to pass to the
     assembler.  See the file 'sun3.h' for an example of this.

     Do not define this macro if it does not need to do anything.

 -- Macro: ASM_FINAL_SPEC
     A C string constant that tells the GCC driver program how to run
     any programs which cleanup after the normal assembler.  Normally,
     this is not needed.  See the file 'mips.h' for an example of this.

     Do not define this macro if it does not need to do anything.

 -- Macro: AS_NEEDS_DASH_FOR_PIPED_INPUT
     Define this macro, with no value, if the driver should give the
     assembler an argument consisting of a single dash, '-', to instruct
     it to read from its standard input (which will be a pipe connected
     to the output of the compiler proper).  This argument is given
     after any '-o' option specifying the name of the output file.

     If you do not define this macro, the assembler is assumed to read
     its standard input if given no non-option arguments.  If your
     assembler cannot read standard input at all, use a '%{pipe:%e}'
     construct; see 'mips.h' for instance.

 -- Macro: LINK_SPEC
     A C string constant that tells the GCC driver program options to
     pass to the linker.  It can also specify how to translate options
     you give to GCC into options for GCC to pass to the linker.

     Do not define this macro if it does not need to do anything.

 -- Macro: LIB_SPEC
     Another C string constant used much like 'LINK_SPEC'.  The
     difference between the two is that 'LIB_SPEC' is used at the end of
     the command given to the linker.

     If this macro is not defined, a default is provided that loads the
     standard C library from the usual place.  See 'gcc.c'.

 -- Macro: LIBGCC_SPEC
     Another C string constant that tells the GCC driver program how and
     when to place a reference to 'libgcc.a' into the linker command
     line.  This constant is placed both before and after the value of
     'LIB_SPEC'.

     If this macro is not defined, the GCC driver provides a default
     that passes the string '-lgcc' to the linker.

 -- Macro: REAL_LIBGCC_SPEC
     By default, if 'ENABLE_SHARED_LIBGCC' is defined, the 'LIBGCC_SPEC'
     is not directly used by the driver program but is instead modified
     to refer to different versions of 'libgcc.a' depending on the
     values of the command line flags '-static', '-shared',
     '-static-libgcc', and '-shared-libgcc'.  On targets where these
     modifications are inappropriate, define 'REAL_LIBGCC_SPEC' instead.
     'REAL_LIBGCC_SPEC' tells the driver how to place a reference to
     'libgcc' on the link command line, but, unlike 'LIBGCC_SPEC', it is
     used unmodified.

 -- Macro: USE_LD_AS_NEEDED
     A macro that controls the modifications to 'LIBGCC_SPEC' mentioned
     in 'REAL_LIBGCC_SPEC'.  If nonzero, a spec will be generated that
     uses '--as-needed' or equivalent options and the shared 'libgcc' in
     place of the static exception handler library, when linking without
     any of '-static', '-static-libgcc', or '-shared-libgcc'.

 -- Macro: LINK_EH_SPEC
     If defined, this C string constant is added to 'LINK_SPEC'.  When
     'USE_LD_AS_NEEDED' is zero or undefined, it also affects the
     modifications to 'LIBGCC_SPEC' mentioned in 'REAL_LIBGCC_SPEC'.

 -- Macro: STARTFILE_SPEC
     Another C string constant used much like 'LINK_SPEC'.  The
     difference between the two is that 'STARTFILE_SPEC' is used at the
     very beginning of the command given to the linker.

     If this macro is not defined, a default is provided that loads the
     standard C startup file from the usual place.  See 'gcc.c'.

 -- Macro: ENDFILE_SPEC
     Another C string constant used much like 'LINK_SPEC'.  The
     difference between the two is that 'ENDFILE_SPEC' is used at the
     very end of the command given to the linker.

     Do not define this macro if it does not need to do anything.

 -- Macro: THREAD_MODEL_SPEC
     GCC '-v' will print the thread model GCC was configured to use.
     However, this doesn't work on platforms that are multilibbed on
     thread models, such as AIX 4.3.  On such platforms, define
     'THREAD_MODEL_SPEC' such that it evaluates to a string without
     blanks that names one of the recognized thread models.  '%*', the
     default value of this macro, will expand to the value of
     'thread_file' set in 'config.gcc'.

 -- Macro: SYSROOT_SUFFIX_SPEC
     Define this macro to add a suffix to the target sysroot when GCC is
     configured with a sysroot.  This will cause GCC to search for
     usr/lib, et al, within sysroot+suffix.

 -- Macro: SYSROOT_HEADERS_SUFFIX_SPEC
     Define this macro to add a headers_suffix to the target sysroot
     when GCC is configured with a sysroot.  This will cause GCC to pass
     the updated sysroot+headers_suffix to CPP, causing it to search for
     usr/include, et al, within sysroot+headers_suffix.

 -- Macro: EXTRA_SPECS
     Define this macro to provide additional specifications to put in
     the 'specs' file that can be used in various specifications like
     'CC1_SPEC'.

     The definition should be an initializer for an array of structures,
     containing a string constant, that defines the specification name,
     and a string constant that provides the specification.

     Do not define this macro if it does not need to do anything.

     'EXTRA_SPECS' is useful when an architecture contains several
     related targets, which have various '..._SPECS' which are similar
     to each other, and the maintainer would like one central place to
     keep these definitions.

     For example, the PowerPC System V.4 targets use 'EXTRA_SPECS' to
     define either '_CALL_SYSV' when the System V calling sequence is
     used or '_CALL_AIX' when the older AIX-based calling sequence is
     used.

     The 'config/rs6000/rs6000.h' target file defines:

          #define EXTRA_SPECS \
            { "cpp_sysv_default", CPP_SYSV_DEFAULT },

          #define CPP_SYS_DEFAULT ""

     The 'config/rs6000/sysv.h' target file defines:
          #undef CPP_SPEC
          #define CPP_SPEC \
          "%{posix: -D_POSIX_SOURCE } \
          %{mcall-sysv: -D_CALL_SYSV } \
          %{!mcall-sysv: %(cpp_sysv_default) } \
          %{msoft-float: -D_SOFT_FLOAT} %{mcpu=403: -D_SOFT_FLOAT}"

          #undef CPP_SYSV_DEFAULT
          #define CPP_SYSV_DEFAULT "-D_CALL_SYSV"

     while the 'config/rs6000/eabiaix.h' target file defines
     'CPP_SYSV_DEFAULT' as:

          #undef CPP_SYSV_DEFAULT
          #define CPP_SYSV_DEFAULT "-D_CALL_AIX"

 -- Macro: LINK_LIBGCC_SPECIAL_1
     Define this macro if the driver program should find the library
     'libgcc.a'.  If you do not define this macro, the driver program
     will pass the argument '-lgcc' to tell the linker to do the search.

 -- Macro: LINK_GCC_C_SEQUENCE_SPEC
     The sequence in which libgcc and libc are specified to the linker.
     By default this is '%G %L %G'.

 -- Macro: POST_LINK_SPEC
     Define this macro to add additional steps to be executed after
     linker.  The default value of this macro is empty string.

 -- Macro: LINK_COMMAND_SPEC
     A C string constant giving the complete command line need to
     execute the linker.  When you do this, you will need to update your
     port each time a change is made to the link command line within
     'gcc.c'.  Therefore, define this macro only if you need to
     completely redefine the command line for invoking the linker and
     there is no other way to accomplish the effect you need.
     Overriding this macro may be avoidable by overriding
     'LINK_GCC_C_SEQUENCE_SPEC' instead.

 -- Common Target Hook: bool TARGET_ALWAYS_STRIP_DOTDOT
     True if '..' components should always be removed from directory
     names computed relative to GCC's internal directories, false
     (default) if such components should be preserved and directory
     names containing them passed to other tools such as the linker.

 -- Macro: MULTILIB_DEFAULTS
     Define this macro as a C expression for the initializer of an array
     of string to tell the driver program which options are defaults for
     this target and thus do not need to be handled specially when using
     'MULTILIB_OPTIONS'.

     Do not define this macro if 'MULTILIB_OPTIONS' is not defined in
     the target makefile fragment or if none of the options listed in
     'MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.

 -- Macro: RELATIVE_PREFIX_NOT_LINKDIR
     Define this macro to tell 'gcc' that it should only translate a
     '-B' prefix into a '-L' linker option if the prefix indicates an
     absolute file name.

 -- Macro: MD_EXEC_PREFIX
     If defined, this macro is an additional prefix to try after
     'STANDARD_EXEC_PREFIX'.  'MD_EXEC_PREFIX' is not searched when the
     compiler is built as a cross compiler.  If you define
     'MD_EXEC_PREFIX', then be sure to add it to the list of directories
     used to find the assembler in 'configure.ac'.

 -- Macro: STANDARD_STARTFILE_PREFIX
     Define this macro as a C string constant if you wish to override
     the standard choice of 'libdir' as the default prefix to try when
     searching for startup files such as 'crt0.o'.
     'STANDARD_STARTFILE_PREFIX' is not searched when the compiler is
     built as a cross compiler.

 -- Macro: STANDARD_STARTFILE_PREFIX_1
     Define this macro as a C string constant if you wish to override
     the standard choice of '/lib' as a prefix to try after the default
     prefix when searching for startup files such as 'crt0.o'.
     'STANDARD_STARTFILE_PREFIX_1' is not searched when the compiler is
     built as a cross compiler.

 -- Macro: STANDARD_STARTFILE_PREFIX_2
     Define this macro as a C string constant if you wish to override
     the standard choice of '/lib' as yet another prefix to try after
     the default prefix when searching for startup files such as
     'crt0.o'.  'STANDARD_STARTFILE_PREFIX_2' is not searched when the
     compiler is built as a cross compiler.

 -- Macro: MD_STARTFILE_PREFIX
     If defined, this macro supplies an additional prefix to try after
     the standard prefixes.  'MD_EXEC_PREFIX' is not searched when the
     compiler is built as a cross compiler.

 -- Macro: MD_STARTFILE_PREFIX_1
     If defined, this macro supplies yet another prefix to try after the
     standard prefixes.  It is not searched when the compiler is built
     as a cross compiler.

 -- Macro: INIT_ENVIRONMENT
     Define this macro as a C string constant if you wish to set
     environment variables for programs called by the driver, such as
     the assembler and loader.  The driver passes the value of this
     macro to 'putenv' to initialize the necessary environment
     variables.

 -- Macro: LOCAL_INCLUDE_DIR
     Define this macro as a C string constant if you wish to override
     the standard choice of '/usr/local/include' as the default prefix
     to try when searching for local header files.  'LOCAL_INCLUDE_DIR'
     comes before 'NATIVE_SYSTEM_HEADER_DIR' (set in 'config.gcc',
     normally '/usr/include') in the search order.

     Cross compilers do not search either '/usr/local/include' or its
     replacement.

 -- Macro: NATIVE_SYSTEM_HEADER_COMPONENT
     The "component" corresponding to 'NATIVE_SYSTEM_HEADER_DIR'.  See
     'INCLUDE_DEFAULTS', below, for the description of components.  If
     you do not define this macro, no component is used.

 -- Macro: INCLUDE_DEFAULTS
     Define this macro if you wish to override the entire default search
     path for include files.  For a native compiler, the default search
     path usually consists of 'GCC_INCLUDE_DIR', 'LOCAL_INCLUDE_DIR',
     'GPLUSPLUS_INCLUDE_DIR', and 'NATIVE_SYSTEM_HEADER_DIR'.  In
     addition, 'GPLUSPLUS_INCLUDE_DIR' and 'GCC_INCLUDE_DIR' are defined
     automatically by 'Makefile', and specify private search areas for
     GCC.  The directory 'GPLUSPLUS_INCLUDE_DIR' is used only for C++
     programs.

     The definition should be an initializer for an array of structures.
     Each array element should have four elements: the directory name (a
     string constant), the component name (also a string constant), a
     flag for C++-only directories, and a flag showing that the includes
     in the directory don't need to be wrapped in 'extern 'C'' when
     compiling C++.  Mark the end of the array with a null element.

     The component name denotes what GNU package the include file is
     part of, if any, in all uppercase letters.  For example, it might
     be 'GCC' or 'BINUTILS'.  If the package is part of a
     vendor-supplied operating system, code the component name as '0'.

     For example, here is the definition used for VAX/VMS:

          #define INCLUDE_DEFAULTS \
          {                                       \
            { "GNU_GXX_INCLUDE:", "G++", 1, 1},   \
            { "GNU_CC_INCLUDE:", "GCC", 0, 0},    \
            { "SYS$SYSROOT:[SYSLIB.]", 0, 0, 0},  \
            { ".", 0, 0, 0},                      \
            { 0, 0, 0, 0}                         \
          }

 Here is the order of prefixes tried for exec files:

  1. Any prefixes specified by the user with '-B'.

  2. The environment variable 'GCC_EXEC_PREFIX' or, if 'GCC_EXEC_PREFIX'
     is not set and the compiler has not been installed in the
     configure-time PREFIX, the location in which the compiler has
     actually been installed.

  3. The directories specified by the environment variable
     'COMPILER_PATH'.

  4. The macro 'STANDARD_EXEC_PREFIX', if the compiler has been
     installed in the configured-time PREFIX.

  5. The location '/usr/libexec/gcc/', but only if this is a native
     compiler.

  6. The location '/usr/lib/gcc/', but only if this is a native
     compiler.

  7. The macro 'MD_EXEC_PREFIX', if defined, but only if this is a
     native compiler.

 Here is the order of prefixes tried for startfiles:

  1. Any prefixes specified by the user with '-B'.

  2. The environment variable 'GCC_EXEC_PREFIX' or its automatically
     determined value based on the installed toolchain location.

  3. The directories specified by the environment variable
     'LIBRARY_PATH' (or port-specific name; native only, cross compilers
     do not use this).

  4. The macro 'STANDARD_EXEC_PREFIX', but only if the toolchain is
     installed in the configured PREFIX or this is a native compiler.

  5. The location '/usr/lib/gcc/', but only if this is a native
     compiler.

  6. The macro 'MD_EXEC_PREFIX', if defined, but only if this is a
     native compiler.

  7. The macro 'MD_STARTFILE_PREFIX', if defined, but only if this is a
     native compiler, or we have a target system root.

  8. The macro 'MD_STARTFILE_PREFIX_1', if defined, but only if this is
     a native compiler, or we have a target system root.

  9. The macro 'STANDARD_STARTFILE_PREFIX', with any sysroot
     modifications.  If this path is relative it will be prefixed by
     'GCC_EXEC_PREFIX' and the machine suffix or 'STANDARD_EXEC_PREFIX'
     and the machine suffix.

  10. The macro 'STANDARD_STARTFILE_PREFIX_1', but only if this is a
     native compiler, or we have a target system root.  The default for
     this macro is '/lib/'.

  11. The macro 'STANDARD_STARTFILE_PREFIX_2', but only if this is a
     native compiler, or we have a target system root.  The default for
     this macro is '/usr/lib/'.

==============================================================================
File: gccint.info,  Node: |Run_time_Target|,  Next: |Per_Function_Data|,  Prev: |Driver|,  Up: |Target_Macros|
==============================================================================

                                                               *Run_time_Target*

18.3 Run-time Target Specification
----------------------------------

Here are run-time target specifications.

 -- Macro: TARGET_CPU_CPP_BUILTINS ()
     This function-like macro expands to a block of code that defines
     built-in preprocessor macros and assertions for the target CPU,
     using the functions 'builtin_define', 'builtin_define_std' and
     'builtin_assert'.  When the front end calls this macro it provides
     a trailing semicolon, and since it has finished command line option
     processing your code can use those results freely.

     'builtin_assert' takes a string in the form you pass to the
     command-line option '-A', such as 'cpu=mips', and creates the
     assertion.  'builtin_define' takes a string in the form accepted by
     option '-D' and unconditionally defines the macro.

     'builtin_define_std' takes a string representing the name of an
     object-like macro.  If it doesn't lie in the user's namespace,
     'builtin_define_std' defines it unconditionally.  Otherwise, it
     defines a version with two leading underscores, and another version
     with two leading and trailing underscores, and defines the original
     only if an ISO standard was not requested on the command line.  For
     example, passing 'unix' defines '__unix', '__unix__' and possibly
     'unix'; passing '_mips' defines '__mips', '__mips__' and possibly
     '_mips', and passing '_ABI64' defines only '_ABI64'.

     You can also test for the C dialect being compiled.  The variable
     'c_language' is set to one of 'clk_c', 'clk_cplusplus' or
     'clk_objective_c'.  Note that if we are preprocessing assembler,
     this variable will be 'clk_c' but the function-like macro
     'preprocessing_asm_p()' will return true, so you might want to
     check for that first.  If you need to check for strict ANSI, the
     variable 'flag_iso' can be used.  The function-like macro
     'preprocessing_trad_p()' can be used to check for traditional
     preprocessing.

 -- Macro: TARGET_OS_CPP_BUILTINS ()
     Similarly to 'TARGET_CPU_CPP_BUILTINS' but this macro is optional
     and is used for the target operating system instead.

 -- Macro: TARGET_OBJFMT_CPP_BUILTINS ()
     Similarly to 'TARGET_CPU_CPP_BUILTINS' but this macro is optional
     and is used for the target object format.  'elfos.h' uses this
     macro to define '__ELF__', so you probably do not need to define it
     yourself.

 -- Variable: extern int target_flags
     This variable is declared in 'options.h', which is included before
     any target-specific headers.

 -- Common Target Hook: int TARGET_DEFAULT_TARGET_FLAGS
     This variable specifies the initial value of 'target_flags'.  Its
     default setting is 0.

 -- Common Target Hook: bool TARGET_HANDLE_OPTION (struct gcc_options
          *OPTS, struct gcc_options *OPTS_SET, const struct
          cl_decoded_option *DECODED, location_t LOC)
     This hook is called whenever the user specifies one of the
     target-specific options described by the '.opt' definition files
     (*note Options::).  It has the opportunity to do some
     option-specific processing and should return true if the option is
     valid.  The default definition does nothing but return true.

     DECODED specifies the option and its arguments.  OPTS and OPTS_SET
     are the 'gcc_options' structures to be used for storing option
     state, and LOC is the location at which the option was passed
     ('UNKNOWN_LOCATION' except for options passed via attributes).

 -- C Target Hook: bool TARGET_HANDLE_C_OPTION (size_t CODE, const char
          *ARG, int VALUE)
     This target hook is called whenever the user specifies one of the
     target-specific C language family options described by the '.opt'
     definition files(*note Options::).  It has the opportunity to do
     some option-specific processing and should return true if the
     option is valid.  The arguments are like for
     'TARGET_HANDLE_OPTION'.  The default definition does nothing but
     return false.

     In general, you should use 'TARGET_HANDLE_OPTION' to handle
     options.  However, if processing an option requires routines that
     are only available in the C (and related language) front ends, then
     you should use 'TARGET_HANDLE_C_OPTION' instead.

 -- C Target Hook: tree TARGET_OBJC_CONSTRUCT_STRING_OBJECT (tree
          STRING)
     Targets may provide a string object type that can be used within
     and between C, C++ and their respective Objective-C dialects.  A
     string object might, for example, embed encoding and length
     information.  These objects are considered opaque to the compiler
     and handled as references.  An ideal implementation makes the
     composition of the string object match that of the Objective-C
     'NSString' ('NXString' for GNUStep), allowing efficient
     interworking between C-only and Objective-C code.  If a target
     implements string objects then this hook should return a reference
     to such an object constructed from the normal 'C' string
     representation provided in STRING.  At present, the hook is used by
     Objective-C only, to obtain a common-format string object when the
     target provides one.

 -- C Target Hook: void TARGET_OBJC_DECLARE_UNRESOLVED_CLASS_REFERENCE
          (const char *CLASSNAME)
     Declare that Objective C class CLASSNAME is referenced by the
     current TU.

 -- C Target Hook: void TARGET_OBJC_DECLARE_CLASS_DEFINITION (const char
          *CLASSNAME)
     Declare that Objective C class CLASSNAME is defined by the current
     TU.

 -- C Target Hook: bool TARGET_STRING_OBJECT_REF_TYPE_P (const_tree
          STRINGREF)
     If a target implements string objects then this hook should return
     'true' if STRINGREF is a valid reference to such an object.

 -- C Target Hook: void TARGET_CHECK_STRING_OBJECT_FORMAT_ARG (tree
          FORMAT_ARG, tree ARGS_LIST)
     If a target implements string objects then this hook should should
     provide a facility to check the function arguments in ARGS_LIST
     against the format specifiers in FORMAT_ARG where the type of
     FORMAT_ARG is one recognized as a valid string reference type.

 -- Target Hook: void TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE (void)
     This target function is similar to the hook
     'TARGET_OPTION_OVERRIDE' but is called when the optimize level is
     changed via an attribute or pragma or when it is reset at the end
     of the code affected by the attribute or pragma.  It is not called
     at the beginning of compilation when 'TARGET_OPTION_OVERRIDE' is
     called so if you want to perform these actions then, you should
     have 'TARGET_OPTION_OVERRIDE' call
     'TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE'.

 -- Macro: C_COMMON_OVERRIDE_OPTIONS
     This is similar to the 'TARGET_OPTION_OVERRIDE' hook but is only
     used in the C language frontends (C, Objective-C, C++,
     Objective-C++) and so can be used to alter option flag variables
     which only exist in those frontends.

 -- Common Target Hook: const struct default_options *
          TARGET_OPTION_OPTIMIZATION_TABLE
     Some machines may desire to change what optimizations are performed
     for various optimization levels.  This variable, if defined,
     describes options to enable at particular sets of optimization
     levels.  These options are processed once just after the
     optimization level is determined and before the remainder of the
     command options have been parsed, so may be overridden by other
     options passed explicitly.

     This processing is run once at program startup and when the
     optimization options are changed via '#pragma GCC optimize' or by
     using the 'optimize' attribute.

 -- Common Target Hook: void TARGET_OPTION_INIT_STRUCT (struct
          gcc_options *OPTS)
     Set target-dependent initial values of fields in OPTS.

 -- Macro: SWITCHABLE_TARGET
     Some targets need to switch between substantially different
     subtargets during compilation.  For example, the MIPS target has
     one subtarget for the traditional MIPS architecture and another for
     MIPS16.  Source code can switch between these two subarchitectures
     using the 'mips16' and 'nomips16' attributes.

     Such subtargets can differ in things like the set of available
     registers, the set of available instructions, the costs of various
     operations, and so on.  GCC caches a lot of this type of
     information in global variables, and recomputing them for each
     subtarget takes a significant amount of time.  The compiler
     therefore provides a facility for maintaining several versions of
     the global variables and quickly switching between them; see
     'target-globals.h' for details.

     Define this macro to 1 if your target needs this facility.  The
     default is 0.

 -- Target Hook: bool TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P
          (void)
     Returns true if the target supports IEEE 754 floating-point
     exceptions and rounding modes, false otherwise.  This is intended
     to relate to the 'float' and 'double' types, but not necessarily
     'long double'.  By default, returns true if the 'adddf3'
     instruction pattern is available and false otherwise, on the
     assumption that hardware floating point supports exceptions and
     rounding modes but software floating point does not.

==============================================================================
File: gccint.info,  Node: |Per_Function_Data|,  Next: |Storage_Layout|,  Prev: |Run_time_Target|,  Up: |Target_Macros|
==============================================================================

                                                             *Per_Function_Data*

18.4 Defining data structures for per-function information.
-----------------------------------------------------------

If the target needs to store information on a per-function basis, GCC
provides a macro and a couple of variables to allow this.  Note, just
using statics to store the information is a bad idea, since GCC supports
nested functions, so you can be halfway through encoding one function
when another one comes along.

 GCC defines a data structure called 'struct function' which contains
all of the data specific to an individual function.  This structure
contains a field called 'machine' whose type is 'struct machine_function
*', which can be used by targets to point to their own specific data.

 If a target needs per-function specific data it should define the type
'struct machine_function' and also the macro 'INIT_EXPANDERS'.  This
macro should be used to initialize the function pointer
'init_machine_status'.  This pointer is explained below.

 One typical use of per-function, target specific data is to create an
RTX to hold the register containing the function's return address.  This
RTX can then be used to implement the '__builtin_return_address'
function, for level 0.

 Note--earlier implementations of GCC used a single data area to hold
all of the per-function information.  Thus when processing of a nested
function began the old per-function data had to be pushed onto a stack,
and when the processing was finished, it had to be popped off the stack.
GCC used to provide function pointers called 'save_machine_status' and
'restore_machine_status' to handle the saving and restoring of the
target specific information.  Since the single data area approach is no
longer used, these pointers are no longer supported.

 -- Macro: INIT_EXPANDERS
     Macro called to initialize any target specific information.  This
     macro is called once per function, before generation of any RTL has
     begun.  The intention of this macro is to allow the initialization
     of the function pointer 'init_machine_status'.

 -- Variable: void (*)(struct function *) init_machine_status
     If this function pointer is non-'NULL' it will be called once per
     function, before function compilation starts, in order to allow the
     target to perform any target specific initialization of the 'struct
     function' structure.  It is intended that this would be used to
     initialize the 'machine' of that structure.

     'struct machine_function' structures are expected to be freed by
     GC.  Generally, any memory that they reference must be allocated by
     using GC allocation, including the structure itself.

==============================================================================
File: gccint.info,  Node: |Storage_Layout|,  Next: |Type_Layout|,  Prev: |Per_Function_Data|,  Up: |Target_Macros|
==============================================================================

                                                                *Storage_Layout*

18.5 Storage Layout
-------------------

Note that the definitions of the macros in this table which are sizes or
alignments measured in bits do not need to be constant.  They can be C
expressions that refer to static variables, such as the 'target_flags'.
*Note Run-time Target::.

 -- Macro: BITS_BIG_ENDIAN
     Define this macro to have the value 1 if the most significant bit
     in a byte has the lowest number; otherwise define it to have the
     value zero.  This means that bit-field instructions count from the
     most significant bit.  If the machine has no bit-field
     instructions, then this must still be defined, but it doesn't
     matter which value it is defined to.  This macro need not be a
     constant.

     This macro does not affect the way structure fields are packed into
     bytes or words; that is controlled by 'BYTES_BIG_ENDIAN'.

 -- Macro: BYTES_BIG_ENDIAN
     Define this macro to have the value 1 if the most significant byte
     in a word has the lowest number.  This macro need not be a
     constant.

 -- Macro: WORDS_BIG_ENDIAN
     Define this macro to have the value 1 if, in a multiword object,
     the most significant word has the lowest number.  This applies to
     both memory locations and registers; see 'REG_WORDS_BIG_ENDIAN' if
     the order of words in memory is not the same as the order in
     registers.  This macro need not be a constant.

 -- Macro: REG_WORDS_BIG_ENDIAN
     On some machines, the order of words in a multiword object differs
     between registers in memory.  In such a situation, define this
     macro to describe the order of words in a register.  The macro
     'WORDS_BIG_ENDIAN' controls the order of words in memory.

 -- Macro: FLOAT_WORDS_BIG_ENDIAN
     Define this macro to have the value 1 if 'DFmode', 'XFmode' or
     'TFmode' floating point numbers are stored in memory with the word
     containing the sign bit at the lowest address; otherwise define it
     to have the value 0.  This macro need not be a constant.

     You need not define this macro if the ordering is the same as for
     multi-word integers.

 -- Macro: BITS_PER_WORD
     Number of bits in a word.  If you do not define this macro, the
     default is 'BITS_PER_UNIT * UNITS_PER_WORD'.

 -- Macro: MAX_BITS_PER_WORD
     Maximum number of bits in a word.  If this is undefined, the
     default is 'BITS_PER_WORD'.  Otherwise, it is the constant value
     that is the largest value that 'BITS_PER_WORD' can have at
     run-time.

 -- Macro: UNITS_PER_WORD
     Number of storage units in a word; normally the size of a
     general-purpose register, a power of two from 1 or 8.

 -- Macro: MIN_UNITS_PER_WORD
     Minimum number of units in a word.  If this is undefined, the
     default is 'UNITS_PER_WORD'.  Otherwise, it is the constant value
     that is the smallest value that 'UNITS_PER_WORD' can have at
     run-time.

 -- Macro: POINTER_SIZE
     Width of a pointer, in bits.  You must specify a value no wider
     than the width of 'Pmode'.  If it is not equal to the width of
     'Pmode', you must define 'POINTERS_EXTEND_UNSIGNED'.  If you do not
     specify a value the default is 'BITS_PER_WORD'.

 -- Macro: POINTERS_EXTEND_UNSIGNED
     A C expression that determines how pointers should be extended from
     'ptr_mode' to either 'Pmode' or 'word_mode'.  It is greater than
     zero if pointers should be zero-extended, zero if they should be
     sign-extended, and negative if some other sort of conversion is
     needed.  In the last case, the extension is done by the target's
     'ptr_extend' instruction.

     You need not define this macro if the 'ptr_mode', 'Pmode' and
     'word_mode' are all the same width.

 -- Macro: PROMOTE_MODE (M, UNSIGNEDP, TYPE)
     A macro to update M and UNSIGNEDP when an object whose type is TYPE
     and which has the specified mode and signedness is to be stored in
     a register.  This macro is only called when TYPE is a scalar type.

     On most RISC machines, which only have operations that operate on a
     full register, define this macro to set M to 'word_mode' if M is an
     integer mode narrower than 'BITS_PER_WORD'.  In most cases, only
     integer modes should be widened because wider-precision
     floating-point operations are usually more expensive than their
     narrower counterparts.

     For most machines, the macro definition does not change UNSIGNEDP.
     However, some machines, have instructions that preferentially
     handle either signed or unsigned quantities of certain modes.  For
     example, on the DEC Alpha, 32-bit loads from memory and 32-bit add
     instructions sign-extend the result to 64 bits.  On such machines,
     set UNSIGNEDP according to which kind of extension is more
     efficient.

     Do not define this macro if it would never modify M.

 -- Target Hook: enum flt_eval_method TARGET_C_EXCESS_PRECISION (enum
          excess_precision_type TYPE)
     Return a value, with the same meaning as the C99 macro
     'FLT_EVAL_METHOD' that describes which excess precision should be
     applied.  TYPE is either 'EXCESS_PRECISION_TYPE_IMPLICIT',
     'EXCESS_PRECISION_TYPE_FAST', or 'EXCESS_PRECISION_TYPE_STANDARD'.
     For 'EXCESS_PRECISION_TYPE_IMPLICIT', the target should return
     which precision and range operations will be implictly evaluated in
     regardless of the excess precision explicitly added.  For
     'EXCESS_PRECISION_TYPE_STANDARD' and 'EXCESS_PRECISION_TYPE_FAST',
     the target should return the explicit excess precision that should
     be added depending on the value set for
     '-fexcess-precision=[standard|fast]'.  Note that unpredictable
     explicit excess precision does not make sense, so a target should
     never return 'FLT_EVAL_METHOD_UNPREDICTABLE' when TYPE is
     'EXCESS_PRECISION_TYPE_STANDARD' or 'EXCESS_PRECISION_TYPE_FAST'.

 -- Target Hook: machine_mode TARGET_PROMOTE_FUNCTION_MODE (const_tree
          TYPE, machine_mode MODE, int *PUNSIGNEDP, const_tree FUNTYPE,
          int FOR_RETURN)
     Like 'PROMOTE_MODE', but it is applied to outgoing function
     arguments or function return values.  The target hook should return
     the new mode and possibly change '*PUNSIGNEDP' if the promotion
     should change signedness.  This function is called only for scalar
     _or pointer_ types.

     FOR_RETURN allows to distinguish the promotion of arguments and
     return values.  If it is '1', a return value is being promoted and
     'TARGET_FUNCTION_VALUE' must perform the same promotions done here.
     If it is '2', the returned mode should be that of the register in
     which an incoming parameter is copied, or the outgoing result is
     computed; then the hook should return the same mode as
     'promote_mode', though the signedness may be different.

     TYPE can be NULL when promoting function arguments of libcalls.

     The default is to not promote arguments and return values.  You can
     also define the hook to
     'default_promote_function_mode_always_promote' if you would like to
     apply the same rules given by 'PROMOTE_MODE'.

 -- Macro: PARM_BOUNDARY
     Normal alignment required for function parameters on the stack, in
     bits.  All stack parameters receive at least this much alignment
     regardless of data type.  On most machines, this is the same as the
     size of an integer.

 -- Macro: STACK_BOUNDARY
     Define this macro to the minimum alignment enforced by hardware for
     the stack pointer on this machine.  The definition is a C
     expression for the desired alignment (measured in bits).  This
     value is used as a default if 'PREFERRED_STACK_BOUNDARY' is not
     defined.  On most machines, this should be the same as
     'PARM_BOUNDARY'.

 -- Macro: PREFERRED_STACK_BOUNDARY
     Define this macro if you wish to preserve a certain alignment for
     the stack pointer, greater than what the hardware enforces.  The
     definition is a C expression for the desired alignment (measured in
     bits).  This macro must evaluate to a value equal to or larger than
     'STACK_BOUNDARY'.

 -- Macro: INCOMING_STACK_BOUNDARY
     Define this macro if the incoming stack boundary may be different
     from 'PREFERRED_STACK_BOUNDARY'.  This macro must evaluate to a
     value equal to or larger than 'STACK_BOUNDARY'.

 -- Macro: FUNCTION_BOUNDARY
     Alignment required for a function entry point, in bits.

 -- Macro: BIGGEST_ALIGNMENT
     Biggest alignment that any data type can require on this machine,
     in bits.  Note that this is not the biggest alignment that is
     supported, just the biggest alignment that, when violated, may
     cause a fault.

 -- Target Hook: HOST_WIDE_INT TARGET_ABSOLUTE_BIGGEST_ALIGNMENT
     If defined, this target hook specifies the absolute biggest
     alignment that a type or variable can have on this machine,
     otherwise, 'BIGGEST_ALIGNMENT' is used.

 -- Macro: MALLOC_ABI_ALIGNMENT
     Alignment, in bits, a C conformant malloc implementation has to
     provide.  If not defined, the default value is 'BITS_PER_WORD'.

 -- Macro: ATTRIBUTE_ALIGNED_VALUE
     Alignment used by the '__attribute__ ((aligned))' construct.  If
     not defined, the default value is 'BIGGEST_ALIGNMENT'.

 -- Macro: MINIMUM_ATOMIC_ALIGNMENT
     If defined, the smallest alignment, in bits, that can be given to
     an object that can be referenced in one operation, without
     disturbing any nearby object.  Normally, this is 'BITS_PER_UNIT',
     but may be larger on machines that don't have byte or half-word
     store operations.

 -- Macro: BIGGEST_FIELD_ALIGNMENT
     Biggest alignment that any structure or union field can require on
     this machine, in bits.  If defined, this overrides
     'BIGGEST_ALIGNMENT' for structure and union fields only, unless the
     field alignment has been set by the '__attribute__ ((aligned (N)))'
     construct.

 -- Macro: ADJUST_FIELD_ALIGN (FIELD, TYPE, COMPUTED)
     An expression for the alignment of a structure field FIELD of type
     TYPE if the alignment computed in the usual way (including applying
     of 'BIGGEST_ALIGNMENT' and 'BIGGEST_FIELD_ALIGNMENT' to the
     alignment) is COMPUTED.  It overrides alignment only if the field
     alignment has not been set by the '__attribute__ ((aligned (N)))'
     construct.  Note that FIELD may be 'NULL_TREE' in case we just
     query for the minimum alignment of a field of type TYPE in
     structure context.

 -- Macro: MAX_STACK_ALIGNMENT
     Biggest stack alignment guaranteed by the backend.  Use this macro
     to specify the maximum alignment of a variable on stack.

     If not defined, the default value is 'STACK_BOUNDARY'.

 -- Macro: MAX_OFILE_ALIGNMENT
     Biggest alignment supported by the object file format of this
     machine.  Use this macro to limit the alignment which can be
     specified using the '__attribute__ ((aligned (N)))' construct for
     functions and objects with static storage duration.  The alignment
     of automatic objects may exceed the object file format maximum up
     to the maximum supported by GCC. If not defined, the default value
     is 'BIGGEST_ALIGNMENT'.

     On systems that use ELF, the default (in 'config/elfos.h') is the
     largest supported 32-bit ELF section alignment representable on a
     32-bit host e.g. '(((uint64_t) 1 << 28) * 8)'.  On 32-bit ELF the
     largest supported section alignment in bits is '(0x80000000 * 8)',
     but this is not representable on 32-bit hosts.

 -- Target Hook: HOST_WIDE_INT TARGET_STATIC_RTX_ALIGNMENT (machine_mode
          MODE)
     This hook returns the preferred alignment in bits for a
     statically-allocated rtx, such as a constant pool entry.  MODE is
     the mode of the rtx.  The default implementation returns
     'GET_MODE_ALIGNMENT (MODE)'.

 -- Macro: DATA_ALIGNMENT (TYPE, BASIC-ALIGN)
     If defined, a C expression to compute the alignment for a variable
     in the static store.  TYPE is the data type, and BASIC-ALIGN is the
     alignment that the object would ordinarily have.  The value of this
     macro is used instead of that alignment to align the object.

     If this macro is not defined, then BASIC-ALIGN is used.

     One use of this macro is to increase alignment of medium-size data
     to make it all fit in fewer cache lines.  Another is to cause
     character arrays to be word-aligned so that 'strcpy' calls that
     copy constants to character arrays can be done inline.

 -- Macro: DATA_ABI_ALIGNMENT (TYPE, BASIC-ALIGN)
     Similar to 'DATA_ALIGNMENT', but for the cases where the ABI
     mandates some alignment increase, instead of optimization only
     purposes.  E.g. AMD x86-64 psABI says that variables with array
     type larger than 15 bytes must be aligned to 16 byte boundaries.

     If this macro is not defined, then BASIC-ALIGN is used.

 -- Target Hook: HOST_WIDE_INT TARGET_CONSTANT_ALIGNMENT (const_tree
          CONSTANT, HOST_WIDE_INT BASIC_ALIGN)
     This hook returns the alignment in bits of a constant that is being
     placed in memory.  CONSTANT is the constant and BASIC_ALIGN is the
     alignment that the object would ordinarily have.

     The default definition just returns BASIC_ALIGN.

     The typical use of this hook is to increase alignment for string
     constants to be word aligned so that 'strcpy' calls that copy
     constants can be done inline.  The function
     'constant_alignment_word_strings' provides such a definition.

 -- Macro: LOCAL_ALIGNMENT (TYPE, BASIC-ALIGN)
     If defined, a C expression to compute the alignment for a variable
     in the local store.  TYPE is the data type, and BASIC-ALIGN is the
     alignment that the object would ordinarily have.  The value of this
     macro is used instead of that alignment to align the object.

     If this macro is not defined, then BASIC-ALIGN is used.

     One use of this macro is to increase alignment of medium-size data
     to make it all fit in fewer cache lines.

     If the value of this macro has a type, it should be an unsigned
     type.

 -- Target Hook: HOST_WIDE_INT TARGET_VECTOR_ALIGNMENT (const_tree TYPE)
     This hook can be used to define the alignment for a vector of type
     TYPE, in order to comply with a platform ABI. The default is to
     require natural alignment for vector types.  The alignment returned
     by this hook must be a power-of-two multiple of the default
     alignment of the vector element type.

 -- Macro: STACK_SLOT_ALIGNMENT (TYPE, MODE, BASIC-ALIGN)
     If defined, a C expression to compute the alignment for stack slot.
     TYPE is the data type, MODE is the widest mode available, and
     BASIC-ALIGN is the alignment that the slot would ordinarily have.
     The value of this macro is used instead of that alignment to align
     the slot.

     If this macro is not defined, then BASIC-ALIGN is used when TYPE is
     'NULL'.  Otherwise, 'LOCAL_ALIGNMENT' will be used.

     This macro is to set alignment of stack slot to the maximum
     alignment of all possible modes which the slot may have.

     If the value of this macro has a type, it should be an unsigned
     type.

 -- Macro: LOCAL_DECL_ALIGNMENT (DECL)
     If defined, a C expression to compute the alignment for a local
     variable DECL.

     If this macro is not defined, then 'LOCAL_ALIGNMENT (TREE_TYPE
     (DECL), DECL_ALIGN (DECL))' is used.

     One use of this macro is to increase alignment of medium-size data
     to make it all fit in fewer cache lines.

     If the value of this macro has a type, it should be an unsigned
     type.

 -- Macro: MINIMUM_ALIGNMENT (EXP, MODE, ALIGN)
     If defined, a C expression to compute the minimum required
     alignment for dynamic stack realignment purposes for EXP (a type or
     decl), MODE, assuming normal alignment ALIGN.

     If this macro is not defined, then ALIGN will be used.

 -- Macro: EMPTY_FIELD_BOUNDARY
     Alignment in bits to be given to a structure bit-field that follows
     an empty field such as 'int : 0;'.

     If 'PCC_BITFIELD_TYPE_MATTERS' is true, it overrides this macro.

 -- Macro: STRUCTURE_SIZE_BOUNDARY
     Number of bits which any structure or union's size must be a
     multiple of.  Each structure or union's size is rounded up to a
     multiple of this.

     If you do not define this macro, the default is the same as
     'BITS_PER_UNIT'.

 -- Macro: STRICT_ALIGNMENT
     Define this macro to be the value 1 if instructions will fail to
     work if given data not on the nominal alignment.  If instructions
     will merely go slower in that case, define this macro as 0.

 -- Macro: PCC_BITFIELD_TYPE_MATTERS
     Define this if you wish to imitate the way many other C compilers
     handle alignment of bit-fields and the structures that contain
     them.

     The behavior is that the type written for a named bit-field ('int',
     'short', or other integer type) imposes an alignment for the entire
     structure, as if the structure really did contain an ordinary field
     of that type.  In addition, the bit-field is placed within the
     structure so that it would fit within such a field, not crossing a
     boundary for it.

     Thus, on most machines, a named bit-field whose type is written as
     'int' would not cross a four-byte boundary, and would force
     four-byte alignment for the whole structure.  (The alignment used
     may not be four bytes; it is controlled by the other alignment
     parameters.)

     An unnamed bit-field will not affect the alignment of the
     containing structure.

     If the macro is defined, its definition should be a C expression; a
     nonzero value for the expression enables this behavior.

     Note that if this macro is not defined, or its value is zero, some
     bit-fields may cross more than one alignment boundary.  The
     compiler can support such references if there are 'insv', 'extv',
     and 'extzv' insns that can directly reference memory.

     The other known way of making bit-fields work is to define
     'STRUCTURE_SIZE_BOUNDARY' as large as 'BIGGEST_ALIGNMENT'.  Then
     every structure can be accessed with fullwords.

     Unless the machine has bit-field instructions or you define
     'STRUCTURE_SIZE_BOUNDARY' that way, you must define
     'PCC_BITFIELD_TYPE_MATTERS' to have a nonzero value.

     If your aim is to make GCC use the same conventions for laying out
     bit-fields as are used by another compiler, here is how to
     investigate what the other compiler does.  Compile and run this
     program:

          struct foo1
          {
            char x;
            char :0;
            char y;
          };

          struct foo2
          {
            char x;
            int :0;
            char y;
          };

          main ()
          {
            printf ("Size of foo1 is %d\n",
                    sizeof (struct foo1));
            printf ("Size of foo2 is %d\n",
                    sizeof (struct foo2));
            exit (0);
          }

     If this prints 2 and 5, then the compiler's behavior is what you
     would get from 'PCC_BITFIELD_TYPE_MATTERS'.

 -- Macro: BITFIELD_NBYTES_LIMITED
     Like 'PCC_BITFIELD_TYPE_MATTERS' except that its effect is limited
     to aligning a bit-field within the structure.

 -- Target Hook: bool TARGET_ALIGN_ANON_BITFIELD (void)
     When 'PCC_BITFIELD_TYPE_MATTERS' is true this hook will determine
     whether unnamed bitfields affect the alignment of the containing
     structure.  The hook should return true if the structure should
     inherit the alignment requirements of an unnamed bitfield's type.

 -- Target Hook: bool TARGET_NARROW_VOLATILE_BITFIELD (void)
     This target hook should return 'true' if accesses to volatile
     bitfields should use the narrowest mode possible.  It should return
     'false' if these accesses should use the bitfield container type.

     The default is 'false'.

 -- Target Hook: bool TARGET_MEMBER_TYPE_FORCES_BLK (const_tree FIELD,
          machine_mode MODE)
     Return true if a structure, union or array containing FIELD should
     be accessed using 'BLKMODE'.

     If FIELD is the only field in the structure, MODE is its mode,
     otherwise MODE is VOIDmode.  MODE is provided in the case where
     structures of one field would require the structure's mode to
     retain the field's mode.

     Normally, this is not needed.

 -- Macro: ROUND_TYPE_ALIGN (TYPE, COMPUTED, SPECIFIED)
     Define this macro as an expression for the alignment of a type
     (given by TYPE as a tree node) if the alignment computed in the
     usual way is COMPUTED and the alignment explicitly specified was
     SPECIFIED.

     The default is to use SPECIFIED if it is larger; otherwise, use the
     smaller of COMPUTED and 'BIGGEST_ALIGNMENT'

 -- Macro: MAX_FIXED_MODE_SIZE
     An integer expression for the size in bits of the largest integer
     machine mode that should actually be used.  All integer machine
     modes of this size or smaller can be used for structures and unions
     with the appropriate sizes.  If this macro is undefined,
     'GET_MODE_BITSIZE (DImode)' is assumed.

 -- Macro: STACK_SAVEAREA_MODE (SAVE_LEVEL)
     If defined, an expression of type 'machine_mode' that specifies the
     mode of the save area operand of a 'save_stack_LEVEL' named pattern
     (*note Standard Names::).  SAVE_LEVEL is one of 'SAVE_BLOCK',
     'SAVE_FUNCTION', or 'SAVE_NONLOCAL' and selects which of the three
     named patterns is having its mode specified.

     You need not define this macro if it always returns 'Pmode'.  You
     would most commonly define this macro if the 'save_stack_LEVEL'
     patterns need to support both a 32- and a 64-bit mode.

 -- Macro: STACK_SIZE_MODE
     If defined, an expression of type 'machine_mode' that specifies the
     mode of the size increment operand of an 'allocate_stack' named
     pattern (*note Standard Names::).

     You need not define this macro if it always returns 'word_mode'.
     You would most commonly define this macro if the 'allocate_stack'
     pattern needs to support both a 32- and a 64-bit mode.

 -- Target Hook: scalar_int_mode TARGET_LIBGCC_CMP_RETURN_MODE (void)
     This target hook should return the mode to be used for the return
     value of compare instructions expanded to libgcc calls.  If not
     defined 'word_mode' is returned which is the right choice for a
     majority of targets.

 -- Target Hook: scalar_int_mode TARGET_LIBGCC_SHIFT_COUNT_MODE (void)
     This target hook should return the mode to be used for the shift
     count operand of shift instructions expanded to libgcc calls.  If
     not defined 'word_mode' is returned which is the right choice for a
     majority of targets.

 -- Target Hook: scalar_int_mode TARGET_UNWIND_WORD_MODE (void)
     Return machine mode to be used for '_Unwind_Word' type.  The
     default is to use 'word_mode'.

 -- Target Hook: bool TARGET_MS_BITFIELD_LAYOUT_P (const_tree
          RECORD_TYPE)
     This target hook returns 'true' if bit-fields in the given
     RECORD_TYPE are to be laid out following the rules of Microsoft
     Visual C/C++, namely: (i) a bit-field won't share the same storage
     unit with the previous bit-field if their underlying types have
     different sizes, and the bit-field will be aligned to the highest
     alignment of the underlying types of itself and of the previous
     bit-field; (ii) a zero-sized bit-field will affect the alignment of
     the whole enclosing structure, even if it is unnamed; except that
     (iii) a zero-sized bit-field will be disregarded unless it follows
     another bit-field of nonzero size.  If this hook returns 'true',
     other macros that control bit-field layout are ignored.

     When a bit-field is inserted into a packed record, the whole size
     of the underlying type is used by one or more same-size adjacent
     bit-fields (that is, if its long:3, 32 bits is used in the record,
     and any additional adjacent long bit-fields are packed into the
     same chunk of 32 bits.  However, if the size changes, a new field
     of that size is allocated).  In an unpacked record, this is the
     same as using alignment, but not equivalent when packing.

     If both MS bit-fields and '__attribute__((packed))' are used, the
     latter will take precedence.  If '__attribute__((packed))' is used
     on a single field when MS bit-fields are in use, it will take
     precedence for that field, but the alignment of the rest of the
     structure may affect its placement.

 -- Target Hook: bool TARGET_DECIMAL_FLOAT_SUPPORTED_P (void)
     Returns true if the target supports decimal floating point.

 -- Target Hook: bool TARGET_FIXED_POINT_SUPPORTED_P (void)
     Returns true if the target supports fixed-point arithmetic.

 -- Target Hook: void TARGET_EXPAND_TO_RTL_HOOK (void)
     This hook is called just before expansion into rtl, allowing the
     target to perform additional initializations or analysis before the
     expansion.  For example, the rs6000 port uses it to allocate a
     scratch stack slot for use in copying SDmode values between memory
     and floating point registers whenever the function being expanded
     has any SDmode usage.

 -- Target Hook: void TARGET_INSTANTIATE_DECLS (void)
     This hook allows the backend to perform additional instantiations
     on rtl that are not actually in any insns yet, but will be later.

 -- Target Hook: const char * TARGET_MANGLE_TYPE (const_tree TYPE)
     If your target defines any fundamental types, or any types your
     target uses should be mangled differently from the default, define
     this hook to return the appropriate encoding for these types as
     part of a C++ mangled name.  The TYPE argument is the tree
     structure representing the type to be mangled.  The hook may be
     applied to trees which are not target-specific fundamental types;
     it should return 'NULL' for all such types, as well as arguments it
     does not recognize.  If the return value is not 'NULL', it must
     point to a statically-allocated string constant.

     Target-specific fundamental types might be new fundamental types or
     qualified versions of ordinary fundamental types.  Encode new
     fundamental types as 'u N NAME', where NAME is the name used for
     the type in source code, and N is the length of NAME in decimal.
     Encode qualified versions of ordinary types as 'U N NAME CODE',
     where NAME is the name used for the type qualifier in source code,
     N is the length of NAME as above, and CODE is the code used to
     represent the unqualified version of this type.  (See
     'write_builtin_type' in 'cp/mangle.c' for the list of codes.)  In
     both cases the spaces are for clarity; do not include any spaces in
     your string.

     This hook is applied to types prior to typedef resolution.  If the
     mangled name for a particular type depends only on that type's main
     variant, you can perform typedef resolution yourself using
     'TYPE_MAIN_VARIANT' before mangling.

     The default version of this hook always returns 'NULL', which is
     appropriate for a target that does not define any new fundamental
     types.

==============================================================================
File: gccint.info,  Node: |Type_Layout|,  Next: |Registers|,  Prev: |Storage_Layout|,  Up: |Target_Macros|
==============================================================================

                                                                   *Type_Layout*

18.6 Layout of Source Language Data Types
-----------------------------------------

These macros define the sizes and other characteristics of the standard
basic data types used in programs being compiled.  Unlike the macros in
the previous section, these apply to specific features of C and related
languages, rather than to fundamental aspects of storage layout.

 -- Macro: INT_TYPE_SIZE
     A C expression for the size in bits of the type 'int' on the target
     machine.  If you don't define this, the default is one word.

 -- Macro: SHORT_TYPE_SIZE
     A C expression for the size in bits of the type 'short' on the
     target machine.  If you don't define this, the default is half a
     word.  (If this would be less than one storage unit, it is rounded
     up to one unit.)

 -- Macro: LONG_TYPE_SIZE
     A C expression for the size in bits of the type 'long' on the
     target machine.  If you don't define this, the default is one word.

 -- Macro: ADA_LONG_TYPE_SIZE
     On some machines, the size used for the Ada equivalent of the type
     'long' by a native Ada compiler differs from that used by C.  In
     that situation, define this macro to be a C expression to be used
     for the size of that type.  If you don't define this, the default
     is the value of 'LONG_TYPE_SIZE'.

 -- Macro: LONG_LONG_TYPE_SIZE
     A C expression for the size in bits of the type 'long long' on the
     target machine.  If you don't define this, the default is two
     words.  If you want to support GNU Ada on your machine, the value
     of this macro must be at least 64.

 -- Macro: CHAR_TYPE_SIZE
     A C expression for the size in bits of the type 'char' on the
     target machine.  If you don't define this, the default is
     'BITS_PER_UNIT'.

 -- Macro: BOOL_TYPE_SIZE
     A C expression for the size in bits of the C++ type 'bool' and C99
     type '_Bool' on the target machine.  If you don't define this, and
     you probably shouldn't, the default is 'CHAR_TYPE_SIZE'.

 -- Macro: FLOAT_TYPE_SIZE
     A C expression for the size in bits of the type 'float' on the
     target machine.  If you don't define this, the default is one word.

 -- Macro: DOUBLE_TYPE_SIZE
     A C expression for the size in bits of the type 'double' on the
     target machine.  If you don't define this, the default is two
     words.

 -- Macro: LONG_DOUBLE_TYPE_SIZE
     A C expression for the size in bits of the type 'long double' on
     the target machine.  If you don't define this, the default is two
     words.

 -- Macro: SHORT_FRACT_TYPE_SIZE
     A C expression for the size in bits of the type 'short _Fract' on
     the target machine.  If you don't define this, the default is
     'BITS_PER_UNIT'.

 -- Macro: FRACT_TYPE_SIZE
     A C expression for the size in bits of the type '_Fract' on the
     target machine.  If you don't define this, the default is
     'BITS_PER_UNIT * 2'.

 -- Macro: LONG_FRACT_TYPE_SIZE
     A C expression for the size in bits of the type 'long _Fract' on
     the target machine.  If you don't define this, the default is
     'BITS_PER_UNIT * 4'.

 -- Macro: LONG_LONG_FRACT_TYPE_SIZE
     A C expression for the size in bits of the type 'long long _Fract'
     on the target machine.  If you don't define this, the default is
     'BITS_PER_UNIT * 8'.

 -- Macro: SHORT_ACCUM_TYPE_SIZE
     A C expression for the size in bits of the type 'short _Accum' on
     the target machine.  If you don't define this, the default is
     'BITS_PER_UNIT * 2'.

 -- Macro: ACCUM_TYPE_SIZE
     A C expression for the size in bits of the type '_Accum' on the
     target machine.  If you don't define this, the default is
     'BITS_PER_UNIT * 4'.

 -- Macro: LONG_ACCUM_TYPE_SIZE
     A C expression for the size in bits of the type 'long _Accum' on
     the target machine.  If you don't define this, the default is
     'BITS_PER_UNIT * 8'.

 -- Macro: LONG_LONG_ACCUM_TYPE_SIZE
     A C expression for the size in bits of the type 'long long _Accum'
     on the target machine.  If you don't define this, the default is
     'BITS_PER_UNIT * 16'.

 -- Macro: LIBGCC2_GNU_PREFIX
     This macro corresponds to the 'TARGET_LIBFUNC_GNU_PREFIX' target
     hook and should be defined if that hook is overriden to be true.
     It causes function names in libgcc to be changed to use a '__gnu_'
     prefix for their name rather than the default '__'.  A port which
     uses this macro should also arrange to use 't-gnu-prefix' in the
     libgcc 'config.host'.

 -- Macro: WIDEST_HARDWARE_FP_SIZE
     A C expression for the size in bits of the widest floating-point
     format supported by the hardware.  If you define this macro, you
     must specify a value less than or equal to the value of
     'LONG_DOUBLE_TYPE_SIZE'.  If you do not define this macro, the
     value of 'LONG_DOUBLE_TYPE_SIZE' is the default.

 -- Macro: DEFAULT_SIGNED_CHAR
     An expression whose value is 1 or 0, according to whether the type
     'char' should be signed or unsigned by default.  The user can
     always override this default with the options '-fsigned-char' and
     '-funsigned-char'.

 -- Target Hook: bool TARGET_DEFAULT_SHORT_ENUMS (void)
     This target hook should return true if the compiler should give an
     'enum' type only as many bytes as it takes to represent the range
     of possible values of that type.  It should return false if all
     'enum' types should be allocated like 'int'.

     The default is to return false.

 -- Macro: SIZE_TYPE
     A C expression for a string describing the name of the data type to
     use for size values.  The typedef name 'size_t' is defined using
     the contents of the string.

     The string can contain more than one keyword.  If so, separate them
     with spaces, and write first any length keyword, then 'unsigned' if
     appropriate, and finally 'int'.  The string must exactly match one
     of the data type names defined in the function
     'c_common_nodes_and_builtins' in the file 'c-family/c-common.c'.
     You may not omit 'int' or change the order--that would cause the
     compiler to crash on startup.

     If you don't define this macro, the default is '"long unsigned
     int"'.

 -- Macro: SIZETYPE
     GCC defines internal types ('sizetype', 'ssizetype', 'bitsizetype'
     and 'sbitsizetype') for expressions dealing with size.  This macro
     is a C expression for a string describing the name of the data type
     from which the precision of 'sizetype' is extracted.

     The string has the same restrictions as 'SIZE_TYPE' string.

     If you don't define this macro, the default is 'SIZE_TYPE'.

 -- Macro: PTRDIFF_TYPE
     A C expression for a string describing the name of the data type to
     use for the result of subtracting two pointers.  The typedef name
     'ptrdiff_t' is defined using the contents of the string.  See
     'SIZE_TYPE' above for more information.

     If you don't define this macro, the default is '"long int"'.

 -- Macro: WCHAR_TYPE
     A C expression for a string describing the name of the data type to
     use for wide characters.  The typedef name 'wchar_t' is defined
     using the contents of the string.  See 'SIZE_TYPE' above for more
     information.

     If you don't define this macro, the default is '"int"'.

 -- Macro: WCHAR_TYPE_SIZE
     A C expression for the size in bits of the data type for wide
     characters.  This is used in 'cpp', which cannot make use of
     'WCHAR_TYPE'.

 -- Macro: WINT_TYPE
     A C expression for a string describing the name of the data type to
     use for wide characters passed to 'printf' and returned from
     'getwc'.  The typedef name 'wint_t' is defined using the contents
     of the string.  See 'SIZE_TYPE' above for more information.

     If you don't define this macro, the default is '"unsigned int"'.

 -- Macro: INTMAX_TYPE
     A C expression for a string describing the name of the data type
     that can represent any value of any standard or extended signed
     integer type.  The typedef name 'intmax_t' is defined using the
     contents of the string.  See 'SIZE_TYPE' above for more
     information.

     If you don't define this macro, the default is the first of
     '"int"', '"long int"', or '"long long int"' that has as much
     precision as 'long long int'.

 -- Macro: UINTMAX_TYPE
     A C expression for a string describing the name of the data type
     that can represent any value of any standard or extended unsigned
     integer type.  The typedef name 'uintmax_t' is defined using the
     contents of the string.  See 'SIZE_TYPE' above for more
     information.

     If you don't define this macro, the default is the first of
     '"unsigned int"', '"long unsigned int"', or '"long long unsigned
     int"' that has as much precision as 'long long unsigned int'.

 -- Macro: SIG_ATOMIC_TYPE
 -- Macro: INT8_TYPE
 -- Macro: INT16_TYPE
 -- Macro: INT32_TYPE
 -- Macro: INT64_TYPE
 -- Macro: UINT8_TYPE
 -- Macro: UINT16_TYPE
 -- Macro: UINT32_TYPE
 -- Macro: UINT64_TYPE
 -- Macro: INT_LEAST8_TYPE
 -- Macro: INT_LEAST16_TYPE
 -- Macro: INT_LEAST32_TYPE
 -- Macro: INT_LEAST64_TYPE
 -- Macro: UINT_LEAST8_TYPE
 -- Macro: UINT_LEAST16_TYPE
 -- Macro: UINT_LEAST32_TYPE
 -- Macro: UINT_LEAST64_TYPE
 -- Macro: INT_FAST8_TYPE
 -- Macro: INT_FAST16_TYPE
 -- Macro: INT_FAST32_TYPE
 -- Macro: INT_FAST64_TYPE
 -- Macro: UINT_FAST8_TYPE
 -- Macro: UINT_FAST16_TYPE
 -- Macro: UINT_FAST32_TYPE
 -- Macro: UINT_FAST64_TYPE
 -- Macro: INTPTR_TYPE
 -- Macro: UINTPTR_TYPE
     C expressions for the standard types 'sig_atomic_t', 'int8_t',
     'int16_t', 'int32_t', 'int64_t', 'uint8_t', 'uint16_t', 'uint32_t',
     'uint64_t', 'int_least8_t', 'int_least16_t', 'int_least32_t',
     'int_least64_t', 'uint_least8_t', 'uint_least16_t',
     'uint_least32_t', 'uint_least64_t', 'int_fast8_t', 'int_fast16_t',
     'int_fast32_t', 'int_fast64_t', 'uint_fast8_t', 'uint_fast16_t',
     'uint_fast32_t', 'uint_fast64_t', 'intptr_t', and 'uintptr_t'.  See
     'SIZE_TYPE' above for more information.

     If any of these macros evaluates to a null pointer, the
     corresponding type is not supported; if GCC is configured to
     provide '<stdint.h>' in such a case, the header provided may not
     conform to C99, depending on the type in question.  The defaults
     for all of these macros are null pointers.

 -- Macro: TARGET_PTRMEMFUNC_VBIT_LOCATION
     The C++ compiler represents a pointer-to-member-function with a
     struct that looks like:

            struct {
              union {
                void (*fn)();
                ptrdiff_t vtable_index;
              };
              ptrdiff_t delta;
            };

     The C++ compiler must use one bit to indicate whether the function
     that will be called through a pointer-to-member-function is
     virtual.  Normally, we assume that the low-order bit of a function
     pointer must always be zero.  Then, by ensuring that the
     vtable_index is odd, we can distinguish which variant of the union
     is in use.  But, on some platforms function pointers can be odd,
     and so this doesn't work.  In that case, we use the low-order bit
     of the 'delta' field, and shift the remainder of the 'delta' field
     to the left.

     GCC will automatically make the right selection about where to
     store this bit using the 'FUNCTION_BOUNDARY' setting for your
     platform.  However, some platforms such as ARM/Thumb have
     'FUNCTION_BOUNDARY' set such that functions always start at even
     addresses, but the lowest bit of pointers to functions indicate
     whether the function at that address is in ARM or Thumb mode.  If
     this is the case of your architecture, you should define this macro
     to 'ptrmemfunc_vbit_in_delta'.

     In general, you should not have to define this macro.  On
     architectures in which function addresses are always even,
     according to 'FUNCTION_BOUNDARY', GCC will automatically define
     this macro to 'ptrmemfunc_vbit_in_pfn'.

 -- Macro: TARGET_VTABLE_USES_DESCRIPTORS
     Normally, the C++ compiler uses function pointers in vtables.  This
     macro allows the target to change to use "function descriptors"
     instead.  Function descriptors are found on targets for whom a
     function pointer is actually a small data structure.  Normally the
     data structure consists of the actual code address plus a data
     pointer to which the function's data is relative.

     If vtables are used, the value of this macro should be the number
     of words that the function descriptor occupies.

 -- Macro: TARGET_VTABLE_ENTRY_ALIGN
     By default, the vtable entries are void pointers, the so the
     alignment is the same as pointer alignment.  The value of this
     macro specifies the alignment of the vtable entry in bits.  It
     should be defined only when special alignment is necessary.  */

 -- Macro: TARGET_VTABLE_DATA_ENTRY_DISTANCE
     There are a few non-descriptor entries in the vtable at offsets
     below zero.  If these entries must be padded (say, to preserve the
     alignment specified by 'TARGET_VTABLE_ENTRY_ALIGN'), set this to
     the number of words in each data entry.

==============================================================================
File: gccint.info,  Node: |Registers|,  Next: |Register_Classes|,  Prev: |Type_Layout|,  Up: |Target_Macros|
==============================================================================

                                                                     *Registers*

18.7 Register Usage
-------------------

This section explains how to describe what registers the target machine
has, and how (in general) they can be used.

 The description of which registers a specific instruction can use is
done with register classes; see *note Register Classes::.  For
information on using registers to access a stack frame, see *note Frame
Registers::.  For passing values in registers, see *note Register
Arguments::.  For returning values in registers, see *note Scalar
Return::.

MENU

* |Register_Basics|::             Number and kinds of registers.
* |Allocation_Order|::            Order in which registers are allocated.
* |Values_in_Registers|::         What kinds of values each reg can hold.
* |Leaf_Functions|::              Renumbering registers for leaf functions.
* |Stack_Registers|::             Handling a register stack such as 80387.

==============================================================================
File: gccint.info,  Node: |Register_Basics|,  Next: |Allocation_Order|,  Up: |Registers|
==============================================================================

                                                               *Register_Basics*

18.7.1 Basic Characteristics of Registers
-----------------------------------------

Registers have various characteristics.

 -- Macro: FIRST_PSEUDO_REGISTER
     Number of hardware registers known to the compiler.  They receive
     numbers 0 through 'FIRST_PSEUDO_REGISTER-1'; thus, the first pseudo
     register's number really is assigned the number
     'FIRST_PSEUDO_REGISTER'.

 -- Macro: FIXED_REGISTERS
     An initializer that says which registers are used for fixed
     purposes all throughout the compiled code and are therefore not
     available for general allocation.  These would include the stack
     pointer, the frame pointer (except on machines where that can be
     used as a general register when no frame pointer is needed), the
     program counter on machines where that is considered one of the
     addressable registers, and any other numbered register with a
     standard use.

     This information is expressed as a sequence of numbers, separated
     by commas and surrounded by braces.  The Nth number is 1 if
     register N is fixed, 0 otherwise.

     The table initialized from this macro, and the table initialized by
     the following one, may be overridden at run time either
     automatically, by the actions of the macro
     'CONDITIONAL_REGISTER_USAGE', or by the user with the command
     options '-ffixed-REG', '-fcall-used-REG' and '-fcall-saved-REG'.

 -- Macro: CALL_USED_REGISTERS
     Like 'FIXED_REGISTERS' but has 1 for each register that is
     clobbered (in general) by function calls as well as for fixed
     registers.  This macro therefore identifies the registers that are
     not available for general allocation of values that must live
     across function calls.

     If a register has 0 in 'CALL_USED_REGISTERS', the compiler
     automatically saves it on function entry and restores it on
     function exit, if the register is used within the function.

     Exactly one of 'CALL_USED_REGISTERS' and
     'CALL_REALLY_USED_REGISTERS' must be defined.  Modern ports should
     define 'CALL_REALLY_USED_REGISTERS'.

 -- Macro: CALL_REALLY_USED_REGISTERS
     Like 'CALL_USED_REGISTERS' except this macro doesn't require that
     the entire set of 'FIXED_REGISTERS' be included.
     ('CALL_USED_REGISTERS' must be a superset of 'FIXED_REGISTERS').

     Exactly one of 'CALL_USED_REGISTERS' and
     'CALL_REALLY_USED_REGISTERS' must be defined.  Modern ports should
     define 'CALL_REALLY_USED_REGISTERS'.

 -- Target Hook: const predefined_function_abi & TARGET_FNTYPE_ABI
          (const_tree TYPE)
     Return the ABI used by a function with type TYPE; see the
     definition of 'predefined_function_abi' for details of the ABI
     descriptor.  Targets only need to define this hook if they support
     interoperability between several ABIs in the same translation unit.

 -- Target Hook: const predefined_function_abi & TARGET_INSN_CALLEE_ABI
          (const rtx_insn *INSN)
     This hook returns a description of the ABI used by the target of
     call instruction INSN; see the definition of
     'predefined_function_abi' for details of the ABI descriptor.  Only
     the global function 'insn_callee_abi' should call this hook
     directly.

     Targets only need to define this hook if they support
     interoperability between several ABIs in the same translation unit.

 -- Target Hook: bool TARGET_HARD_REGNO_CALL_PART_CLOBBERED (unsigned
          int ABI_ID, unsigned int REGNO, machine_mode MODE)
     ABIs usually specify that calls must preserve the full contents of
     a particular register, or that calls can alter any part of a
     particular register.  This information is captured by the target
     macro 'CALL_REALLY_USED_REGISTERS'.  However, some ABIs specify
     that calls must preserve certain bits of a particular register but
     can alter others.  This hook should return true if this applies to
     at least one of the registers in '(reg:MODE REGNO)', and if as a
     result the call would alter part of the MODE value.  For example,
     if a call preserves the low 32 bits of a 64-bit hard register REGNO
     but can clobber the upper 32 bits, this hook should return true for
     a 64-bit mode but false for a 32-bit mode.

     The value of ABI_ID comes from the 'predefined_function_abi'
     structure that describes the ABI of the call; see the definition of
     the structure for more details.  If (as is usual) the target uses
     the same ABI for all functions in a translation unit, ABI_ID is
     always 0.

     The default implementation returns false, which is correct for
     targets that don't have partly call-clobbered registers.

 -- Target Hook: const char * TARGET_GET_MULTILIB_ABI_NAME (void)
     This hook returns name of multilib ABI name.

 -- Target Hook: void TARGET_CONDITIONAL_REGISTER_USAGE (void)
     This hook may conditionally modify five variables 'fixed_regs',
     'call_used_regs', 'global_regs', 'reg_names', and
     'reg_class_contents', to take into account any dependence of these
     register sets on target flags.  The first three of these are of
     type 'char []' (interpreted as boolean vectors).  'global_regs' is
     a 'const char *[]', and 'reg_class_contents' is a 'HARD_REG_SET'.
     Before the macro is called, 'fixed_regs', 'call_used_regs',
     'reg_class_contents', and 'reg_names' have been initialized from
     'FIXED_REGISTERS', 'CALL_USED_REGISTERS', 'REG_CLASS_CONTENTS', and
     'REGISTER_NAMES', respectively.  'global_regs' has been cleared,
     and any '-ffixed-REG', '-fcall-used-REG' and '-fcall-saved-REG'
     command options have been applied.

     If the usage of an entire class of registers depends on the target
     flags, you may indicate this to GCC by using this macro to modify
     'fixed_regs' and 'call_used_regs' to 1 for each of the registers in
     the classes which should not be used by GCC.  Also make
     'define_register_constraint's return 'NO_REGS' for constraints that
     shouldn't be used.

     (However, if this class is not included in 'GENERAL_REGS' and all
     of the insn patterns whose constraints permit this class are
     controlled by target switches, then GCC will automatically avoid
     using these registers when the target switches are opposed to
     them.)

 -- Macro: INCOMING_REGNO (OUT)
     Define this macro if the target machine has register windows.  This
     C expression returns the register number as seen by the called
     function corresponding to the register number OUT as seen by the
     calling function.  Return OUT if register number OUT is not an
     outbound register.

 -- Macro: OUTGOING_REGNO (IN)
     Define this macro if the target machine has register windows.  This
     C expression returns the register number as seen by the calling
     function corresponding to the register number IN as seen by the
     called function.  Return IN if register number IN is not an inbound
     register.

 -- Macro: LOCAL_REGNO (REGNO)
     Define this macro if the target machine has register windows.  This
     C expression returns true if the register is call-saved but is in
     the register window.  Unlike most call-saved registers, such
     registers need not be explicitly restored on function exit or
     during non-local gotos.

 -- Macro: PC_REGNUM
     If the program counter has a register number, define this as that
     register number.  Otherwise, do not define it.

==============================================================================
File: gccint.info,  Node: |Allocation_Order|,  Next: |Values_in_Registers|,  Prev: |Register_Basics|,  Up: |Registers|
==============================================================================

                                                              *Allocation_Order*

18.7.2 Order of Allocation of Registers
---------------------------------------

Registers are allocated in order.

 -- Macro: REG_ALLOC_ORDER
     If defined, an initializer for a vector of integers, containing the
     numbers of hard registers in the order in which GCC should prefer
     to use them (from most preferred to least).

     If this macro is not defined, registers are used lowest numbered
     first (all else being equal).

     One use of this macro is on machines where the highest numbered
     registers must always be saved and the save-multiple-registers
     instruction supports only sequences of consecutive registers.  On
     such machines, define 'REG_ALLOC_ORDER' to be an initializer that
     lists the highest numbered allocable register first.

 -- Macro: ADJUST_REG_ALLOC_ORDER
     A C statement (sans semicolon) to choose the order in which to
     allocate hard registers for pseudo-registers local to a basic
     block.

     Store the desired register order in the array 'reg_alloc_order'.
     Element 0 should be the register to allocate first; element 1, the
     next register; and so on.

     The macro body should not assume anything about the contents of
     'reg_alloc_order' before execution of the macro.

     On most machines, it is not necessary to define this macro.

 -- Macro: HONOR_REG_ALLOC_ORDER
     Normally, IRA tries to estimate the costs for saving a register in
     the prologue and restoring it in the epilogue.  This discourages it
     from using call-saved registers.  If a machine wants to ensure that
     IRA allocates registers in the order given by REG_ALLOC_ORDER even
     if some call-saved registers appear earlier than call-used ones,
     then define this macro as a C expression to nonzero.  Default is 0.

 -- Macro: IRA_HARD_REGNO_ADD_COST_MULTIPLIER (REGNO)
     In some case register allocation order is not enough for the
     Integrated Register Allocator (IRA) to generate a good code.  If
     this macro is defined, it should return a floating point value
     based on REGNO.  The cost of using REGNO for a pseudo will be
     increased by approximately the pseudo's usage frequency times the
     value returned by this macro.  Not defining this macro is
     equivalent to having it always return '0.0'.

     On most machines, it is not necessary to define this macro.

==============================================================================
File: gccint.info,  Node: |Values_in_Registers|,  Next: |Leaf_Functions|,  Prev: |Allocation_Order|,  Up: |Registers|
==============================================================================

                                                           *Values_in_Registers*

18.7.3 How Values Fit in Registers
----------------------------------

This section discusses the macros that describe which kinds of values
(specifically, which machine modes) each register can hold, and how many
consecutive registers are needed for a given mode.

 -- Target Hook: unsigned int TARGET_HARD_REGNO_NREGS (unsigned int
          REGNO, machine_mode MODE)
     This hook returns the number of consecutive hard registers,
     starting at register number REGNO, required to hold a value of mode
     MODE.  This hook must never return zero, even if a register cannot
     hold the requested mode - indicate that with
     'TARGET_HARD_REGNO_MODE_OK' and/or 'TARGET_CAN_CHANGE_MODE_CLASS'
     instead.

     The default definition returns the number of words in MODE.

 -- Macro: HARD_REGNO_NREGS_HAS_PADDING (REGNO, MODE)
     A C expression that is nonzero if a value of mode MODE, stored in
     memory, ends with padding that causes it to take up more space than
     in registers starting at register number REGNO (as determined by
     multiplying GCC's notion of the size of the register when
     containing this mode by the number of registers returned by
     'TARGET_HARD_REGNO_NREGS').  By default this is zero.

     For example, if a floating-point value is stored in three 32-bit
     registers but takes up 128 bits in memory, then this would be
     nonzero.

     This macros only needs to be defined if there are cases where
     'subreg_get_info' would otherwise wrongly determine that a 'subreg'
     can be represented by an offset to the register number, when in
     fact such a 'subreg' would contain some of the padding not stored
     in registers and so not be representable.

 -- Macro: HARD_REGNO_NREGS_WITH_PADDING (REGNO, MODE)
     For values of REGNO and MODE for which
     'HARD_REGNO_NREGS_HAS_PADDING' returns nonzero, a C expression
     returning the greater number of registers required to hold the
     value including any padding.  In the example above, the value would
     be four.

 -- Macro: REGMODE_NATURAL_SIZE (MODE)
     Define this macro if the natural size of registers that hold values
     of mode MODE is not the word size.  It is a C expression that
     should give the natural size in bytes for the specified mode.  It
     is used by the register allocator to try to optimize its results.
     This happens for example on SPARC 64-bit where the natural size of
     floating-point registers is still 32-bit.

 -- Target Hook: bool TARGET_HARD_REGNO_MODE_OK (unsigned int REGNO,
          machine_mode MODE)
     This hook returns true if it is permissible to store a value of
     mode MODE in hard register number REGNO (or in several registers
     starting with that one).  The default definition returns true
     unconditionally.

     You need not include code to check for the numbers of fixed
     registers, because the allocation mechanism considers them to be
     always occupied.

     On some machines, double-precision values must be kept in even/odd
     register pairs.  You can implement that by defining this hook to
     reject odd register numbers for such modes.

     The minimum requirement for a mode to be OK in a register is that
     the 'movMODE' instruction pattern support moves between the
     register and other hard register in the same class and that moving
     a value into the register and back out not alter it.

     Since the same instruction used to move 'word_mode' will work for
     all narrower integer modes, it is not necessary on any machine for
     this hook to distinguish between these modes, provided you define
     patterns 'movhi', etc., to take advantage of this.  This is useful
     because of the interaction between 'TARGET_HARD_REGNO_MODE_OK' and
     'TARGET_MODES_TIEABLE_P'; it is very desirable for all integer
     modes to be tieable.

     Many machines have special registers for floating point arithmetic.
     Often people assume that floating point machine modes are allowed
     only in floating point registers.  This is not true.  Any registers
     that can hold integers can safely _hold_ a floating point machine
     mode, whether or not floating arithmetic can be done on it in those
     registers.  Integer move instructions can be used to move the
     values.

     On some machines, though, the converse is true: fixed-point machine
     modes may not go in floating registers.  This is true if the
     floating registers normalize any value stored in them, because
     storing a non-floating value there would garble it.  In this case,
     'TARGET_HARD_REGNO_MODE_OK' should reject fixed-point machine modes
     in floating registers.  But if the floating registers do not
     automatically normalize, if you can store any bit pattern in one
     and retrieve it unchanged without a trap, then any machine mode may
     go in a floating register, so you can define this hook to say so.

     The primary significance of special floating registers is rather
     that they are the registers acceptable in floating point arithmetic
     instructions.  However, this is of no concern to
     'TARGET_HARD_REGNO_MODE_OK'.  You handle it by writing the proper
     constraints for those instructions.

     On some machines, the floating registers are especially slow to
     access, so that it is better to store a value in a stack frame than
     in such a register if floating point arithmetic is not being done.
     As long as the floating registers are not in class 'GENERAL_REGS',
     they will not be used unless some pattern's constraint asks for
     one.

 -- Macro: HARD_REGNO_RENAME_OK (FROM, TO)
     A C expression that is nonzero if it is OK to rename a hard
     register FROM to another hard register TO.

     One common use of this macro is to prevent renaming of a register
     to another register that is not saved by a prologue in an interrupt
     handler.

     The default is always nonzero.

 -- Target Hook: bool TARGET_MODES_TIEABLE_P (machine_mode MODE1,
          machine_mode MODE2)
     This hook returns true if a value of mode MODE1 is accessible in
     mode MODE2 without copying.

     If 'TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and
     'TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are always the same for any
     R, then 'TARGET_MODES_TIEABLE_P (MODE1, MODE2)' should be true.  If
     they differ for any R, you should define this hook to return false
     unless some other mechanism ensures the accessibility of the value
     in a narrower mode.

     You should define this hook to return true in as many cases as
     possible since doing so will allow GCC to perform better register
     allocation.  The default definition returns true unconditionally.

 -- Target Hook: bool TARGET_HARD_REGNO_SCRATCH_OK (unsigned int REGNO)
     This target hook should return 'true' if it is OK to use a hard
     register REGNO as scratch reg in peephole2.

     One common use of this macro is to prevent using of a register that
     is not saved by a prologue in an interrupt handler.

     The default version of this hook always returns 'true'.

 -- Macro: AVOID_CCMODE_COPIES
     Define this macro if the compiler should avoid copies to/from
     'CCmode' registers.  You should only define this macro if support
     for copying to/from 'CCmode' is incomplete.

==============================================================================
File: gccint.info,  Node: |Leaf_Functions|,  Next: |Stack_Registers|,  Prev: |Values_in_Registers|,  Up: |Registers|
==============================================================================

                                                                *Leaf_Functions*

18.7.4 Handling Leaf Functions
------------------------------

On some machines, a leaf function (i.e., one which makes no calls) can
run more efficiently if it does not make its own register window.  Often
this means it is required to receive its arguments in the registers
where they are passed by the caller, instead of the registers where they
would normally arrive.

 The special treatment for leaf functions generally applies only when
other conditions are met; for example, often they may use only those
registers for its own variables and temporaries.  We use the term "leaf
function" to mean a function that is suitable for this special handling,
so that functions with no calls are not necessarily "leaf functions".

 GCC assigns register numbers before it knows whether the function is
suitable for leaf function treatment.  So it needs to renumber the
registers in order to output a leaf function.  The following macros
accomplish this.

 -- Macro: LEAF_REGISTERS
     Name of a char vector, indexed by hard register number, which
     contains 1 for a register that is allowable in a candidate for leaf
     function treatment.

     If leaf function treatment involves renumbering the registers, then
     the registers marked here should be the ones before
     renumbering--those that GCC would ordinarily allocate.  The
     registers which will actually be used in the assembler code, after
     renumbering, should not be marked with 1 in this vector.

     Define this macro only if the target machine offers a way to
     optimize the treatment of leaf functions.

 -- Macro: LEAF_REG_REMAP (REGNO)
     A C expression whose value is the register number to which REGNO
     should be renumbered, when a function is treated as a leaf
     function.

     If REGNO is a register number which should not appear in a leaf
     function before renumbering, then the expression should yield -1,
     which will cause the compiler to abort.

     Define this macro only if the target machine offers a way to
     optimize the treatment of leaf functions, and registers need to be
     renumbered to do this.

 'TARGET_ASM_FUNCTION_PROLOGUE' and 'TARGET_ASM_FUNCTION_EPILOGUE' must
usually treat leaf functions specially.  They can test the C variable
'current_function_is_leaf' which is nonzero for leaf functions.
'current_function_is_leaf' is set prior to local register allocation and
is valid for the remaining compiler passes.  They can also test the C
variable 'current_function_uses_only_leaf_regs' which is nonzero for
leaf functions which only use leaf registers.
'current_function_uses_only_leaf_regs' is valid after all passes that
modify the instructions have been run and is only useful if
'LEAF_REGISTERS' is defined.

==============================================================================
File: gccint.info,  Node: |Stack_Registers|,  Prev: |Leaf_Functions|,  Up: |Registers|
==============================================================================

                                                               *Stack_Registers*

18.7.5 Registers That Form a Stack
----------------------------------

There are special features to handle computers where some of the
"registers" form a stack.  Stack registers are normally written by
pushing onto the stack, and are numbered relative to the top of the
stack.

 Currently, GCC can only handle one group of stack-like registers, and
they must be consecutively numbered.  Furthermore, the existing support
for stack-like registers is specific to the 80387 floating point
coprocessor.  If you have a new architecture that uses stack-like
registers, you will need to do substantial work on 'reg-stack.c' and
write your machine description to cooperate with it, as well as defining
these macros.

 -- Macro: STACK_REGS
     Define this if the machine has any stack-like registers.

 -- Macro: STACK_REG_COVER_CLASS
     This is a cover class containing the stack registers.  Define this
     if the machine has any stack-like registers.

 -- Macro: FIRST_STACK_REG
     The number of the first stack-like register.  This one is the top
     of the stack.

 -- Macro: LAST_STACK_REG
     The number of the last stack-like register.  This one is the bottom
     of the stack.

==============================================================================
File: gccint.info,  Node: |Register_Classes|,  Next: |Stack_and_Calling|,  Prev: |Registers|,  Up: |Target_Macros|
==============================================================================

                                                              *Register_Classes*

18.8 Register Classes
---------------------

On many machines, the numbered registers are not all equivalent.  For
example, certain registers may not be allowed for indexed addressing;
certain registers may not be allowed in some instructions.  These
machine restrictions are described to the compiler using "register
classes".

 You define a number of register classes, giving each one a name and
saying which of the registers belong to it.  Then you can specify
register classes that are allowed as operands to particular instruction
patterns.

 In general, each register will belong to several classes.  In fact, one
class must be named 'ALL_REGS' and contain all the registers.  Another
class must be named 'NO_REGS' and contain no registers.  Often the union
of two classes will be another class; however, this is not required.

 One of the classes must be named 'GENERAL_REGS'.  There is nothing
terribly special about the name, but the operand constraint letters 'r'
and 'g' specify this class.  If 'GENERAL_REGS' is the same as
'ALL_REGS', just define it as a macro which expands to 'ALL_REGS'.

 Order the classes so that if class X is contained in class Y then X has
a lower class number than Y.

 The way classes other than 'GENERAL_REGS' are specified in operand
constraints is through machine-dependent operand constraint letters.
You can define such letters to correspond to various classes, then use
them in operand constraints.

 You must define the narrowest register classes for allocatable
registers, so that each class either has no subclasses, or that for some
mode, the move cost between registers within the class is cheaper than
moving a register in the class to or from memory (*note Costs::).

 You should define a class for the union of two classes whenever some
instruction allows both classes.  For example, if an instruction allows
either a floating point (coprocessor) register or a general register for
a certain operand, you should define a class 'FLOAT_OR_GENERAL_REGS'
which includes both of them.  Otherwise you will get suboptimal code, or
even internal compiler errors when reload cannot find a register in the
class computed via 'reg_class_subunion'.

 You must also specify certain redundant information about the register
classes: for each class, which classes contain it and which ones are
contained in it; for each pair of classes, the largest class contained
in their union.

 When a value occupying several consecutive registers is expected in a
certain class, all the registers used must belong to that class.
Therefore, register classes cannot be used to enforce a requirement for
a register pair to start with an even-numbered register.  The way to
specify this requirement is with 'TARGET_HARD_REGNO_MODE_OK'.

 Register classes used for input-operands of bitwise-and or shift
instructions have a special requirement: each such class must have, for
each fixed-point machine mode, a subclass whose registers can transfer
that mode to or from memory.  For example, on some machines, the
operations for single-byte values ('QImode') are limited to certain
registers.  When this is so, each register class that is used in a
bitwise-and or shift instruction must have a subclass consisting of
registers from which single-byte values can be loaded or stored.  This
is so that 'PREFERRED_RELOAD_CLASS' can always have a possible value to
return.

 -- Data type: enum reg_class
     An enumerated type that must be defined with all the register class
     names as enumerated values.  'NO_REGS' must be first.  'ALL_REGS'
     must be the last register class, followed by one more enumerated
     value, 'LIM_REG_CLASSES', which is not a register class but rather
     tells how many classes there are.

     Each register class has a number, which is the value of casting the
     class name to type 'int'.  The number serves as an index in many of
     the tables described below.

 -- Macro: N_REG_CLASSES
     The number of distinct register classes, defined as follows:

          #define N_REG_CLASSES (int) LIM_REG_CLASSES

 -- Macro: REG_CLASS_NAMES
     An initializer containing the names of the register classes as C
     string constants.  These names are used in writing some of the
     debugging dumps.

 -- Macro: REG_CLASS_CONTENTS
     An initializer containing the contents of the register classes, as
     integers which are bit masks.  The Nth integer specifies the
     contents of class N.  The way the integer MASK is interpreted is
     that register R is in the class if 'MASK & (1 << R)' is 1.

     When the machine has more than 32 registers, an integer does not
     suffice.  Then the integers are replaced by sub-initializers,
     braced groupings containing several integers.  Each sub-initializer
     must be suitable as an initializer for the type 'HARD_REG_SET'
     which is defined in 'hard-reg-set.h'.  In this situation, the first
     integer in each sub-initializer corresponds to registers 0 through
     31, the second integer to registers 32 through 63, and so on.

 -- Macro: REGNO_REG_CLASS (REGNO)
     A C expression whose value is a register class containing hard
     register REGNO.  In general there is more than one such class;
     choose a class which is "minimal", meaning that no smaller class
     also contains the register.

 -- Macro: BASE_REG_CLASS
     A macro whose definition is the name of the class to which a valid
     base register must belong.  A base register is one used in an
     address which is the register value plus a displacement.

 -- Macro: MODE_BASE_REG_CLASS (MODE)
     This is a variation of the 'BASE_REG_CLASS' macro which allows the
     selection of a base register in a mode dependent manner.  If MODE
     is VOIDmode then it should return the same value as
     'BASE_REG_CLASS'.

 -- Macro: MODE_BASE_REG_REG_CLASS (MODE)
     A C expression whose value is the register class to which a valid
     base register must belong in order to be used in a base plus index
     register address.  You should define this macro if base plus index
     addresses have different requirements than other base register
     uses.

 -- Macro: MODE_CODE_BASE_REG_CLASS (MODE, ADDRESS_SPACE, OUTER_CODE,
          INDEX_CODE)
     A C expression whose value is the register class to which a valid
     base register for a memory reference in mode MODE to address space
     ADDRESS_SPACE must belong.  OUTER_CODE and INDEX_CODE define the
     context in which the base register occurs.  OUTER_CODE is the code
     of the immediately enclosing expression ('MEM' for the top level of
     an address, 'ADDRESS' for something that occurs in an
     'address_operand').  INDEX_CODE is the code of the corresponding
     index expression if OUTER_CODE is 'PLUS'; 'SCRATCH' otherwise.

 -- Macro: INDEX_REG_CLASS
     A macro whose definition is the name of the class to which a valid
     index register must belong.  An index register is one used in an
     address where its value is either multiplied by a scale factor or
     added to another register (as well as added to a displacement).

 -- Macro: REGNO_OK_FOR_BASE_P (NUM)
     A C expression which is nonzero if register number NUM is suitable
     for use as a base register in operand addresses.

 -- Macro: REGNO_MODE_OK_FOR_BASE_P (NUM, MODE)
     A C expression that is just like 'REGNO_OK_FOR_BASE_P', except that
     that expression may examine the mode of the memory reference in
     MODE.  You should define this macro if the mode of the memory
     reference affects whether a register may be used as a base
     register.  If you define this macro, the compiler will use it
     instead of 'REGNO_OK_FOR_BASE_P'.  The mode may be 'VOIDmode' for
     addresses that appear outside a 'MEM', i.e., as an
     'address_operand'.

 -- Macro: REGNO_MODE_OK_FOR_REG_BASE_P (NUM, MODE)
     A C expression which is nonzero if register number NUM is suitable
     for use as a base register in base plus index operand addresses,
     accessing memory in mode MODE.  It may be either a suitable hard
     register or a pseudo register that has been allocated such a hard
     register.  You should define this macro if base plus index
     addresses have different requirements than other base register
     uses.

     Use of this macro is deprecated; please use the more general
     'REGNO_MODE_CODE_OK_FOR_BASE_P'.

 -- Macro: REGNO_MODE_CODE_OK_FOR_BASE_P (NUM, MODE, ADDRESS_SPACE,
          OUTER_CODE, INDEX_CODE)
     A C expression which is nonzero if register number NUM is suitable
     for use as a base register in operand addresses, accessing memory
     in mode MODE in address space ADDRESS_SPACE.  This is similar to
     'REGNO_MODE_OK_FOR_BASE_P', except that that expression may examine
     the context in which the register appears in the memory reference.
     OUTER_CODE is the code of the immediately enclosing expression
     ('MEM' if at the top level of the address, 'ADDRESS' for something
     that occurs in an 'address_operand').  INDEX_CODE is the code of
     the corresponding index expression if OUTER_CODE is 'PLUS';
     'SCRATCH' otherwise.  The mode may be 'VOIDmode' for addresses that
     appear outside a 'MEM', i.e., as an 'address_operand'.

 -- Macro: REGNO_OK_FOR_INDEX_P (NUM)
     A C expression which is nonzero if register number NUM is suitable
     for use as an index register in operand addresses.  It may be
     either a suitable hard register or a pseudo register that has been
     allocated such a hard register.

     The difference between an index register and a base register is
     that the index register may be scaled.  If an address involves the
     sum of two registers, neither one of them scaled, then either one
     may be labeled the "base" and the other the "index"; but whichever
     labeling is used must fit the machine's constraints of which
     registers may serve in each capacity.  The compiler will try both
     labelings, looking for one that is valid, and will reload one or
     both registers only if neither labeling works.

 -- Target Hook: reg_class_t TARGET_PREFERRED_RENAME_CLASS (reg_class_t
          RCLASS)
     A target hook that places additional preference on the register
     class to use when it is necessary to rename a register in class
     RCLASS to another class, or perhaps NO_REGS, if no preferred
     register class is found or hook 'preferred_rename_class' is not
     implemented.  Sometimes returning a more restrictive class makes
     better code.  For example, on ARM, thumb-2 instructions using
     'LO_REGS' may be smaller than instructions using 'GENERIC_REGS'.
     By returning 'LO_REGS' from 'preferred_rename_class', code size can
     be reduced.

 -- Target Hook: reg_class_t TARGET_PREFERRED_RELOAD_CLASS (rtx X,
          reg_class_t RCLASS)
     A target hook that places additional restrictions on the register
     class to use when it is necessary to copy value X into a register
     in class RCLASS.  The value is a register class; perhaps RCLASS, or
     perhaps another, smaller class.

     The default version of this hook always returns value of 'rclass'
     argument.

     Sometimes returning a more restrictive class makes better code.
     For example, on the 68000, when X is an integer constant that is in
     range for a 'moveq' instruction, the value of this macro is always
     'DATA_REGS' as long as RCLASS includes the data registers.
     Requiring a data register guarantees that a 'moveq' will be used.

     One case where 'TARGET_PREFERRED_RELOAD_CLASS' must not return
     RCLASS is if X is a legitimate constant which cannot be loaded into
     some register class.  By returning 'NO_REGS' you can force X into a
     memory location.  For example, rs6000 can load immediate values
     into general-purpose registers, but does not have an instruction
     for loading an immediate value into a floating-point register, so
     'TARGET_PREFERRED_RELOAD_CLASS' returns 'NO_REGS' when X is a
     floating-point constant.  If the constant can't be loaded into any
     kind of register, code generation will be better if
     'TARGET_LEGITIMATE_CONSTANT_P' makes the constant illegitimate
     instead of using 'TARGET_PREFERRED_RELOAD_CLASS'.

     If an insn has pseudos in it after register allocation, reload will
     go through the alternatives and call repeatedly
     'TARGET_PREFERRED_RELOAD_CLASS' to find the best one.  Returning
     'NO_REGS', in this case, makes reload add a '!' in front of the
     constraint: the x86 back-end uses this feature to discourage usage
     of 387 registers when math is done in the SSE registers (and vice
     versa).

 -- Macro: PREFERRED_RELOAD_CLASS (X, CLASS)
     A C expression that places additional restrictions on the register
     class to use when it is necessary to copy value X into a register
     in class CLASS.  The value is a register class; perhaps CLASS, or
     perhaps another, smaller class.  On many machines, the following
     definition is safe:

          #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS

     Sometimes returning a more restrictive class makes better code.
     For example, on the 68000, when X is an integer constant that is in
     range for a 'moveq' instruction, the value of this macro is always
     'DATA_REGS' as long as CLASS includes the data registers.
     Requiring a data register guarantees that a 'moveq' will be used.

     One case where 'PREFERRED_RELOAD_CLASS' must not return CLASS is if
     X is a legitimate constant which cannot be loaded into some
     register class.  By returning 'NO_REGS' you can force X into a
     memory location.  For example, rs6000 can load immediate values
     into general-purpose registers, but does not have an instruction
     for loading an immediate value into a floating-point register, so
     'PREFERRED_RELOAD_CLASS' returns 'NO_REGS' when X is a
     floating-point constant.  If the constant cannot be loaded into any
     kind of register, code generation will be better if
     'TARGET_LEGITIMATE_CONSTANT_P' makes the constant illegitimate
     instead of using 'TARGET_PREFERRED_RELOAD_CLASS'.

     If an insn has pseudos in it after register allocation, reload will
     go through the alternatives and call repeatedly
     'PREFERRED_RELOAD_CLASS' to find the best one.  Returning
     'NO_REGS', in this case, makes reload add a '!' in front of the
     constraint: the x86 back-end uses this feature to discourage usage
     of 387 registers when math is done in the SSE registers (and vice
     versa).

 -- Target Hook: reg_class_t TARGET_PREFERRED_OUTPUT_RELOAD_CLASS (rtx
          X, reg_class_t RCLASS)
     Like 'TARGET_PREFERRED_RELOAD_CLASS', but for output reloads
     instead of input reloads.

     The default version of this hook always returns value of 'rclass'
     argument.

     You can also use 'TARGET_PREFERRED_OUTPUT_RELOAD_CLASS' to
     discourage reload from using some alternatives, like
     'TARGET_PREFERRED_RELOAD_CLASS'.

 -- Macro: LIMIT_RELOAD_CLASS (MODE, CLASS)
     A C expression that places additional restrictions on the register
     class to use when it is necessary to be able to hold a value of
     mode MODE in a reload register for which class CLASS would
     ordinarily be used.

     Unlike 'PREFERRED_RELOAD_CLASS', this macro should be used when
     there are certain modes that simply cannot go in certain reload
     classes.

     The value is a register class; perhaps CLASS, or perhaps another,
     smaller class.

     Don't define this macro unless the target machine has limitations
     which require the macro to do something nontrivial.

 -- Target Hook: reg_class_t TARGET_SECONDARY_RELOAD (bool IN_P, rtx X,
          reg_class_t RELOAD_CLASS, machine_mode RELOAD_MODE,
          secondary_reload_info *SRI)
     Many machines have some registers that cannot be copied directly to
     or from memory or even from other types of registers.  An example
     is the 'MQ' register, which on most machines, can only be copied to
     or from general registers, but not memory.  Below, we shall be
     using the term 'intermediate register' when a move operation cannot
     be performed directly, but has to be done by copying the source
     into the intermediate register first, and then copying the
     intermediate register to the destination.  An intermediate register
     always has the same mode as source and destination.  Since it holds
     the actual value being copied, reload might apply optimizations to
     re-use an intermediate register and eliding the copy from the
     source when it can determine that the intermediate register still
     holds the required value.

     Another kind of secondary reload is required on some machines which
     allow copying all registers to and from memory, but require a
     scratch register for stores to some memory locations (e.g., those
     with symbolic address on the RT, and those with certain symbolic
     address on the SPARC when compiling PIC).  Scratch registers need
     not have the same mode as the value being copied, and usually hold
     a different value than that being copied.  Special patterns in the
     md file are needed to describe how the copy is performed with the
     help of the scratch register; these patterns also describe the
     number, register class(es) and mode(s) of the scratch register(s).

     In some cases, both an intermediate and a scratch register are
     required.

     For input reloads, this target hook is called with nonzero IN_P,
     and X is an rtx that needs to be copied to a register of class
     RELOAD_CLASS in RELOAD_MODE.  For output reloads, this target hook
     is called with zero IN_P, and a register of class RELOAD_CLASS
     needs to be copied to rtx X in RELOAD_MODE.

     If copying a register of RELOAD_CLASS from/to X requires an
     intermediate register, the hook 'secondary_reload' should return
     the register class required for this intermediate register.  If no
     intermediate register is required, it should return NO_REGS. If
     more than one intermediate register is required, describe the one
     that is closest in the copy chain to the reload register.

     If scratch registers are needed, you also have to describe how to
     perform the copy from/to the reload register to/from this closest
     intermediate register.  Or if no intermediate register is required,
     but still a scratch register is needed, describe the copy from/to
     the reload register to/from the reload operand X.

     You do this by setting 'sri->icode' to the instruction code of a
     pattern in the md file which performs the move.  Operands 0 and 1
     are the output and input of this copy, respectively.  Operands from
     operand 2 onward are for scratch operands.  These scratch operands
     must have a mode, and a single-register-class output constraint.

     When an intermediate register is used, the 'secondary_reload' hook
     will be called again to determine how to copy the intermediate
     register to/from the reload operand X, so your hook must also have
     code to handle the register class of the intermediate operand.

     X might be a pseudo-register or a 'subreg' of a pseudo-register,
     which could either be in a hard register or in memory.  Use
     'true_regnum' to find out; it will return -1 if the pseudo is in
     memory and the hard register number if it is in a register.

     Scratch operands in memory (constraint '"=m"' / '"=&m"') are
     currently not supported.  For the time being, you will have to
     continue to use 'TARGET_SECONDARY_MEMORY_NEEDED' for that purpose.

     'copy_cost' also uses this target hook to find out how values are
     copied.  If you want it to include some extra cost for the need to
     allocate (a) scratch register(s), set 'sri->extra_cost' to the
     additional cost.  Or if two dependent moves are supposed to have a
     lower cost than the sum of the individual moves due to expected
     fortuitous scheduling and/or special forwarding logic, you can set
     'sri->extra_cost' to a negative amount.

 -- Macro: SECONDARY_RELOAD_CLASS (CLASS, MODE, X)
 -- Macro: SECONDARY_INPUT_RELOAD_CLASS (CLASS, MODE, X)
 -- Macro: SECONDARY_OUTPUT_RELOAD_CLASS (CLASS, MODE, X)
     These macros are obsolete, new ports should use the target hook
     'TARGET_SECONDARY_RELOAD' instead.

     These are obsolete macros, replaced by the
     'TARGET_SECONDARY_RELOAD' target hook.  Older ports still define
     these macros to indicate to the reload phase that it may need to
     allocate at least one register for a reload in addition to the
     register to contain the data.  Specifically, if copying X to a
     register CLASS in MODE requires an intermediate register, you were
     supposed to define 'SECONDARY_INPUT_RELOAD_CLASS' to return the
     largest register class all of whose registers can be used as
     intermediate registers or scratch registers.

     If copying a register CLASS in MODE to X requires an intermediate
     or scratch register, 'SECONDARY_OUTPUT_RELOAD_CLASS' was supposed
     to be defined be defined to return the largest register class
     required.  If the requirements for input and output reloads were
     the same, the macro 'SECONDARY_RELOAD_CLASS' should have been used
     instead of defining both macros identically.

     The values returned by these macros are often 'GENERAL_REGS'.
     Return 'NO_REGS' if no spare register is needed; i.e., if X can be
     directly copied to or from a register of CLASS in MODE without
     requiring a scratch register.  Do not define this macro if it would
     always return 'NO_REGS'.

     If a scratch register is required (either with or without an
     intermediate register), you were supposed to define patterns for
     'reload_inM' or 'reload_outM', as required (*note Standard Names::.
     These patterns, which were normally implemented with a
     'define_expand', should be similar to the 'movM' patterns, except
     that operand 2 is the scratch register.

     These patterns need constraints for the reload register and scratch
     register that contain a single register class.  If the original
     reload register (whose class is CLASS) can meet the constraint
     given in the pattern, the value returned by these macros is used
     for the class of the scratch register.  Otherwise, two additional
     reload registers are required.  Their classes are obtained from the
     constraints in the insn pattern.

     X might be a pseudo-register or a 'subreg' of a pseudo-register,
     which could either be in a hard register or in memory.  Use
     'true_regnum' to find out; it will return -1 if the pseudo is in
     memory and the hard register number if it is in a register.

     These macros should not be used in the case where a particular
     class of registers can only be copied to memory and not to another
     class of registers.  In that case, secondary reload registers are
     not needed and would not be helpful.  Instead, a stack location
     must be used to perform the copy and the 'movM' pattern should use
     memory as an intermediate storage.  This case often occurs between
     floating-point and general registers.

 -- Target Hook: bool TARGET_SECONDARY_MEMORY_NEEDED (machine_mode MODE,
          reg_class_t CLASS1, reg_class_t CLASS2)
     Certain machines have the property that some registers cannot be
     copied to some other registers without using memory.  Define this
     hook on those machines to return true if objects of mode M in
     registers of CLASS1 can only be copied to registers of class CLASS2
     by storing a register of CLASS1 into memory and loading that memory
     location into a register of CLASS2.  The default definition returns
     false for all inputs.

 -- Macro: SECONDARY_MEMORY_NEEDED_RTX (MODE)
     Normally when 'TARGET_SECONDARY_MEMORY_NEEDED' is defined, the
     compiler allocates a stack slot for a memory location needed for
     register copies.  If this macro is defined, the compiler instead
     uses the memory location defined by this macro.

     Do not define this macro if you do not define
     'TARGET_SECONDARY_MEMORY_NEEDED'.

 -- Target Hook: machine_mode TARGET_SECONDARY_MEMORY_NEEDED_MODE
          (machine_mode MODE)
     If 'TARGET_SECONDARY_MEMORY_NEEDED' tells the compiler to use
     memory when moving between two particular registers of mode MODE,
     this hook specifies the mode that the memory should have.

     The default depends on 'TARGET_LRA_P'.  Without LRA, the default is
     to use a word-sized mode for integral modes that are smaller than a
     a word.  This is right thing to do on most machines because it
     ensures that all bits of the register are copied and prevents
     accesses to the registers in a narrower mode, which some machines
     prohibit for floating-point registers.

     However, this default behavior is not correct on some machines,
     such as the DEC Alpha, that store short integers in floating-point
     registers differently than in integer registers.  On those
     machines, the default widening will not work correctly and you must
     define this hook to suppress that widening in some cases.  See the
     file 'alpha.c' for details.

     With LRA, the default is to use MODE unmodified.

 -- Target Hook: void TARGET_SELECT_EARLY_REMAT_MODES (sbitmap MODES)
     On some targets, certain modes cannot be held in registers around a
     standard ABI call and are relatively expensive to spill to the
     stack.  The early rematerialization pass can help in such cases by
     aggressively recomputing values after calls, so that they don't
     need to be spilled.

     This hook returns the set of such modes by setting the associated
     bits in MODES.  The default implementation selects no modes, which
     has the effect of disabling the early rematerialization pass.

 -- Target Hook: bool TARGET_CLASS_LIKELY_SPILLED_P (reg_class_t RCLASS)
     A target hook which returns 'true' if pseudos that have been
     assigned to registers of class RCLASS would likely be spilled
     because registers of RCLASS are needed for spill registers.

     The default version of this target hook returns 'true' if RCLASS
     has exactly one register and 'false' otherwise.  On most machines,
     this default should be used.  For generally register-starved
     machines, such as i386, or machines with right register
     constraints, such as SH, this hook can be used to avoid excessive
     spilling.

     This hook is also used by some of the global intra-procedural code
     transformations to throtle code motion, to avoid increasing
     register pressure.

 -- Target Hook: unsigned char TARGET_CLASS_MAX_NREGS (reg_class_t
          RCLASS, machine_mode MODE)
     A target hook returns the maximum number of consecutive registers
     of class RCLASS needed to hold a value of mode MODE.

     This is closely related to the macro 'TARGET_HARD_REGNO_NREGS'.  In
     fact, the value returned by 'TARGET_CLASS_MAX_NREGS (RCLASS, MODE)'
     target hook should be the maximum value of 'TARGET_HARD_REGNO_NREGS
     (REGNO, MODE)' for all REGNO values in the class RCLASS.

     This target hook helps control the handling of multiple-word values
     in the reload pass.

     The default version of this target hook returns the size of MODE in
     words.

 -- Macro: CLASS_MAX_NREGS (CLASS, MODE)
     A C expression for the maximum number of consecutive registers of
     class CLASS needed to hold a value of mode MODE.

     This is closely related to the macro 'TARGET_HARD_REGNO_NREGS'.  In
     fact, the value of the macro 'CLASS_MAX_NREGS (CLASS, MODE)' should
     be the maximum value of 'TARGET_HARD_REGNO_NREGS (REGNO, MODE)' for
     all REGNO values in the class CLASS.

     This macro helps control the handling of multiple-word values in
     the reload pass.

 -- Target Hook: bool TARGET_CAN_CHANGE_MODE_CLASS (machine_mode FROM,
          machine_mode TO, reg_class_t RCLASS)
     This hook returns true if it is possible to bitcast values held in
     registers of class RCLASS from mode FROM to mode TO and if doing so
     preserves the low-order bits that are common to both modes.  The
     result is only meaningful if RCLASS has registers that can hold
     both 'from' and 'to'.  The default implementation returns true.

     As an example of when such bitcasting is invalid, loading 32-bit
     integer or floating-point objects into floating-point registers on
     Alpha extends them to 64 bits.  Therefore loading a 64-bit object
     and then storing it as a 32-bit object does not store the low-order
     32 bits, as would be the case for a normal register.  Therefore,
     'alpha.h' defines 'TARGET_CAN_CHANGE_MODE_CLASS' to return:

          (GET_MODE_SIZE (from) == GET_MODE_SIZE (to)
           || !reg_classes_intersect_p (FLOAT_REGS, rclass))

     Even if storing from a register in mode TO would be valid, if both
     FROM and 'raw_reg_mode' for RCLASS are wider than 'word_mode', then
     we must prevent TO narrowing the mode.  This happens when the
     middle-end assumes that it can load or store pieces of an N-word
     pseudo, and that the pseudo will eventually be allocated to N
     'word_mode' hard registers.  Failure to prevent this kind of mode
     change will result in the entire 'raw_reg_mode' being modified
     instead of the partial value that the middle-end intended.

 -- Target Hook: reg_class_t TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS
          (int, REG_CLASS_T, REG_CLASS_T)
     A target hook which can change allocno class for given pseudo from
     allocno and best class calculated by IRA.

     The default version of this target hook always returns given class.

 -- Target Hook: bool TARGET_LRA_P (void)
     A target hook which returns true if we use LRA instead of reload
     pass.  The default version of this target hook returns true.  New
     ports should use LRA, and existing ports are encouraged to convert.

 -- Target Hook: int TARGET_REGISTER_PRIORITY (int)
     A target hook which returns the register priority number to which
     the register HARD_REGNO belongs to.  The bigger the number, the
     more preferable the hard register usage (when all other conditions
     are the same).  This hook can be used to prefer some hard register
     over others in LRA. For example, some x86-64 register usage needs
     additional prefix which makes instructions longer.  The hook can
     return lower priority number for such registers make them less
     favorable and as result making the generated code smaller.  The
     default version of this target hook returns always zero.

 -- Target Hook: bool TARGET_REGISTER_USAGE_LEVELING_P (void)
     A target hook which returns true if we need register usage
     leveling.  That means if a few hard registers are equally good for
     the assignment, we choose the least used hard register.  The
     register usage leveling may be profitable for some targets.  Don't
     use the usage leveling for targets with conditional execution or
     targets with big register files as it hurts if-conversion and
     cross-jumping optimizations.  The default version of this target
     hook returns always false.

 -- Target Hook: bool TARGET_DIFFERENT_ADDR_DISPLACEMENT_P (void)
     A target hook which returns true if an address with the same
     structure can have different maximal legitimate displacement.  For
     example, the displacement can depend on memory mode or on operand
     combinations in the insn.  The default version of this target hook
     returns always false.

 -- Target Hook: bool TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P (rtx SUBST)
     A target hook which returns 'true' if SUBST can't substitute safely
     pseudos with equivalent memory values during register allocation.
     The default version of this target hook returns 'false'.  On most
     machines, this default should be used.  For generally machines with
     non orthogonal register usage for addressing, such as SH, this hook
     can be used to avoid excessive spilling.

 -- Target Hook: bool TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT (rtx
          *OFFSET1, rtx *OFFSET2, poly_int64 ORIG_OFFSET, machine_mode
          MODE)
     This hook tries to split address offset ORIG_OFFSET into two parts:
     one that should be added to the base address to create a local
     anchor point, and an additional offset that can be applied to the
     anchor to address a value of mode MODE.  The idea is that the local
     anchor could be shared by other accesses to nearby locations.

     The hook returns true if it succeeds, storing the offset of the
     anchor from the base in OFFSET1 and the offset of the final address
     from the anchor in OFFSET2.  The default implementation returns
     false.

 -- Target Hook: reg_class_t TARGET_SPILL_CLASS (reg_class_t,
          MACHINE_MODE)
     This hook defines a class of registers which could be used for
     spilling pseudos of the given mode and class, or 'NO_REGS' if only
     memory should be used.  Not defining this hook is equivalent to
     returning 'NO_REGS' for all inputs.

 -- Target Hook: bool TARGET_ADDITIONAL_ALLOCNO_CLASS_P (reg_class_t)
     This hook should return 'true' if given class of registers should
     be an allocno class in any way.  Usually RA uses only one register
     class from all classes containing the same register set.  In some
     complicated cases, you need to have two or more such classes as
     allocno ones for RA correct work.  Not defining this hook is
     equivalent to returning 'false' for all inputs.

 -- Target Hook: scalar_int_mode TARGET_CSTORE_MODE (enum insn_code
          ICODE)
     This hook defines the machine mode to use for the boolean result of
     conditional store patterns.  The ICODE argument is the instruction
     code for the cstore being performed.  Not definiting this hook is
     the same as accepting the mode encoded into operand 0 of the cstore
     expander patterns.

 -- Target Hook: int TARGET_COMPUTE_PRESSURE_CLASSES (enum reg_class
          *PRESSURE_CLASSES)
     A target hook which lets a backend compute the set of pressure
     classes to be used by those optimization passes which take register
     pressure into account, as opposed to letting IRA compute them.  It
     returns the number of register classes stored in the array
     PRESSURE_CLASSES.

==============================================================================
File: gccint.info,  Node: |Stack_and_Calling|,  Next: |Varargs|,  Prev: |Register_Classes|,  Up: |Target_Macros|
==============================================================================

                                                             *Stack_and_Calling*

18.9 Stack Layout and Calling Conventions
-----------------------------------------

This describes the stack layout and calling conventions.

MENU

* |Frame_Layout|::
* |Exception_Handling|::
* |Stack_Checking|::
* |Frame_Registers|::
* |Elimination|::
* |Stack_Arguments|::
* |Register_Arguments|::
* |Scalar_Return|::
* |Aggregate_Return|::
* |Caller_Saves|::
* |Function_Entry|::
* |Profiling|::
* |Tail_Calls|::
* |Shrink_wrapping_separate_components|::
* |Stack_Smashing_Protection|::
* |Miscellaneous_Register_Hooks|::

==============================================================================
File: gccint.info,  Node: |Frame_Layout|,  Next: |Exception_Handling|,  Up: |Stack_and_Calling|
==============================================================================

                                                                  *Frame_Layout*

18.9.1 Basic Stack Layout
-------------------------

Here is the basic stack layout.

 -- Macro: STACK_GROWS_DOWNWARD
     Define this macro to be true if pushing a word onto the stack moves
     the stack pointer to a smaller address, and false otherwise.

 -- Macro: STACK_PUSH_CODE
     This macro defines the operation used when something is pushed on
     the stack.  In RTL, a push operation will be '(set (mem
     (STACK_PUSH_CODE (reg sp))) ...)'

     The choices are 'PRE_DEC', 'POST_DEC', 'PRE_INC', and 'POST_INC'.
     Which of these is correct depends on the stack direction and on
     whether the stack pointer points to the last item on the stack or
     whether it points to the space for the next item on the stack.

     The default is 'PRE_DEC' when 'STACK_GROWS_DOWNWARD' is true, which
     is almost always right, and 'PRE_INC' otherwise, which is often
     wrong.

 -- Macro: FRAME_GROWS_DOWNWARD
     Define this macro to nonzero value if the addresses of local
     variable slots are at negative offsets from the frame pointer.

 -- Macro: ARGS_GROW_DOWNWARD
     Define this macro if successive arguments to a function occupy
     decreasing addresses on the stack.

 -- Target Hook: HOST_WIDE_INT TARGET_STARTING_FRAME_OFFSET (void)
     This hook returns the offset from the frame pointer to the first
     local variable slot to be allocated.  If 'FRAME_GROWS_DOWNWARD', it
     is the offset to _end_ of the first slot allocated, otherwise it is
     the offset to _beginning_ of the first slot allocated.  The default
     implementation returns 0.

 -- Macro: STACK_ALIGNMENT_NEEDED
     Define to zero to disable final alignment of the stack during
     reload.  The nonzero default for this macro is suitable for most
     ports.

     On ports where 'TARGET_STARTING_FRAME_OFFSET' is nonzero or where
     there is a register save block following the local block that
     doesn't require alignment to 'STACK_BOUNDARY', it may be beneficial
     to disable stack alignment and do it in the backend.

 -- Macro: STACK_POINTER_OFFSET
     Offset from the stack pointer register to the first location at
     which outgoing arguments are placed.  If not specified, the default
     value of zero is used.  This is the proper value for most machines.

     If 'ARGS_GROW_DOWNWARD', this is the offset to the location above
     the first location at which outgoing arguments are placed.

 -- Macro: FIRST_PARM_OFFSET (FUNDECL)
     Offset from the argument pointer register to the first argument's
     address.  On some machines it may depend on the data type of the
     function.

     If 'ARGS_GROW_DOWNWARD', this is the offset to the location above
     the first argument's address.

 -- Macro: STACK_DYNAMIC_OFFSET (FUNDECL)
     Offset from the stack pointer register to an item dynamically
     allocated on the stack, e.g., by 'alloca'.

     The default value for this macro is 'STACK_POINTER_OFFSET' plus the
     length of the outgoing arguments.  The default is correct for most
     machines.  See 'function.c' for details.

 -- Macro: INITIAL_FRAME_ADDRESS_RTX
     A C expression whose value is RTL representing the address of the
     initial stack frame.  This address is passed to 'RETURN_ADDR_RTX'
     and 'DYNAMIC_CHAIN_ADDRESS'.  If you don't define this macro, a
     reasonable default value will be used.  Define this macro in order
     to make frame pointer elimination work in the presence of
     '__builtin_frame_address (count)' and '__builtin_return_address
     (count)' for 'count' not equal to zero.

 -- Macro: DYNAMIC_CHAIN_ADDRESS (FRAMEADDR)
     A C expression whose value is RTL representing the address in a
     stack frame where the pointer to the caller's frame is stored.
     Assume that FRAMEADDR is an RTL expression for the address of the
     stack frame itself.

     If you don't define this macro, the default is to return the value
     of FRAMEADDR--that is, the stack frame address is also the address
     of the stack word that points to the previous frame.

 -- Macro: SETUP_FRAME_ADDRESSES
     A C expression that produces the machine-specific code to setup the
     stack so that arbitrary frames can be accessed.  For example, on
     the SPARC, we must flush all of the register windows to the stack
     before we can access arbitrary stack frames.  You will seldom need
     to define this macro.  The default is to do nothing.

 -- Target Hook: rtx TARGET_BUILTIN_SETJMP_FRAME_VALUE (void)
     This target hook should return an rtx that is used to store the
     address of the current frame into the built in 'setjmp' buffer.
     The default value, 'virtual_stack_vars_rtx', is correct for most
     machines.  One reason you may need to define this target hook is if
     'hard_frame_pointer_rtx' is the appropriate value on your machine.

 -- Macro: FRAME_ADDR_RTX (FRAMEADDR)
     A C expression whose value is RTL representing the value of the
     frame address for the current frame.  FRAMEADDR is the frame
     pointer of the current frame.  This is used for
     __builtin_frame_address.  You need only define this macro if the
     frame address is not the same as the frame pointer.  Most machines
     do not need to define it.

 -- Macro: RETURN_ADDR_RTX (COUNT, FRAMEADDR)
     A C expression whose value is RTL representing the value of the
     return address for the frame COUNT steps up from the current frame,
     after the prologue.  FRAMEADDR is the frame pointer of the COUNT
     frame, or the frame pointer of the COUNT - 1 frame if
     'RETURN_ADDR_IN_PREVIOUS_FRAME' is nonzero.

     The value of the expression must always be the correct address when
     COUNT is zero, but may be 'NULL_RTX' if there is no way to
     determine the return address of other frames.

 -- Macro: RETURN_ADDR_IN_PREVIOUS_FRAME
     Define this macro to nonzero value if the return address of a
     particular stack frame is accessed from the frame pointer of the
     previous stack frame.  The zero default for this macro is suitable
     for most ports.

 -- Macro: INCOMING_RETURN_ADDR_RTX
     A C expression whose value is RTL representing the location of the
     incoming return address at the beginning of any function, before
     the prologue.  This RTL is either a 'REG', indicating that the
     return value is saved in 'REG', or a 'MEM' representing a location
     in the stack.

     You only need to define this macro if you want to support call
     frame debugging information like that provided by DWARF 2.

     If this RTL is a 'REG', you should also define
     'DWARF_FRAME_RETURN_COLUMN' to 'DWARF_FRAME_REGNUM (REGNO)'.

 -- Macro: DWARF_ALT_FRAME_RETURN_COLUMN
     A C expression whose value is an integer giving a DWARF 2 column
     number that may be used as an alternative return column.  The
     column must not correspond to any gcc hard register (that is, it
     must not be in the range of 'DWARF_FRAME_REGNUM').

     This macro can be useful if 'DWARF_FRAME_RETURN_COLUMN' is set to a
     general register, but an alternative column needs to be used for
     signal frames.  Some targets have also used different frame return
     columns over time.

 -- Macro: DWARF_ZERO_REG
     A C expression whose value is an integer giving a DWARF 2 register
     number that is considered to always have the value zero.  This
     should only be defined if the target has an architected zero
     register, and someone decided it was a good idea to use that
     register number to terminate the stack backtrace.  New ports should
     avoid this.

 -- Target Hook: void TARGET_DWARF_HANDLE_FRAME_UNSPEC (const char
          *LABEL, rtx PATTERN, int INDEX)
     This target hook allows the backend to emit frame-related insns
     that contain UNSPECs or UNSPEC_VOLATILEs.  The DWARF 2 call frame
     debugging info engine will invoke it on insns of the form
          (set (reg) (unspec [...] UNSPEC_INDEX))
     and
          (set (reg) (unspec_volatile [...] UNSPECV_INDEX)).
     to let the backend emit the call frame instructions.  LABEL is the
     CFI label attached to the insn, PATTERN is the pattern of the insn
     and INDEX is 'UNSPEC_INDEX' or 'UNSPECV_INDEX'.

 -- Target Hook: unsigned int TARGET_DWARF_POLY_INDETERMINATE_VALUE
          (unsigned int I, unsigned int *FACTOR, int *OFFSET)
     Express the value of 'poly_int' indeterminate I as a DWARF
     expression, with I counting from 1.  Return the number of a DWARF
     register R and set '*FACTOR' and '*OFFSET' such that the value of
     the indeterminate is:
          value_of(R) / FACTOR - OFFSET

     A target only needs to define this hook if it sets
     'NUM_POLY_INT_COEFFS' to a value greater than 1.

 -- Macro: INCOMING_FRAME_SP_OFFSET
     A C expression whose value is an integer giving the offset, in
     bytes, from the value of the stack pointer register to the top of
     the stack frame at the beginning of any function, before the
     prologue.  The top of the frame is defined to be the value of the
     stack pointer in the previous frame, just before the call
     instruction.

     You only need to define this macro if you want to support call
     frame debugging information like that provided by DWARF 2.

 -- Macro: DEFAULT_INCOMING_FRAME_SP_OFFSET
     Like 'INCOMING_FRAME_SP_OFFSET', but must be the same for all
     functions of the same ABI, and when using GAS '.cfi_*' directives
     must also agree with the default CFI GAS emits.  Define this macro
     only if 'INCOMING_FRAME_SP_OFFSET' can have different values
     between different functions of the same ABI or when
     'INCOMING_FRAME_SP_OFFSET' does not agree with GAS default CFI.

 -- Macro: ARG_POINTER_CFA_OFFSET (FUNDECL)
     A C expression whose value is an integer giving the offset, in
     bytes, from the argument pointer to the canonical frame address
     (cfa).  The final value should coincide with that calculated by
     'INCOMING_FRAME_SP_OFFSET'.  Which is unfortunately not usable
     during virtual register instantiation.

     The default value for this macro is 'FIRST_PARM_OFFSET (fundecl) +
     crtl->args.pretend_args_size', which is correct for most machines;
     in general, the arguments are found immediately before the stack
     frame.  Note that this is not the case on some targets that save
     registers into the caller's frame, such as SPARC and rs6000, and so
     such targets need to define this macro.

     You only need to define this macro if the default is incorrect, and
     you want to support call frame debugging information like that
     provided by DWARF 2.

 -- Macro: FRAME_POINTER_CFA_OFFSET (FUNDECL)
     If defined, a C expression whose value is an integer giving the
     offset in bytes from the frame pointer to the canonical frame
     address (cfa).  The final value should coincide with that
     calculated by 'INCOMING_FRAME_SP_OFFSET'.

     Normally the CFA is calculated as an offset from the argument
     pointer, via 'ARG_POINTER_CFA_OFFSET', but if the argument pointer
     is variable due to the ABI, this may not be possible.  If this
     macro is defined, it implies that the virtual register
     instantiation should be based on the frame pointer instead of the
     argument pointer.  Only one of 'FRAME_POINTER_CFA_OFFSET' and
     'ARG_POINTER_CFA_OFFSET' should be defined.

 -- Macro: CFA_FRAME_BASE_OFFSET (FUNDECL)
     If defined, a C expression whose value is an integer giving the
     offset in bytes from the canonical frame address (cfa) to the frame
     base used in DWARF 2 debug information.  The default is zero.  A
     different value may reduce the size of debug information on some
     ports.

==============================================================================
File: gccint.info,  Node: |Exception_Handling|,  Next: |Stack_Checking|,  Prev: |Frame_Layout|,  Up: |Stack_and_Calling|
==============================================================================

                                                            *Exception_Handling*

18.9.2 Exception Handling Support
---------------------------------

 -- Macro: EH_RETURN_DATA_REGNO (N)
     A C expression whose value is the Nth register number used for data
     by exception handlers, or 'INVALID_REGNUM' if fewer than N
     registers are usable.

     The exception handling library routines communicate with the
     exception handlers via a set of agreed upon registers.  Ideally
     these registers should be call-clobbered; it is possible to use
     call-saved registers, but may negatively impact code size.  The
     target must support at least 2 data registers, but should define 4
     if there are enough free registers.

     You must define this macro if you want to support call frame
     exception handling like that provided by DWARF 2.

 -- Macro: EH_RETURN_STACKADJ_RTX
     A C expression whose value is RTL representing a location in which
     to store a stack adjustment to be applied before function return.
     This is used to unwind the stack to an exception handler's call
     frame.  It will be assigned zero on code paths that return
     normally.

     Typically this is a call-clobbered hard register that is otherwise
     untouched by the epilogue, but could also be a stack slot.

     Do not define this macro if the stack pointer is saved and restored
     by the regular prolog and epilog code in the call frame itself; in
     this case, the exception handling library routines will update the
     stack location to be restored in place.  Otherwise, you must define
     this macro if you want to support call frame exception handling
     like that provided by DWARF 2.

 -- Macro: EH_RETURN_HANDLER_RTX
     A C expression whose value is RTL representing a location in which
     to store the address of an exception handler to which we should
     return.  It will not be assigned on code paths that return
     normally.

     Typically this is the location in the call frame at which the
     normal return address is stored.  For targets that return by
     popping an address off the stack, this might be a memory address
     just below the _target_ call frame rather than inside the current
     call frame.  If defined, 'EH_RETURN_STACKADJ_RTX' will have already
     been assigned, so it may be used to calculate the location of the
     target call frame.

     Some targets have more complex requirements than storing to an
     address calculable during initial code generation.  In that case
     the 'eh_return' instruction pattern should be used instead.

     If you want to support call frame exception handling, you must
     define either this macro or the 'eh_return' instruction pattern.

 -- Macro: RETURN_ADDR_OFFSET
     If defined, an integer-valued C expression for which rtl will be
     generated to add it to the exception handler address before it is
     searched in the exception handling tables, and to subtract it again
     from the address before using it to return to the exception
     handler.

 -- Macro: ASM_PREFERRED_EH_DATA_FORMAT (CODE, GLOBAL)
     This macro chooses the encoding of pointers embedded in the
     exception handling sections.  If at all possible, this should be
     defined such that the exception handling section will not require
     dynamic relocations, and so may be read-only.

     CODE is 0 for data, 1 for code labels, 2 for function pointers.
     GLOBAL is true if the symbol may be affected by dynamic
     relocations.  The macro should return a combination of the
     'DW_EH_PE_*' defines as found in 'dwarf2.h'.

     If this macro is not defined, pointers will not be encoded but
     represented directly.

 -- Macro: ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX (FILE, ENCODING, SIZE,
          ADDR, DONE)
     This macro allows the target to emit whatever special magic is
     required to represent the encoding chosen by
     'ASM_PREFERRED_EH_DATA_FORMAT'.  Generic code takes care of
     pc-relative and indirect encodings; this must be defined if the
     target uses text-relative or data-relative encodings.

     This is a C statement that branches to DONE if the format was
     handled.  ENCODING is the format chosen, SIZE is the number of
     bytes that the format occupies, ADDR is the 'SYMBOL_REF' to be
     emitted.

 -- Macro: MD_FALLBACK_FRAME_STATE_FOR (CONTEXT, FS)
     This macro allows the target to add CPU and operating system
     specific code to the call-frame unwinder for use when there is no
     unwind data available.  The most common reason to implement this
     macro is to unwind through signal frames.

     This macro is called from 'uw_frame_state_for' in 'unwind-dw2.c',
     'unwind-dw2-xtensa.c' and 'unwind-ia64.c'.  CONTEXT is an
     '_Unwind_Context'; FS is an '_Unwind_FrameState'.  Examine
     'context->ra' for the address of the code being executed and
     'context->cfa' for the stack pointer value.  If the frame can be
     decoded, the register save addresses should be updated in FS and
     the macro should evaluate to '_URC_NO_REASON'.  If the frame cannot
     be decoded, the macro should evaluate to '_URC_END_OF_STACK'.

     For proper signal handling in Java this macro is accompanied by
     'MAKE_THROW_FRAME', defined in 'libjava/include/*-signal.h'
     headers.

 -- Macro: MD_HANDLE_UNWABI (CONTEXT, FS)
     This macro allows the target to add operating system specific code
     to the call-frame unwinder to handle the IA-64 '.unwabi' unwinding
     directive, usually used for signal or interrupt frames.

     This macro is called from 'uw_update_context' in libgcc's
     'unwind-ia64.c'.  CONTEXT is an '_Unwind_Context'; FS is an
     '_Unwind_FrameState'.  Examine 'fs->unwabi' for the abi and context
     in the '.unwabi' directive.  If the '.unwabi' directive can be
     handled, the register save addresses should be updated in FS.

 -- Macro: TARGET_USES_WEAK_UNWIND_INFO
     A C expression that evaluates to true if the target requires unwind
     info to be given comdat linkage.  Define it to be '1' if comdat
     linkage is necessary.  The default is '0'.

==============================================================================
File: gccint.info,  Node: |Stack_Checking|,  Next: |Frame_Registers|,  Prev: |Exception_Handling|,  Up: |Stack_and_Calling|
==============================================================================

                                                                *Stack_Checking*

18.9.3 Specifying How Stack Checking is Done
--------------------------------------------

GCC will check that stack references are within the boundaries of the
stack, if the option '-fstack-check' is specified, in one of three ways:

  1. If the value of the 'STACK_CHECK_BUILTIN' macro is nonzero, GCC
     will assume that you have arranged for full stack checking to be
     done at appropriate places in the configuration files.  GCC will
     not do other special processing.

  2. If 'STACK_CHECK_BUILTIN' is zero and the value of the
     'STACK_CHECK_STATIC_BUILTIN' macro is nonzero, GCC will assume that
     you have arranged for static stack checking (checking of the static
     stack frame of functions) to be done at appropriate places in the
     configuration files.  GCC will only emit code to do dynamic stack
     checking (checking on dynamic stack allocations) using the third
     approach below.

  3. If neither of the above are true, GCC will generate code to
     periodically "probe" the stack pointer using the values of the
     macros defined below.

 If neither STACK_CHECK_BUILTIN nor STACK_CHECK_STATIC_BUILTIN is
defined, GCC will change its allocation strategy for large objects if
the option '-fstack-check' is specified: they will always be allocated
dynamically if their size exceeds 'STACK_CHECK_MAX_VAR_SIZE' bytes.

 -- Macro: STACK_CHECK_BUILTIN
     A nonzero value if stack checking is done by the configuration
     files in a machine-dependent manner.  You should define this macro
     if stack checking is required by the ABI of your machine or if you
     would like to do stack checking in some more efficient way than the
     generic approach.  The default value of this macro is zero.

 -- Macro: STACK_CHECK_STATIC_BUILTIN
     A nonzero value if static stack checking is done by the
     configuration files in a machine-dependent manner.  You should
     define this macro if you would like to do static stack checking in
     some more efficient way than the generic approach.  The default
     value of this macro is zero.

 -- Macro: STACK_CHECK_PROBE_INTERVAL_EXP
     An integer specifying the interval at which GCC must generate stack
     probe instructions, defined as 2 raised to this integer.  You will
     normally define this macro so that the interval be no larger than
     the size of the "guard pages" at the end of a stack area.  The
     default value of 12 (4096-byte interval) is suitable for most
     systems.

 -- Macro: STACK_CHECK_MOVING_SP
     An integer which is nonzero if GCC should move the stack pointer
     page by page when doing probes.  This can be necessary on systems
     where the stack pointer contains the bottom address of the memory
     area accessible to the executing thread at any point in time.  In
     this situation an alternate signal stack is required in order to be
     able to recover from a stack overflow.  The default value of this
     macro is zero.

 -- Macro: STACK_CHECK_PROTECT
     The number of bytes of stack needed to recover from a stack
     overflow, for languages where such a recovery is supported.  The
     default value of 4KB/8KB with the 'setjmp'/'longjmp'-based
     exception handling mechanism and 8KB/12KB with other exception
     handling mechanisms should be adequate for most architectures and
     operating systems.

 The following macros are relevant only if neither STACK_CHECK_BUILTIN
nor STACK_CHECK_STATIC_BUILTIN is defined; you can omit them altogether
in the opposite case.

 -- Macro: STACK_CHECK_MAX_FRAME_SIZE
     The maximum size of a stack frame, in bytes.  GCC will generate
     probe instructions in non-leaf functions to ensure at least this
     many bytes of stack are available.  If a stack frame is larger than
     this size, stack checking will not be reliable and GCC will issue a
     warning.  The default is chosen so that GCC only generates one
     instruction on most systems.  You should normally not change the
     default value of this macro.

 -- Macro: STACK_CHECK_FIXED_FRAME_SIZE
     GCC uses this value to generate the above warning message.  It
     represents the amount of fixed frame used by a function, not
     including space for any callee-saved registers, temporaries and
     user variables.  You need only specify an upper bound for this
     amount and will normally use the default of four words.

 -- Macro: STACK_CHECK_MAX_VAR_SIZE
     The maximum size, in bytes, of an object that GCC will place in the
     fixed area of the stack frame when the user specifies
     '-fstack-check'.  GCC computed the default from the values of the
     above macros and you will normally not need to override that
     default.

 -- Target Hook: HOST_WIDE_INT
          TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE (void)
     Some targets have an ABI defined interval for which no probing
     needs to be done.  When a probe does need to be done this same
     interval is used as the probe distance up when doing stack clash
     protection for alloca.  On such targets this value can be set to
     override the default probing up interval.  Define this variable to
     return nonzero if such a probe range is required or zero otherwise.
     Defining this hook also requires your functions which make use of
     alloca to have at least 8 byesof outgoing arguments.  If this is
     not the case the stack will be corrupted.  You need not define this
     macro if it would always have the value zero.

==============================================================================
File: gccint.info,  Node: |Frame_Registers|,  Next: |Elimination|,  Prev: |Stack_Checking|,  Up: |Stack_and_Calling|
==============================================================================

                                                               *Frame_Registers*

18.9.4 Registers That Address the Stack Frame
---------------------------------------------

This discusses registers that address the stack frame.

 -- Macro: STACK_POINTER_REGNUM
     The register number of the stack pointer register, which must also
     be a fixed register according to 'FIXED_REGISTERS'.  On most
     machines, the hardware determines which register this is.

 -- Macro: FRAME_POINTER_REGNUM
     The register number of the frame pointer register, which is used to
     access automatic variables in the stack frame.  On some machines,
     the hardware determines which register this is.  On other machines,
     you can choose any register you wish for this purpose.

 -- Macro: HARD_FRAME_POINTER_REGNUM
     On some machines the offset between the frame pointer and starting
     offset of the automatic variables is not known until after register
     allocation has been done (for example, because the saved registers
     are between these two locations).  On those machines, define
     'FRAME_POINTER_REGNUM' the number of a special, fixed register to
     be used internally until the offset is known, and define
     'HARD_FRAME_POINTER_REGNUM' to be the actual hard register number
     used for the frame pointer.

     You should define this macro only in the very rare circumstances
     when it is not possible to calculate the offset between the frame
     pointer and the automatic variables until after register allocation
     has been completed.  When this macro is defined, you must also
     indicate in your definition of 'ELIMINABLE_REGS' how to eliminate
     'FRAME_POINTER_REGNUM' into either 'HARD_FRAME_POINTER_REGNUM' or
     'STACK_POINTER_REGNUM'.

     Do not define this macro if it would be the same as
     'FRAME_POINTER_REGNUM'.

 -- Macro: ARG_POINTER_REGNUM
     The register number of the arg pointer register, which is used to
     access the function's argument list.  On some machines, this is the
     same as the frame pointer register.  On some machines, the hardware
     determines which register this is.  On other machines, you can
     choose any register you wish for this purpose.  If this is not the
     same register as the frame pointer register, then you must mark it
     as a fixed register according to 'FIXED_REGISTERS', or arrange to
     be able to eliminate it (*note Elimination::).

 -- Macro: HARD_FRAME_POINTER_IS_FRAME_POINTER
     Define this to a preprocessor constant that is nonzero if
     'hard_frame_pointer_rtx' and 'frame_pointer_rtx' should be the
     same.  The default definition is '(HARD_FRAME_POINTER_REGNUM ==
     FRAME_POINTER_REGNUM)'; you only need to define this macro if that
     definition is not suitable for use in preprocessor conditionals.

 -- Macro: HARD_FRAME_POINTER_IS_ARG_POINTER
     Define this to a preprocessor constant that is nonzero if
     'hard_frame_pointer_rtx' and 'arg_pointer_rtx' should be the same.
     The default definition is '(HARD_FRAME_POINTER_REGNUM ==
     ARG_POINTER_REGNUM)'; you only need to define this macro if that
     definition is not suitable for use in preprocessor conditionals.

 -- Macro: RETURN_ADDRESS_POINTER_REGNUM
     The register number of the return address pointer register, which
     is used to access the current function's return address from the
     stack.  On some machines, the return address is not at a fixed
     offset from the frame pointer or stack pointer or argument pointer.
     This register can be defined to point to the return address on the
     stack, and then be converted by 'ELIMINABLE_REGS' into either the
     frame pointer or stack pointer.

     Do not define this macro unless there is no other way to get the
     return address from the stack.

 -- Macro: STATIC_CHAIN_REGNUM
 -- Macro: STATIC_CHAIN_INCOMING_REGNUM
     Register numbers used for passing a function's static chain
     pointer.  If register windows are used, the register number as seen
     by the called function is 'STATIC_CHAIN_INCOMING_REGNUM', while the
     register number as seen by the calling function is
     'STATIC_CHAIN_REGNUM'.  If these registers are the same,
     'STATIC_CHAIN_INCOMING_REGNUM' need not be defined.

     The static chain register need not be a fixed register.

     If the static chain is passed in memory, these macros should not be
     defined; instead, the 'TARGET_STATIC_CHAIN' hook should be used.

 -- Target Hook: rtx TARGET_STATIC_CHAIN (const_tree FNDECL_OR_TYPE,
          bool INCOMING_P)
     This hook replaces the use of 'STATIC_CHAIN_REGNUM' et al for
     targets that may use different static chain locations for different
     nested functions.  This may be required if the target has function
     attributes that affect the calling conventions of the function and
     those calling conventions use different static chain locations.

     The default version of this hook uses 'STATIC_CHAIN_REGNUM' et al.

     If the static chain is passed in memory, this hook should be used
     to provide rtx giving 'mem' expressions that denote where they are
     stored.  Often the 'mem' expression as seen by the caller will be
     at an offset from the stack pointer and the 'mem' expression as
     seen by the callee will be at an offset from the frame pointer.
     The variables 'stack_pointer_rtx', 'frame_pointer_rtx', and
     'arg_pointer_rtx' will have been initialized and should be used to
     refer to those items.

 -- Macro: DWARF_FRAME_REGISTERS
     This macro specifies the maximum number of hard registers that can
     be saved in a call frame.  This is used to size data structures
     used in DWARF2 exception handling.

     Prior to GCC 3.0, this macro was needed in order to establish a
     stable exception handling ABI in the face of adding new hard
     registers for ISA extensions.  In GCC 3.0 and later, the EH ABI is
     insulated from changes in the number of hard registers.
     Nevertheless, this macro can still be used to reduce the runtime
     memory requirements of the exception handling routines, which can
     be substantial if the ISA contains a lot of registers that are not
     call-saved.

     If this macro is not defined, it defaults to
     'FIRST_PSEUDO_REGISTER'.

 -- Macro: PRE_GCC3_DWARF_FRAME_REGISTERS

     This macro is similar to 'DWARF_FRAME_REGISTERS', but is provided
     for backward compatibility in pre GCC 3.0 compiled code.

     If this macro is not defined, it defaults to
     'DWARF_FRAME_REGISTERS'.

 -- Macro: DWARF_REG_TO_UNWIND_COLUMN (REGNO)

     Define this macro if the target's representation for dwarf
     registers is different than the internal representation for unwind
     column.  Given a dwarf register, this macro should return the
     internal unwind column number to use instead.

 -- Macro: DWARF_FRAME_REGNUM (REGNO)

     Define this macro if the target's representation for dwarf
     registers used in .eh_frame or .debug_frame is different from that
     used in other debug info sections.  Given a GCC hard register
     number, this macro should return the .eh_frame register number.
     The default is 'DBX_REGISTER_NUMBER (REGNO)'.

 -- Macro: DWARF2_FRAME_REG_OUT (REGNO, FOR_EH)

     Define this macro to map register numbers held in the call frame
     info that GCC has collected using 'DWARF_FRAME_REGNUM' to those
     that should be output in .debug_frame ('FOR_EH' is zero) and
     .eh_frame ('FOR_EH' is nonzero).  The default is to return 'REGNO'.

 -- Macro: REG_VALUE_IN_UNWIND_CONTEXT

     Define this macro if the target stores register values as
     '_Unwind_Word' type in unwind context.  It should be defined if
     target register size is larger than the size of 'void *'.  The
     default is to store register values as 'void *' type.

 -- Macro: ASSUME_EXTENDED_UNWIND_CONTEXT

     Define this macro to be 1 if the target always uses extended unwind
     context with version, args_size and by_value fields.  If it is
     undefined, it will be defined to 1 when
     'REG_VALUE_IN_UNWIND_CONTEXT' is defined and 0 otherwise.

 -- Macro: DWARF_LAZY_REGISTER_VALUE (REGNO, VALUE)
     Define this macro if the target has pseudo DWARF registers whose
     values need to be computed lazily on demand by the unwinder (such
     as when referenced in a CFA expression).  The macro returns true if
     REGNO is such a register and stores its value in '*VALUE' if so.

==============================================================================
File: gccint.info,  Node: |Elimination|,  Next: |Stack_Arguments|,  Prev: |Frame_Registers|,  Up: |Stack_and_Calling|
==============================================================================

                                                                   *Elimination*

18.9.5 Eliminating Frame Pointer and Arg Pointer
------------------------------------------------

This is about eliminating the frame pointer and arg pointer.

 -- Target Hook: bool TARGET_FRAME_POINTER_REQUIRED (void)
     This target hook should return 'true' if a function must have and
     use a frame pointer.  This target hook is called in the reload
     pass.  If its return value is 'true' the function will have a frame
     pointer.

     This target hook can in principle examine the current function and
     decide according to the facts, but on most machines the constant
     'false' or the constant 'true' suffices.  Use 'false' when the
     machine allows code to be generated with no frame pointer, and
     doing so saves some time or space.  Use 'true' when there is no
     possible advantage to avoiding a frame pointer.

     In certain cases, the compiler does not know how to produce valid
     code without a frame pointer.  The compiler recognizes those cases
     and automatically gives the function a frame pointer regardless of
     what 'targetm.frame_pointer_required' returns.  You don't need to
     worry about them.

     In a function that does not require a frame pointer, the frame
     pointer register can be allocated for ordinary usage, unless you
     mark it as a fixed register.  See 'FIXED_REGISTERS' for more
     information.

     Default return value is 'false'.

 -- Macro: ELIMINABLE_REGS
     This macro specifies a table of register pairs used to eliminate
     unneeded registers that point into the stack frame.

     The definition of this macro is a list of structure
     initializations, each of which specifies an original and
     replacement register.

     On some machines, the position of the argument pointer is not known
     until the compilation is completed.  In such a case, a separate
     hard register must be used for the argument pointer.  This register
     can be eliminated by replacing it with either the frame pointer or
     the argument pointer, depending on whether or not the frame pointer
     has been eliminated.

     In this case, you might specify:
          #define ELIMINABLE_REGS  \
          {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \
           {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \
           {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}

     Note that the elimination of the argument pointer with the stack
     pointer is specified first since that is the preferred elimination.

 -- Target Hook: bool TARGET_CAN_ELIMINATE (const int FROM_REG, const
          int TO_REG)
     This target hook should return 'true' if the compiler is allowed to
     try to replace register number FROM_REG with register number
     TO_REG.  This target hook will usually be 'true', since most of the
     cases preventing register elimination are things that the compiler
     already knows about.

     Default return value is 'true'.

 -- Macro: INITIAL_ELIMINATION_OFFSET (FROM-REG, TO-REG, OFFSET-VAR)
     This macro returns the initial difference between the specified
     pair of registers.  The value would be computed from information
     such as the result of 'get_frame_size ()' and the tables of
     registers 'df_regs_ever_live_p' and 'call_used_regs'.

 -- Target Hook: void TARGET_COMPUTE_FRAME_LAYOUT (void)
     This target hook is called once each time the frame layout needs to
     be recalculated.  The calculations can be cached by the target and
     can then be used by 'INITIAL_ELIMINATION_OFFSET' instead of
     re-computing the layout on every invocation of that hook.  This is
     particularly useful for targets that have an expensive frame layout
     function.  Implementing this callback is optional.

==============================================================================
File: gccint.info,  Node: |Stack_Arguments|,  Next: |Register_Arguments|,  Prev: |Elimination|,  Up: |Stack_and_Calling|
==============================================================================

                                                               *Stack_Arguments*

18.9.6 Passing Function Arguments on the Stack
----------------------------------------------

The macros in this section control how arguments are passed on the
stack.  See the following section for other macros that control passing
certain arguments in registers.

 -- Target Hook: bool TARGET_PROMOTE_PROTOTYPES (const_tree FNTYPE)
     This target hook returns 'true' if an argument declared in a
     prototype as an integral type smaller than 'int' should actually be
     passed as an 'int'.  In addition to avoiding errors in certain
     cases of mismatch, it also makes for better code on certain
     machines.  The default is to not promote prototypes.

 -- Macro: PUSH_ARGS
     A C expression.  If nonzero, push insns will be used to pass
     outgoing arguments.  If the target machine does not have a push
     instruction, set it to zero.  That directs GCC to use an alternate
     strategy: to allocate the entire argument block and then store the
     arguments into it.  When 'PUSH_ARGS' is nonzero, 'PUSH_ROUNDING'
     must be defined too.

 -- Macro: PUSH_ARGS_REVERSED
     A C expression.  If nonzero, function arguments will be evaluated
     from last to first, rather than from first to last.  If this macro
     is not defined, it defaults to 'PUSH_ARGS' on targets where the
     stack and args grow in opposite directions, and 0 otherwise.

 -- Macro: PUSH_ROUNDING (NPUSHED)
     A C expression that is the number of bytes actually pushed onto the
     stack when an instruction attempts to push NPUSHED bytes.

     On some machines, the definition

          #define PUSH_ROUNDING(BYTES) (BYTES)

     will suffice.  But on other machines, instructions that appear to
     push one byte actually push two bytes in an attempt to maintain
     alignment.  Then the definition should be

          #define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)

     If the value of this macro has a type, it should be an unsigned
     type.

 -- Macro: ACCUMULATE_OUTGOING_ARGS
     A C expression.  If nonzero, the maximum amount of space required
     for outgoing arguments will be computed and placed into
     'crtl->outgoing_args_size'.  No space will be pushed onto the stack
     for each call; instead, the function prologue should increase the
     stack frame size by this amount.

     Setting both 'PUSH_ARGS' and 'ACCUMULATE_OUTGOING_ARGS' is not
     proper.

 -- Macro: REG_PARM_STACK_SPACE (FNDECL)
     Define this macro if functions should assume that stack space has
     been allocated for arguments even when their values are passed in
     registers.

     The value of this macro is the size, in bytes, of the area reserved
     for arguments passed in registers for the function represented by
     FNDECL, which can be zero if GCC is calling a library function.
     The argument FNDECL can be the FUNCTION_DECL, or the type itself of
     the function.

     This space can be allocated by the caller, or be a part of the
     machine-dependent stack frame: 'OUTGOING_REG_PARM_STACK_SPACE' says
     which.

 -- Macro: INCOMING_REG_PARM_STACK_SPACE (FNDECL)
     Like 'REG_PARM_STACK_SPACE', but for incoming register arguments.
     Define this macro if space guaranteed when compiling a function
     body is different to space required when making a call, a situation
     that can arise with K&R style function definitions.

 -- Macro: OUTGOING_REG_PARM_STACK_SPACE (FNTYPE)
     Define this to a nonzero value if it is the responsibility of the
     caller to allocate the area reserved for arguments passed in
     registers when calling a function of FNTYPE.  FNTYPE may be NULL if
     the function called is a library function.

     If 'ACCUMULATE_OUTGOING_ARGS' is defined, this macro controls
     whether the space for these arguments counts in the value of
     'crtl->outgoing_args_size'.

 -- Macro: STACK_PARMS_IN_REG_PARM_AREA
     Define this macro if 'REG_PARM_STACK_SPACE' is defined, but the
     stack parameters don't skip the area specified by it.

     Normally, when a parameter is not passed in registers, it is placed
     on the stack beyond the 'REG_PARM_STACK_SPACE' area.  Defining this
     macro suppresses this behavior and causes the parameter to be
     passed on the stack in its natural location.

 -- Target Hook: poly_int64 TARGET_RETURN_POPS_ARGS (tree FUNDECL, tree
          FUNTYPE, poly_int64 SIZE)
     This target hook returns the number of bytes of its own arguments
     that a function pops on returning, or 0 if the function pops no
     arguments and the caller must therefore pop them all after the
     function returns.

     FUNDECL is a C variable whose value is a tree node that describes
     the function in question.  Normally it is a node of type
     'FUNCTION_DECL' that describes the declaration of the function.
     From this you can obtain the 'DECL_ATTRIBUTES' of the function.

     FUNTYPE is a C variable whose value is a tree node that describes
     the function in question.  Normally it is a node of type
     'FUNCTION_TYPE' that describes the data type of the function.  From
     this it is possible to obtain the data types of the value and
     arguments (if known).

     When a call to a library function is being considered, FUNDECL will
     contain an identifier node for the library function.  Thus, if you
     need to distinguish among various library functions, you can do so
     by their names.  Note that "library function" in this context means
     a function used to perform arithmetic, whose name is known
     specially in the compiler and was not mentioned in the C code being
     compiled.

     SIZE is the number of bytes of arguments passed on the stack.  If a
     variable number of bytes is passed, it is zero, and argument
     popping will always be the responsibility of the calling function.

     On the VAX, all functions always pop their arguments, so the
     definition of this macro is SIZE.  On the 68000, using the standard
     calling convention, no functions pop their arguments, so the value
     of the macro is always 0 in this case.  But an alternative calling
     convention is available in which functions that take a fixed number
     of arguments pop them but other functions (such as 'printf') pop
     nothing (the caller pops all).  When this convention is in use,
     FUNTYPE is examined to determine whether a function takes a fixed
     number of arguments.

 -- Macro: CALL_POPS_ARGS (CUM)
     A C expression that should indicate the number of bytes a call
     sequence pops off the stack.  It is added to the value of
     'RETURN_POPS_ARGS' when compiling a function call.

     CUM is the variable in which all arguments to the called function
     have been accumulated.

     On certain architectures, such as the SH5, a call trampoline is
     used that pops certain registers off the stack, depending on the
     arguments that have been passed to the function.  Since this is a
     property of the call site, not of the called function,
     'RETURN_POPS_ARGS' is not appropriate.

==============================================================================
File: gccint.info,  Node: |Register_Arguments|,  Next: |Scalar_Return|,  Prev: |Stack_Arguments|,  Up: |Stack_and_Calling|
==============================================================================

                                                            *Register_Arguments*

18.9.7 Passing Arguments in Registers
-------------------------------------

This section describes the macros which let you control how various
types of arguments are passed in registers or how they are arranged in
the stack.

 -- Target Hook: rtx TARGET_FUNCTION_ARG (cumulative_args_t CA, const
          function_arg_info &ARG)
     Return an RTX indicating whether function argument ARG is passed in
     a register and if so, which register.  Argument CA summarizes all
     the previous arguments.

     The return value is usually either a 'reg' RTX for the hard
     register in which to pass the argument, or zero to pass the
     argument on the stack.

     The return value can be a 'const_int' which means argument is
     passed in a target specific slot with specified number.  Target
     hooks should be used to store or load argument in such case.  See
     'TARGET_STORE_BOUNDS_FOR_ARG' and 'TARGET_LOAD_BOUNDS_FOR_ARG' for
     more information.

     The value of the expression can also be a 'parallel' RTX.  This is
     used when an argument is passed in multiple locations.  The mode of
     the 'parallel' should be the mode of the entire argument.  The
     'parallel' holds any number of 'expr_list' pairs; each one
     describes where part of the argument is passed.  In each
     'expr_list' the first operand must be a 'reg' RTX for the hard
     register in which to pass this part of the argument, and the mode
     of the register RTX indicates how large this part of the argument
     is.  The second operand of the 'expr_list' is a 'const_int' which
     gives the offset in bytes into the entire argument of where this
     part starts.  As a special exception the first 'expr_list' in the
     'parallel' RTX may have a first operand of zero.  This indicates
     that the entire argument is also stored on the stack.

     The last time this hook is called, it is called with 'MODE ==
     VOIDmode', and its result is passed to the 'call' or 'call_value'
     pattern as operands 2 and 3 respectively.

     The usual way to make the ISO library 'stdarg.h' work on a machine
     where some arguments are usually passed in registers, is to cause
     nameless arguments to be passed on the stack instead.  This is done
     by making 'TARGET_FUNCTION_ARG' return 0 whenever NAMED is 'false'.

     You may use the hook 'targetm.calls.must_pass_in_stack' in the
     definition of this macro to determine if this argument is of a type
     that must be passed in the stack.  If 'REG_PARM_STACK_SPACE' is not
     defined and 'TARGET_FUNCTION_ARG' returns nonzero for such an
     argument, the compiler will abort.  If 'REG_PARM_STACK_SPACE' is
     defined, the argument will be computed in the stack and then loaded
     into a register.

 -- Target Hook: bool TARGET_MUST_PASS_IN_STACK (const function_arg_info
          &ARG)
     This target hook should return 'true' if we should not pass ARG
     solely in registers.  The file 'expr.h' defines a definition that
     is usually appropriate, refer to 'expr.h' for additional
     documentation.

 -- Target Hook: rtx TARGET_FUNCTION_INCOMING_ARG (cumulative_args_t CA,
          const function_arg_info &ARG)
     Define this hook if the caller and callee on the target have
     different views of where arguments are passed.  Also define this
     hook if there are functions that are never directly called, but are
     invoked by the hardware and which have nonstandard calling
     conventions.

     In this case 'TARGET_FUNCTION_ARG' computes the register in which
     the caller passes the value, and 'TARGET_FUNCTION_INCOMING_ARG'
     should be defined in a similar fashion to tell the function being
     called where the arguments will arrive.

     'TARGET_FUNCTION_INCOMING_ARG' can also return arbitrary address
     computation using hard register, which can be forced into a
     register, so that it can be used to pass special arguments.

     If 'TARGET_FUNCTION_INCOMING_ARG' is not defined,
     'TARGET_FUNCTION_ARG' serves both purposes.

 -- Target Hook: bool TARGET_USE_PSEUDO_PIC_REG (void)
     This hook should return 1 in case pseudo register should be created
     for pic_offset_table_rtx during function expand.

 -- Target Hook: void TARGET_INIT_PIC_REG (void)
     Perform a target dependent initialization of pic_offset_table_rtx.
     This hook is called at the start of register allocation.

 -- Target Hook: int TARGET_ARG_PARTIAL_BYTES (cumulative_args_t CUM,
          const function_arg_info &ARG)
     This target hook returns the number of bytes at the beginning of an
     argument that must be put in registers.  The value must be zero for
     arguments that are passed entirely in registers or that are
     entirely pushed on the stack.

     On some machines, certain arguments must be passed partially in
     registers and partially in memory.  On these machines, typically
     the first few words of arguments are passed in registers, and the
     rest on the stack.  If a multi-word argument (a 'double' or a
     structure) crosses that boundary, its first few words must be
     passed in registers and the rest must be pushed.  This macro tells
     the compiler when this occurs, and how many bytes should go in
     registers.

     'TARGET_FUNCTION_ARG' for these arguments should return the first
     register to be used by the caller for this argument; likewise
     'TARGET_FUNCTION_INCOMING_ARG', for the called function.

 -- Target Hook: bool TARGET_PASS_BY_REFERENCE (cumulative_args_t CUM,
          const function_arg_info &ARG)
     This target hook should return 'true' if argument ARG at the
     position indicated by CUM should be passed by reference.  This
     predicate is queried after target independent reasons for being
     passed by reference, such as 'TREE_ADDRESSABLE (ARG.type)'.

     If the hook returns true, a copy of that argument is made in memory
     and a pointer to the argument is passed instead of the argument
     itself.  The pointer is passed in whatever way is appropriate for
     passing a pointer to that type.

 -- Target Hook: bool TARGET_CALLEE_COPIES (cumulative_args_t CUM, const
          function_arg_info &ARG)
     The function argument described by the parameters to this hook is
     known to be passed by reference.  The hook should return true if
     the function argument should be copied by the callee instead of
     copied by the caller.

     For any argument for which the hook returns true, if it can be
     determined that the argument is not modified, then a copy need not
     be generated.

     The default version of this hook always returns false.

 -- Macro: CUMULATIVE_ARGS
     A C type for declaring a variable that is used as the first
     argument of 'TARGET_FUNCTION_ARG' and other related values.  For
     some target machines, the type 'int' suffices and can hold the
     number of bytes of argument so far.

     There is no need to record in 'CUMULATIVE_ARGS' anything about the
     arguments that have been passed on the stack.  The compiler has
     other variables to keep track of that.  For target machines on
     which all arguments are passed on the stack, there is no need to
     store anything in 'CUMULATIVE_ARGS'; however, the data structure
     must exist and should not be empty, so use 'int'.

 -- Macro: OVERRIDE_ABI_FORMAT (FNDECL)
     If defined, this macro is called before generating any code for a
     function, but after the CFUN descriptor for the function has been
     created.  The back end may use this macro to update CFUN to reflect
     an ABI other than that which would normally be used by default.  If
     the compiler is generating code for a compiler-generated function,
     FNDECL may be 'NULL'.

 -- Macro: INIT_CUMULATIVE_ARGS (CUM, FNTYPE, LIBNAME, FNDECL,
          N_NAMED_ARGS)
     A C statement (sans semicolon) for initializing the variable CUM
     for the state at the beginning of the argument list.  The variable
     has type 'CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node
     for the data type of the function which will receive the args, or 0
     if the args are to a compiler support library function.  For direct
     calls that are not libcalls, FNDECL contain the declaration node of
     the function.  FNDECL is also set when 'INIT_CUMULATIVE_ARGS' is
     used to find arguments for the function being compiled.
     N_NAMED_ARGS is set to the number of named arguments, including a
     structure return address if it is passed as a parameter, when
     making a call.  When processing incoming arguments, N_NAMED_ARGS is
     set to -1.

     When processing a call to a compiler support library function,
     LIBNAME identifies which one.  It is a 'symbol_ref' rtx which
     contains the name of the function, as a string.  LIBNAME is 0 when
     an ordinary C function call is being processed.  Thus, each time
     this macro is called, either LIBNAME or FNTYPE is nonzero, but
     never both of them at once.

 -- Macro: INIT_CUMULATIVE_LIBCALL_ARGS (CUM, MODE, LIBNAME)
     Like 'INIT_CUMULATIVE_ARGS' but only used for outgoing libcalls, it
     gets a 'MODE' argument instead of FNTYPE, that would be 'NULL'.
     INDIRECT would always be zero, too.  If this macro is not defined,
     'INIT_CUMULATIVE_ARGS (cum, NULL_RTX, libname, 0)' is used instead.

 -- Macro: INIT_CUMULATIVE_INCOMING_ARGS (CUM, FNTYPE, LIBNAME)
     Like 'INIT_CUMULATIVE_ARGS' but overrides it for the purposes of
     finding the arguments for the function being compiled.  If this
     macro is undefined, 'INIT_CUMULATIVE_ARGS' is used instead.

     The value passed for LIBNAME is always 0, since library routines
     with special calling conventions are never compiled with GCC.  The
     argument LIBNAME exists for symmetry with 'INIT_CUMULATIVE_ARGS'.

 -- Target Hook: void TARGET_FUNCTION_ARG_ADVANCE (cumulative_args_t CA,
          const function_arg_info &ARG)
     This hook updates the summarizer variable pointed to by CA to
     advance past argument ARG in the argument list.  Once this is done,
     the variable CUM is suitable for analyzing the _following_ argument
     with 'TARGET_FUNCTION_ARG', etc.

     This hook need not do anything if the argument in question was
     passed on the stack.  The compiler knows how to track the amount of
     stack space used for arguments without any special help.

 -- Target Hook: HOST_WIDE_INT TARGET_FUNCTION_ARG_OFFSET (machine_mode
          MODE, const_tree TYPE)
     This hook returns the number of bytes to add to the offset of an
     argument of type TYPE and mode MODE when passed in memory.  This is
     needed for the SPU, which passes 'char' and 'short' arguments in
     the preferred slot that is in the middle of the quad word instead
     of starting at the top.  The default implementation returns 0.

 -- Target Hook: pad_direction TARGET_FUNCTION_ARG_PADDING (machine_mode
          MODE, const_tree TYPE)
     This hook determines whether, and in which direction, to pad out an
     argument of mode MODE and type TYPE.  It returns 'PAD_UPWARD' to
     insert padding above the argument, 'PAD_DOWNWARD' to insert padding
     below the argument, or 'PAD_NONE' to inhibit padding.

     The _amount_ of padding is not controlled by this hook, but by
     'TARGET_FUNCTION_ARG_ROUND_BOUNDARY'.  It is always just enough to
     reach the next multiple of that boundary.

     This hook has a default definition that is right for most systems.
     For little-endian machines, the default is to pad upward.  For
     big-endian machines, the default is to pad downward for an argument
     of constant size shorter than an 'int', and upward otherwise.

 -- Macro: PAD_VARARGS_DOWN
     If defined, a C expression which determines whether the default
     implementation of va_arg will attempt to pad down before reading
     the next argument, if that argument is smaller than its aligned
     space as controlled by 'PARM_BOUNDARY'.  If this macro is not
     defined, all such arguments are padded down if 'BYTES_BIG_ENDIAN'
     is true.

 -- Macro: BLOCK_REG_PADDING (MODE, TYPE, FIRST)
     Specify padding for the last element of a block move between
     registers and memory.  FIRST is nonzero if this is the only
     element.  Defining this macro allows better control of register
     function parameters on big-endian machines, without using
     'PARALLEL' rtl.  In particular, 'MUST_PASS_IN_STACK' need not test
     padding and mode of types in registers, as there is no longer a
     "wrong" part of a register; For example, a three byte aggregate may
     be passed in the high part of a register if so required.

 -- Target Hook: unsigned int TARGET_FUNCTION_ARG_BOUNDARY (machine_mode
          MODE, const_tree TYPE)
     This hook returns the alignment boundary, in bits, of an argument
     with the specified mode and type.  The default hook returns
     'PARM_BOUNDARY' for all arguments.

 -- Target Hook: unsigned int TARGET_FUNCTION_ARG_ROUND_BOUNDARY
          (machine_mode MODE, const_tree TYPE)
     Normally, the size of an argument is rounded up to 'PARM_BOUNDARY',
     which is the default value for this hook.  You can define this hook
     to return a different value if an argument size must be rounded to
     a larger value.

 -- Macro: FUNCTION_ARG_REGNO_P (REGNO)
     A C expression that is nonzero if REGNO is the number of a hard
     register in which function arguments are sometimes passed.  This
     does _not_ include implicit arguments such as the static chain and
     the structure-value address.  On many machines, no registers can be
     used for this purpose since all function arguments are pushed on
     the stack.

 -- Target Hook: bool TARGET_SPLIT_COMPLEX_ARG (const_tree TYPE)
     This hook should return true if parameter of type TYPE are passed
     as two scalar parameters.  By default, GCC will attempt to pack
     complex arguments into the target's word size.  Some ABIs require
     complex arguments to be split and treated as their individual
     components.  For example, on AIX64, complex floats should be passed
     in a pair of floating point registers, even though a complex float
     would fit in one 64-bit floating point register.

     The default value of this hook is 'NULL', which is treated as
     always false.

 -- Target Hook: tree TARGET_BUILD_BUILTIN_VA_LIST (void)
     This hook returns a type node for 'va_list' for the target.  The
     default version of the hook returns 'void*'.

 -- Target Hook: int TARGET_ENUM_VA_LIST_P (int IDX, const char **PNAME,
          tree *PTREE)
     This target hook is used in function 'c_common_nodes_and_builtins'
     to iterate through the target specific builtin types for va_list.
     The variable IDX is used as iterator.  PNAME has to be a pointer to
     a 'const char *' and PTREE a pointer to a 'tree' typed variable.
     The arguments PNAME and PTREE are used to store the result of this
     macro and are set to the name of the va_list builtin type and its
     internal type.  If the return value of this macro is zero, then
     there is no more element.  Otherwise the IDX should be increased
     for the next call of this macro to iterate through all types.

 -- Target Hook: tree TARGET_FN_ABI_VA_LIST (tree FNDECL)
     This hook returns the va_list type of the calling convention
     specified by FNDECL.  The default version of this hook returns
     'va_list_type_node'.

 -- Target Hook: tree TARGET_CANONICAL_VA_LIST_TYPE (tree TYPE)
     This hook returns the va_list type of the calling convention
     specified by the type of TYPE.  If TYPE is not a valid va_list
     type, it returns 'NULL_TREE'.

 -- Target Hook: tree TARGET_GIMPLIFY_VA_ARG_EXPR (tree VALIST, tree
          TYPE, gimple_seq *PRE_P, gimple_seq *POST_P)
     This hook performs target-specific gimplification of 'VA_ARG_EXPR'.
     The first two parameters correspond to the arguments to 'va_arg';
     the latter two are as in 'gimplify.c:gimplify_expr'.

 -- Target Hook: bool TARGET_VALID_POINTER_MODE (scalar_int_mode MODE)
     Define this to return nonzero if the port can handle pointers with
     machine mode MODE.  The default version of this hook returns true
     for both 'ptr_mode' and 'Pmode'.

 -- Target Hook: bool TARGET_REF_MAY_ALIAS_ERRNO (ao_ref *REF)
     Define this to return nonzero if the memory reference REF may alias
     with the system C library errno location.  The default version of
     this hook assumes the system C library errno location is either a
     declaration of type int or accessed by dereferencing a pointer to
     int.

 -- Target Hook: machine_mode TARGET_TRANSLATE_MODE_ATTRIBUTE
          (machine_mode MODE)
     Define this hook if during mode attribute processing, the port
     should translate machine_mode MODE to another mode.  For example,
     rs6000's 'KFmode', when it is the same as 'TFmode'.

     The default version of the hook returns that mode that was passed
     in.

 -- Target Hook: bool TARGET_SCALAR_MODE_SUPPORTED_P (scalar_mode MODE)
     Define this to return nonzero if the port is prepared to handle
     insns involving scalar mode MODE.  For a scalar mode to be
     considered supported, all the basic arithmetic and comparisons must
     work.

     The default version of this hook returns true for any mode required
     to handle the basic C types (as defined by the port).  Included
     here are the double-word arithmetic supported by the code in
     'optabs.c'.

 -- Target Hook: bool TARGET_VECTOR_MODE_SUPPORTED_P (machine_mode MODE)
     Define this to return nonzero if the port is prepared to handle
     insns involving vector mode MODE.  At the very least, it must have
     move patterns for this mode.

 -- Target Hook: bool TARGET_COMPATIBLE_VECTOR_TYPES_P (const_tree
          TYPE1, const_tree TYPE2)
     Return true if there is no target-specific reason for treating
     vector types TYPE1 and TYPE2 as distinct types.  The caller has
     already checked for target-independent reasons, meaning that the
     types are known to have the same mode, to have the same number of
     elements, and to have what the caller considers to be compatible
     element types.

     The main reason for defining this hook is to reject pairs of types
     that are handled differently by the target's calling convention.
     For example, when a new N-bit vector architecture is added to a
     target, the target may want to handle normal N-bit 'VECTOR_TYPE'
     arguments and return values in the same way as before, to maintain
     backwards compatibility.  However, it may also provide new,
     architecture-specific 'VECTOR_TYPE's that are passed and returned
     in a more efficient way.  It is then important to maintain a
     distinction between the "normal" 'VECTOR_TYPE's and the new
     architecture-specific ones.

     The default implementation returns true, which is correct for most
     targets.

 -- Target Hook: opt_machine_mode TARGET_ARRAY_MODE (machine_mode MODE,
          unsigned HOST_WIDE_INT NELEMS)
     Return the mode that GCC should use for an array that has NELEMS
     elements, with each element having mode MODE.  Return no mode if
     the target has no special requirements.  In the latter case, GCC
     looks for an integer mode of the appropriate size if available and
     uses BLKmode otherwise.  Usually the search for the integer mode is
     limited to 'MAX_FIXED_MODE_SIZE', but the
     'TARGET_ARRAY_MODE_SUPPORTED_P' hook allows a larger mode to be
     used in specific cases.

     The main use of this hook is to specify that an array of vectors
     should also have a vector mode.  The default implementation returns
     no mode.

 -- Target Hook: bool TARGET_ARRAY_MODE_SUPPORTED_P (machine_mode MODE,
          unsigned HOST_WIDE_INT NELEMS)
     Return true if GCC should try to use a scalar mode to store an
     array of NELEMS elements, given that each element has mode MODE.
     Returning true here overrides the usual 'MAX_FIXED_MODE' limit and
     allows GCC to use any defined integer mode.

     One use of this hook is to support vector load and store operations
     that operate on several homogeneous vectors.  For example, ARM NEON
     has operations like:

          int8x8x3_t vld3_s8 (const int8_t *)

     where the return type is defined as:

          typedef struct int8x8x3_t
          {
            int8x8_t val[3];
          } int8x8x3_t;

     If this hook allows 'val' to have a scalar mode, then 'int8x8x3_t'
     can have the same mode.  GCC can then store 'int8x8x3_t's in
     registers rather than forcing them onto the stack.

 -- Target Hook: bool TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P
          (scalar_float_mode MODE)
     Define this to return nonzero if libgcc provides support for the
     floating-point mode MODE, which is known to pass
     'TARGET_SCALAR_MODE_SUPPORTED_P'.  The default version of this hook
     returns true for all of 'SFmode', 'DFmode', 'XFmode' and 'TFmode',
     if such modes exist.

 -- Target Hook: opt_scalar_float_mode TARGET_FLOATN_MODE (int N, bool
          EXTENDED)
     Define this to return the machine mode to use for the type
     '_FloatN', if EXTENDED is false, or the type '_FloatNx', if
     EXTENDED is true.  If such a type is not supported, return
     'opt_scalar_float_mode ()'.  The default version of this hook
     returns 'SFmode' for '_Float32', 'DFmode' for '_Float64' and
     '_Float32x' and 'TFmode' for '_Float128', if those modes exist and
     satisfy the requirements for those types and pass
     'TARGET_SCALAR_MODE_SUPPORTED_P' and
     'TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P'; for '_Float64x', it
     returns the first of 'XFmode' and 'TFmode' that exists and
     satisfies the same requirements; for other types, it returns
     'opt_scalar_float_mode ()'.  The hook is only called for values of
     N and EXTENDED that are valid according to ISO/IEC TS 18661-3:2015;
     that is, N is one of 32, 64, 128, or, if EXTENDED is false, 16 or
     greater than 128 and a multiple of 32.

 -- Target Hook: bool TARGET_FLOATN_BUILTIN_P (int FUNC)
     Define this to return true if the '_FloatN' and '_FloatNx' built-in
     functions should implicitly enable the built-in function without
     the '__builtin_' prefix in addition to the normal built-in function
     with the '__builtin_' prefix.  The default is to only enable
     built-in functions without the '__builtin_' prefix for the GNU C
     langauge.  In strict ANSI/ISO mode, the built-in function without
     the '__builtin_' prefix is not enabled.  The argument 'FUNC' is the
     'enum built_in_function' id of the function to be enabled.

 -- Target Hook: bool TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P
          (machine_mode MODE)
     Define this to return nonzero for machine modes for which the port
     has small register classes.  If this target hook returns nonzero
     for a given MODE, the compiler will try to minimize the lifetime of
     registers in MODE.  The hook may be called with 'VOIDmode' as
     argument.  In this case, the hook is expected to return nonzero if
     it returns nonzero for any mode.

     On some machines, it is risky to let hard registers live across
     arbitrary insns.  Typically, these machines have instructions that
     require values to be in specific registers (like an accumulator),
     and reload will fail if the required hard register is used for
     another purpose across such an insn.

     Passes before reload do not know which hard registers will be used
     in an instruction, but the machine modes of the registers set or
     used in the instruction are already known.  And for some machines,
     register classes are small for, say, integer registers but not for
     floating point registers.  For example, the AMD x86-64 architecture
     requires specific registers for the legacy x86 integer
     instructions, but there are many SSE registers for floating point
     operations.  On such targets, a good strategy may be to return
     nonzero from this hook for 'INTEGRAL_MODE_P' machine modes but zero
     for the SSE register classes.

     The default version of this hook returns false for any mode.  It is
     always safe to redefine this hook to return with a nonzero value.
     But if you unnecessarily define it, you will reduce the amount of
     optimizations that can be performed in some cases.  If you do not
     define this hook to return a nonzero value when it is required, the
     compiler will run out of spill registers and print a fatal error
     message.

==============================================================================
File: gccint.info,  Node: |Scalar_Return|,  Next: |Aggregate_Return|,  Prev: |Register_Arguments|,  Up: |Stack_and_Calling|
==============================================================================

                                                                 *Scalar_Return*

18.9.8 How Scalar Function Values Are Returned
----------------------------------------------

This section discusses the macros that control returning scalars as
values--values that can fit in registers.

 -- Target Hook: rtx TARGET_FUNCTION_VALUE (const_tree RET_TYPE,
          const_tree FN_DECL_OR_TYPE, bool OUTGOING)

     Define this to return an RTX representing the place where a
     function returns or receives a value of data type RET_TYPE, a tree
     node representing a data type.  FN_DECL_OR_TYPE is a tree node
     representing 'FUNCTION_DECL' or 'FUNCTION_TYPE' of a function being
     called.  If OUTGOING is false, the hook should compute the register
     in which the caller will see the return value.  Otherwise, the hook
     should return an RTX representing the place where a function
     returns a value.

     On many machines, only 'TYPE_MODE (RET_TYPE)' is relevant.
     (Actually, on most machines, scalar values are returned in the same
     place regardless of mode.)  The value of the expression is usually
     a 'reg' RTX for the hard register where the return value is stored.
     The value can also be a 'parallel' RTX, if the return value is in
     multiple places.  See 'TARGET_FUNCTION_ARG' for an explanation of
     the 'parallel' form.  Note that the callee will populate every
     location specified in the 'parallel', but if the first element of
     the 'parallel' contains the whole return value, callers will use
     that element as the canonical location and ignore the others.  The
     m68k port uses this type of 'parallel' to return pointers in both
     '%a0' (the canonical location) and '%d0'.

     If 'TARGET_PROMOTE_FUNCTION_RETURN' returns true, you must apply
     the same promotion rules specified in 'PROMOTE_MODE' if VALTYPE is
     a scalar type.

     If the precise function being called is known, FUNC is a tree node
     ('FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This
     makes it possible to use a different value-returning convention for
     specific functions when all their calls are known.

     Some target machines have "register windows" so that the register
     in which a function returns its value is not the same as the one in
     which the caller sees the value.  For such machines, you should
     return different RTX depending on OUTGOING.

     'TARGET_FUNCTION_VALUE' is not used for return values with
     aggregate data types, because these are returned in another way.
     See 'TARGET_STRUCT_VALUE_RTX' and related macros, below.

 -- Macro: FUNCTION_VALUE (VALTYPE, FUNC)
     This macro has been deprecated.  Use 'TARGET_FUNCTION_VALUE' for a
     new target instead.

 -- Macro: LIBCALL_VALUE (MODE)
     A C expression to create an RTX representing the place where a
     library function returns a value of mode MODE.

     Note that "library function" in this context means a compiler
     support routine, used to perform arithmetic, whose name is known
     specially by the compiler and was not mentioned in the C code being
     compiled.

 -- Target Hook: rtx TARGET_LIBCALL_VALUE (machine_mode MODE, const_rtx
          FUN)
     Define this hook if the back-end needs to know the name of the
     libcall function in order to determine where the result should be
     returned.

     The mode of the result is given by MODE and the name of the called
     library function is given by FUN.  The hook should return an RTX
     representing the place where the library function result will be
     returned.

     If this hook is not defined, then LIBCALL_VALUE will be used.

 -- Macro: FUNCTION_VALUE_REGNO_P (REGNO)
     A C expression that is nonzero if REGNO is the number of a hard
     register in which the values of called function may come back.

     A register whose use for returning values is limited to serving as
     the second of a pair (for a value of type 'double', say) need not
     be recognized by this macro.  So for most machines, this definition
     suffices:

          #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)

     If the machine has register windows, so that the caller and the
     called function use different registers for the return value, this
     macro should recognize only the caller's register numbers.

     This macro has been deprecated.  Use
     'TARGET_FUNCTION_VALUE_REGNO_P' for a new target instead.

 -- Target Hook: bool TARGET_FUNCTION_VALUE_REGNO_P (const unsigned int
          REGNO)
     A target hook that return 'true' if REGNO is the number of a hard
     register in which the values of called function may come back.

     A register whose use for returning values is limited to serving as
     the second of a pair (for a value of type 'double', say) need not
     be recognized by this target hook.

     If the machine has register windows, so that the caller and the
     called function use different registers for the return value, this
     target hook should recognize only the caller's register numbers.

     If this hook is not defined, then FUNCTION_VALUE_REGNO_P will be
     used.

 -- Macro: APPLY_RESULT_SIZE
     Define this macro if 'untyped_call' and 'untyped_return' need more
     space than is implied by 'FUNCTION_VALUE_REGNO_P' for saving and
     restoring an arbitrary return value.

 -- Target Hook: bool TARGET_OMIT_STRUCT_RETURN_REG
     Normally, when a function returns a structure by memory, the
     address is passed as an invisible pointer argument, but the
     compiler also arranges to return the address from the function like
     it would a normal pointer return value.  Define this to true if
     that behavior is undesirable on your target.

 -- Target Hook: bool TARGET_RETURN_IN_MSB (const_tree TYPE)
     This hook should return true if values of type TYPE are returned at
     the most significant end of a register (in other words, if they are
     padded at the least significant end).  You can assume that TYPE is
     returned in a register; the caller is required to check this.

     Note that the register provided by 'TARGET_FUNCTION_VALUE' must be
     able to hold the complete return value.  For example, if a 1-, 2-
     or 3-byte structure is returned at the most significant end of a
     4-byte register, 'TARGET_FUNCTION_VALUE' should provide an 'SImode'
     rtx.

==============================================================================
File: gccint.info,  Node: |Aggregate_Return|,  Next: |Caller_Saves|,  Prev: |Scalar_Return|,  Up: |Stack_and_Calling|
==============================================================================

                                                              *Aggregate_Return*

18.9.9 How Large Values Are Returned
------------------------------------

When a function value's mode is 'BLKmode' (and in some other cases), the
value is not returned according to 'TARGET_FUNCTION_VALUE' (*note Scalar
Return::).  Instead, the caller passes the address of a block of memory
in which the value should be stored.  This address is called the
"structure value address".

 This section describes how to control returning structure values in
memory.

 -- Target Hook: bool TARGET_RETURN_IN_MEMORY (const_tree TYPE,
          const_tree FNTYPE)
     This target hook should return a nonzero value to say to return the
     function value in memory, just as large structures are always
     returned.  Here TYPE will be the data type of the value, and FNTYPE
     will be the type of the function doing the returning, or 'NULL' for
     libcalls.

     Note that values of mode 'BLKmode' must be explicitly handled by
     this function.  Also, the option '-fpcc-struct-return' takes effect
     regardless of this macro.  On most systems, it is possible to leave
     the hook undefined; this causes a default definition to be used,
     whose value is the constant 1 for 'BLKmode' values, and 0
     otherwise.

     Do not use this hook to indicate that structures and unions should
     always be returned in memory.  You should instead use
     'DEFAULT_PCC_STRUCT_RETURN' to indicate this.

 -- Macro: DEFAULT_PCC_STRUCT_RETURN
     Define this macro to be 1 if all structure and union return values
     must be in memory.  Since this results in slower code, this should
     be defined only if needed for compatibility with other compilers or
     with an ABI.  If you define this macro to be 0, then the
     conventions used for structure and union return values are decided
     by the 'TARGET_RETURN_IN_MEMORY' target hook.

     If not defined, this defaults to the value 1.

 -- Target Hook: rtx TARGET_STRUCT_VALUE_RTX (tree FNDECL, int INCOMING)
     This target hook should return the location of the structure value
     address (normally a 'mem' or 'reg'), or 0 if the address is passed
     as an "invisible" first argument.  Note that FNDECL may be 'NULL',
     for libcalls.  You do not need to define this target hook if the
     address is always passed as an "invisible" first argument.

     On some architectures the place where the structure value address
     is found by the called function is not the same place that the
     caller put it.  This can be due to register windows, or it could be
     because the function prologue moves it to a different place.
     INCOMING is '1' or '2' when the location is needed in the context
     of the called function, and '0' in the context of the caller.

     If INCOMING is nonzero and the address is to be found on the stack,
     return a 'mem' which refers to the frame pointer.  If INCOMING is
     '2', the result is being used to fetch the structure value address
     at the beginning of a function.  If you need to emit adjusting
     code, you should do it at this point.

 -- Macro: PCC_STATIC_STRUCT_RETURN
     Define this macro if the usual system convention on the target
     machine for returning structures and unions is for the called
     function to return the address of a static variable containing the
     value.

     Do not define this if the usual system convention is for the caller
     to pass an address to the subroutine.

     This macro has effect in '-fpcc-struct-return' mode, but it does
     nothing when you use '-freg-struct-return' mode.

 -- Target Hook: fixed_size_mode TARGET_GET_RAW_RESULT_MODE (int REGNO)
     This target hook returns the mode to be used when accessing raw
     return registers in '__builtin_return'.  Define this macro if the
     value in REG_RAW_MODE is not correct.

 -- Target Hook: fixed_size_mode TARGET_GET_RAW_ARG_MODE (int REGNO)
     This target hook returns the mode to be used when accessing raw
     argument registers in '__builtin_apply_args'.  Define this macro if
     the value in REG_RAW_MODE is not correct.

 -- Target Hook: bool TARGET_EMPTY_RECORD_P (const_tree TYPE)
     This target hook returns true if the type is an empty record.  The
     default is to return 'false'.

 -- Target Hook: void TARGET_WARN_PARAMETER_PASSING_ABI
 vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
