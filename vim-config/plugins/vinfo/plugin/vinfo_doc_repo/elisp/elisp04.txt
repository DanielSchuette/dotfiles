'byte-compile-file', or several files with 'byte-recompile-directory' or
'batch-byte-compile'.

   Sometimes, the byte compiler produces warning and/or error messages
(*note Compiler Errors::, for details).  These messages are normally
recorded in a buffer called 'Compile-Log', which uses Compilation
mode.  *Note (emacs)Compilation Mode::.  However, if the variable
'byte-compile-debug' is non-'nil', error messages will be signaled as
Lisp errors instead (*note Errors::).

   Be careful when writing macro calls in files that you intend to
byte-compile.  Since macro calls are expanded when they are compiled,
the macros need to be loaded into Emacs or the byte compiler will not do
the right thing.  The usual way to handle this is with 'require' forms
which specify the files containing the needed macro definitions (*note
Named Features::).  Normally, the byte compiler does not evaluate the
code that it is compiling, but it handles 'require' forms specially, by
loading the specified libraries.  To avoid loading the macro definition
files when someone _runs_ the compiled program, write
'eval-when-compile' around the 'require' calls (*note Eval During
Compile::).  For more details, *Note Compiling Macros::.

   Inline ('defsubst') functions are less troublesome; if you compile a
call to such a function before its definition is known, the call will
still work right, it will just run slower.

 -- Function: byte-compile symbol
     This function byte-compiles the function definition of SYMBOL,
     replacing the previous definition with the compiled one.  The
     function definition of SYMBOL must be the actual code for the
     function; 'byte-compile' does not handle function indirection.  The
     return value is the byte-code function object which is the compiled
     definition of SYMBOL (*note Byte-Code Objects::).

          (defun factorial (integer)
            "Compute factorial of INTEGER."
            (if (= 1 integer) 1
              (* integer (factorial (1- integer)))))
          => factorial

          (byte-compile 'factorial)
          =>
          #[(integer)
            "^H\301U\203^H^@\301\207\302^H\303^HS!\"\207"
            [integer 1 * factorial]
            4 "Compute factorial of INTEGER."]

     If SYMBOL's definition is a byte-code function object,
     'byte-compile' does nothing and returns 'nil'.  It does not compile
     the symbol's definition again, since the original (non-compiled)
     code has already been replaced in the symbol's function cell by the
     byte-compiled code.

     The argument to 'byte-compile' can also be a 'lambda' expression.
     In that case, the function returns the corresponding compiled code
     but does not store it anywhere.

 -- Command: compile-defun &optional arg
     This command reads the defun containing point, compiles it, and
     evaluates the result.  If you use this on a defun that is actually
     a function definition, the effect is to install a compiled version
     of that function.

     'compile-defun' normally displays the result of evaluation in the
     echo area, but if ARG is non-'nil', it inserts the result in the
     current buffer after the form it has compiled.

 -- Command: byte-compile-file filename &optional load
     This function compiles a file of Lisp code named FILENAME into a
     file of byte-code.  The output file's name is made by changing the
     '.el' suffix into '.elc'; if FILENAME does not end in '.el', it
     adds '.elc' to the end of FILENAME.

     Compilation works by reading the input file one form at a time.  If
     it is a definition of a function or macro, the compiled function or
     macro definition is written out.  Other forms are batched together,
     then each batch is compiled, and written so that its compiled code
     will be executed when the file is read.  All comments are discarded
     when the input file is read.

     This command returns 't' if there were no errors and 'nil'
     otherwise.  When called interactively, it prompts for the file
     name.

     If LOAD is non-'nil', this command loads the compiled file after
     compiling it.  Interactively, LOAD is the prefix argument.

          $ ls -l push*
          -rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el

          (byte-compile-file "~/emacs/push.el")
               => t

          $ ls -l push*
          -rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
          -rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc

 -- Command: byte-recompile-directory directory &optional flag force
     This command recompiles every '.el' file in DIRECTORY (or its
     subdirectories) that needs recompilation.  A file needs
     recompilation if a '.elc' file exists but is older than the '.el'
     file.

     When a '.el' file has no corresponding '.elc' file, FLAG says what
     to do.  If it is 'nil', this command ignores these files.  If FLAG
     is 0, it compiles them.  If it is neither 'nil' nor 0, it asks the
     user whether to compile each such file, and asks about each
     subdirectory as well.

     Interactively, 'byte-recompile-directory' prompts for DIRECTORY and
     FLAG is the prefix argument.

     If FORCE is non-'nil', this command recompiles every '.el' file
     that has a '.elc' file.

     The returned value is unpredictable.

 -- Function: batch-byte-compile &optional noforce
     This function runs 'byte-compile-file' on files specified on the
     command line.  This function must be used only in a batch execution
     of Emacs, as it kills Emacs on completion.  An error in one file
     does not prevent processing of subsequent files, but no output file
     will be generated for it, and the Emacs process will terminate with
     a nonzero status code.

     If NOFORCE is non-'nil', this function does not recompile files
     that have an up-to-date '.elc' file.

          $ emacs -batch -f batch-byte-compile *.el

==============================================================================
File: elisp.info,  Node: |Docs_and_Compilation|,  Next: |Dynamic_Loading|,  Prev: |Compilation_Functions|,  Up: |Byte_Compilation|
==============================================================================

                                                          *Docs_and_Compilation*

17.3 Documentation Strings and Compilation
------------------------------------------

When Emacs loads functions and variables from a byte-compiled file, it
normally does not load their documentation strings into memory.  Each
documentation string is dynamically loaded from the byte-compiled file
only when needed.  This saves memory, and speeds up loading by skipping
the processing of the documentation strings.

   This feature has a drawback: if you delete, move, or alter the
compiled file (such as by compiling a new version), Emacs may no longer
be able to access the documentation string of previously-loaded
functions or variables.  Such a problem normally only occurs if you
build Emacs yourself, and happen to edit and/or recompile the Lisp
source files.  To solve it, just reload each file after recompilation.

   Dynamic loading of documentation strings from byte-compiled files is
determined, at compile time, for each byte-compiled file.  It can be
disabled via the option 'byte-compile-dynamic-docstrings'.

 -- User Option: byte-compile-dynamic-docstrings
     If this is non-'nil', the byte compiler generates compiled files
     that are set up for dynamic loading of documentation strings.

     To disable the dynamic loading feature for a specific file, set
     this option to 'nil' in its header line (*note Local Variables in
     Files: (emacs)File Variables.), like this:

          -*-byte-compile-dynamic-docstrings: nil;-*-

     This is useful mainly if you expect to change the file, and you
     want Emacs sessions that have already loaded it to keep working
     when the file changes.

   Internally, the dynamic loading of documentation strings is
accomplished by writing compiled files with a special Lisp reader
construct, '#@COUNT'.  This construct skips the next COUNT characters.
It also uses the '#$' construct, which stands for the name of this file,
as a string.  Do not use these constructs in Lisp source files; they are
not designed to be clear to humans reading the file.

==============================================================================
File: elisp.info,  Node: |Dynamic_Loading|,  Next: |Eval_During_Compile|,  Prev: |Docs_and_Compilation|,  Up: |Byte_Compilation|
==============================================================================

                                                               *Dynamic_Loading*

17.4 Dynamic Loading of Individual Functions
--------------------------------------------

When you compile a file, you can optionally enable the "dynamic function
loading" feature (also known as "lazy loading").  With dynamic function
loading, loading the file doesn't fully read the function definitions in
the file.  Instead, each function definition contains a place-holder
which refers to the file.  The first time each function is called, it
reads the full definition from the file, to replace the place-holder.

   The advantage of dynamic function loading is that loading the file
should become faster.  This is a good thing for a file which contains
many separate user-callable functions, if using one of them does not
imply you will probably also use the rest.  A specialized mode which
provides many keyboard commands often has that usage pattern: a user may
invoke the mode, but use only a few of the commands it provides.

   The dynamic loading feature has certain disadvantages:

   * If you delete or move the compiled file after loading it, Emacs can
     no longer load the remaining function definitions not already
     loaded.

   * If you alter the compiled file (such as by compiling a new
     version), then trying to load any function not already loaded will
     usually yield nonsense results.

   These problems will never happen in normal circumstances with
installed Emacs files.  But they are quite likely to happen with Lisp
files that you are changing.  The easiest way to prevent these problems
is to reload the new compiled file immediately after each recompilation.

   _Experience shows that using dynamic function loading provides
benefits that are hardly measurable, so this feature is deprecated since
Emacs 27.1._

   The byte compiler uses the dynamic function loading feature if the
variable 'byte-compile-dynamic' is non-'nil' at compilation time.  Do
not set this variable globally, since dynamic loading is desirable only
for certain files.  Instead, enable the feature for specific source
files with file-local variable bindings.  For example, you could do it
by writing this text in the source file's first line:

     -*-byte-compile-dynamic: t;-*-

 -- Variable: byte-compile-dynamic
     If this is non-'nil', the byte compiler generates compiled files
     that are set up for dynamic function loading.

 -- Function: fetch-bytecode function
     If FUNCTION is a byte-code function object, this immediately
     finishes loading the byte code of FUNCTION from its byte-compiled
     file, if it is not fully loaded already.  Otherwise, it does
     nothing.  It always returns FUNCTION.

==============================================================================
File: elisp.info,  Node: |Eval_During_Compile|,  Next: |Compiler_Errors|,  Prev: |Dynamic_Loading|,  Up: |Byte_Compilation|
==============================================================================

                                                           *Eval_During_Compile*

17.5 Evaluation During Compilation
----------------------------------

These features permit you to write code to be evaluated during
compilation of a program.

 -- Special Form: eval-and-compile body...
     This form marks BODY to be evaluated both when you compile the
     containing code and when you run it (whether compiled or not).

     You can get a similar result by putting BODY in a separate file and
     referring to that file with 'require'.  That method is preferable
     when BODY is large.  Effectively 'require' is automatically
     'eval-and-compile', the package is loaded both when compiling and
     executing.

     'autoload' is also effectively 'eval-and-compile' too.  It's
     recognized when compiling, so uses of such a function don't produce
     "not known to be defined" warnings.

     Most uses of 'eval-and-compile' are fairly sophisticated.

     If a macro has a helper function to build its result, and that
     macro is used both locally and outside the package, then
     'eval-and-compile' should be used to get the helper both when
     compiling and then later when running.

     If functions are defined programmatically (with 'fset' say), then
     'eval-and-compile' can be used to have that done at compile-time as
     well as run-time, so calls to those functions are checked (and
     warnings about "not known to be defined" suppressed).

 -- Special Form: eval-when-compile body...
     This form marks BODY to be evaluated at compile time but not when
     the compiled program is loaded.  The result of evaluation by the
     compiler becomes a constant which appears in the compiled program.
     If you load the source file, rather than compiling it, BODY is
     evaluated normally.

     If you have a constant that needs some calculation to produce,
     'eval-when-compile' can do that at compile-time.  For example,

          (defvar my-regexp
            (eval-when-compile (regexp-opt '("aaa" "aba" "abb"))))

     If you're using another package, but only need macros from it (the
     byte compiler will expand those), then 'eval-when-compile' can be
     used to load it for compiling, but not executing.  For example,

          (eval-when-compile
            (require 'my-macro-package))

     The same sort of thing goes for macros and 'defsubst' functions
     defined locally and only for use within the file.  They are needed
     for compiling the file, but in most cases they are not needed for
     execution of the compiled file.  For example,

          (eval-when-compile
            (unless (fboundp 'some-new-thing)
              (defmacro 'some-new-thing ()
                (compatibility code))))

     This is often good for code that's only a fallback for
     compatibility with other versions of Emacs.

     *Common Lisp Note:* At top level, 'eval-when-compile' is analogous
     to the Common Lisp idiom '(eval-when (compile eval) ...)'.
     Elsewhere, the Common Lisp '#.' reader macro (but not when
     interpreting) is closer to what 'eval-when-compile' does.

==============================================================================
File: elisp.info,  Node: |Compiler_Errors|,  Next: |Byte_Code_Objects|,  Prev: |Eval_During_Compile|,  Up: |Byte_Compilation|
==============================================================================

                                                               *Compiler_Errors*

17.6 Compiler Errors
--------------------

Error and warning messages from byte compilation are printed in a buffer
named 'Compile-Log'.  These messages include file names and line
numbers identifying the location of the problem.  The usual Emacs
commands for operating on compiler output can be used on these messages.

   When an error is due to invalid syntax in the program, the byte
compiler might get confused about the error's exact location.  One way
to investigate is to switch to the buffer ' *Compiler Input*'.  (This
buffer name starts with a space, so it does not show up in the Buffer
Menu.)  This buffer contains the program being compiled, and point shows
how far the byte compiler was able to read; the cause of the error might
be nearby.  *Note Syntax Errors::, for some tips for locating syntax
errors.

   A common type of warning issued by the byte compiler is for functions
and variables that were used but not defined.  Such warnings report the
line number for the end of the file, not the locations where the missing
functions or variables were used; to find these, you must search the
file manually.

   If you are sure that a warning message about a missing function or
variable is unjustified, there are several ways to suppress it:

   * You can suppress the warning for a specific call to a function FUNC
     by conditionalizing it on an 'fboundp' test, like this:

          (if (fboundp 'FUNC) ...(FUNC ...)...)

     The call to FUNC must be in the THEN-FORM of the 'if', and FUNC
     must appear quoted in the call to 'fboundp'.  (This feature
     operates for 'cond' as well.)

   * Likewise, you can suppress the warning for a specific use of a
     variable VARIABLE by conditionalizing it on a 'boundp' test:

          (if (boundp 'VARIABLE) ...VARIABLE...)

     The reference to VARIABLE must be in the THEN-FORM of the 'if', and
     VARIABLE must appear quoted in the call to 'boundp'.

   * You can tell the compiler that a function is defined using
     'declare-function'.  *Note Declaring Functions::.

   * Likewise, you can tell the compiler that a variable is defined
     using 'defvar' with no initial value.  (Note that this marks the
     variable as special, i.e. dynamically bound, but only within the
     current lexical scope, or file if at top-level.)  *Note Defining
     Variables::.

   You can also suppress compiler warnings within a certain expression
using the 'with-suppressed-warnings' macro:

 -- Special Form: with-suppressed-warnings warnings body...
     In execution, this is equivalent to '(progn BODY...)', but the
     compiler does not issue warnings for the specified conditions in
     BODY.  WARNINGS is an associative list of warning symbols and
     function/variable symbols they apply to.  For instance, if you wish
     to call an obsolete function called 'foo', but want to suppress the
     compilation warning, say:

          (with-suppressed-warnings ((obsolete foo))
            (foo ...))

   For more coarse-grained suppression of compiler warnings, you can use
the 'with-no-warnings' construct:

 -- Special Form: with-no-warnings body...
     In execution, this is equivalent to '(progn BODY...)', but the
     compiler does not issue warnings for anything that occurs inside
     BODY.

     We recommend that you use 'with-suppressed-warnings' instead, but
     if you do use this construct, that you use it around the smallest
     possible piece of code to avoid missing possible warnings other
     than one you intend to suppress.

   Byte compiler warnings can be controlled more precisely by setting
the variable 'byte-compile-warnings'.  See its documentation string for
details.

   Sometimes you may wish the byte-compiler warnings to be reported
using 'error'.  If so, set 'byte-compile-error-on-warn' to a non-'nil'
value.

==============================================================================
File: elisp.info,  Node: |Byte_Code_Objects|,  Next: |Disassembly|,  Prev: |Compiler_Errors|,  Up: |Byte_Compilation|
==============================================================================

                                                             *Byte_Code_Objects*

17.7 Byte-Code Function Objects
-------------------------------

Byte-compiled functions have a special data type: they are "byte-code
function objects".  Whenever such an object appears as a function to be
called, Emacs uses the byte-code interpreter to execute the byte-code.

   Internally, a byte-code function object is much like a vector; its
elements can be accessed using 'aref'.  Its printed representation is
like that for a vector, with an additional '#' before the opening '['.
It must have at least four elements; there is no maximum number, but
only the first six elements have any normal use.  They are:

ARGDESC
     The descriptor of the arguments.  This can either be a list of
     arguments, as described in *note Argument List::, or an integer
     encoding the required number of arguments.  In the latter case, the
     value of the descriptor specifies the minimum number of arguments
     in the bits zero to 6, and the maximum number of arguments in bits
     8 to 14.  If the argument list uses '&rest', then bit 7 is set;
     otherwise it's cleared.

     If ARGDESC is a list, the arguments will be dynamically bound
     before executing the byte code.  If ARGDESC is an integer, the
     arguments will be instead pushed onto the stack of the byte-code
     interpreter, before executing the code.

BYTE-CODE
     The string containing the byte-code instructions.

CONSTANTS
     The vector of Lisp objects referenced by the byte code.  These
     include symbols used as function names and variable names.

STACKSIZE
     The maximum stack size this function needs.

DOCSTRING
     The documentation string (if any); otherwise, 'nil'.  The value may
     be a number or a list, in case the documentation string is stored
     in a file.  Use the function 'documentation' to get the real
     documentation string (*note Accessing Documentation::).

INTERACTIVE
     The interactive spec (if any).  This can be a string or a Lisp
     expression.  It is 'nil' for a function that isn't interactive.

   Here's an example of a byte-code function object, in printed
representation.  It is the definition of the command 'backward-sexp'.

     #[256
       "\211\204^G^@\300\262^A\301^A[!\207"
       [1 forward-sexp]
       3
       1793299
       "^p"]

   The primitive way to create a byte-code object is with
'make-byte-code':

 -- Function: make-byte-code &rest elements
     This function constructs and returns a byte-code function object
     with ELEMENTS as its elements.

   You should not try to come up with the elements for a byte-code
function yourself, because if they are inconsistent, Emacs may crash
when you call the function.  Always leave it to the byte compiler to
create these objects; it makes the elements consistent (we hope).

==============================================================================
File: elisp.info,  Node: |Disassembly|,  Prev: |Byte_Code_Objects|,  Up: |Byte_Compilation|
==============================================================================

                                                                   *Disassembly*

17.8 Disassembled Byte-Code
---------------------------

People do not write byte-code; that job is left to the byte compiler.
But we provide a disassembler to satisfy a cat-like curiosity.  The
disassembler converts the byte-compiled code into human-readable form.

   The byte-code interpreter is implemented as a simple stack machine.
It pushes values onto a stack of its own, then pops them off to use them
in calculations whose results are themselves pushed back on the stack.
When a byte-code function returns, it pops a value off the stack and
returns it as the value of the function.

   In addition to the stack, byte-code functions can use, bind, and set
ordinary Lisp variables, by transferring values between variables and
the stack.

 -- Command: disassemble object &optional buffer-or-name
     This command displays the disassembled code for OBJECT.  In
     interactive use, or if BUFFER-OR-NAME is 'nil' or omitted, the
     output goes in a buffer named 'Disassemble'.  If BUFFER-OR-NAME
     is non-'nil', it must be a buffer or the name of an existing
     buffer.  Then the output goes there, at point, and point is left
     before the output.

     The argument OBJECT can be a function name, a lambda expression
     (*note Lambda Expressions::), or a byte-code object (*note
     Byte-Code Objects::).  If it is a lambda expression, 'disassemble'
     compiles it and disassembles the resulting compiled code.

   Here are two examples of using the 'disassemble' function.  We have
added explanatory comments to help you relate the byte-code to the Lisp
source; these do not appear in the output of 'disassemble'.

     (defun factorial (integer)
       "Compute factorial of an integer."
       (if (= 1 integer) 1
         (* integer (factorial (1- integer)))))
          => factorial

     (factorial 4)
          => 24

     (disassemble 'factorial)
          -| byte-code for factorial:
      doc: Compute factorial of an integer.
      args: (integer)

     0   varref   integer      ; Get the value of 'integer' and
                               ;   push it onto the stack.
     1   constant 1            ; Push 1 onto stack.
     2   eqlsign               ; Pop top two values off stack, compare
                               ;   them, and push result onto stack.
     3   goto-if-nil 1         ; Pop and test top of stack;
                               ;   if 'nil', go to 1, else continue.
     6   constant 1            ; Push 1 onto top of stack.
     7   return                ; Return the top element of the stack.
     8:1 varref   integer      ; Push value of 'integer' onto stack.
     9   constant factorial    ; Push 'factorial' onto stack.
     10  varref   integer      ; Push value of 'integer' onto stack.
     11  sub1                  ; Pop 'integer', decrement value,
                               ;   push new value onto stack.
     12  call     1            ; Call function 'factorial' using first
                               ;   (i.e., top) stack element as argument;
                               ;   push returned value onto stack.
     13 mult                   ; Pop top two values off stack, multiply
                               ;   them, and push result onto stack.
     14 return                 ; Return the top element of the stack.

   The 'silly-loop' function is somewhat more complex:

     (defun silly-loop (n)
       "Return time before and after N iterations of a loop."
       (let ((t1 (current-time-string)))
         (while (> (setq n (1- n))
                   0))
         (list t1 (current-time-string))))
          => silly-loop

     (disassemble 'silly-loop)
          -| byte-code for silly-loop:
      doc: Return time before and after N iterations of a loop.
      args: (n)

     0   constant current-time-string  ; Push 'current-time-string'
                                       ;   onto top of stack.
     1   call     0            ; Call 'current-time-string' with no
                               ;   argument, push result onto stack.
     2   varbind  t1           ; Pop stack and bind 't1' to popped value.
     3:1 varref   n            ; Get value of 'n' from the environment
                               ;   and push the value on the stack.
     4   sub1                  ; Subtract 1 from top of stack.
     5   dup                   ; Duplicate top of stack; i.e., copy the top
                               ;   of the stack and push copy onto stack.
     6   varset   n            ; Pop the top of the stack,
                               ;   and bind 'n' to the value.

     ;; (In effect, the sequence 'dup varset' copies the top of the stack
     ;; into the value of 'n' without popping it.)

     7   constant 0            ; Push 0 onto stack.
     8   gtr                   ; Pop top two values off stack,
                               ;   test if N is greater than 0
                               ;   and push result onto stack.
     9   goto-if-not-nil 1     ; Goto 1 if 'n' > 0
                               ;   (this continues the while loop)
                               ;   else continue.
     12  varref   t1           ; Push value of 't1' onto stack.
     13  constant current-time-string  ; Push 'current-time-string'
                                       ;   onto the top of the stack.
     14  call     0            ; Call 'current-time-string' again.
     15  unbind   1            ; Unbind 't1' in local environment.
     16  list2                 ; Pop top two elements off stack, create a
                               ;   list of them, and push it onto stack.
     17  return                ; Return value of the top of stack.

==============================================================================
File: elisp.info,  Node: |Debugging|,  Next: |Read_and_Print|,  Prev: |Byte_Compilation|,  Up: |Top|
==============================================================================

                                                                     *Debugging*

18 Debugging Lisp Programs
==========================

There are several ways to find and investigate problems in an Emacs Lisp
program.

   * If a problem occurs when you run the program, you can use the
     built-in Emacs Lisp debugger to suspend the Lisp evaluator, and
     examine and/or alter its internal state.

   * You can use Edebug, a source-level debugger for Emacs Lisp.

   * You can trace the execution of functions involved in the problem
     using the tracing facilities provided by the 'trace.el' package.
     This package provides the functions 'trace-function-foreground' and
     'trace-function-background' for tracing function calls, and
     'trace-values' for adding values of select variables to the trace.
     For the details, see the documentation of these facilities in
     'trace.el'.

   * If a syntactic problem is preventing Lisp from even reading the
     program, you can locate it using Lisp editing commands.

   * You can look at the error and warning messages produced by the byte
     compiler when it compiles the program.  *Note Compiler Errors::.

   * You can use the Testcover package to perform coverage testing on
     the program.

   * You can use the ERT package to write regression tests for the
     program.  *Note the ERT manual: (ert)Top.

   * You can profile the program to get hints about how to make it more
     efficient.

   Other useful tools for debugging input and output problems are the
dribble file (*note Terminal Input::) and the 'open-termscript' function
(*note Terminal Output::).

MENU

* |Debugger|::            A debugger for the Emacs Lisp evaluator.
* |Edebug|::              A source-level Emacs Lisp debugger.
* |Syntax_Errors|::       How to find syntax errors.
* |Test_Coverage|::       Ensuring you have tested all branches in your code.
* |Profiling|::           Measuring the resources that your code uses.

==============================================================================
File: elisp.info,  Node: |Debugger|,  Next: |Edebug|,  Up: |Debugging|
==============================================================================

                                                                      *Debugger*

18.1 The Lisp Debugger
----------------------

The ordinary "Lisp debugger" provides the ability to suspend evaluation
of a form.  While evaluation is suspended (a state that is commonly
known as a "break"), you may examine the run time stack, examine the
values of local or global variables, or change those values.  Since a
break is a recursive edit, all the usual editing facilities of Emacs are
available; you can even run programs that will enter the debugger
recursively.  *Note Recursive Editing::.

MENU

* |Error_Debugging|::       Entering the debugger when an error happens.
* |Infinite_Loops|::        Stopping and debugging a program that doesn't exit.
* |Function_Debugging|::    Entering it when a certain function is called.
* |Variable_Debugging|::    Entering it when a variable is modified.
* |Explicit_Debug|::        Entering it at a certain point in the program.
* |Using_Debugger|::        What the debugger does.
* |Backtraces|::            What you see while in the debugger.
* |Debugger_Commands|::     Commands used while in the debugger.
* |Invoking_the_Debugger|:: How to call the function 'debug'.
* |Internals_of_Debugger|:: Subroutines of the debugger, and global variables.

==============================================================================
File: elisp.info,  Node: |Error_Debugging|,  Next: |Infinite_Loops|,  Up: Debugger
==============================================================================

                                                               *Error_Debugging*

18.1.1 Entering the Debugger on an Error
----------------------------------------

The most important time to enter the debugger is when a Lisp error
happens.  This allows you to investigate the immediate causes of the
error.

   However, entry to the debugger is not a normal consequence of an
error.  Many commands signal Lisp errors when invoked inappropriately,
and during ordinary editing it would be very inconvenient to enter the
debugger each time this happens.  So if you want errors to enter the
debugger, set the variable 'debug-on-error' to non-'nil'.  (The command
'toggle-debug-on-error' provides an easy way to do this.)

 -- User Option: debug-on-error
     This variable determines whether the debugger is called when an
     error is signaled and not handled.  If 'debug-on-error' is 't', all
     kinds of errors call the debugger, except those listed in
     'debug-ignored-errors' (see below).  If it is 'nil', none call the
     debugger.

     The value can also be a list of error conditions (*note Signaling
     Errors::).  Then the debugger is called only for error conditions
     in this list (except those also listed in 'debug-ignored-errors').
     For example, if you set 'debug-on-error' to the list
     '(void-variable)', the debugger is only called for errors about a
     variable that has no value.

     Note that 'eval-expression-debug-on-error' overrides this variable
     in some cases; see below.

     When this variable is non-'nil', Emacs does not create an error
     handler around process filter functions and sentinels.  Therefore,
     errors in these functions also invoke the debugger.  *Note
     Processes::.

 -- User Option: debug-ignored-errors
     This variable specifies errors which should not enter the debugger,
     regardless of the value of 'debug-on-error'.  Its value is a list
     of error condition symbols and/or regular expressions.  If the
     error has any of those condition symbols, or if the error message
     matches any of the regular expressions, then that error does not
     enter the debugger.

     The normal value of this variable includes 'user-error', as well as
     several errors that happen often during editing but rarely result
     from bugs in Lisp programs.  However, "rarely" is not "never"; if
     your program fails with an error that matches this list, you may
     try changing this list to debug the error.  The easiest way is
     usually to set 'debug-ignored-errors' to 'nil'.

 -- User Option: eval-expression-debug-on-error
     If this variable has a non-'nil' value (the default), running the
     command 'eval-expression' causes 'debug-on-error' to be temporarily
     bound to 't'.  *Note Evaluating Emacs-Lisp Expressions: (emacs)Lisp
     Eval.

     If 'eval-expression-debug-on-error' is 'nil', then the value of
     'debug-on-error' is not changed during 'eval-expression'.

 -- User Option: debug-on-signal
     Normally, errors caught by 'condition-case' never invoke the
     debugger.  The 'condition-case' gets a chance to handle the error
     before the debugger gets a chance.

     If you change 'debug-on-signal' to a non-'nil' value, the debugger
     gets the first chance at every error, regardless of the presence of
     'condition-case'.  (To invoke the debugger, the error must still
     fulfill the criteria specified by 'debug-on-error' and
     'debug-ignored-errors'.)

     For example, setting this variable is useful to get a backtrace
     from code evaluated by emacsclient's '--eval' option.  If Lisp code
     evaluated by emacsclient signals an error while this variable is
     non-'nil', the backtrace will popup in the running Emacs.

     Warning: Setting this variable to non-'nil' may have annoying
     effects.  Various parts of Emacs catch errors in the normal course
     of affairs, and you may not even realize that errors happen there.
     If you need to debug code wrapped in 'condition-case', consider
     using 'condition-case-unless-debug' (*note Handling Errors::).

 -- User Option: debug-on-event
     If you set 'debug-on-event' to a special event (*note Special
     Events::), Emacs will try to enter the debugger as soon as it
     receives this event, bypassing 'special-event-map'.  At present,
     the only supported values correspond to the signals 'SIGUSR1' and
     'SIGUSR2' (this is the default).  This can be helpful when
     'inhibit-quit' is set and Emacs is not otherwise responding.

 -- Variable: debug-on-message
     If you set 'debug-on-message' to a regular expression, Emacs will
     enter the debugger if it displays a matching message in the echo
     area.  For example, this can be useful when trying to find the
     cause of a particular message.

   To debug an error that happens during loading of the init file, use
the option '--debug-init'.  This binds 'debug-on-error' to 't' while
loading the init file, and bypasses the 'condition-case' which normally
catches errors in the init file.

==============================================================================
File: elisp.info,  Node: |Infinite_Loops|,  Next: |Function_Debugging|,  Prev: |Error_Debugging|,  Up: |Debugger|
==============================================================================

                                                                *Infinite_Loops*

18.1.2 Debugging Infinite Loops
-------------------------------

When a program loops infinitely and fails to return, your first problem
is to stop the loop.  On most operating systems, you can do this with
'C-g', which causes a "quit".  *Note Quitting::.

   Ordinary quitting gives no information about why the program was
looping.  To get more information, you can set the variable
'debug-on-quit' to non-'nil'.  Once you have the debugger running in the
middle of the infinite loop, you can proceed from the debugger using the
stepping commands.  If you step through the entire loop, you may get
enough information to solve the problem.

   Quitting with 'C-g' is not considered an error, and 'debug-on-error'
has no effect on the handling of 'C-g'.  Likewise, 'debug-on-quit' has
no effect on errors.

 -- User Option: debug-on-quit
     This variable determines whether the debugger is called when 'quit'
     is signaled and not handled.  If 'debug-on-quit' is non-'nil', then
     the debugger is called whenever you quit (that is, type 'C-g').  If
     'debug-on-quit' is 'nil' (the default), then the debugger is not
     called when you quit.

==============================================================================
File: elisp.info,  Node: |Function_Debugging|,  Next: |Variable_Debugging|,  Prev: |Infinite_Loops|,  Up: |Debugger|
==============================================================================

                                                            *Function_Debugging*

18.1.3 Entering the Debugger on a Function Call
-----------------------------------------------

To investigate a problem that happens in the middle of a program, one
useful technique is to enter the debugger whenever a certain function is
called.  You can do this to the function in which the problem occurs,
and then step through the function, or you can do this to a function
called shortly before the problem, step quickly over the call to that
function, and then step through its caller.

 -- Command: debug-on-entry function-name
     This function requests FUNCTION-NAME to invoke the debugger each
     time it is called.

     Any function or macro defined as Lisp code may be set to break on
     entry, regardless of whether it is interpreted code or compiled
     code.  If the function is a command, it will enter the debugger
     when called from Lisp and when called interactively (after the
     reading of the arguments).  You can also set debug-on-entry for
     primitive functions (i.e., those written in C) this way, but it
     only takes effect when the primitive is called from Lisp code.
     Debug-on-entry is not allowed for special forms.

     When 'debug-on-entry' is called interactively, it prompts for
     FUNCTION-NAME in the minibuffer.  If the function is already set up
     to invoke the debugger on entry, 'debug-on-entry' does nothing.
     'debug-on-entry' always returns FUNCTION-NAME.

     Here's an example to illustrate use of this function:

          (defun fact (n)
            (if (zerop n) 1
                (* n (fact (1- n)))))
               => fact
          (debug-on-entry 'fact)
               => fact
          (fact 3)

          ------ Buffer: Backtrace ------
          Debugger entered--entering a function:
          * fact(3)
            eval((fact 3))
            eval-last-sexp-1(nil)
            eval-last-sexp(nil)
            call-interactively(eval-last-sexp)
          ------ Buffer: Backtrace ------


 -- Command: cancel-debug-on-entry &optional function-name
     This function undoes the effect of 'debug-on-entry' on
     FUNCTION-NAME.  When called interactively, it prompts for
     FUNCTION-NAME in the minibuffer.  If FUNCTION-NAME is omitted or
     'nil', it cancels break-on-entry for all functions.  Calling
     'cancel-debug-on-entry' does nothing to a function which is not
     currently set up to break on entry.

==============================================================================
File: elisp.info,  Node: |Variable_Debugging|,  Next: |Explicit_Debug|,  Prev: |Function_Debugging|,  Up: |Debugger|
==============================================================================

                                                            *Variable_Debugging*

18.1.4 Entering the debugger when a variable is modified
--------------------------------------------------------

Sometimes a problem with a function is due to a wrong setting of a
variable.  Setting up the debugger to trigger whenever the variable is
changed is a quick way to find the origin of the setting.

 -- Command: debug-on-variable-change variable
     This function arranges for the debugger to be called whenever
     VARIABLE is modified.

     It is implemented using the watchpoint mechanism, so it inherits
     the same characteristics and limitations: all aliases of VARIABLE
     will be watched together, only dynamic variables can be watched,
     and changes to the objects referenced by variables are not
     detected.  For details, see *note Watching Variables::.

 -- Command: cancel-debug-on-variable-change &optional variable
     This function undoes the effect of 'debug-on-variable-change' on
     VARIABLE.  When called interactively, it prompts for VARIABLE in
     the minibuffer.  If VARIABLE is omitted or 'nil', it cancels
     break-on-change for all variables.  Calling
     'cancel-debug-on-variable-change' does nothing to a variable which
     is not currently set up to break on change.

==============================================================================
File: elisp.info,  Node: |Explicit_Debug|,  Next: |Using_Debugger|,  Prev: |Variable_Debugging|,  Up: |Debugger|
==============================================================================

                                                                *Explicit_Debug*

18.1.5 Explicit Entry to the Debugger
-------------------------------------

You can cause the debugger to be called at a certain point in your
program by writing the expression '(debug)' at that point.  To do this,
visit the source file, insert the text '(debug)' at the proper place,
and type 'C-M-x' ('eval-defun', a Lisp mode key binding).  Warning: if
you do this for temporary debugging purposes, be sure to undo this
insertion before you save the file!

   The place where you insert '(debug)' must be a place where an
additional form can be evaluated and its value ignored.  (If the value
of '(debug)' isn't ignored, it will alter the execution of the program!)
The most common suitable places are inside a 'progn' or an implicit
'progn' (*note Sequencing::).

   If you don't know exactly where in the source code you want to put
the debug statement, but you want to display a backtrace when a certain
message is displayed, you can set 'debug-on-message' to a regular
expression matching the desired message.

==============================================================================
File: elisp.info,  Node: |Using_Debugger|,  Next: |Backtraces|,  Prev: |Explicit_Debug|,  Up: |Debugger|
==============================================================================

                                                                *Using_Debugger*

18.1.6 Using the Debugger
-------------------------

When the debugger is entered, it displays the previously selected buffer
in one window and a buffer named 'Backtrace' in another window.  The
backtrace buffer contains one line for each level of Lisp function
execution currently going on.  At the beginning of this buffer is a
message describing the reason that the debugger was invoked (such as the
error message and associated data, if it was invoked due to an error).

   The backtrace buffer is read-only and uses a special major mode,
Debugger mode, in which letters are defined as debugger commands.  The
usual Emacs editing commands are available; thus, you can switch windows
to examine the buffer that was being edited at the time of the error,
switch buffers, visit files, or do any other sort of editing.  However,
the debugger is a recursive editing level (*note Recursive Editing::)
and it is wise to go back to the backtrace buffer and exit the debugger
(with the 'q' command) when you are finished with it.  Exiting the
debugger gets out of the recursive edit and buries the backtrace buffer.
(You can customize what the 'q' command does with the backtrace buffer
by setting the variable 'debugger-bury-or-kill'.  For example, set it to
'kill' if you prefer to kill the buffer rather than bury it.  Consult
the variable's documentation for more possibilities.)

   When the debugger has been entered, the 'debug-on-error' variable is
temporarily set according to 'eval-expression-debug-on-error'.  If the
latter variable is non-'nil', 'debug-on-error' will temporarily be set
to 't'.  This means that any further errors that occur while doing a
debugging session will (by default) trigger another backtrace.  If this
is not what you want, you can either set
'eval-expression-debug-on-error' to 'nil', or set 'debug-on-error' to
'nil' in 'debugger-mode-hook'.

   The debugger itself must be run byte-compiled, since it makes
assumptions about the state of the Lisp interpreter.  These assumptions
are false if the debugger is running interpreted.

==============================================================================
File: elisp.info,  Node: |Backtraces|,  Next: |Debugger_Commands|,  Prev: |Using_Debugger|,  Up: |Debugger|
==============================================================================

                                                                    *Backtraces*

18.1.7 Backtraces
-----------------

Debugger mode is derived from Backtrace mode, which is also used to show
backtraces by Edebug and ERT.  (*note Edebug::, and *note the ERT
manual: (ert)Top.)

   The backtrace buffer shows you the functions that are executing and
their argument values.  When a backtrace buffer is created, it shows
each stack frame on one, possibly very long, line.  (A stack frame is
the place where the Lisp interpreter records information about a
particular invocation of a function.)  The most recently called function
will be at the top.

   In a backtrace you can specify a stack frame by moving point to a
line describing that frame.  The frame whose line point is on is
considered the "current frame".

   If a function name is underlined, that means Emacs knows where its
source code is located.  You can click with the mouse on that name, or
move to it and type <RET>, to visit the source code.  You can also type
<RET> while point is on any name of a function or variable which is not
underlined, to see help information for that symbol in a help buffer, if
any exists.  The 'xref-find-definitions' command, bound to <M-.>, can
also be used on any identifier in a backtrace (*note (emacs)Looking Up
Identifiers::).

   In backtraces, the tails of long lists and the ends of long strings,
vectors or structures, as well as objects which are deeply nested, will
be printed as underlined "...".  You can click with the mouse on a
"...", or type <RET> while point is on it, to show the part of the
object that was hidden.  To control how much abbreviation is done,
customize 'backtrace-line-length'.

   Here is a list of commands for navigating and viewing backtraces:

'v'
     Toggle the display of local variables of the current stack frame.

'p'
     Move to the beginning of the frame, or to the beginning of the
     previous frame.

'n'
     Move to the beginning of the next frame.

'+'
     Add line breaks and indentation to the top-level Lisp form at point
     to make it more readable.

'-'
     Collapse the top-level Lisp form at point back to a single line.

'#'
     Toggle 'print-circle' for the frame at point.

':'
     Toggle 'print-gensym' for the frame at point.

'.'
     Expand all the forms abbreviated with "..." in the frame at point.

==============================================================================
File: elisp.info,  Node: |Debugger_Commands|,  Next: |Invoking_the_Debugger|,  Prev: |Backtraces|,  Up: |Debugger|
==============================================================================

                                                             *Debugger_Commands*

18.1.8 Debugger Commands
------------------------

The debugger buffer (in Debugger mode) provides special commands in
addition to the usual Emacs commands and to the Backtrace mode commands
described in the previous section.  The most important use of debugger
commands is for stepping through code, so that you can see how control
flows.  The debugger can step through the control structures of an
interpreted function, but cannot do so in a byte-compiled function.  If
you would like to step through a byte-compiled function, replace it with
an interpreted definition of the same function.  (To do this, visit the
source for the function and type 'C-M-x' on its definition.)  You cannot
use the Lisp debugger to step through a primitive function.

   Some of the debugger commands operate on the current frame.  If a
frame starts with a star, that means that exiting that frame will call
the debugger again.  This is useful for examining the return value of a
function.

   Here is a list of Debugger mode commands:

'c'
     Exit the debugger and continue execution.  This resumes execution
     of the program as if the debugger had never been entered (aside
     from any side-effects that you caused by changing variable values
     or data structures while inside the debugger).

'd'
     Continue execution, but enter the debugger the next time any Lisp
     function is called.  This allows you to step through the
     subexpressions of an expression, seeing what values the
     subexpressions compute, and what else they do.

     The stack frame made for the function call which enters the
     debugger in this way will be flagged automatically so that the
     debugger will be called again when the frame is exited.  You can
     use the 'u' command to cancel this flag.

'b'
     Flag the current frame so that the debugger will be entered when
     the frame is exited.  Frames flagged in this way are marked with
     stars in the backtrace buffer.

'u'
     Don't enter the debugger when the current frame is exited.  This
     cancels a 'b' command on that frame.  The visible effect is to
     remove the star from the line in the backtrace buffer.

'j'
     Flag the current frame like 'b'.  Then continue execution like 'c',
     but temporarily disable break-on-entry for all functions that are
     set up to do so by 'debug-on-entry'.

'e'
     Read a Lisp expression in the minibuffer, evaluate it (with the
     relevant lexical environment, if applicable), and print the value
     in the echo area.  The debugger alters certain important variables,
     and the current buffer, as part of its operation; 'e' temporarily
     restores their values from outside the debugger, so you can examine
     and change them.  This makes the debugger more transparent.  By
     contrast, 'M-:' does nothing special in the debugger; it shows you
     the variable values within the debugger.

'R'
     Like 'e', but also save the result of evaluation in the buffer
     'Debugger-record'.

'q'
     Terminate the program being debugged; return to top-level Emacs
     command execution.

     If the debugger was entered due to a 'C-g' but you really want to
     quit, and not debug, use the 'q' command.

'r'
     Return a value from the debugger.  The value is computed by reading
     an expression with the minibuffer and evaluating it.

     The 'r' command is useful when the debugger was invoked due to exit
     from a Lisp call frame (as requested with 'b' or by entering the
     frame with 'd'); then the value specified in the 'r' command is
     used as the value of that frame.  It is also useful if you call
     'debug' and use its return value.  Otherwise, 'r' has the same
     effect as 'c', and the specified return value does not matter.

     You can't use 'r' when the debugger was entered due to an error.

'l'
     Display a list of functions that will invoke the debugger when
     called.  This is a list of functions that are set to break on entry
     by means of 'debug-on-entry'.

==============================================================================
File: elisp.info,  Node: |Invoking_the_Debugger|,  Next: |Internals_of_Debugger|,  Prev: |Debugger_Commands|,  Up: |Debugger|
==============================================================================

                                                         *Invoking_the_Debugger*

18.1.9 Invoking the Debugger
----------------------------

Here we describe in full detail the function 'debug' that is used to
invoke the debugger.

 -- Command: debug &rest debugger-args
     This function enters the debugger.  It switches buffers to a buffer
     named 'Backtrace' (or '*Backtrace*<2>' if it is the second
     recursive entry to the debugger, etc.), and fills it with
     information about the stack of Lisp function calls.  It then enters
     a recursive edit, showing the backtrace buffer in Debugger mode.

     The Debugger mode 'c', 'd', 'j', and 'r' commands exit the
     recursive edit; then 'debug' switches back to the previous buffer
     and returns to whatever called 'debug'.  This is the only way the
     function 'debug' can return to its caller.

     The use of the DEBUGGER-ARGS is that 'debug' displays the rest of
     its arguments at the top of the 'Backtrace' buffer, so that the
     user can see them.  Except as described below, this is the _only_
     way these arguments are used.

     However, certain values for first argument to 'debug' have a
     special significance.  (Normally, these values are used only by the
     internals of Emacs, and not by programmers calling 'debug'.)  Here
     is a table of these special values:

     'lambda'
          A first argument of 'lambda' means 'debug' was called because
          of entry to a function when 'debug-on-next-call' was
          non-'nil'.  The debugger displays 'Debugger entered--entering
          a function:' as a line of text at the top of the buffer.

     'debug'
          'debug' as first argument means 'debug' was called because of
          entry to a function that was set to debug on entry.  The
          debugger displays the string 'Debugger entered--entering a
          function:', just as in the 'lambda' case.  It also marks the
          stack frame for that function so that it will invoke the
          debugger when exited.

     't'
          When the first argument is 't', this indicates a call to
          'debug' due to evaluation of a function call form when
          'debug-on-next-call' is non-'nil'.  The debugger displays
          'Debugger entered--beginning evaluation of function call
          form:' as the top line in the buffer.

     'exit'
          When the first argument is 'exit', it indicates the exit of a
          stack frame previously marked to invoke the debugger on exit.
          The second argument given to 'debug' in this case is the value
          being returned from the frame.  The debugger displays
          'Debugger entered--returning value:' in the top line of the
          buffer, followed by the value being returned.

     'error'
          When the first argument is 'error', the debugger indicates
          that it is being entered because an error or 'quit' was
          signaled and not handled, by displaying 'Debugger
          entered--Lisp error:' followed by the error signaled and any
          arguments to 'signal'.  For example,

               (let ((debug-on-error t))
                 (/ 1 0))

               ------ Buffer: Backtrace ------
               Debugger entered--Lisp error: (arith-error)
                 /(1 0)
               ...
               ------ Buffer: Backtrace ------

          If an error was signaled, presumably the variable
          'debug-on-error' is non-'nil'.  If 'quit' was signaled, then
          presumably the variable 'debug-on-quit' is non-'nil'.

     'nil'
          Use 'nil' as the first of the DEBUGGER-ARGS when you want to
          enter the debugger explicitly.  The rest of the DEBUGGER-ARGS
          are printed on the top line of the buffer.  You can use this
          feature to display messages--for example, to remind yourself of
          the conditions under which 'debug' is called.

==============================================================================
File: elisp.info,  Node: |Internals_of_Debugger|,  Prev: |Invoking_the_Debugger|,  Up: |Debugger|
==============================================================================

                                                         *Internals_of_Debugger*

18.1.10 Internals of the Debugger
---------------------------------

This section describes functions and variables used internally by the
debugger.

 -- Variable: debugger
     The value of this variable is the function to call to invoke the
     debugger.  Its value must be a function of any number of arguments,
     or, more typically, the name of a function.  This function should
     invoke some kind of debugger.  The default value of the variable is
     'debug'.

     The first argument that Lisp hands to the function indicates why it
     was called.  The convention for arguments is detailed in the
     description of 'debug' (*note Invoking the Debugger::).

 -- Function: backtrace
     This function prints a trace of Lisp function calls currently
     active.  The trace is identical to the one that 'debug' would show
     in the 'Backtrace' buffer.  The return value is always nil.

     In the following example, a Lisp expression calls 'backtrace'
     explicitly.  This prints the backtrace to the stream
     'standard-output', which, in this case, is the buffer
     'backtrace-output'.

     Each line of the backtrace represents one function call.  The line
     shows the function followed by a list of the values of the
     function's arguments if they are all known; if they are still being
     computed, the line consists of a list containing the function and
     its unevaluated arguments.  Long lists or deeply nested structures
     may be elided.

          (with-output-to-temp-buffer "backtrace-output"
            (let ((var 1))
              (save-excursion
                (setq var (eval '(progn
                                   (1+ var)
                                   (list 'testing (backtrace))))))))

               => (testing nil)

          ----------- Buffer: backtrace-output ------------
            backtrace()
            (list 'testing (backtrace))
            (progn ...)
            eval((progn (1+ var) (list 'testing (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            eval((with-output-to-temp-buffer ...))
            eval-last-sexp-1(nil)
            eval-last-sexp(nil)
            call-interactively(eval-last-sexp)
          ----------- Buffer: backtrace-output ------------

 -- User Option: debugger-stack-frame-as-list
     If this variable is non-'nil', every stack frame of the backtrace
     is displayed as a list.  This aims at improving the backtrace
     readability at the cost of special forms no longer being visually
     different from regular function calls.

     With 'debugger-stack-frame-as-list' non-'nil', the above example
     would look as follows:

          ----------- Buffer: backtrace-output ------------
            (backtrace)
            (list 'testing (backtrace))
            (progn ...)
            (eval (progn (1+ var) (list 'testing (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            (eval (with-output-to-temp-buffer ...))
            (eval-last-sexp-1 nil)
            (eval-last-sexp nil)
            (call-interactively eval-last-sexp)
          ----------- Buffer: backtrace-output ------------

 -- Variable: debug-on-next-call
     If this variable is non-'nil', it says to call the debugger before
     the next 'eval', 'apply' or 'funcall'.  Entering the debugger sets
     'debug-on-next-call' to 'nil'.

     The 'd' command in the debugger works by setting this variable.

 -- Function: backtrace-debug level flag
     This function sets the debug-on-exit flag of the stack frame LEVEL
     levels down the stack, giving it the value FLAG.  If FLAG is
     non-'nil', this will cause the debugger to be entered when that
     frame later exits.  Even a nonlocal exit through that frame will
     enter the debugger.

     This function is used only by the debugger.

 -- Variable: command-debug-status
     This variable records the debugging status of the current
     interactive command.  Each time a command is called interactively,
     this variable is bound to 'nil'.  The debugger can set this
     variable to leave information for future debugger invocations
     during the same command invocation.

     The advantage of using this variable rather than an ordinary global
     variable is that the data will never carry over to a subsequent
     command invocation.

     This variable is obsolete and will be removed in future versions.

 -- Function: backtrace-frame frame-number &optional base
     The function 'backtrace-frame' is intended for use in Lisp
     debuggers.  It returns information about what computation is
     happening in the stack frame FRAME-NUMBER levels down.

     If that frame has not evaluated the arguments yet, or is a special
     form, the value is '(nil FUNCTION ARG-FORMS...)'.

     If that frame has evaluated its arguments and called its function
     already, the return value is '(t FUNCTION ARG-VALUES...)'.

     In the return value, FUNCTION is whatever was supplied as the CAR
     of the evaluated list, or a 'lambda' expression in the case of a
     macro call.  If the function has a '&rest' argument, that is
     represented as the tail of the list ARG-VALUES.

     If BASE is specified, FRAME-NUMBER counts relative to the topmost
     frame whose FUNCTION is BASE.

     If FRAME-NUMBER is out of range, 'backtrace-frame' returns 'nil'.

 -- Function: mapbacktrace function &optional base
     The function 'mapbacktrace' calls FUNCTION once for each frame in
     the backtrace, starting at the first frame whose function is BASE
     (or from the top if BASE is omitted or 'nil').

     FUNCTION is called with four arguments: EVALD, FUNC, ARGS, and
     FLAGS.

     If a frame has not evaluated its arguments yet or is a special
     form, EVALD is 'nil' and ARGS is a list of forms.

     If a frame has evaluated its arguments and called its function
     already, EVALD is 't' and ARGS is a list of values.  FLAGS is a
     plist of properties of the current frame: currently, the only
     supported property is ':debug-on-exit', which is 't' if the stack
     frame's 'debug-on-exit' flag is set.

==============================================================================
File: elisp.info,  Node: |Edebug|,  Next: |Syntax_Errors|,  Prev: |Debugger|,  Up: |Debugging|
==============================================================================

                                                                        *Edebug*

18.2 Edebug
-----------

Edebug is a source-level debugger for Emacs Lisp programs, with which
you can:

   * Step through evaluation, stopping before and after each expression.

   * Set conditional or unconditional breakpoints.

   * Stop when a specified condition is true (the global break event).

   * Trace slow or fast, stopping briefly at each stop point, or at each
     breakpoint.

   * Display expression results and evaluate expressions as if outside
     of Edebug.

   * Automatically re-evaluate a list of expressions and display their
     results each time Edebug updates the display.

   * Output trace information on function calls and returns.

   * Stop when an error occurs.

   * Display a backtrace, omitting Edebug's own frames.

   * Specify argument evaluation for macros and defining forms.

   * Obtain rudimentary coverage testing and frequency counts.

   The first three sections below should tell you enough about Edebug to
start using it.

MENU

* |Using_Edebug|::                Introduction to use of Edebug.
* |Instrumenting|::               You must instrument your code
                                  in order to debug it with Edebug.
* Modes: Edebug Execution Modes. Execution modes, stopping more or less often.
* |Jumping|::                     Commands to jump to a specified place.
* Misc: Edebug Misc.            Miscellaneous commands.
* |Breaks|::                      Setting breakpoints to make the program stop.
* |Trapping_Errors|::             Trapping errors with Edebug.
* Views: Edebug Views.          Views inside and outside of Edebug.
* Eval: Edebug Eval.            Evaluating expressions within Edebug.
* |Eval_List|::                   Expressions whose values are displayed
                                  each time you enter Edebug.
* |Printing_in_Edebug|::          Customization of printing.
* |Trace_Buffer|::                How to produce trace output in a buffer.
* |Coverage_Testing|::            How to test evaluation coverage.
* |The_Outside_Context|::         Data that Edebug saves and restores.
* |Edebug_and_Macros|::           Specifying how to handle macro calls.
* Options: Edebug Options.      Option variables for customizing Edebug.

==============================================================================
File: elisp.info,  Node: |Using_Edebug|,  Next: |Instrumenting|,  Up: |Edebug|
==============================================================================

                                                                  *Using_Edebug*

18.2.1 Using Edebug
-------------------

To debug a Lisp program with Edebug, you must first "instrument" the
Lisp code that you want to debug.  A simple way to do this is to first
move point into the definition of a function or macro and then do 'C-u
C-M-x' ('eval-defun' with a prefix argument).  See *note
Instrumenting::, for alternative ways to instrument code.

   Once a function is instrumented, any call to the function activates
Edebug.  Depending on which Edebug execution mode you have selected,
activating Edebug may stop execution and let you step through the
function, or it may update the display and continue execution while
checking for debugging commands.  The default execution mode is step,
which stops execution.  *Note Edebug Execution Modes::.

   Within Edebug, you normally view an Emacs buffer showing the source
of the Lisp code you are debugging.  This is referred to as the "source
code buffer", and it is temporarily read-only.

   An arrow in the left fringe indicates the line where the function is
executing.  Point initially shows where within the line the function is
executing, but this ceases to be true if you move point yourself.

   If you instrument the definition of 'fac' (shown below) and then
execute '(fac 3)', here is what you would normally see.  Point is at the
open-parenthesis before 'if'.

     (defun fac (n)
     =>-!-(if (< 0 n)
           (* n (fac (1- n)))
         1))

   The places within a function where Edebug can stop execution are
called "stop points".  These occur both before and after each
subexpression that is a list, and also after each variable reference.
Here we use periods to show the stop points in the function 'fac':

     (defun fac (n)
       .(if .(< 0 n.).
           .(* n. .(fac .(1- n.).).).
         1).)

   The special commands of Edebug are available in the source code
buffer in addition to the commands of Emacs Lisp mode.  For example, you
can type the Edebug command <SPC> to execute until the next stop point.
If you type <SPC> once after entry to 'fac', here is the display you
will see:

     (defun fac (n)
     =>(if -!-(< 0 n)
           (* n (fac (1- n)))
         1))

   When Edebug stops execution after an expression, it displays the
expression's value in the echo area.

   Other frequently used commands are 'b' to set a breakpoint at a stop
point, 'g' to execute until a breakpoint is reached, and 'q' to exit
Edebug and return to the top-level command loop.  Type '?' to display a
list of all Edebug commands.

==============================================================================
File: elisp.info,  Node: |Instrumenting|,  Next: |Edebug_Execution_Modes|,  Prev: |Using_Edebug|,  Up: |Edebug|
==============================================================================

                                                                 *Instrumenting*

18.2.2 Instrumenting for Edebug
-------------------------------

In order to use Edebug to debug Lisp code, you must first "instrument"
the code.  Instrumenting code inserts additional code into it, to invoke
Edebug at the proper places.

   When you invoke command 'C-M-x' ('eval-defun') with a prefix argument
on a function definition, it instruments the definition before
evaluating it.  (This does not modify the source code itself.)  If the
variable 'edebug-all-defs' is non-'nil', that inverts the meaning of the
prefix argument: in this case, 'C-M-x' instruments the definition
_unless_ it has a prefix argument.  The default value of
'edebug-all-defs' is 'nil'.  The command 'M-x edebug-all-defs' toggles
the value of the variable 'edebug-all-defs'.

   If 'edebug-all-defs' is non-'nil', then the commands 'eval-region',
'eval-current-buffer', and 'eval-buffer' also instrument any definitions
they evaluate.  Similarly, 'edebug-all-forms' controls whether
'eval-region' should instrument _any_ form, even non-defining forms.
This doesn't apply to loading or evaluations in the minibuffer.  The
command 'M-x edebug-all-forms' toggles this option.

   Another command, 'M-x edebug-eval-top-level-form', is available to
instrument any top-level form regardless of the values of
'edebug-all-defs' and 'edebug-all-forms'.  'edebug-defun' is an alias
for 'edebug-eval-top-level-form'.

   While Edebug is active, the command 'I' ('edebug-instrument-callee')
instruments the definition of the function or macro called by the list
form after point, if it is not already instrumented.  This is possible
only if Edebug knows where to find the source for that function; for
this reason, after loading Edebug, 'eval-region' records the position of
every definition it evaluates, even if not instrumenting it.  See also
the 'i' command (*note Jumping::), which steps into the call after
instrumenting the function.

   Edebug knows how to instrument all the standard special forms,
'interactive' forms with an expression argument, anonymous lambda
expressions, and other defining forms.  However, Edebug cannot determine
on its own what a user-defined macro will do with the arguments of a
macro call, so you must provide that information using Edebug
specifications; for details, *note Edebug and Macros::.

   When Edebug is about to instrument code for the first time in a
session, it runs the hook 'edebug-setup-hook', then sets it to 'nil'.
You can use this to load Edebug specifications associated with a package
you are using, but only when you use Edebug.

   If Edebug detects a syntax error while instrumenting, it leaves point
at the erroneous code and signals an 'invalid-read-syntax' error.
Example:

     error-> Invalid read syntax: "Expected lambda expression"

   One potential reason for such a failure to instrument is that some
macro definitions are not yet known to Emacs.  To work around this, load
the file which defines the function you are about to instrument.

   To remove instrumentation from a definition, simply re-evaluate its
definition in a way that does not instrument.  There are two ways of
evaluating forms that never instrument them: from a file with 'load',
and from the minibuffer with 'eval-expression' ('M-:').

   A different way to remove the instrumentation from a definition is to
use the 'edebug-remove-instrumentation' command.  It also allows
removing the instrumentation from everything that has been instrumented.

   *Note Edebug Eval::, for other evaluation functions available inside
of Edebug.

==============================================================================
File: elisp.info,  Node: |Edebug_Execution_Modes|,  Next: |Jumping|,  Prev: |Instrumenting|,  Up: |Edebug|
==============================================================================

                                                        *Edebug_Execution_Modes*

18.2.3 Edebug Execution Modes
-----------------------------

Edebug supports several execution modes for running the program you are
debugging.  We call these alternatives "Edebug execution modes"; do not
confuse them with major or minor modes.  The current Edebug execution
mode determines how far Edebug continues execution before
stopping--whether it stops at each stop point, or continues to the next
breakpoint, for example--and how much Edebug displays the progress of the
evaluation before it stops.

   Normally, you specify the Edebug execution mode by typing a command
to continue the program in a certain mode.  Here is a table of these
commands; all except for 'S' resume execution of the program, at least
for a certain distance.

'S'
     Stop: don't execute any more of the program, but wait for more
     Edebug commands ('edebug-stop').

'<SPC>'
     Step: stop at the next stop point encountered ('edebug-step-mode').

'n'
     Next: stop at the next stop point encountered after an expression
     ('edebug-next-mode').  Also see 'edebug-forward-sexp' in *note
     Jumping::.

't'
     Trace: pause (normally one second) at each Edebug stop point
     ('edebug-trace-mode').

'T'
     Rapid trace: update the display at each stop point, but don't
     actually pause ('edebug-Trace-fast-mode').

'g'
     Go: run until the next breakpoint ('edebug-go-mode').  *Note
     Breakpoints::.

'c'
     Continue: pause one second at each breakpoint, and then continue
     ('edebug-continue-mode').

'C'
     Rapid continue: move point to each breakpoint, but don't pause
     ('edebug-Continue-fast-mode').

'G'
     Go non-stop: ignore breakpoints ('edebug-Go-nonstop-mode').  You
     can still stop the program by typing 'S', or any editing command.

   In general, the execution modes earlier in the above list run the
program more slowly or stop sooner than the modes later in the list.

   When you enter a new Edebug level, Edebug will normally stop at the
first instrumented function it encounters.  If you prefer to stop only
at a break point, or not at all (for example, when gathering coverage
data), change the value of 'edebug-initial-mode' from its default 'step'
to 'go', or 'Go-nonstop', or one of its other values (*note Edebug
Options::).  You can do this readily with 'C-x C-a C-m'
('edebug-set-initial-mode'):

 -- Command: edebug-set-initial-mode
     This command, bound to 'C-x C-a C-m', sets 'edebug-initial-mode'.
     It prompts you for a key to indicate the mode.  You should enter
     one of the eight keys listed above, which sets the corresponding
     mode.

   Note that you may reenter the same Edebug level several times if, for
example, an instrumented function is called several times from one
command.

   While executing or tracing, you can interrupt the execution by typing
any Edebug command.  Edebug stops the program at the next stop point and
then executes the command you typed.  For example, typing 't' during
execution switches to trace mode at the next stop point.  You can use
'S' to stop execution without doing anything else.

   If your function happens to read input, a character you type
intending to interrupt execution may be read by the function instead.
You can avoid such unintended results by paying attention to when your
program wants input.

   Keyboard macros containing the commands in this section do not
completely work: exiting from Edebug, to resume the program, loses track
of the keyboard macro.  This is not easy to fix.  Also, defining or
executing a keyboard macro outside of Edebug does not affect commands
inside Edebug.  This is usually an advantage.  See also the
'edebug-continue-kbd-macro' option in *note Edebug Options::.

 -- User Option: edebug-sit-for-seconds
     This option specifies how many seconds to wait between execution
     steps in trace mode or continue mode.  The default is 1 second.

==============================================================================
File: elisp.info,  Node: |Jumping|,  Next: |Edebug_Misc|,  Prev: |Edebug_Execution_Modes|,  Up: |Edebug|
==============================================================================

                                                                       *Jumping*

18.2.4 Jumping
--------------

The commands described in this section execute until they reach a
specified location.  All except 'i' make a temporary breakpoint to
establish the place to stop, then switch to go mode.  Any other
breakpoint reached before the intended stop point will also stop
execution.  *Note Breakpoints::, for the details on breakpoints.

   These commands may fail to work as expected in case of nonlocal exit,
as that can bypass the temporary breakpoint where you expected the
program to stop.

'h'
     Proceed to the stop point near where point is ('edebug-goto-here').

'f'
     Run the program for one expression ('edebug-forward-sexp').

'o'
     Run the program until the end of the containing sexp
     ('edebug-step-out').

'i'
     Step into the function or macro called by the form after point
     ('edebug-step-in').

   The 'h' command proceeds to the stop point at or after the current
location of point, using a temporary breakpoint.

   The 'f' command runs the program forward over one expression.  More
precisely, it sets a temporary breakpoint at the position that
'forward-sexp' would reach, then executes in go mode so that the program
will stop at breakpoints.

   With a prefix argument N, the temporary breakpoint is placed N sexps
beyond point.  If the containing list ends before N more elements, then
the place to stop is after the containing expression.

   You must check that the position 'forward-sexp' finds is a place that
the program will really get to.  In 'cond', for example, this may not be
true.

   For flexibility, the 'f' command does 'forward-sexp' starting at
point, rather than at the stop point.  If you want to execute one
expression _from the current stop point_, first type 'w'
('edebug-where') to move point there, and then type 'f'.

   The 'o' command continues out of an expression.  It places a
temporary breakpoint at the end of the sexp containing point.  If the
containing sexp is a function definition itself, 'o' continues until
just before the last sexp in the definition.  If that is where you are
now, it returns from the function and then stops.  In other words, this
command does not exit the currently executing function unless you are
positioned after the last sexp.

   Normally, the 'h', 'f', and 'o' commands display "Break" and pause
for 'edebug-sit-for-seconds' before showing the result of the form just
evaluated.  You can avoid this pause by setting 'edebug-sit-on-break' to
'nil'.  *Note Edebug Options::.

   The 'i' command steps into the function or macro called by the list
form after point, and stops at its first stop point.  Note that the form
need not be the one about to be evaluated.  But if the form is a
function call about to be evaluated, remember to use this command before
any of the arguments are evaluated, since otherwise it will be too late.

   The 'i' command instruments the function or macro it's supposed to
step into, if it isn't instrumented already.  This is convenient, but
keep in mind that the function or macro remains instrumented unless you
explicitly arrange to deinstrument it.

==============================================================================
File: elisp.info,  Node: |Edebug_Misc|,  Next: |Breaks|,  Prev: |Jumping|,  Up: |Edebug|
==============================================================================

                                                                   *Edebug_Misc*

18.2.5 Miscellaneous Edebug Commands
------------------------------------

Some miscellaneous Edebug commands are described here.

'?'
     Display the help message for Edebug ('edebug-help').

'C-]'
     Abort one level back to the previous command level
     ('abort-recursive-edit').

'q'
     Return to the top level editor command loop ('top-level').  This
     exits all recursive editing levels, including all levels of Edebug
     activity.  However, instrumented code protected with
     'unwind-protect' or 'condition-case' forms may resume debugging.

'Q'
     Like 'q', but don't stop even for protected code
     ('edebug-top-level-nonstop').

'r'
     Redisplay the most recently known expression result in the echo
     area ('edebug-previous-result').

'd'
     Display a backtrace, excluding Edebug's own functions for clarity
     ('edebug-backtrace').

     *Note Backtraces::, for a description of backtraces and the
     commands which work on them.

     If you would like to see Edebug's functions in the backtrace, use
     'M-x edebug-backtrace-show-instrumentation'.  To hide them again
     use 'M-x edebug-backtrace-hide-instrumentation'.

     If a backtrace frame starts with '>' that means that Edebug knows
     where the source code for the frame is located.  Use 's' to jump to
     the source code for the current frame.

     The backtrace buffer is killed automatically when you continue
     execution.

   You can invoke commands from Edebug that activate Edebug again
recursively.  Whenever Edebug is active, you can quit to the top level
with 'q' or abort one recursive edit level with 'C-]'.  You can display
a backtrace of all the pending evaluations with 'd'.

==============================================================================
File: elisp.info,  Node: |Breaks|,  Next: |Trapping_Errors|,  Prev: |Edebug_Misc|,  Up: |Edebug|
==============================================================================

                                                                        *Breaks*

18.2.6 Breaks
-------------

Edebug's step mode stops execution when the next stop point is reached.
There are three other ways to stop Edebug execution once it has started:
breakpoints, the global break condition, and source breakpoints.

MENU

* |Breakpoints|::                 Breakpoints at stop points.
* |Global_Break_Condition|::      Breaking on an event.
* |Source_Breakpoints|::          Embedding breakpoints in source code.

==============================================================================
File: elisp.info,  Node: |Breakpoints|,  Next: |Global_Break_Condition|,  Up: |Breaks|
==============================================================================

                                                                   *Breakpoints*

18.2.6.1 Edebug Breakpoints
---------------------------

While using Edebug, you can specify "breakpoints" in the program you are
testing: these are places where execution should stop.  You can set a
breakpoint at any stop point, as defined in *note Using Edebug::.  For
setting and unsetting breakpoints, the stop point that is affected is
the first one at or after point in the source code buffer.  Here are the
Edebug commands for breakpoints:

'b'
     Set a breakpoint at the stop point at or after point
     ('edebug-set-breakpoint').  If you use a prefix argument, the
     breakpoint is temporary--it turns off the first time it stops the
     program.  An overlay with the 'edebug-enabled-breakpoint' or
     'edebug-disabled-breakpoint' faces is put at the breakpoint.

'u'
     Unset the breakpoint (if any) at the stop point at or after point
     ('edebug-unset-breakpoint').

'U'
     Unset any breakpoints in the current form
     ('edebug-unset-breakpoints').

'D'
     Toggle whether to disable the breakpoint near point
     ('edebug-toggle-disable-breakpoint').  This command is mostly
     useful if the breakpoint is conditional and it would take some work
     to recreate the condition.

'x CONDITION <RET>'
     Set a conditional breakpoint which stops the program only if
     evaluating CONDITION produces a non-'nil' value
     ('edebug-set-conditional-breakpoint').  With a prefix argument, the
     breakpoint is temporary.

'B'
     Move point to the next breakpoint in the current definition
     ('edebug-next-breakpoint').

   While in Edebug, you can set a breakpoint with 'b' and unset one with
'u'.  First move point to the Edebug stop point of your choice, then
type 'b' or 'u' to set or unset a breakpoint there.  Unsetting a
breakpoint where none has been set has no effect.

   Re-evaluating or reinstrumenting a definition removes all of its
previous breakpoints.

   A "conditional breakpoint" tests a condition each time the program
gets there.  Any errors that occur as a result of evaluating the
condition are ignored, as if the result were 'nil'.  To set a
conditional breakpoint, use 'x', and specify the condition expression in
the minibuffer.  Setting a conditional breakpoint at a stop point that
has a previously established conditional breakpoint puts the previous
condition expression in the minibuffer so you can edit it.

   You can make a conditional or unconditional breakpoint "temporary" by
using a prefix argument with the command to set the breakpoint.  When a
temporary breakpoint stops the program, it is automatically unset.

   Edebug always stops or pauses at a breakpoint, except when the Edebug
mode is Go-nonstop.  In that mode, it ignores breakpoints entirely.

   To find out where your breakpoints are, use the 'B' command, which
moves point to the next breakpoint following point, within the same
function, or to the first breakpoint if there are no following
breakpoints.  This command does not continue execution--it just moves
point in the buffer.

==============================================================================
File: elisp.info,  Node: |Global_Break_Condition|,  Next: |Source_Breakpoints|,  Prev: |Breakpoints|,  Up: |Breaks|
==============================================================================

                                                        *Global_Break_Condition*

18.2.6.2 Global Break Condition
-------------------------------

A "global break condition" stops execution when a specified condition is
satisfied, no matter where that may occur.  Edebug evaluates the global
break condition at every stop point; if it evaluates to a non-'nil'
value, then execution stops or pauses depending on the execution mode,
as if a breakpoint had been hit.  If evaluating the condition gets an
error, execution does not stop.

   The condition expression is stored in
'edebug-global-break-condition'.  You can specify a new expression using
the 'X' command from the source code buffer while Edebug is active, or
using 'C-x X X' from any buffer at any time, as long as Edebug is loaded
('edebug-set-global-break-condition').

   The global break condition is the simplest way to find where in your
code some event occurs, but it makes code run much more slowly.  So you
should reset the condition to 'nil' when not using it.

==============================================================================
File: elisp.info,  Node: |Source_Breakpoints|,  Prev: |Global_Break_Condition|,  Up: |Breaks|
==============================================================================

                                                            *Source_Breakpoints*

18.2.6.3 Source Breakpoints
---------------------------

All breakpoints in a definition are forgotten each time you reinstrument
it.  If you wish to make a breakpoint that won't be forgotten, you can
write a "source breakpoint", which is simply a call to the function
'edebug' in your source code.  You can, of course, make such a call
conditional.  For example, in the 'fac' function, you can insert the
first line as shown below, to stop when the argument reaches zero:

     (defun fac (n)
       (if (= n 0) (edebug))
       (if (< 0 n)
           (* n (fac (1- n)))
         1))

   When the 'fac' definition is instrumented and the function is called,
the call to 'edebug' acts as a breakpoint.  Depending on the execution
mode, Edebug stops or pauses there.

   If no instrumented code is being executed when 'edebug' is called,
that function calls 'debug'.

==============================================================================
File: elisp.info,  Node: |Trapping_Errors|,  Next: |Edebug_Views|,  Prev: |Breaks|,  Up: |Edebug|
==============================================================================

                                                               *Trapping_Errors*

18.2.7 Trapping Errors
----------------------

Emacs normally displays an error message when an error is signaled and
not handled with 'condition-case'.  While Edebug is active and executing
instrumented code, it normally responds to all unhandled errors.  You
can customize this with the options 'edebug-on-error' and
'edebug-on-quit'; see *note Edebug Options::.

   When Edebug responds to an error, it shows the last stop point
encountered before the error.  This may be the location of a call to a
function which was not instrumented, and within which the error actually
occurred.  For an unbound variable error, the last known stop point
might be quite distant from the offending variable reference.  In that
case, you might want to display a full backtrace (*note Edebug Misc::).

   If you change 'debug-on-error' or 'debug-on-quit' while Edebug is
active, these changes will be forgotten when Edebug becomes inactive.
Furthermore, during Edebug's recursive edit, these variables are bound
to the values they had outside of Edebug.

==============================================================================
File: elisp.info,  Node: |Edebug_Views|,  Next: |Edebug_Eval|,  Prev: |Trapping_Errors|,  Up: |Edebug|
==============================================================================

                                                                  *Edebug_Views*

18.2.8 Edebug Views
-------------------

These Edebug commands let you view aspects of the buffer and window
status as they were before entry to Edebug.  The outside window
configuration is the collection of windows and contents that were in
effect outside of Edebug.

'v'
     Switch to viewing the outside window configuration
     ('edebug-view-outside').  Type 'C-x X w' to return to Edebug.

'p'
     Temporarily display the outside current buffer with point at its
     outside position ('edebug-bounce-point'), pausing for one second
     before returning to Edebug.  With a prefix argument N, pause for N
     seconds instead.

'w'
     Move point back to the current stop point in the source code buffer
     ('edebug-where').

     If you use this command in a different window displaying the same
     buffer, that window will be used instead to display the current
     definition in the future.

'W'
     Toggle whether Edebug saves and restores the outside window
     configuration ('edebug-toggle-save-windows').

     With a prefix argument, 'W' only toggles saving and restoring of
     the selected window.  To specify a window that is not displaying
     the source code buffer, you must use 'C-x X W' from the global
     keymap.

   You can view the outside window configuration with 'v' or just bounce
to the point in the current buffer with 'p', even if it is not normally
displayed.

   After moving point, you may wish to jump back to the stop point.  You
can do that with 'w' from a source code buffer.  You can jump back to
the stop point in the source code buffer from any buffer using 'C-x X
w'.

   Each time you use 'W' to turn saving _off_, Edebug forgets the saved
outside window configuration--so that even if you turn saving back _on_,
the current window configuration remains unchanged when you next exit
Edebug (by continuing the program).  However, the automatic redisplay of
'edebug' and '*edebug-trace*' may conflict with the buffers you wish
to see unless you have enough windows open.

==============================================================================
File: elisp.info,  Node: |Edebug_Eval|,  Next: |Eval_List|,  Prev: |Edebug_Views|,  Up: |Edebug|
==============================================================================

                                                                   *Edebug_Eval*

18.2.9 Evaluation
-----------------

While within Edebug, you can evaluate expressions as if Edebug were not
running.  Edebug tries to be invisible to the expression's evaluation
and printing.  Evaluation of expressions that cause side effects will
work as expected, except for changes to data that Edebug explicitly
saves and restores.  *Note The Outside Context::, for details on this
process.

'e EXP <RET>'
     Evaluate expression EXP in the context outside of Edebug
     ('edebug-eval-expression').  That is, Edebug tries to minimize its
     interference with the evaluation.

'M-: EXP <RET>'
     Evaluate expression EXP in the context of Edebug itself
     ('eval-expression').

'C-x C-e'
     Evaluate the expression before point, in the context outside of
     Edebug ('edebug-eval-last-sexp').  With the prefix argument of zero
     ('C-u 0 C-x C-e'), don't shorten long items (like strings and
     lists).

   Edebug supports evaluation of expressions containing references to
lexically bound symbols created by the following constructs in 'cl.el':
'lexical-let', 'macrolet', and 'symbol-macrolet'.

==============================================================================
File: elisp.info,  Node: |Eval_List|,  Next: |Printing_in_Edebug|,  Prev: |Edebug_Eval|,  Up: |Edebug|
==============================================================================

                                                                     *Eval_List*

18.2.10 Evaluation List Buffer
------------------------------

You can use the "evaluation list buffer", called 'edebug', to evaluate
expressions interactively.  You can also set up the "evaluation list" of
expressions to be evaluated automatically each time Edebug updates the
display.

'E'
     Switch to the evaluation list buffer 'edebug'
     ('edebug-visit-eval-list').

   In the 'edebug' buffer you can use the commands of Lisp Interaction
mode (*note (emacs)Lisp Interaction::) as well as these special
commands:

'C-j'
     Evaluate the expression before point, in the outside context, and
     insert the value in the buffer ('edebug-eval-print-last-sexp').
     With prefix argument of zero ('C-u 0 C-j'), don't shorten long
     items (like strings and lists).

'C-x C-e'
     Evaluate the expression before point, in the context outside of
     Edebug ('edebug-eval-last-sexp').

'C-c C-u'
     Build a new evaluation list from the contents of the buffer
     ('edebug-update-eval-list').

'C-c C-d'
     Delete the evaluation list group that point is in
     ('edebug-delete-eval-item').

'C-c C-w'
     Switch back to the source code buffer at the current stop point
     ('edebug-where').

   You can evaluate expressions in the evaluation list window with 'C-j'
or 'C-x C-e', just as you would in 'scratch'; but they are evaluated
in the context outside of Edebug.

   The expressions you enter interactively (and their results) are lost
when you continue execution; but you can set up an "evaluation list"
consisting of expressions to be evaluated each time execution stops.

   To do this, write one or more "evaluation list groups" in the
evaluation list buffer.  An evaluation list group consists of one or
more Lisp expressions.  Groups are separated by comment lines.

   The command 'C-c C-u' ('edebug-update-eval-list') rebuilds the
evaluation list, scanning the buffer and using the first expression of
each group.  (The idea is that the second expression of the group is the
value previously computed and displayed.)

   Each entry to Edebug redisplays the evaluation list by inserting each
expression in the buffer, followed by its current value.  It also
inserts comment lines so that each expression becomes its own group.
Thus, if you type 'C-c C-u' again without changing the buffer text, the
evaluation list is effectively unchanged.

   If an error occurs during an evaluation from the evaluation list, the
error message is displayed in a string as if it were the result.
Therefore, expressions using variables that are not currently valid do
not interrupt your debugging.

   Here is an example of what the evaluation list window looks like
after several expressions have been added to it:

     (current-buffer)
     #<buffer scratch>
     ;---------------------------------------------------------------
     (selected-window)
     #<window 16 on scratch>
     ;---------------------------------------------------------------
     (point)
     196
     ;---------------------------------------------------------------
     bad-var
     "Symbol's value as variable is void: bad-var"
     ;---------------------------------------------------------------
     (recursion-depth)
     0
     ;---------------------------------------------------------------
     this-command
     eval-last-sexp
     ;---------------------------------------------------------------

   To delete a group, move point into it and type 'C-c C-d', or simply
delete the text for the group and update the evaluation list with 'C-c
C-u'.  To add a new expression to the evaluation list, insert the
expression at a suitable place, insert a new comment line, then type
'C-c C-u'.  You need not insert dashes in the comment line--its contents
don't matter.

   After selecting 'edebug', you can return to the source code buffer
with 'C-c C-w'.  The 'edebug' buffer is killed when you continue
execution, and recreated next time it is needed.

==============================================================================
File: elisp.info,  Node: |Printing_in_Edebug|,  Next: |Trace_Buffer|,  Prev: |Eval_List|,  Up: |Edebug|
==============================================================================

                                                            *Printing_in_Edebug*

18.2.11 Printing in Edebug
--------------------------

If an expression in your program produces a value containing circular
list structure, you may get an error when Edebug attempts to print it.

   One way to cope with circular structure is to set 'print-length' or
'print-level' to truncate the printing.  Edebug does this for you; it
binds 'print-length' and 'print-level' to the values of the variables
'edebug-print-length' and 'edebug-print-level' (so long as they have
non-'nil' values).  *Note Output Variables::.

 -- User Option: edebug-print-length
     If non-'nil', Edebug binds 'print-length' to this value while
     printing results.  The default value is '50'.

 -- User Option: edebug-print-level
     If non-'nil', Edebug binds 'print-level' to this value while
     printing results.  The default value is '50'.

   You can also print circular structures and structures that share
elements more informatively by binding 'print-circle' to a non-'nil'
value.

   Here is an example of code that creates a circular structure:

     (setq a (list 'x 'y))
     (setcar a a)

Custom printing prints this as 'Result: #1=(#1# y)'.  The '#1=' notation
labels the structure that follows it with the label '1', and the '#1#'
notation references the previously labeled structure.  This notation is
used for any shared elements of lists or vectors.

 -- User Option: edebug-print-circle
     If non-'nil', Edebug binds 'print-circle' to this value while
     printing results.  The default value is 't'.

   Other programs can also use custom printing; see 'cust-print.el' for
details.

==============================================================================
File: elisp.info,  Node: |Trace_Buffer|,  Next: |Coverage_Testing|,  Prev: |Printing_in_Edebug|,  Up: |Edebug|
==============================================================================

                                                                  *Trace_Buffer*

18.2.12 Trace Buffer
--------------------

Edebug can record an execution trace, storing it in a buffer named
'edebug-trace'.  This is a log of function calls and returns, showing
the function names and their arguments and values.  To enable trace
recording, set 'edebug-trace' to a non-'nil' value.

   Making a trace buffer is not the same thing as using trace execution
mode (*note Edebug Execution Modes::).

   When trace recording is enabled, each function entry and exit adds
lines to the trace buffer.  A function entry record consists of '::::{',
followed by the function name and argument values.  A function exit
record consists of '::::}', followed by the function name and result of
the function.

   The number of ':'s in an entry shows its recursion depth.  You can
use the braces in the trace buffer to find the matching beginning or end
of function calls.

   You can customize trace recording for function entry and exit by
redefining the functions 'edebug-print-trace-before' and
'edebug-print-trace-after'.

 -- Macro: edebug-tracing string body...
     This macro requests additional trace information around the
     execution of the BODY forms.  The argument STRING specifies text to
     put in the trace buffer, after the '{' or '}'.  All the arguments
     are evaluated, and 'edebug-tracing' returns the value of the last
     form in BODY.

 -- Function: edebug-trace format-string &rest format-args
     This function inserts text in the trace buffer.  It computes the
     text with '(apply 'format FORMAT-STRING FORMAT-ARGS)'.  It also
     appends a newline to separate entries.

   'edebug-tracing' and 'edebug-trace' insert lines in the trace buffer
whenever they are called, even if Edebug is not active.  Adding text to
the trace buffer also scrolls its window to show the last lines
inserted.

==============================================================================
File: elisp.info,  Node: |Coverage_Testing|,  Next: |The_Outside_Context|,  Prev: |Trace_Buffer|,  Up: |Edebug|
==============================================================================

                                                              *Coverage_Testing*

18.2.13 Coverage Testing
------------------------

Edebug provides rudimentary coverage testing and display of execution
frequency.

   Coverage testing works by comparing the result of each expression
with the previous result; each form in the program is considered covered
if it has returned two different values since you began testing coverage
in the current Emacs session.  Thus, to do coverage testing on your
program, execute it under various conditions and note whether it behaves
correctly; Edebug will tell you when you have tried enough different
conditions that each form has returned two different values.

   Coverage testing makes execution slower, so it is only done if
'edebug-test-coverage' is non-'nil'.  Frequency counting is performed
for all executions of an instrumented function, even if the execution
mode is Go-nonstop, and regardless of whether coverage testing is
enabled.

   Use 'C-x X =' ('edebug-display-freq-count') to display both the
coverage information and the frequency counts for a definition.  Just
'=' ('edebug-temp-display-freq-count') displays the same information
temporarily, only until you type another key.

 -- Command: edebug-display-freq-count
     This command displays the frequency count data for each line of the
     current definition.

     It inserts frequency counts as comment lines after each line of
     code.  You can undo all insertions with one 'undo' command.  The
     counts appear under the '(' before an expression or the ')' after
     an expression, or on the last character of a variable.  To simplify
     the display, a count is not shown if it is equal to the count of an
     earlier expression on the same line.

     The character '=' following the count for an expression says that
     the expression has returned the same value each time it was
     evaluated.  In other words, it is not yet covered for coverage
     testing purposes.

     To clear the frequency count and coverage data for a definition,
     simply reinstrument it with 'eval-defun'.

   For example, after evaluating '(fac 5)' with a source breakpoint, and
setting 'edebug-test-coverage' to 't', when the breakpoint is reached,
the frequency data looks like this:

     (defun fac (n)
       (if (= n 0) (edebug))
     ;#6           1      = =5
       (if (< 0 n)
     ;#5         =
           (* n (fac (1- n)))
     ;#    5               0
         1))
     ;#   0

   The comment lines show that 'fac' was called 6 times.  The first 'if'
statement returned 5 times with the same result each time; the same is
true of the condition on the second 'if'.  The recursive call of 'fac'
did not return at all.

==============================================================================
File: elisp.info,  Node: |The_Outside_Context|,  Next: |Edebug_and_Macros|,  Prev: |Coverage_Testing|,  Up: |Edebug|
==============================================================================

                                                           *The_Outside_Context*

18.2.14 The Outside Context
---------------------------

Edebug tries to be transparent to the program you are debugging, but it
does not succeed completely.  Edebug also tries to be transparent when
you evaluate expressions with 'e' or with the evaluation list buffer, by
temporarily restoring the outside context.  This section explains
precisely what context Edebug restores, and how Edebug fails to be
completely transparent.

MENU

* |Checking_Whether_to_Stop|::    When Edebug decides what to do.
* |Edebug_Display_Update|::       When Edebug updates the display.
* |Edebug_Recursive_Edit|::       When Edebug stops execution.

==============================================================================
File: elisp.info,  Node: |Checking_Whether_to_Stop|,  Next: |Edebug_Display_Update|,  Up: |The_Outside_Context|
==============================================================================

                                                      *Checking_Whether_to_Stop*

18.2.14.1 Checking Whether to Stop
----------------------------------

Whenever Edebug is entered, it needs to save and restore certain data
before even deciding whether to make trace information or stop the
program.

   * 'max-lisp-eval-depth' (*note Eval::) and 'max-specpdl-size' (*note
     Local Variables::) are both increased to reduce Edebug's impact on
     the stack.  You could, however, still run out of stack space when
     using Edebug.  You can also enlarge the value of 'edebug-max-depth'
     if Edebug reaches the limit of recursion depth instrumenting code
     that contains very large quoted lists.

   * The state of keyboard macro execution is saved and restored.  While
     Edebug is active, 'executing-kbd-macro' is bound to 'nil' unless
     'edebug-continue-kbd-macro' is non-'nil'.

==============================================================================
File: elisp.info,  Node: |Edebug_Display_Update|,  Next: |Edebug_Recursive_Edit|,  Prev: |Checking_Whether_to_Stop|,  Up: |The_Outside_Context|
==============================================================================

                                                         *Edebug_Display_Update*

18.2.14.2 Edebug Display Update
-------------------------------

When Edebug needs to display something (e.g., in trace mode), it saves
the current window configuration from outside Edebug (*note Window
Configurations::).  When you exit Edebug, it restores the previous
window configuration.

   Emacs redisplays only when it pauses.  Usually, when you continue
execution, the program re-enters Edebug at a breakpoint or after
stepping, without pausing or reading input in between.  In such cases,
Emacs never gets a chance to redisplay the outside configuration.
Consequently, what you see is the same window configuration as the last
time Edebug was active, with no interruption.

   Entry to Edebug for displaying something also saves and restores the
following data (though some of them are deliberately not restored if an
error or quit signal occurs).

   * Which buffer is current, and the positions of point and the mark in
     the current buffer, are saved and restored.

   * The outside window configuration is saved and restored if
     'edebug-save-windows' is non-'nil' (*note Edebug Options::).

     The window configuration is not restored on error or quit, but the
     outside selected window _is_ reselected even on error or quit in
     case a 'save-excursion' is active.  If the value of
     'edebug-save-windows' is a list, only the listed windows are saved
     and restored.

     The window start and horizontal scrolling of the source code buffer
     are not restored, however, so that the display remains coherent
     within Edebug.

   * The value of point in each displayed buffer is saved and restored
     if 'edebug-save-displayed-buffer-points' is non-'nil'.

   * The variables 'overlay-arrow-position' and 'overlay-arrow-string'
     are saved and restored, so you can safely invoke Edebug from the
     recursive edit elsewhere in the same buffer.

   * 'cursor-in-echo-area' is locally bound to 'nil' so that the cursor
     shows up in the window.

==============================================================================
File: elisp.info,  Node: |Edebug_Recursive_Edit|,  Prev: |Edebug_Display_Update|,  Up: |The_Outside_Context|
==============================================================================

                                                         *Edebug_Recursive_Edit*

18.2.14.3 Edebug Recursive Edit
-------------------------------

When Edebug is entered and actually reads commands from the user, it
saves (and later restores) these additional data:

   * The current match data.  *Note Match Data::.

   * The variables 'last-command', 'this-command', 'last-command-event',
     'last-input-event', 'last-event-frame', 'last-nonmenu-event', and
     'track-mouse'.  Commands in Edebug do not affect these variables
     outside of Edebug.

     Executing commands within Edebug can change the key sequence that
     would be returned by 'this-command-keys', and there is no way to
     reset the key sequence from Lisp.

     Edebug cannot save and restore the value of
     'unread-command-events'.  Entering Edebug while this variable has a
     nontrivial value can interfere with execution of the program you
     are debugging.

   * Complex commands executed while in Edebug are added to the variable
     'command-history'.  In rare cases this can alter execution.

   * Within Edebug, the recursion depth appears one deeper than the
     recursion depth outside Edebug.  This is not true of the
     automatically updated evaluation list window.

   * 'standard-output' and 'standard-input' are bound to 'nil' by the
     'recursive-edit', but Edebug temporarily restores them during
     evaluations.

   * The state of keyboard macro definition is saved and restored.
     While Edebug is active, 'defining-kbd-macro' is bound to
     'edebug-continue-kbd-macro'.

==============================================================================
File: elisp.info,  Node: |Edebug_and_Macros|,  Next: |Edebug_Options|,  Prev: |The_Outside_Context|,  Up: |Edebug|
==============================================================================

                                                             *Edebug_and_Macros*

18.2.15 Edebug and Macros
-------------------------

To make Edebug properly instrument expressions that call macros, some
extra care is needed.  This subsection explains the details.

MENU

* |Instrumenting_Macro_Calls|::   The basic problem.
* |Specification_List|::          How to specify complex patterns of evaluation.
* |Backtracking|::                What Edebug does when matching fails.
* |Specification_Examples|::      To help understand specifications.

==============================================================================
File: elisp.info,  Node: |Instrumenting_Macro_Calls|,  Next: |Specification_List|,  Up: |Edebug_and_Macros|
==============================================================================

                                                     *Instrumenting_Macro_Calls*

18.2.15.1 Instrumenting Macro Calls
-----------------------------------

When Edebug instruments an expression that calls a Lisp macro, it needs
additional information about the macro to do the job properly.  This is
because there is no a-priori way to tell which subexpressions of the
macro call are forms to be evaluated.  (Evaluation may occur explicitly
in the macro body, or when the resulting expansion is evaluated, or any
time later.)

   Therefore, you must define an Edebug specification for each macro
that Edebug will encounter, to explain the format of calls to that
macro.  To do this, add a 'debug' declaration to the macro definition.
Here is a simple example that shows the specification for the 'for'
example macro (*note Argument Evaluation::).

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       (declare (debug (symbolp "from" form "to" form "do" &rest form)))
       ...)

   The Edebug specification says which parts of a call to the macro are
forms to be evaluated.  For simple macros, the specification often looks
very similar to the formal argument list of the macro definition, but
specifications are much more general than macro arguments.  *Note
Defining Macros::, for more explanation of the 'declare' form.

   Take care to ensure that the specifications are known to Edebug when
you instrument code.  If you are instrumenting a function which uses a
macro defined in another file, you may first need to either evaluate the
'require' forms in the file containing your function, or explicitly load
the file containing the macro.  If the definition of a macro is wrapped
by 'eval-when-compile', you may need to evaluate it.

   You can also define an edebug specification for a macro separately
from the macro definition with 'def-edebug-spec'.  Adding 'debug'
declarations is preferred, and more convenient, for macro definitions in
Lisp, but 'def-edebug-spec' makes it possible to define Edebug
specifications for special forms implemented in C.

 -- Macro: def-edebug-spec macro specification
     Specify which expressions of a call to macro MACRO are forms to be
     evaluated.  SPECIFICATION should be the edebug specification.
     Neither argument is evaluated.

     The MACRO argument can actually be any symbol, not just a macro
     name.

   Here is a table of the possibilities for SPECIFICATION and how each
directs processing of arguments.

't'
     All arguments are instrumented for evaluation.

'0'
     None of the arguments is instrumented.

a symbol
     The symbol must have an Edebug specification, which is used
     instead.  This indirection is repeated until another kind of
     specification is found.  This allows you to inherit the
     specification from another macro.

a list
     The elements of the list describe the types of the arguments of a
     calling form.  The possible elements of a specification list are
     described in the following sections.

   If a macro has no Edebug specification, neither through a 'debug'
declaration nor through a 'def-edebug-spec' call, the variable
'edebug-eval-macro-args' comes into play.

 -- User Option: edebug-eval-macro-args
     This controls the way Edebug treats macro arguments with no
     explicit Edebug specification.  If it is 'nil' (the default), none
     of the arguments is instrumented for evaluation.  Otherwise, all
     arguments are instrumented.

==============================================================================
File: elisp.info,  Node: |Specification_List|,  Next: |Backtracking|,  Prev: |Instrumenting_Macro_Calls|,  Up: |Edebug_and_Macros|
==============================================================================

                                                            *Specification_List*

18.2.15.2 Specification List
----------------------------

A "specification list" is required for an Edebug specification if some
arguments of a macro call are evaluated while others are not.  Some
elements in a specification list match one or more arguments, but others
modify the processing of all following elements.  The latter, called
"specification keywords", are symbols beginning with '&' (such as
'&optional').

   A specification list may contain sublists, which match arguments that
are themselves lists, or it may contain vectors used for grouping.
Sublists and groups thus subdivide the specification list into a
hierarchy of levels.  Specification keywords apply only to the remainder
of the sublist or group they are contained in.

   When a specification list involves alternatives or repetition,
matching it against an actual macro call may require backtracking.  For
more details, *note Backtracking::.

   Edebug specifications provide the power of regular expression
matching, plus some context-free grammar constructs: the matching of
sublists with balanced parentheses, recursive processing of forms, and
recursion via indirect specifications.

   Here's a table of the possible elements of a specification list, with
their meanings (see *note Specification Examples::, for the referenced
examples):

'sexp'
     A single unevaluated Lisp object, which is not instrumented.

'form'
     A single evaluated expression, which is instrumented.  If your
     macro wraps the expression with 'lambda' before it is evaluated,
     use 'def-form' instead.  See 'def-form' below.

'place'
     A generalized variable.  *Note Generalized Variables::.

'body'
     Short for '&rest form'.  See '&rest' below.  If your macro wraps
     its body of code with 'lambda' before it is evaluated, use
     'def-body' instead.  See 'def-body' below.

'function-form'
     A function form: either a quoted function symbol, a quoted lambda
     expression, or a form (that should evaluate to a function symbol or
     lambda expression).  This is useful when an argument that's a
     lambda expression might be quoted with 'quote' rather than
     'function', since it instruments the body of the lambda expression
     either way.

'lambda-expr'
     A lambda expression with no quoting.

'&optional'
     All following elements in the specification list are optional; as
     soon as one does not match, Edebug stops matching at this level.

     To make just a few elements optional, followed by non-optional
     elements, use '[&optional SPECS...]'.  To specify that several
     elements must all match or none, use '&optional [SPECS...]'.  See
     the 'defun' example.

'&rest'
     All following elements in the specification list are repeated zero
     or more times.  In the last repetition, however, it is not a
     problem if the expression runs out before matching all of the
     elements of the specification list.

     To repeat only a few elements, use '[&rest SPECS...]'.  To specify
     several elements that must all match on every repetition, use
     '&rest [SPECS...]'.

'&or'
     Each of the following elements in the specification list is an
     alternative.  One of the alternatives must match, or the '&or'
     specification fails.

     Each list element following '&or' is a single alternative.  To
     group two or more list elements as a single alternative, enclose
     them in '[...]'.

'&not'
     Each of the following elements is matched as alternatives as if by
     using '&or', but if any of them match, the specification fails.  If
     none of them match, nothing is matched, but the '&not'
     specification succeeds.

'&define'
     Indicates that the specification is for a defining form.  Edebug's
     definition of a defining form is a form containing one or more code
     forms which are saved and executed later, after the execution of
     the defining form.

     The defining form itself is not instrumented (that is, Edebug does
     not stop before and after the defining form), but forms inside it
     typically will be instrumented.  The '&define' keyword should be
     the first element in a list specification.

'nil'
     This is successful when there are no more arguments to match at the
     current argument list level; otherwise it fails.  See sublist
     specifications and the backquote example.

'gate'
     No argument is matched but backtracking through the gate is
     disabled while matching the remainder of the specifications at this
     level.  This is primarily used to generate more specific syntax
     error messages.  See *note Backtracking::, for more details.  Also
     see the 'let' example.

'OTHER-SYMBOL'
     Any other symbol in a specification list may be a predicate or an
     indirect specification.

     If the symbol has an Edebug specification, this "indirect
     specification" should be either a list specification that is used
     in place of the symbol, or a function that is called to process the
     arguments.  The specification may be defined with 'def-edebug-spec'
     just as for macros.  See the 'defun' example.

     Otherwise, the symbol should be a predicate.  The predicate is
     called with the argument, and if the predicate returns 'nil', the
     specification fails and the argument is not instrumented.

     Some suitable predicates include 'symbolp', 'integerp', 'stringp',
     'vectorp', and 'atom'.

'[ELEMENTS...]'
     A vector of elements groups the elements into a single "group
     specification".  Its meaning has nothing to do with vectors.

'"STRING"'
     The argument should be a symbol named STRING.  This specification
     is equivalent to the quoted symbol, ''SYMBOL', where the name of
     SYMBOL is the STRING, but the string form is preferred.

'(vector ELEMENTS...)'
     The argument should be a vector whose elements must match the
     ELEMENTS in the specification.  See the backquote example.

'(ELEMENTS...)'
     Any other list is a "sublist specification" and the argument must
     be a list whose elements match the specification ELEMENTS.

     A sublist specification may be a dotted list and the corresponding
     list argument may then be a dotted list.  Alternatively, the last
     CDR of a dotted list specification may be another sublist
     specification (via a grouping or an indirect specification, e.g.,
     '(spec . [(more specs...)])') whose elements match the non-dotted
     list arguments.  This is useful in recursive specifications such as
     in the backquote example.  Also see the description of a 'nil'
     specification above for terminating such recursion.

     Note that a sublist specification written as '(specs . nil)' is
     equivalent to '(specs)', and '(specs . (sublist-elements...))' is
     equivalent to '(specs sublist-elements...)'.

   Here is a list of additional specifications that may appear only
after '&define'.  See the 'defun' example.

'name'
     The argument, a symbol, is the name of the defining form.

     A defining form is not required to have a name field; and it may
     have multiple name fields.

':name'
     This construct does not actually match an argument.  The element
     following ':name' should be a symbol; it is used as an additional
     name component for the definition.  You can use this to add a
     unique, static component to the name of the definition.  It may be
     used more than once.

'arg'
     The argument, a symbol, is the name of an argument of the defining
     form.  However, lambda-list keywords (symbols starting with '&')
     are not allowed.

'lambda-list'
     This matches a lambda list--the argument list of a lambda
     expression.

'def-body'
     The argument is the body of code in a definition.  This is like
     'body', described above, but a definition body must be instrumented
     with a different Edebug call that looks up information associated
     with the definition.  Use 'def-body' for the highest level list of
     forms within the definition.

'def-form'
     The argument is a single, highest-level form in a definition.  This
     is like 'def-body', except it is used to match a single form rather
     than a list of forms.  As a special case, 'def-form' also means
     that tracing information is not output when the form is executed.
     See the 'interactive' example.

==============================================================================
File: elisp.info,  Node: |Backtracking|,  Next: |Specification_Examples|,  Prev: |Specification_List|,  Up: |Edebug_and_Macros|
==============================================================================

                                                                  *Backtracking*

18.2.15.3 Backtracking in Specifications
----------------------------------------

If a specification fails to match at some point, this does not
necessarily mean a syntax error will be signaled; instead,
"backtracking" will take place until all alternatives have been
exhausted.  Eventually every element of the argument list must be
matched by some element in the specification, and every required element
in the specification must match some argument.

   When a syntax error is detected, it might not be reported until much
later, after higher-level alternatives have been exhausted, and with the
point positioned further from the real error.  But if backtracking is
disabled when an error occurs, it can be reported immediately.  Note
that backtracking is also reenabled automatically in several situations;
when a new alternative is established by '&optional', '&rest', or '&or',
or at the start of processing a sublist, group, or indirect
specification.  The effect of enabling or disabling backtracking is
limited to the remainder of the level currently being processed and
lower levels.

   Backtracking is disabled while matching any of the form
specifications (that is, 'form', 'body', 'def-form', and 'def-body').
These specifications will match any form so any error must be in the
form itself rather than at a higher level.

   Backtracking is also disabled after successfully matching a quoted
symbol or string specification, since this usually indicates a
recognized construct.  But if you have a set of alternative constructs
that all begin with the same symbol, you can usually work around this
constraint by factoring the symbol out of the alternatives, e.g.,
'["foo" &or [first case] [second case] ...]'.

   Most needs are satisfied by these two ways that backtracking is
automatically disabled, but occasionally it is useful to explicitly
disable backtracking by using the 'gate' specification.  This is useful
when you know that no higher alternatives could apply.  See the example
of the 'let' specification.

==============================================================================
File: elisp.info,  Node: |Specification_Examples|,  Prev: |Backtracking|,  Up: |Edebug_and_Macros|
==============================================================================

                                                        *Specification_Examples*

18.2.15.4 Specification Examples
--------------------------------

It may be easier to understand Edebug specifications by studying the
examples provided here.

   A 'let' special form has a sequence of bindings and a body.  Each of
the bindings is either a symbol or a sublist with a symbol and optional
expression.  In the specification below, notice the 'gate' inside of the
sublist to prevent backtracking once a sublist is found.

     (def-edebug-spec let
       ((&rest
         &or symbolp (gate symbolp &optional form))
        body))

   Edebug uses the following specifications for 'defun' and the
associated argument list and 'interactive' specifications.  It is
necessary to handle interactive forms specially since an expression
argument is actually evaluated outside of the function body.  (The
specification for 'defmacro' is very similar to that for 'defun', but
allows for the 'declare' statement.)

     (def-edebug-spec defun
       (&define name lambda-list
                [&optional stringp]   ; Match the doc string, if present.
                [&optional ("interactive" interactive)]
                def-body))

     (def-edebug-spec lambda-list
       (([&rest arg]
         [&optional ["&optional" arg &rest arg]]
         &optional ["&rest" arg]
         )))

     (def-edebug-spec interactive
       (&optional &or stringp def-form))    ; Notice: 'def-form'

   The specification for backquote below illustrates how to match dotted
lists and use 'nil' to terminate recursion.  It also illustrates how
components of a vector may be matched.  (The actual specification
defined by Edebug is a little different, and does not support dotted
lists because doing so causes very deep recursion that could fail.)

     (def-edebug-spec \` (backquote-form))   ; Alias just for clarity.

     (def-edebug-spec backquote-form
       (&or ([&or "," ",@"] &or ("quote" backquote-form) form)
            (backquote-form . [&or nil backquote-form])
            (vector &rest backquote-form)
            sexp))

==============================================================================
File: elisp.info,  Node: |Edebug_Options|,  Prev: Edebug and Macros,  Up: |Edebug|
==============================================================================

                                                                *Edebug_Options*

18.2.16 Edebug Options
----------------------

These options affect the behavior of Edebug:

 -- User Option: edebug-setup-hook
     Functions to call before Edebug is used.  Each time it is set to a
     new value, Edebug will call those functions once and then reset
     'edebug-setup-hook' to 'nil'.  You could use this to load up Edebug
     specifications associated with a package you are using, but only
     when you also use Edebug.  *Note Instrumenting::.

 -- User Option: edebug-all-defs
     If this is non-'nil', normal evaluation of defining forms such as
     'defun' and 'defmacro' instruments them for Edebug.  This applies
     to 'eval-defun', 'eval-region', 'eval-buffer', and
     'eval-current-buffer'.

     Use the command 'M-x edebug-all-defs' to toggle the value of this
     option.  *Note Instrumenting::.

 -- User Option: edebug-all-forms
     If this is non-'nil', the commands 'eval-defun', 'eval-region',
     'eval-buffer', and 'eval-current-buffer' instrument all forms, even
     those that don't define anything.  This doesn't apply to loading or
     evaluations in the minibuffer.

     Use the command 'M-x edebug-all-forms' to toggle the value of this
     option.  *Note Instrumenting::.

 -- User Option: edebug-eval-macro-args
     When this is non-'nil', all macro arguments will be instrumented in
     the generated code.  For any macro, an 'edebug-form-spec' overrides
     this option.  So to specify exceptions for macros that have some
     arguments evaluated and some not, use 'def-edebug-spec' to specify
     an 'edebug-form-spec'.

 -- User Option: edebug-save-windows
     If this is non-'nil', Edebug saves and restores the window
     configuration.  That takes some time, so if your program does not
     care what happens to the window configurations, it is better to set
     this variable to 'nil'.

     If the value is a list, only the listed windows are saved and
     restored.

     You can use the 'W' command in Edebug to change this variable
     interactively.  *Note Edebug Display Update::.

 -- User Option: edebug-save-displayed-buffer-points
     If this is non-'nil', Edebug saves and restores point in all
     displayed buffers.

     Saving and restoring point in other buffers is necessary if you are
     debugging code that changes the point of a buffer that is displayed
     in a non-selected window.  If Edebug or the user then selects the
     window, point in that buffer will move to the window's value of
     point.

     Saving and restoring point in all buffers is expensive, since it
     requires selecting each window twice, so enable this only if you
     need it.  *Note Edebug Display Update::.

 -- User Option: edebug-initial-mode
     If this variable is non-'nil', it specifies the initial execution
     mode for Edebug when it is first activated.  Possible values are
     'step', 'next', 'go', 'Go-nonstop', 'trace', 'Trace-fast',
     'continue', and 'Continue-fast'.

     The default value is 'step'.  This variable can be set
     interactively with 'C-x C-a C-m' ('edebug-set-initial-mode').
     *Note Edebug Execution Modes::.

 -- User Option: edebug-trace
     If this is non-'nil', trace each function entry and exit.  Tracing
     output is displayed in a buffer named 'edebug-trace', one
     function entry or exit per line, indented by the recursion level.

     Also see 'edebug-tracing', in *note Trace Buffer::.

 -- User Option: edebug-test-coverage
     If non-'nil', Edebug tests coverage of all expressions debugged.
     *Note Coverage Testing::.

 -- User Option: edebug-continue-kbd-macro
     If non-'nil', continue defining or executing any keyboard macro
     that is executing outside of Edebug.  Use this with caution since
     it is not debugged.  *Note Edebug Execution Modes::.

 -- User Option: edebug-print-length
     If non-'nil', the default value of 'print-length' for printing
     results in Edebug.  *Note Output Variables::.

 -- User Option: edebug-print-level
     If non-'nil', the default value of 'print-level' for printing
     results in Edebug.  *Note Output Variables::.

 -- User Option: edebug-print-circle
     If non-'nil', the default value of 'print-circle' for printing
     results in Edebug.  *Note Output Variables::.

 -- User Option: edebug-unwrap-results
     If non-'nil', Edebug tries to remove any of its own instrumentation
     when showing the results of expressions.  This is relevant when
     debugging macros where the results of expressions are themselves
     instrumented expressions.  As a very artificial example, suppose
     that the example function 'fac' has been instrumented, and consider
     a macro of the form:

          (defmacro test () "Edebug example."
            (if (symbol-function 'fac)
                ...))

     If you instrument the 'test' macro and step through it, then by
     default the result of the 'symbol-function' call has numerous
     'edebug-after' and 'edebug-before' forms, which can make it
     difficult to see the actual result.  If 'edebug-unwrap-results' is
     non-'nil', Edebug tries to remove these forms from the result.

 -- User Option: edebug-on-error
     Edebug binds 'debug-on-error' to this value, if 'debug-on-error'
     was previously 'nil'.  *Note Trapping Errors::.

 -- User Option: edebug-on-quit
     Edebug binds 'debug-on-quit' to this value, if 'debug-on-quit' was
     previously 'nil'.  *Note Trapping Errors::.

   If you change the values of 'edebug-on-error' or 'edebug-on-quit'
while Edebug is active, their values won't be used until the _next_ time
Edebug is invoked via a new command.

 -- User Option: edebug-global-break-condition
     If non-'nil', an expression to test for at every stop point.  If
     the result is non-'nil', then break.  Errors are ignored.  *Note
     Global Break Condition::.

 -- User Option: edebug-sit-for-seconds
     Number of seconds to pause when a breakpoint is reached and the
     execution mode is trace or continue.  *Note Edebug Execution
     Modes::.

 -- User Option: edebug-sit-on-break
     Whether or not to pause for 'edebug-sit-for-seconds' on reaching a
     breakpoint.  Set to 'nil' to prevent the pause, non-'nil' to allow
     it.

 -- User Option: edebug-behavior-alist
     By default, this alist contains one entry with the key 'edebug' and
     a list of three functions, which are the default implementations of
     the functions inserted in instrumented code: 'edebug-enter',
     'edebug-before' and 'edebug-after'.  To change Edebug's behavior
     globally, modify the default entry.

     Edebug's behavior may also be changed on a per-definition basis by
     adding an entry to this alist, with a key of your choice and three
     functions.  Then set the 'edebug-behavior' symbol property of an
     instrumented definition to the key of the new entry, and Edebug
     will call the new functions in place of its own for that
     definition.

 -- User Option: edebug-new-definition-function
     A function run by Edebug after it wraps the body of a definition or
     closure.  After Edebug has initialized its own data, this function
     is called with one argument, the symbol associated with the
     definition, which may be the actual symbol defined or one generated
     by Edebug.  This function may be used to set the 'edebug-behavior'
     symbol property of each definition instrumented by Edebug.

 -- User Option: edebug-after-instrumentation-function
     To inspect or modify Edebug's instrumentation before it is used,
     set this variable to a function which takes one argument, an
     instrumented top-level form, and returns either the same or a
     replacement form, which Edebug will then use as the final result of
     instrumentation.

==============================================================================
File: elisp.info,  Node: |Syntax_Errors|,  Next: |Test_Coverage|,  Prev: |Edebug|,  Up: |Debugging|
==============================================================================

                                                                 *Syntax_Errors*

18.3 Debugging Invalid Lisp Syntax
----------------------------------

The Lisp reader reports invalid syntax, but cannot say where the real
problem is.  For example, the error 'End of file during parsing' in
evaluating an expression indicates an excess of open parentheses (or
square brackets).  The reader detects this imbalance at the end of the
file, but it cannot figure out where the close parenthesis should have
been.  Likewise, 'Invalid read syntax: ")"' indicates an excess close
parenthesis or missing open parenthesis, but does not say where the
missing parenthesis belongs.  How, then, to find what to change?

   If the problem is not simply an imbalance of parentheses, a useful
technique is to try 'C-M-e' ('end-of-defun', *note (emacs)Moving by
Defuns::) at the beginning of each defun, and see if it goes to the
place where that defun appears to end.  If it does not, there is a
problem in that defun.

   However, unmatched parentheses are the most common syntax errors in
Lisp, and we can give further advice for those cases.  (In addition,
just moving point through the code with Show Paren mode enabled might
find the mismatch.)

MENU

* |Excess_Open|::     How to find a spurious open paren or missing close.
* |Excess_Close|::    How to find a spurious close paren or missing open.

==============================================================================
File: elisp.info,  Node: |Excess_Open|,  Next: |Excess_Close|,  Up: |Syntax_Errors|
==============================================================================

                                                                   *Excess_Open*

18.3.1 Excess Open Parentheses
------------------------------

The first step is to find the defun that is unbalanced.  If there is an
excess open parenthesis, the way to do this is to go to the end of the
file and type 'C-u C-M-u' ('backward-up-list', *note (emacs)Moving by
Parens::).  This will move you to the beginning of the first defun that
is unbalanced.

   The next step is to determine precisely what is wrong.  There is no
way to be sure of this except by studying the program, but often the
existing indentation is a clue to where the parentheses should have
been.  The easiest way to use this clue is to reindent with 'C-M-q'
('indent-pp-sexp', *note (emacs)Multi-line Indent::) and see what moves.
*But don't do this yet!*  Keep reading, first.

   Before you do this, make sure the defun has enough close parentheses.
Otherwise, 'C-M-q' will get an error, or will reindent all the rest of
the file until the end.  So move to the end of the defun and insert a
close parenthesis there.  Don't use 'C-M-e' ('end-of-defun') to move
there, since that too will fail to work until the defun is balanced.

   Now you can go to the beginning of the defun and type 'C-M-q'.
Usually all the lines from a certain point to the end of the function
will shift to the right.  There is probably a missing close parenthesis,
or a superfluous open parenthesis, near that point.  (However, don't
assume this is true; study the code to make sure.)  Once you have found
the discrepancy, undo the 'C-M-q' with 'C-_' ('undo'), since the old
indentation is probably appropriate to the intended parentheses.

   After you think you have fixed the problem, use 'C-M-q' again.  If
the old indentation actually fit the intended nesting of parentheses,
and you have put back those parentheses, 'C-M-q' should not change
anything.

==============================================================================
File: elisp.info,  Node: |Excess_Close|,  Prev: |Excess_Open|,  Up: |Syntax_Errors|
==============================================================================

                                                                  *Excess_Close*

18.3.2 Excess Close Parentheses
-------------------------------

To deal with an excess close parenthesis, first go to the beginning of
the file, then type 'C-u -1 C-M-u' ('backward-up-list' with an argument
of -1) to find the end of the first unbalanced defun.

   Then find the actual matching close parenthesis by typing 'C-M-f'
('forward-sexp', *note (emacs)Expressions::) at the beginning of that
defun.  This will leave you somewhere short of the place where the defun
ought to end.  It is possible that you will find a spurious close
parenthesis in that vicinity.

   If you don't see a problem at that point, the next thing to do is to
type 'C-M-q' ('indent-pp-sexp') at the beginning of the defun.  A range
of lines will probably shift left; if so, the missing open parenthesis
or spurious close parenthesis is probably near the first of those lines.
(However, don't assume this is true; study the code to make sure.)  Once
you have found the discrepancy, undo the 'C-M-q' with 'C-_' ('undo'),
since the old indentation is probably appropriate to the intended
parentheses.

   After you think you have fixed the problem, use 'C-M-q' again.  If
the old indentation actually fits the intended nesting of parentheses,
and you have put back those parentheses, 'C-M-q' should not change
anything.

==============================================================================
File: elisp.info,  Node: |Test_Coverage|,  Next: |Profiling|,  Prev: |Syntax_Errors|,  Up: |Debugging|
==============================================================================

                                                                 *Test_Coverage*

18.4 Test Coverage
------------------

You can do coverage testing for a file of Lisp code by loading the
'testcover' library and using the command 'M-x testcover-start <RET>
FILE <RET>' to instrument the code.  Then test your code by calling it
one or more times.  Then use the command 'M-x testcover-mark-all' to
display colored highlights on the code to show where coverage is
insufficient.  The command 'M-x testcover-next-mark' will move point
forward to the next highlighted spot.

   Normally, a red highlight indicates the form was never completely
evaluated; a brown highlight means it always evaluated to the same value
(meaning there has been little testing of what is done with the result).
However, the red highlight is skipped for forms that can't possibly
complete their evaluation, such as 'error'.  The brown highlight is
skipped for forms that are expected to always evaluate to the same
value, such as '(setq x 14)'.

   For difficult cases, you can add do-nothing macros to your code to
give advice to the test coverage tool.

 -- Macro: 1value form
     Evaluate FORM and return its value, but inform coverage testing
     that FORM's value should always be the same.

 -- Macro: noreturn form
     Evaluate FORM, informing coverage testing that FORM should never
     return.  If it ever does return, you get a run-time error.

   Edebug also has a coverage testing feature (*note Coverage
Testing::).  These features partly duplicate each other, and it would be
cleaner to combine them.

==============================================================================
File: elisp.info,  Node: |Profiling|,  Prev: |Test_Coverage|,  Up: |Debugging|
==============================================================================

                                                                     *Profiling*

18.5 Profiling
--------------

If your program is working correctly, but not fast enough, and you want
to make it run more quickly or efficiently, the first thing to do is
"profile" your code so that you know where it spends most of the
execution time.  If you find that one particular function is responsible
for a significant portion of the execution time, you can start looking
for ways to optimize that piece.

   Emacs has built-in support for this.  To begin profiling, type 'M-x
profiler-start'.  You can choose to profile by processor usage, memory
usage, or both.  Then run the code you'd like to speed up.  After that,
type 'M-x profiler-report' to display a summary buffer for each resource
(cpu and memory) that you chose to profile.  The names of the report
buffers include the times at which the reports were generated, so you
can generate another report later on without erasing previous results.
When you have finished profiling, type 'M-x profiler-stop' (there is a
small overhead associated with profiling, so we don't recommend leaving
it active except when you are actually running the code you want to
examine).

   The profiler report buffer shows, on each line, a function that was
called, followed by how much resources (cpu or memory) it used in
absolute and percentage terms since profiling started.  If a given line
has a '+' symbol at the left-hand side, you can expand that line by
typing '<RET>', in order to see the function(s) called by the
higher-level function.  Use a prefix argument ('C-u <RET>') to see the
whole call tree below a function.  Pressing '<RET>' again will collapse
back to the original state.

   Press 'j' or 'mouse-2' to jump to the definition of a function at
point.  Press 'd' to view a function's documentation.  You can save a
profile to a file using 'C-x C-w'.  You can compare two profiles using
'='.

   The 'elp' library offers an alternative approach, which is useful
when you know in advance which Lisp function(s) you want to profile.
Using that library, you begin by setting 'elp-function-list' to the list
of function symbols--those are the functions you want to profile.  Then
type 'M-x elp-instrument-list <RET> nil <RET>' to arrange for profiling
those functions.  After running the code you want to profile, invoke
'M-x elp-results' to display the current results.  See the file 'elp.el'
for more detailed instructions.  This approach is limited to profiling
functions written in Lisp, it cannot profile Emacs primitives.

   You can measure the time it takes to evaluate individual Emacs Lisp
forms using the 'benchmark' library.  See the macros 'benchmark-run',
'benchmark-run-compiled' and 'benchmark-progn' in 'benchmark.el'.  You
can also use the 'benchmark' command for timing forms interactively.

   To profile Emacs at the level of its C code, you can build it using
the '--enable-profiling' option of 'configure'.  When Emacs exits, it
generates a file 'gmon.out' that you can examine using the 'gprof'
utility.  This feature is mainly useful for debugging Emacs.  It
actually stops the Lisp-level 'M-x profiler-...' commands described
above from working.

==============================================================================
File: elisp.info,  Node: |Read_and_Print|,  Next: |Minibuffers|,  Prev: |Debugging|,  Up: |Top|
==============================================================================

                                                                *Read_and_Print*

19 Reading and Printing Lisp Objects
====================================

"Printing" and "reading" are the operations of converting Lisp objects
to textual form and vice versa.  They use the printed representations
and read syntax described in *note Lisp Data Types::.

   This chapter describes the Lisp functions for reading and printing.
It also describes "streams", which specify where to get the text (if
reading) or where to put it (if printing).

MENU

* |Streams_Intro|::     Overview of streams, reading and printing.
* |Input_Streams|::     Various data types that can be used as input streams.
* |Input_Functions|::   Functions to read Lisp objects from text.
* |Output_Streams|::    Various data types that can be used as output streams.
* |Output_Functions|::  Functions to print Lisp objects as text.
* |Output_Variables|::  Variables that control what the printing functions do.

==============================================================================
File: elisp.info,  Node: |Streams_Intro|,  Next: |Input_Streams|,  Up: |Read_and_Print|
==============================================================================

                                                                 *Streams_Intro*

19.1 Introduction to Reading and Printing
-----------------------------------------

"Reading" a Lisp object means parsing a Lisp expression in textual form
and producing a corresponding Lisp object.  This is how Lisp programs
get into Lisp from files of Lisp code.  We call the text the "read
syntax" of the object.  For example, the text '(a . 5)' is the read
syntax for a cons cell whose CAR is 'a' and whose CDR is the number 5.

   "Printing" a Lisp object means producing text that represents that
object--converting the object to its "printed representation" (*note
Printed Representation::).  Printing the cons cell described above
produces the text '(a . 5)'.

   Reading and printing are more or less inverse operations: printing
the object that results from reading a given piece of text often
produces the same text, and reading the text that results from printing
an object usually produces a similar-looking object.  For example,
printing the symbol 'foo' produces the text 'foo', and reading that text
returns the symbol 'foo'.  Printing a list whose elements are 'a' and
'b' produces the text '(a b)', and reading that text produces a list
(but not the same list) with elements 'a' and 'b'.

   However, these two operations are not precisely inverse to each
other.  There are three kinds of exceptions:

   * Printing can produce text that cannot be read.  For example,
     buffers, windows, frames, subprocesses and markers print as text
     that starts with '#'; if you try to read this text, you get an
     error.  There is no way to read those data types.

   * One object can have multiple textual representations.  For example,
     '1' and '01' represent the same integer, and '(a b)' and '(a .
     (b))' represent the same list.  Reading will accept any of the
     alternatives, but printing must choose one of them.

   * Comments can appear at certain points in the middle of an object's
     read sequence without affecting the result of reading it.

==============================================================================
File: elisp.info,  Node: |Input_Streams|,  Next: |Input_Functions|,  Prev: |Streams_Intro|,  Up: |Read_and_Print|
==============================================================================

                                                                 *Input_Streams*

19.2 Input Streams
------------------

Most of the Lisp functions for reading text take an "input stream" as an
argument.  The input stream specifies where or how to get the characters
of the text to be read.  Here are the possible types of input stream:

BUFFER
     The input characters are read from BUFFER, starting with the
     character directly after point.  Point advances as characters are
     read.

MARKER
     The input characters are read from the buffer that MARKER is in,
     starting with the character directly after the marker.  The marker
     position advances as characters are read.  The value of point in
     the buffer has no effect when the stream is a marker.

STRING
     The input characters are taken from STRING, starting at the first
     character in the string and using as many characters as required.

FUNCTION
     The input characters are generated by FUNCTION, which must support
     two kinds of calls:

        * When it is called with no arguments, it should return the next
          character.

        * When it is called with one argument (always a character),
          FUNCTION should save the argument and arrange to return it on
          the next call.  This is called "unreading" the character; it
          happens when the Lisp reader reads one character too many and
          wants to put it back where it came from.  In this case, it
          makes no difference what value FUNCTION returns.

't'
     't' used as a stream means that the input is read from the
     minibuffer.  In fact, the minibuffer is invoked once and the text
     given by the user is made into a string that is then used as the
     input stream.  If Emacs is running in batch mode, standard input is
     used instead of the minibuffer.  For example,
          (message "%s" (read t))
     will read a Lisp expression from standard input and print the
     result to standard output.

'nil'
     'nil' supplied as an input stream means to use the value of
     'standard-input' instead; that value is the "default input stream",
     and must be a non-'nil' input stream.

SYMBOL
     A symbol as input stream is equivalent to the symbol's function
     definition (if any).

   Here is an example of reading from a stream that is a buffer, showing
where point is located before and after:

     ---------- Buffer: foo ----------
     This-!- is the contents of foo.
     ---------- Buffer: foo ----------

     (read (get-buffer "foo"))
          => is
     (read (get-buffer "foo"))
          => the

     ---------- Buffer: foo ----------
     This is the-!- contents of foo.
     ---------- Buffer: foo ----------

Note that the first read skips a space.  Reading skips any amount of
whitespace preceding the significant text.

   Here is an example of reading from a stream that is a marker,
initially positioned at the beginning of the buffer shown.  The value
read is the symbol 'This'.


     ---------- Buffer: foo ----------
     This is the contents of foo.
     ---------- Buffer: foo ----------

     (setq m (set-marker (make-marker) 1 (get-buffer "foo")))
          => #<marker at 1 in foo>
     (read m)
          => This
     m
          => #<marker at 5 in foo>   ;; Before the first space.

   Here we read from the contents of a string:

     (read "(When in) the course")
          => (When in)

   The following example reads from the minibuffer.  The prompt is:
'Lisp expression: '.  (That is always the prompt used when you read from
the stream 't'.)  The user's input is shown following the prompt.

     (read t)
          => 23
     ---------- Buffer: Minibuffer ----------
     Lisp expression: 23 <RET>
     ---------- Buffer: Minibuffer ----------

   Finally, here is an example of a stream that is a function, named
'useless-stream'.  Before we use the stream, we initialize the variable
'useless-list' to a list of characters.  Then each call to the function
'useless-stream' obtains the next character in the list or unreads a
character by adding it to the front of the list.

     (setq useless-list (append "XY()" nil))
          => (88 89 40 41)

     (defun useless-stream (&optional unread)
       (if unread
           (setq useless-list (cons unread useless-list))
         (prog1 (car useless-list)
                (setq useless-list (cdr useless-list)))))
          => useless-stream

Now we read using the stream thus constructed:

     (read 'useless-stream)
          => XY

     useless-list
          => (40 41)

Note that the open and close parentheses remain in the list.  The Lisp
reader encountered the open parenthesis, decided that it ended the
input, and unread it.  Another attempt to read from the stream at this
point would read '()' and return 'nil'.

==============================================================================
File: elisp.info,  Node: |Input_Functions|,  Next: |Output_Streams|,  Prev: |Input_Streams|,  Up: |Read_and_Print|
==============================================================================

                                                               *Input_Functions*

19.3 Input Functions
--------------------

This section describes the Lisp functions and variables that pertain to
reading.

   In the functions below, STREAM stands for an input stream (see the
previous section).  If STREAM is 'nil' or omitted, it defaults to the
value of 'standard-input'.

   An 'end-of-file' error is signaled if reading encounters an
unterminated list, vector, or string.

 -- Function: read &optional stream
     This function reads one textual Lisp expression from STREAM,
     returning it as a Lisp object.  This is the basic Lisp input
     function.

 -- Function: read-from-string string &optional start end
     This function reads the first textual Lisp expression from the text
     in STRING.  It returns a cons cell whose CAR is that expression,
     and whose CDR is an integer giving the position of the next
     remaining character in the string (i.e., the first one not read).

     If START is supplied, then reading begins at index START in the
     string (where the first character is at index 0).  If you specify
     END, then reading is forced to stop just before that index, as if
     the rest of the string were not there.

     For example:

          (read-from-string "(setq x 55) (setq y 5)")
               => ((setq x 55) . 11)
          (read-from-string "\"A short string\"")
               => ("A short string" . 16)

          ;; Read starting at the first character.
          (read-from-string "(list 112)" 0)
               => ((list 112) . 10)
          ;; Read starting at the second character.
          (read-from-string "(list 112)" 1)
               => (list . 5)
          ;; Read starting at the seventh character,
          ;;   and stopping at the ninth.
          (read-from-string "(list 112)" 6 8)
               => (11 . 8)

 -- Variable: standard-input
     This variable holds the default input stream--the stream that 'read'
     uses when the STREAM argument is 'nil'.  The default is 't',
     meaning use the minibuffer.

 -- Variable: read-circle
     If non-'nil', this variable enables the reading of circular and
     shared structures.  *Note Circular Objects::.  Its default value is
     't'.

   When reading or writing from the standard input/output streams of the
Emacs process in batch mode, it is sometimes required to make sure any
arbitrary binary data will be read/written verbatim, and/or that no
translation of newlines to or from CR-LF pairs is performed.  This issue
does not exist on POSIX hosts, only on MS-Windows and MS-DOS.  The
following function allows you to control the I/O mode of any standard
stream of the Emacs process.

 -- Function: set-binary-mode stream mode
     Switch STREAM into binary or text I/O mode.  If MODE is non-'nil',
     switch to binary mode, otherwise switch to text mode.  The value of
     STREAM can be one of 'stdin', 'stdout', or 'stderr'.  This function
     flushes any pending output data of STREAM as a side effect, and
     returns the previous value of I/O mode for STREAM.  On POSIX hosts,
     it always returns a non-'nil' value and does nothing except
     flushing pending output.

==============================================================================
File: elisp.info,  Node: |Output_Streams|,  Next: |Output_Functions|,  Prev: |Input_Functions|,  Up: |Read_and_Print|
==============================================================================

                                                                *Output_Streams*

19.4 Output Streams
-------------------

An output stream specifies what to do with the characters produced by
printing.  Most print functions accept an output stream as an optional
argument.  Here are the possible types of output stream:

BUFFER
     The output characters are inserted into BUFFER at point.  Point
     advances as characters are inserted.

MARKER
     The output characters are inserted into the buffer that MARKER
     points into, at the marker position.  The marker position advances
     as characters are inserted.  The value of point in the buffer has
     no effect on printing when the stream is a marker, and this kind of
     printing does not move point (except that if the marker points at
     or before the position of point, point advances with the
     surrounding text, as usual).

FUNCTION
     The output characters are passed to FUNCTION, which is responsible
     for storing them away.  It is called with a single character as
     argument, as many times as there are characters to be output, and
     is responsible for storing the characters wherever you want to put
     them.

't'
     The output characters are displayed in the echo area.

'nil'
     'nil' specified as an output stream means to use the value of
     'standard-output' instead; that value is the "default output
     stream", and must not be 'nil'.

SYMBOL
     A symbol as output stream is equivalent to the symbol's function
     definition (if any).

   Many of the valid output streams are also valid as input streams.
The difference between input and output streams is therefore more a
matter of how you use a Lisp object, than of different types of object.

   Here is an example of a buffer used as an output stream.  Point is
initially located as shown immediately before the 'h' in 'the'.  At the
end, point is located directly before that same 'h'.

     ---------- Buffer: foo ----------
     This is t-!-he contents of foo.
     ---------- Buffer: foo ----------

     (print "This is the output" (get-buffer "foo"))
          => "This is the output"

     ---------- Buffer: foo ----------
     This is t
     "This is the output"
     -!-he contents of foo.
     ---------- Buffer: foo ----------

   Now we show a use of a marker as an output stream.  Initially, the
marker is in buffer 'foo', between the 't' and the 'h' in the word
'the'.  At the end, the marker has advanced over the inserted text so
that it remains positioned before the same 'h'.  Note that the location
of point, shown in the usual fashion, has no effect.

     ---------- Buffer: foo ----------
     This is the -!-output
     ---------- Buffer: foo ----------

     (setq m (copy-marker 10))
          => #<marker at 10 in foo>

     (print "More output for foo." m)
          => "More output for foo."

     ---------- Buffer: foo ----------
     This is t
     "More output for foo."
     he -!-output
     ---------- Buffer: foo ----------

     m
          => #<marker at 34 in foo>

   The following example shows output to the echo area:

     (print "Echo Area output" t)
          => "Echo Area output"
     ---------- Echo Area ----------
     "Echo Area output"
     ---------- Echo Area ----------

   Finally, we show the use of a function as an output stream.  The
function 'eat-output' takes each character that it is given and conses
it onto the front of the list 'last-output' (*note Building Lists::).
At the end, the list contains all the characters output, but in reverse
order.

     (setq last-output nil)
          => nil

     (defun eat-output (c)
       (setq last-output (cons c last-output)))
          => eat-output

     (print "This is the output" #'eat-output)
          => "This is the output"

     last-output
          => (10 34 116 117 112 116 117 111 32 101 104
         116 32 115 105 32 115 105 104 84 34 10)

Now we can put the output in the proper order by reversing the list:

     (concat (nreverse last-output))
          => "
     \"This is the output\"
     "

Calling 'concat' converts the list to a string so you can see its
contents more clearly.

 -- Function: external-debugging-output character
     This function can be useful as an output stream when debugging.  It
     writes CHARACTER to the standard error stream.

     For example
          (print "This is the output" #'external-debugging-output)
          -| This is the output
          => "This is the output"

==============================================================================
File: elisp.info,  Node: |Output_Functions|,  Next: |Output_Variables|,  Prev: |Output_Streams|,  Up: |Read_and_Print|
==============================================================================

                                                              *Output_Functions*

19.5 Output Functions
---------------------

This section describes the Lisp functions for printing Lisp
objects--converting objects into their printed representation.

   Some of the Emacs printing functions add quoting characters to the
output when necessary so that it can be read properly.  The quoting
characters used are '"' and '\'; they distinguish strings from symbols,
and prevent punctuation characters in strings and symbols from being
taken as delimiters when reading.  *Note Printed Representation::, for
full details.  You specify quoting or no quoting by the choice of
printing function.

   If the text is to be read back into Lisp, then you should print with
quoting characters to avoid ambiguity.  Likewise, if the purpose is to
describe a Lisp object clearly for a Lisp programmer.  However, if the
purpose of the output is to look nice for humans, then it is usually
better to print without quoting.

   Lisp objects can refer to themselves.  Printing a self-referential
object in the normal way would require an infinite amount of text, and
the attempt could cause infinite recursion.  Emacs detects such
recursion and prints '#LEVEL' instead of recursively printing an object
already being printed.  For example, here '#0' indicates a recursive
reference to the object at level 0 of the current print operation:

     (setq foo (list nil))
          => (nil)
     (setcar foo foo)
          => (#0)

   In the functions below, STREAM stands for an output stream.  (See the
previous section for a description of output streams.  Also *Note
external-debugging-output::, a useful stream value for debugging.)  If
STREAM is 'nil' or omitted, it defaults to the value of
'standard-output'.

 -- Function: print object &optional stream
     The 'print' function is a convenient way of printing.  It outputs
     the printed representation of OBJECT to STREAM, printing in
     addition one newline before OBJECT and another after it.  Quoting
     characters are used.  'print' returns OBJECT.  For example:

          (progn (print 'The\ cat\ in)
                 (print "the hat")
                 (print " came back"))
               -|
               -| The\ cat\ in
               -|
               -| "the hat"
               -|
               -| " came back"
               => " came back"

 -- Function: prin1 object &optional stream
     This function outputs the printed representation of OBJECT to
     STREAM.  It does not print newlines to separate output as 'print'
     does, but it does use quoting characters just like 'print'.  It
     returns OBJECT.

          (progn (prin1 'The\ cat\ in)
                 (prin1 "the hat")
                 (prin1 " came back"))
               -| The\ cat\ in"the hat"" came back"
               => " came back"

 -- Function: princ object &optional stream
     This function outputs the printed representation of OBJECT to
     STREAM.  It returns OBJECT.

     This function is intended to produce output that is readable by
     people, not by 'read', so it doesn't insert quoting characters and
     doesn't put double-quotes around the contents of strings.  It does
     not add any spacing between calls.

          (progn
            (princ 'The\ cat)
            (princ " in the \"hat\""))
               -| The cat in the "hat"
               => " in the \"hat\""

 -- Function: terpri &optional stream ensure
     This function outputs a newline to STREAM.  The name stands for
     "terminate print".  If ENSURE is non-'nil' no newline is printed if
     STREAM is already at the beginning of a line.  Note in this case
     STREAM can not be a function and an error is signaled if it is.
     This function returns 't' if a newline is printed.

 -- Function: write-char character &optional stream
     This function outputs CHARACTER to STREAM.  It returns CHARACTER.

 -- Function: prin1-to-string object &optional noescape
     This function returns a string containing the text that 'prin1'
     would have printed for the same argument.

          (prin1-to-string 'foo)
               => "foo"
          (prin1-to-string (mark-marker))
               => "#<marker at 2773 in strings.texi>"

     If NOESCAPE is non-'nil', that inhibits use of quoting characters
     in the output.  (This argument is supported in Emacs versions 19
     and later.)

          (prin1-to-string "foo")
               => "\"foo\""
          (prin1-to-string "foo" t)
               => "foo"

     See 'format', in *note Formatting Strings::, for other ways to
     obtain the printed representation of a Lisp object as a string.

 -- Macro: with-output-to-string body...
     This macro executes the BODY forms with 'standard-output' set up to
     feed output into a string.  Then it returns that string.

     For example, if the current buffer name is 'foo',

          (with-output-to-string
            (princ "The buffer is ")
            (princ (buffer-name)))

     returns '"The buffer is foo"'.

 -- Function: pp object &optional stream
     This function outputs OBJECT to STREAM, just like 'prin1', but does
     it in a prettier way.  That is, it'll indent and fill the object to
     make it more readable for humans.

   If you need to use binary I/O in batch mode, e.g., use the functions
described in this section to write out arbitrary binary data or avoid
conversion of newlines on non-POSIX hosts, see *note set-binary-mode:
Input Functions.

==============================================================================
File: elisp.info,  Node: |Output_Variables|,  Prev: |Output_Functions|,  Up: |Read_and_Print|
==============================================================================

                                                              *Output_Variables*

19.6 Variables Affecting Output
-------------------------------

 -- Variable: standard-output
     The value of this variable is the default output stream--the stream
     that print functions use when the STREAM argument is 'nil'.  The
     default is 't', meaning display in the echo area.

 -- Variable: print-quoted
     If this is non-'nil', that means to print quoted forms using
     abbreviated reader syntax, e.g., '(quote foo)' prints as ''foo',
     and '(function foo)' as '#'foo'.  The default is 't'.

 -- Variable: print-escape-newlines
     If this variable is non-'nil', then newline characters in strings
     are printed as '\n' and formfeeds are printed as '\f'.  Normally
     these characters are printed as actual newlines and formfeeds.

     This variable affects the print functions 'prin1' and 'print' that
     print with quoting.  It does not affect 'princ'.  Here is an
     example using 'prin1':

          (prin1 "a\nb")
               -| "a
               -| b"
               => "a
          b"

          (let ((print-escape-newlines t))
            (prin1 "a\nb"))
               -| "a\nb"
               => "a
          b"

     In the second expression, the local binding of
     'print-escape-newlines' is in effect during the call to 'prin1',
     but not during the printing of the result.

 -- Variable: print-escape-control-characters
     If this variable is non-'nil', control characters in strings are
     printed as backslash sequences by the print functions 'prin1' and
     'print' that print with quoting.  If this variable and
     'print-escape-newlines' are both non-'nil', the latter takes
     precedences for newlines and formfeeds.

 -- Variable: print-escape-nonascii
     If this variable is non-'nil', then unibyte non-ASCII characters in
     strings are unconditionally printed as backslash sequences by the
     print functions 'prin1' and 'print' that print with quoting.

     Those functions also use backslash sequences for unibyte non-ASCII
     characters, regardless of the value of this variable, when the
     output stream is a multibyte buffer or a marker pointing into one.

 -- Variable: print-escape-multibyte
     If this variable is non-'nil', then multibyte non-ASCII characters
     in strings are unconditionally printed as backslash sequences by
     the print functions 'prin1' and 'print' that print with quoting.

     Those functions also use backslash sequences for multibyte
     non-ASCII characters, regardless of the value of this variable,
     when the output stream is a unibyte buffer or a marker pointing
     into one.

 -- Variable: print-charset-text-property
     This variable controls printing of 'charset' text property on
     printing a string.  The value should be 'nil', 't', or 'default'.

     If the value is 'nil', 'charset' text properties are never printed.
     If 't', they are always printed.

     If the value is 'default', only print 'charset' text properties if
     there is an "unexpected" 'charset' property.  For ascii characters,
     all charsets are considered "expected".  Otherwise, the expected
     'charset' property of a character is given by 'char-charset'.

 -- Variable: print-length
     The value of this variable is the maximum number of elements to
     print in any list, vector or bool-vector.  If an object being
     printed has more than this many elements, it is abbreviated with an
     ellipsis.

     If the value is 'nil' (the default), then there is no limit.

          (setq print-length 2)
               => 2
          (print '(1 2 3 4 5))
               -| (1 2 ...)
               => (1 2 ...)

 -- Variable: print-level
     The value of this variable is the maximum depth of nesting of
     parentheses and brackets when printed.  Any list or vector at a
     depth exceeding this limit is abbreviated with an ellipsis.  A
     value of 'nil' (which is the default) means no limit.

 -- User Option: eval-expression-print-length
 -- User Option: eval-expression-print-level
     These are the values for 'print-length' and 'print-level' used by
     'eval-expression', and thus, indirectly, by many interactive
     evaluation commands (*note Evaluating Emacs-Lisp Expressions:
     (emacs)Lisp Eval.).

   These variables are used for detecting and reporting circular and
shared structure:

 -- Variable: print-circle
     If non-'nil', this variable enables detection of circular and
     shared structure in printing.  *Note Circular Objects::.

 -- Variable: print-gensym
     If non-'nil', this variable enables detection of uninterned symbols
     (*note Creating Symbols::) in printing.  When this is enabled,
     uninterned symbols print with the prefix '#:', which tells the Lisp
     reader to produce an uninterned symbol.

 -- Variable: print-continuous-numbering
     If non-'nil', that means number continuously across print calls.
     This affects the numbers printed for '#N=' labels and '#M#'
     references.  Don't set this variable with 'setq'; you should only
     bind it temporarily to 't' with 'let'.  When you do that, you
     should also bind 'print-number-table' to 'nil'.

 -- Variable: print-number-table
     This variable holds a vector used internally by printing to
     implement the 'print-circle' feature.  You should not use it except
     to bind it to 'nil' when you bind 'print-continuous-numbering'.

 -- Variable: float-output-format
     This variable specifies how to print floating-point numbers.  The
     default is 'nil', meaning use the shortest output that represents
     the number without losing information.

     To control output format more precisely, you can put a string in
     this variable.  The string should hold a '%'-specification to be
     used in the C function 'sprintf'.  For further restrictions on what
     you can use, see the variable's documentation string.

==============================================================================
File: elisp.info,  Node: |Minibuffers|,  Next: |Command_Loop|,  Prev: |Read_and_Print|,  Up: |Top|
==============================================================================

                                                                   *Minibuffers*

20 Minibuffers
==============

A "minibuffer" is a special buffer that Emacs commands use to read
arguments more complicated than the single numeric prefix argument.
These arguments include file names, buffer names, and command names (as
in 'M-x').  The minibuffer is displayed on the bottom line of the frame,
in the same place as the echo area (*note The Echo Area::), but only
while it is in use for reading an argument.

MENU

* |Intro_to_Minibuffers|::      Basic information about minibuffers.
* |Text_from_Minibuffer|::      How to read a straight text string.
* |Object_from_Minibuffer|::    How to read a Lisp object or expression.
* |Minibuffer_History|::        Recording previous minibuffer inputs
                                so the user can reuse them.
* |Initial_Input|::             Specifying initial contents for the minibuffer.
* |Completion|::                How to invoke and customize completion.
* |Yes_or_No_Queries|::         Asking a question with a simple answer.
* |Multiple_Queries|::          Asking complex questions.
* |Reading_a_Password|::        Reading a password from the terminal.
* |Minibuffer_Commands|::       Commands used as key bindings in minibuffers.
* |Minibuffer_Windows|::        Operating on the special minibuffer windows.
* |Minibuffer_Contents|::       How such commands access the minibuffer text.
* |Recursive_Mini|::            Whether recursive entry to minibuffer is allowed.
* |Minibuffer_Misc|::           Various customization hooks and variables.

==============================================================================
File: elisp.info,  Node: |Intro_to_Minibuffers|,  Next: |Text_from_Minibuffer|,  Up: |Minibuffers|
==============================================================================

                                                          *Intro_to_Minibuffers*

20.1 Introduction to Minibuffers
--------------------------------

In most ways, a minibuffer is a normal Emacs buffer.  Most operations
_within_ a buffer, such as editing commands, work normally in a
minibuffer.  However, many operations for managing buffers do not apply
to minibuffers.  The name of a minibuffer always has the form
' Minibuf-NUMBER', and it cannot be changed.  Minibuffers are
displayed only in special windows used only for minibuffers; these
windows always appear at the bottom of a frame.  (Sometimes frames have
no minibuffer window, and sometimes a special kind of frame contains
nothing but a minibuffer window; see *note Minibuffers and Frames::.)

   The text in the minibuffer always starts with the "prompt string",
the text that was specified by the program that is using the minibuffer
to tell the user what sort of input to type.  This text is marked
read-only so you won't accidentally delete or change it.  It is also
marked as a field (*note Fields::), so that certain motion functions,
including 'beginning-of-line', 'forward-word', 'forward-sentence', and
'forward-paragraph', stop at the boundary between the prompt and the
actual text.

   The minibuffer's window is normally a single line; it grows
automatically if the contents require more space.  Whilst the minibuffer
is active, you can explicitly resize its window temporarily with the
window sizing commands; the window reverts to its normal size when the
minibuffer is exited.  When the minibuffer is not active, you can resize
its window permanently by using the window sizing commands in the
frame's other window, or dragging the mode line with the mouse.  (Due to
details of the current implementation, for this to work
'resize-mini-windows' must be 'nil'.)  If the frame contains just a
minibuffer window, you can change its size by changing the frame's size.

   Use of the minibuffer reads input events, and that alters the values
of variables such as 'this-command' and 'last-command' (*note Command
Loop Info::).  Your program should bind them around the code that uses
the minibuffer, if you do not want that to change them.

   Under some circumstances, a command can use a minibuffer even if
there is an active minibuffer; such a minibuffer is called a "recursive
minibuffer".  The first minibuffer is named ' Minibuf-1'.  Recursive
minibuffers are named by incrementing the number at the end of the name.
(The names begin with a space so that they won't show up in normal
buffer lists.)  Of several recursive minibuffers, the innermost (or most
recently entered) is the active minibuffer.  We usually call this _the_
minibuffer.  You can permit or forbid recursive minibuffers by setting
the variable 'enable-recursive-minibuffers', or by putting properties of
that name on command symbols (*Note Recursive Mini::.)

   Like other buffers, a minibuffer uses a local keymap (*note
Keymaps::) to specify special key bindings.  The function that invokes
the minibuffer also sets up its local map according to the job to be
done.  *Note Text from Minibuffer::, for the non-completion minibuffer
local maps.  *Note Completion Commands::, for the minibuffer local maps
for completion.

   When a minibuffer is inactive, its major mode is
'minibuffer-inactive-mode', with keymap 'minibuffer-inactive-mode-map'.
This is only really useful if the minibuffer is in a separate frame.
*Note Minibuffers and Frames::.

   When Emacs is running in batch mode, any request to read from the
minibuffer actually reads a line from the standard input descriptor that
was supplied when Emacs was started.  This supports only basic input:
none of the special minibuffer features (history, completion, etc.) are
available in batch mode.

==============================================================================
File: elisp.info,  Node: |Text_from_Minibuffer|,  Next: |Object_from_Minibuffer|,  Prev: |Intro_to_Minibuffers|,  Up: |Minibuffers|
==============================================================================

                                                          *Text_from_Minibuffer*

20.2 Reading Text Strings with the Minibuffer
---------------------------------------------

The most basic primitive for minibuffer input is 'read-from-minibuffer',
which can be used to read either a string or a Lisp object in textual
form.  The function 'read-regexp' is used for reading regular
expressions (*note Regular Expressions::), which are a special kind of
string.  There are also specialized functions for reading commands,
variables, file names, etc. (*note Completion::).

   In most cases, you should not call minibuffer input functions in the
middle of a Lisp function.  Instead, do all minibuffer input as part of
reading the arguments for a command, in the 'interactive' specification.
*Note Defining Commands::.

 -- Function: read-from-minibuffer prompt &optional initial keymap read
          history default inherit-input-method
     This function is the most general way to get input from the
     minibuffer.  By default, it accepts arbitrary text and returns it
     as a string; however, if READ is non-'nil', then it uses 'read' to
     convert the text into a Lisp object (*note Input Functions::).

     The first thing this function does is to activate a minibuffer and
     display it with PROMPT (which must be a string) as the prompt.
     Then the user can edit text in the minibuffer.

     When the user types a command to exit the minibuffer,
     'read-from-minibuffer' constructs the return value from the text in
     the minibuffer.  Normally it returns a string containing that text.
     However, if READ is non-'nil', 'read-from-minibuffer' reads the
     text and returns the resulting Lisp object, unevaluated.  (*Note
     Input Functions::, for information about reading.)

     The argument DEFAULT specifies default values to make available
     through the history commands.  It should be a string, a list of
     strings, or 'nil'.  The string or strings become the minibuffer's
     "future history", available to the user with 'M-n'.

     If READ is non-'nil', then DEFAULT is also used as the input to
     'read', if the user enters empty input.  If DEFAULT is a list of
     strings, the first string is used as the input.  If DEFAULT is
     'nil', empty input results in an 'end-of-file' error.  However, in
     the usual case (where READ is 'nil'), 'read-from-minibuffer'
     ignores DEFAULT when the user enters empty input and returns an
     empty string, '""'.  In this respect, it differs from all the other
     minibuffer input functions in this chapter.

     If KEYMAP is non-'nil', that keymap is the local keymap to use in
     the minibuffer.  If KEYMAP is omitted or 'nil', the value of
     'minibuffer-local-map' is used as the keymap.  Specifying a keymap
     is the most important way to customize the minibuffer for various
     applications such as completion.

     The argument HISTORY specifies a history list variable to use for
     saving the input and for history commands used in the minibuffer.
     It defaults to 'minibuffer-history'.  You can optionally specify a
     starting position in the history list as well.  *Note Minibuffer
     History::.

     If the variable 'minibuffer-allow-text-properties' is non-'nil',
     then the string that is returned includes whatever text properties
     were present in the minibuffer.  Otherwise all the text properties
     are stripped when the value is returned.

     The text properties in 'minibuffer-prompt-properties' are applied
     to the prompt.  By default, this property list defines a face to
     use for the prompt.  This face, if present, is applied to the end
     of the face list and merged before display.

     If the user wants to completely control the look of the prompt, the
     most convenient way to do that is to specify the 'default' face at
     the end of all face lists.  For instance:

          (read-from-minibuffer
           (concat
            (propertize "Bold" 'face '(bold default))
            (propertize " and normal: " 'face '(default))))

     If the argument INHERIT-INPUT-METHOD is non-'nil', then the
     minibuffer inherits the current input method (*note Input
     Methods::) and the setting of 'enable-multibyte-characters' (*note
     Text Representations::) from whichever buffer was current before
     entering the minibuffer.

     Use of INITIAL is mostly deprecated; we recommend using a non-'nil'
     value only in conjunction with specifying a cons cell for HISTORY.
     *Note Initial Input::.

 -- Function: read-string prompt &optional initial history default
          inherit-input-method
     This function reads a string from the minibuffer and returns it.
     The arguments PROMPT, INITIAL, HISTORY and INHERIT-INPUT-METHOD are
     used as in 'read-from-minibuffer'.  The keymap used is
     'minibuffer-local-map'.

     The optional argument DEFAULT is used as in 'read-from-minibuffer',
     except that, if non-'nil', it also specifies a default value to
     return if the user enters null input.  As in 'read-from-minibuffer'
     it should be a string, a list of strings, or 'nil', which is
     equivalent to an empty string.  When DEFAULT is a string, that
     string is the default value.  When it is a list of strings, the
     first string is the default value.  (All these strings are
     available to the user in the "future minibuffer history".)

     This function works by calling the 'read-from-minibuffer' function:

          (read-string PROMPT INITIAL HISTORY DEFAULT INHERIT)
          ???
          (let ((value
                 (read-from-minibuffer PROMPT INITIAL nil nil
                                       HISTORY DEFAULT INHERIT)))
            (if (and (equal value "") DEFAULT)
                (if (consp DEFAULT) (car DEFAULT) DEFAULT)
              value))

 -- Function: read-regexp prompt &optional defaults history
     This function reads a regular expression as a string from the
     minibuffer and returns it.  If the minibuffer prompt string PROMPT
     does not end in ':' (followed by optional whitespace), the function
     adds ': ' to the end, preceded by the default return value (see
     below), if that is non-empty.

     The optional argument DEFAULTS controls the default value to return
     if the user enters null input, and should be one of: a string;
     'nil', which is equivalent to an empty string; a list of strings;
     or a symbol.

     If DEFAULTS is a symbol, 'read-regexp' consults the value of the
     variable 'read-regexp-defaults-function' (see below), and if that
     is non-'nil' uses it in preference to DEFAULTS.  The value in this
     case should be either:

        - 'regexp-history-last', which means to use the first element of
          the appropriate minibuffer history list (see below).

        - A function of no arguments, whose return value (which should
          be 'nil', a string, or a list of strings) becomes the value of
          DEFAULTS.

     'read-regexp' now ensures that the result of processing DEFAULTS is
     a list (i.e., if the value is 'nil' or a string, it converts it to
     a list of one element).  To this list, 'read-regexp' then appends a
     few potentially useful candidates for input.  These are:

        - The word or symbol at point.
        - The last regexp used in an incremental search.
        - The last string used in an incremental search.
        - The last string or pattern used in query-replace commands.

     The function now has a list of regular expressions that it passes
     to 'read-from-minibuffer' to obtain the user's input.  The first
     element of the list is the default result in case of empty input.
     All elements of the list are available to the user as the "future
     minibuffer history" list (*note future list: (emacs)Minibuffer
     History.).

     The optional argument HISTORY, if non-'nil', is a symbol specifying
     a minibuffer history list to use (*note Minibuffer History::).  If
     it is omitted or 'nil', the history list defaults to
     'regexp-history'.

 -- User Option: read-regexp-defaults-function
     The function 'read-regexp' may use the value of this variable to
     determine its list of default regular expressions.  If non-'nil',
     the value of this variable should be either:

        - The symbol 'regexp-history-last'.

        - A function of no arguments that returns either 'nil', a
          string, or a list of strings.

     See 'read-regexp' above for details of how these values are used.

 -- Variable: minibuffer-allow-text-properties
     If this variable is 'nil', then 'read-from-minibuffer' and
     'read-string' strip all text properties from the minibuffer input
     before returning it.  However, 'read-no-blanks-input' (see below),
     as well as 'read-minibuffer' and related functions (*note Reading
     Lisp Objects With the Minibuffer: Object from Minibuffer.), and all
     functions that do minibuffer input with completion, discard text
     properties unconditionally, regardless of the value of this
     variable.

 -- Variable: minibuffer-local-map
     This is the default local keymap for reading from the minibuffer.
     By default, it makes the following bindings:

     'C-j'
          'exit-minibuffer'

     <RET>
          'exit-minibuffer'

     <M-<>
          'minibuffer-beginning-of-buffer'

     'C-g'
          'abort-recursive-edit'

     'M-n'
     <DOWN>
          'next-history-element'

     'M-p'
     <UP>
          'previous-history-element'

     'M-s'
          'next-matching-history-element'

     'M-r'
          'previous-matching-history-element'

 -- Function: read-no-blanks-input prompt &optional initial
          inherit-input-method
     This function reads a string from the minibuffer, but does not
     allow whitespace characters as part of the input: instead, those
     characters terminate the input.  The arguments PROMPT, INITIAL, and
     INHERIT-INPUT-METHOD are used as in 'read-from-minibuffer'.

     This is a simplified interface to the 'read-from-minibuffer'
     function, and passes the value of the 'minibuffer-local-ns-map'
     keymap as the KEYMAP argument for that function.  Since the keymap
     'minibuffer-local-ns-map' does not rebind 'C-q', it _is_ possible
     to put a space into the string, by quoting it.

     This function discards text properties, regardless of the value of
     'minibuffer-allow-text-properties'.

          (read-no-blanks-input PROMPT INITIAL)
          ???
          (let (minibuffer-allow-text-properties)
            (read-from-minibuffer PROMPT INITIAL minibuffer-local-ns-map))

 -- Variable: minibuffer-local-ns-map
     This built-in variable is the keymap used as the minibuffer local
     keymap in the function 'read-no-blanks-input'.  By default, it
     makes the following bindings, in addition to those of
     'minibuffer-local-map':

     <SPC>
          'exit-minibuffer'

     <TAB>
          'exit-minibuffer'

     '?'
          'self-insert-and-exit'

==============================================================================
File: elisp.info,  Node: |Object_from_Minibuffer|,  Next: |Minibuffer_History|,  Prev: |Text_from_Minibuffer|,  Up: |Minibuffers|
==============================================================================

                                                        *Object_from_Minibuffer*

20.3 Reading Lisp Objects with the Minibuffer
---------------------------------------------

This section describes functions for reading Lisp objects with the
minibuffer.

 -- Function: read-minibuffer prompt &optional initial
     This function reads a Lisp object using the minibuffer, and returns
     it without evaluating it.  The arguments PROMPT and INITIAL are
     used as in 'read-from-minibuffer'.

     This is a simplified interface to the 'read-from-minibuffer'
     function:

          (read-minibuffer PROMPT INITIAL)
          ???
          (let (minibuffer-allow-text-properties)
            (read-from-minibuffer PROMPT INITIAL nil t))

     Here is an example in which we supply the string '"(testing)"' as
     initial input:

          (read-minibuffer
           "Enter an expression: " (format "%s" '(testing)))

          ;; Here is how the minibuffer is displayed:

          ---------- Buffer: Minibuffer ----------
          Enter an expression: (testing)-!-
          ---------- Buffer: Minibuffer ----------

     The user can type <RET> immediately to use the initial input as a
     default, or can edit the input.

 -- Function: eval-minibuffer prompt &optional initial
     This function reads a Lisp expression using the minibuffer,
     evaluates it, then returns the result.  The arguments PROMPT and
     INITIAL are used as in 'read-from-minibuffer'.

     This function simply evaluates the result of a call to
     'read-minibuffer':

          (eval-minibuffer PROMPT INITIAL)
          ???
          (eval (read-minibuffer PROMPT INITIAL))

 -- Function: edit-and-eval-command prompt form
     This function reads a Lisp expression in the minibuffer, evaluates
     it, then returns the result.  The difference between this command
     and 'eval-minibuffer' is that here the initial FORM is not optional
     and it is treated as a Lisp object to be converted to printed
     representation rather than as a string of text.  It is printed with
     'prin1', so if it is a string, double-quote characters ('"') appear
     in the initial text.  *Note Output Functions::.

     In the following example, we offer the user an expression with
     initial text that is already a valid form:

          (edit-and-eval-command "Please edit: " '(forward-word 1))

          ;; After evaluation of the preceding expression,
          ;;   the following appears in the minibuffer:

          ---------- Buffer: Minibuffer ----------
          Please edit: (forward-word 1)-!-
          ---------- Buffer: Minibuffer ----------

     Typing <RET> right away would exit the minibuffer and evaluate the
     expression, thus moving point forward one word.

==============================================================================
File: elisp.info,  Node: |Minibuffer_History|,  Next: |Initial_Input|,  Prev: |Object_from_Minibuffer|,  Up: |Minibuffers|
==============================================================================

                                                            *Minibuffer_History*

20.4 Minibuffer History
-----------------------

A "minibuffer history list" records previous minibuffer inputs so the
user can reuse them conveniently.  It is a variable whose value is a
list of strings (previous inputs), most recent first.

   There are many separate minibuffer history lists, used for different
kinds of inputs.  It's the Lisp programmer's job to specify the right
history list for each use of the minibuffer.

   You specify a minibuffer history list with the optional HISTORY
argument to 'read-from-minibuffer' or 'completing-read'.  Here are the
possible values for it:

VARIABLE
     Use VARIABLE (a symbol) as the history list.

(VARIABLE . STARTPOS)
     Use VARIABLE (a symbol) as the history list, and assume that the
     initial history position is STARTPOS (a nonnegative integer).

     Specifying 0 for STARTPOS is equivalent to just specifying the
     symbol VARIABLE.  'previous-history-element' will display the most
     recent element of the history list in the minibuffer.  If you
     specify a positive STARTPOS, the minibuffer history functions
     behave as if '(elt VARIABLE (1- STARTPOS))' were the history
     element currently shown in the minibuffer.

     For consistency, you should also specify that element of the
     history as the initial minibuffer contents, using the INITIAL
     argument to the minibuffer input function (*note Initial Input::).

   If you don't specify HISTORY, then the default history list
'minibuffer-history' is used.  For other standard history lists, see
below.  You can also create your own history list variable; just
initialize it to 'nil' before the first use.  If the variable is buffer
local, then each buffer will have its own input history list.

   Both 'read-from-minibuffer' and 'completing-read' add new elements to
the history list automatically, and provide commands to allow the user
to reuse items on the list.  The only thing your program needs to do to
use a history list is to initialize it and to pass its name to the input
functions when you wish.  But it is safe to modify the list by hand when
the minibuffer input functions are not using it.

   Emacs functions that add a new element to a history list can also
delete old elements if the list gets too long.  The variable
'history-length' specifies the maximum length for most history lists.
To specify a different maximum length for a particular history list, put
the length in the 'history-length' property of the history list symbol.
The variable 'history-delete-duplicates' specifies whether to delete
duplicates in history.

 -- Function: add-to-history history-var newelt &optional maxelt
          keep-all
     This function adds a new element NEWELT, if it isn't the empty
     string, to the history list stored in the variable HISTORY-VAR, and
     returns the updated history list.  It limits the list length to the
     value of MAXELT (if non-'nil') or 'history-length' (described
     below).  The possible values of MAXELT have the same meaning as the
     values of 'history-length'.  HISTORY-VAR cannot refer to a lexical
     variable.

     Normally, 'add-to-history' removes duplicate members from the
     history list if 'history-delete-duplicates' is non-'nil'.  However,
     if KEEP-ALL is non-'nil', that says not to remove duplicates, and
     to add NEWELT to the list even if it is empty.

 -- Variable: history-add-new-input
     If the value of this variable is 'nil', standard functions that
     read from the minibuffer don't add new elements to the history
     list.  This lets Lisp programs explicitly manage input history by
     using 'add-to-history'.  The default value is 't'.

 -- User Option: history-length
     The value of this variable specifies the maximum length for all
     history lists that don't specify their own maximum lengths.  If the
     value is 't', that means there is no maximum (don't delete old
     elements).  If a history list variable's symbol has a non-'nil'
     'history-length' property, it overrides this variable for that
     particular history list.

 -- User Option: history-delete-duplicates
     If the value of this variable is 't', that means when adding a new
     history element, all previous identical elements are deleted.

   Here are some of the standard minibuffer history list variables:

 -- Variable: minibuffer-history
     The default history list for minibuffer history input.

 -- Variable: query-replace-history
     A history list for arguments to 'query-replace' (and similar
     arguments to other commands).

 -- Variable: file-name-history
     A history list for file-name arguments.

 -- Variable: buffer-name-history
     A history list for buffer-name arguments.

 -- Variable: regexp-history
     A history list for regular expression arguments.

 -- Variable: extended-command-history
     A history list for arguments that are names of extended commands.

 -- Variable: shell-command-history
     A history list for arguments that are shell commands.

 -- Variable: read-expression-history
     A history list for arguments that are Lisp expressions to evaluate.

 -- Variable: face-name-history
     A history list for arguments that are faces.

 -- Variable: custom-variable-history
     A history list for variable-name arguments read by 'read-variable'.

==============================================================================
File: elisp.info,  Node: |Initial_Input|,  Next: |Completion|,  Prev: |Minibuffer_History|,  Up: |Minibuffers|
==============================================================================

                                                                 *Initial_Input*

20.5 Initial Input
------------------

Several of the functions for minibuffer input have an argument called
INITIAL.  This is a mostly-deprecated feature for specifying that the
minibuffer should start out with certain text, instead of empty as
usual.

   If INITIAL is a string, the minibuffer starts out containing the text
of the string, with point at the end, when the user starts to edit the
text.  If the user simply types <RET> to exit the minibuffer, it will
use the initial input string to determine the value to return.

   *We discourage use of a non-'nil' value for INITIAL*, because initial
input is an intrusive interface.  History lists and default values
provide a much more convenient method to offer useful default inputs to
the user.

   There is just one situation where you should specify a string for an
INITIAL argument.  This is when you specify a cons cell for the HISTORY
argument.  *Note Minibuffer History::.

   INITIAL can also be a cons cell of the form '(STRING . POSITION)'.
This means to insert STRING in the minibuffer but put point at POSITION
within the string's text.

   As a historical accident, POSITION was implemented inconsistently in
different functions.  In 'completing-read', POSITION's value is
interpreted as origin-zero; that is, a value of 0 means the beginning of
the string, 1 means after the first character, etc.  In
'read-minibuffer', and the other non-completion minibuffer input
functions that support this argument, 1 means the beginning of the
string, 2 means after the first character, etc.

   Use of a cons cell as the value for INITIAL arguments is deprecated.

==============================================================================
File: elisp.info,  Node: |Completion|,  Next: |Yes_or_No_Queries|,  Prev: |Initial_Input|,  Up: |Minibuffers|
==============================================================================

                                                                    *Completion*

20.6 Completion
---------------

"Completion" is a feature that fills in the rest of a name starting from
an abbreviation for it.  Completion works by comparing the user's input
against a list of valid names and determining how much of the name is
determined uniquely by what the user has typed.  For example, when you
type 'C-x b' ('switch-to-buffer') and then type the first few letters of
the name of the buffer to which you wish to switch, and then type <TAB>
('minibuffer-complete'), Emacs extends the name as far as it can.

   Standard Emacs commands offer completion for names of symbols, files,
buffers, and processes; with the functions in this section, you can
implement completion for other kinds of names.

   The 'try-completion' function is the basic primitive for completion:
it returns the longest determined completion of a given initial string,
with a given set of strings to match against.

   The function 'completing-read' provides a higher-level interface for
completion.  A call to 'completing-read' specifies how to determine the
list of valid names.  The function then activates the minibuffer with a
local keymap that binds a few keys to commands useful for completion.
Other functions provide convenient simple interfaces for reading certain
kinds of names with completion.

MENU

* |Basic_Completion|::       Low-level functions for completing strings.
* |Minibuffer_Completion|::  Invoking the minibuffer with completion.
* |Completion_Commands|::    Minibuffer commands that do completion.
* |High_Level_Completion|::  Convenient special cases of completion
                             (reading buffer names, variable names, etc.).
* |Reading_File_Names|::     Using completion to read file names and
                             shell commands.
* |Completion_Variables|::   Variables controlling completion behavior.
* |Programmed_Completion|::  Writing your own completion function.
* |Completion_in_Buffers|::  Completing text in ordinary buffers.

==============================================================================
File: elisp.info,  Node: |Basic_Completion|,  Next: |Minibuffer_Completion|,  Up: |Completion|
==============================================================================

                                                              *Basic_Completion*

20.6.1 Basic Completion Functions
---------------------------------

The following completion functions have nothing in themselves to do with
minibuffers.  We describe them here to keep them near the higher-level
completion features that do use the minibuffer.

 -- Function: try-completion string collection &optional predicate
     This function returns the longest common substring of all possible
     completions of STRING in COLLECTION.

     COLLECTION is called the "completion table".  Its value must be a
     list of strings or cons cells, an obarray, a hash table, or a
     completion function.

     'try-completion' compares STRING against each of the permissible
     completions specified by the completion table.  If no permissible
     completions match, it returns 'nil'.  If there is just one matching
     completion, and the match is exact, it returns 't'.  Otherwise, it
     returns the longest initial sequence common to all possible
     matching completions.

     If COLLECTION is a list, the permissible completions are specified
     by the elements of the list, each of which should be either a
     string, or a cons cell whose CAR is either a string or a symbol (a
     symbol is converted to a string using 'symbol-name').  If the list
     contains elements of any other type, those are ignored.

     If COLLECTION is an obarray (*note Creating Symbols::), the names
     of all symbols in the obarray form the set of permissible
     completions.

     If COLLECTION is a hash table, then the keys that are strings or
     symbols are the possible completions.  Other keys are ignored.

     You can also use a function as COLLECTION.  Then the function is
     solely responsible for performing completion; 'try-completion'
     returns whatever this function returns.  The function is called
     with three arguments: STRING, PREDICATE and 'nil' (the third
     argument is so that the same function can be used in
     'all-completions' and do the appropriate thing in either case).
     *Note Programmed Completion::.

     If the argument PREDICATE is non-'nil', then it must be a function
     of one argument, unless COLLECTION is a hash table, in which case
     it should be a function of two arguments.  It is used to test each
     possible match, and the match is accepted only if PREDICATE returns
     non-'nil'.  The argument given to PREDICATE is either a string or a
     cons cell (the CAR of which is a string) from the alist, or a
     symbol (_not_ a symbol name) from the obarray.  If COLLECTION is a
     hash table, PREDICATE is called with two arguments, the string key
     and the associated value.

     In addition, to be acceptable, a completion must also match all the
     regular expressions in 'completion-regexp-list'.  (Unless
     COLLECTION is a function, in which case that function has to handle
     'completion-regexp-list' itself.)

     In the first of the following examples, the string 'foo' is matched
     by three of the alist CARs.  All of the matches begin with the
     characters 'fooba', so that is the result.  In the second example,
     there is only one possible match, and it is exact, so the return
     value is 't'.

          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
               => "fooba"

          (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
               => t

     In the following example, numerous symbols begin with the
     characters 'forw', and all of them begin with the word 'forward'.
     In most of the symbols, this is followed with a '-', but not in
     all, so no more than 'forward' can be completed.

          (try-completion "forw" obarray)
               => "forward"

     Finally, in the following example, only two of the three possible
     matches pass the predicate 'test' (the string 'foobaz' is too
     short).  Both of those begin with the string 'foobar'.

          (defun test (s)
            (> (length (car s)) 6))
               => test
          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               => "foobar"

 -- Function: all-completions string collection &optional predicate
     This function returns a list of all possible completions of STRING.
     The arguments to this function are the same as those of
     'try-completion', and it uses 'completion-regexp-list' in the same
     way that 'try-completion' does.

     If COLLECTION is a function, it is called with three arguments:
     STRING, PREDICATE and 't'; then 'all-completions' returns whatever
     the function returns.  *Note Programmed Completion::.

     Here is an example, using the function 'test' shown in the example
     for 'try-completion':

          (defun test (s)
            (> (length (car s)) 6))
               => test

          (all-completions
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               => ("foobar1" "foobar2")

 -- Function: test-completion string collection &optional predicate
     This function returns non-'nil' if STRING is a valid completion
     alternative specified by COLLECTION and PREDICATE.  The arguments
     are the same as in 'try-completion'.  For instance, if COLLECTION
     is a list of strings, this is true if STRING appears in the list
     and PREDICATE is satisfied.

     This function uses 'completion-regexp-list' in the same way that
     'try-completion' does.

     If PREDICATE is non-'nil' and if COLLECTION contains several
     strings that are equal to each other, as determined by
     'compare-strings' according to 'completion-ignore-case', then
     PREDICATE should accept either all or none of them.  Otherwise, the
     return value of 'test-completion' is essentially unpredictable.

     If COLLECTION is a function, it is called with three arguments, the
     values STRING, PREDICATE and 'lambda'; whatever it returns,
     'test-completion' returns in turn.

 -- Function: completion-boundaries string collection predicate suffix
     This function returns the boundaries of the field on which
     COLLECTION will operate, assuming that STRING holds the text before
     point and SUFFIX holds the text after point.

     Normally completion operates on the whole string, so for all normal
     collections, this will always return '(0 . (length SUFFIX))'.  But
     more complex completion such as completion on files is done one
     field at a time.  For example, completion of '"/usr/sh"' will
     include '"/usr/share/"' but not '"/usr/share/doc"' even if
     '"/usr/share/doc"' exists.  Also 'all-completions' on '"/usr/sh"'
     will not include '"/usr/share/"' but only '"share/"'.  So if STRING
     is '"/usr/sh"' and SUFFIX is '"e/doc"', 'completion-boundaries'
     will return '(5 . 1)' which tells us that the COLLECTION will only
     return completion information that pertains to the area after
     '"/usr/"' and before '"/doc"'.

   If you store a completion alist in a variable, you should mark the
variable as risky by giving it a non-'nil' 'risky-local-variable'
property.  *Note File Local Variables::.

 -- Variable: completion-ignore-case
     If the value of this variable is non-'nil', case is not considered
     significant in completion.  Within 'read-file-name', this variable
     is overridden by 'read-file-name-completion-ignore-case' (*note
     Reading File Names::); within 'read-buffer', it is overridden by
     'read-buffer-completion-ignore-case' (*note High-Level
     Completion::).

 -- Variable: completion-regexp-list
     This is a list of regular expressions.  The completion functions
     only consider a completion acceptable if it matches all regular
     expressions in this list, with 'case-fold-search' (*note Searching
     and Case::) bound to the value of 'completion-ignore-case'.

 -- Macro: lazy-completion-table var fun
     This macro provides a way to initialize the variable VAR as a
     collection for completion in a lazy way, not computing its actual
     contents until they are first needed.  You use this macro to
     produce a value that you store in VAR.  The actual computation of
     the proper value is done the first time you do completion using
     VAR.  It is done by calling FUN with no arguments.  The value FUN
     returns becomes the permanent value of VAR.

     Here is an example:

          (defvar foo (lazy-completion-table foo make-my-alist))

   There are several functions that take an existing completion table
and return a modified version.  'completion-table-case-fold' returns a
case-insensitive table.  'completion-table-in-turn' and
'completion-table-merge' combine multiple input tables in different
ways.  'completion-table-subvert' alters a table to use a different
initial prefix.  'completion-table-with-quoting' returns a table
suitable for operating on quoted text.
'completion-table-with-predicate' filters a table with a predicate
function.  'completion-table-with-terminator' adds a terminating string.

==============================================================================
File: elisp.info,  Node: |Minibuffer_Completion|,  Next: |Completion_Commands|,  Prev: |Basic_Completion|,  Up: |Completion|
==============================================================================

                                                         *Minibuffer_Completion*

20.6.2 Completion and the Minibuffer
------------------------------------

This section describes the basic interface for reading from the
minibuffer with completion.

 -- Function: completing-read prompt collection &optional predicate
          require-match initial history default inherit-input-method
     This function reads a string in the minibuffer, assisting the user
     by providing completion.  It activates the minibuffer with prompt
     PROMPT, which must be a string.

     The actual completion is done by passing the completion table
     COLLECTION and the completion predicate PREDICATE to the function
     'try-completion' (*note Basic Completion::).  This happens in
     certain commands bound in the local keymaps used for completion.
     Some of these commands also call 'test-completion'.  Thus, if
     PREDICATE is non-'nil', it should be compatible with COLLECTION and
     'completion-ignore-case'.  *Note Definition of test-completion::.

     *Note Programmed Completion::, for detailed requirements when
     COLLECTION is a function.

     The value of the optional argument REQUIRE-MATCH determines how the
     user may exit the minibuffer:

        * If 'nil', the usual minibuffer exit commands work regardless
          of the input in the minibuffer.

        * If 't', the usual minibuffer exit commands won't exit unless
          the input completes to an element of COLLECTION.

        * If 'confirm', the user can exit with any input, but is asked
          for confirmation if the input is not an element of COLLECTION.

        * If 'confirm-after-completion', the user can exit with any
          input, but is asked for confirmation if the preceding command
          was a completion command (i.e., one of the commands in
          'minibuffer-confirm-exit-commands') and the resulting input is
          not an element of COLLECTION.  *Note Completion Commands::.

        * Any other value of REQUIRE-MATCH behaves like 't', except that
          the exit commands won't exit if it performs completion.

     However, empty input is always permitted, regardless of the value
     of REQUIRE-MATCH; in that case, 'completing-read' returns the first
     element of DEFAULT, if it is a list; '""', if DEFAULT is 'nil'; or
     DEFAULT.  The string or strings in DEFAULT are also available to
     the user through the history commands.

     The function 'completing-read' uses
     'minibuffer-local-completion-map' as the keymap if REQUIRE-MATCH is
     'nil', and uses 'minibuffer-local-must-match-map' if REQUIRE-MATCH
     is non-'nil'.  *Note Completion Commands::.

     The argument HISTORY specifies which history list variable to use
     for saving the input and for minibuffer history commands.  It
     defaults to 'minibuffer-history'.  *Note Minibuffer History::.

     The argument INITIAL is mostly deprecated; we recommend using a
     non-'nil' value only in conjunction with specifying a cons cell for
     HISTORY.  *Note Initial Input::.  For default input, use DEFAULT
     instead.

     If the argument INHERIT-INPUT-METHOD is non-'nil', then the
     minibuffer inherits the current input method (*note Input
     Methods::) and the setting of 'enable-multibyte-characters' (*note
     Text Representations::) from whichever buffer was current before
     entering the minibuffer.

     If the variable 'completion-ignore-case' is non-'nil', completion
     ignores case when comparing the input against the possible matches.
     *Note Basic Completion::.  In this mode of operation, PREDICATE
     must also ignore case, or you will get surprising results.

     Here's an example of using 'completing-read':

          (completing-read
           "Complete a foo: "
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           nil t "fo")

          ;; After evaluation of the preceding expression,
          ;;   the following appears in the minibuffer:

          ---------- Buffer: Minibuffer ----------
          Complete a foo: fo-!-
          ---------- Buffer: Minibuffer ----------

     If the user then types '<DEL> <DEL> b <RET>', 'completing-read'
     returns 'barfoo'.

     The 'completing-read' function binds variables to pass information
     to the commands that actually do completion.  They are described in
     the following section.

 -- Variable: completing-read-function
     The value of this variable must be a function, which is called by
     'completing-read' to actually do its work.  It should accept the
     same arguments as 'completing-read'.  This can be bound to a
     different function to completely override the normal behavior of
     'completing-read'.

==============================================================================
File: elisp.info,  Node: |Completion_Commands|,  Next: |High_Level_Completion|,  Prev: |Minibuffer_Completion|,  Up: |Completion|
==============================================================================

                                                           *Completion_Commands*

20.6.3 Minibuffer Commands that Do Completion
---------------------------------------------

This section describes the keymaps, commands and user options used in
the minibuffer to do completion.

 -- Variable: minibuffer-completion-table
     The value of this variable is the completion table (*note Basic
     Completion::) used for completion in the minibuffer.  This is the
     global variable that contains what 'completing-read' passes to
     'try-completion'.  It is used by minibuffer completion commands
     such as 'minibuffer-complete-word'.

 -- Variable: minibuffer-completion-predicate
     This variable's value is the predicate that 'completing-read'
     passes to 'try-completion'.  The variable is also used by the other
     minibuffer completion functions.

 -- Variable: minibuffer-completion-confirm
     This variable determines whether Emacs asks for confirmation before
     exiting the minibuffer; 'completing-read' binds this variable, and
     the function 'minibuffer-complete-and-exit' checks the value before
     exiting.  If the value is 'nil', confirmation is not required.  If
     the value is 'confirm', the user may exit with an input that is not
     a valid completion alternative, but Emacs asks for confirmation.
     If the value is 'confirm-after-completion', the user may exit with
     an input that is not a valid completion alternative, but Emacs asks
     for confirmation if the user submitted the input right after any of
     the completion commands in 'minibuffer-confirm-exit-commands'.

 -- Variable: minibuffer-confirm-exit-commands
     This variable holds a list of commands that cause Emacs to ask for
     confirmation before exiting the minibuffer, if the REQUIRE-MATCH
     argument to 'completing-read' is 'confirm-after-completion'.  The
     confirmation is requested if the user attempts to exit the
     minibuffer immediately after calling any command in this list.

 -- Command: minibuffer-complete-word
     This function completes the minibuffer contents by at most a single
     word.  Even if the minibuffer contents have only one completion,
     'minibuffer-complete-word' does not add any characters beyond the
     first character that is not a word constituent.  *Note Syntax
     Tables::.

 -- Command: minibuffer-complete
     This function completes the minibuffer contents as far as possible.

 -- Command: minibuffer-complete-and-exit
     This function completes the minibuffer contents, and exits if
     confirmation is not required, i.e., if
     'minibuffer-completion-confirm' is 'nil'.  If confirmation _is_
     required, it is given by repeating this command immediately--the
     command is programmed to work without confirmation when run twice
     in succession.

 -- Command: minibuffer-completion-help
     This function creates a list of the possible completions of the
     current minibuffer contents.  It works by calling 'all-completions'
     using the value of the variable 'minibuffer-completion-table' as
     the COLLECTION argument, and the value of
     'minibuffer-completion-predicate' as the PREDICATE argument.  The
     list of completions is displayed as text in a buffer named
     'Completions'.

 -- Function: display-completion-list completions
     This function displays COMPLETIONS to the stream in
     'standard-output', usually a buffer.  (*Note Read and Print::, for
     more information about streams.)  The argument COMPLETIONS is
     normally a list of completions just returned by 'all-completions',
     but it does not have to be.  Each element may be a symbol or a
     string, either of which is simply printed.  It can also be a list
     of two strings, which is printed as if the strings were
     concatenated.  The first of the two strings is the actual
     completion, the second string serves as annotation.

     This function is called by 'minibuffer-completion-help'.  A common
     way to use it is together with 'with-output-to-temp-buffer', like
     this:

          (with-output-to-temp-buffer "Completions"
            (display-completion-list
              (all-completions (buffer-string) my-alist)))

 -- User Option: completion-auto-help
     If this variable is non-'nil', the completion commands
     automatically display a list of possible completions whenever
     nothing can be completed because the next character is not uniquely
     determined.

 -- Variable: minibuffer-local-completion-map
     'completing-read' uses this value as the local keymap when an exact
     match of one of the completions is not required.  By default, this
     keymap makes the following bindings:

     '?'
          'minibuffer-completion-help'

     <SPC>
          'minibuffer-complete-word'

     <TAB>
          'minibuffer-complete'

     and uses 'minibuffer-local-map' as its parent keymap (*note
     Definition of minibuffer-local-map::).

 -- Variable: minibuffer-local-must-match-map
     'completing-read' uses this value as the local keymap when an exact
     match of one of the completions is required.  Therefore, no keys
     are bound to 'exit-minibuffer', the command that exits the
     minibuffer unconditionally.  By default, this keymap makes the
     following bindings:

     'C-j'
          'minibuffer-complete-and-exit'

     <RET>
          'minibuffer-complete-and-exit'

     and uses 'minibuffer-local-completion-map' as its parent keymap.

 -- Variable: minibuffer-local-filename-completion-map
     This is a sparse keymap that simply unbinds <SPC>; because
     filenames can contain spaces.  The function 'read-file-name'
     combines this keymap with either 'minibuffer-local-completion-map'
     or 'minibuffer-local-must-match-map'.

 -- Variable: minibuffer-beginning-of-buffer-movement
     If non-'nil', the 'M-<' command will move to the end of the prompt
     if point is after the end of the prompt.  If point is at or before
     the end of the prompt, move to the start of the buffer.  If this
     variable is 'nil', the command behaves like 'beginning-of-buffer'.

==============================================================================
File: elisp.info,  Node: |High_Level_Completion|,  Next: |Reading_File_Names|,  Prev: |Completion_Commands|,  Up: |Completion|
==============================================================================

                                                         *High_Level_Completion*

20.6.4 High-Level Completion Functions
--------------------------------------

This section describes the higher-level convenience functions for
reading certain sorts of names with completion.

   In most cases, you should not call these functions in the middle of a
Lisp function.  When possible, do all minibuffer input as part of
reading the arguments for a command, in the 'interactive' specification.
*Note Defining Commands::.

 -- Function: read-buffer prompt &optional default require-match
          predicate
     This function reads the name of a buffer and returns it as a
     string.  It prompts with PROMPT.  The argument DEFAULT is the
     default name to use, the value to return if the user exits with an
     empty minibuffer.  If non-'nil', it should be a string, a list of
     strings, or a buffer.  If it is a list, the default value is the
     first element of this list.  It is mentioned in the prompt, but is
     not inserted in the minibuffer as initial input.

     The argument PROMPT should be a string ending with a colon and a
     space.  If DEFAULT is non-'nil', the function inserts it in PROMPT
     before the colon to follow the convention for reading from the
     minibuffer with a default value (*note Programming Tips::).

     The optional argument REQUIRE-MATCH has the same meaning as in
     'completing-read'.  *Note Minibuffer Completion::.

     The optional argument PREDICATE, if non-'nil', specifies a function
     to filter the buffers that should be considered: the function will
     be called with every potential candidate as its argument, and
     should return 'nil' to reject the candidate, non-'nil' to accept
     it.

     In the following example, the user enters 'minibuffer.t', and then
     types <RET>.  The argument REQUIRE-MATCH is 't', and the only
     buffer name starting with the given input is 'minibuffer.texi', so
     that name is the value.

          (read-buffer "Buffer name: " "foo" t)
          ;; After evaluation of the preceding expression,
          ;;   the following prompt appears,
          ;;   with an empty minibuffer:

          ---------- Buffer: Minibuffer ----------
          Buffer name (default foo): -!-
          ---------- Buffer: Minibuffer ----------

          ;; The user types 'minibuffer.t <RET>'.
               => "minibuffer.texi"

 -- User Option: read-buffer-function
     This variable, if non-'nil', specifies a function for reading
     buffer names.  'read-buffer' calls this function instead of doing
     its usual work, with the same arguments passed to 'read-buffer'.

 -- User Option: read-buffer-completion-ignore-case
     If this variable is non-'nil', 'read-buffer' ignores case when
     performing completion while reading the buffer name.

 -- Function: read-command prompt &optional default
     This function reads the name of a command and returns it as a Lisp
     symbol.  The argument PROMPT is used as in 'read-from-minibuffer'.
     Recall that a command is anything for which 'commandp' returns 't',
     and a command name is a symbol for which 'commandp' returns 't'.
     *Note Interactive Call::.

     The argument DEFAULT specifies what to return if the user enters
     null input.  It can be a symbol, a string or a list of strings.  If
     it is a string, 'read-command' interns it before returning it.  If
     it is a list, 'read-command' interns the first element of this
     list.  If DEFAULT is 'nil', that means no default has been
     specified; then if the user enters null input, the return value is
     '(intern "")', that is, a symbol whose name is an empty string, and
     whose printed representation is '##' (*note Symbol Type::).

          (read-command "Command name? ")

          ;; After evaluation of the preceding expression,
          ;;   the following prompt appears with an empty minibuffer:

          ---------- Buffer: Minibuffer ----------
          Command name?
          ---------- Buffer: Minibuffer ----------

     If the user types 'forward-c <RET>', then this function returns
     'forward-char'.

     The 'read-command' function is a simplified interface to
     'completing-read'.  It uses the variable 'obarray' so as to
     complete in the set of extant Lisp symbols, and it uses the
     'commandp' predicate so as to accept only command names:

          (read-command PROMPT)
          ???
          (intern (completing-read PROMPT obarray
                                   'commandp t nil))

 -- Function: read-variable prompt &optional default
     This function reads the name of a customizable variable and returns
     it as a symbol.  Its arguments have the same form as those of
     'read-command'.  It behaves just like 'read-command', except that
     it uses the predicate 'custom-variable-p' instead of 'commandp'.

 -- Command: read-color &optional prompt convert allow-empty display
     This function reads a string that is a color specification, either
     the color's name or an RGB hex value such as '#RRRGGGBBB'.  It
     prompts with PROMPT (default: '"Color (name or #RGB triplet):"')
     and provides completion for color names, but not for hex RGB
     values.  In addition to names of standard colors, completion
     candidates include the foreground and background colors at point.

     Valid RGB values are described in *note Color Names::.

     The function's return value is the string typed by the user in the
     minibuffer.  However, when called interactively or if the optional
     argument CONVERT is non-'nil', it converts any input color name
     into the corresponding RGB value string and instead returns that.
     This function requires a valid color specification to be input.
     Empty color names are allowed when ALLOW-EMPTY is non-'nil' and the
     user enters null input.

     Interactively, or when DISPLAY is non-'nil', the return value is
     also displayed in the echo area.

   See also the functions 'read-coding-system' and
'read-non-nil-coding-system', in *note User-Chosen Coding Systems::, and
'read-input-method-name', in *note Input Methods::.

==============================================================================
File: elisp.info,  Node: |Reading_File_Names|,  Next: |Completion_Variables|,  Prev: |High_Level_Completion|,  Up: |Completion|
==============================================================================

                                                            *Reading_File_Names*
vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
