
 -- Function: previous-single-char-property-change pos prop &optional
          object limit
     This is like 'next-single-char-property-change', but scans back
     from POS instead of forward, and returns the minimum valid position
     in OBJECT if no change is found.

 -- Function: text-property-any start end prop value &optional object
     This function returns non-'nil' if at least one character between
     START and END has a property PROP whose value is VALUE.  More
     precisely, it returns the position of the first such character.
     Otherwise, it returns 'nil'.

     The optional fifth argument, OBJECT, specifies the string or buffer
     to scan.  Positions are relative to OBJECT.  The default for OBJECT
     is the current buffer.

 -- Function: text-property-not-all start end prop value &optional
          object
     This function returns non-'nil' if at least one character between
     START and END does not have a property PROP with value VALUE.  More
     precisely, it returns the position of the first such character.
     Otherwise, it returns 'nil'.

     The optional fifth argument, OBJECT, specifies the string or buffer
     to scan.  Positions are relative to OBJECT.  The default for OBJECT
     is the current buffer.

 -- Function: text-property-search-forward prop &optional value
          predicate not-current
     Search for the next region that has text property PROP set to VALUE
     according to PREDICATE.

     This function is modelled after 'search-forward' and friends in
     that it moves point, but it returns a structure that describes the
     match instead of returning it in 'match-beginning' and friends.

     If the text property can't be found, the function returns 'nil'.
     If it's found, point is placed at the end of the region that has
     this text property match, and a 'prop-match' structure is returned.

     PREDICATE can either be 't' (which is a synonym for 'equal'), 'nil'
     (which means "not equal"), or a predicate that will be called with
     two parameters: The first is VALUE, and the second is the value of
     the text property we're inspecting.

     If NOT-CURRENT, if point is in a region where we have a match, then
     skip past that and find the next instance instead.

     The 'prop-match' structure has the following accessors:
     'prop-match-beginning' (the start of the match), 'prop-match-end'
     (the end of the match), and 'prop-match-value' (the value of
     PROPERTY at the start of the match).

     In the examples below, imagine that you're in a buffer that looks
     like this:

          This is a bold and here's bolditalic and this is the end.

     That is, the "bold" words are the 'bold' face, and the "italic"
     word is in the 'italic' face.

     With point at the start:

          (while (setq match (text-property-search-forward 'face 'bold t))
            (push (buffer-substring (prop-match-beginning match)
                                    (prop-match-end match))
                  words))

     This will pick out all the words that use the 'bold' face.

          (while (setq match (text-property-search-forward 'face nil t))
            (push (buffer-substring (prop-match-beginning match)
                                    (prop-match-end match))
                  words))

     This will pick out all the bits that have no face properties, which
     will result in the list '("This is a " "and here's " "and this is
     the end")' (only reversed, since we used 'push').

          (while (setq match (text-property-search-forward 'face nil nil))
            (push (buffer-substring (prop-match-beginning match)
                                    (prop-match-end match))
                  words))

     This will pick out all the regions where 'face' is set to
     something, but this is split up into where the properties change,
     so the result here will be '("bold" "bold" "italic")'.

     For a more realistic example where you might use this, consider
     that you have a buffer where certain sections represent URLs, and
     these are tagged with 'shr-url'.

          (while (setq match (text-property-search-forward 'shr-url nil nil))
            (push (prop-match-value match) urls))

     This will give you a list of all those URLs.

 -- Function: text-property-search-backward prop &optional value
          predicate not-current
     This is just like 'text-property-search-backward', but searches
     backward instead.  Point is placed at the beginning of the matched
     region instead of the end, though.

==============================================================================
File: elisp.info,  Node: |Special_Properties|,  Next: |Format_Properties|,  Prev: |Property_Search|,  Up: |Text_Properties|
==============================================================================

                                                            *Special_Properties*

32.19.4 Properties with Special Meanings
----------------------------------------

Here is a table of text property names that have special built-in
meanings.  The following sections list a few additional special property
names that control filling and property inheritance.  All other names
have no standard meaning, and you can use them as you like.

   Note: the properties 'composition', 'display', 'invisible' and
'intangible' can also cause point to move to an acceptable place, after
each Emacs command.  *Note Adjusting Point::.

'category'
     If a character has a 'category' property, we call it the "property
     category" of the character.  It should be a symbol.  The properties
     of this symbol serve as defaults for the properties of the
     character.

'face'
     The 'face' property controls the appearance of the character (*note
     Faces::).  The value of the property can be the following:

        * A face name (a symbol or string).

        * An anonymous face: a property list of the form '(KEYWORD VALUE
          ...)', where each KEYWORD is a face attribute name and VALUE
          is a value for that attribute.

        * A list of faces.  Each list element should be either a face
          name or an anonymous face.  This specifies a face which is an
          aggregate of the attributes of each of the listed faces.
          Faces occurring earlier in the list have higher priority.

        * A cons cell of the form '(foreground-color . COLOR-NAME)' or
          '(background-color . COLOR-NAME)'.  This specifies the
          foreground or background color, similar to '(:foreground
          COLOR-NAME)' or '(:background COLOR-NAME)'.  This form is
          supported for backward compatibility only, and should be
          avoided.

        * A cons cell of the form '(:filtered FILTER FACE-SPEC)', that
          specifies the face given by FACE-SPEC, but only if FILTER
          matches when the face is used for display.  The FACE-SPEC can
          use any of the forms mentioned above.  The FILTER should be of
          the form '(:window PARAM VALUE)', which matches for windows
          whose parameter PARAM is 'eq' to VALUE.  If the variable
          'face-filters-always-match' is non-'nil', all face filters are
          deemed to have matched.

     Font Lock mode (*note Font Lock Mode::) works in most buffers by
     dynamically updating the 'face' property of characters based on the
     context.

     The 'add-face-text-property' function provides a convenient way to
     set this text property.  *Note Changing Properties::.

'font-lock-face'
     This property specifies a value for the 'face' property that Font
     Lock mode should apply to the underlying text.  It is one of the
     fontification methods used by Font Lock mode, and is useful for
     special modes that implement their own highlighting.  *Note
     Precalculated Fontification::.  When Font Lock mode is disabled,
     'font-lock-face' has no effect.

'mouse-face'
     This property is used instead of 'face' when the mouse is on or
     near the character.  For this purpose, "near" means that all text
     between the character and where the mouse is have the same
     'mouse-face' property value.

     Emacs ignores all face attributes from the 'mouse-face' property
     that alter the text size (e.g., ':height', ':weight', and
     ':slant').  Those attributes are always the same as for the
     unhighlighted text.

'fontified'
     This property says whether the text is ready for display.  If
     'nil', Emacs's redisplay routine calls the functions in
     'fontification-functions' (*note Auto Faces::) to prepare this part
     of the buffer before it is displayed.  It is used internally by the
     just-in-time font locking code.

'display'
     This property activates various features that change the way text
     is displayed.  For example, it can make text appear taller or
     shorter, higher or lower, wider or narrow, or replaced with an
     image.  *Note Display Property::.

'help-echo'
     If text has a string as its 'help-echo' property, then when you
     move the mouse onto that text, Emacs displays that string in the
     echo area, or in the tooltip window (*note Tooltips::), after
     passing it through 'substitute-command-keys'.

     If the value of the 'help-echo' property is a function, that
     function is called with three arguments, WINDOW, OBJECT and POS and
     should return a help string or 'nil' for none.  The first argument,
     WINDOW is the window in which the help was found.  The second,
     OBJECT, is the buffer, overlay or string which had the 'help-echo'
     property.  The POS argument is as follows:

        * If OBJECT is a buffer, POS is the position in the buffer.
        * If OBJECT is an overlay, that overlay has a 'help-echo'
          property, and POS is the position in the overlay's buffer.
        * If OBJECT is a string (an overlay string or a string displayed
          with the 'display' property), POS is the position in that
          string.

     If the value of the 'help-echo' property is neither a function nor
     a string, it is evaluated to obtain a help string.

     You can alter the way help text is displayed by setting the
     variable 'show-help-function' (*note Help display::).

     This feature is used in the mode line and for other active text.

'help-echo-inhibit-substitution'
     If the first character of a 'help-echo' string has a non-'nil'
     'help-echo-inhibit-substitution' property, then it is displayed
     as-is by 'show-help-function', without being passed through
     'substitute-command-keys'.

'keymap'
     The 'keymap' property specifies an additional keymap for commands.
     When this keymap applies, it is used for key lookup before the
     minor mode keymaps and before the buffer's local map.  *Note Active
     Keymaps::.  If the property value is a symbol, the symbol's
     function definition is used as the keymap.

     The property's value for the character before point applies if it
     is non-'nil' and rear-sticky, and the property's value for the
     character after point applies if it is non-'nil' and front-sticky.
     (For mouse clicks, the position of the click is used instead of the
     position of point.)

'local-map'
     This property works like 'keymap' except that it specifies a keymap
     to use _instead of_ the buffer's local map.  For most purposes
     (perhaps all purposes), it is better to use the 'keymap' property.

'syntax-table'
     The 'syntax-table' property overrides what the syntax table says
     about this particular character.  *Note Syntax Properties::.

'read-only'
     If a character has the property 'read-only', then modifying that
     character is not allowed.  Any command that would do so gets an
     error, 'text-read-only'.  If the property value is a string, that
     string is used as the error message.

     Insertion next to a read-only character is an error if inserting
     ordinary text there would inherit the 'read-only' property due to
     stickiness.  Thus, you can control permission to insert next to
     read-only text by controlling the stickiness.  *Note Sticky
     Properties::.

     Since changing properties counts as modifying the buffer, it is not
     possible to remove a 'read-only' property unless you know the
     special trick: bind 'inhibit-read-only' to a non-'nil' value and
     then remove the property.  *Note Read Only Buffers::.

'inhibit-read-only'
     Characters that have the property 'inhibit-read-only' can be edited
     even in read-only buffers.  *Note Read Only Buffers::.

'invisible'
     A non-'nil' 'invisible' property can make a character invisible on
     the screen.  *Note Invisible Text::, for details.

'intangible'
     If a group of consecutive characters have equal and non-'nil'
     'intangible' properties, then you cannot place point between them.
     If you try to move point forward into the group, point actually
     moves to the end of the group.  If you try to move point backward
     into the group, point actually moves to the start of the group.

     If consecutive characters have unequal non-'nil' 'intangible'
     properties, they belong to separate groups; each group is
     separately treated as described above.

     When the variable 'inhibit-point-motion-hooks' is non-'nil' (as it
     is by default), the 'intangible' property is ignored.

     Beware: this property operates at a very low level, and affects a
     lot of code in unexpected ways.  So use it with extreme caution.  A
     common misuse is to put an intangible property on invisible text,
     which is actually unnecessary since the command loop will move
     point outside of the invisible text at the end of each command
     anyway.  *Note Adjusting Point::.  For these reasons, this property
     is obsolete; use the 'cursor-intangible' property instead.

'cursor-intangible'
     When the minor mode 'cursor-intangible-mode' is turned on, point is
     moved away from any position that has a non-'nil'
     'cursor-intangible' property, just before redisplay happens.

     When the variable 'cursor-sensor-inhibit' is non-'nil', the
     'cursor-intangible' property and the 'cursor-sensor-functions'
     property (described below) are ignored.

'field'
     Consecutive characters with the same 'field' property constitute a
     "field".  Some motion functions including 'forward-word' and
     'beginning-of-line' stop moving at a field boundary.  *Note
     Fields::.

'cursor'
     Normally, the cursor is displayed at the beginning or the end of
     any overlay and text property strings present at the current buffer
     position.  You can place the cursor on any desired character of
     these strings by giving that character a non-'nil' 'cursor' text
     property.  In addition, if the value of the 'cursor' property is an
     integer, it specifies the number of buffer's character positions,
     starting with the position where the overlay or the 'display'
     property begins, for which the cursor should be displayed on that
     character.  Specifically, if the value of the 'cursor' property of
     a character is the number N, the cursor will be displayed on this
     character for any buffer position in the range '[OVPOS..OVPOS+N)',
     where OVPOS is the overlay's starting position given by
     'overlay-start' (*note Managing Overlays::), or the position where
     the 'display' text property begins in the buffer.

     In other words, the string character with the 'cursor' property of
     any non-'nil' value is the character where to display the cursor.
     The value of the property says for which buffer positions to
     display the cursor there.  If the value is an integer N, the cursor
     is displayed there when point is anywhere between the beginning of
     the overlay or 'display' property and N positions after that.  If
     the value is anything else and non-'nil', the cursor is displayed
     there only when point is at the beginning of the 'display' property
     or at 'overlay-start'.

     When the buffer has many overlay strings (e.g., *note
     before-string: Overlay Properties.) that conceal some of the buffer
     text or 'display' properties that are strings, it is a good idea to
     use the 'cursor' property on these strings to cue the Emacs display
     about the places where to put the cursor while traversing these
     strings.  This directly communicates to the display engine where
     the Lisp program wants to put the cursor, or where the user would
     expect the cursor, when point is located on some buffer position
     that is "covered" by the display or overlay string.

'pointer'
     This specifies a specific pointer shape when the mouse pointer is
     over this text or image.  *Note Pointer Shape::, for possible
     pointer shapes.

'line-spacing'
     A newline can have a 'line-spacing' text or overlay property that
     controls the height of the display line ending with that newline.
     The property value overrides the default frame line spacing and the
     buffer local 'line-spacing' variable.  *Note Line Height::.

'line-height'
     A newline can have a 'line-height' text or overlay property that
     controls the total height of the display line ending in that
     newline.  *Note Line Height::.

'wrap-prefix'
     If text has a 'wrap-prefix' property, the prefix it defines will be
     added at display time to the beginning of every continuation line
     due to text wrapping (so if lines are truncated, the wrap-prefix is
     never used).  It may be a string or an image (*note Other Display
     Specs::), or a stretch of whitespace such as specified by the
     ':width' or ':align-to' display properties (*note Specified
     Space::).

     A wrap-prefix may also be specified for an entire buffer using the
     'wrap-prefix' buffer-local variable (however, a 'wrap-prefix'
     text-property takes precedence over the value of the 'wrap-prefix'
     variable).  *Note Truncation::.

'line-prefix'
     If text has a 'line-prefix' property, the prefix it defines will be
     added at display time to the beginning of every non-continuation
     line.  It may be a string or an image (*note Other Display
     Specs::), or a stretch of whitespace such as specified by the
     ':width' or ':align-to' display properties (*note Specified
     Space::).

     A line-prefix may also be specified for an entire buffer using the
     'line-prefix' buffer-local variable (however, a 'line-prefix'
     text-property takes precedence over the value of the 'line-prefix'
     variable).  *Note Truncation::.

'modification-hooks'
     If a character has the property 'modification-hooks', then its
     value should be a list of functions; modifying that character calls
     all of those functions before the actual modification.  Each
     function receives two arguments: the beginning and end of the part
     of the buffer being modified.  Note that if a particular
     modification hook function appears on several characters being
     modified by a single primitive, you can't predict how many times
     the function will be called.  Furthermore, insertion will not
     modify any existing character, so this hook will only be run when
     removing some characters, replacing them with others, or changing
     their text-properties.

     Unlike with other similar hooks, when Emacs calls these functions,
     'inhibit-modification-hooks' does _not_ get bound to non-'nil'.  If
     the functions modify the buffer, you should consider binding this
     variable to non-'nil' to prevent any buffer changes running the
     change hooks.  Otherwise, you must be prepared for recursive calls.
     *Note Change Hooks::.

     Overlays also support the 'modification-hooks' property, but the
     details are somewhat different (*note Overlay Properties::).

'insert-in-front-hooks'
'insert-behind-hooks'
     The operation of inserting text in a buffer also calls the
     functions listed in the 'insert-in-front-hooks' property of the
     following character and in the 'insert-behind-hooks' property of
     the preceding character.  These functions receive two arguments,
     the beginning and end of the inserted text.  The functions are
     called _after_ the actual insertion takes place.

     When these functions are called, 'inhibit-modification-hooks' is
     bound to non-'nil'.  If the functions modify the buffer, you might
     want to bind 'inhibit-modification-hooks' to 'nil', so as to cause
     the change hooks to run for these modifications.  However, doing
     this may call your own change hook recursively, so be sure to
     prepare for that.

     See also *note Change Hooks::, for other hooks that are called when
     you change text in a buffer.

'point-entered'
'point-left'
     The special properties 'point-entered' and 'point-left' record hook
     functions that report motion of point.  Each time point moves,
     Emacs compares these two property values:

        * the 'point-left' property of the character after the old
          location, and
        * the 'point-entered' property of the character after the new
          location.

     If these two values differ, each of them is called (if not 'nil')
     with two arguments: the old value of point, and the new one.

     The same comparison is made for the characters before the old and
     new locations.  The result may be to execute two 'point-left'
     functions (which may be the same function) and/or two
     'point-entered' functions (which may be the same function).  In any
     case, all the 'point-left' functions are called first, followed by
     all the 'point-entered' functions.

     It is possible to use 'char-after' to examine characters at various
     buffer positions without moving point to those positions.  Only an
     actual change in the value of point runs these hook functions.

     The variable 'inhibit-point-motion-hooks' by default inhibits
     running the 'point-left' and 'point-entered' hooks, see *note
     Inhibit point motion hooks::.

     These properties are obsolete; please use 'cursor-sensor-functions'
     instead.

'cursor-sensor-functions'
     This special property records a list of functions that react to
     cursor motion.  Each function in the list is called, just before
     redisplay, with 3 arguments: the affected window, the previous
     known position of the cursor, and one of the symbols 'entered' or
     'left', depending on whether the cursor is entering the text that
     has this property or leaving it.  The functions are called only
     when the minor mode 'cursor-sensor-mode' is turned on.

     When the variable 'cursor-sensor-inhibit' is non-'nil', the
     'cursor-sensor-functions' property is ignored.

'composition'
     This text property is used to display a sequence of characters as a
     single glyph composed from components.  But the value of the
     property itself is completely internal to Emacs and should not be
     manipulated directly by, for instance, 'put-text-property'.

'minibuffer-message'
     This text property tells where to display temporary messages in an
     active minibuffer.  Specifically, the first character of the
     minibuffer text which has this property will have the temporary
     message displayed before it.  The default is to display temporary
     messages at the end of the minibuffer text.  This text property is
     used by the function that is the default value of
     'set-message-function' (*note Displaying Messages::).

 -- Variable: inhibit-point-motion-hooks
     When this obsolete variable is non-'nil', 'point-left' and
     'point-entered' hooks are not run, and the 'intangible' property
     has no effect.  Do not set this variable globally; bind it with
     'let'.  Since the affected properties are obsolete, this variable's
     default value is 't', to effectively disable them.

 -- Variable: show-help-function
     If this variable is non-'nil', it specifies a function called to
     display help strings.  These may be 'help-echo' properties, menu
     help strings (*note Simple Menu Items::, *note Extended Menu
     Items::), or tool bar help strings (*note Tool Bar::).  The
     specified function is called with one argument, the help string to
     display, which is passed through 'substitute-command-keys' before
     being given to the function, unless the help string has a non-'nil'
     'help-echo-inhibit-substitution' property on its first character;
     see *note Keys in Documentation::.  See the code of Tooltip mode
     (*note (emacs)Tooltips::) for an example of a mode that uses
     'show-help-function'.

 -- Variable: face-filters-always-match
     If this variable is non-'nil', face filters that specify attributes
     applied only when certain conditions are met will be deemed to
     match always.

==============================================================================
File: elisp.info,  Node: |Format_Properties|,  Next: |Sticky_Properties|,  Prev: |Special_Properties|,  Up: |Text_Properties|
==============================================================================

                                                             *Format_Properties*

32.19.5 Formatted Text Properties
---------------------------------

These text properties affect the behavior of the fill commands.  They
are used for representing formatted text.  *Note Filling::, and *note
Margins::.

'hard'
     If a newline character has this property, it is a "hard" newline.
     The fill commands do not alter hard newlines and do not move words
     across them.  However, this property takes effect only if the
     'use-hard-newlines' minor mode is enabled.  *Note Hard and Soft
     Newlines: (emacs)Hard and Soft Newlines.

'right-margin'
     This property specifies an extra right margin for filling this part
     of the text.

'left-margin'
     This property specifies an extra left margin for filling this part
     of the text.

'justification'
     This property specifies the style of justification for filling this
     part of the text.

==============================================================================
File: elisp.info,  Node: |Sticky_Properties|,  Next: |Lazy_Properties|,  Prev: |Format_Properties|,  Up: |Text_Properties|
==============================================================================

                                                             *Sticky_Properties*

32.19.6 Stickiness of Text Properties
-------------------------------------

Self-inserting characters, the ones that get inserted into a buffer when
the user types them (*note Commands for Insertion::), normally take on
the same properties as the preceding character.  This is called
"inheritance" of properties.

   By contrast, a Lisp program can do insertion with inheritance or
without, depending on the choice of insertion primitive.  The ordinary
text insertion functions, such as 'insert', do not inherit any
properties.  They insert text with precisely the properties of the
string being inserted, and no others.  This is correct for programs that
copy text from one context to another--for example, into or out of the
kill ring.  To insert with inheritance, use the special primitives
described in this section.  Self-inserting characters inherit properties
because they work using these primitives.

   When you do insertion with inheritance, _which_ properties are
inherited, and from where, depends on which properties are "sticky".
Insertion after a character inherits those of its properties that are
"rear-sticky".  Insertion before a character inherits those of its
properties that are "front-sticky".  When both sides offer different
sticky values for the same property, the previous character's value
takes precedence.

   By default, a text property is rear-sticky but not front-sticky;
thus, the default is to inherit all the properties of the preceding
character, and nothing from the following character.

   You can control the stickiness of various text properties with two
specific text properties, 'front-sticky' and 'rear-nonsticky', and with
the variable 'text-property-default-nonsticky'.  You can use the
variable to specify a different default for a given property.  You can
use those two text properties to make any specific properties sticky or
nonsticky in any particular part of the text.

   If a character's 'front-sticky' property is 't', then all its
properties are front-sticky.  If the 'front-sticky' property is a list,
then the sticky properties of the character are those whose names are in
the list.  For example, if a character has a 'front-sticky' property
whose value is '(face read-only)', then insertion before the character
can inherit its 'face' property and its 'read-only' property, but no
others.

   The 'rear-nonsticky' property works the opposite way.  Most
properties are rear-sticky by default, so the 'rear-nonsticky' property
says which properties are _not_ rear-sticky.  If a character's
'rear-nonsticky' property is 't', then none of its properties are
rear-sticky.  If the 'rear-nonsticky' property is a list, properties are
rear-sticky _unless_ their names are in the list.

 -- Variable: text-property-default-nonsticky
     This variable holds an alist which defines the default
     rear-stickiness of various text properties.  Each element has the
     form '(PROPERTY . NONSTICKINESS)', and it defines the stickiness of
     a particular text property, PROPERTY.

     If NONSTICKINESS is non-'nil', this means that the property
     PROPERTY is rear-nonsticky by default.  Since all properties are
     front-nonsticky by default, this makes PROPERTY nonsticky in both
     directions by default.

     The text properties 'front-sticky' and 'rear-nonsticky', when used,
     take precedence over the default NONSTICKINESS specified in
     'text-property-default-nonsticky'.

   Here are the functions that insert text with inheritance of
properties:

 -- Function: insert-and-inherit &rest strings
     Insert the strings STRINGS, just like the function 'insert', but
     inherit any sticky properties from the adjoining text.

 -- Function: insert-before-markers-and-inherit &rest strings
     Insert the strings STRINGS, just like the function
     'insert-before-markers', but inherit any sticky properties from the
     adjoining text.

   *Note Insertion::, for the ordinary insertion functions which do not
inherit.

==============================================================================
File: elisp.info,  Node: |Lazy_Properties|,  Next: |Clickable_Text|,  Prev: |Sticky_Properties|,  Up: |Text_Properties|
==============================================================================

                                                               *Lazy_Properties*

32.19.7 Lazy Computation of Text Properties
-------------------------------------------

Instead of computing text properties for all the text in the buffer, you
can arrange to compute the text properties for parts of the text when
and if something depends on them.

   The primitive that extracts text from the buffer along with its
properties is 'buffer-substring'.  Before examining the properties, this
function runs the abnormal hook 'buffer-access-fontify-functions'.

 -- Variable: buffer-access-fontify-functions
     This variable holds a list of functions for computing text
     properties.  Before 'buffer-substring' copies the text and text
     properties for a portion of the buffer, it calls all the functions
     in this list.  Each of the functions receives two arguments that
     specify the range of the buffer being accessed.  (The buffer itself
     is always the current buffer.)

   The function 'buffer-substring-no-properties' does not call these
functions, since it ignores text properties anyway.

   In order to prevent the hook functions from being called more than
once for the same part of the buffer, you can use the variable
'buffer-access-fontified-property'.

 -- Variable: buffer-access-fontified-property
     If this variable's value is non-'nil', it is a symbol which is used
     as a text property name.  A non-'nil' value for that text property
     means the other text properties for this character have already
     been computed.

     If all the characters in the range specified for 'buffer-substring'
     have a non-'nil' value for this property, 'buffer-substring' does
     not call the 'buffer-access-fontify-functions' functions.  It
     assumes these characters already have the right text properties,
     and just copies the properties they already have.

     The normal way to use this feature is that the
     'buffer-access-fontify-functions' functions add this property, as
     well as others, to the characters they operate on.  That way, they
     avoid being called over and over for the same text.

==============================================================================
File: elisp.info,  Node: |Clickable_Text|,  Next: |Fields|,  Prev: |Lazy_Properties|,  Up: |Text_Properties|
==============================================================================

                                                                *Clickable_Text*

32.19.8 Defining Clickable Text
-------------------------------

"Clickable text" is text that can be clicked, with either the mouse or
via a keyboard command, to produce some result.  Many major modes use
clickable text to implement textual hyper-links, or "links" for short.

   The easiest way to insert and manipulate links is to use the 'button'
package.  *Note Buttons::.  In this section, we will explain how to
manually set up clickable text in a buffer, using text properties.  For
simplicity, we will refer to the clickable text as a "link".

   Implementing a link involves three separate steps: (1) indicating
clickability when the mouse moves over the link; (2) making <RET> or
'mouse-2' on that link do something; and (3) setting up a 'follow-link'
condition so that the link obeys 'mouse-1-click-follows-link'.

   To indicate clickability, add the 'mouse-face' text property to the
text of the link; then Emacs will highlight the link when the mouse
moves over it.  In addition, you should define a tooltip or echo area
message, using the 'help-echo' text property.  *Note Special
Properties::.  For instance, here is how Dired indicates that file names
are clickable:

      (if (dired-move-to-filename)
          (add-text-properties
            (point)
            (save-excursion
              (dired-move-to-end-of-filename)
              (point))
            '(mouse-face highlight
              help-echo "mouse-2: visit this file in other window")))

   To make the link clickable, bind <RET> and 'mouse-2' to commands that
perform the desired action.  Each command should check to see whether it
was called on a link, and act accordingly.  For instance, Dired's major
mode keymap binds 'mouse-2' to the following command:

     (defun dired-mouse-find-file-other-window (event)
       "In Dired, visit the file or directory name you click on."
       (interactive "e")
       (let ((window (posn-window (event-end event)))
             (pos (posn-point (event-end event)))
             file)
         (if (not (windowp window))
             (error "No file chosen"))
         (with-current-buffer (window-buffer window)
           (goto-char pos)
           (setq file (dired-get-file-for-visit)))
         (if (file-directory-p file)
             (or (and (cdr dired-subdir-alist)
                      (dired-goto-subdir file))
                 (progn
                   (select-window window)
                   (dired-other-window file)))
           (select-window window)
           (find-file-other-window (file-name-sans-versions file t)))))

This command uses the functions 'posn-window' and 'posn-point' to
determine where the click occurred, and 'dired-get-file-for-visit' to
determine which file to visit.

   Instead of binding the mouse command in a major mode keymap, you can
bind it within the link text, using the 'keymap' text property (*note
Special Properties::).  For instance:

     (let ((map (make-sparse-keymap)))
       (define-key map [mouse-2] 'operate-this-button)
       (put-text-property link-start link-end 'keymap map))

With this method, you can easily define different commands for different
links.  Furthermore, the global definition of <RET> and 'mouse-2' remain
available for the rest of the text in the buffer.

   The basic Emacs command for clicking on links is 'mouse-2'.  However,
for compatibility with other graphical applications, Emacs also
recognizes 'mouse-1' clicks on links, provided the user clicks on the
link quickly without moving the mouse.  This behavior is controlled by
the user option 'mouse-1-click-follows-link'.  *Note (emacs)Mouse
References::.

   To set up the link so that it obeys 'mouse-1-click-follows-link', you
must either (1) apply a 'follow-link' text or overlay property to the
link text, or (2) bind the 'follow-link' event to a keymap (which can be
a major mode keymap or a local keymap specified via the 'keymap' text
property).  The value of the 'follow-link' property, or the binding for
the 'follow-link' event, acts as a condition for the link action.  This
condition tells Emacs two things: the circumstances under which a
'mouse-1' click should be regarded as occurring inside the link, and how
to compute an action code that says what to translate the 'mouse-1'
click into.  The link action condition can be one of the following:

'mouse-face'
     If the condition is the symbol 'mouse-face', a position is inside a
     link if there is a non-'nil' 'mouse-face' property at that
     position.  The action code is always 't'.

     For example, here is how Info mode handles <mouse-1>:

          (define-key Info-mode-map [follow-link] 'mouse-face)

a function
     If the condition is a function, FUNC, then a position POS is inside
     a link if '(FUNC POS)' evaluates to non-'nil'.  The value returned
     by FUNC serves as the action code.

     For example, here is how pcvs enables 'mouse-1' to follow links on
     file names only:

          (define-key map [follow-link]
            (lambda (pos)
              (eq (get-char-property pos 'face) 'cvs-filename-face)))

anything else
     If the condition value is anything else, then the position is
     inside a link and the condition itself is the action code.
     Clearly, you should specify this kind of condition only when
     applying the condition via a text or property overlay on the link
     text (so that it does not apply to the entire buffer).

The action code tells 'mouse-1' how to follow the link:

a string or vector
     If the action code is a string or vector, the 'mouse-1' event is
     translated into the first element of the string or vector; i.e.,
     the action of the 'mouse-1' click is the local or global binding of
     that character or symbol.  Thus, if the action code is '"foo"',
     'mouse-1' translates into 'f'.  If it is '[foo]', 'mouse-1'
     translates into <foo>.

anything else
     For any other non-'nil' action code, the 'mouse-1' event is
     translated into a 'mouse-2' event at the same position.

   To define 'mouse-1' to activate a button defined with
'define-button-type', give the button a 'follow-link' property.  The
property value should be a link action condition, as described above.
*Note Buttons::.  For example, here is how Help mode handles 'mouse-1':

     (define-button-type 'help-xref
       'follow-link t
       'action #'help-button-action)

   To define 'mouse-1' on a widget defined with 'define-widget', give
the widget a ':follow-link' property.  The property value should be a
link action condition, as described above.  For example, here is how the
'link' widget specifies that a <mouse-1> click shall be translated to
<RET>:

     (define-widget 'link 'item
       "An embedded link."
       :button-prefix 'widget-link-prefix
       :button-suffix 'widget-link-suffix
       :follow-link "\C-m"
       :help-echo "Follow the link."
       :format "%[%t%]")

 -- Function: mouse-on-link-p pos
     This function returns non-'nil' if position POS in the current
     buffer is on a link.  POS can also be a mouse event location, as
     returned by 'event-start' (*note Accessing Mouse::).

==============================================================================
File: elisp.info,  Node: |Fields|,  Next: |Not_Intervals|,  Prev: |Clickable_Text|,  Up: |Text_Properties|
==============================================================================

                                                                        *Fields*

32.19.9 Defining and Using Fields
---------------------------------

A field is a range of consecutive characters in the buffer that are
identified by having the same value (comparing with 'eq') of the 'field'
property (either a text-property or an overlay property).  This section
describes special functions that are available for operating on fields.

   You specify a field with a buffer position, POS.  We think of each
field as containing a range of buffer positions, so the position you
specify stands for the field containing that position.

   When the characters before and after POS are part of the same field,
there is no doubt which field contains POS: the one those characters
both belong to.  When POS is at a boundary between fields, which field
it belongs to depends on the stickiness of the 'field' properties of the
two surrounding characters (*note Sticky Properties::).  The field whose
property would be inherited by text inserted at POS is the field that
contains POS.

   There is an anomalous case where newly inserted text at POS would not
inherit the 'field' property from either side.  This happens if the
previous character's 'field' property is not rear-sticky, and the
following character's 'field' property is not front-sticky.  In this
case, POS belongs to neither the preceding field nor the following
field; the field functions treat it as belonging to an empty field whose
beginning and end are both at POS.

   In all of these functions, if POS is omitted or 'nil', the value of
point is used by default.  If narrowing is in effect, then POS should
fall within the accessible portion.  *Note Narrowing::.

 -- Function: field-beginning &optional pos escape-from-edge limit
     This function returns the beginning of the field specified by POS.

     If POS is at the beginning of its field, and ESCAPE-FROM-EDGE is
     non-'nil', then the return value is always the beginning of the
     preceding field that _ends_ at POS, regardless of the stickiness of
     the 'field' properties around POS.

     If LIMIT is non-'nil', it is a buffer position; if the beginning of
     the field is before LIMIT, then LIMIT will be returned instead.

 -- Function: field-end &optional pos escape-from-edge limit
     This function returns the end of the field specified by POS.

     If POS is at the end of its field, and ESCAPE-FROM-EDGE is
     non-'nil', then the return value is always the end of the following
     field that _begins_ at POS, regardless of the stickiness of the
     'field' properties around POS.

     If LIMIT is non-'nil', it is a buffer position; if the end of the
     field is after LIMIT, then LIMIT will be returned instead.

 -- Function: field-string &optional pos
     This function returns the contents of the field specified by POS,
     as a string.

 -- Function: field-string-no-properties &optional pos
     This function returns the contents of the field specified by POS,
     as a string, discarding text properties.

 -- Function: delete-field &optional pos
     This function deletes the text of the field specified by POS.

 -- Function: constrain-to-field new-pos old-pos &optional
          escape-from-edge only-in-line inhibit-capture-property
     This function constrains NEW-POS to the field that OLD-POS belongs
     to--in other words, it returns the position closest to NEW-POS that
     is in the same field as OLD-POS.

     If NEW-POS is 'nil', then 'constrain-to-field' uses the value of
     point instead, and moves point to the resulting position in
     addition to returning that position.

     If OLD-POS is at the boundary of two fields, then the acceptable
     final positions depend on the argument ESCAPE-FROM-EDGE.  If
     ESCAPE-FROM-EDGE is 'nil', then NEW-POS must be in the field whose
     'field' property equals what new characters inserted at OLD-POS
     would inherit.  (This depends on the stickiness of the 'field'
     property for the characters before and after OLD-POS.)  If
     ESCAPE-FROM-EDGE is non-'nil', NEW-POS can be anywhere in the two
     adjacent fields.  Additionally, if two fields are separated by
     another field with the special value 'boundary', then any point
     within this special field is also considered to be on the boundary.

     Commands like 'C-a' with no argument, that normally move backward
     to a specific kind of location and stay there once there, probably
     should specify 'nil' for ESCAPE-FROM-EDGE.  Other motion commands
     that check fields should probably pass 't'.

     If the optional argument ONLY-IN-LINE is non-'nil', and
     constraining NEW-POS in the usual way would move it to a different
     line, NEW-POS is returned unconstrained.  This used in commands
     that move by line, such as 'next-line' and 'beginning-of-line', so
     that they respect field boundaries only in the case where they can
     still move to the right line.

     If the optional argument INHIBIT-CAPTURE-PROPERTY is non-'nil', and
     OLD-POS has a non-'nil' property of that name, then any field
     boundaries are ignored.

     You can cause 'constrain-to-field' to ignore all field boundaries
     (and so never constrain anything) by binding the variable
     'inhibit-field-text-motion' to a non-'nil' value.

==============================================================================
File: elisp.info,  Node: |Not_Intervals|,  Prev: |Fields|,  Up: |Text_Properties|
==============================================================================

                                                                 *Not_Intervals*

32.19.10 Why Text Properties are not Intervals
----------------------------------------------

Some editors that support adding attributes to text in the buffer do so
by letting the user specify intervals within the text, and adding the
properties to the intervals.  Those editors permit the user or the
programmer to determine where individual intervals start and end.  We
deliberately provided a different sort of interface in Emacs Lisp to
avoid certain paradoxical behavior associated with text modification.

   If the actual subdivision into intervals is meaningful, that means
you can distinguish between a buffer that is just one interval with a
certain property, and a buffer containing the same text subdivided into
two intervals, both of which have that property.

   Suppose you take the buffer with just one interval and kill part of
the text.  The text remaining in the buffer is one interval, and the
copy in the kill ring (and the undo list) becomes a separate interval.
Then if you yank back the killed text, you get two intervals with the
same properties.  Thus, editing does not preserve the distinction
between one interval and two.

   Suppose we attempt to fix this problem by coalescing the two
intervals when the text is inserted.  That works fine if the buffer
originally was a single interval.  But suppose instead that we have two
adjacent intervals with the same properties, and we kill the text of one
interval and yank it back.  The same interval-coalescence feature that
rescues the other case causes trouble in this one: after yanking, we
have just one interval.  Once again, editing does not preserve the
distinction between one interval and two.

   Insertion of text at the border between intervals also raises
questions that have no satisfactory answer.

   However, it is easy to arrange for editing to behave consistently for
questions of the form, "What are the properties of text at this buffer
or string position?" So we have decided these are the only questions
that make sense; we have not implemented asking questions about where
intervals start or end.

   In practice, you can usually use the text property search functions
in place of explicit interval boundaries.  You can think of them as
finding the boundaries of intervals, assuming that intervals are always
coalesced whenever possible.  *Note Property Search::.

   Emacs also provides explicit intervals as a presentation feature; see
*note Overlays::.

==============================================================================
File: elisp.info,  Node: |Substitution|,  Next: |Registers|,  Prev: |Text_Properties|,  Up: |Text|
==============================================================================

                                                                  *Substitution*

32.20 Substituting for a Character Code
---------------------------------------

The following functions replace characters within a specified region
based on their character codes.

 -- Function: subst-char-in-region start end old-char new-char &optional
          noundo
     This function replaces all occurrences of the character OLD-CHAR
     with the character NEW-CHAR in the region of the current buffer
     defined by START and END.

     If NOUNDO is non-'nil', then 'subst-char-in-region' does not record
     the change for undo and does not mark the buffer as modified.  This
     was useful for controlling the old selective display feature (*note
     Selective Display::).

     'subst-char-in-region' does not move point and returns 'nil'.

          ---------- Buffer: foo ----------
          This is the contents of the buffer before.
          ---------- Buffer: foo ----------

          (subst-char-in-region 1 20 ?i ?X)
               => nil

          ---------- Buffer: foo ----------
          ThXs Xs the contents of the buffer before.
          ---------- Buffer: foo ----------

 -- Command: translate-region start end table
     This function applies a translation table to the characters in the
     buffer between positions START and END.

     The translation table TABLE is a string or a char-table; '(aref
     TABLE OCHAR)' gives the translated character corresponding to
     OCHAR.  If TABLE is a string, any characters with codes larger than
     the length of TABLE are not altered by the translation.

     The return value of 'translate-region' is the number of characters
     that were actually changed by the translation.  This does not count
     characters that were mapped into themselves in the translation
     table.

==============================================================================
File: elisp.info,  Node: |Registers|,  Next: |Transposition|,  Prev: |Substitution|,  Up: |Text|
==============================================================================

                                                                     *Registers*

32.21 Registers
---------------

A register is a sort of variable used in Emacs editing that can hold a
variety of different kinds of values.  Each register is named by a
single character.  All ASCII characters and their meta variants (but
with the exception of 'C-g') can be used to name registers.  Thus, there
are 255 possible registers.  A register is designated in Emacs Lisp by
the character that is its name.

 -- Variable: register-alist
     This variable is an alist of elements of the form '(NAME .
     CONTENTS)'.  Normally, there is one element for each Emacs register
     that has been used.

     The object NAME is a character (an integer) identifying the
     register.

   The CONTENTS of a register can have several possible types:

a number
     A number stands for itself.  If 'insert-register' finds a number in
     the register, it converts the number to decimal.

a marker
     A marker represents a buffer position to jump to.

a string
     A string is text saved in the register.

a rectangle
     A rectangle is represented by a list of strings.

'(WINDOW-CONFIGURATION POSITION)'
     This represents a window configuration to restore in one frame, and
     a position to jump to in the current buffer.

'(FRAME-CONFIGURATION POSITION)'
     This represents a frame configuration to restore, and a position to
     jump to in the current buffer.

(file FILENAME)
     This represents a file to visit; jumping to this value visits file
     FILENAME.

(file-query FILENAME POSITION)
     This represents a file to visit and a position in it; jumping to
     this value visits file FILENAME and goes to buffer position
     POSITION.  Restoring this type of position asks the user for
     confirmation first.

   The functions in this section return unpredictable values unless
otherwise stated.

 -- Function: get-register reg
     This function returns the contents of the register REG, or 'nil' if
     it has no contents.

 -- Function: set-register reg value
     This function sets the contents of register REG to VALUE.  A
     register can be set to any value, but the other register functions
     expect only certain data types.  The return value is VALUE.

 -- Command: view-register reg
     This command displays what is contained in register REG.

 -- Command: insert-register reg &optional beforep
     This command inserts contents of register REG into the current
     buffer.

     Normally, this command puts point before the inserted text, and the
     mark after it.  However, if the optional second argument BEFOREP is
     non-'nil', it puts the mark before and point after.

     When called interactively, the command defaults to putting point
     after text, and a prefix argument inverts this behavior.

     If the register contains a rectangle, then the rectangle is
     inserted with its upper left corner at point.  This means that text
     is inserted in the current line and underneath it on successive
     lines.

     If the register contains something other than saved text (a string)
     or a rectangle (a list), currently useless things happen.  This may
     be changed in the future.

 -- Function: register-read-with-preview prompt
     This function reads and returns a register name, prompting with
     PROMPT and possibly showing a preview of the existing registers and
     their contents.  The preview is shown in a temporary window, after
     the delay specified by the user option 'register-preview-delay', if
     its value and 'register-alist' are both non-'nil'.  The preview is
     also shown if the user requests help (e.g., by typing the help
     character).  We recommend that all interactive commands which read
     register names use this function.

==============================================================================
File: elisp.info,  Node: |Transposition|,  Next: |Replacing|,  Prev: |Registers|,  Up: |Text|
==============================================================================

                                                                 *Transposition*

32.22 Transposition of Text
---------------------------

This function can be used to transpose stretches of text:

 -- Function: transpose-regions start1 end1 start2 end2 &optional
          leave-markers
     This function exchanges two nonoverlapping portions of the buffer
     (if they overlap, the function signals an error).  Arguments START1
     and END1 specify the bounds of one portion and arguments START2 and
     END2 specify the bounds of the other portion.

     Normally, 'transpose-regions' relocates markers with the transposed
     text; a marker previously positioned within one of the two
     transposed portions moves along with that portion, thus remaining
     between the same two characters in their new position.  However, if
     LEAVE-MARKERS is non-'nil', 'transpose-regions' does not do this--it
     leaves all markers unrelocated.

==============================================================================
File: elisp.info,  Node: |Replacing|,  Next: |Decompression|,  Prev: |Transposition|,  Up: |Text|
==============================================================================

                                                                     *Replacing*

32.23 Replacing Buffer Text
---------------------------

You can use the following function to replace the text of one buffer
with the text of another buffer:

 -- Command: replace-buffer-contents source &optional max-secs max-costs
     This function replaces the accessible portion of the current buffer
     with the accessible portion of the buffer SOURCE.  SOURCE may
     either be a buffer object or the name of a buffer.  When
     'replace-buffer-contents' succeeds, the text of the accessible
     portion of the current buffer will be equal to the text of the
     accessible portion of the SOURCE buffer.

     This function attempts to keep point, markers, text properties, and
     overlays in the current buffer intact.  One potential case where
     this behavior is useful is external code formatting programs: they
     typically write the reformatted text into a temporary buffer or
     file, and using 'delete-region' and 'insert-buffer-substring' would
     destroy these properties.  However, the latter combination is
     typically faster (*Note Deletion::, and *note Insertion::).

     For its working, 'replace-buffer-contents' needs to compare the
     contents of the original buffer with that of SOURCE which is a
     costly operation if the buffers are huge and there is a high number
     of differences between them.  In order to keep
     'replace-buffer-contents''s runtime in bounds, it has two optional
     arguments.

     MAX-SECS defines a hard boundary in terms of seconds.  If given and
     exceeded, it will fall back to 'delete-region' and
     'insert-buffer-substring'.

     MAX-COSTS defines the quality of the difference computation.  If
     the actual costs exceed this limit, heuristics are used to provide
     a faster but suboptimal solution.  The default value is 1000000.

     'replace-buffer-contents' returns t if a non-destructive
     replacement could be performed.  Otherwise, i.e., if MAX-SECS was
     exceeded, it returns nil.

 -- Function: replace-region-contents beg end replace-fn &optional
          max-secs max-costs
     This function replaces the region between BEG and END using the
     given REPLACE-FN.  The function REPLACE-FN is run in the current
     buffer narrowed to the specified region and it should return either
     a string or a buffer replacing the region.

     The replacement is performed using 'replace-buffer-contents' (see
     above) which also describes the MAX-SECS and MAX-COSTS arguments
     and the return value.

     Note: If the replacement is a string, it will be placed in a
     temporary buffer so that 'replace-buffer-contents' can operate on
     it.  Therefore, if you already have the replacement in a buffer, it
     makes no sense to convert it to a string using 'buffer-substring'
     or similar.

==============================================================================
File: elisp.info,  Node: |Decompression|,  Next: |Base_64|,  Prev: |Replacing|,  Up: |Text|
==============================================================================

                                                                 *Decompression*

32.24 Dealing With Compressed Data
----------------------------------

When 'auto-compression-mode' is enabled, Emacs automatically
uncompresses compressed files when you visit them, and automatically
recompresses them if you alter and save them.  *Note (emacs)Compressed
Files::.

   The above feature works by calling an external executable (e.g.,
'gzip').  Emacs can also be compiled with support for built-in
decompression using the zlib library, which is faster than calling an
external program.

 -- Function: zlib-available-p
     This function returns non-'nil' if built-in zlib decompression is
     available.

 -- Function: zlib-decompress-region start end &optional allow-partial
     This function decompresses the region between START and END, using
     built-in zlib decompression.  The region should contain data that
     were compressed with gzip or zlib.  On success, the function
     replaces the contents of the region with the decompressed data.  If
     ALLOW-PARTIAL is 'nil' or omitted, then on failure, the function
     leaves the region unchanged and returns 'nil'.  Otherwise, it
     returns the number of bytes that were not decompressed and replaces
     the region text by whatever data was successfully decompressed.
     This function can be called only in unibyte buffers.

==============================================================================
File: elisp.info,  Node: |Base_64|,  Next: |Checksum/Hash|,  Prev: |Decompression|,  Up: |Text|
==============================================================================

                                                                       *Base_64*

32.25 Base 64 Encoding
----------------------

Base 64 code is used in email to encode a sequence of 8-bit bytes as a
longer sequence of ASCII graphic characters.  It is defined in Internet
RFC(1)2045 and also in RFC 4648.  This section describes the functions
for converting to and from this code.

 -- Command: base64-encode-region beg end &optional no-line-break
     This function converts the region from BEG to END into base 64
     code.  It returns the length of the encoded text.  An error is
     signaled if a character in the region is multibyte, i.e., in a
     multibyte buffer the region must contain only characters from the
     charsets 'ascii', 'eight-bit-control' and 'eight-bit-graphic'.

     Normally, this function inserts newline characters into the encoded
     text, to avoid overlong lines.  However, if the optional argument
     NO-LINE-BREAK is non-'nil', these newlines are not added, so the
     output is just one long line.

 -- Command: base64url-encode-region beg end &optional no-pad
     This function is like 'base64-encode-region', but it implements the
     URL variant of base 64 encoding, per RFC 4648, and it doesn't
     insert newline characters into the encoded text, so the output is
     just one long line.

     If the optional argument NO-PAD is non-'nil' then this function
     doesn't generate the padding ('=').

 -- Function: base64-encode-string string &optional no-line-break
     This function converts the string STRING into base 64 code.  It
     returns a string containing the encoded text.  As for
     'base64-encode-region', an error is signaled if a character in the
     string is multibyte.

     Normally, this function inserts newline characters into the encoded
     text, to avoid overlong lines.  However, if the optional argument
     NO-LINE-BREAK is non-'nil', these newlines are not added, so the
     result string is just one long line.

 -- Function: base64url-encode-string string &optional no-pad
     Like 'base64-encode-string', but generates the URL variant of base
     64, and doesn't insert newline characters into the encoded text, so
     the result is just one long line.

     If the optional argument NO-PAD is non-'nil' then this function
     doesn't generate the padding.

 -- Command: base64-decode-region beg end &optional base64url
     This function converts the region from BEG to END from base 64 code
     into the corresponding decoded text.  It returns the length of the
     decoded text.

     The decoding functions ignore newline characters in the encoded
     text.

     If optional argument BASE64URL is non-'nil', then padding is
     optional, and the URL variant of base 64 encoding is used.

 -- Function: base64-decode-string string &optional base64url
     This function converts the string STRING from base 64 code into the
     corresponding decoded text.  It returns a unibyte string containing
     the decoded text.

     The decoding functions ignore newline characters in the encoded
     text.

     If optional argument BASE64URL is non-'nil', then padding is
     optional, and the URL variant of base 64 encoding is used.

   ---------- Footnotes ----------

   (1) An RFC, an acronym for "Request for Comments", is a numbered
Internet informational document describing a standard.  RFCs are usually
written by technical experts acting on their own initiative, and are
traditionally written in a pragmatic, experience-driven manner.

==============================================================================
File: elisp.info,  Node: |Checksum/Hash|,  Next: |GnuTLS_Cryptography|,  Prev: |Base_64|,  Up: |Text|
==============================================================================

                                                                 *Checksum/Hash*

32.26 Checksum/Hash
-------------------

Emacs has built-in support for computing "cryptographic hashes".  A
cryptographic hash, or "checksum", is a digital fingerprint of a piece
of data (e.g., a block of text) which can be used to check that you have
an unaltered copy of that data.

   Emacs supports several common cryptographic hash algorithms: MD5,
SHA-1, SHA-2, SHA-224, SHA-256, SHA-384 and SHA-512.  MD5 is the oldest
of these algorithms, and is commonly used in "message digests" to check
the integrity of messages transmitted over a network.  MD5 and SHA-1 are
not collision resistant (i.e., it is possible to deliberately design
different pieces of data which have the same MD5 or SHA-1 hash), so you
should not use them for anything security-related.  For security-related
applications you should use the other hash types, such as SHA-2 (e.g.
'sha256' or 'sha512').

 -- Function: secure-hash-algorithms
     This function returns a list of symbols representing algorithms
     that 'secure-hash' can use.

 -- Function: secure-hash algorithm object &optional start end binary
     This function returns a hash for OBJECT.  The argument ALGORITHM is
     a symbol stating which hash to compute: one of 'md5', 'sha1',
     'sha224', 'sha256', 'sha384' or 'sha512'.  The argument OBJECT
     should be a buffer or a string.

     The optional arguments START and END are character positions
     specifying the portion of OBJECT to compute the message digest for.
     If they are 'nil' or omitted, the hash is computed for the whole of
     OBJECT.

     If the argument BINARY is omitted or 'nil', the function returns
     the "text form" of the hash, as an ordinary Lisp string.  If BINARY
     is non-'nil', it returns the hash in "binary form", as a sequence
     of bytes stored in a unibyte string.

     This function does not compute the hash directly from the internal
     representation of OBJECT's text (*note Text Representations::).
     Instead, it encodes the text using a coding system (*note Coding
     Systems::), and computes the hash from that encoded text.  If
     OBJECT is a buffer, the coding system used is the one which would
     be chosen by default for writing the text into a file.  If OBJECT
     is a string, the user's preferred coding system is used (*note
     (emacs)Recognize Coding::).

 -- Function: md5 object &optional start end coding-system noerror
     This function returns an MD5 hash.  It is semi-obsolete, since for
     most purposes it is equivalent to calling 'secure-hash' with 'md5'
     as the ALGORITHM argument.  The OBJECT, START and END arguments
     have the same meanings as in 'secure-hash'.

     If CODING-SYSTEM is non-'nil', it specifies a coding system to use
     to encode the text; if omitted or 'nil', the default coding system
     is used, like in 'secure-hash'.

     Normally, 'md5' signals an error if the text can't be encoded using
     the specified or chosen coding system.  However, if NOERROR is
     non-'nil', it silently uses 'raw-text' coding instead.

 -- Function: buffer-hash &optional buffer-or-name
     Return a hash of BUFFER-OR-NAME.  If 'nil', this defaults to the
     current buffer.  As opposed to 'secure-hash', this function
     computes the hash based on the internal representation of the
     buffer, disregarding any coding systems.  It's therefore only
     useful when comparing two buffers running in the same Emacs, and is
     not guaranteed to return the same hash between different Emacs
     versions.  It should be somewhat more efficient on larger buffers
     than 'secure-hash' is, and should not allocate more memory.

==============================================================================
File: elisp.info,  Node: |GnuTLS_Cryptography|,  Next: |Parsing_HTML/XML|,  Prev: |Checksum/Hash|,  Up: |Text|
==============================================================================

                                                           *GnuTLS_Cryptography*

32.27 GnuTLS Cryptography
-------------------------

If compiled with GnuTLS, Emacs offers built-in cryptographic support.
Following the GnuTLS API terminology, the available tools are digests,
MACs, symmetric ciphers, and AEAD ciphers.

   The terms used herein, such as IV (Initialization Vector), require
some familiarity with cryptography and will not be defined in detail.
Please consult <https://www.gnutls.org/> for specific documentation
which may help you understand the terminology and structure of the
GnuTLS library.

MENU

* |Format_of_GnuTLS_Cryptography_Inputs|::
* |GnuTLS_Cryptographic_Functions|::

==============================================================================
File: elisp.info,  Node: |Format_of_GnuTLS_Cryptography_Inputs|,  Next: |GnuTLS_Cryptographic_Functions|,  Up: |GnuTLS_Cryptography|
==============================================================================

                                          *Format_of_GnuTLS_Cryptography_Inputs*

32.27.1 Format of GnuTLS Cryptography Inputs
--------------------------------------------

The inputs to GnuTLS cryptographic functions can be specified in several
ways, both as primitive Emacs Lisp types or as lists.

   The list form is currently similar to how 'md5' and 'secure-hash'
operate.

'BUFFER'
     Simply passing a buffer as input means the whole buffer should be
     used.

'STRING'
     A string as input will be used directly.  It may be modified by the
     function (unlike most other Emacs Lisp functions) to reduce the
     chance of exposing sensitive data after the function does its work.

'(BUFFER-OR-STRING START END CODING-SYSTEM NOERROR)'
     This specifies a buffer or a string as described above, but an
     optional range can be specified with START and END.

     In addition an optional CODING-SYSTEM can be specified if needed.

     The last optional item, NOERROR, overrides the normal error when
     the text can't be encoded using the specified or chosen coding
     system.  When NOERROR is non-'nil', this function silently uses
     'raw-text' coding instead.

'(iv-auto LENGTH)'
     This will generate an IV (Initialization Vector) of the specified
     length using the GnuTLS 'GNUTLS_RND_NONCE' generator and pass it to
     the function.  This ensures that the IV is unpredictable and
     unlikely to be reused in the same session.  The actual value of the
     IV is returned by the function as described below.

==============================================================================
File: elisp.info,  Node: |GnuTLS_Cryptographic_Functions|,  Prev: |Format_of_GnuTLS_Cryptography_Inputs|,  Up: |GnuTLS_Cryptography|
==============================================================================

                                                *GnuTLS_Cryptographic_Functions*

32.27.2 GnuTLS Cryptographic Functions
--------------------------------------

 -- Function: gnutls-digests
     This function returns the alist of the GnuTLS digest algorithms.

     Each entry has a key which represents the algorithm, followed by a
     plist with internal details about the algorithm.  The plist will
     have ':type gnutls-digest-algorithm' and also will have the key
     ':digest-algorithm-length 64' to indicate the size, in bytes, of
     the resulting digest.

     There is a name parallel between GnuTLS MAC and digest algorithms
     but they are separate things internally and should not be mixed.

 -- Function: gnutls-hash-digest digest-method input
     The DIGEST-METHOD can be the whole plist from 'gnutls-digests', or
     just the symbol key, or a string with the name of that symbol.

     The INPUT can be specified as a buffer or string or in other ways
     (*note Format of GnuTLS Cryptography Inputs::).

     This function returns 'nil' on error, and signals a Lisp error if
     the DIGEST-METHOD or INPUT are invalid.  On success, it returns a
     list of a binary string (the output) and the IV used.

 -- Function: gnutls-macs
     This function returns the alist of the GnuTLS MAC algorithms.

     Each entry has a key which represents the algorithm, followed by a
     plist with internal details about the algorithm.  The plist will
     have ':type gnutls-mac-algorithm' and also will have the keys
     ':mac-algorithm-length' ':mac-algorithm-keysize'
     ':mac-algorithm-noncesize' to indicate the size, in bytes, of the
     resulting hash, the key, and the nonce respectively.

     The nonce is currently unused and only some MACs support it.

     There is a name parallel between GnuTLS MAC and digest algorithms
     but they are separate things internally and should not be mixed.

 -- Function: gnutls-hash-mac hash-method key input
     The HASH-METHOD can be the whole plist from 'gnutls-macs', or just
     the symbol key, or a string with the name of that symbol.

     The KEY can be specified as a buffer or string or in other ways
     (*note Format of GnuTLS Cryptography Inputs::).  The KEY will be
     wiped after use if it's a string.

     The INPUT can be specified as a buffer or string or in other ways
     (*note Format of GnuTLS Cryptography Inputs::).

     This function returns 'nil' on error, and signals a Lisp error if
     the HASH-METHOD or KEY or INPUT are invalid.

     On success, it returns a list of a binary string (the output) and
     the IV used.

 -- Function: gnutls-ciphers
     This function returns the alist of the GnuTLS ciphers.

     Each entry has a key which represents the cipher, followed by a
     plist with internal details about the algorithm.  The plist will
     have ':type gnutls-symmetric-cipher' and also will have the keys
     ':cipher-aead-capable' set to 'nil' or 't' to indicate AEAD
     capability; and ':cipher-tagsize' ':cipher-blocksize'
     ':cipher-keysize' ':cipher-ivsize' to indicate the size, in bytes,
     of the tag, block size of the resulting data, the key, and the IV
     respectively.

 -- Function: gnutls-symmetric-encrypt cipher key iv input &optional
          aead_auth
     The CIPHER can be the whole plist from 'gnutls-ciphers', or just
     the symbol key, or a string with the name of that symbol.

     The KEY can be specified as a buffer or string or in other ways
     (*note Format of GnuTLS Cryptography Inputs::).  The KEY will be
     wiped after use if it's a string.

     The IV and INPUT and the optional AEAD_AUTH can be specified as a
     buffer or string or in other ways (*note Format of GnuTLS
     Cryptography Inputs::).

     AEAD_AUTH is only checked with AEAD ciphers, that is, ciphers whose
     plist has ':cipher-aead-capable t'.  Otherwise it's ignored.

     This function returns 'nil' on error, and signals a Lisp error if
     the CIPHER or KEY, IV, or INPUT are invalid, or if AEAD_AUTH was
     specified with an AEAD cipher and was invalid.

     On success, it returns a list of a binary string (the output) and
     the IV used.

 -- Function: gnutls-symmetric-decrypt cipher key iv input &optional
          aead_auth
     The CIPHER can be the whole plist from 'gnutls-ciphers', or just
     the symbol key, or a string with the name of that symbol.

     The KEY can be specified as a buffer or string or in other ways
     (*note Format of GnuTLS Cryptography Inputs::).  The KEY will be
     wiped after use if it's a string.

     The IV and INPUT and the optional AEAD_AUTH can be specified as a
     buffer or string or in other ways (*note Format of GnuTLS
     Cryptography Inputs::).

     AEAD_AUTH is only checked with AEAD ciphers, that is, ciphers whose
     plist has ':cipher-aead-capable t'.  Otherwise it's ignored.

     This function returns 'nil' on decryption error, and signals a Lisp
     error if the CIPHER or KEY, IV, or INPUT are invalid, or if
     AEAD_AUTH was specified with an AEAD cipher and was invalid.

     On success, it returns a list of a binary string (the output) and
     the IV used.

==============================================================================
File: elisp.info,  Node: |Parsing_HTML/XML|,  Next: |Parsing_JSON|,  Prev: |GnuTLS_Cryptography|,  Up: |Text|
==============================================================================

                                                              *Parsing_HTML/XML*

32.28 Parsing HTML and XML
--------------------------

Emacs can be compiled with built-in libxml2 support.

 -- Function: libxml-available-p
     This function returns non-'nil' if built-in libxml2 support is
     available in this Emacs session.

   When libxml2 support is available, the following functions can be
used to parse HTML or XML text into Lisp object trees.

 -- Function: libxml-parse-html-region start end &optional base-url
          discard-comments
     This function parses the text between START and END as HTML, and
     returns a list representing the HTML "parse tree".  It attempts to
     handle real-world HTML by robustly coping with syntax mistakes.

     The optional argument BASE-URL, if non-'nil', should be a string
     specifying the base URL for relative URLs occurring in links.

     If the optional argument DISCARD-COMMENTS is non-'nil', any
     top-level comment is discarded.  (This argument is obsolete and
     will be removed in future Emacs versions.  To remove comments, use
     the 'xml-remove-comments' utility function on the data before you
     call the parsing function.)

     In the parse tree, each HTML node is represented by a list in which
     the first element is a symbol representing the node name, the
     second element is an alist of node attributes, and the remaining
     elements are the subnodes.

     The following example demonstrates this.  Given this (malformed)
     HTML document:

          <html><head></head><body width=101><div class=thing>Foo<div>Yes

     A call to 'libxml-parse-html-region' returns this DOM (document
     object model):

          (html nil
           (head nil)
           (body ((width . "101"))
            (div ((class . "thing"))
             "Foo"
             (div nil
              "Yes"))))

 -- Function: shr-insert-document dom
     This function renders the parsed HTML in DOM into the current
     buffer.  The argument DOM should be a list as generated by
     'libxml-parse-html-region'.  This function is, e.g., used by *note
     EWW: (eww)Top.

 -- Function: libxml-parse-xml-region start end &optional base-url
          discard-comments
     This function is the same as 'libxml-parse-html-region', except
     that it parses the text as XML rather than HTML (so it is stricter
     about syntax).

MENU

* |Document_Object_Model|:: Access, manipulate and search the DOM.

==============================================================================
File: elisp.info,  Node: |Document_Object_Model|,  Up: |Parsing_HTML/XML|
==============================================================================

                                                         *Document_Object_Model*

32.28.1 Document Object Model
-----------------------------

The DOM returned by 'libxml-parse-html-region' (and the other XML
parsing functions) is a tree structure where each node has a node name
(called a "tag"), and optional key/value "attribute" list, and then a
list of "child nodes".  The child nodes are either strings or DOM
objects.

     (body ((width . "101"))
      (div ((class . "thing"))
       "Foo"
       (div nil
        "Yes")))

 -- Function: dom-node tag &optional attributes &rest children
     This function creates a DOM node of type TAG.  If given, ATTRIBUTES
     should be a key/value pair list.  If given, CHILDREN should be DOM
     nodes.

   The following functions can be used to work with this structure.
Each function takes a DOM node, or a list of nodes.  In the latter case,
only the first node in the list is used.

   Simple accessors:

'dom-tag NODE'
     Return the "tag" (also called "node name") of the node.

'dom-attr NODE ATTRIBUTE'
     Return the value of ATTRIBUTE in the node.  A common usage would
     be:

          (dom-attr img 'href)
          => "https://fsf.org/logo.png"

'dom-children NODE'
     Return all the children of the node.

'dom-non-text-children NODE'
     Return all the non-string children of the node.

'dom-attributes NODE'
     Return the key/value pair list of attributes of the node.

'dom-text NODE'
     Return all the textual elements of the node as a concatenated
     string.

'dom-texts NODE'
     Return all the textual elements of the node, as well as the textual
     elements of all the children of the node, recursively, as a
     concatenated string.  This function also takes an optional
     separator to be inserted between the textual elements.

'dom-parent DOM NODE'
     Return the parent of NODE in DOM.

'dom-remove DOM NODE'
     Remove NODE from DOM.

   The following are functions for altering the DOM.

'dom-set-attribute NODE ATTRIBUTE VALUE'
     Set the ATTRIBUTE of the node to VALUE.

'dom-append-child NODE CHILD'
     Append CHILD as the last child of NODE.

'dom-add-child-before NODE CHILD BEFORE'
     Add CHILD to NODE's child list before the BEFORE node.  If BEFORE
     is 'nil', make CHILD the first child.

'dom-set-attributes NODE ATTRIBUTES'
     Replace all the attributes of the node with a new key/value list.

   The following are functions for searching for elements in the DOM.
They all return lists of matching nodes.

'dom-by-tag DOM TAG'
     Return all nodes in DOM that are of type TAG.  A typical use would
     be:

          (dom-by-tag dom 'td)
          => '((td ...) (td ...) (td ...))

'dom-by-class DOM MATCH'
     Return all nodes in DOM that have class names that match MATCH,
     which is a regular expression.

'dom-by-style DOM STYLE'
     Return all nodes in DOM that have styles that match MATCH, which is
     a regular expression.

'dom-by-id DOM STYLE'
     Return all nodes in DOM that have IDs that match MATCH, which is a
     regular expression.

'dom-search DOM PREDICATE'
     Return all nodes in DOM where PREDICATE returns a non-'nil' value.
     PREDICATE is called with the node to be tested as its parameter.

'dom-strings DOM'
     Return all strings in DOM.

   Utility functions:

'dom-pp DOM &optional REMOVE-EMPTY'
     Pretty-print DOM at point.  If REMOVE-EMPTY, don't print textual
     nodes that just contain white-space.

==============================================================================
File: elisp.info,  Node: |Parsing_JSON|,  Next: |JSONRPC|,  Prev: |Parsing_HTML/XML|,  Up: |Text|
==============================================================================

                                                                  *Parsing_JSON*

32.29 Parsing and generating JSON values
----------------------------------------

When Emacs is compiled with JSON ("JavaScript Object Notation") support,
it provides several functions to convert between Lisp objects and JSON
values.  Any JSON value can be converted to a Lisp object, but not vice
versa.  Specifically:

   * JSON uses three keywords: 'true', 'null', 'false'.  'true' is
     represented by the symbol 't'.  By default, the remaining two are
     represented, respectively, by the symbols ':null' and ':false'.

   * JSON only has floating-point numbers.  They can represent both Lisp
     integers and Lisp floating-point numbers.

   * JSON strings are always Unicode strings encoded in UTF-8.  Lisp
     strings can contain non-Unicode characters.

   * JSON has only one sequence type, the array.  JSON arrays are
     represented using Lisp vectors.

   * JSON has only one map type, the object.  JSON objects are
     represented using Lisp hashtables, alists or plists.  When an alist
     or plist contains several elements with the same key, Emacs uses
     only the first element for serialization, in accordance with the
     behavior of 'assq'.

Note that 'nil', being both a valid alist and a valid plist, represents
'{}', the empty JSON object; not 'null', 'false', or an empty array, all
of which are different JSON values.

   If some Lisp object can't be represented in JSON, the serialization
functions will signal an error of type 'wrong-type-argument'.  The
parsing functions can also signal the following errors:

'json-end-of-file'
     Signaled when encountering a premature end of the input text.

'json-trailing-content'
     Signaled when encountering unexpected input after the first JSON
     object parsed.

'json-parse-error'
     Signaled when encountering invalid JSON syntax.

   Only top-level values (arrays and objects) can be serialized to JSON.
The subobjects within these top-level values can be of any type.
Likewise, the parsing functions will only return vectors, hashtables,
alists, and plists.

 -- Function: json-serialize object &rest args
     This function returns a new Lisp string which contains the JSON
     representation of OBJECT.  The argument ARGS is a list of
     keyword/argument pairs.  The following keywords are accepted:

     ':null-object'
          The value decides which Lisp object to use to represent the
          JSON keyword 'null'.  It defaults to the symbol ':null'.

     ':false-object'
          The value decides which Lisp object to use to represent the
          JSON keyword 'false'.  It defaults to the symbol ':false'.

 -- Function: json-insert object &rest args
     This function inserts the JSON representation of OBJECT into the
     current buffer before point.  The argument ARGS are interpreted as
     in 'json-parse-string'.

 -- Function: json-parse-string string &rest args
     This function parses the JSON value in STRING, which must be a Lisp
     string.  If STRING doesn't contain a valid JSON object, this
     function signals the 'json-parse-error' error.

     The argument ARGS is a list of keyword/argument pairs.  The
     following keywords are accepted:

     ':object-type'
          The value decides which Lisp object to use for representing
          the key-value mappings of a JSON object.  It can be either
          'hash-table', the default, to make hashtables with strings as
          keys; 'alist' to use alists with symbols as keys; or 'plist'
          to use plists with keyword symbols as keys.

     ':array-type'
          The value decides which Lisp object to use for representing a
          JSON array.  It can be either 'array', the default, to use
          Lisp arrays; or 'list' to use lists.

     ':null-object'
          The value decides which Lisp object to use to represent the
          JSON keyword 'null'.  It defaults to the symbol ':null'.

     ':false-object'
          The value decides which Lisp object to use to represent the
          JSON keyword 'false'.  It defaults to the symbol ':false'.

 -- Function: json-parse-buffer &rest args
     This function reads the next JSON value from the current buffer,
     starting at point.  It moves point to the position immediately
     after the value if contains a valid JSON object; otherwise it
     signals the 'json-parse-error' error and doesn't move point.  The
     arguments ARGS are interpreted as in 'json-parse-string'.

==============================================================================
File: elisp.info,  Node: |JSONRPC|,  Next: |Atomic_Changes|,  Prev: |Parsing_JSON|,  Up: |Text|
==============================================================================

                                                                       *JSONRPC*

32.30 JSONRPC communication
---------------------------

The 'jsonrpc' library implements the JSONRPC specification, version 2.0,
as it is described in <https://www.jsonrpc.org/>.  As the name suggests,
JSONRPC is a generic "Remote Procedure Call" protocol designed around
JSON objects, which you can convert to and from Lisp objects (*note
Parsing JSON::).

MENU

* |JSONRPC_Overview|::
* |Process_based_JSONRPC_connections|::
* |JSONRPC_JSON_object_format|::
* |JSONRPC_deferred_requests|::

==============================================================================
File: elisp.info,  Node: |JSONRPC_Overview|,  Next: |Process_based_JSONRPC_connections|,  Up: |JSONRPC|
==============================================================================

                                                              *JSONRPC_Overview*

32.30.1 Overview
----------------

Quoting from the spec (https://www.jsonrpc.org/), JSONRPC "is transport
agnostic in that the concepts can be used within the same process, over
sockets, over http, or in many various message passing environments."

   To model this agnosticism, the 'jsonrpc' library uses objects of a
'jsonrpc-connection' class, which represent a connection to a remote
JSON endpoint (for details on Emacs's object system, *note EIEIO:
(eieio)Top.).  In modern object-oriented parlance, this class is
"abstract", i.e. the actual class of a useful connection object is
always a subclass of 'jsonrpc-connection'.  Nevertheless, we can define
two distinct APIs around the 'jsonrpc-connection' class:

  1. A user interface for building JSONRPC applications

     In this scenario, the JSONRPC application selects a concrete
     subclass of 'jsonrpc-connection', and proceeds to create objects of
     that subclass using 'make-instance'.  To initiate a contact to the
     remote endpoint, the JSONRPC application passes this object to the
     functions 'jsonrpc-notify', 'jsonrpc-request', and/or
     'jsonrpc-async-request'.  For handling remotely initiated contacts,
     which generally come in asynchronously, the instantiation should
     include ':request-dispatcher' and ':notification-dispatcher'
     initargs, which are both functions of 3 arguments: the connection
     object; a symbol naming the JSONRPC method invoked remotely; and a
     JSONRPC 'params' object.

     The function passed as ':request-dispatcher' is responsible for
     handling the remote endpoint's requests, which expect a reply from
     the local endpoint (in this case, the program you're building).
     Inside that function, you may either return locally (a normal
     return) or non-locally (an error return).  A local return value
     must be a Lisp object that can be serialized as JSON (*note Parsing
     JSON::).  This determines a success response, and the object is
     forwarded to the server as the JSONRPC 'result' object.  A
     non-local return, achieved by calling the function 'jsonrpc-error',
     causes an error response to be sent to the server.  The details of
     the accompanying JSONRPC 'error' are filled out with whatever was
     passed to 'jsonrpc-error'.  A non-local return triggered by an
     unexpected error of any other type also causes an error response to
     be sent (unless you have set 'debug-on-error', in which case this
     calls the Lisp debugger, *note Error Debugging::).

  2. A inheritance interface for building JSONRPC transport
     implementations

     In this scenario, 'jsonrpc-connection' is subclassed to implement a
     different underlying transport strategy (for details on how to
     subclass, see *note Inheritance: (eieio)Inheritance.).  Users of
     the application-building interface can then instantiate objects of
     this concrete class (using the 'make-instance' function) and
     connect to JSONRPC endpoints using that strategy.

     This API has mandatory and optional parts.

     To allow its users to initiate JSONRPC contacts (notifications or
     requests) or reply to endpoint requests, the subclass must have an
     implementation of the 'jsonrpc-connection-send' method.

     Likewise, for handling the three types of remote contacts
     (requests, notifications, and responses to local requests), the
     transport implementation must arrange for the function
     'jsonrpc-connection-receive' to be called after noticing a new
     JSONRPC message on the wire (whatever that "wire" may be).

     Finally, and optionally, the 'jsonrpc-connection' subclass should
     implement the 'jsonrpc-shutdown' and 'jsonrpc-running-p' methods if
     these concepts apply to the transport.  If they do, then any system
     resources (e.g. processes, timers, etc.)  used to listen for
     messages on the wire should be released in 'jsonrpc-shutdown', i.e.
     they should only be needed while 'jsonrpc-running-p' is non-nil.

==============================================================================
File: elisp.info,  Node: |Process_based_JSONRPC_connections|,  Next: |JSONRPC_JSON_object_format|,  Prev: |JSONRPC_Overview|,  Up: |JSONRPC|
==============================================================================

                                             *Process_based_JSONRPC_connections*

32.30.2 Process-based JSONRPC connections
-----------------------------------------

For convenience, the 'jsonrpc' library comes with a built-in
'jsonrpc-process-connection' transport implementation that can talk to
local subprocesses (using the standard input and standard output); or
TCP hosts (using sockets); or any other remote endpoint that Emacs's
process object can represent (*note Processes::).

   Using this transport, the JSONRPC messages are encoded on the wire as
plain text and prefaced by some basic HTTP-style enveloping headers,
such as "Content-Length".

   For an example of an application using this transport scheme on top
of JSONRPC, see the Language Server Protocol
(https://microsoft.github.io/language-server-protocol/specification).

   Along with the mandatory ':request-dispatcher' and
':notification-dispatcher' initargs, users of the
'jsonrpc-process-connection' class should pass the following initargs as
keyword-value pairs to 'make-instance':

':process'
     Value must be a live process object or a function of no arguments
     producing one such object.  If passed a process object, the object
     is expected to contain a pre-established connection; otherwise, the
     function is called immediately after the object is made.

':on-shutdown'
     Value must be a function of a single argument, the
     'jsonrpc-process-connection' object.  The function is called after
     the underlying process object has been deleted (either deliberately
     by 'jsonrpc-shutdown', or unexpectedly, because of some external
     cause).

==============================================================================
File: elisp.info,  Node: |JSONRPC_JSON_object_format|,  Next: |JSONRPC_deferred_requests|,  Prev: |Process_based_JSONRPC_connections|,  Up: |JSONRPC|
==============================================================================

                                                    *JSONRPC_JSON_object_format*

32.30.3 JSONRPC JSON object format
----------------------------------

JSONRPC JSON objects are exchanged as Lisp plists (*note Property
Lists::): JSON-compatible plists are handed to the dispatcher functions
and, likewise, JSON-compatible plists should be given to
'jsonrpc-notify', 'jsonrpc-request', and 'jsonrpc-async-request'.

   To facilitate handling plists, this library makes liberal use of
'cl-lib' library (*note cl-lib: (cl)Top.) and suggests (but doesn't
force) its clients to do the same.  A macro 'jsonrpc-lambda' can be used
to create a lambda for destructuring a JSON-object like in this example:

     (jsonrpc-async-request
      myproc :frobnicate `(:foo "trix")
      :success-fn (jsonrpc-lambda (&key bar baz &allow-other-keys)
                    (message "Server replied back with %s and %s!"
                             bar baz))
      :error-fn (jsonrpc-lambda (&key code message _data)
                  (message "Sadly, server reports %s: %s"
                           code message)))

==============================================================================
File: elisp.info,  Node: |JSONRPC_deferred_requests|,  Prev: |JSONRPC_JSON_object_format|,  Up: |JSONRPC|
==============================================================================

                                                     *JSONRPC_deferred_requests*

32.30.4 Deferred JSONRPC requests
---------------------------------

In many RPC situations, synchronization between the two communicating
endpoints is a matter of correctly designing the RPC application: when
synchronization is needed, requests (which are blocking) should be used;
when it isn't, notifications should suffice.  However, when Emacs acts
as one of these endpoints, asynchronous events (e.g.  timer- or
process-related) may be triggered while there is still uncertainty about
the state of the remote endpoint.  Furthermore, acting on these events
may only sometimes demand synchronization, depending on the event's
specific nature.

   The ':deferred' keyword argument to 'jsonrpc-request' and
'jsonrpc-async-request' is designed to let the caller indicate that the
specific request needs synchronization and its actual issuance may be
delayed to the future, until some condition is satisfied.  Specifying
':deferred' for a request doesn't mean it _will_ be delayed, only that
it _can_ be.  If the request isn't sent immediately, 'jsonrpc' will make
renewed efforts to send it at certain key times during communication,
such as when receiving or sending other messages to the endpoint.

   Before any attempt to send the request, the application-specific
conditions are checked.  Since the 'jsonrpc' library can't know what
these conditions are, the program can use the
'jsonrpc-connection-ready-p' generic function (*note Generic
Functions::) to specify them.  The default method for this function
returns 't', but you can add overriding methods that return 'nil' in
some situations, based on the arguments passed to it, which are the
'jsonrpc-connection' object (*note JSONRPC Overview::) and whichever
value you passed as the ':deferred' keyword argument.

==============================================================================
File: elisp.info,  Node: |Atomic_Changes|,  Next: |Change_Hooks|,  Prev: |JSONRPC|,  Up: |Text|
==============================================================================

                                                                *Atomic_Changes*

32.31 Atomic Change Groups
--------------------------

In database terminology, an "atomic" change is an indivisible change--it
can succeed entirely or it can fail entirely, but it cannot partly
succeed.  A Lisp program can make a series of changes to one or several
buffers as an "atomic change group", meaning that either the entire
series of changes will be installed in their buffers or, in case of an
error, none of them will be.

   To do this for one buffer, the one already current, simply write a
call to 'atomic-change-group' around the code that makes the changes,
like this:

     (atomic-change-group
       (insert foo)
       (delete-region x y))

If an error (or other nonlocal exit) occurs inside the body of
'atomic-change-group', it unmakes all the changes in that buffer that
were during the execution of the body.  This kind of change group has no
effect on any other buffers--any such changes remain.

   If you need something more sophisticated, such as to make changes in
various buffers constitute one atomic group, you must directly call
lower-level functions that 'atomic-change-group' uses.

 -- Function: prepare-change-group &optional buffer
     This function sets up a change group for buffer BUFFER, which
     defaults to the current buffer.  It returns a handle that
     represents the change group.  You must use this handle to activate
     the change group and subsequently to finish it.

   To use the change group, you must "activate" it.  You must do this
before making any changes in the text of BUFFER.

 -- Function: activate-change-group handle
     This function activates the change group that HANDLE designates.

   After you activate the change group, any changes you make in that
buffer become part of it.  Once you have made all the desired changes in
the buffer, you must "finish" the change group.  There are two ways to
do this: you can either accept (and finalize) all the changes, or cancel
them all.

 -- Function: accept-change-group handle
     This function accepts all the changes in the change group specified
     by HANDLE, making them final.

 -- Function: cancel-change-group handle
     This function cancels and undoes all the changes in the change
     group specified by HANDLE.

   Your code should use 'unwind-protect' to make sure the group is
always finished.  The call to 'activate-change-group' should be inside
the 'unwind-protect', in case the user types 'C-g' just after it runs.
(This is one reason why 'prepare-change-group' and
'activate-change-group' are separate functions, because normally you
would call 'prepare-change-group' before the start of that
'unwind-protect'.)  Once you finish the group, don't use the handle
again--in particular, don't try to finish the same group twice.

   To make a multibuffer change group, call 'prepare-change-group' once
for each buffer you want to cover, then use 'nconc' to combine the
returned values, like this:

     (nconc (prepare-change-group buffer-1)
            (prepare-change-group buffer-2))

   You can then activate the multibuffer change group with a single call
to 'activate-change-group', and finish it with a single call to
'accept-change-group' or 'cancel-change-group'.

   Nested use of several change groups for the same buffer works as you
would expect.  Non-nested use of change groups for the same buffer will
get Emacs confused, so don't let it happen; the first change group you
start for any given buffer should be the last one finished.

==============================================================================
File: elisp.info,  Node: |Change_Hooks|,  Prev: |Atomic_Changes|,  Up: |Text|
==============================================================================

                                                                  *Change_Hooks*

32.32 Change Hooks
------------------

These hook variables let you arrange to take notice of changes in
buffers (or in a particular buffer, if you make them buffer-local).  See
also *note Special Properties::, for how to detect changes to specific
parts of the text.

   The functions you use in these hooks should save and restore the
match data if they do anything that uses regular expressions; otherwise,
they will interfere in bizarre ways with the editing operations that
call them.

 -- Variable: before-change-functions
     This variable holds a list of functions to call when Emacs is about
     to modify a buffer.  Each function gets two arguments, the
     beginning and end of the region that is about to change,
     represented as integers.  The buffer that is about to change is
     always the current buffer when the function is called.

 -- Variable: after-change-functions
     This variable holds a list of functions to call after Emacs
     modifies a buffer.  Each function receives three arguments: the
     beginning and end of the region just changed, and the length of the
     text that existed before the change.  All three arguments are
     integers.  The buffer that has been changed is always the current
     buffer when the function is called.

     The length of the old text is the difference between the buffer
     positions before and after that text as it was before the change.
     As for the changed text, its length is simply the difference
     between the first two arguments.

   Output of messages into the 'Messages' buffer does not call these
functions, and neither do certain internal buffer changes, such as
changes in buffers created by Emacs internally for certain jobs, that
should not be visible to Lisp programs.

   The vast majority of buffer changing primitives will call
'before-change-functions' and 'after-change-functions' in balanced
pairs, once for each change, where the arguments to these hooks exactly
delimit the change being made.  Yet, hook functions should not rely on
this always being the case, because some complex primitives call
'before-change-functions' once before making changes, and then call
'after-change-functions' zero or more times, depending on how many
individual changes the primitive is making.  When that happens, the
arguments to 'before-change-functions' will enclose a region in which
the individual changes are made, but won't necessarily be the minimal
such region, and the arguments to each successive call of
'after-change-functions' will then delimit the part of text being
changed exactly.  In general, we advise using either the before- or the
after-change hook, but not both.

 -- Macro: combine-after-change-calls body...
     The macro executes BODY normally, but arranges to call the
     after-change functions just once for a series of several changes--if
     that seems safe.

     If a program makes several text changes in the same area of the
     buffer, using the macro 'combine-after-change-calls' around that
     part of the program can make it run considerably faster when
     after-change hooks are in use.  When the after-change hooks are
     ultimately called, the arguments specify a portion of the buffer
     including all of the changes made within the
     'combine-after-change-calls' body.

     Warning: You must not alter the values of
     'after-change-functions' within the body of a
     'combine-after-change-calls' form.

     Warning: If the changes you combine occur in widely scattered
     parts of the buffer, this will still work, but it is not advisable,
     because it may lead to inefficient behavior for some change hook
     functions.

 -- Macro: combine-change-calls beg end body...
     This executes BODY normally, except any buffer changes it makes do
     not trigger the calls to 'before-change-functions' and
     'after-change-functions'.  Instead there is a single call of each
     of these hooks for the region enclosed by BEG and END, the
     parameters supplied to 'after-change-functions' reflecting the
     changes made to the size of the region by BODY.

     The result of this macro is the result returned by BODY.

     This macro is useful when a function makes a possibly large number
     of repetitive changes to the buffer, and the change hooks would
     otherwise take a long time to run, were they to be run for each
     individual buffer modification.  Emacs itself uses this macro, for
     example, in the commands 'comment-region' and 'uncomment-region'.

     Warning: You must not alter the values of
     'before-change-functions' or 'after-change-function' within BODY.

     Warning: You must not make any buffer changes outside of the
     region specified by BEG and END.

 -- Variable: first-change-hook
     This variable is a normal hook that is run whenever a buffer is
     changed that was previously in the unmodified state.

 -- Variable: inhibit-modification-hooks
     If this variable is non-'nil', all of the change hooks are
     disabled; none of them run.  This affects all the hook variables
     described above in this section, as well as the hooks attached to
     certain special text properties (*note Special Properties::) and
     overlay properties (*note Overlay Properties::).

     Also, this variable is bound to non-'nil' while running those same
     hook variables, so that by default modifying the buffer from a
     modification hook does not cause other modification hooks to be
     run.  If you do want modification hooks to be run in a particular
     piece of code that is itself run from a modification hook, then
     rebind locally 'inhibit-modification-hooks' to 'nil'.  However,
     doing this may cause recursive calls to the modification hooks, so
     be sure to prepare for that (for example, by binding some variable
     which tells your hook to do nothing).

     We recommend that you only bind this variable for modifications
     that do not result in lasting changes to buffer text contents (for
     example face changes or temporary modifications).  If you need to
     delay change hooks during a series of changes (typically for
     performance reasons), use 'combine-change-calls' or
     'combine-after-change-calls' instead.

==============================================================================
File: elisp.info,  Node: |Non_ASCII_Characters|,  Next: |Searching_and_Matching|,  Prev: |Text|,  Up: |Top|
==============================================================================

                                                          *Non_ASCII_Characters*

33 Non-ASCII Characters
=======================

This chapter covers the special issues relating to characters and how
they are stored in strings and buffers.

MENU

* |Text_Representations|::    How Emacs represents text.
* |Disabling_Multibyte|::     Controlling whether to use multibyte characters.
* |Converting_Representations|::  Converting unibyte to multibyte and vice versa.
* |Selecting_a_Representation|::  Treating a byte sequence as unibyte or multi.
* |Character_Codes|::         How unibyte and multibyte relate to
                                codes of individual characters.
* |Character_Properties|::    Character attributes that define their
                                behavior and handling.
* |Character_Sets|::          The space of possible character codes
                                is divided into various character sets.
* |Scanning_Charsets|::       Which character sets are used in a buffer?
* |Translation_of_Characters|::   Translation tables are used for conversion.
* |Coding_Systems|::          Coding systems are conversions for saving files.
* |Input_Methods|::           Input methods allow users to enter various
                                non-ASCII characters without special keyboards.
* |Locales|::                 Interacting with the POSIX locale.

==============================================================================
File: elisp.info,  Node: |Text_Representations|,  Next: |Disabling_Multibyte|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                          *Text_Representations*

33.1 Text Representations
-------------------------

Emacs buffers and strings support a large repertoire of characters from
many different scripts, allowing users to type and display text in
almost any known written language.

   To support this multitude of characters and scripts, Emacs closely
follows the "Unicode Standard".  The Unicode Standard assigns a unique
number, called a "codepoint", to each and every character.  The range of
codepoints defined by Unicode, or the Unicode "codespace", is
'0..#x10FFFF' (in hexadecimal notation), inclusive.  Emacs extends this
range with codepoints in the range '#x110000..#x3FFFFF', which it uses
for representing characters that are not unified with Unicode and "raw
8-bit bytes" that cannot be interpreted as characters.  Thus, a
character codepoint in Emacs is a 22-bit integer.

   To conserve memory, Emacs does not hold fixed-length 22-bit numbers
that are codepoints of text characters within buffers and strings.
Rather, Emacs uses a variable-length internal representation of
characters, that stores each character as a sequence of 1 to 5 8-bit
bytes, depending on the magnitude of its codepoint(1).  For example, any
ASCII character takes up only 1 byte, a Latin-1 character takes up 2
bytes, etc.  We call this representation of text "multibyte".

   Outside Emacs, characters can be represented in many different
encodings, such as ISO-8859-1, GB-2312, Big-5, etc.  Emacs converts
between these external encodings and its internal representation, as
appropriate, when it reads text into a buffer or a string, or when it
writes text to a disk file or passes it to some other process.

   Occasionally, Emacs needs to hold and manipulate encoded text or
binary non-text data in its buffers or strings.  For example, when Emacs
visits a file, it first reads the file's text verbatim into a buffer,
and only then converts it to the internal representation.  Before the
conversion, the buffer holds encoded text.

   Encoded text is not really text, as far as Emacs is concerned, but
rather a sequence of raw 8-bit bytes.  We call buffers and strings that
hold encoded text "unibyte" buffers and strings, because Emacs treats
them as a sequence of individual bytes.  Usually, Emacs displays unibyte
buffers and strings as octal codes such as '\237'.  We recommend that
you never use unibyte buffers and strings except for manipulating
encoded text or binary non-text data.

   In a buffer, the buffer-local value of the variable
'enable-multibyte-characters' specifies the representation used.  The
representation for a string is determined and recorded in the string
when the string is constructed.

 -- Variable: enable-multibyte-characters
     This variable specifies the current buffer's text representation.
     If it is non-'nil', the buffer contains multibyte text; otherwise,
     it contains unibyte encoded text or binary non-text data.

     You cannot set this variable directly; instead, use the function
     'set-buffer-multibyte' to change a buffer's representation.

 -- Function: position-bytes position
     Buffer positions are measured in character units.  This function
     returns the byte-position corresponding to buffer position POSITION
     in the current buffer.  This is 1 at the start of the buffer, and
     counts upward in bytes.  If POSITION is out of range, the value is
     'nil'.

 -- Function: byte-to-position byte-position
     Return the buffer position, in character units, corresponding to
     given BYTE-POSITION in the current buffer.  If BYTE-POSITION is out
     of range, the value is 'nil'.  In a multibyte buffer, an arbitrary
     value of BYTE-POSITION can be not at character boundary, but inside
     a multibyte sequence representing a single character; in this case,
     this function returns the buffer position of the character whose
     multibyte sequence includes BYTE-POSITION.  In other words, the
     value does not change for all byte positions that belong to the
     same character.

   The following two functions are useful when a Lisp program needs to
map buffer positions to byte offsets in a file visited by the buffer.

 -- Function: bufferpos-to-filepos position &optional quality
          coding-system
     This function is similar to 'position-bytes', but instead of byte
     position in the current buffer it returns the offset from the
     beginning of the current buffer's file of the byte that corresponds
     to the given character POSITION in the buffer.  The conversion
     requires to know how the text is encoded in the buffer's file; this
     is what the CODING-SYSTEM argument is for, defaulting to the value
     of 'buffer-file-coding-system'.  The optional argument QUALITY
     specifies how accurate the result should be; it should be one of
     the following:

     'exact'
          The result must be accurate.  The function may need to encode
          and decode a large part of the buffer, which is expensive and
          can be slow.
     'approximate'
          The value can be an approximation.  The function may avoid
          expensive processing and return an inexact result.
     'nil'
          If the exact result needs expensive processing, the function
          will return 'nil' rather than an approximation.  This is the
          default if the argument is omitted.

 -- Function: filepos-to-bufferpos byte &optional quality coding-system
     This function returns the buffer position corresponding to a file
     position specified by BYTE, a zero-base byte offset from the file's
     beginning.  The function performs the conversion opposite to what
     'bufferpos-to-filepos' does.  Optional arguments QUALITY and
     CODING-SYSTEM have the same meaning and values as for
     'bufferpos-to-filepos'.

 -- Function: multibyte-string-p string
     Return 't' if STRING is a multibyte string, 'nil' otherwise.  This
     function also returns 'nil' if STRING is some object other than a
     string.

 -- Function: string-bytes string
     This function returns the number of bytes in STRING.  If STRING is
     a multibyte string, this can be greater than '(length STRING)'.

 -- Function: unibyte-string &rest bytes
     This function concatenates all its argument BYTES and makes the
     result a unibyte string.

   ---------- Footnotes ----------

   (1) This internal representation is based on one of the encodings
defined by the Unicode Standard, called "UTF-8", for representing any
Unicode codepoint, but Emacs extends UTF-8 to represent the additional
codepoints it uses for raw 8-bit bytes and characters not unified with
Unicode.

==============================================================================
File: elisp.info,  Node: |Disabling_Multibyte|,  Next: |Converting_Representations|,  Prev: |Text_Representations|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                           *Disabling_Multibyte*

33.2 Disabling Multibyte Characters
-----------------------------------

By default, Emacs starts in multibyte mode: it stores the contents of
buffers and strings using an internal encoding that represents non-ASCII
characters using multi-byte sequences.  Multibyte mode allows you to use
all the supported languages and scripts without limitations.

   Under very special circumstances, you may want to disable multibyte
character support, for a specific buffer.  When multibyte characters are
disabled in a buffer, we call that "unibyte mode".  In unibyte mode,
each character in the buffer has a character code ranging from 0 through
255 (0377 octal); 0 through 127 (0177 octal) represent ASCII characters,
and 128 (0200 octal) through 255 (0377 octal) represent non-ASCII
characters.

   To edit a particular file in unibyte representation, visit it using
'find-file-literally'.  *Note Visiting Functions::.  You can convert a
multibyte buffer to unibyte by saving it to a file, killing the buffer,
and visiting the file again with 'find-file-literally'.  Alternatively,
you can use 'C-x <RET> c' ('universal-coding-system-argument') and
specify 'raw-text' as the coding system with which to visit or save a
file.  *Note Specifying a Coding System for File Text: (emacs)Text
Coding.  Unlike 'find-file-literally', finding a file as 'raw-text'
doesn't disable format conversion, uncompression, or auto mode
selection.

   The buffer-local variable 'enable-multibyte-characters' is non-'nil'
in multibyte buffers, and 'nil' in unibyte ones.  The mode line also
indicates whether a buffer is multibyte or not.  With a graphical
display, in a multibyte buffer, the portion of the mode line that
indicates the character set has a tooltip that (amongst other things)
says that the buffer is multibyte.  In a unibyte buffer, the character
set indicator is absent.  Thus, in a unibyte buffer (when using a
graphical display) there is normally nothing before the indication of
the visited file's end-of-line convention (colon, backslash, etc.),
unless you are using an input method.

   You can turn off multibyte support in a specific buffer by invoking
the command 'toggle-enable-multibyte-characters' in that buffer.

==============================================================================
File: elisp.info,  Node: |Converting_Representations|,  Next: |Selecting_a_Representation|,  Prev: |Disabling_Multibyte|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                    *Converting_Representations*

33.3 Converting Text Representations
------------------------------------

Emacs can convert unibyte text to multibyte; it can also convert
multibyte text to unibyte, provided that the multibyte text contains
only ASCII and 8-bit raw bytes.  In general, these conversions happen
when inserting text into a buffer, or when putting text from several
strings together in one string.  You can also explicitly convert a
string's contents to either representation.

   Emacs chooses the representation for a string based on the text from
which it is constructed.  The general rule is to convert unibyte text to
multibyte text when combining it with other multibyte text, because the
multibyte representation is more general and can hold whatever
characters the unibyte text has.

   When inserting text into a buffer, Emacs converts the text to the
buffer's representation, as specified by 'enable-multibyte-characters'
in that buffer.  In particular, when you insert multibyte text into a
unibyte buffer, Emacs converts the text to unibyte, even though this
conversion cannot in general preserve all the characters that might be
in the multibyte text.  The other natural alternative, to convert the
buffer contents to multibyte, is not acceptable because the buffer's
representation is a choice made by the user that cannot be overridden
automatically.

   Converting unibyte text to multibyte text leaves ASCII characters
unchanged, and converts bytes with codes 128 through 255 to the
multibyte representation of raw eight-bit bytes.

   Converting multibyte text to unibyte converts all ASCII and eight-bit
characters to their single-byte form, but loses information for
non-ASCII characters by discarding all but the low 8 bits of each
character's codepoint.  Converting unibyte text to multibyte and back to
unibyte reproduces the original unibyte text.

   The next two functions either return the argument STRING, or a newly
created string with no text properties.

 -- Function: string-to-multibyte string
     This function returns a multibyte string containing the same
     sequence of characters as STRING.  If STRING is a multibyte string,
     it is returned unchanged.  The function assumes that STRING
     includes only ASCII characters and raw 8-bit bytes; the latter are
     converted to their multibyte representation corresponding to the
     codepoints '#x3FFF80' through '#x3FFFFF', inclusive (*note
     codepoints: Text Representations.).

 -- Function: string-to-unibyte string
     This function returns a unibyte string containing the same sequence
     of characters as STRING.  It signals an error if STRING contains a
     non-ASCII character.  If STRING is a unibyte string, it is returned
     unchanged.  Use this function for STRING arguments that contain
     only ASCII and eight-bit characters.

 -- Function: byte-to-string byte
     This function returns a unibyte string containing a single byte of
     character data, BYTE.  It signals an error if BYTE is not an
     integer between 0 and 255.

 -- Function: multibyte-char-to-unibyte char
     This converts the multibyte character CHAR to a unibyte character,
     and returns that character.  If CHAR is neither ASCII nor
     eight-bit, the function returns -1.

 -- Function: unibyte-char-to-multibyte char
     This convert the unibyte character CHAR to a multibyte character,
     assuming CHAR is either ASCII or raw 8-bit byte.

==============================================================================
File: elisp.info,  Node: |Selecting_a_Representation|,  Next: |Character_Codes|,  Prev: |Converting_Representations|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                    *Selecting_a_Representation*

33.4 Selecting a Representation
-------------------------------

Sometimes it is useful to examine an existing buffer or string as
multibyte when it was unibyte, or vice versa.

 -- Function: set-buffer-multibyte multibyte
     Set the representation type of the current buffer.  If MULTIBYTE is
     non-'nil', the buffer becomes multibyte.  If MULTIBYTE is 'nil',
     the buffer becomes unibyte.

     This function leaves the buffer contents unchanged when viewed as a
     sequence of bytes.  As a consequence, it can change the contents
     viewed as characters; for instance, a sequence of three bytes which
     is treated as one character in multibyte representation will count
     as three characters in unibyte representation.  Eight-bit
     characters representing raw bytes are an exception.  They are
     represented by one byte in a unibyte buffer, but when the buffer is
     set to multibyte, they are converted to two-byte sequences, and
     vice versa.

     This function sets 'enable-multibyte-characters' to record which
     representation is in use.  It also adjusts various data in the
     buffer (including overlays, text properties and markers) so that
     they cover the same text as they did before.

     This function signals an error if the buffer is narrowed, since the
     narrowing might have occurred in the middle of multibyte character
     sequences.

     This function also signals an error if the buffer is an indirect
     buffer.  An indirect buffer always inherits the representation of
     its base buffer.

 -- Function: string-as-unibyte string
     If STRING is already a unibyte string, this function returns STRING
     itself.  Otherwise, it returns a new string with the same bytes as
     STRING, but treating each byte as a separate character (so that the
     value may have more characters than STRING); as an exception, each
     eight-bit character representing a raw byte is converted into a
     single byte.  The newly-created string contains no text properties.

 -- Function: string-as-multibyte string
     If STRING is a multibyte string, this function returns STRING
     itself.  Otherwise, it returns a new string with the same bytes as
     STRING, but treating each multibyte sequence as one character.
     This means that the value may have fewer characters than STRING
     has.  If a byte sequence in STRING is invalid as a multibyte
     representation of a single character, each byte in the sequence is
     treated as a raw 8-bit byte.  The newly-created string contains no
     text properties.

==============================================================================
File: elisp.info,  Node: |Character_Codes|,  Next: |Character_Properties|,  Prev: |Selecting_a_Representation|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                               *Character_Codes*

33.5 Character Codes
--------------------

The unibyte and multibyte text representations use different character
codes.  The valid character codes for unibyte representation range from
0 to '#xFF' (255)--the values that can fit in one byte.  The valid
character codes for multibyte representation range from 0 to '#x3FFFFF'.
In this code space, values 0 through '#x7F' (127) are for ASCII
characters, and values '#x80' (128) through '#x3FFF7F' (4194175) are for
non-ASCII characters.

   Emacs character codes are a superset of the Unicode standard.  Values
0 through '#x10FFFF' (1114111) correspond to Unicode characters of the
same codepoint; values '#x110000' (1114112) through '#x3FFF7F' (4194175)
represent characters that are not unified with Unicode; and values
'#x3FFF80' (4194176) through '#x3FFFFF' (4194303) represent eight-bit
raw bytes.

 -- Function: characterp charcode
     This returns 't' if CHARCODE is a valid character, and 'nil'
     otherwise.

          (characterp 65)
               => t
          (characterp 4194303)
               => t
          (characterp 4194304)
               => nil

 -- Function: max-char
     This function returns the largest value that a valid character
     codepoint can have.

          (characterp (max-char))
               => t
          (characterp (1+ (max-char)))
               => nil

 -- Function: char-from-name string &optional ignore-case
     This function returns the character whose Unicode name is STRING.
     If IGNORE-CASE is non-'nil', case is ignored in STRING.  This
     function returns 'nil' if STRING does not name a character.

          ;; U+03A3
          (= (char-from-name "GREEK CAPITAL LETTER SIGMA") #x03A3)
               => t

 -- Function: get-byte &optional pos string
     This function returns the byte at character position POS in the
     current buffer.  If the current buffer is unibyte, this is
     literally the byte at that position.  If the buffer is multibyte,
     byte values of ASCII characters are the same as character
     codepoints, whereas eight-bit raw bytes are converted to their
     8-bit codes.  The function signals an error if the character at POS
     is non-ASCII.

     The optional argument STRING means to get a byte value from that
     string instead of the current buffer.

==============================================================================
File: elisp.info,  Node: |Character_Properties|,  Next: |Character_Sets|,  Prev: |Character_Codes|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                          *Character_Properties*

33.6 Character Properties
-------------------------

A "character property" is a named attribute of a character that
specifies how the character behaves and how it should be handled during
text processing and display.  Thus, character properties are an
important part of specifying the character's semantics.

   On the whole, Emacs follows the Unicode Standard in its
implementation of character properties.  In particular, Emacs supports
the Unicode Character Property Model
(https://www.unicode.org/reports/tr23/), and the Emacs character
property database is derived from the Unicode Character Database (UCD).
See the Character Properties chapter of the Unicode Standard
(https://www.unicode.org/versions/Unicode12.1.0/ch04.pdf), for a
detailed description of Unicode character properties and their meaning.
This section assumes you are already familiar with that chapter of the
Unicode Standard, and want to apply that knowledge to Emacs Lisp
programs.

   In Emacs, each property has a name, which is a symbol, and a set of
possible values, whose types depend on the property; if a character does
not have a certain property, the value is 'nil'.  As a general rule, the
names of character properties in Emacs are produced from the
corresponding Unicode properties by downcasing them and replacing each
'_' character with a dash '-'.  For example, 'Canonical_Combining_Class'
becomes 'canonical-combining-class'.  However, sometimes we shorten the
names to make their use easier.

   Some codepoints are left "unassigned" by the UCD--they don't
correspond to any character.  The Unicode Standard defines default
values of properties for such codepoints; they are mentioned below for
each property.

   Here is the full list of value types for all the character properties
that Emacs knows about:

'name'
     Corresponds to the 'Name' Unicode property.  The value is a string
     consisting of upper-case Latin letters A to Z, digits, spaces, and
     hyphen '-' characters.  For unassigned codepoints, the value is
     'nil'.

'general-category'
     Corresponds to the 'General_Category' Unicode property.  The value
     is a symbol whose name is a 2-letter abbreviation of the
     character's classification.  For unassigned codepoints, the value
     is 'Cn'.

'canonical-combining-class'
     Corresponds to the 'Canonical_Combining_Class' Unicode property.
     The value is an integer.  For unassigned codepoints, the value is
     zero.

'bidi-class'
     Corresponds to the Unicode 'Bidi_Class' property.  The value is a
     symbol whose name is the Unicode "directional type" of the
     character.  Emacs uses this property when it reorders bidirectional
     text for display (*note Bidirectional Display::).  For unassigned
     codepoints, the value depends on the code blocks to which the
     codepoint belongs: most unassigned codepoints get the value of 'L'
     (strong L), but some get values of 'AL' (Arabic letter) or 'R'
     (strong R).

'decomposition'
     Corresponds to the Unicode properties 'Decomposition_Type' and
     'Decomposition_Value'.  The value is a list, whose first element
     may be a symbol representing a compatibility formatting tag, such
     as 'small'(1); the other elements are characters that give the
     compatibility decomposition sequence of this character.  For
     characters that don't have decomposition sequences, and for
     unassigned codepoints, the value is a list with a single member,
     the character itself.

'decimal-digit-value'
     Corresponds to the Unicode 'Numeric_Value' property for characters
     whose 'Numeric_Type' is 'Decimal'.  The value is an integer, or
     'nil' if the character has no decimal digit value.  For unassigned
     codepoints, the value is 'nil', which means NaN, or "not a number".

'digit-value'
     Corresponds to the Unicode 'Numeric_Value' property for characters
     whose 'Numeric_Type' is 'Digit'.  The value is an integer.
     Examples of such characters include compatibility subscript and
     superscript digits, for which the value is the corresponding
     number.  For characters that don't have any numeric value, and for
     unassigned codepoints, the value is 'nil', which means NaN.

'numeric-value'
     Corresponds to the Unicode 'Numeric_Value' property for characters
     whose 'Numeric_Type' is 'Numeric'.  The value of this property is a
     number.  Examples of characters that have this property include
     fractions, subscripts, superscripts, Roman numerals, currency
     numerators, and encircled numbers.  For example, the value of this
     property for the character U+2155 VULGAR FRACTION ONE FIFTH is
     '0.2'.  For characters that don't have any numeric value, and for
     unassigned codepoints, the value is 'nil', which means NaN.

'mirrored'
     Corresponds to the Unicode 'Bidi_Mirrored' property.  The value of
     this property is a symbol, either 'Y' or 'N'.  For unassigned
     codepoints, the value is 'N'.

'mirroring'
     Corresponds to the Unicode 'Bidi_Mirroring_Glyph' property.  The
     value of this property is a character whose glyph represents the
     mirror image of the character's glyph, or 'nil' if there's no
     defined mirroring glyph.  All the characters whose 'mirrored'
     property is 'N' have 'nil' as their 'mirroring' property; however,
     some characters whose 'mirrored' property is 'Y' also have 'nil'
     for 'mirroring', because no appropriate characters exist with
     mirrored glyphs.  Emacs uses this property to display mirror images
     of characters when appropriate (*note Bidirectional Display::).
     For unassigned codepoints, the value is 'nil'.

'paired-bracket'
     Corresponds to the Unicode 'Bidi_Paired_Bracket' property.  The
     value of this property is the codepoint of a character's "paired
     bracket", or 'nil' if the character is not a bracket character.
     This establishes a mapping between characters that are treated as
     bracket pairs by the Unicode Bidirectional Algorithm; Emacs uses
     this property when it decides how to reorder for display
     parentheses, braces, and other similar characters (*note
     Bidirectional Display::).

'bracket-type'
     Corresponds to the Unicode 'Bidi_Paired_Bracket_Type' property.
     For characters whose 'paired-bracket' property is non-'nil', the
     value of this property is a symbol, either 'o' (for opening bracket
     characters) or 'c' (for closing bracket characters).  For
     characters whose 'paired-bracket' property is 'nil', the value is
     the symbol 'n' (None).  Like 'paired-bracket', this property is
     used for bidirectional display.

'old-name'
     Corresponds to the Unicode 'Unicode_1_Name' property.  The value is
     a string.  For unassigned codepoints, and characters that have no
     value for this property, the value is 'nil'.

'iso-10646-comment'
     Corresponds to the Unicode 'ISO_Comment' property.  The value is
     either a string or 'nil'.  For unassigned codepoints, the value is
     'nil'.

'uppercase'
     Corresponds to the Unicode 'Simple_Uppercase_Mapping' property.
     The value of this property is a single character.  For unassigned
     codepoints, the value is 'nil', which means the character itself.

'lowercase'
     Corresponds to the Unicode 'Simple_Lowercase_Mapping' property.
     The value of this property is a single character.  For unassigned
     codepoints, the value is 'nil', which means the character itself.

'titlecase'
     Corresponds to the Unicode 'Simple_Titlecase_Mapping' property.
     "Title case" is a special form of a character used when the first
     character of a word needs to be capitalized.  The value of this
     property is a single character.  For unassigned codepoints, the
     value is 'nil', which means the character itself.

'special-uppercase'
     Corresponds to Unicode language- and context-independent special
     upper-casing rules.  The value of this property is a string (which
     may be empty).  For example mapping for U+00DF LATIN SMALL LETTER
     SHARP S is '"SS"'.  For characters with no special mapping, the
     value is 'nil' which means 'uppercase' property needs to be
     consulted instead.

'special-lowercase'
     Corresponds to Unicode language- and context-independent special
     lower-casing rules.  The value of this property is a string (which
     may be empty).  For example mapping for U+0130 LATIN CAPITAL LETTER
     I WITH DOT ABOVE the value is '"i\u0307"' (i.e.  2-character string
     consisting of LATIN SMALL LETTER I followed by U+0307 COMBINING DOT
     ABOVE).  For characters with no special mapping, the value is 'nil'
     which means 'lowercase' property needs to be consulted instead.

'special-titlecase'
     Corresponds to Unicode unconditional special title-casing rules.
     The value of this property is a string (which may be empty).  For
     example mapping for U+FB01 LATIN SMALL LIGATURE FI the value is
     '"Fi"'.  For characters with no special mapping, the value is 'nil'
     which means 'titlecase' property needs to be consulted instead.

 -- Function: get-char-code-property char propname
     This function returns the value of CHAR's PROPNAME property.

          (get-char-code-property ?\s 'general-category)
               => Zs
          (get-char-code-property ?1 'general-category)
               => Nd
          ;; U+2084
          (get-char-code-property ?\N{SUBSCRIPT FOUR}
                                  'digit-value)
               => 4
          ;; U+2155
          (get-char-code-property ?\N{VULGAR FRACTION ONE FIFTH}
                                  'numeric-value)
               => 0.2
          ;; U+2163
          (get-char-code-property ?\N{ROMAN NUMERAL FOUR}
                                  'numeric-value)
               => 4
          (get-char-code-property ?\( 'paired-bracket)
               => 41  ;; closing parenthesis
          (get-char-code-property ?\) 'bracket-type)
               => c

 -- Function: char-code-property-description prop value
     This function returns the description string of property PROP's
     VALUE, or 'nil' if VALUE has no description.

          (char-code-property-description 'general-category 'Zs)
               => "Separator, Space"
          (char-code-property-description 'general-category 'Nd)
               => "Number, Decimal Digit"
          (char-code-property-description 'numeric-value '1/5)
               => nil

 -- Function: put-char-code-property char propname value
     This function stores VALUE as the value of the property PROPNAME
     for the character CHAR.

 -- Variable: unicode-category-table
     The value of this variable is a char-table (*note Char-Tables::)
     that specifies, for each character, its Unicode 'General_Category'
     property as a symbol.

 -- Variable: char-script-table
     The value of this variable is a char-table that specifies, for each
     character, a symbol whose name is the script to which the character
     belongs, according to the Unicode Standard classification of the
     Unicode code space into script-specific blocks.  This char-table
     has a single extra slot whose value is the list of all script
     symbols.

 -- Variable: char-width-table
     The value of this variable is a char-table that specifies the width
     of each character in columns that it will occupy on the screen.

 -- Variable: printable-chars
     The value of this variable is a char-table that specifies, for each
     character, whether it is printable or not.  That is, if evaluating
     '(aref printable-chars char)' results in 't', the character is
     printable, and if it results in 'nil', it is not.

   ---------- Footnotes ----------

   (1) The Unicode specification writes these tag names inside '<..>'
brackets, but the tag names in Emacs do not include the brackets; e.g.,
Unicode specifies '<small>' where Emacs uses 'small'.

==============================================================================
File: elisp.info,  Node: |Character_Sets|,  Next: |Scanning_Charsets|,  Prev: |Character_Properties|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                                *Character_Sets*

33.7 Character Sets
-------------------

An Emacs "character set", or "charset", is a set of characters in which
each character is assigned a numeric code point.  (The Unicode Standard
calls this a "coded character set".)  Each Emacs charset has a name
which is a symbol.  A single character can belong to any number of
different character sets, but it will generally have a different code
point in each charset.  Examples of character sets include 'ascii',
'iso-8859-1', 'greek-iso8859-7', and 'windows-1255'.  The code point
assigned to a character in a charset is usually different from its code
point used in Emacs buffers and strings.

   Emacs defines several special character sets.  The character set
'unicode' includes all the characters whose Emacs code points are in the
range '0..#x10FFFF'.  The character set 'emacs' includes all ASCII and
non-ASCII characters.  Finally, the 'eight-bit' charset includes the
8-bit raw bytes; Emacs uses it to represent raw bytes encountered in
text.

 -- Function: charsetp object
     Returns 't' if OBJECT is a symbol that names a character set, 'nil'
     otherwise.

 -- Variable: charset-list
     The value is a list of all defined character set names.

 -- Function: charset-priority-list &optional highestp
     This function returns a list of all defined character sets ordered
     by their priority.  If HIGHESTP is non-'nil', the function returns
     a single character set of the highest priority.

 -- Function: set-charset-priority &rest charsets
     This function makes CHARSETS the highest priority character sets.

 -- Function: char-charset character &optional restriction
     This function returns the name of the character set of highest
     priority that CHARACTER belongs to.  ASCII characters are an
     exception: for them, this function always returns 'ascii'.

     If RESTRICTION is non-'nil', it should be a list of charsets to
     search.  Alternatively, it can be a coding system, in which case
     the returned charset must be supported by that coding system (*note
     Coding Systems::).

 -- Function: charset-plist charset
     This function returns the property list of the character set
     CHARSET.  Although CHARSET is a symbol, this is not the same as the
     property list of that symbol.  Charset properties include important
     information about the charset, such as its documentation string,
     short name, etc.

 -- Function: put-charset-property charset propname value
     This function sets the PROPNAME property of CHARSET to the given
     VALUE.

 -- Function: get-charset-property charset propname
     This function returns the value of CHARSETs property PROPNAME.

 -- Command: list-charset-chars charset
     This command displays a list of characters in the character set
     CHARSET.

   Emacs can convert between its internal representation of a character
and the character's codepoint in a specific charset.  The following two
functions support these conversions.

 -- Function: decode-char charset code-point
     This function decodes a character that is assigned a CODE-POINT in
     CHARSET, to the corresponding Emacs character, and returns it.  If
     CHARSET doesn't contain a character of that code point, the value
     is 'nil'.

     For backward compatibility, if CODE-POINT doesn't fit in a Lisp
     fixnum (*note most-positive-fixnum: Integer Basics.), it can be
     specified as a cons cell '(HIGH . LOW)', where LOW are the lower 16
     bits of the value and HIGH are the high 16 bits.  This usage is
     obsolescent.

 -- Function: encode-char char charset
     This function returns the code point assigned to the character CHAR
     in CHARSET.  If CHARSET doesn't have a codepoint for CHAR, the
     value is 'nil'.

   The following function comes in handy for applying a certain function
to all or part of the characters in a charset:

 -- Function: map-charset-chars function charset &optional arg from-code
          to-code
     Call FUNCTION for characters in CHARSET.  FUNCTION is called with
     two arguments.  The first one is a cons cell '(FROM . TO)', where
     FROM and TO indicate a range of characters contained in charset.
     The second argument passed to FUNCTION is ARG.

     By default, the range of codepoints passed to FUNCTION includes all
     the characters in CHARSET, but optional arguments FROM-CODE and
     TO-CODE limit that to the range of characters between these two
     codepoints of CHARSET.  If either of them is 'nil', it defaults to
     the first or last codepoint of CHARSET, respectively.

==============================================================================
File: elisp.info,  Node: |Scanning_Charsets|,  Next: |Translation_of_Characters|,  Prev: |Character_Sets|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                             *Scanning_Charsets*

33.8 Scanning for Character Sets
--------------------------------

Sometimes it is useful to find out which character set a particular
character belongs to.  One use for this is in determining which coding
systems (*note Coding Systems::) are capable of representing all of the
text in question; another is to determine the font(s) for displaying
that text.

 -- Function: charset-after &optional pos
     This function returns the charset of highest priority containing
     the character at position POS in the current buffer.  If POS is
     omitted or 'nil', it defaults to the current value of point.  If
     POS is out of range, the value is 'nil'.

 -- Function: find-charset-region beg end &optional translation
     This function returns a list of the character sets of highest
     priority that contain characters in the current buffer between
     positions BEG and END.

     The optional argument TRANSLATION specifies a translation table to
     use for scanning the text (*note Translation of Characters::).  If
     it is non-'nil', then each character in the region is translated
     through this table, and the value returned describes the translated
     characters instead of the characters actually in the buffer.

 -- Function: find-charset-string string &optional translation
     This function returns a list of character sets of highest priority
     that contain characters in STRING.  It is just like
     'find-charset-region', except that it applies to the contents of
     STRING instead of part of the current buffer.

==============================================================================
File: elisp.info,  Node: |Translation_of_Characters|,  Next: |Coding_Systems|,  Prev: |Scanning_Charsets|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                     *Translation_of_Characters*

33.9 Translation of Characters
------------------------------

A "translation table" is a char-table (*note Char-Tables::) that
specifies a mapping of characters into characters.  These tables are
used in encoding and decoding, and for other purposes.  Some coding
systems specify their own particular translation tables; there are also
default translation tables which apply to all other coding systems.

   A translation table has two extra slots.  The first is either 'nil'
or a translation table that performs the reverse translation; the second
is the maximum number of characters to look up for translating sequences
of characters (see the description of
'make-translation-table-from-alist' below).

 -- Function: make-translation-table &rest translations
     This function returns a translation table based on the argument
     TRANSLATIONS.  Each element of TRANSLATIONS should be a list of
     elements of the form '(FROM . TO)'; this says to translate the
     character FROM into TO.

     The arguments and the forms in each argument are processed in
     order, and if a previous form already translates TO to some other
     character, say TO-ALT, FROM is also translated to TO-ALT.

   During decoding, the translation table's translations are applied to
the characters that result from ordinary decoding.  If a coding system
has the property ':decode-translation-table', that specifies the
translation table to use, or a list of translation tables to apply in
sequence.  (This is a property of the coding system, as returned by
'coding-system-get', not a property of the symbol that is the coding
system's name.  *Note Basic Concepts of Coding Systems: Coding System
Basics.)  Finally, if 'standard-translation-table-for-decode' is
non-'nil', the resulting characters are translated by that table.

   During encoding, the translation table's translations are applied to
the characters in the buffer, and the result of translation is actually
encoded.  If a coding system has property ':encode-translation-table',
that specifies the translation table to use, or a list of translation
tables to apply in sequence.  In addition, if the variable
'standard-translation-table-for-encode' is non-'nil', it specifies the
translation table to use for translating the result.

 -- Variable: standard-translation-table-for-decode
     This is the default translation table for decoding.  If a coding
     systems specifies its own translation tables, the table that is the
     value of this variable, if non-'nil', is applied after them.

 -- Variable: standard-translation-table-for-encode
     This is the default translation table for encoding.  If a coding
     systems specifies its own translation tables, the table that is the
     value of this variable, if non-'nil', is applied after them.

 -- Variable: translation-table-for-input
     Self-inserting characters are translated through this translation
     table before they are inserted.  Search commands also translate
     their input through this table, so they can compare more reliably
     with what's in the buffer.

     This variable automatically becomes buffer-local when set.

 -- Function: make-translation-table-from-vector vec
     This function returns a translation table made from VEC that is an
     array of 256 elements to map bytes (values 0 through #xFF) to
     characters.  Elements may be 'nil' for untranslated bytes.  The
     returned table has a translation table for reverse mapping in the
     first extra slot, and the value '1' in the second extra slot.

     This function provides an easy way to make a private coding system
     that maps each byte to a specific character.  You can specify the
     returned table and the reverse translation table using the
     properties ':decode-translation-table' and
     ':encode-translation-table' respectively in the PROPS argument to
     'define-coding-system'.

 -- Function: make-translation-table-from-alist alist
     This function is similar to 'make-translation-table' but returns a
     complex translation table rather than a simple one-to-one mapping.
     Each element of ALIST is of the form '(FROM . TO)', where FROM and
     TO are either characters or vectors specifying a sequence of
     characters.  If FROM is a character, that character is translated
     to TO (i.e., to a character or a character sequence).  If FROM is a
     vector of characters, that sequence is translated to TO.  The
     returned table has a translation table for reverse mapping in the
     first extra slot, and the maximum length of all the FROM character
     sequences in the second extra slot.

==============================================================================
File: elisp.info,  Node: |Coding_Systems|,  Next: |Input_Methods|,  Prev: |Translation_of_Characters|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                                *Coding_Systems*

33.10 Coding Systems
--------------------

When Emacs reads or writes a file, and when Emacs sends text to a
subprocess or receives text from a subprocess, it normally performs
character code conversion and end-of-line conversion as specified by a
particular "coding system".

   How to define a coding system is an arcane matter, and is not
documented here.

MENU

* |Coding_System_Basics|::        Basic concepts.
* |Encoding_and_I/O|::            How file I/O functions handle coding systems.
* |Lisp_and_Coding_Systems|::     Functions to operate on coding system names.
* |User_Chosen_Coding_Systems|::  Asking the user to choose a coding system.
* |Default_Coding_Systems|::      Controlling the default choices.
* |Specifying_Coding_Systems|::   Requesting a particular coding system
                                    for a single file operation.
* |Explicit_Encoding|::           Encoding or decoding text without doing I/O.
* |Terminal_I/O_Encoding|::       Use of encoding for terminal I/O.

==============================================================================
File: elisp.info,  Node: |Coding_System_Basics|,  Next: |Encoding_and_I/O|,  Up: |Coding_Systems|
==============================================================================

                                                          *Coding_System_Basics*

33.10.1 Basic Concepts of Coding Systems
----------------------------------------

"Character code conversion" involves conversion between the internal
representation of characters used inside Emacs and some other encoding.
Emacs supports many different encodings, in that it can convert to and
from them.  For example, it can convert text to or from encodings such
as Latin 1, Latin 2, Latin 3, Latin 4, Latin 5, and several variants of
ISO 2022.  In some cases, Emacs supports several alternative encodings
for the same characters; for example, there are three coding systems for
the Cyrillic (Russian) alphabet: ISO, Alternativnyj, and KOI8.

   Every coding system specifies a particular set of character code
conversions, but the coding system 'undecided' is special: it leaves the
choice unspecified, to be chosen heuristically for each file, based on
the file's data.  The coding system 'prefer-utf-8' is like 'undecided',
but it prefers to choose 'utf-8' when possible.

   In general, a coding system doesn't guarantee roundtrip identity:
decoding a byte sequence using a coding system, then encoding the
resulting text in the same coding system, can produce a different byte
sequence.  But some coding systems do guarantee that the byte sequence
will be the same as what you originally decoded.  Here are a few
examples:

     iso-8859-1, utf-8, big5, shift_jis, euc-jp

   Encoding buffer text and then decoding the result can also fail to
reproduce the original text.  For instance, if you encode a character
with a coding system which does not support that character, the result
is unpredictable, and thus decoding it using the same coding system may
produce a different text.  Currently, Emacs can't report errors that
result from encoding unsupported characters.

   "End of line conversion" handles three different conventions used on
various systems for representing end of line in files.  The Unix
convention, used on GNU and Unix systems, is to use the linefeed
character (also called newline).  The DOS convention, used on MS-Windows
and MS-DOS systems, is to use a carriage return and a linefeed at the
end of a line.  The Mac convention is to use just carriage return.
(This was the convention used in Classic Mac OS.)

   "Base coding systems" such as 'latin-1' leave the end-of-line
conversion unspecified, to be chosen based on the data.  "Variant coding
systems" such as 'latin-1-unix', 'latin-1-dos' and 'latin-1-mac' specify
the end-of-line conversion explicitly as well.  Most base coding systems
have three corresponding variants whose names are formed by adding
'-unix', '-dos' and '-mac'.

   The coding system 'raw-text' is special in that it prevents character
code conversion, and causes the buffer visited with this coding system
to be a unibyte buffer.  For historical reasons, you can save both
unibyte and multibyte text with this coding system.  When you use
'raw-text' to encode multibyte text, it does perform one character code
conversion: it converts eight-bit characters to their single-byte
external representation.  'raw-text' does not specify the end-of-line
conversion, allowing that to be determined as usual by the data, and has
the usual three variants which specify the end-of-line conversion.

   'no-conversion' (and its alias 'binary') is equivalent to
'raw-text-unix': it specifies no conversion of either character codes or
end-of-line.

   The coding system 'utf-8-emacs' specifies that the data is
represented in the internal Emacs encoding (*note Text
Representations::).  This is like 'raw-text' in that no code conversion
happens, but different in that the result is multibyte data.  The name
'emacs-internal' is an alias for 'utf-8-emacs-unix' (so it forces no
conversion of end-of-line, unlike 'utf-8-emacs', which can decode all 3
kinds of end-of-line conventions).

 -- Function: coding-system-get coding-system property
     This function returns the specified property of the coding system
     CODING-SYSTEM.  Most coding system properties exist for internal
     purposes, but one that you might find useful is ':mime-charset'.
     That property's value is the name used in MIME for the character
     coding which this coding system can read and write.  Examples:

          (coding-system-get 'iso-latin-1 :mime-charset)
               => iso-8859-1
          (coding-system-get 'iso-2022-cn :mime-charset)
               => iso-2022-cn
          (coding-system-get 'cyrillic-koi8 :mime-charset)
               => koi8-r

     The value of the ':mime-charset' property is also defined as an
     alias for the coding system.

 -- Function: coding-system-aliases coding-system
     This function returns the list of aliases of CODING-SYSTEM.

==============================================================================
File: elisp.info,  Node: |Encoding_and_I/O|,  Next: |Lisp_and_Coding_Systems|,  Prev: |Coding_System_Basics|,  Up: |Coding_Systems|
==============================================================================

                                                              *Encoding_and_I/O*

33.10.2 Encoding and I/O
------------------------

The principal purpose of coding systems is for use in reading and
writing files.  The function 'insert-file-contents' uses a coding system
to decode the file data, and 'write-region' uses one to encode the
buffer contents.

   You can specify the coding system to use either explicitly (*note
Specifying Coding Systems::), or implicitly using a default mechanism
(*note Default Coding Systems::).  But these methods may not completely
specify what to do.  For example, they may choose a coding system such
as 'undecided' which leaves the character code conversion to be
determined from the data.  In these cases, the I/O operation finishes
the job of choosing a coding system.  Very often you will want to find
out afterwards which coding system was chosen.

 -- Variable: buffer-file-coding-system
     This buffer-local variable records the coding system used for
     saving the buffer and for writing part of the buffer with
     'write-region'.  If the text to be written cannot be safely encoded
     using the coding system specified by this variable, these
     operations select an alternative encoding by calling the function
     'select-safe-coding-system' (*note User-Chosen Coding Systems::).
     If selecting a different encoding requires to ask the user to
     specify a coding system, 'buffer-file-coding-system' is updated to
     the newly selected coding system.

     'buffer-file-coding-system' does _not_ affect sending text to a
     subprocess.

 -- Variable: save-buffer-coding-system
     This variable specifies the coding system for saving the buffer (by
     overriding 'buffer-file-coding-system').  Note that it is not used
     for 'write-region'.

     When a command to save the buffer starts out to use
     'buffer-file-coding-system' (or 'save-buffer-coding-system'), and
     that coding system cannot handle the actual text in the buffer, the
     command asks the user to choose another coding system (by calling
     'select-safe-coding-system').  After that happens, the command also
     updates 'buffer-file-coding-system' to represent the coding system
     that the user specified.

 -- Variable: last-coding-system-used
     I/O operations for files and subprocesses set this variable to the
     coding system name that was used.  The explicit encoding and
     decoding functions (*note Explicit Encoding::) set it too.

     Warning: Since receiving subprocess output sets this variable, it
     can change whenever Emacs waits; therefore, you should copy the
     value shortly after the function call that stores the value you are
     interested in.

   The variable 'selection-coding-system' specifies how to encode
selections for the window system.  *Note Window System Selections::.

 -- Variable: file-name-coding-system
     The variable 'file-name-coding-system' specifies the coding system
     to use for encoding file names.  Emacs encodes file names using
     that coding system for all file operations.  If
     'file-name-coding-system' is 'nil', Emacs uses a default coding
     system determined by the selected language environment.  In the
     default language environment, any non-ASCII characters in file
     names are not encoded specially; they appear in the file system
     using the internal Emacs representation.

   Warning: if you change 'file-name-coding-system' (or the language
environment) in the middle of an Emacs session, problems can result if
you have already visited files whose names were encoded using the
earlier coding system and are handled differently under the new coding
system.  If you try to save one of these buffers under the visited file
name, saving may use the wrong file name, or it may get an error.  If
such a problem happens, use 'C-x C-w' to specify a new file name for
that buffer.

   On Windows 2000 and later, Emacs by default uses Unicode APIs to pass
file names to the OS, so the value of 'file-name-coding-system' is
largely ignored.  Lisp applications that need to encode or decode file
names on the Lisp level should use 'utf-8' coding-system when
'system-type' is 'windows-nt'; the conversion of UTF-8 encoded file
names to the encoding appropriate for communicating with the OS is
performed internally by Emacs.

==============================================================================
File: elisp.info,  Node: |Lisp_and_Coding_Systems|,  Next: |User_Chosen_Coding_Systems|,  Prev: |Encoding_and_I/O|,  Up: |Coding_Systems|
==============================================================================

                                                       *Lisp_and_Coding_Systems*

33.10.3 Coding Systems in Lisp
------------------------------

Here are the Lisp facilities for working with coding systems:

 -- Function: coding-system-list &optional base-only
     This function returns a list of all coding system names (symbols).
     If BASE-ONLY is non-'nil', the value includes only the base coding
     systems.  Otherwise, it includes alias and variant coding systems
     as well.

 -- Function: coding-system-p object
     This function returns 't' if OBJECT is a coding system name or
     'nil'.

 -- Function: check-coding-system coding-system
     This function checks the validity of CODING-SYSTEM.  If that is
     valid, it returns CODING-SYSTEM.  If CODING-SYSTEM is 'nil', the
     function return 'nil'.  For any other values, it signals an error
     whose 'error-symbol' is 'coding-system-error' (*note signal:
     Signaling Errors.).

 -- Function: coding-system-eol-type coding-system
     This function returns the type of end-of-line (a.k.a. "eol")
     conversion used by CODING-SYSTEM.  If CODING-SYSTEM specifies a
     certain eol conversion, the return value is an integer 0, 1, or 2,
     standing for 'unix', 'dos', and 'mac', respectively.  If
     CODING-SYSTEM doesn't specify eol conversion explicitly, the return
     value is a vector of coding systems, each one with one of the
     possible eol conversion types, like this:

          (coding-system-eol-type 'latin-1)
               => [latin-1-unix latin-1-dos latin-1-mac]

     If this function returns a vector, Emacs will decide, as part of
     the text encoding or decoding process, what eol conversion to use.
     For decoding, the end-of-line format of the text is auto-detected,
     and the eol conversion is set to match it (e.g., DOS-style CRLF
     format will imply 'dos' eol conversion).  For encoding, the eol
     conversion is taken from the appropriate default coding system
     (e.g., default value of 'buffer-file-coding-system' for
     'buffer-file-coding-system'), or from the default eol conversion
     appropriate for the underlying platform.

 -- Function: coding-system-change-eol-conversion coding-system eol-type
     This function returns a coding system which is like CODING-SYSTEM
     except for its eol conversion, which is specified by 'eol-type'.
     EOL-TYPE should be 'unix', 'dos', 'mac', or 'nil'.  If it is 'nil',
     the returned coding system determines the end-of-line conversion
     from the data.

     EOL-TYPE may also be 0, 1 or 2, standing for 'unix', 'dos' and
     'mac', respectively.

 -- Function: coding-system-change-text-conversion eol-coding
          text-coding
     This function returns a coding system which uses the end-of-line
     conversion of EOL-CODING, and the text conversion of TEXT-CODING.
     If TEXT-CODING is 'nil', it returns 'undecided', or one of its
     variants according to EOL-CODING.

 -- Function: find-coding-systems-region from to
     This function returns a list of coding systems that could be used
     to encode a text between FROM and TO.  All coding systems in the
     list can safely encode any multibyte characters in that portion of
     the text.

     If the text contains no multibyte characters, the function returns
     the list '(undecided)'.

 -- Function: find-coding-systems-string string
     This function returns a list of coding systems that could be used
     to encode the text of STRING.  All coding systems in the list can
     safely encode any multibyte characters in STRING.  If the text
     contains no multibyte characters, this returns the list
     '(undecided)'.

 -- Function: find-coding-systems-for-charsets charsets
     This function returns a list of coding systems that could be used
     to encode all the character sets in the list CHARSETS.

 -- Function: check-coding-systems-region start end coding-system-list
     This function checks whether coding systems in the list
     'coding-system-list' can encode all the characters in the region
     between START and END.  If all of the coding systems in the list
     can encode the specified text, the function returns 'nil'.  If some
     coding systems cannot encode some of the characters, the value is
     an alist, each element of which has the form '(CODING-SYSTEM1 POS1
     POS2 ...)', meaning that CODING-SYSTEM1 cannot encode characters at
     buffer positions POS1, POS2, ....

     START may be a string, in which case END is ignored and the
     returned value references string indices instead of buffer
     positions.

 -- Function: detect-coding-region start end &optional highest
     This function chooses a plausible coding system for decoding the
     text from START to END.  This text should be a byte sequence, i.e.,
     unibyte text or multibyte text with only ASCII and eight-bit
     characters (*note Explicit Encoding::).

     Normally this function returns a list of coding systems that could
     handle decoding the text that was scanned.  They are listed in
     order of decreasing priority.  But if HIGHEST is non-'nil', then
     the return value is just one coding system, the one that is highest
     in priority.

     If the region contains only ASCII characters except for such
     ISO-2022 control characters ISO-2022 as 'ESC', the value is
     'undecided' or '(undecided)', or a variant specifying end-of-line
     conversion, if that can be deduced from the text.

     If the region contains null bytes, the value is 'no-conversion',
     even if the region contains text encoded in some coding system.

 -- Function: detect-coding-string string &optional highest
     This function is like 'detect-coding-region' except that it
     operates on the contents of STRING instead of bytes in the buffer.

 -- Variable: inhibit-nul-byte-detection
     If this variable has a non-'nil' value, null bytes are ignored when
     detecting the encoding of a region or a string.  This allows the
     encoding of text that contains null bytes to be correctly detected,
     such as Info files with Index nodes.

 -- Variable: inhibit-iso-escape-detection
     If this variable has a non-'nil' value, ISO-2022 escape sequences
     are ignored when detecting the encoding of a region or a string.
     The result is that no text is ever detected as encoded in some
     ISO-2022 encoding, and all escape sequences become visible in a
     buffer.  Warning: _Use this variable with extreme caution,
     because many files in the Emacs distribution use ISO-2022
     encoding._

 -- Function: coding-system-charset-list coding-system
     This function returns the list of character sets (*note Character
     Sets::) supported by CODING-SYSTEM.  Some coding systems that
     support too many character sets to list them all yield special
     values:
        * If CODING-SYSTEM supports all Emacs characters, the value is
          '(emacs)'.
        * If CODING-SYSTEM supports all Unicode characters, the value is
          '(unicode)'.
        * If CODING-SYSTEM supports all ISO-2022 charsets, the value is
          'iso-2022'.
        * If CODING-SYSTEM supports all the characters in the internal
          coding system used by Emacs version 21 (prior to the
          implementation of internal Unicode support), the value is
          'emacs-mule'.

   *Note Process Information: Coding systems for a subprocess, in
particular the description of the functions 'process-coding-system' and
'set-process-coding-system', for how to examine or set the coding
systems used for I/O to a subprocess.

==============================================================================
File: elisp.info,  Node: |User_Chosen_Coding_Systems|,  Next: |Default_Coding_Systems|,  Prev: |Lisp_and_Coding_Systems|,  Up: |Coding_Systems|
==============================================================================

                                                    *User_Chosen_Coding_Systems*

33.10.4 User-Chosen Coding Systems
----------------------------------

 -- Function: select-safe-coding-system from to &optional
          default-coding-system accept-default-p file
     This function selects a coding system for encoding specified text,
     asking the user to choose if necessary.  Normally the specified
     text is the text in the current buffer between FROM and TO.  If
     FROM is a string, the string specifies the text to encode, and TO
     is ignored.

     If the specified text includes raw bytes (*note Text
     Representations::), 'select-safe-coding-system' suggests 'raw-text'
     for its encoding.

     If DEFAULT-CODING-SYSTEM is non-'nil', that is the first coding
     system to try; if that can handle the text,
     'select-safe-coding-system' returns that coding system.  It can
     also be a list of coding systems; then the function tries each of
     them one by one.  After trying all of them, it next tries the
     current buffer's value of 'buffer-file-coding-system' (if it is not
     'undecided'), then the default value of 'buffer-file-coding-system'
     and finally the user's most preferred coding system, which the user
     can set using the command 'prefer-coding-system' (*note Recognizing
     Coding Systems: (emacs)Recognize Coding.).

     If one of those coding systems can safely encode all the specified
     text, 'select-safe-coding-system' chooses it and returns it.
     Otherwise, it asks the user to choose from a list of coding systems
     which can encode all the text, and returns the user's choice.

     DEFAULT-CODING-SYSTEM can also be a list whose first element is 't'
     and whose other elements are coding systems.  Then, if no coding
     system in the list can handle the text, 'select-safe-coding-system'
     queries the user immediately, without trying any of the three
     alternatives described above.  This is handy for checking only the
     coding systems in the list.

     The optional argument ACCEPT-DEFAULT-P determines whether a coding
     system selected without user interaction is acceptable.  If it's
     omitted or 'nil', such a silent selection is always acceptable.  If
     it is non-'nil', it should be a function;
     'select-safe-coding-system' calls this function with one argument,
     the base coding system of the selected coding system.  If the
     function returns 'nil', 'select-safe-coding-system' rejects the
     silently selected coding system, and asks the user to select a
     coding system from a list of possible candidates.

     If the variable 'select-safe-coding-system-accept-default-p' is
     non-'nil', it should be a function taking a single argument.  It is
     used in place of ACCEPT-DEFAULT-P, overriding any value supplied
     for this argument.

     As a final step, before returning the chosen coding system,
     'select-safe-coding-system' checks whether that coding system is
     consistent with what would be selected if the contents of the
     region were read from a file.  (If not, this could lead to data
     corruption in a file subsequently re-visited and edited.)
     Normally, 'select-safe-coding-system' uses 'buffer-file-name' as
     the file for this purpose, but if FILE is non-'nil', it uses that
     file instead (this can be relevant for 'write-region' and similar
     functions).  If it detects an apparent inconsistency,
     'select-safe-coding-system' queries the user before selecting the
     coding system.

 -- Variable: select-safe-coding-system-function
     This variable names the function to be called to request the user
     to select a proper coding system for encoding text when the default
     coding system for an output operation cannot safely encode that
     text.  The default value of this variable is
     'select-safe-coding-system'.  Emacs primitives that write text to
     files, such as 'write-region', or send text to other processes,
     such as 'process-send-region', normally call the value of this
     variable, unless 'coding-system-for-write' is bound to a non-'nil'
     value (*note Specifying Coding Systems::).

   Here are two functions you can use to let the user specify a coding
system, with completion.  *Note Completion::.

 -- Function: read-coding-system prompt &optional default
     This function reads a coding system using the minibuffer, prompting
     with string PROMPT, and returns the coding system name as a symbol.
     If the user enters null input, DEFAULT specifies which coding
     system to return.  It should be a symbol or a string.

 -- Function: read-non-nil-coding-system prompt
     This function reads a coding system using the minibuffer, prompting
     with string PROMPT, and returns the coding system name as a symbol.
     If the user tries to enter null input, it asks the user to try
     again.  *Note Coding Systems::.

==============================================================================
File: elisp.info,  Node: |Default_Coding_Systems|,  Next: |Specifying_Coding_Systems|,  Prev: |User_Chosen_Coding_Systems|,  Up: |Coding_Systems|
==============================================================================

                                                        *Default_Coding_Systems*

33.10.5 Default Coding Systems
------------------------------

This section describes variables that specify the default coding system
for certain files or when running certain subprograms, and the function
that I/O operations use to access them.

   The idea of these variables is that you set them once and for all to
the defaults you want, and then do not change them again.  To specify a
particular coding system for a particular operation in a Lisp program,
don't change these variables; instead, override them using
'coding-system-for-read' and 'coding-system-for-write' (*note Specifying
Coding Systems::).

 -- User Option: auto-coding-regexp-alist
     This variable is an alist of text patterns and corresponding coding
     systems.  Each element has the form '(REGEXP . CODING-SYSTEM)'; a
     file whose first few kilobytes match REGEXP is decoded with
     CODING-SYSTEM when its contents are read into a buffer.  The
     settings in this alist take priority over 'coding:' tags in the
     files and the contents of 'file-coding-system-alist' (see below).
     The default value is set so that Emacs automatically recognizes
     mail files in Babyl format and reads them with no code conversions.

 -- User Option: file-coding-system-alist
     This variable is an alist that specifies the coding systems to use
     for reading and writing particular files.  Each element has the
     form '(PATTERN . CODING)', where PATTERN is a regular expression
     that matches certain file names.  The element applies to file names
     that match PATTERN.

     The CDR of the element, CODING, should be either a coding system, a
     cons cell containing two coding systems, or a function name (a
     symbol with a function definition).  If CODING is a coding system,
     that coding system is used for both reading the file and writing
     it.  If CODING is a cons cell containing two coding systems, its
     CAR specifies the coding system for decoding, and its CDR specifies
     the coding system for encoding.

     If CODING is a function name, the function should take one
     argument, a list of all arguments passed to
     'find-operation-coding-system'.  It must return a coding system or
     a cons cell containing two coding systems.  This value has the same
     meaning as described above.

     If CODING (or what returned by the above function) is 'undecided',
     the normal code-detection is performed.

 -- User Option: auto-coding-alist
     This variable is an alist that specifies the coding systems to use
     for reading and writing particular files.  Its form is like that of
     'file-coding-system-alist', but, unlike the latter, this variable
     takes priority over any 'coding:' tags in the file.

 -- Variable: process-coding-system-alist
     This variable is an alist specifying which coding systems to use
     for a subprocess, depending on which program is running in the
     subprocess.  It works like 'file-coding-system-alist', except that
     PATTERN is matched against the program name used to start the
     subprocess.  The coding system or systems specified in this alist
     are used to initialize the coding systems used for I/O to the
     subprocess, but you can specify other coding systems later using
     'set-process-coding-system'.

   Warning: Coding systems such as 'undecided', which determine the
coding system from the data, do not work entirely reliably with
asynchronous subprocess output.  This is because Emacs handles
asynchronous subprocess output in batches, as it arrives.  If the coding
system leaves the character code conversion unspecified, or leaves the
end-of-line conversion unspecified, Emacs must try to detect the proper
conversion from one batch at a time, and this does not always work.

   Therefore, with an asynchronous subprocess, if at all possible, use a
coding system which determines both the character code conversion and
the end of line conversion--that is, one like 'latin-1-unix', rather than
'undecided' or 'latin-1'.

 -- Variable: network-coding-system-alist
     This variable is an alist that specifies the coding system to use
     for network streams.  It works much like
     'file-coding-system-alist', with the difference that the PATTERN in
     an element may be either a port number or a regular expression.  If
     it is a regular expression, it is matched against the network
     service name used to open the network stream.

 -- Variable: default-process-coding-system
     This variable specifies the coding systems to use for subprocess
     (and network stream) input and output, when nothing else specifies
     what to do.

     The value should be a cons cell of the form '(INPUT-CODING .
     OUTPUT-CODING)'.  Here INPUT-CODING applies to input from the
     subprocess, and OUTPUT-CODING applies to output to it.

 -- User Option: auto-coding-functions
     This variable holds a list of functions that try to determine a
     coding system for a file based on its undecoded contents.

     Each function in this list should be written to look at text in the
     current buffer, but should not modify it in any way.  The buffer
     will contain the text of parts of the file.  Each function should
     take one argument, SIZE, which tells it how many characters to look
     at, starting from point.  If the function succeeds in determining a
     coding system for the file, it should return that coding system.
     Otherwise, it should return 'nil'.

     The functions in this list could be called either when the file is
     visited and Emacs wants to decode its contents, and/or when the
     file's buffer is about to be saved and Emacs wants to determine how
     to encode its contents.

     If a file has a 'coding:' tag, that takes precedence, so these
     functions won't be called.

 -- Function: find-auto-coding filename size
     This function tries to determine a suitable coding system for
     FILENAME.  It examines the buffer visiting the named file, using
     the variables documented above in sequence, until it finds a match
     for one of the rules specified by these variables.  It then returns
     a cons cell of the form '(CODING . SOURCE)', where CODING is the
     coding system to use and SOURCE is a symbol, one of
     'auto-coding-alist', 'auto-coding-regexp-alist', ':coding', or
     'auto-coding-functions', indicating which one supplied the matching
     rule.  The value ':coding' means the coding system was specified by
     the 'coding:' tag in the file (*note coding tag: (emacs)Specify
     Coding.).  The order of looking for a matching rule is
     'auto-coding-alist' first, then 'auto-coding-regexp-alist', then
     the 'coding:' tag, and lastly 'auto-coding-functions'.  If no
     matching rule was found, the function returns 'nil'.

     The second argument SIZE is the size of text, in characters,
     following point.  The function examines text only within SIZE
     characters after point.  Normally, the buffer should be positioned
     at the beginning when this function is called, because one of the
     places for the 'coding:' tag is the first one or two lines of the
     file; in that case, SIZE should be the size of the buffer.

 -- Function: set-auto-coding filename size
     This function returns a suitable coding system for file FILENAME.
     It uses 'find-auto-coding' to find the coding system.  If no coding
     system could be determined, the function returns 'nil'.  The
     meaning of the argument SIZE is like in 'find-auto-coding'.

 -- Function: find-operation-coding-system operation &rest arguments
     This function returns the coding system to use (by default) for
     performing OPERATION with ARGUMENTS.  The value has this form:

          (DECODING-SYSTEM . ENCODING-SYSTEM)

     The first element, DECODING-SYSTEM, is the coding system to use for
     decoding (in case OPERATION does decoding), and ENCODING-SYSTEM is
     the coding system for encoding (in case OPERATION does encoding).

     The argument OPERATION is a symbol; it should be one of
     'write-region', 'start-process', 'call-process',
     'call-process-region', 'insert-file-contents', or
     'open-network-stream'.  These are the names of the Emacs I/O
     primitives that can do character code and eol conversion.

     The remaining arguments should be the same arguments that might be
     given to the corresponding I/O primitive.  Depending on the
     primitive, one of those arguments is selected as the "target".  For
     example, if OPERATION does file I/O, whichever argument specifies
     the file name is the target.  For subprocess primitives, the
     process name is the target.  For 'open-network-stream', the target
     is the service name or port number.

     Depending on OPERATION, this function looks up the target in
     'file-coding-system-alist', 'process-coding-system-alist', or
     'network-coding-system-alist'.  If the target is found in the
     alist, 'find-operation-coding-system' returns its association in
     the alist; otherwise it returns 'nil'.

     If OPERATION is 'insert-file-contents', the argument corresponding
     to the target may be a cons cell of the form '(FILENAME . BUFFER)'.
     In that case, FILENAME is a file name to look up in
     'file-coding-system-alist', and BUFFER is a buffer that contains
     the file's contents (not yet decoded).  If
     'file-coding-system-alist' specifies a function to call for this
     file, and that function needs to examine the file's contents (as it
     usually does), it should examine the contents of BUFFER instead of
     reading the file.

==============================================================================
File: elisp.info,  Node: |Specifying_Coding_Systems|,  Next: |Explicit_Encoding|,  Prev: |Default_Coding_Systems|,  Up: |Coding_Systems|
==============================================================================

                                                     *Specifying_Coding_Systems*

33.10.6 Specifying a Coding System for One Operation
----------------------------------------------------

You can specify the coding system for a specific operation by binding
the variables 'coding-system-for-read' and/or 'coding-system-for-write'.

 -- Variable: coding-system-for-read
     If this variable is non-'nil', it specifies the coding system to
     use for reading a file, or for input from a synchronous subprocess.

     It also applies to any asynchronous subprocess or network stream,
     but in a different way: the value of 'coding-system-for-read' when
     you start the subprocess or open the network stream specifies the
     input decoding method for that subprocess or network stream.  It
     remains in use for that subprocess or network stream unless and
     until overridden.

     The right way to use this variable is to bind it with 'let' for a
     specific I/O operation.  Its global value is normally 'nil', and
     you should not globally set it to any other value.  Here is an
     example of the right way to use the variable:

          ;; Read the file with no character code conversion.
          (let ((coding-system-for-read 'no-conversion))
            (insert-file-contents filename))

     When its value is non-'nil', this variable takes precedence over
     all other methods of specifying a coding system to use for input,
     including 'file-coding-system-alist', 'process-coding-system-alist'
     and 'network-coding-system-alist'.

 -- Variable: coding-system-for-write
     This works much like 'coding-system-for-read', except that it
     applies to output rather than input.  It affects writing to files,
     as well as sending output to subprocesses and net connections.  It
     also applies to encoding command-line arguments with which Emacs
     invokes subprocesses.

     When a single operation does both input and output, as do
     'call-process-region' and 'start-process', both
     'coding-system-for-read' and 'coding-system-for-write' affect it.

 -- Variable: coding-system-require-warning
     Binding 'coding-system-for-write' to a non-'nil' value prevents
     output primitives from calling the function specified by
     'select-safe-coding-system-function' (*note User-Chosen Coding
     Systems::).  This is because 'C-x <RET> c'
     ('universal-coding-system-argument') works by binding
     'coding-system-for-write', and Emacs should obey user selection.
     If a Lisp program binds 'coding-system-for-write' to a value that
     might not be safe for encoding the text to be written, it can also
     bind 'coding-system-require-warning' to a non-'nil' value, which
     will force the output primitives to check the encoding by calling
     the value of 'select-safe-coding-system-function' even though
     'coding-system-for-write' is non-'nil'.  Alternatively, call
     'select-safe-coding-system' explicitly before using the specified
     encoding.

 -- User Option: inhibit-eol-conversion
     When this variable is non-'nil', no end-of-line conversion is done,
     no matter which coding system is specified.  This applies to all
     the Emacs I/O and subprocess primitives, and to the explicit
     encoding and decoding functions (*note Explicit Encoding::).

   Sometimes, you need to prefer several coding systems for some
operation, rather than fix a single one.  Emacs lets you specify a
priority order for using coding systems.  This ordering affects the
sorting of lists of coding systems returned by functions such as
'find-coding-systems-region' (*note Lisp and Coding Systems::).

 -- Function: coding-system-priority-list &optional highestp
     This function returns the list of coding systems in the order of
     their current priorities.  Optional argument HIGHESTP, if
     non-'nil', means return only the highest priority coding system.

 -- Function: set-coding-system-priority &rest coding-systems
     This function puts CODING-SYSTEMS at the beginning of the priority
     list for coding systems, thus making their priority higher than all
     the rest.

 -- Macro: with-coding-priority coding-systems &rest body
     This macro executes BODY, like 'progn' does (*note progn:
     Sequencing.), with CODING-SYSTEMS at the front of the priority list
     for coding systems.  CODING-SYSTEMS should be a list of coding
     systems to prefer during execution of BODY.

==============================================================================
File: elisp.info,  Node: |Explicit_Encoding|,  Next: |Terminal_I/O_Encoding|,  Prev: |Specifying_Coding_Systems|,  Up: |Coding_Systems|
==============================================================================

                                                             *Explicit_Encoding*

33.10.7 Explicit Encoding and Decoding
--------------------------------------

All the operations that transfer text in and out of Emacs have the
ability to use a coding system to encode or decode the text.  You can
also explicitly encode and decode text using the functions in this
section.

   The result of encoding, and the input to decoding, are not ordinary
text.  They logically consist of a series of byte values; that is, a
series of ASCII and eight-bit characters.  In unibyte buffers and
strings, these characters have codes in the range 0 through #xFF (255).
In a multibyte buffer or string, eight-bit characters have character
codes higher than #xFF (*note Text Representations::), but Emacs
transparently converts them to their single-byte values when you encode
or decode such text.

   The usual way to read a file into a buffer as a sequence of bytes, so
you can decode the contents explicitly, is with
'insert-file-contents-literally' (*note Reading from Files::);
alternatively, specify a non-'nil' RAWFILE argument when visiting a file
with 'find-file-noselect'.  These methods result in a unibyte buffer.

   The usual way to use the byte sequence that results from explicitly
encoding text is to copy it to a file or process--for example, to write
it with 'write-region' (*note Writing to Files::), and suppress encoding
by binding 'coding-system-for-write' to 'no-conversion'.

   Here are the functions to perform explicit encoding or decoding.  The
encoding functions produce sequences of bytes; the decoding functions
are meant to operate on sequences of bytes.  All of these functions
discard text properties.  They also set 'last-coding-system-used' to the
precise coding system they used.

 -- Command: encode-coding-region start end coding-system &optional
          destination
     This command encodes the text from START to END according to coding
     system CODING-SYSTEM.  Normally, the encoded text replaces the
     original text in the buffer, but the optional argument DESTINATION
     can change that.  If DESTINATION is a buffer, the encoded text is
     inserted in that buffer after point (point does not move); if it is
     't', the command returns the encoded text as a unibyte string
     without inserting it.

     If encoded text is inserted in some buffer, this command returns
     the length of the encoded text.

     The result of encoding is logically a sequence of bytes, but the
     buffer remains multibyte if it was multibyte before, and any 8-bit
     bytes are converted to their multibyte representation (*note Text
     Representations::).

     Do _not_ use 'undecided' for CODING-SYSTEM when encoding text,
     since that may lead to unexpected results.  Instead, use
     'select-safe-coding-system' (*note select-safe-coding-system:
     User-Chosen Coding Systems.) to suggest a suitable encoding, if
     there's no obvious pertinent value for CODING-SYSTEM.

 -- Function: encode-coding-string string coding-system &optional nocopy
          buffer
     This function encodes the text in STRING according to coding system
     CODING-SYSTEM.  It returns a new string containing the encoded
     text, except when NOCOPY is non-'nil', in which case the function
     may return STRING itself if the encoding operation is trivial.  The
     result of encoding is a unibyte string.

 -- Command: decode-coding-region start end coding-system &optional
          destination
     This command decodes the text from START to END according to coding
     system CODING-SYSTEM.  To make explicit decoding useful, the text
     before decoding ought to be a sequence of byte values, but both
     multibyte and unibyte buffers are acceptable (in the multibyte
     case, the raw byte values should be represented as eight-bit
     characters).  Normally, the decoded text replaces the original text
     in the buffer, but the optional argument DESTINATION can change
     that.  If DESTINATION is a buffer, the decoded text is inserted in
     that buffer after point (point does not move); if it is 't', the
     command returns the decoded text as a multibyte string without
     inserting it.

     If decoded text is inserted in some buffer, this command returns
     the length of the decoded text.  If that buffer is a unibyte buffer
     (*note Selecting a Representation::), the internal representation
     of the decoded text (*note Text Representations::) is inserted into
     the buffer as individual bytes.

     This command puts a 'charset' text property on the decoded text.
     The value of the property states the character set used to decode
     the original text.

 -- Function: decode-coding-string string coding-system &optional nocopy
          buffer
     This function decodes the text in STRING according to
     CODING-SYSTEM.  It returns a new string containing the decoded
     text, except when NOCOPY is non-'nil', in which case the function
     may return STRING itself if the decoding operation is trivial.  To
     make explicit decoding useful, the contents of STRING ought to be a
     unibyte string with a sequence of byte values, but a multibyte
     string is also acceptable (assuming it contains 8-bit bytes in
     their multibyte form).

     If optional argument BUFFER specifies a buffer, the decoded text is
     inserted in that buffer after point (point does not move).  In this
     case, the return value is the length of the decoded text.  If that
     buffer is a unibyte buffer, the internal representation of the
     decoded text is inserted into it as individual bytes.

     This function puts a 'charset' text property on the decoded text.
     The value of the property states the character set used to decode
     the original text:

          (decode-coding-string "Gr\374ss Gott" 'latin-1)
               => #("Gru"ss Gott" 0 9 (charset iso-8859-1))

 -- Function: decode-coding-inserted-region from to filename &optional
          visit beg end replace
     This function decodes the text from FROM to TO as if it were being
     read from file FILENAME using 'insert-file-contents' using the rest
     of the arguments provided.

     The normal way to use this function is after reading text from a
     file without decoding, if you decide you would rather have decoded
     it.  Instead of deleting the text and reading it again, this time
     with decoding, you can call this function.

==============================================================================
File: elisp.info,  Node: |Terminal_I/O_Encoding|,  Prev: |Explicit_Encoding|,  Up: |Coding_Systems|
==============================================================================

                                                         *Terminal_I/O_Encoding*

33.10.8 Terminal I/O Encoding
-----------------------------

Emacs can use coding systems to decode keyboard input and encode
terminal output.  This is useful for terminals that transmit or display
text using a particular encoding, such as Latin-1.  Emacs does not set
'last-coding-system-used' when encoding or decoding terminal I/O.

 -- Function: keyboard-coding-system &optional terminal
     This function returns the coding system used for decoding keyboard
     input from TERMINAL.  A value of 'no-conversion' means no decoding
     is done.  If TERMINAL is omitted or 'nil', it means the selected
     frame's terminal.  *Note Multiple Terminals::.

 -- Command: set-keyboard-coding-system coding-system &optional terminal
     This command specifies CODING-SYSTEM as the coding system to use
     for decoding keyboard input from TERMINAL.  If CODING-SYSTEM is
     'nil', that means not to decode keyboard input.  If TERMINAL is a
     frame, it means that frame's terminal; if it is 'nil', that means
     the currently selected frame's terminal.  *Note Multiple
     Terminals::.

 -- Function: terminal-coding-system &optional terminal
     This function returns the coding system that is in use for encoding
     terminal output from TERMINAL.  A value of 'no-conversion' means no
     encoding is done.  If TERMINAL is a frame, it means that frame's
     terminal; if it is 'nil', that means the currently selected frame's
     terminal.

 -- Command: set-terminal-coding-system coding-system &optional terminal
     This command specifies CODING-SYSTEM as the coding system to use
     for encoding terminal output from TERMINAL.  If CODING-SYSTEM is
     'nil', that means not to encode terminal output.  If TERMINAL is a
     frame, it means that frame's terminal; if it is 'nil', that means
     the currently selected frame's terminal.

==============================================================================
File: elisp.info,  Node: |Input_Methods|,  Next: |Locales|,  Prev: |Coding_Systems|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                                 *Input_Methods*

33.11 Input Methods
-------------------

"Input methods" provide convenient ways of entering non-ASCII characters
from the keyboard.  Unlike coding systems, which translate non-ASCII
characters to and from encodings meant to be read by programs, input
methods provide human-friendly commands.  (*Note (emacs)Input Methods::,
for information on how users use input methods to enter text.)  How to
define input methods is not yet documented in this manual, but here we
describe how to use them.

   Each input method has a name, which is currently a string; in the
future, symbols may also be usable as input method names.

 -- Variable: current-input-method
     This variable holds the name of the input method now active in the
     current buffer.  (It automatically becomes local in each buffer
     when set in any fashion.)  It is 'nil' if no input method is active
     in the buffer now.

 -- User Option: default-input-method
     This variable holds the default input method for commands that
     choose an input method.  Unlike 'current-input-method', this
     variable is normally global.

 -- Command: set-input-method input-method
     This command activates input method INPUT-METHOD for the current
     buffer.  It also sets 'default-input-method' to INPUT-METHOD.  If
     INPUT-METHOD is 'nil', this command deactivates any input method
     for the current buffer.

 -- Function: read-input-method-name prompt &optional default
          inhibit-null
     This function reads an input method name with the minibuffer,
     prompting with PROMPT.  If DEFAULT is non-'nil', that is returned
     by default, if the user enters empty input.  However, if
     INHIBIT-NULL is non-'nil', empty input signals an error.

     The returned value is a string.

 -- Variable: input-method-alist
     This variable defines all the supported input methods.  Each
     element defines one input method, and should have the form:

          (INPUT-METHOD LANGUAGE-ENV ACTIVATE-FUNC
           TITLE DESCRIPTION ARGS...)

     Here INPUT-METHOD is the input method name, a string; LANGUAGE-ENV
     is another string, the name of the language environment this input
     method is recommended for.  (That serves only for documentation
     purposes.)

     ACTIVATE-FUNC is a function to call to activate this method.  The
     ARGS, if any, are passed as arguments to ACTIVATE-FUNC.  All told,
     the arguments to ACTIVATE-FUNC are INPUT-METHOD and the ARGS.

     TITLE is a string to display in the mode line while this method is
     active.  DESCRIPTION is a string describing this method and what it
     is good for.

   The fundamental interface to input methods is through the variable
'input-method-function'.  *Note Reading One Event::, and *note Invoking
the Input Method::.

==============================================================================
File: elisp.info,  Node: |Locales|,  Prev: |Input_Methods|,  Up: |Non_ASCII_Characters|
==============================================================================

                                                                       *Locales*

33.12 Locales
-------------

In POSIX, locales control which language to use in language-related
features.  These Emacs variables control how Emacs interacts with these
features.

 -- Variable: locale-coding-system
     This variable specifies the coding system to use for decoding
     system error messages and--on X Window system only--keyboard input,
     for sending batch output to the standard output and error streams,
     for encoding the format argument to 'format-time-string', and for
     decoding the return value of 'format-time-string'.

 -- Variable: system-messages-locale
     This variable specifies the locale to use for generating system
     error messages.  Changing the locale can cause messages to come out
     in a different language or in a different orthography.  If the
     variable is 'nil', the locale is specified by environment variables
     in the usual POSIX fashion.

 -- Variable: system-time-locale
     This variable specifies the locale to use for formatting time
     values.  Changing the locale can cause messages to appear according
     to the conventions of a different language.  If the variable is
     'nil', the locale is specified by environment variables in the
     usual POSIX fashion.

 -- Function: locale-info item
     This function returns locale data ITEM for the current POSIX
     locale, if available.  ITEM should be one of these symbols:

     'codeset'
          Return the character set as a string (locale item 'CODESET').

     'days'
          Return a 7-element vector of day names (locale items 'DAY_1'
          through 'DAY_7');

     'months'
          Return a 12-element vector of month names (locale items
          'MON_1' through 'MON_12').

     'paper'
          Return a list '(WIDTH HEIGHT)' of 2 integers, for the default
          paper size measured in millimeters (locale items
          '_NL_PAPER_WIDTH' and '_NL_PAPER_HEIGHT').

     If the system can't provide the requested information, or if ITEM
     is not one of those symbols, the value is 'nil'.  All strings in
     the return value are decoded using 'locale-coding-system'.  *Note
     (libc)Locales::, for more information about locales and locale
     items.

==============================================================================
File: elisp.info,  Node: |Searching_and_Matching|,  Next: |Syntax_Tables|,  Prev: |Non_ASCII_Characters|,  Up: |Top|
==============================================================================

                                                        *Searching_and_Matching*

34 Searching and Matching
=========================

GNU Emacs provides two ways to search through a buffer for specified
text: exact string searches and regular expression searches.  After a
regular expression search, you can examine the "match data" to determine
which text matched the whole regular expression or various portions of
it.

MENU

* |String_Search|::         Search for an exact match.
* |Searching_and_Case|::    Case-independent or case-significant searching.
* |Regular_Expressions|::   Describing classes of strings.
* |Regexp_Search|::         Searching for a match for a regexp.
* |POSIX_Regexps|::         Searching POSIX-style for the longest match.
* |Match_Data|::            Finding out which part of the text matched,
                            after a string or regexp search.
* |Search_and_Replace|::    Commands that loop, searching and replacing.
* |Standard_Regexps|::      Useful regexps for finding sentences, pages,...

   The 'skip-chars...' functions also perform a kind of searching.
*Note Skipping Characters::.  To search for changes in character
properties, see *note Property Search::.

==============================================================================
File: elisp.info,  Node: |String_Search|,  Next: |Searching_and_Case|,  Up: |Searching_and_Matching|
==============================================================================

                                                                 *String_Search*

34.1 Searching for Strings
--------------------------

These are the primitive functions for searching through the text in a
buffer.  They are meant for use in programs, but you may call them
interactively.  If you do so, they prompt for the search string; the
arguments LIMIT and NOERROR are 'nil', and REPEAT is 1.  For more
details on interactive searching, *note Searching and Replacement:
(emacs)Search.

   These search functions convert the search string to multibyte if the
buffer is multibyte; they convert the search string to unibyte if the
buffer is unibyte.  *Note Text Representations::.

 -- Command: search-forward string &optional limit noerror count
     This function searches forward from point for an exact match for
     STRING.  If successful, it sets point to the end of the occurrence
     found, and returns the new value of point.  If no match is found,
     the value and side effects depend on NOERROR (see below).

     In the following example, point is initially at the beginning of
     the line.  Then '(search-forward "fox")' moves point after the last
     letter of 'fox':

          ---------- Buffer: foo ----------
          -!-The quick brown fox jumped over the lazy dog.
          ---------- Buffer: foo ----------

          (search-forward "fox")
               => 20

          ---------- Buffer: foo ----------
          The quick brown fox-!- jumped over the lazy dog.
          ---------- Buffer: foo ----------

     The argument LIMIT specifies the bound to the search, and should be
     a position in the current buffer.  No match extending after that
     position is accepted.  If LIMIT is omitted or 'nil', it defaults to
     the end of the accessible portion of the buffer.

     What happens when the search fails depends on the value of NOERROR.
     If NOERROR is 'nil', a 'search-failed' error is signaled.  If
     NOERROR is 't', 'search-forward' returns 'nil' and does nothing.
     If NOERROR is neither 'nil' nor 't', then 'search-forward' moves
     point to the upper bound and returns 'nil'.

     The argument NOERROR only affects valid searches which fail to find
     a match.  Invalid arguments cause errors regardless of NOERROR.

     If COUNT is a positive number N, the search is done N times; each
     successive search starts at the end of the previous match.  If all
     these successive searches succeed, the function call succeeds,
     moving point and returning its new value.  Otherwise the function
     call fails, with results depending on the value of NOERROR, as
     described above.  If COUNT is a negative number -N, the search is
     done N times in the opposite (backward) direction.

 -- Command: search-backward string &optional limit noerror count
     This function searches backward from point for STRING.  It is like
     'search-forward', except that it searches backwards rather than
     forwards.  Backward searches leave point at the beginning of the
     match.

 -- Command: word-search-forward string &optional limit noerror count
     This function searches forward from point for a word match for
     STRING.  If it finds a match, it sets point to the end of the match
     found, and returns the new value of point.

     Word matching regards STRING as a sequence of words, disregarding
     punctuation that separates them.  It searches the buffer for the
     same sequence of words.  Each word must be distinct in the buffer
     (searching for the word 'ball' does not match the word 'balls'),
     but the details of punctuation and spacing are ignored (searching
     for 'ball boy' does match 'ball. Boy!').

     In this example, point is initially at the beginning of the buffer;
     the search leaves it between the 'y' and the '!'.

          ---------- Buffer: foo ----------
          -!-He said "Please!  Find
          the ball boy!"
          ---------- Buffer: foo ----------

          (word-search-forward "Please find the ball, boy.")
               => 39

          ---------- Buffer: foo ----------
          He said "Please!  Find
          the ball boy-!-!"
          ---------- Buffer: foo ----------

     If LIMIT is non-'nil', it must be a position in the current buffer;
     it specifies the upper bound to the search.  The match found must
     not extend after that position.

     If NOERROR is 'nil', then 'word-search-forward' signals an error if
     the search fails.  If NOERROR is 't', then it returns 'nil' instead
     of signaling an error.  If NOERROR is neither 'nil' nor 't', it
     moves point to LIMIT (or the end of the accessible portion of the
     buffer) and returns 'nil'.

     If COUNT is a positive number, it specifies how many successive
     occurrences to search for.  Point is positioned at the end of the
     last match.  If COUNT is a negative number, the search is backward
     and point is positioned at the beginning of the last match.

     Internally, 'word-search-forward' and related functions use the
     function 'word-search-regexp' to convert STRING to a regular
     expression that ignores punctuation.

 -- Command: word-search-forward-lax string &optional limit noerror
          count
     This command is identical to 'word-search-forward', except that the
     beginning or the end of STRING need not match a word boundary,
     unless STRING begins or ends in whitespace.  For instance,
     searching for 'ball boy' matches 'ball boyee', but does not match
     'balls boy'.

 -- Command: word-search-backward string &optional limit noerror count
     This function searches backward from point for a word match to
     STRING.  This function is just like 'word-search-forward' except
     that it searches backward and normally leaves point at the
     beginning of the match.

 -- Command: word-search-backward-lax string &optional limit noerror
          count
     This command is identical to 'word-search-backward', except that
     the beginning or the end of STRING need not match a word boundary,
     unless STRING begins or ends in whitespace.

==============================================================================
File: elisp.info,  Node: |Searching_and_Case|,  Next: |Regular_Expressions|,  Prev: |String_Search|,  Up: |Searching_and_Matching|
==============================================================================

                                                            *Searching_and_Case*

34.2 Searching and Case
-----------------------

By default, searches in Emacs ignore the case of the text they are
searching through; if you specify searching for 'FOO', then 'Foo' or
'foo' is also considered a match.  This applies to regular expressions,
too; thus, '[aB]' would match 'a' or 'A' or 'b' or 'B'.

   If you do not want this feature, set the variable 'case-fold-search'
to 'nil'.  Then all letters must match exactly, including case.  This is
a buffer-local variable; altering the variable affects only the current
buffer.  (*Note Intro to Buffer-Local::.)  Alternatively, you may change
the default value.  In Lisp code, you will more typically use 'let' to
bind 'case-fold-search' to the desired value.

   Note that the user-level incremental search feature handles case
distinctions differently.  When the search string contains only lower
case letters, the search ignores case, but when the search string
contains one or more upper case letters, the search becomes
case-sensitive.  But this has nothing to do with the searching functions
used in Lisp code.  *Note (emacs)Incremental Search::.

 -- User Option: case-fold-search
     This buffer-local variable determines whether searches should
     ignore case.  If the variable is 'nil' they do not ignore case;
     otherwise (and by default) they do ignore case.

 -- User Option: case-replace
     This variable determines whether the higher-level replacement
     functions should preserve case.  If the variable is 'nil', that
     means to use the replacement text verbatim.  A non-'nil' value
     means to convert the case of the replacement text according to the
     text being replaced.

     This variable is used by passing it as an argument to the function
     'replace-match'.  *Note Replacing Match::.

==============================================================================
File: elisp.info,  Node: |Regular_Expressions|,  Next: |Regexp_Search|,  Prev: |Searching_and_Case|,  Up: |Searching_and_Matching|
==============================================================================

                                                           *Regular_Expressions*

34.3 Regular Expressions
------------------------

A "regular expression", or "regexp" for short, is a pattern that denotes
a (possibly infinite) set of strings.  Searching for matches for a
regexp is a very powerful operation.  This section explains how to write
regexps; the following section says how to search for them.

   For interactive development of regular expressions, you can use the
'M-x re-builder' command.  It provides a convenient interface for
creating regular expressions, by giving immediate visual feedback in a
separate buffer.  As you edit the regexp, all its matches in the target
buffer are highlighted.  Each parenthesized sub-expression of the regexp
is shown in a distinct face, which makes it easier to verify even very
complex regexps.

MENU

* |Syntax_of_Regexps|::       Rules for writing regular expressions.
* |Regexp_Example|::          Illustrates regular expression syntax.
* |Rx_Notation|::             An alternative, structured regexp notation.
* |Regexp_Functions|::        Functions for operating on regular expressions.

==============================================================================
File: elisp.info,  Node: |Syntax_of_Regexps|,  Next: |Regexp_Example|,  Up: |Regular_Expressions|
==============================================================================

                                                             *Syntax_of_Regexps*

34.3.1 Syntax of Regular Expressions
------------------------------------

Regular expressions have a syntax in which a few characters are special
constructs and the rest are "ordinary".  An ordinary character is a
simple regular expression that matches that character and nothing else.
The special characters are '.', '*', '+', '?', '[', '^', '$', and '\';
no new special characters will be defined in the future.  The character
']' is special if it ends a character alternative (see later).  The
character '-' is special inside a character alternative.  A '[:' and
balancing ':]' enclose a character class inside a character alternative.
Any other character appearing in a regular expression is ordinary,
unless a '\' precedes it.

   For example, 'f' is not a special character, so it is ordinary, and
therefore 'f' is a regular expression that matches the string 'f' and no
other string.  (It does _not_ match the string 'fg', but it does match a
_part_ of that string.)  Likewise, 'o' is a regular expression that
matches only 'o'.

   Any two regular expressions A and B can be concatenated.  The result
is a regular expression that matches a string if A matches some amount
of the beginning of that string and B matches the rest of the string.

   As a simple example, we can concatenate the regular expressions 'f'
and 'o' to get the regular expression 'fo', which matches only the
string 'fo'.  Still trivial.  To do something more powerful, you need to
use one of the special regular expression constructs.

MENU

* |Regexp_Special|::      Special characters in regular expressions.
* |Char_Classes|::        Character classes used in regular expressions.
* |Regexp_Backslash|::    Backslash-sequences in regular expressions.

==============================================================================
File: elisp.info,  Node: |Regexp_Special|,  Next: |Char_Classes|,  Up: Syntax of Regexps
==============================================================================

                                                                *Regexp_Special*

34.3.1.1 Special Characters in Regular Expressions
--------------------------------------------------

Here is a list of the characters that are special in a regular
expression.

'.' (Period)
     is a special character that matches any single character except a
     newline.  Using concatenation, we can make regular expressions like
     'a.b', which matches any three-character string that begins with
     'a' and ends with 'b'.

'*'
     is not a construct by itself; it is a postfix operator that means
     to match the preceding regular expression repetitively as many
     times as possible.  Thus, 'o*' matches any number of 'o's
     (including no 'o's).

     '*' always applies to the _smallest_ possible preceding expression.
     Thus, 'fo*' has a repeating 'o', not a repeating 'fo'.  It matches
     'f', 'fo', 'foo', and so on.

     The matcher processes a '*' construct by matching, immediately, as
     many repetitions as can be found.  Then it continues with the rest
     of the pattern.  If that fails, backtracking occurs, discarding
     some of the matches of the '*'-modified construct in the hope that
     this will make it possible to match the rest of the pattern.  For
     example, in matching 'ca*ar' against the string 'caaar', the 'a*'
     first tries to match all three 'a's; but the rest of the pattern is
     'ar' and there is only 'r' left to match, so this try fails.  The
     next alternative is for 'a*' to match only two 'a's.  With this
     choice, the rest of the regexp matches successfully.

     Warning: Nested repetition operators can run for an indefinitely
     long time, if they lead to ambiguous matching.  For example, trying
     to match the regular expression '\(x+y*\)*a' against the string
     'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz' could take hours before it
     ultimately fails.  Emacs must try each way of grouping the 'x's
     before concluding that none of them can work.  Even worse,
     '\(x*\)*' can match the null string in infinitely many ways, so it
     causes an infinite loop.  To avoid these problems, check nested
     repetitions carefully, to make sure that they do not cause
     combinatorial explosions in backtracking.

'+'
     is a postfix operator, similar to '*' except that it must match the
     preceding expression at least once.  So, for example, 'ca+r'
     matches the strings 'car' and 'caaaar' but not the string 'cr',
     whereas 'ca*r' matches all three strings.

'?'
     is a postfix operator, similar to '*' except that it must match the
     preceding expression either once or not at all.  For example,
     'ca?r' matches 'car' or 'cr'; nothing else.

'*?', '+?', '??'
     These are "non-greedy" variants of the operators '*', '+' and '?'.
     Where those operators match the largest possible substring
     (consistent with matching the entire containing expression), the
     non-greedy variants match the smallest possible substring
     (consistent with matching the entire containing expression).

     For example, the regular expression 'c[ad]*a' when applied to the
     string 'cdaaada' matches the whole string; but the regular
     expression 'c[ad]*?a', applied to that same string, matches just
     'cda'.  (The smallest possible match here for '[ad]*?' that permits
     the whole expression to match is 'd'.)

'[ ... ]'
     is a "character alternative", which begins with '[' and is
     terminated by ']'.  In the simplest case, the characters between
     the two brackets are what this character alternative can match.

     Thus, '[ad]' matches either one 'a' or one 'd', and '[ad]*' matches
     any string composed of just 'a's and 'd's (including the empty
     string).  It follows that 'c[ad]*r' matches 'cr', 'car', 'cdr',
     'caddaar', etc.

     You can also include character ranges in a character alternative,
     by writing the starting and ending characters with a '-' between
     them.  Thus, '[a-z]' matches any lower-case ASCII letter.  Ranges
     may be intermixed freely with individual characters, as in
     '[a-z$%.]', which matches any lower case ASCII letter or '$', '%'
     or period.  However, the ending character of one range should not
     be the starting point of another one; for example, '[a-m-z]' should
     be avoided.

     A character alternative can also specify named character classes
     (*note Char Classes::).  This is a POSIX feature.  For example,
     '[[:ascii:]]' matches any ASCII character.  Using a character class
     is equivalent to mentioning each of the characters in that class;
     but the latter is not feasible in practice, since some classes
     include thousands of different characters.  A character class
     should not appear as the lower or upper bound of a range.

     The usual regexp special characters are not special inside a
     character alternative.  A completely different set of characters is
     special: ']', '-' and '^'.  To include ']' in a character
     alternative, put it at the beginning.  To include '^', put it
     anywhere but at the beginning.  To include '-', put it at the end.
     Thus, '[]^-]' matches all three of these special characters.  You
     cannot use '\' to escape these three characters, since '\' is not
     special here.

     The following aspects of ranges are specific to Emacs, in that
     POSIX allows but does not require this behavior and programs other
     than Emacs may behave differently:

       1. If 'case-fold-search' is non-'nil', '[a-z]' also matches
          upper-case letters.

       2. A range is not affected by the locale's collation sequence: it
          always represents the set of characters with codepoints
          ranging between those of its bounds, so that '[a-z]' matches
          only ASCII letters, even outside the C or POSIX locale.

       3. If the lower bound of a range is greater than its upper bound,
          the range is empty and represents no characters.  Thus,
          '[z-a]' always fails to match, and '[^z-a]' matches any
          character, including newline.  However, a reversed range
          should always be from the letter 'z' to the letter 'a' to make
          it clear that it is not a typo; for example, '[+-*/]' should
          be avoided, because it matches only '/' rather than the
          likely-intended four characters.

     Some kinds of character alternatives are not the best style even
     though they have a well-defined meaning in Emacs.  They include:

       1. Although a range's bound can be almost any character, it is
          better style to stay within natural sequences of ASCII letters
          and digits because most people have not memorized character
          code tables.  For example, '[.-9]' is less clear than
          '[./0-9]', and '[`-~]' is less clear than '[`a-z{|}~]'.
          Unicode character escapes can help here; for example, for most
          programmers '[???-??????-???]' is less clear than
          '[\u0E01-\u0E3A\u0E3F-\u0E5B]'.

       2. Although a character alternative can include duplicates, it is
          better style to avoid them.  For example, '[XYa-yYb-zX]' is
          less clear than '[XYa-z]'.

       3. Although a range can denote just one, two, or three
          characters, it is simpler to list the characters.  For
          example, '[a-a0]' is less clear than '[a0]', '[i-j]' is less
          clear than '[ij]', and '[i-k]' is less clear than '[ijk]'.

       4. Although a '-' can appear at the beginning of a character
          alternative or as the upper bound of a range, it is better
          style to put '-' by itself at the end of a character
          alternative.  For example, although '[-a-z]' is valid,
          '[a-z-]' is better style; and although '[*--]' is valid,
          '[*+,-]' is clearer.

'[^ ... ]'
     '[^' begins a "complemented character alternative".  This matches
     any character except the ones specified.  Thus, '[^a-z0-9A-Z]'
     matches all characters _except_ ASCII letters and digits.

     '^' is not special in a character alternative unless it is the
     first character.  The character following the '^' is treated as if
     it were first (in other words, '-' and ']' are not special there).

     A complemented character alternative can match a newline, unless
     newline is mentioned as one of the characters not to match.  This
     is in contrast to the handling of regexps in programs such as
     'grep'.

     You can specify named character classes, just like in character
     alternatives.  For instance, '[^[:ascii:]]' matches any non-ASCII
     character.  *Note Char Classes::.

'^'
     When matching a buffer, '^' matches the empty string, but only at
     the beginning of a line in the text being matched (or the beginning
     of the accessible portion of the buffer).  Otherwise it fails to
     match anything.  Thus, '^foo' matches a 'foo' that occurs at the
     beginning of a line.

     When matching a string instead of a buffer, '^' matches at the
     beginning of the string or after a newline character.

     For historical compatibility reasons, '^' can be used only at the
     beginning of the regular expression, or after '\(', '\(?:' or '\|'.

'$'
     is similar to '^' but matches only at the end of a line (or the end
     of the accessible portion of the buffer).  Thus, 'x+$' matches a
     string of one 'x' or more at the end of a line.

     When matching a string instead of a buffer, '$' matches at the end
     of the string or before a newline character.

     For historical compatibility reasons, '$' can be used only at the
     end of the regular expression, or before '\)' or '\|'.

'\'
     has two functions: it quotes the special characters (including
     '\'), and it introduces additional special constructs.

     Because '\' quotes special characters, '\$' is a regular expression
     that matches only '$', and '\[' is a regular expression that
     matches only '[', and so on.

     Note that '\' also has special meaning in the read syntax of Lisp
     strings (*note String Type::), and must be quoted with '\'.  For
     example, the regular expression that matches the '\' character is
     '\\'.  To write a Lisp string that contains the characters '\\',
     Lisp syntax requires you to quote each '\' with another '\'.
     Therefore, the read syntax for a regular expression matching '\' is
     '"\\\\"'.

   *Please note:* For historical compatibility, special characters are
treated as ordinary ones if they are in contexts where their special
meanings make no sense.  For example, '*foo' treats '*' as ordinary
since there is no preceding expression on which the '*' can act.  It is
poor practice to depend on this behavior; quote the special character
anyway, regardless of where it appears.

   As a '\' is not special inside a character alternative, it can never
remove the special meaning of '-' or ']'.  So you should not quote these
characters when they have no special meaning either.  This would not
clarify anything, since backslashes can legitimately precede these
characters where they _have_ special meaning, as in '[^\]' ('"[^\\]"'
for Lisp string syntax), which matches any single character except a
backslash.

   In practice, most ']' that occur in regular expressions close a
character alternative and hence are special.  However, occasionally a
regular expression may try to match a complex pattern of literal '[' and
']'.  In such situations, it sometimes may be necessary to carefully
parse the regexp from the start to determine which square brackets
enclose a character alternative.  For example, '[^][]]' consists of the
complemented character alternative '[^][]' (which matches any single
character that is not a square bracket), followed by a literal ']'.

   The exact rules are that at the beginning of a regexp, '[' is special
and ']' not.  This lasts until the first unquoted '[', after which we
are in a character alternative; '[' is no longer special (except when it
starts a character class) but ']' is special, unless it immediately
follows the special '[' or that '[' followed by a '^'.  This lasts until
the next special ']' that does not end a character class.  This ends the
character alternative and restores the ordinary syntax of regular
expressions; an unquoted '[' is special again and a ']' not.

==============================================================================
File: elisp.info,  Node: |Char_Classes|,  Next: |Regexp_Backslash|,  Prev: |Regexp_Special|,  Up: |Syntax_of_Regexps|
==============================================================================

                                                                  *Char_Classes*

34.3.1.2 Character Classes
--------------------------

Below is a table of the classes you can use in a character alternative,
and what they mean.  Note that the '[' and ']' characters that enclose
the class name are part of the name, so a regular expression using these
classes needs one more pair of brackets.  For example, a regular
expression matching a sequence of one or more letters and digits would
be '[[:alnum:]]+', not '[:alnum:]+'.

'[:ascii:]'
     This matches any ASCII character (codes 0-127).
'[:alnum:]'
     This matches any letter or digit.  For multibyte characters, it
     matches characters whose Unicode 'general-category' property (*note
     Character Properties::) indicates they are alphabetic or decimal
     number characters.
'[:alpha:]'
     This matches any letter.  For multibyte characters, it matches
     characters whose Unicode 'general-category' property (*note
     Character Properties::) indicates they are alphabetic characters.
'[:blank:]'
     This matches horizontal whitespace, as defined by Annex C of the
     Unicode Technical Standard #18.  In particular, it matches spaces,
     tabs, and other characters whose Unicode 'general-category'
     property (*note Character Properties::) indicates they are spacing
     separators.
'[:cntrl:]'
     This matches any character whose code is in the range 0-31.
'[:digit:]'
     This matches '0' through '9'.  Thus, '[-+[:digit:]]' matches any
     digit, as well as '+' and '-'.
'[:graph:]'
     This matches graphic characters--everything except whitespace, ASCII
     and non-ASCII control characters, surrogates, and codepoints
     unassigned by Unicode, as indicated by the Unicode
     'general-category' property (*note Character Properties::).
'[:lower:]'
     This matches any lower-case letter, as determined by the current
     case table (*note Case Tables::).  If 'case-fold-search' is
     non-'nil', this also matches any upper-case letter.
'[:multibyte:]'
     This matches any multibyte character (*note Text
     Representations::).
'[:nonascii:]'
     This matches any non-ASCII character.
'[:print:]'
     This matches any printing character--either whitespace, or a graphic
     character matched by '[:graph:]'.
'[:punct:]'
     This matches any punctuation character.  (At present, for multibyte
     characters, it matches anything that has non-word syntax.)
'[:space:]'
     This matches any character that has whitespace syntax (*note Syntax
     Class Table::).
'[:unibyte:]'
     This matches any unibyte character (*note Text Representations::).
'[:upper:]'
     This matches any upper-case letter, as determined by the current
     case table (*note Case Tables::).  If 'case-fold-search' is
     non-'nil', this also matches any lower-case letter.
'[:word:]'
     This matches any character that has word syntax (*note Syntax Class
     Table::).
'[:xdigit:]'
     This matches the hexadecimal digits: '0' through '9', 'a' through
     'f' and 'A' through 'F'.

==============================================================================
File: elisp.info,  Node: |Regexp_Backslash|,  Prev: |Char_Classes|,  Up: |Syntax_of_Regexps|
==============================================================================

                                                              *Regexp_Backslash*

34.3.1.3 Backslash Constructs in Regular Expressions
----------------------------------------------------

For the most part, '\' followed by any character matches only that
character.  However, there are several exceptions: certain sequences
starting with '\' that have special meanings.  Here is a table of the
special '\' constructs.

'\|'
     specifies an alternative.  Two regular expressions A and B with
     '\|' in between form an expression that matches anything that
     either A or B matches.

     Thus, 'foo\|bar' matches either 'foo' or 'bar' but no other string.

     '\|' applies to the largest possible surrounding expressions.  Only
     a surrounding '\( ... \)' grouping can limit the grouping power of
     '\|'.

     If you need full backtracking capability to handle multiple uses of
     '\|', use the POSIX regular expression functions (*note POSIX
     Regexps::).

'\{M\}'
     is a postfix operator that repeats the previous pattern exactly M
     times.  Thus, 'x\{5\}' matches the string 'xxxxx' and nothing else.
     'c[ad]\{3\}r' matches string such as 'caaar', 'cdddr', 'cadar', and
     so on.

'\{M,N\}'
     is a more general postfix operator that specifies repetition with a
     minimum of M repeats and a maximum of N repeats.  If M is omitted,
     the minimum is 0; if N is omitted, there is no maximum.  For both
     forms, M and N, if specified, may be no larger than 2**16 - 1 .

     For example, 'c[ad]\{1,2\}r' matches the strings 'car', 'cdr',
     'caar', 'cadr', 'cdar', and 'cddr', and nothing else.
     '\{0,1\}' or '\{,1\}' is equivalent to '?'.
     '\{0,\}' or '\{,\}' is equivalent to '*'.
     '\{1,\}' is equivalent to '+'.

'\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of '\|' alternatives for other operations.
          Thus, the regular expression '\(foo\|bar\)x' matches either
          'foox' or 'barx'.

       2. To enclose a complicated expression for the postfix operators
          '*', '+' and '?' to operate on.  Thus, 'ba\(na\)*' matches
          'ba', 'bana', 'banana', 'bananana', etc., with any number
          (zero or more) of 'na' strings.

       3. To record a matched substring for future reference with
          '\DIGIT' (see below).

     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature that was assigned
     as a second meaning to the same '\( ... \)' construct because, in
     practice, there was usually no conflict between the two meanings.
     But occasionally there is a conflict, and that led to the
     introduction of shy groups.

'\(?: ... \)'
     is the "shy group" construct.  A shy group serves the first two
     purposes of an ordinary group (controlling the nesting of other
     operators), but it does not get a number, so you cannot refer back
     to its value with '\DIGIT'.  Shy groups are particularly useful for
     mechanically-constructed regular expressions, because they can be
     added automatically without altering the numbering of ordinary,
     non-shy groups.

     Shy groups are also called "non-capturing" or "unnumbered groups".

'\(?NUM: ... \)'
     is the "explicitly numbered group" construct.  Normal groups get
     their number implicitly, based on their position, which can be
     inconvenient.  This construct allows you to force a particular
     group number.  There is no particular restriction on the numbering,
     e.g., you can have several groups with the same number in which
     case the last one to match (i.e., the rightmost match) will win.
     Implicitly numbered groups always get the smallest integer larger
     than the one of any previous group.

'\DIGIT'
     matches the same text that matched the DIGITth occurrence of a
     grouping ('\( ... \)') construct.

     In other words, after the end of a group, the matcher remembers the
     beginning and end of the text matched by that group.  Later on in
     the regular expression you can use '\' followed by DIGIT to match
     that same text, whatever it may have been.

     The strings matching the first nine grouping constructs appearing
     in the entire regular expression passed to a search or matching
     function are assigned numbers 1 through 9 in the order that the
     open parentheses appear in the regular expression.  So you can use
     '\1' through '\9' to refer to the text matched by the corresponding
     grouping constructs.

     For example, '\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The '\(.*\)' matches the first
     half, which may be anything, but the '\1' that follows must match
     the same exact text.

     If a '\( ... \)' construct matches more than once (which can
     happen, for instance, if it is followed by '*'), only the last
     match is recorded.

     If a particular grouping construct in the regular expression was
     never matched--for instance, if it appears inside of an alternative
     that wasn't used, or inside of a repetition that repeated zero
     times--then the corresponding '\DIGIT' construct never matches
     anything.  To use an artificial example, '\(foo\(b*\)\|lose\)\2'
     cannot match 'lose': the second alternative inside the larger group
     matches it, but then '\2' is undefined and can't match anything.
     But it can match 'foobb', because the first alternative matches
     'foob' and '\2' matches 'b'.

'\w'
     matches any word-constituent character.  The editor syntax table
     determines which characters these are.  *Note Syntax Tables::.

'\W'
     matches any character that is not a word constituent.

'\sCODE'
     matches any character whose syntax is CODE.  Here CODE is a
     character that represents a syntax code: thus, 'w' for word
     constituent, '-' for whitespace, '(' for open parenthesis, etc.  To
     represent whitespace syntax, use either '-' or a space character.
     *Note Syntax Class Table::, for a list of syntax codes and the
     characters that stand for them.

'\SCODE'
     matches any character whose syntax is not CODE.

'\cC'
     matches any character whose category is C.  Here C is a character
     that represents a category: thus, 'c' for Chinese characters or 'g'
     for Greek characters in the standard category table.  You can see
     the list of all the currently defined categories with 'M-x
     describe-categories <RET>'.  You can also define your own
     categories in addition to the standard ones using the
     'define-category' function (*note Categories::).

'\CC'
     matches any character whose category is not C.

   The following regular expression constructs match the empty
string--that is, they don't use up any characters--but whether they match
depends on the context.  For all, the beginning and end of the
accessible portion of the buffer are treated as if they were the actual
beginning and end of the buffer.

'\`'
     matches the empty string, but only at the beginning of the buffer
     or string being matched against.

'\''
     matches the empty string, but only at the end of the buffer or
     string being matched against.

'\='
     matches the empty string, but only at point.  (This construct is
     not defined when matching against a string.)

'\b'
     matches the empty string, but only at the beginning or end of a
     word.  Thus, '\bfoo\b' matches any occurrence of 'foo' as a
     separate word.  '\bballs?\b' matches 'ball' or 'balls' as a
     separate word.

     '\b' matches at the beginning or end of the buffer (or string)
     regardless of what text appears next to it.

'\B'
     matches the empty string, but _not_ at the beginning or end of a
     word, nor at the beginning or end of the buffer (or string).

'\<'
     matches the empty string, but only at the beginning of a word.
     '\<' matches at the beginning of the buffer (or string) only if a
     word-constituent character follows.

'\>'
     matches the empty string, but only at the end of a word.  '\>'
     matches at the end of the buffer (or string) only if the contents
     end with a word-constituent character.

'\_<'
     matches the empty string, but only at the beginning of a symbol.  A
     symbol is a sequence of one or more word or symbol constituent
     characters.  '\_<' matches at the beginning of the buffer (or
     string) only if a symbol-constituent character follows.

'\_>'
     matches the empty string, but only at the end of a symbol.  '\_>'
     matches at the end of the buffer (or string) only if the contents
     end with a symbol-constituent character.

   Not every string is a valid regular expression.  For example, a
string that ends inside a character alternative without a terminating
']' is invalid, and so is a string that ends with a single '\'.  If an
invalid regular expression is passed to any of the search functions, an
'invalid-regexp' error is signaled.

==============================================================================
File: elisp.info,  Node: |Regexp_Example|,  Next: |Rx_Notation|,  Prev: |Syntax_of_Regexps|,  Up: |Regular_Expressions|
==============================================================================

                                                                *Regexp_Example*

34.3.2 Complex Regexp Example
-----------------------------

Here is a complicated regexp which was formerly used by Emacs to
recognize the end of a sentence together with any whitespace that
follows.  (Nowadays Emacs uses a similar but more complex default regexp
constructed by the function 'sentence-end'.  *Note Standard Regexps::.)

   Below, we show first the regexp as a string in Lisp syntax (to
distinguish spaces from tab characters), and then the result of
evaluating it.  The string constant begins and ends with a double-quote.
'\"' stands for a double-quote as part of the string, '\\' for a
backslash as part of the string, '\t' for a tab and '\n' for a newline.

     "[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"
          => "[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[
     ]*"

In the output, tab and newline appear as themselves.

   This regular expression contains four parts in succession and can be
deciphered as follows:

'[.?!]'
     The first part of the pattern is a character alternative that
     matches any one of three characters: period, question mark, and
     exclamation mark.  The match must begin with one of these three
     characters.  (This is one point where the new default regexp used
     by Emacs differs from the old.  The new value also allows some
     non-ASCII characters that end a sentence without any following
     whitespace.)

'[]\"')}]*'
     The second part of the pattern matches any closing braces and
     quotation marks, zero or more of them, that may follow the period,
     question mark or exclamation mark.  The '\"' is Lisp syntax for a
     double-quote in a string.  The '*' at the end indicates that the
     immediately preceding regular expression (a character alternative,
     in this case) may be repeated zero or more times.

'\\($\\| $\\|\t\\|  \\)'
     The third part of the pattern matches the whitespace that follows
     the end of a sentence: the end of a line (optionally with a space),
     or a tab, or two spaces.  The double backslashes mark the
     parentheses and vertical bars as regular expression syntax; the
     parentheses delimit a group and the vertical bars separate
     alternatives.  The dollar sign is used to match the end of a line.

'[ \t\n]*'
     Finally, the last part of the pattern matches any additional
     whitespace beyond the minimum needed to end a sentence.

   In the 'rx' notation (*note Rx Notation::), the regexp could be
written

     (rx (any ".?!")                    ; Punctuation ending sentence.
         (zero-or-more (any "\"')]}"))  ; Closing quotes or brackets.
         (or line-end
             (seq " " line-end)
             "\t"
             "  ")                      ; Two spaces.
         (zero-or-more (any "\t\n ")))  ; Optional extra whitespace.

   Since 'rx' regexps are just S-expressions, they can be formatted and
commented as such.

==============================================================================
File: elisp.info,  Node: |Rx_Notation|,  Next: |Regexp_Functions|,  Prev: |Regexp_Example|,  Up: |Regular_Expressions|
==============================================================================

                                                                   *Rx_Notation*

34.3.3 The 'rx' Structured Regexp Notation
------------------------------------------
vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
