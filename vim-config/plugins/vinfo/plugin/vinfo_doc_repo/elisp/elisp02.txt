
'safe-local-variable'
     The value specifies a function for determining safe file-local
     values for the named variable.  *Note File Local Variables::.

'side-effect-free'
     A non-'nil' value indicates that the named function is free of side
     effects (*note What Is a Function::), so the byte compiler may
     ignore a call whose value is unused.  If the property's value is
     'error-free', the byte compiler may even delete such unused calls.
     In addition to byte compiler optimizations, this property is also
     used for determining function safety (*note Function Safety::).

'undo-inhibit-region'
     If non-'nil', the named function prevents the 'undo' operation from
     being restricted to the active region, if 'undo' is invoked
     immediately after the function.  *Note Undo::.

'variable-documentation'
     If non-'nil', this specifies the named variable's documentation
     string.  This is set automatically by 'defvar' and related
     functions.  *Note Defining Faces::.

==============================================================================
File: elisp.info,  Node: |Evaluation|,  Next: |Control_Structures|,  Prev: |Symbols|,  Up: |Top|
==============================================================================

                                                                    *Evaluation*

10 Evaluation
=============

The "evaluation" of expressions in Emacs Lisp is performed by the "Lisp
interpreter"--a program that receives a Lisp object as input and computes
its "value as an expression".  How it does this depends on the data type
of the object, according to rules described in this chapter.  The
interpreter runs automatically to evaluate portions of your program, but
can also be called explicitly via the Lisp primitive function 'eval'.

MENU

* |Intro_Eval|::     Evaluation in the scheme of things.
* |Forms|::          How various sorts of objects are evaluated.
* |Quoting|::        Avoiding evaluation (to put constants in the program).
* |Backquote|::      Easier construction of list structure.
* |Eval|::           How to invoke the Lisp interpreter explicitly.
* |Deferred_Eval|::  Deferred and lazy evaluation of forms.

==============================================================================
File: elisp.info,  Node: |Intro_Eval|,  Next: |Forms|,  Up: |Evaluation|
==============================================================================

                                                                    *Intro_Eval*

10.1 Introduction to Evaluation
-------------------------------

The Lisp interpreter, or evaluator, is the part of Emacs that computes
the value of an expression that is given to it.  When a function written
in Lisp is called, the evaluator computes the value of the function by
evaluating the expressions in the function body.  Thus, running any Lisp
program really means running the Lisp interpreter.

   A Lisp object that is intended for evaluation is called a "form" or
"expression"(1).  The fact that forms are data objects and not merely
text is one of the fundamental differences between Lisp-like languages
and typical programming languages.  Any object can be evaluated, but in
practice only numbers, symbols, lists and strings are evaluated very
often.

   In subsequent sections, we will describe the details of what
evaluation means for each kind of form.

   It is very common to read a Lisp form and then evaluate the form, but
reading and evaluation are separate activities, and either can be
performed alone.  Reading per se does not evaluate anything; it converts
the printed representation of a Lisp object to the object itself.  It is
up to the caller of 'read' to specify whether this object is a form to
be evaluated, or serves some entirely different purpose.  *Note Input
Functions::.

   Evaluation is a recursive process, and evaluating a form often
involves evaluating parts within that form.  For instance, when you
evaluate a "function call" form such as '(car x)', Emacs first evaluates
the argument (the subform 'x').  After evaluating the argument, Emacs
"executes" the function ('car'), and if the function is written in Lisp,
execution works by evaluating the "body" of the function (in this
example, however, 'car' is not a Lisp function; it is a primitive
function implemented in C). *Note Functions::, for more information
about functions and function calls.

   Evaluation takes place in a context called the "environment", which
consists of the current values and bindings of all Lisp variables (*note
Variables::).(2)  Whenever a form refers to a variable without creating
a new binding for it, the variable evaluates to the value given by the
current environment.  Evaluating a form may also temporarily alter the
environment by binding variables (*note Local Variables::).

   Evaluating a form may also make changes that persist; these changes
are called "side effects".  An example of a form that produces a side
effect is '(setq foo 1)'.

   Do not confuse evaluation with command key interpretation.  The
editor command loop translates keyboard input into a command (an
interactively callable function) using the active keymaps, and then uses
'call-interactively' to execute that command.  Executing the command
usually involves evaluation, if the command is written in Lisp; however,
this step is not considered a part of command key interpretation.  *Note
Command Loop::.

   ---------- Footnotes ----------

   (1) It is sometimes also referred to as an "S-expression" or "sexp",
but we generally do not use this terminology in this manual.

   (2) This definition of "environment" is specifically not intended to
include all the data that can affect the result of a program.

==============================================================================
File: elisp.info,  Node: |Forms|,  Next: |Quoting|,  Prev: |Intro_Eval|,  Up: |Evaluation|
==============================================================================

                                                                         *Forms*

10.2 Kinds of Forms
-------------------

A Lisp object that is intended to be evaluated is called a "form" (or an
"expression").  How Emacs evaluates a form depends on its data type.
Emacs has three different kinds of form that are evaluated differently:
symbols, lists, and all other types.  This section describes all three
kinds, one by one, starting with the other types, which are
self-evaluating forms.

MENU

* |Self_Evaluating_Forms|::   Forms that evaluate to themselves.
* |Symbol_Forms|::            Symbols evaluate as variables.
* |Classifying_Lists|::       How to distinguish various sorts of list forms.
* |Function_Indirection|::    When a symbol appears as the car of a list,
                              we find the real function via the symbol.
* |Function_Forms|::          Forms that call functions.
* |Macro_Forms|::             Forms that call macros.
* |Special_Forms|::           Special forms are idiosyncratic primitives,
                              most of them extremely important.
* |Autoloading|::             Functions set up to load files
                              containing their real definitions.

==============================================================================
File: elisp.info,  Node: |Self_Evaluating_Forms|,  Next: |Symbol_Forms|,  Up: |Forms|
==============================================================================

                                                         *Self_Evaluating_Forms*

10.2.1 Self-Evaluating Forms
----------------------------

A "self-evaluating form" is any form that is not a list or symbol.
Self-evaluating forms evaluate to themselves: the result of evaluation
is the same object that was evaluated.  Thus, the number 25 evaluates to
25, and the string '"foo"' evaluates to the string '"foo"'.  Likewise,
evaluating a vector does not cause evaluation of the elements of the
vector--it returns the same vector with its contents unchanged.

     '123               ; A number, shown without evaluation.
          => 123
     123                ; Evaluated as usual--result is the same.
          => 123
     (eval '123)        ; Evaluated "by hand"--result is the same.
          => 123
     (eval (eval '123)) ; Evaluating twice changes nothing.
          => 123

   A self-evaluating form yields a value that becomes part of the
program, and you should not try to modify it via 'setcar', 'aset' or
similar operations.  The Lisp interpreter might unify the constants
yielded by your program's self-evaluating forms, so that these constants
might share structure.  *Note Mutability::.

   It is common to write numbers, characters, strings, and even vectors
in Lisp code, taking advantage of the fact that they self-evaluate.
However, it is quite unusual to do this for types that lack a read
syntax, because there's no way to write them textually.  It is possible
to construct Lisp expressions containing these types by means of a Lisp
program.  Here is an example:

     ;; Build an expression containing a buffer object.
     (setq print-exp (list 'print (current-buffer)))
          => (print #<buffer eval.texi>)
     ;; Evaluate it.
     (eval print-exp)
          -| #<buffer eval.texi>
          => #<buffer eval.texi>

==============================================================================
File: elisp.info,  Node: |Symbol_Forms|,  Next: |Classifying_Lists|,  Prev: |Self_Evaluating_Forms|,  Up: |Forms|
==============================================================================

                                                                  *Symbol_Forms*

10.2.2 Symbol Forms
-------------------

When a symbol is evaluated, it is treated as a variable.  The result is
the variable's value, if it has one.  If the symbol has no value as a
variable, the Lisp interpreter signals an error.  For more information
on the use of variables, see *note Variables::.

   In the following example, we set the value of a symbol with 'setq'.
Then we evaluate the symbol, and get back the value that 'setq' stored.

     (setq a 123)
          => 123
     (eval 'a)
          => 123
     a
          => 123

   The symbols 'nil' and 't' are treated specially, so that the value of
'nil' is always 'nil', and the value of 't' is always 't'; you cannot
set or bind them to any other values.  Thus, these two symbols act like
self-evaluating forms, even though 'eval' treats them like any other
symbol.  A symbol whose name starts with ':' also self-evaluates in the
same way; likewise, its value ordinarily cannot be changed.  *Note
Constant Variables::.

==============================================================================
File: elisp.info,  Node: |Classifying_Lists|,  Next: |Function_Indirection|,  Prev: |Symbol_Forms|,  Up: |Forms|
==============================================================================

                                                             *Classifying_Lists*

10.2.3 Classification of List Forms
-----------------------------------

A form that is a nonempty list is either a function call, a macro call,
or a special form, according to its first element.  These three kinds of
forms are evaluated in different ways, described below.  The remaining
list elements constitute the "arguments" for the function, macro, or
special form.

   The first step in evaluating a nonempty list is to examine its first
element.  This element alone determines what kind of form the list is
and how the rest of the list is to be processed.  The first element is
_not_ evaluated, as it would be in some Lisp dialects such as Scheme.

==============================================================================
File: elisp.info,  Node: |Function_Indirection|,  Next: |Function_Forms|,  Prev: |Classifying_Lists|,  Up: |Forms|
==============================================================================

                                                          *Function_Indirection*

10.2.4 Symbol Function Indirection
----------------------------------

If the first element of the list is a symbol then evaluation examines
the symbol's function cell, and uses its contents instead of the
original symbol.  If the contents are another symbol, this process,
called "symbol function indirection", is repeated until it obtains a
non-symbol.  *Note Function Names::, for more information about symbol
function indirection.

   One possible consequence of this process is an infinite loop, in the
event that a symbol's function cell refers to the same symbol.
Otherwise, we eventually obtain a non-symbol, which ought to be a
function or other suitable object.

   More precisely, we should now have a Lisp function (a lambda
expression), a byte-code function, a primitive function, a Lisp macro, a
special form, or an autoload object.  Each of these types is a case
described in one of the following sections.  If the object is not one of
these types, Emacs signals an 'invalid-function' error.

   The following example illustrates the symbol indirection process.  We
use 'fset' to set the function cell of a symbol and 'symbol-function' to
get the function cell contents (*note Function Cells::).  Specifically,
we store the symbol 'car' into the function cell of 'first', and the
symbol 'first' into the function cell of 'erste'.

     ;; Build this function cell linkage:
     ;;   -------------       -----        -------        -------
     ;;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
     ;;   -------------       -----        -------        -------
     (symbol-function 'car)
          => #<subr car>
     (fset 'first 'car)
          => car
     (fset 'erste 'first)
          => first
     (erste '(1 2 3))   ; Call the function referenced by 'erste'.
          => 1

   By contrast, the following example calls a function without any
symbol function indirection, because the first element is an anonymous
Lisp function, not a symbol.

     ((lambda (arg) (erste arg))
      '(1 2 3))
          => 1

Executing the function itself evaluates its body; this does involve
symbol function indirection when calling 'erste'.

   This form is rarely used and is now deprecated.  Instead, you should
write it as:

     (funcall (lambda (arg) (erste arg))
              '(1 2 3))
   or just
     (let ((arg '(1 2 3))) (erste arg))

   The built-in function 'indirect-function' provides an easy way to
perform symbol function indirection explicitly.

 -- Function: indirect-function function &optional noerror
     This function returns the meaning of FUNCTION as a function.  If
     FUNCTION is a symbol, then it finds FUNCTION's function definition
     and starts over with that value.  If FUNCTION is not a symbol, then
     it returns FUNCTION itself.

     This function returns 'nil' if the final symbol is unbound.  It
     signals a 'cyclic-function-indirection' error if there is a loop in
     the chain of symbols.

     The optional argument NOERROR is obsolete, kept for backward
     compatibility, and has no effect.

     Here is how you could define 'indirect-function' in Lisp:

          (defun indirect-function (function)
            (if (symbolp function)
                (indirect-function (symbol-function function))
              function))

==============================================================================
File: elisp.info,  Node: |Function_Forms|,  Next: |Macro_Forms|,  Prev: |Function_Indirection|,  Up: |Forms|
==============================================================================

                                                                *Function_Forms*

10.2.5 Evaluation of Function Forms
-----------------------------------

If the first element of a list being evaluated is a Lisp function
object, byte-code object or primitive function object, then that list is
a "function call".  For example, here is a call to the function '+':

     (+ 1 x)

   The first step in evaluating a function call is to evaluate the
remaining elements of the list from left to right.  The results are the
actual argument values, one value for each list element.  The next step
is to call the function with this list of arguments, effectively using
the function 'apply' (*note Calling Functions::).  If the function is
written in Lisp, the arguments are used to bind the argument variables
of the function (*note Lambda Expressions::); then the forms in the
function body are evaluated in order, and the value of the last body
form becomes the value of the function call.

==============================================================================
File: elisp.info,  Node: |Macro_Forms|,  Next: |Special_Forms|,  Prev: |Function_Forms|,  Up: |Forms|
==============================================================================

                                                                   *Macro_Forms*

10.2.6 Lisp Macro Evaluation
----------------------------

If the first element of a list being evaluated is a macro object, then
the list is a "macro call".  When a macro call is evaluated, the
elements of the rest of the list are _not_ initially evaluated.
Instead, these elements themselves are used as the arguments of the
macro.  The macro definition computes a replacement form, called the
"expansion" of the macro, to be evaluated in place of the original form.
The expansion may be any sort of form: a self-evaluating constant, a
symbol, or a list.  If the expansion is itself a macro call, this
process of expansion repeats until some other sort of form results.

   Ordinary evaluation of a macro call finishes by evaluating the
expansion.  However, the macro expansion is not necessarily evaluated
right away, or at all, because other programs also expand macro calls,
and they may or may not evaluate the expansions.

   Normally, the argument expressions are not evaluated as part of
computing the macro expansion, but instead appear as part of the
expansion, so they are computed when the expansion is evaluated.

   For example, given a macro defined as follows:

     (defmacro cadr (x)
       (list 'car (list 'cdr x)))

an expression such as '(cadr (assq 'handler list))' is a macro call, and
its expansion is:

     (car (cdr (assq 'handler list)))

Note that the argument '(assq 'handler list)' appears in the expansion.

   *Note Macros::, for a complete description of Emacs Lisp macros.

==============================================================================
File: elisp.info,  Node: |Special_Forms|,  Next: |Autoloading|,  Prev: |Macro_Forms|,  Up: |Forms|
==============================================================================

                                                                 *Special_Forms*

10.2.7 Special Forms
--------------------

A "special form" is a primitive function specially marked so that its
arguments are not all evaluated.  Most special forms define control
structures or perform variable bindings--things which functions cannot
do.

   Each special form has its own rules for which arguments are evaluated
and which are used without evaluation.  Whether a particular argument is
evaluated may depend on the results of evaluating other arguments.

   If an expression's first symbol is that of a special form, the
expression should follow the rules of that special form; otherwise,
Emacs's behavior is not well-defined (though it will not crash).  For
example, '((lambda (x) x . 3) 4)' contains a subexpression that begins
with 'lambda' but is not a well-formed 'lambda' expression, so Emacs may
signal an error, or may return 3 or 4 or 'nil', or may behave in other
ways.

 -- Function: special-form-p object
     This predicate tests whether its argument is a special form, and
     returns 't' if so, 'nil' otherwise.

   Here is a list, in alphabetical order, of all of the special forms in
Emacs Lisp with a reference to where each is described.

'and'
     *note Combining Conditions::

'catch'
     *note Catch and Throw::

'cond'
     *note Conditionals::

'condition-case'
     *note Handling Errors::

'defconst'
     *note Defining Variables::

'defvar'
     *note Defining Variables::

'function'
     *note Anonymous Functions::

'if'
     *note Conditionals::

'interactive'
     *note Interactive Call::

'lambda'
     *note Lambda Expressions::

'let'
'let*'
     *note Local Variables::

'or'
     *note Combining Conditions::

'prog1'
'prog2'
'progn'
     *note Sequencing::

'quote'
     *note Quoting::

'save-current-buffer'
     *note Current Buffer::

'save-excursion'
     *note Excursions::

'save-restriction'
     *note Narrowing::

'setq'
     *note Setting Variables::

'setq-default'
     *note Creating Buffer-Local::

'unwind-protect'
     *note Nonlocal Exits::

'while'
     *note Iteration::

     Common Lisp note: Here are some comparisons of special forms in GNU
     Emacs Lisp and Common Lisp.  'setq', 'if', and 'catch' are special
     forms in both Emacs Lisp and Common Lisp.  'save-excursion' is a
     special form in Emacs Lisp, but doesn't exist in Common Lisp.
     'throw' is a special form in Common Lisp (because it must be able
     to throw multiple values), but it is a function in Emacs Lisp
     (which doesn't have multiple values).

==============================================================================
File: elisp.info,  Node: |Autoloading|,  Prev: |Special_Forms|,  Up: |Forms|
==============================================================================

                                                                   *Autoloading*

10.2.8 Autoloading
------------------

The "autoload" feature allows you to call a function or macro whose
function definition has not yet been loaded into Emacs.  It specifies
which file contains the definition.  When an autoload object appears as
a symbol's function definition, calling that symbol as a function
automatically loads the specified file; then it calls the real
definition loaded from that file.  The way to arrange for an autoload
object to appear as a symbol's function definition is described in *note
Autoload::.

==============================================================================
File: elisp.info,  Node: |Quoting|,  Next: |Backquote|,  Prev: |Forms|,  Up: |Evaluation|
==============================================================================

                                                                       *Quoting*

10.3 Quoting
------------

The special form 'quote' returns its single argument, as written,
without evaluating it.  This provides a way to include constant symbols
and lists, which are not self-evaluating objects, in a program.  (It is
not necessary to quote self-evaluating objects such as numbers, strings,
and vectors.)

 -- Special Form: quote object
     This special form returns OBJECT, without evaluating it.  The
     returned value might be shared and should not be modified.  *Note
     Self-Evaluating Forms::.

   Because 'quote' is used so often in programs, Lisp provides a
convenient read syntax for it.  An apostrophe character (''') followed
by a Lisp object (in read syntax) expands to a list whose first element
is 'quote', and whose second element is the object.  Thus, the read
syntax ''x' is an abbreviation for '(quote x)'.

   Here are some examples of expressions that use 'quote':

     (quote (+ 1 2))
          => (+ 1 2)
     (quote foo)
          => foo
     'foo
          => foo
     ''foo
          => 'foo
     '(quote foo)
          => 'foo
     ['foo]
          => ['foo]

   Although the expressions '(list '+ 1 2)' and ''(+ 1 2)' both yield
lists equal to '(+ 1 2)', the former yields a freshly-minted mutable
list whereas the latter yields a list built from conses that might be
shared and should not be modified.  *Note Self-Evaluating Forms::.

   Other quoting constructs include 'function' (*note Anonymous
Functions::), which causes an anonymous lambda expression written in
Lisp to be compiled, and '`' (*note Backquote::), which is used to quote
only part of a list, while computing and substituting other parts.

==============================================================================
File: elisp.info,  Node: |Backquote|,  Next: |Eval|,  Prev: |Quoting|,  Up: |Evaluation|
==============================================================================

                                                                     *Backquote*

10.4 Backquote
--------------

"Backquote constructs" allow you to quote a list, but selectively
evaluate elements of that list.  In the simplest case, it is identical
to the special form 'quote' (described in the previous section; *note
Quoting::).  For example, these two forms yield identical results:

     `(a list of (+ 2 3) elements)
          => (a list of (+ 2 3) elements)
     '(a list of (+ 2 3) elements)
          => (a list of (+ 2 3) elements)

   The special marker ',' inside of the argument to backquote indicates
a value that isn't constant.  The Emacs Lisp evaluator evaluates the
argument of ',', and puts the value in the list structure:

     `(a list of ,(+ 2 3) elements)
          => (a list of 5 elements)

Substitution with ',' is allowed at deeper levels of the list structure
also.  For example:

     `(1 2 (3 ,(+ 4 5)))
          => (1 2 (3 9))

   You can also "splice" an evaluated value into the resulting list,
using the special marker ',@'.  The elements of the spliced list become
elements at the same level as the other elements of the resulting list.
The equivalent code without using '`' is often unreadable.  Here are
some examples:

     (setq some-list '(2 3))
          => (2 3)
     (cons 1 (append some-list '(4) some-list))
          => (1 2 3 4 2 3)
     `(1 ,@some-list 4 ,@some-list)
          => (1 2 3 4 2 3)

     (setq list '(hack foo bar))
          => (hack foo bar)
     (cons 'use
       (cons 'the
         (cons 'words (append (cdr list) '(as elements)))))
          => (use the words foo bar as elements)
     `(use the words ,@(cdr list) as elements)
          => (use the words foo bar as elements)

   If a subexpression of a backquote construct has no substitutions or
splices, it acts like 'quote' in that it yields conses, vectors and
strings that might be shared and should not be modified.  *Note
Self-Evaluating Forms::.

==============================================================================
File: elisp.info,  Node: |Eval|,  Next: |Deferred_Eval|,  Prev: |Backquote|,  Up: |Evaluation|
==============================================================================

                                                                          *Eval*

10.5 Eval
---------

Most often, forms are evaluated automatically, by virtue of their
occurrence in a program being run.  On rare occasions, you may need to
write code that evaluates a form that is computed at run time, such as
after reading a form from text being edited or getting one from a
property list.  On these occasions, use the 'eval' function.  Often
'eval' is not needed and something else should be used instead.  For
example, to get the value of a variable, while 'eval' works,
'symbol-value' is preferable; or rather than store expressions in a
property list that then need to go through 'eval', it is better to store
functions instead that are then passed to 'funcall'.

   The functions and variables described in this section evaluate forms,
specify limits to the evaluation process, or record recently returned
values.  Loading a file also does evaluation (*note Loading::).

   It is generally cleaner and more flexible to store a function in a
data structure, and call it with 'funcall' or 'apply', than to store an
expression in the data structure and evaluate it.  Using functions
provides the ability to pass information to them as arguments.

 -- Function: eval form &optional lexical
     This is the basic function for evaluating an expression.  It
     evaluates FORM in the current environment, and returns the result.
     The type of the FORM object determines how it is evaluated.  *Note
     Forms::.

     The argument LEXICAL specifies the scoping rule for local variables
     (*note Variable Scoping::).  If it is omitted or 'nil', that means
     to evaluate FORM using the default dynamic scoping rule.  If it is
     't', that means to use the lexical scoping rule.  The value of
     LEXICAL can also be a non-empty alist specifying a particular
     "lexical environment" for lexical bindings; however, this feature
     is only useful for specialized purposes, such as in Emacs Lisp
     debuggers.  *Note Lexical Binding::.

     Since 'eval' is a function, the argument expression that appears in
     a call to 'eval' is evaluated twice: once as preparation before
     'eval' is called, and again by the 'eval' function itself.  Here is
     an example:

          (setq foo 'bar)
               => bar
          (setq bar 'baz)
               => baz
          ;; Here 'eval' receives argument 'foo'
          (eval 'foo)
               => bar
          ;; Here 'eval' receives argument 'bar', which is the value of 'foo'
          (eval foo)
               => baz

     The number of currently active calls to 'eval' is limited to
     'max-lisp-eval-depth' (see below).

 -- Command: eval-region start end &optional stream read-function
     This function evaluates the forms in the current buffer in the
     region defined by the positions START and END.  It reads forms from
     the region and calls 'eval' on them until the end of the region is
     reached, or until an error is signaled and not handled.

     By default, 'eval-region' does not produce any output.  However, if
     STREAM is non-'nil', any output produced by output functions (*note
     Output Functions::), as well as the values that result from
     evaluating the expressions in the region are printed using STREAM.
     *Note Output Streams::.

     If READ-FUNCTION is non-'nil', it should be a function, which is
     used instead of 'read' to read expressions one by one.  This
     function is called with one argument, the stream for reading input.
     You can also use the variable 'load-read-function' (*note How
     Programs Do Loading: Definition of load-read-function.) to specify
     this function, but it is more robust to use the READ-FUNCTION
     argument.

     'eval-region' does not move point.  It always returns 'nil'.

 -- Command: eval-buffer &optional buffer-or-name stream filename
          unibyte print
     This is similar to 'eval-region', but the arguments provide
     different optional features.  'eval-buffer' operates on the entire
     accessible portion of buffer BUFFER-OR-NAME (*note
     (emacs)Narrowing::).  BUFFER-OR-NAME can be a buffer, a buffer name
     (a string), or 'nil' (or omitted), which means to use the current
     buffer.  STREAM is used as in 'eval-region', unless STREAM is 'nil'
     and PRINT non-'nil'.  In that case, values that result from
     evaluating the expressions are still discarded, but the output of
     the output functions is printed in the echo area.  FILENAME is the
     file name to use for 'load-history' (*note Unloading::), and
     defaults to 'buffer-file-name' (*note Buffer File Name::).  If
     UNIBYTE is non-'nil', 'read' converts strings to unibyte whenever
     possible.

     'eval-current-buffer' is an alias for this command.

 -- User Option: max-lisp-eval-depth
     This variable defines the maximum depth allowed in calls to 'eval',
     'apply', and 'funcall' before an error is signaled (with error
     message '"Lisp nesting exceeds max-lisp-eval-depth"').

     This limit, with the associated error when it is exceeded, is one
     way Emacs Lisp avoids infinite recursion on an ill-defined
     function.  If you increase the value of 'max-lisp-eval-depth' too
     much, such code can cause stack overflow instead.  On some systems,
     this overflow can be handled.  In that case, normal Lisp evaluation
     is interrupted and control is transferred back to the top level
     command loop ('top-level').  Note that there is no way to enter
     Emacs Lisp debugger in this situation.  *Note Error Debugging::.

     The depth limit counts internal uses of 'eval', 'apply', and
     'funcall', such as for calling the functions mentioned in Lisp
     expressions, and recursive evaluation of function call arguments
     and function body forms, as well as explicit calls in Lisp code.

     The default value of this variable is 800.  If you set it to a
     value less than 100, Lisp will reset it to 100 if the given value
     is reached.  Entry to the Lisp debugger increases the value, if
     there is little room left, to make sure the debugger itself has
     room to execute.

     'max-specpdl-size' provides another limit on nesting.  *Note Local
     Variables: Definition of max-specpdl-size.

 -- Variable: values
     The value of this variable is a list of the values returned by all
     the expressions that were read, evaluated, and printed from buffers
     (including the minibuffer) by the standard Emacs commands which do
     this.  (Note that this does _not_ include evaluation in 'ielm'
     buffers, nor evaluation using 'C-j', 'C-x C-e', and similar
     evaluation commands in 'lisp-interaction-mode'.)  The elements are
     ordered most recent first.

          (setq x 1)
               => 1
          (list 'A (1+ 2) auto-save-default)
               => (A 3 t)
          values
               => ((A 3 t) 1 ...)

     This variable is useful for referring back to values of forms
     recently evaluated.  It is generally a bad idea to print the value
     of 'values' itself, since this may be very long.  Instead, examine
     particular elements, like this:

          ;; Refer to the most recent evaluation result.
          (nth 0 values)
               => (A 3 t)
          ;; That put a new element on,
          ;;   so all elements move back one.
          (nth 1 values)
               => (A 3 t)
          ;; This gets the element that was next-to-most-recent
          ;;   before this example.
          (nth 3 values)
               => 1

==============================================================================
File: elisp.info,  Node: |Deferred_Eval|,  Prev: |Eval|,  Up: |Evaluation|
==============================================================================

                                                                 *Deferred_Eval*

10.6 Deferred and Lazy Evaluation
---------------------------------

Sometimes it is useful to delay the evaluation of an expression, for
example if you want to avoid performing a time-consuming calculation if
it turns out that the result is not needed in the future of the program.
The 'thunk' library provides the following functions and macros to
support such "deferred evaluation":

 -- Macro: thunk-delay forms...
     Return a "thunk" for evaluating the FORMS.  A thunk is a closure
     (*note Closures::) that inherits the lexical environment of the
     'thunk-delay' call.  Using this macro requires 'lexical-binding'.

 -- Function: thunk-force thunk
     Force THUNK to perform the evaluation of the forms specified in the
     'thunk-delay' that created the thunk.  The result of the evaluation
     of the last form is returned.  The THUNK also "remembers" that it
     has been forced: Any further calls of 'thunk-force' with the same
     THUNK will just return the same result without evaluating the forms
     again.

 -- Macro: thunk-let (bindings...) forms...
     This macro is analogous to 'let' but creates "lazy" variable
     bindings.  Any binding has the form '(SYMBOL VALUE-FORM)'.  Unlike
     'let', the evaluation of any VALUE-FORM is deferred until the
     binding of the according SYMBOL is used for the first time when
     evaluating the FORMS.  Any VALUE-FORM is evaluated at most once.
     Using this macro requires 'lexical-binding'.

   Example:

     (defun f (number)
       (thunk-let ((derived-number
                   (progn (message "Calculating 1 plus 2 times %d" number)
                          (1+ (* 2 number)))))
         (if (> number 10)
             derived-number
           number)))

     (f 5)
     => 5

     (f 12)
     -| Calculating 1 plus 2 times 12
     => 25


   Because of the special nature of lazily bound variables, it is an
error to set them (e.g. with 'setq').

 -- Macro: thunk-let* (bindings...) forms...
     This is like 'thunk-let' but any expression in BINDINGS is allowed
     to refer to preceding bindings in this 'thunk-let*' form.  Using
     this macro requires 'lexical-binding'.

     (thunk-let* ((x (prog2 (message "Calculating x...")
                         (+ 1 1)
                       (message "Finished calculating x")))
                  (y (prog2 (message "Calculating y...")
                         (+ x 1)
                       (message "Finished calculating y")))
                  (z (prog2 (message "Calculating z...")
                         (+ y 1)
                       (message "Finished calculating z")))
                  (a (prog2 (message "Calculating a...")
                         (+ z 1)
                       (message "Finished calculating a"))))
       (* z x))

     -| Calculating z...
     -| Calculating y...
     -| Calculating x...
     -| Finished calculating x
     -| Finished calculating y
     -| Finished calculating z
     => 8


   'thunk-let' and 'thunk-let*' use thunks implicitly: their expansion
creates helper symbols and binds them to thunks wrapping the binding
expressions.  All references to the original variables in the body FORMS
are then replaced by an expression that calls 'thunk-force' with the
according helper variable as the argument.  So, any code using
'thunk-let' or 'thunk-let*' could be rewritten to use thunks, but in
many cases using these macros results in nicer code than using thunks
explicitly.

==============================================================================
File: elisp.info,  Node: |Control_Structures|,  Next: |Variables|,  Prev: |Evaluation|,  Up: |Top|
==============================================================================

                                                            *Control_Structures*

11 Control Structures
=====================

A Lisp program consists of a set of "expressions", or "forms" (*note
Forms::).  We control the order of execution of these forms by enclosing
them in "control structures".  Control structures are special forms
which control when, whether, or how many times to execute the forms they
contain.

   The simplest order of execution is sequential execution: first form
A, then form B, and so on.  This is what happens when you write several
forms in succession in the body of a function, or at top level in a file
of Lisp code--the forms are executed in the order written.  We call this
"textual order".  For example, if a function body consists of two forms
A and B, evaluation of the function evaluates first A and then B.  The
result of evaluating B becomes the value of the function.

   Explicit control structures make possible an order of execution other
than sequential.

   Emacs Lisp provides several kinds of control structure, including
other varieties of sequencing, conditionals, iteration, and (controlled)
jumps--all discussed below.  The built-in control structures are special
forms since their subforms are not necessarily evaluated or not
evaluated sequentially.  You can use macros to define your own control
structure constructs (*note Macros::).

MENU

* |Sequencing|::             Evaluation in textual order.
* |Conditionals|::           'if', 'cond', 'when', 'unless'.
* |Combining_Conditions|::   'and', 'or', 'not', and friends.
* |Pattern_Matching_Conditional|::  How to use 'pcase' and friends.
* |Iteration|::              'while' loops.
* |Generators|::             Generic sequences and coroutines.
* |Nonlocal_Exits|::         Jumping out of a sequence.

==============================================================================
File: elisp.info,  Node: |Sequencing|,  Next: |Conditionals|,  Up: |Control_Structures|
==============================================================================

                                                                    *Sequencing*

11.1 Sequencing
---------------

Evaluating forms in the order they appear is the most common way control
passes from one form to another.  In some contexts, such as in a
function body, this happens automatically.  Elsewhere you must use a
control structure construct to do this: 'progn', the simplest control
construct of Lisp.

   A 'progn' special form looks like this:

     (progn A B C ...)

and it says to execute the forms A, B, C, and so on, in that order.
These forms are called the "body" of the 'progn' form.  The value of the
last form in the body becomes the value of the entire 'progn'.
'(progn)' returns 'nil'.

   In the early days of Lisp, 'progn' was the only way to execute two or
more forms in succession and use the value of the last of them.  But
programmers found they often needed to use a 'progn' in the body of a
function, where (at that time) only one form was allowed.  So the body
of a function was made into an implicit 'progn': several forms are
allowed just as in the body of an actual 'progn'.  Many other control
structures likewise contain an implicit 'progn'.  As a result, 'progn'
is not used as much as it was many years ago.  It is needed now most
often inside an 'unwind-protect', 'and', 'or', or in the THEN-part of an
'if'.

 -- Special Form: progn forms...
     This special form evaluates all of the FORMS, in textual order,
     returning the result of the final form.

          (progn (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               -| "The first form"
               -| "The second form"
               -| "The third form"
          => "The third form"

   Two other constructs likewise evaluate a series of forms but return
different values:

 -- Special Form: prog1 form1 forms...
     This special form evaluates FORM1 and all of the FORMS, in textual
     order, returning the result of FORM1.

          (prog1 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               -| "The first form"
               -| "The second form"
               -| "The third form"
          => "The first form"

     Here is a way to remove the first element from a list in the
     variable 'x', then return the value of that former element:

          (prog1 (car x) (setq x (cdr x)))

 -- Special Form: prog2 form1 form2 forms...
     This special form evaluates FORM1, FORM2, and all of the following
     FORMS, in textual order, returning the result of FORM2.

          (prog2 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               -| "The first form"
               -| "The second form"
               -| "The third form"
          => "The second form"

==============================================================================
File: elisp.info,  Node: |Conditionals|,  Next: |Combining_Conditions|,  Prev: |Sequencing|,  Up: |Control_Structures|
==============================================================================

                                                                  *Conditionals*

11.2 Conditionals
-----------------

Conditional control structures choose among alternatives.  Emacs Lisp
has five conditional forms: 'if', which is much the same as in other
languages; 'when' and 'unless', which are variants of 'if'; 'cond',
which is a generalized case statement; and 'pcase', which is a
generalization of 'cond' (*note Pattern-Matching Conditional::).

 -- Special Form: if condition then-form else-forms...
     'if' chooses between the THEN-FORM and the ELSE-FORMS based on the
     value of CONDITION.  If the evaluated CONDITION is non-'nil',
     THEN-FORM is evaluated and the result returned.  Otherwise, the
     ELSE-FORMS are evaluated in textual order, and the value of the
     last one is returned.  (The ELSE part of 'if' is an example of an
     implicit 'progn'.  *Note Sequencing::.)

     If CONDITION has the value 'nil', and no ELSE-FORMS are given, 'if'
     returns 'nil'.

     'if' is a special form because the branch that is not selected is
     never evaluated--it is ignored.  Thus, in this example, 'true' is
     not printed because 'print' is never called:

          (if nil
              (print 'true)
            'very-false)
          => very-false

 -- Macro: when condition then-forms...
     This is a variant of 'if' where there are no ELSE-FORMS, and
     possibly several THEN-FORMS.  In particular,

          (when CONDITION A B C)

     is entirely equivalent to

          (if CONDITION (progn A B C) nil)

 -- Macro: unless condition forms...
     This is a variant of 'if' where there is no THEN-FORM:

          (unless CONDITION A B C)

     is entirely equivalent to

          (if CONDITION nil
             A B C)

 -- Special Form: cond clause...
     'cond' chooses among an arbitrary number of alternatives.  Each
     CLAUSE in the 'cond' must be a list.  The CAR of this list is the
     CONDITION; the remaining elements, if any, the BODY-FORMS.  Thus, a
     clause looks like this:

          (CONDITION BODY-FORMS...)

     'cond' tries the clauses in textual order, by evaluating the
     CONDITION of each clause.  If the value of CONDITION is non-'nil',
     the clause succeeds; then 'cond' evaluates its BODY-FORMS, and
     returns the value of the last of BODY-FORMS.  Any remaining clauses
     are ignored.

     If the value of CONDITION is 'nil', the clause fails, so the 'cond'
     moves on to the following clause, trying its CONDITION.

     A clause may also look like this:

          (CONDITION)

     Then, if CONDITION is non-'nil' when tested, the 'cond' form
     returns the value of CONDITION.

     If every CONDITION evaluates to 'nil', so that every clause fails,
     'cond' returns 'nil'.

     The following example has four clauses, which test for the cases
     where the value of 'x' is a number, string, buffer and symbol,
     respectively:

          (cond ((numberp x) x)
                ((stringp x) x)
                ((bufferp x)
                 (setq temporary-hack x) ; multiple body-forms
                 (buffer-name x))        ; in one clause
                ((symbolp x) (symbol-value x)))

     Often we want to execute the last clause whenever none of the
     previous clauses was successful.  To do this, we use 't' as the
     CONDITION of the last clause, like this: '(t BODY-FORMS)'.  The
     form 't' evaluates to 't', which is never 'nil', so this clause
     never fails, provided the 'cond' gets to it at all.  For example:

          (setq a 5)
          (cond ((eq a 'hack) 'foo)
                (t "default"))
          => "default"

     This 'cond' expression returns 'foo' if the value of 'a' is 'hack',
     and returns the string '"default"' otherwise.

   Any conditional construct can be expressed with 'cond' or with 'if'.
Therefore, the choice between them is a matter of style.  For example:

     (if A B C)
     ???
     (cond (A B) (t C))

==============================================================================
File: elisp.info,  Node: |Combining_Conditions|,  Next: |Pattern_Matching_Conditional|,  Prev: |Conditionals|,  Up: |Control_Structures|
==============================================================================

                                                          *Combining_Conditions*

11.3 Constructs for Combining Conditions
----------------------------------------

This section describes constructs that are often used together with 'if'
and 'cond' to express complicated conditions.  The constructs 'and' and
'or' can also be used individually as kinds of multiple conditional
constructs.

 -- Function: not condition
     This function tests for the falsehood of CONDITION.  It returns 't'
     if CONDITION is 'nil', and 'nil' otherwise.  The function 'not' is
     identical to 'null', and we recommend using the name 'null' if you
     are testing for an empty list.

 -- Special Form: and conditions...
     The 'and' special form tests whether all the CONDITIONS are true.
     It works by evaluating the CONDITIONS one by one in the order
     written.

     If any of the CONDITIONS evaluates to 'nil', then the result of the
     'and' must be 'nil' regardless of the remaining CONDITIONS; so
     'and' returns 'nil' right away, ignoring the remaining CONDITIONS.

     If all the CONDITIONS turn out non-'nil', then the value of the
     last of them becomes the value of the 'and' form.  Just '(and)',
     with no CONDITIONS, returns 't', appropriate because all the
     CONDITIONS turned out non-'nil'.  (Think about it; which one did
     not?)

     Here is an example.  The first condition returns the integer 1,
     which is not 'nil'.  Similarly, the second condition returns the
     integer 2, which is not 'nil'.  The third condition is 'nil', so
     the remaining condition is never evaluated.

          (and (print 1) (print 2) nil (print 3))
               -| 1
               -| 2
          => nil

     Here is a more realistic example of using 'and':

          (if (and (consp foo) (eq (car foo) 'x))
              (message "foo is a list starting with x"))

     Note that '(car foo)' is not executed if '(consp foo)' returns
     'nil', thus avoiding an error.

     'and' expressions can also be written using either 'if' or 'cond'.
     Here's how:

          (and ARG1 ARG2 ARG3)
          ???
          (if ARG1 (if ARG2 ARG3))
          ???
          (cond (ARG1 (cond (ARG2 ARG3))))

 -- Special Form: or conditions...
     The 'or' special form tests whether at least one of the CONDITIONS
     is true.  It works by evaluating all the CONDITIONS one by one in
     the order written.

     If any of the CONDITIONS evaluates to a non-'nil' value, then the
     result of the 'or' must be non-'nil'; so 'or' returns right away,
     ignoring the remaining CONDITIONS.  The value it returns is the
     non-'nil' value of the condition just evaluated.

     If all the CONDITIONS turn out 'nil', then the 'or' expression
     returns 'nil'.  Just '(or)', with no CONDITIONS, returns 'nil',
     appropriate because all the CONDITIONS turned out 'nil'.  (Think
     about it; which one did not?)

     For example, this expression tests whether 'x' is either 'nil' or
     the integer zero:

          (or (eq x nil) (eq x 0))

     Like the 'and' construct, 'or' can be written in terms of 'cond'.
     For example:

          (or ARG1 ARG2 ARG3)
          ???
          (cond (ARG1)
                (ARG2)
                (ARG3))

     You could almost write 'or' in terms of 'if', but not quite:

          (if ARG1 ARG1
            (if ARG2 ARG2
              ARG3))

     This is not completely equivalent because it can evaluate ARG1 or
     ARG2 twice.  By contrast, '(or ARG1 ARG2 ARG3)' never evaluates any
     argument more than once.

 -- Function: xor condition1 condition2
     This function returns the boolean exclusive-or of CONDITION1 and
     CONDITION2.  That is, 'xor' returns 'nil' if either both arguments
     are 'nil', or both are non-'nil'.  Otherwise, it returns the value
     of that argument which is non-'nil'.

     Note that in contrast to 'or', both arguments are always evaluated.

==============================================================================
File: elisp.info,  Node: |Pattern_Matching_Conditional|,  Next: |Iteration|,  Prev: |Combining_Conditions|,  Up: |Control_Structures|
==============================================================================

                                                  *Pattern_Matching_Conditional*

11.4 Pattern-Matching Conditional
---------------------------------

Aside from the four basic conditional forms, Emacs Lisp also has a
pattern-matching conditional form, the 'pcase' macro, a hybrid of 'cond'
and 'cl-case' (*note (cl)Conditionals::) that overcomes their
limitations and introduces the "pattern matching programming style".
The limitations that 'pcase' overcomes are:

   * The 'cond' form chooses among alternatives by evaluating the
     predicate CONDITION of each of its clauses (*note Conditionals::).
     The primary limitation is that variables let-bound in CONDITION are
     not available to the clause's BODY-FORMS.

     Another annoyance (more an inconvenience than a limitation) is that
     when a series of CONDITION predicates implement equality tests,
     there is a lot of repeated code.  ('cl-case' solves this
     inconvenience.)

   * The 'cl-case' macro chooses among alternatives by evaluating the
     equality of its first argument against a set of specific values.

     Its limitations are two-fold:

       1. The equality tests use 'eql'.
       2. The values must be known and written in advance.

     These render 'cl-case' unsuitable for strings or compound data
     structures (e.g., lists or vectors).  ('cond' doesn't have these
     limitations, but it has others, see above.)

Conceptually, the 'pcase' macro borrows the first-arg focus of 'cl-case'
and the clause-processing flow of 'cond', replacing CONDITION with a
generalization of the equality test which is a variant of "pattern
matching", and adding facilities so that you can concisely express a
clause's predicate, and arrange to share let-bindings between a clause's
predicate and BODY-FORMS.

   The concise expression of a predicate is known as a "pattern".  When
the predicate, called on the value of the first arg, returns non-'nil',
we say that "the pattern matches the value" (or sometimes "the value
matches the pattern").

MENU

* The 'pcase' macro: pcase Macro.  Includes examples and caveats.
* Extending 'pcase': Extending pcase.  Define new kinds of patterns.
* Backquote-Style Patterns: Backquote Patterns.  Structural patterns matching.
* |Destructuring_with_pcase_Patterns|:: Using pcase patterns to extract subfields.

==============================================================================
File: elisp.info,  Node: |pcase_Macro|,  Next: |Extending_pcase|,  Up: |Pattern_Matching_Conditional|
==============================================================================

                                                                   *pcase_Macro*

11.4.1 The 'pcase' macro
------------------------

For background, *Note Pattern-Matching Conditional::.

 -- Macro: pcase expression &rest clauses
     Each clause in CLAUSES has the form: '(PATTERN BODY-FORMS...)'.

     Evaluate EXPRESSION to determine its value, EXPVAL.  Find the first
     clause in CLAUSES whose PATTERN matches EXPVAL and pass control to
     that clause's BODY-FORMS.

     If there is a match, the value of 'pcase' is the value of the last
     of BODY-FORMS in the successful clause.  Otherwise, 'pcase'
     evaluates to 'nil'.

   Each PATTERN has to be a "pcase pattern", which can use either one of
the core patterns defined below, or one of the patterns defined via
'pcase-defmacro' (*note Extending pcase::).

   The rest of this subsection describes different forms of core
patterns, presents some examples, and concludes with important caveats
on using the let-binding facility provided by some pattern forms.  A
core pattern can have the following forms:

'_'
     Matches any EXPVAL.  This is also known as "don't care" or
     "wildcard".

''VAL'
     Matches if EXPVAL equals VAL.  The comparison is done as if by
     'equal' (*note Equality Predicates::).

'KEYWORD'
'INTEGER'
'STRING'
     Matches if EXPVAL equals the literal object.  This is a special
     case of ''VAL', above, possible because literal objects of these
     types are self-quoting.

'SYMBOL'
     Matches any EXPVAL, and additionally let-binds SYMBOL to EXPVAL,
     such that this binding is available to BODY-FORMS (*note Dynamic
     Binding::).

     If SYMBOL is part of a sequencing pattern SEQPAT (e.g., by using
     'and', below), the binding is also available to the portion of
     SEQPAT following the appearance of SYMBOL.  This usage has some
     caveats, see *note caveats: pcase-symbol-caveats.

     Two symbols to avoid are 't', which behaves like '_' (above) and is
     deprecated, and 'nil', which signals an error.  Likewise, it makes
     no sense to bind keyword symbols (*note Constant Variables::).

'(pred FUNCTION)'
     Matches if the predicate FUNCTION returns non-'nil' when called on
     EXPVAL.  the predicate FUNCTION can have one of the following
     forms:

     function name (a symbol)
          Call the named function with one argument, EXPVAL.

          Example: 'integerp'

     lambda expression
          Call the anonymous function with one argument, EXPVAL (*note
          Lambda Expressions::).

          Example: '(lambda (n) (= 42 n))'

     function call with N args
          Call the function (the first element of the function call)
          with N arguments (the other elements) and an additional N+1-th
          argument that is EXPVAL.

          Example: '(= 42)'
          In this example, the function is '=', N is one, and the actual
          function call becomes: '(= 42 EXPVAL)'.

'(app FUNCTION PATTERN)'
     Matches if FUNCTION called on EXPVAL returns a value that matches
     PATTERN.  FUNCTION can take one of the forms described for 'pred',
     above.  Unlike 'pred', however, 'app' tests the result against
     PATTERN, rather than against a boolean truth value.

'(guard BOOLEAN-EXPRESSION)'
     Matches if BOOLEAN-EXPRESSION evaluates to non-'nil'.

'(let PATTERN EXPR)'
     Evaluates EXPR to get EXPRVAL and matches if EXPRVAL matches
     PATTERN.  (It is called 'let' because PATTERN can bind symbols to
     values using SYMBOL.)

   A "sequencing pattern" (also known as SEQPAT) is a pattern that
processes its sub-pattern arguments in sequence.  There are two for
'pcase': 'and' and 'or'.  They behave in a similar manner to the special
forms that share their name (*note Combining Conditions::), but instead
of processing values, they process sub-patterns.

'(and PATTERN1...)'
     Attempts to match PATTERN1..., in order, until one of them fails to
     match.  In that case, 'and' likewise fails to match, and the rest
     of the sub-patterns are not tested.  If all sub-patterns match,
     'and' matches.

'(or PATTERN1 PATTERN2...)'
     Attempts to match PATTERN1, PATTERN2, ..., in order, until one of
     them succeeds.  In that case, 'or' likewise matches, and the rest
     of the sub-patterns are not tested.  (Note that there must be at
     least two sub-patterns.  Simply '(or PATTERN1)' signals error.)

     To present a consistent environment (*note Intro Eval::) to
     BODY-FORMS (thus avoiding an evaluation error on match), if any of
     the sub-patterns let-binds a set of symbols, they _must_ all bind
     the same set of symbols.

'(rx RX-EXPR...)'
     Matches strings against the regexp RX-EXPR..., using the 'rx'
     regexp notation (*note Rx Notation::), as if by 'string-match'.

     In addition to the usual 'rx' syntax, RX-EXPR... can contain the
     following constructs:

     '(let REF RX-EXPR...)'
          Bind the symbol REF to a submatch that matches RX-EXPR....
          REF is bound in BODY-FORMS to the string of the submatch or
          nil, but can also be used in 'backref'.

     '(backref REF)'
          Like the standard 'backref' construct, but REF can here also
          be a name introduced by a previous '(let REF ...)' construct.

Example: Advantage Over 'cl-case'
---------------------------------

Here's an example that highlights some advantages 'pcase' has over
'cl-case' (*note (cl)Conditionals::).

     (pcase (get-return-code x)
       ;; string
       ((and (pred stringp) msg)
        (message "%s" msg))
       ;; symbol
       ('success       (message "Done!"))
       ('would-block   (message "Sorry, can't do it now"))
       ('read-only     (message "The shmliblick is read-only"))
       ('access-denied (message "You do not have the needed rights"))
       ;; default
       (code           (message "Unknown return code %S" code)))

With 'cl-case', you would need to explicitly declare a local variable
'code' to hold the return value of 'get-return-code'.  Also 'cl-case' is
difficult to use with strings because it uses 'eql' for comparison.

Example: Using 'and'
--------------------

A common idiom is to write a pattern starting with 'and', with one or
more SYMBOL sub-patterns providing bindings to the sub-patterns that
follow (as well as to the body forms).  For example, the following
pattern matches single-digit integers.

     (and
       (pred integerp)
       n                     ; bind 'n' to EXPVAL
       (guard (<= -9 n 9)))

First, 'pred' matches if '(integerp EXPVAL)' evaluates to non-'nil'.
Next, 'n' is a SYMBOL pattern that matches anything and binds 'n' to
EXPVAL.  Lastly, 'guard' matches if the boolean expression '(<= -9 n 9)'
(note the reference to 'n') evaluates to non-'nil'.  If all these
sub-patterns match, 'and' matches.

Example: Reformulation with 'pcase'
-----------------------------------

Here is another example that shows how to reformulate a simple matching
task from its traditional implementation (function 'grok/traditional')
to one using 'pcase' (function 'grok/pcase').  The docstring for both
these functions is: "If OBJ is a string of the form "key:NUMBER", return
NUMBER (a string).  Otherwise, return the list ("149" default)." First,
the traditional implementation (*note Regular Expressions::):

     (defun grok/traditional (obj)
       (if (and (stringp obj)
                (string-match "^key:\\([[:digit:]]+\\)$" obj))
           (match-string 1 obj)
         (list "149" 'default)))

     (grok/traditional "key:0")   => "0"
     (grok/traditional "key:149") => "149"
     (grok/traditional 'monolith) => ("149" default)

The reformulation demonstrates SYMBOL binding as well as 'or', 'and',
'pred', 'app' and 'let'.

     (defun grok/pcase (obj)
       (pcase obj
         ((or                                     ; line 1
           (and                                   ; line 2
            (pred stringp)                        ; line 3
            (pred (string-match                   ; line 4
                   "^key:\\([[:digit:]]+\\)$"))   ; line 5
            (app (match-string 1)                 ; line 6
                 val))                            ; line 7
           (let val (list "149" 'default)))       ; line 8
          val)))                                  ; line 9

     (grok/pcase "key:0")   => "0"
     (grok/pcase "key:149") => "149"
     (grok/pcase 'monolith) => ("149" default)

The bulk of 'grok/pcase' is a single clause of a 'pcase' form, the
pattern on lines 1-8, the (single) body form on line 9.  The pattern is
'or', which tries to match in turn its argument sub-patterns, first
'and' (lines 2-7), then 'let' (line 8), until one of them succeeds.

   As in the previous example (*note Example 1: pcase-example-1.), 'and'
begins with a 'pred' sub-pattern to ensure the following sub-patterns
work with an object of the correct type (string, in this case).  If
'(stringp EXPVAL)' returns 'nil', 'pred' fails, and thus 'and' fails,
too.

   The next 'pred' (lines 4-5) evaluates '(string-match RX EXPVAL)' and
matches if the result is non-'nil', which means that EXPVAL has the
desired form: 'key:NUMBER'.  Again, failing this, 'pred' fails and
'and', too.

   Lastly (in this series of 'and' sub-patterns), 'app' evaluates
'(match-string 1 EXPVAL)' (line 6) to get a temporary value TMP (i.e.,
the "NUMBER" substring) and tries to match TMP against pattern 'val'
(line 7).  Since that is a SYMBOL pattern, it matches unconditionally
and additionally binds 'val' to TMP.

   Now that 'app' has matched, all 'and' sub-patterns have matched, and
so 'and' matches.  Likewise, once 'and' has matched, 'or' matches and
does not proceed to try sub-pattern 'let' (line 8).

   Let's consider the situation where 'obj' is not a string, or it is a
string but has the wrong form.  In this case, one of the 'pred' (lines
3-5) fails to match, thus 'and' (line 2) fails to match, thus 'or' (line
1) proceeds to try sub-pattern 'let' (line 8).

   First, 'let' evaluates '(list "149" 'default)' to get
'("149" default)', the EXPRVAL, and then tries to match EXPRVAL against
pattern 'val'.  Since that is a SYMBOL pattern, it matches
unconditionally and additionally binds 'val' to EXPRVAL.  Now that 'let'
has matched, 'or' matches.

   Note how both 'and' and 'let' sub-patterns finish in the same way: by
trying (always successfully) to match against the SYMBOL pattern 'val',
in the process binding 'val'.  Thus, 'or' always matches and control
always passes to the body form (line 9).  Because that is the last body
form in a successfully matched 'pcase' clause, it is the value of
'pcase' and likewise the return value of 'grok/pcase' (*note What Is a
Function::).

Caveats for SYMBOL in Sequencing Patterns
-----------------------------------------

The preceding examples all use sequencing patterns which include the
SYMBOL sub-pattern in some way.  Here are some important details about
that usage.

  1. When SYMBOL occurs more than once in SEQPAT, the second and
     subsequent occurrences do not expand to re-binding, but instead
     expand to an equality test using 'eq'.

     The following example features a 'pcase' form with two clauses and
     two SEQPAT, A and B.  Both A and B first check that EXPVAL is a
     pair (using 'pred'), and then bind symbols to the 'car' and 'cdr'
     of EXPVAL (using one 'app' each).

     For A, because symbol 'st' is mentioned twice, the second mention
     becomes an equality test using 'eq'.  On the other hand, B uses two
     separate symbols, 's1' and 's2', both of which become independent
     bindings.

          (defun grok (object)
            (pcase object
              ((and (pred consp)        ; seqpat A
                    (app car st)        ; first mention: st
                    (app cdr st))       ; second mention: st
               (list 'eq st))
              ((and (pred consp)        ; seqpat B
                    (app car s1)        ; first mention: s1
                    (app cdr s2))       ; first mention: s2
               (list 'not-eq s1 s2))))

          (let ((s "yow!"))
            (grok (cons s s)))      => (eq "yow!")
          (grok (cons "yo!" "yo!")) => (not-eq "yo!" "yo!")
          (grok '(4 2))             => (not-eq 4 (2))

  2. Side-effecting code referencing SYMBOL is undefined.  Avoid.  For
     example, here are two similar functions.  Both use 'and', SYMBOL
     and 'guard':

          (defun square-double-digit-p/CLEAN (integer)
            (pcase (* integer integer)
              ((and n (guard (< 9 n 100))) (list 'yes n))
              (sorry (list 'no sorry))))

          (square-double-digit-p/CLEAN 9) => (yes 81)
          (square-double-digit-p/CLEAN 3) => (no 9)

          (defun square-double-digit-p/MAYBE (integer)
            (pcase (* integer integer)
              ((and n (guard (< 9 (incf n) 100))) (list 'yes n))
              (sorry (list 'no sorry))))

          (square-double-digit-p/MAYBE 9) => (yes 81)
          (square-double-digit-p/MAYBE 3) => (yes 9)  ; WRONG!

     The difference is in BOOLEAN-EXPRESSION in 'guard': 'CLEAN'
     references 'n' simply and directly, while 'MAYBE' references 'n'
     with a side-effect, in the expression '(incf n)'.  When 'integer'
     is 3, here's what happens:

        * The first 'n' binds it to EXPVAL, i.e., the result of
          evaluating '(* 3 3)', or 9.

        * BOOLEAN-EXPRESSION is evaluated:

               start:   (< 9 (incf n)        100)
               becomes: (< 9 (setq n (1+ n)) 100)
               becomes: (< 9 (setq n (1+ 9)) 100)
               becomes: (< 9 (setq n 10)     100)
                                                  ; side-effect here!
               becomes: (< 9       n         100) ; 'n' now bound to 10
               becomes: (< 9      10         100)
               becomes: t

        * Because the result of the evaluation is non-'nil', 'guard'
          matches, 'and' matches, and control passes to that clause's
          body forms.

     Aside from the mathematical incorrectness of asserting that 9 is a
     double-digit integer, there is another problem with 'MAYBE'.  The
     body form references 'n' once more, yet we do not see the updated
     value--10--at all.  What happened to it?

     To sum up, it's best to avoid side-effecting references to SYMBOL
     patterns entirely, not only in BOOLEAN-EXPRESSION (in 'guard'), but
     also in EXPR (in 'let') and FUNCTION (in 'pred' and 'app').

  3. On match, the clause's body forms can reference the set of symbols
     the pattern let-binds.  When SEQPAT is 'and', this set is the union
     of all the symbols each of its sub-patterns let-binds.  This makes
     sense because, for 'and' to match, all the sub-patterns must match.

     When SEQPAT is 'or', things are different: 'or' matches at the
     first sub-pattern that matches; the rest of the sub-patterns are
     ignored.  It makes no sense for each sub-pattern to let-bind a
     different set of symbols because the body forms have no way to
     distinguish which sub-pattern matched and choose among the
     different sets.  For example, the following is invalid:

          (require 'cl-lib)
          (pcase (read-number "Enter an integer: ")
            ((or (and (pred cl-evenp)
                      e-num)      ; bind 'e-num' to EXPVAL
                 o-num)           ; bind 'o-num' to EXPVAL
             (list e-num o-num)))

          Enter an integer: 42
          error-> Symbol's value as variable is void: o-num
          Enter an integer: 149
          error-> Symbol's value as variable is void: e-num

     Evaluating body form '(list e-num o-num)' signals error.  To
     distinguish between sub-patterns, you can use another symbol,
     identical in name in all sub-patterns but differing in value.
     Reworking the above example:

          (require 'cl-lib)
          (pcase (read-number "Enter an integer: ")
            ((and num                                ; line 1
                  (or (and (pred cl-evenp)           ; line 2
                           (let spin 'even))         ; line 3
                      (let spin 'odd)))              ; line 4
             (list spin num)))                       ; line 5

          Enter an integer: 42
          => (even 42)
          Enter an integer: 149
          => (odd 149)

     Line 1 "factors out" the EXPVAL binding with 'and' and SYMBOL (in
     this case, 'num').  On line 2, 'or' begins in the same way as
     before, but instead of binding different symbols, uses 'let' twice
     (lines 3-4) to bind the same symbol 'spin' in both sub-patterns.
     The value of 'spin' distinguishes the sub-patterns.  The body form
     references both symbols (line 5).

==============================================================================
File: elisp.info,  Node: |Extending_pcase|,  Next: |Backquote_Patterns|,  Prev: |pcase_Macro|,  Up: |Pattern_Matching_Conditional|
==============================================================================

                                                               *Extending_pcase*

11.4.2 Extending 'pcase'
------------------------

The 'pcase' macro supports several kinds of patterns (*note
Pattern-Matching Conditional::).  You can add support for other kinds of
patterns using the 'pcase-defmacro' macro.

 -- Macro: pcase-defmacro name args [doc] &rest body
     Define a new kind of pattern for 'pcase', to be invoked as
     '(NAME ACTUAL-ARGS)'.  The 'pcase' macro expands this into a
     function call that evaluates BODY, whose job it is to rewrite the
     invoked pattern into some other pattern, in an environment where
     ARGS are bound to ACTUAL-ARGS.

     Additionally, arrange to display DOC along with the docstring of
     'pcase'.  By convention, DOC should use 'EXPVAL' to stand for the
     result of evaluating EXPRESSION (first arg to 'pcase').

Typically, BODY rewrites the invoked pattern to use more basic patterns.
Although all patterns eventually reduce to core patterns, 'body' need
not use core patterns straight away.  The following example defines two
patterns, named 'less-than' and 'integer-less-than'.

     (pcase-defmacro less-than (n)
       "Matches if EXPVAL is a number less than N."
       `(pred (> ,n)))

     (pcase-defmacro integer-less-than (n)
       "Matches if EXPVAL is an integer less than N."
       `(and (pred integerp)
             (less-than ,n)))

Note that the docstrings mention ARGS (in this case, only one: 'n') in
the usual way, and also mention 'EXPVAL' by convention.  The first
rewrite (i.e., BODY for 'less-than') uses one core pattern: 'pred'.  The
second uses two core patterns: 'and' and 'pred', as well as the
newly-defined pattern 'less-than'.  Both use a single backquote
construct (*note Backquote::).

==============================================================================
File: elisp.info,  Node: |Backquote_Patterns|,  Next: |Destructuring_with_pcase_Patterns|,  Prev: |Extending_pcase|,  Up: |Pattern_Matching_Conditional|
==============================================================================

                                                            *Backquote_Patterns*

11.4.3 Backquote-Style Patterns
-------------------------------

This subsection describes "backquote-style patterns", a set of builtin
patterns that eases structural matching.  For background, *note
Pattern-Matching Conditional::.

   Backquote-style patterns are a powerful set of 'pcase' pattern
extensions (created using 'pcase-defmacro') that make it easy to match
EXPVAL against specifications of its _structure_.

   For example, to match EXPVAL that must be a list of two elements
whose first element is a specific string and the second element is any
value, you can write a core pattern:

     (and (pred listp)
          ls
          (guard (= 2 (length ls)))
          (guard (string= "first" (car ls)))
          (let second-elem (cadr ls)))

or you can write the equivalent backquote-style pattern:

     `("first" ,second-elem)

The backquote-style pattern is more concise, resembles the structure of
EXPVAL, and avoids binding 'ls'.

   A backquote-style pattern has the form '`QPAT' where QPAT can have
the following forms:

'(QPAT1 . QPAT2)'
     Matches if EXPVAL is a cons cell whose 'car' matches QPAT1 and
     whose 'cdr' matches QPAT2.  This readily generalizes to lists as in
     '(QPAT1 QPAT2 ...)'.

'[QPAT1 QPAT2 ... QPATM]'
     Matches if EXPVAL is a vector of length M whose '0'..'(M-1)'th
     elements match QPAT1, QPAT2 ... QPATM, respectively.

'SYMBOL'
'KEYWORD'
'NUMBER'
'STRING'
     Matches if the corresponding element of EXPVAL is 'equal' to the
     specified literal object.

',PATTERN'
     Matches if the corresponding element of EXPVAL matches PATTERN.
     Note that PATTERN is any kind that 'pcase' supports.  (In the
     example above, 'second-elem' is a SYMBOL core pattern; it therefore
     matches anything, and let-binds 'second-elem'.)

   The "corresponding element" is the portion of EXPVAL that is in the
same structural position as the structural position of QPAT in the
backquote-style pattern.  (In the example above, the corresponding
element of 'second-elem' is the second element of EXPVAL.)

   Here is an example of using 'pcase' to implement a simple interpreter
for a little expression language (note that this requires lexical
binding for the lambda expression in the 'fn' clause to properly capture
'body' and 'arg' (*note Lexical Binding::):

     (defun evaluate (form env)
       (pcase form
         (`(add ,x ,y)       (+ (evaluate x env)
                                (evaluate y env)))
         (`(call ,fun ,arg)  (funcall (evaluate fun env)
                                      (evaluate arg env)))
         (`(fn ,arg ,body)   (lambda (val)
                               (evaluate body (cons (cons arg val)
                                                    env))))
         ((pred numberp)     form)
         ((pred symbolp)     (cdr (assq form env)))
         (_                  (error "Syntax error: %S" form))))

The first three clauses use backquote-style patterns.  '`(add ,x ,y)' is
a pattern that checks that 'form' is a three-element list starting with
the literal symbol 'add', then extracts the second and third elements
and binds them to symbols 'x' and 'y', respectively.  The clause body
evaluates 'x' and 'y' and adds the results.  Similarly, the 'call'
clause implements a function call, and the 'fn' clause implements an
anonymous function definition.

   The remaining clauses use core patterns.  '(pred numberp)' matches if
'form' is a number.  On match, the body evaluates it.  '(pred symbolp)'
matches if 'form' is a symbol.  On match, the body looks up the symbol
in 'env' and returns its association.  Finally, '_' is the catch-all
pattern that matches anything, so it's suitable for reporting syntax
errors.

   Here are some sample programs in this small language, including their
evaluation results:

     (evaluate '(add 1 2) nil)                 => 3
     (evaluate '(add x y) '((x . 1) (y . 2)))  => 3
     (evaluate '(call (fn x (add 1 x)) 2) nil) => 3
     (evaluate '(sub 1 2) nil)                 => error

==============================================================================
File: elisp.info,  Node: |Destructuring_with_pcase_Patterns|,  Prev: |Backquote_Patterns|,  Up: |Pattern_Matching_Conditional|
==============================================================================

                                             *Destructuring_with_pcase_Patterns*

11.4.4 Destructuring with 'pcase' Patterns
------------------------------------------

Pcase patterns not only express a condition on the form of the objects
they can match, but they can also extract sub-fields of those objects.
For example we can extract 2 elements from a list that is the value of
the variable 'my-list' with the following code:

       (pcase my-list
         (`(add ,x ,y)  (message "Contains %S and %S" x y)))

   This will not only extract 'x' and 'y' but will additionally test
that 'my-list' is a list containing exactly 3 elements and whose first
element is the symbol 'add'.  If any of those tests fail, 'pcase' will
immediately return 'nil' without calling 'message'.

   Extraction of multiple values stored in an object is known as
"destructuring".  Using 'pcase' patterns allows to perform
"destructuring binding", which is similar to a local binding (*note
Local Variables::), but gives values to multiple elements of a variable
by extracting those values from an object of compatible structure.

   The macros described in this section use 'pcase' patterns to perform
destructuring binding.  The condition of the object to be of compatible
structure means that the object must match the pattern, because only
then the object's subfields can be extracted.  For example:

       (pcase-let ((`(add ,x ,y) my-list))
         (message "Contains %S and %S" x y))

does the same as the previous example, except that it directly tries to
extract 'x' and 'y' from 'my-list' without first verifying if 'my-list'
is a list which has the right number of elements and has 'add' as its
first element.  The precise behavior when the object does not actually
match the pattern is undefined, although the body will not be silently
skipped: either an error is signaled or the body is run with some of the
variables potentially bound to arbitrary values like 'nil'.

   The pcase patterns that are useful for destructuring bindings are
generally those described in *note Backquote Patterns::, since they
express a specification of the structure of objects that will match.

   For an alternative facility for destructuring binding, see *note
seq-let::.

 -- Macro: pcase-let bindings body...
     Perform destructuring binding of variables according to BINDINGS,
     and then evaluate BODY.

     BINDINGS is a list of bindings of the form '(PATTERN EXP)', where
     EXP is an expression to evaluate and PATTERN is a 'pcase' pattern.

     All EXPs are evaluated first, after which they are matched against
     their respective PATTERN, introducing new variable bindings that
     can then be used inside BODY.  The variable bindings are produced
     by destructuring binding of elements of PATTERN to the values of
     the corresponding elements of the evaluated EXP.

 -- Macro: pcase-let* bindings body...
     Perform destructuring binding of variables according to BINDINGS,
     and then evaluate BODY.

     BINDINGS is a list of bindings of the form '(PATTERN EXP)', where
     EXP is an expression to evaluate and PATTERN is a 'pcase' pattern.
     The variable bindings are produced by destructuring binding of
     elements of PATTERN to the values of the corresponding elements of
     the evaluated EXP.

     Unlike 'pcase-let', but similarly to 'let*', each EXP is matched
     against its corresponding PATTERN before processing the next
     element of BINDINGS, so the variable bindings introduced in each
     one of the BINDINGS are available in the EXPs of the BINDINGS that
     follow it, additionally to being available in BODY.

 -- Macro: pcase-dolist (pattern list) body...
     Execute BODY once for each element of LIST, on each iteration
     performing a destructuring binding of variables in PATTERN to the
     values of the corresponding subfields of the element of LIST.  The
     bindings are performed as if by 'pcase-let'.  When PATTERN is a
     simple variable, this ends up being equivalent to 'dolist' (*note
     Iteration::).

==============================================================================
File: elisp.info,  Node: |Iteration|,  Next: |Generators|,  Prev: |Pattern_Matching_Conditional|,  Up: |Control_Structures|
==============================================================================

                                                                     *Iteration*

11.5 Iteration
--------------

Iteration means executing part of a program repetitively.  For example,
you might want to repeat some computation once for each element of a
list, or once for each integer from 0 to N.  You can do this in Emacs
Lisp with the special form 'while':

 -- Special Form: while condition forms...
     'while' first evaluates CONDITION.  If the result is non-'nil', it
     evaluates FORMS in textual order.  Then it reevaluates CONDITION,
     and if the result is non-'nil', it evaluates FORMS again.  This
     process repeats until CONDITION evaluates to 'nil'.

     There is no limit on the number of iterations that may occur.  The
     loop will continue until either CONDITION evaluates to 'nil' or
     until an error or 'throw' jumps out of it (*note Nonlocal Exits::).

     The value of a 'while' form is always 'nil'.

          (setq num 0)
               => 0
          (while (< num 4)
            (princ (format "Iteration %d." num))
            (setq num (1+ num)))
               -| Iteration 0.
               -| Iteration 1.
               -| Iteration 2.
               -| Iteration 3.
               => nil

     To write a repeat-until loop, which will execute something on each
     iteration and then do the end-test, put the body followed by the
     end-test in a 'progn' as the first argument of 'while', as shown
     here:

          (while (progn
                   (forward-line 1)
                   (not (looking-at "^$"))))

     This moves forward one line and continues moving by lines until it
     reaches an empty line.  It is peculiar in that the 'while' has no
     body, just the end test (which also does the real work of moving
     point).

   The 'dolist' and 'dotimes' macros provide convenient ways to write
two common kinds of loops.

 -- Macro: dolist (var list [result]) body...
     This construct executes BODY once for each element of LIST, binding
     the variable VAR locally to hold the current element.  Then it
     returns the value of evaluating RESULT, or 'nil' if RESULT is
     omitted.  For example, here is how you could use 'dolist' to define
     the 'reverse' function:

          (defun reverse (list)
            (let (value)
              (dolist (elt list value)
                (setq value (cons elt value)))))

 -- Macro: dotimes (var count [result]) body...
     This construct executes BODY once for each integer from 0
     (inclusive) to COUNT (exclusive), binding the variable VAR to the
     integer for the current iteration.  Then it returns the value of
     evaluating RESULT, or 'nil' if RESULT is omitted.  Use of RESULT is
     deprecated.  Here is an example of using 'dotimes' to do something
     100 times:

          (dotimes (i 100)
            (insert "I will not obey absurd orders\n"))

==============================================================================
File: elisp.info,  Node: |Generators|,  Next: |Nonlocal_Exits|,  Prev: |Iteration|,  Up: |Control_Structures|
==============================================================================

                                                                    *Generators*

11.6 Generators
---------------

A "generator" is a function that produces a potentially-infinite stream
of values.  Each time the function produces a value, it suspends itself
and waits for a caller to request the next value.

 -- Macro: iter-defun name args [doc] [declare] [interactive] body...
     'iter-defun' defines a generator function.  A generator function
     has the same signature as a normal function, but works differently.
     Instead of executing BODY when called, a generator function returns
     an iterator object.  That iterator runs BODY to generate values,
     emitting a value and pausing where 'iter-yield' or
     'iter-yield-from' appears.  When BODY returns normally, 'iter-next'
     signals 'iter-end-of-sequence' with BODY's result as its condition
     data.

     Any kind of Lisp code is valid inside BODY, but 'iter-yield' and
     'iter-yield-from' cannot appear inside 'unwind-protect' forms.

 -- Macro: iter-lambda args [doc] [interactive] body...
     'iter-lambda' produces an unnamed generator function that works
     just like a generator function produced with 'iter-defun'.

 -- Macro: iter-yield value
     When it appears inside a generator function, 'iter-yield' indicates
     that the current iterator should pause and return VALUE from
     'iter-next'.  'iter-yield' evaluates to the 'value' parameter of
     next call to 'iter-next'.

 -- Macro: iter-yield-from iterator
     'iter-yield-from' yields all the values that ITERATOR produces and
     evaluates to the value that ITERATOR's generator function returns
     normally.  While it has control, ITERATOR receives values sent to
     the iterator using 'iter-next'.

   To use a generator function, first call it normally, producing a
"iterator" object.  An iterator is a specific instance of a generator.
Then use 'iter-next' to retrieve values from this iterator.  When there
are no more values to pull from an iterator, 'iter-next' raises an
'iter-end-of-sequence' condition with the iterator's final value.

   It's important to note that generator function bodies only execute
inside calls to 'iter-next'.  A call to a function defined with
'iter-defun' produces an iterator; you must drive this iterator with
'iter-next' for anything interesting to happen.  Each call to a
generator function produces a _different_ iterator, each with its own
state.

 -- Function: iter-next iterator value
     Retrieve the next value from ITERATOR.  If there are no more values
     to be generated (because ITERATOR's generator function returned),
     'iter-next' signals the 'iter-end-of-sequence' condition; the data
     value associated with this condition is the value with which
     ITERATOR's generator function returned.

     VALUE is sent into the iterator and becomes the value to which
     'iter-yield' evaluates.  VALUE is ignored for the first 'iter-next'
     call to a given iterator, since at the start of ITERATOR's
     generator function, the generator function is not evaluating any
     'iter-yield' form.

 -- Function: iter-close iterator
     If ITERATOR is suspended inside an 'unwind-protect''s 'bodyform'
     and becomes unreachable, Emacs will eventually run unwind handlers
     after a garbage collection pass.  (Note that 'iter-yield' is
     illegal inside an 'unwind-protect''s 'unwindforms'.)  To ensure
     that these handlers are run before then, use 'iter-close'.

   Some convenience functions are provided to make working with
iterators easier:

 -- Macro: iter-do (var iterator) body ...
     Run BODY with VAR bound to each value that ITERATOR produces.

   The Common Lisp loop facility also contains features for working with
iterators.  *Note (cl)Loop Facility::.

   The following piece of code demonstrates some important principles of
working with iterators.

     (require 'generator)
     (iter-defun my-iter (x)
       (iter-yield (1+ (iter-yield (1+ x))))
        ;; Return normally
       -1)

     (let* ((iter (my-iter 5))
            (iter2 (my-iter 0)))
       ;; Prints 6
       (print (iter-next iter))
       ;; Prints 9
       (print (iter-next iter 8))
       ;; Prints 1; iter and iter2 have distinct states
       (print (iter-next iter2 nil))

       ;; We expect the iter sequence to end now
       (condition-case x
           (iter-next iter)
         (iter-end-of-sequence
           ;; Prints -1, which my-iter returned normally
           (print (cdr x)))))

==============================================================================
File: elisp.info,  Node: |Nonlocal_Exits|,  Prev: |Generators|,  Up: |Control_Structures|
==============================================================================

                                                                *Nonlocal_Exits*

11.7 Nonlocal Exits
-------------------

A "nonlocal exit" is a transfer of control from one point in a program
to another remote point.  Nonlocal exits can occur in Emacs Lisp as a
result of errors; you can also use them under explicit control.
Nonlocal exits unbind all variable bindings made by the constructs being
exited.

MENU

* |Catch_and_Throw|::     Nonlocal exits for the program's own purposes.
* |Examples_of_Catch|::   Showing how such nonlocal exits can be written.
* |Errors|::              How errors are signaled and handled.
* |Cleanups|::            Arranging to run a cleanup form if an error happens.

==============================================================================
File: elisp.info,  Node: |Catch_and_Throw|,  Next: |Examples_of_Catch|,  Up: |Nonlocal_Exits|
==============================================================================

                                                               *Catch_and_Throw*

11.7.1 Explicit Nonlocal Exits: 'catch' and 'throw'
---------------------------------------------------

Most control constructs affect only the flow of control within the
construct itself.  The function 'throw' is the exception to this rule of
normal program execution: it performs a nonlocal exit on request.
(There are other exceptions, but they are for error handling only.)
'throw' is used inside a 'catch', and jumps back to that 'catch'.  For
example:

     (defun foo-outer ()
       (catch 'foo
         (foo-inner)))

     (defun foo-inner ()
       ...
       (if x
           (throw 'foo t))
       ...)

The 'throw' form, if executed, transfers control straight back to the
corresponding 'catch', which returns immediately.  The code following
the 'throw' is not executed.  The second argument of 'throw' is used as
the return value of the 'catch'.

   The function 'throw' finds the matching 'catch' based on the first
argument: it searches for a 'catch' whose first argument is 'eq' to the
one specified in the 'throw'.  If there is more than one applicable
'catch', the innermost one takes precedence.  Thus, in the above
example, the 'throw' specifies 'foo', and the 'catch' in 'foo-outer'
specifies the same symbol, so that 'catch' is the applicable one
(assuming there is no other matching 'catch' in between).

   Executing 'throw' exits all Lisp constructs up to the matching
'catch', including function calls.  When binding constructs such as
'let' or function calls are exited in this way, the bindings are
unbound, just as they are when these constructs exit normally (*note
Local Variables::).  Likewise, 'throw' restores the buffer and position
saved by 'save-excursion' (*note Excursions::), and the narrowing status
saved by 'save-restriction'.  It also runs any cleanups established with
the 'unwind-protect' special form when it exits that form (*note
Cleanups::).

   The 'throw' need not appear lexically within the 'catch' that it
jumps to.  It can equally well be called from another function called
within the 'catch'.  As long as the 'throw' takes place chronologically
after entry to the 'catch', and chronologically before exit from it, it
has access to that 'catch'.  This is why 'throw' can be used in commands
such as 'exit-recursive-edit' that throw back to the editor command loop
(*note Recursive Editing::).

     Common Lisp note: Most other versions of Lisp, including Common
     Lisp, have several ways of transferring control nonsequentially:
     'return', 'return-from', and 'go', for example.  Emacs Lisp has
     only 'throw'.  The 'cl-lib' library provides versions of some of
     these.  *Note (cl)Blocks and Exits::.

 -- Special Form: catch tag body...
     'catch' establishes a return point for the 'throw' function.  The
     return point is distinguished from other such return points by TAG,
     which may be any Lisp object except 'nil'.  The argument TAG is
     evaluated normally before the return point is established.

     With the return point in effect, 'catch' evaluates the forms of the
     BODY in textual order.  If the forms execute normally (without
     error or nonlocal exit) the value of the last body form is returned
     from the 'catch'.

     If a 'throw' is executed during the execution of BODY, specifying
     the same value TAG, the 'catch' form exits immediately; the value
     it returns is whatever was specified as the second argument of
     'throw'.

 -- Function: throw tag value
     The purpose of 'throw' is to return from a return point previously
     established with 'catch'.  The argument TAG is used to choose among
     the various existing return points; it must be 'eq' to the value
     specified in the 'catch'.  If multiple return points match TAG, the
     innermost one is used.

     The argument VALUE is used as the value to return from that
     'catch'.

     If no return point is in effect with tag TAG, then a 'no-catch'
     error is signaled with data '(TAG VALUE)'.

==============================================================================
File: elisp.info,  Node: |Examples_of_Catch|,  Next: |Errors|,  Prev: |Catch_and_Throw|,  Up: |Nonlocal_Exits|
==============================================================================

                                                             *Examples_of_Catch*

11.7.2 Examples of 'catch' and 'throw'
--------------------------------------

One way to use 'catch' and 'throw' is to exit from a doubly nested loop.
(In most languages, this would be done with a 'goto'.)  Here we compute
'(foo I J)' for I and J varying from 0 to 9:

     (defun search-foo ()
       (catch 'loop
         (let ((i 0))
           (while (< i 10)
             (let ((j 0))
               (while (< j 10)
                 (if (foo i j)
                     (throw 'loop (list i j)))
                 (setq j (1+ j))))
             (setq i (1+ i))))))

If 'foo' ever returns non-'nil', we stop immediately and return a list
of I and J.  If 'foo' always returns 'nil', the 'catch' returns
normally, and the value is 'nil', since that is the result of the
'while'.

   Here are two tricky examples, slightly different, showing two return
points at once.  First, two return points with the same tag, 'hack':

     (defun catch2 (tag)
       (catch tag
         (throw 'hack 'yes)))
     => catch2

     (catch 'hack
       (print (catch2 'hack))
       'no)
     -| yes
     => no

Since both return points have tags that match the 'throw', it goes to
the inner one, the one established in 'catch2'.  Therefore, 'catch2'
returns normally with value 'yes', and this value is printed.  Finally
the second body form in the outer 'catch', which is ''no', is evaluated
and returned from the outer 'catch'.

   Now let's change the argument given to 'catch2':

     (catch 'hack
       (print (catch2 'quux))
       'no)
     => yes

We still have two return points, but this time only the outer one has
the tag 'hack'; the inner one has the tag 'quux' instead.  Therefore,
'throw' makes the outer 'catch' return the value 'yes'.  The function
'print' is never called, and the body-form ''no' is never evaluated.

==============================================================================
File: elisp.info,  Node: |Errors|,  Next: |Cleanups|,  Prev: |Examples_of_Catch|,  Up: |Nonlocal_Exits|
==============================================================================

                                                                        *Errors*

11.7.3 Errors
-------------

When Emacs Lisp attempts to evaluate a form that, for some reason,
cannot be evaluated, it "signals" an "error".

   When an error is signaled, Emacs's default reaction is to print an
error message and terminate execution of the current command.  This is
the right thing to do in most cases, such as if you type 'C-f' at the
end of the buffer.

   In complicated programs, simple termination may not be what you want.
For example, the program may have made temporary changes in data
structures, or created temporary buffers that should be deleted before
the program is finished.  In such cases, you would use 'unwind-protect'
to establish "cleanup expressions" to be evaluated in case of error.
(*Note Cleanups::.)  Occasionally, you may wish the program to continue
execution despite an error in a subroutine.  In these cases, you would
use 'condition-case' to establish "error handlers" to recover control in
case of error.

   Resist the temptation to use error handling to transfer control from
one part of the program to another; use 'catch' and 'throw' instead.
*Note Catch and Throw::.

MENU

* |Signaling_Errors|::      How to report an error.
* |Processing_of_Errors|::  What Emacs does when you report an error.
* |Handling_Errors|::       How you can trap errors and continue execution.
* |Error_Symbols|::         How errors are classified for trapping them.

==============================================================================
File: elisp.info,  Node: |Signaling_Errors|,  Next: |Processing_of_Errors|,  Up: |Errors|
==============================================================================

                                                              *Signaling_Errors*

11.7.3.1 How to Signal an Error
-------------------------------

"Signaling" an error means beginning error processing.  Error processing
normally aborts all or part of the running program and returns to a
point that is set up to handle the error (*note Processing of Errors::).
Here we describe how to signal an error.

   Most errors are signaled automatically within Lisp primitives which
you call for other purposes, such as if you try to take the CAR of an
integer or move forward a character at the end of the buffer.  You can
also signal errors explicitly with the functions 'error' and 'signal'.

   Quitting, which happens when the user types 'C-g', is not considered
an error, but it is handled almost like an error.  *Note Quitting::.

   Every error specifies an error message, one way or another.  The
message should state what is wrong ("File does not exist"), not how
things ought to be ("File must exist").  The convention in Emacs Lisp is
that error messages should start with a capital letter, but should not
end with any sort of punctuation.

 -- Function: error format-string &rest args
     This function signals an error with an error message constructed by
     applying 'format-message' (*note Formatting Strings::) to
     FORMAT-STRING and ARGS.

     These examples show typical uses of 'error':

          (error "That is an error -- try something else")
               error-> That is an error -- try something else

          (error "Invalid name `%s'" "A%%B")
               error-> Invalid name 'A%%B'

     'error' works by calling 'signal' with two arguments: the error
     symbol 'error', and a list containing the string returned by
     'format-message'.

     Typically grave accent and apostrophe in the format translate to
     matching curved quotes, e.g., "Missing `%s'" might result in
     "Missing 'foo'".  *Note Text Quoting Style::, for how to influence
     or inhibit this translation.

     Warning: If you want to use your own string as an error message
     verbatim, don't just write '(error STRING)'.  If STRING STRING
     contains '%', '`', or ''' it may be reformatted, with undesirable
     results.  Instead, use '(error "%s" STRING)'.

 -- Function: signal error-symbol data
     This function signals an error named by ERROR-SYMBOL.  The argument
     DATA is a list of additional Lisp objects relevant to the
     circumstances of the error.

     The argument ERROR-SYMBOL must be an "error symbol"--a symbol
     defined with 'define-error'.  This is how Emacs Lisp classifies
     different sorts of errors.  *Note Error Symbols::, for a
     description of error symbols, error conditions and condition names.

     If the error is not handled, the two arguments are used in printing
     the error message.  Normally, this error message is provided by the
     'error-message' property of ERROR-SYMBOL.  If DATA is non-'nil',
     this is followed by a colon and a comma separated list of the
     unevaluated elements of DATA.  For 'error', the error message is
     the CAR of DATA (that must be a string).  Subcategories of
     'file-error' are handled specially.

     The number and significance of the objects in DATA depends on
     ERROR-SYMBOL.  For example, with a 'wrong-type-argument' error,
     there should be two objects in the list: a predicate that describes
     the type that was expected, and the object that failed to fit that
     type.

     Both ERROR-SYMBOL and DATA are available to any error handlers that
     handle the error: 'condition-case' binds a local variable to a list
     of the form '(ERROR-SYMBOL . DATA)' (*note Handling Errors::).

     The function 'signal' never returns.

          (signal 'wrong-number-of-arguments '(x y))
               error-> Wrong number of arguments: x, y

          (signal 'no-such-error '("My unknown error condition"))
               error-> peculiar error: "My unknown error condition"

 -- Function: user-error format-string &rest args
     This function behaves exactly like 'error', except that it uses the
     error symbol 'user-error' rather than 'error'.  As the name
     suggests, this is intended to report errors on the part of the
     user, rather than errors in the code itself.  For example, if you
     try to use the command 'Info-history-back' ('l') to move back
     beyond the start of your Info browsing history, Emacs signals a
     'user-error'.  Such errors do not cause entry to the debugger, even
     when 'debug-on-error' is non-'nil'.  *Note Error Debugging::.

     Common Lisp note: Emacs Lisp has nothing like the Common Lisp
     concept of continuable errors.

==============================================================================
File: elisp.info,  Node: |Processing_of_Errors|,  Next: |Handling_Errors|,  Prev: |Signaling_Errors|,  Up: |Errors|
==============================================================================

                                                          *Processing_of_Errors*

11.7.3.2 How Emacs Processes Errors
-----------------------------------

When an error is signaled, 'signal' searches for an active "handler" for
the error.  A handler is a sequence of Lisp expressions designated to be
executed if an error happens in part of the Lisp program.  If the error
has an applicable handler, the handler is executed, and control resumes
following the handler.  The handler executes in the environment of the
'condition-case' that established it; all functions called within that
'condition-case' have already been exited, and the handler cannot return
to them.

   If there is no applicable handler for the error, it terminates the
current command and returns control to the editor command loop.  (The
command loop has an implicit handler for all kinds of errors.)  The
command loop's handler uses the error symbol and associated data to
print an error message.  You can use the variable
'command-error-function' to control how this is done:

 -- Variable: command-error-function
     This variable, if non-'nil', specifies a function to use to handle
     errors that return control to the Emacs command loop.  The function
     should take three arguments: DATA, a list of the same form that
     'condition-case' would bind to its variable; CONTEXT, a string
     describing the situation in which the error occurred, or (more
     often) 'nil'; and CALLER, the Lisp function which called the
     primitive that signaled the error.

   An error that has no explicit handler may call the Lisp debugger.
The debugger is enabled if the variable 'debug-on-error' (*note Error
Debugging::) is non-'nil'.  Unlike error handlers, the debugger runs in
the environment of the error, so that you can examine values of
variables precisely as they were at the time of the error.

==============================================================================
File: elisp.info,  Node: |Handling_Errors|,  Next: |Error_Symbols|,  Prev: |Processing_of_Errors|,  Up: |Errors|
==============================================================================

                                                               *Handling_Errors*

11.7.3.3 Writing Code to Handle Errors
--------------------------------------

The usual effect of signaling an error is to terminate the command that
is running and return immediately to the Emacs editor command loop.  You
can arrange to trap errors occurring in a part of your program by
establishing an error handler, with the special form 'condition-case'.
A simple example looks like this:

     (condition-case nil
         (delete-file filename)
       (error nil))

This deletes the file named FILENAME, catching any error and returning
'nil' if an error occurs.  (You can use the macro 'ignore-errors' for a
simple case like this; see below.)

   The 'condition-case' construct is often used to trap errors that are
predictable, such as failure to open a file in a call to
'insert-file-contents'.  It is also used to trap errors that are totally
unpredictable, such as when the program evaluates an expression read
from the user.

   The second argument of 'condition-case' is called the "protected
form".  (In the example above, the protected form is a call to
'delete-file'.)  The error handlers go into effect when this form begins
execution and are deactivated when this form returns.  They remain in
effect for all the intervening time.  In particular, they are in effect
during the execution of functions called by this form, in their
subroutines, and so on.  This is a good thing, since, strictly speaking,
errors can be signaled only by Lisp primitives (including 'signal' and
'error') called by the protected form, not by the protected form itself.

   The arguments after the protected form are handlers.  Each handler
lists one or more "condition names" (which are symbols) to specify which
errors it will handle.  The error symbol specified when an error is
signaled also defines a list of condition names.  A handler applies to
an error if they have any condition names in common.  In the example
above, there is one handler, and it specifies one condition name,
'error', which covers all errors.

   The search for an applicable handler checks all the established
handlers starting with the most recently established one.  Thus, if two
nested 'condition-case' forms offer to handle the same error, the inner
of the two gets to handle it.

   If an error is handled by some 'condition-case' form, this ordinarily
prevents the debugger from being run, even if 'debug-on-error' says this
error should invoke the debugger.

   If you want to be able to debug errors that are caught by a
'condition-case', set the variable 'debug-on-signal' to a non-'nil'
value.  You can also specify that a particular handler should let the
debugger run first, by writing 'debug' among the conditions, like this:

     (condition-case nil
         (delete-file filename)
       ((debug error) nil))

The effect of 'debug' here is only to prevent 'condition-case' from
suppressing the call to the debugger.  Any given error will invoke the
debugger only if 'debug-on-error' and the other usual filtering
mechanisms say it should.  *Note Error Debugging::.

 -- Macro: condition-case-unless-debug var protected-form handlers...
     The macro 'condition-case-unless-debug' provides another way to
     handle debugging of such forms.  It behaves exactly like
     'condition-case', unless the variable 'debug-on-error' is
     non-'nil', in which case it does not handle any errors at all.

   Once Emacs decides that a certain handler handles the error, it
returns control to that handler.  To do so, Emacs unbinds all variable
bindings made by binding constructs that are being exited, and executes
the cleanups of all 'unwind-protect' forms that are being exited.  Once
control arrives at the handler, the body of the handler executes
normally.

   After execution of the handler body, execution returns from the
'condition-case' form.  Because the protected form is exited completely
before execution of the handler, the handler cannot resume execution at
the point of the error, nor can it examine variable bindings that were
made within the protected form.  All it can do is clean up and proceed.

   Error signaling and handling have some resemblance to 'throw' and
'catch' (*note Catch and Throw::), but they are entirely separate
facilities.  An error cannot be caught by a 'catch', and a 'throw'
cannot be handled by an error handler (though using 'throw' when there
is no suitable 'catch' signals an error that can be handled).

 -- Special Form: condition-case var protected-form handlers...
     This special form establishes the error handlers HANDLERS around
     the execution of PROTECTED-FORM.  If PROTECTED-FORM executes
     without error, the value it returns becomes the value of the
     'condition-case' form; in this case, the 'condition-case' has no
     effect.  The 'condition-case' form makes a difference when an error
     occurs during PROTECTED-FORM.

     Each of the HANDLERS is a list of the form '(CONDITIONS BODY...)'.
     Here CONDITIONS is an error condition name to be handled, or a list
     of condition names (which can include 'debug' to allow the debugger
     to run before the handler).  A condition name of 't' matches any
     condition.  BODY is one or more Lisp expressions to be executed
     when this handler handles an error.  Here are examples of handlers:

          (error nil)

          (arith-error (message "Division by zero"))

          ((arith-error file-error)
           (message
            "Either division by zero or failure to open a file"))

     Each error that occurs has an "error symbol" that describes what
     kind of error it is, and which describes also a list of condition
     names (*note Error Symbols::).  Emacs searches all the active
     'condition-case' forms for a handler that specifies one or more of
     these condition names; the innermost matching 'condition-case'
     handles the error.  Within this 'condition-case', the first
     applicable handler handles the error.

     After executing the body of the handler, the 'condition-case'
     returns normally, using the value of the last form in the handler
     body as the overall value.

     The argument VAR is a variable.  'condition-case' does not bind
     this variable when executing the PROTECTED-FORM, only when it
     handles an error.  At that time, it binds VAR locally to an "error
     description", which is a list giving the particulars of the error.
     The error description has the form '(ERROR-SYMBOL . DATA)'.  The
     handler can refer to this list to decide what to do.  For example,
     if the error is for failure opening a file, the file name is the
     second element of DATA--the third element of the error description.

     If VAR is 'nil', that means no variable is bound.  Then the error
     symbol and associated data are not available to the handler.

     Sometimes it is necessary to re-throw a signal caught by
     'condition-case', for some outer-level handler to catch.  Here's
     how to do that:

            (signal (car err) (cdr err))

     where 'err' is the error description variable, the first argument
     to 'condition-case' whose error condition you want to re-throw.
     *Note Definition of signal::.

 -- Function: error-message-string error-descriptor
     This function returns the error message string for a given error
     descriptor.  It is useful if you want to handle an error by
     printing the usual error message for that error.  *Note Definition
     of signal::.

   Here is an example of using 'condition-case' to handle the error that
results from dividing by zero.  The handler displays the error message
(but without a beep), then returns a very large number.

     (defun safe-divide (dividend divisor)
       (condition-case err
           ;; Protected form.
           (/ dividend divisor)
         ;; The handler.
         (arith-error                        ; Condition.
          ;; Display the usual message for this error.
          (message "%s" (error-message-string err))
          1000000)))
     => safe-divide

     (safe-divide 5 0)
          -| Arithmetic error: (arith-error)
     => 1000000

The handler specifies condition name 'arith-error' so that it will
handle only division-by-zero errors.  Other kinds of errors will not be
handled (by this 'condition-case').  Thus:

     (safe-divide nil 3)
          error-> Wrong type argument: number-or-marker-p, nil

   Here is a 'condition-case' that catches all kinds of errors,
including those from 'error':

     (setq baz 34)
          => 34

     (condition-case err
         (if (eq baz 35)
             t
           ;; This is a call to the function 'error'.
           (error "Rats!  The variable %s was %s, not 35" 'baz baz))
       ;; This is the handler; it is not a form.
       (error (princ (format "The error was: %s" err))
              2))
     -| The error was: (error "Rats!  The variable baz was 34, not 35")
     => 2

 -- Macro: ignore-errors body...
     This construct executes BODY, ignoring any errors that occur during
     its execution.  If the execution is without error, 'ignore-errors'
     returns the value of the last form in BODY; otherwise, it returns
     'nil'.

     Here's the example at the beginning of this subsection rewritten
     using 'ignore-errors':

            (ignore-errors
             (delete-file filename))

 -- Macro: ignore-error condition body...
     This macro is like 'ignore-errors', but will only ignore the
     specific error condition specified.

            (ignore-error end-of-file
              (read ""))

     CONDITION can also be a list of error conditions.

 -- Macro: with-demoted-errors format body...
     This macro is like a milder version of 'ignore-errors'.  Rather
     than suppressing errors altogether, it converts them into messages.
     It uses the string FORMAT to format the message.  FORMAT should
     contain a single '%'-sequence; e.g., '"Error: %S"'.  Use
     'with-demoted-errors' around code that is not expected to signal
     errors, but should be robust if one does occur.  Note that this
     macro uses 'condition-case-unless-debug' rather than
     'condition-case'.

==============================================================================
File: elisp.info,  Node: |Error_Symbols|,  Prev: |Handling_Errors|,  Up: |Errors|
==============================================================================

                                                                 *Error_Symbols*

11.7.3.4 Error Symbols and Condition Names
------------------------------------------

When you signal an error, you specify an "error symbol" to specify the
kind of error you have in mind.  Each error has one and only one error
symbol to categorize it.  This is the finest classification of errors
defined by the Emacs Lisp language.

   These narrow classifications are grouped into a hierarchy of wider
classes called "error conditions", identified by "condition names".  The
narrowest such classes belong to the error symbols themselves: each
error symbol is also a condition name.  There are also condition names
for more extensive classes, up to the condition name 'error' which takes
in all kinds of errors (but not 'quit').  Thus, each error has one or
more condition names: 'error', the error symbol if that is distinct from
'error', and perhaps some intermediate classifications.

 -- Function: define-error name message &optional parent
     In order for a symbol to be an error symbol, it must be defined
     with 'define-error' which takes a parent condition (defaults to
     'error').  This parent defines the conditions that this kind of
     error belongs to.  The transitive set of parents always includes
     the error symbol itself, and the symbol 'error'.  Because quitting
     is not considered an error, the set of parents of 'quit' is just
     '(quit)'.

   In addition to its parents, the error symbol has a MESSAGE which is a
string to be printed when that error is signaled but not handled.  If
that message is not valid, the error message 'peculiar error' is used.
*Note Definition of signal::.

   Internally, the set of parents is stored in the 'error-conditions'
property of the error symbol and the message is stored in the
'error-message' property of the error symbol.

   Here is how we define a new error symbol, 'new-error':

     (define-error 'new-error "A new error" 'my-own-errors)

This error has several condition names: 'new-error', the narrowest
classification; 'my-own-errors', which we imagine is a wider
classification; and all the conditions of 'my-own-errors' which should
include 'error', which is the widest of all.

   The error string should start with a capital letter but it should not
end with a period.  This is for consistency with the rest of Emacs.

   Naturally, Emacs will never signal 'new-error' on its own; only an
explicit call to 'signal' (*note Definition of signal::) in your code
can do this:

     (signal 'new-error '(x y))
          error-> A new error: x, y

   This error can be handled through any of its condition names.  This
example handles 'new-error' and any other errors in the class
'my-own-errors':

     (condition-case foo
         (bar nil t)
       (my-own-errors nil))

   The significant way that errors are classified is by their condition
names--the names used to match errors with handlers.  An error symbol
serves only as a convenient way to specify the intended error message
and list of condition names.  It would be cumbersome to give 'signal' a
list of condition names rather than one error symbol.

   By contrast, using only error symbols without condition names would
seriously decrease the power of 'condition-case'.  Condition names make
it possible to categorize errors at various levels of generality when
you write an error handler.  Using error symbols alone would eliminate
all but the narrowest level of classification.

   *Note Standard Errors::, for a list of the main error symbols and
their conditions.

==============================================================================
File: elisp.info,  Node: |Cleanups|,  Prev: Errors,  Up: |Nonlocal_Exits|
==============================================================================

                                                                      *Cleanups*

11.7.4 Cleaning Up from Nonlocal Exits
--------------------------------------

The 'unwind-protect' construct is essential whenever you temporarily put
a data structure in an inconsistent state; it permits you to make the
data consistent again in the event of an error or throw.  (Another more
specific cleanup construct that is used only for changes in buffer
contents is the atomic change group; *note Atomic Changes::.)

 -- Special Form: unwind-protect body-form cleanup-forms...
     'unwind-protect' executes BODY-FORM with a guarantee that the
     CLEANUP-FORMS will be evaluated if control leaves BODY-FORM, no
     matter how that happens.  BODY-FORM may complete normally, or
     execute a 'throw' out of the 'unwind-protect', or cause an error;
     in all cases, the CLEANUP-FORMS will be evaluated.

     If BODY-FORM finishes normally, 'unwind-protect' returns the value
     of BODY-FORM, after it evaluates the CLEANUP-FORMS.  If BODY-FORM
     does not finish, 'unwind-protect' does not return any value in the
     normal sense.

     Only BODY-FORM is protected by the 'unwind-protect'.  If any of the
     CLEANUP-FORMS themselves exits nonlocally (via a 'throw' or an
     error), 'unwind-protect' is _not_ guaranteed to evaluate the rest
     of them.  If the failure of one of the CLEANUP-FORMS has the
     potential to cause trouble, then protect it with another
     'unwind-protect' around that form.

     The number of currently active 'unwind-protect' forms counts,
     together with the number of local variable bindings, against the
     limit 'max-specpdl-size' (*note Local Variables: Definition of
     max-specpdl-size.).

   For example, here we make an invisible buffer for temporary use, and
make sure to kill it before finishing:

     (let ((buffer (get-buffer-create " temp")))
       (with-current-buffer buffer
         (unwind-protect
             BODY-FORM
           (kill-buffer buffer))))

You might think that we could just as well write '(kill-buffer
(current-buffer))' and dispense with the variable 'buffer'.  However,
the way shown above is safer, if BODY-FORM happens to get an error after
switching to a different buffer!  (Alternatively, you could write a
'save-current-buffer' around BODY-FORM, to ensure that the temporary
buffer becomes current again in time to kill it.)

   Emacs includes a standard macro called 'with-temp-buffer' which
expands into more or less the code shown above (*note Current Buffer:
Definition of with-temp-buffer.).  Several of the macros defined in this
manual use 'unwind-protect' in this way.

   Here is an actual example derived from an FTP package.  It creates a
process (*note Processes::) to try to establish a connection to a remote
machine.  As the function 'ftp-login' is highly susceptible to numerous
problems that the writer of the function cannot anticipate, it is
protected with a form that guarantees deletion of the process in the
event of failure.  Otherwise, Emacs might fill up with useless
subprocesses.

     (let ((win nil))
       (unwind-protect
           (progn
             (setq process (ftp-setup-buffer host file))
             (if (setq win (ftp-login process host user password))
                 (message "Logged in")
               (error "Ftp login failed")))
         (or win (and process (delete-process process)))))

   This example has a small bug: if the user types 'C-g' to quit, and
the quit happens immediately after the function 'ftp-setup-buffer'
returns but before the variable 'process' is set, the process will not
be killed.  There is no easy way to fix this bug, but at least it is
very unlikely.

==============================================================================
File: elisp.info,  Node: |Variables|,  Next: |Functions|,  Prev: |Control_Structures|,  Up: |Top|
==============================================================================

                                                                     *Variables*

12 Variables
============

A "variable" is a name used in a program to stand for a value.  In Lisp,
each variable is represented by a Lisp symbol (*note Symbols::).  The
variable name is simply the symbol's name, and the variable's value is
stored in the symbol's value cell(1).  *Note Symbol Components::.  In
Emacs Lisp, the use of a symbol as a variable is independent of its use
as a function name.

   As previously noted in this manual, a Lisp program is represented
primarily by Lisp objects, and only secondarily as text.  The textual
form of a Lisp program is given by the read syntax of the Lisp objects
that constitute the program.  Hence, the textual form of a variable in a
Lisp program is written using the read syntax for the symbol
representing the variable.

MENU

* |Global_Variables|::            Variable values that exist permanently, everywhere.
* |Constant_Variables|::          Variables that never change.
* |Local_Variables|::             Variable values that exist only temporarily.
* |Void_Variables|::              Symbols that lack values.
* |Defining_Variables|::          A definition says a symbol is used as a variable.
* |Tips_for_Defining|::           Things you should think about when you
                            define a variable.
* |Accessing_Variables|::         Examining values of variables whose names
                            are known only at run time.
* |Setting_Variables|::           Storing new values in variables.
* |Watching_Variables|::          Running a function when a variable is changed.
* |Variable_Scoping|::            How Lisp chooses among local and global values.
* |Buffer_Local_Variables|::      Variable values in effect only in one buffer.
* |File_Local_Variables|::        Handling local variable lists in files.
* |Directory_Local_Variables|::   Local variables common to all files in a directory.
* |Connection_Local_Variables|::  Local variables common for remote connections.
* |Variable_Aliases|::            Variables that are aliases for other variables.
* |Variables_with_Restricted_Values|::  Non-constant variables whose value can
                                        _not_ be an arbitrary Lisp object.
* |Generalized_Variables|::       Extending the concept of variables.

   ---------- Footnotes ----------

   (1) To be precise, under the default "dynamic scoping" rule, the
value cell always holds the variable's current value, but this is not
the case under the "lexical scoping" rule.  *Note Variable Scoping::,
for details.

==============================================================================
File: elisp.info,  Node: |Global_Variables|,  Next: |Constant_Variables|,  Up: |Variables|
==============================================================================

                                                              *Global_Variables*

12.1 Global Variables
---------------------

The simplest way to use a variable is "globally".  This means that the
variable has just one value at a time, and this value is in effect (at
least for the moment) throughout the Lisp system.  The value remains in
effect until you specify a new one.  When a new value replaces the old
one, no trace of the old value remains in the variable.

   You specify a value for a symbol with 'setq'.  For example,

     (setq x '(a b))

gives the variable 'x' the value '(a b)'.  Note that 'setq' is a special
form (*note Special Forms::); it does not evaluate its first argument,
the name of the variable, but it does evaluate the second argument, the
new value.

   Once the variable has a value, you can refer to it by using the
symbol itself as an expression.  Thus,

     x => (a b)

assuming the 'setq' form shown above has already been executed.

   If you do set the same variable again, the new value replaces the old
one:

     x
          => (a b)
     (setq x 4)
          => 4
     x
          => 4

==============================================================================
File: elisp.info,  Node: |Constant_Variables|,  Next: |Local_Variables|,  Prev: |Global_Variables|,  Up: |Variables|
==============================================================================

                                                            *Constant_Variables*

12.2 Variables that Never Change
--------------------------------

In Emacs Lisp, certain symbols normally evaluate to themselves.  These
include 'nil' and 't', as well as any symbol whose name starts with ':'
(these are called "keywords").  These symbols cannot be rebound, nor can
their values be changed.  Any attempt to set or bind 'nil' or 't'
signals a 'setting-constant' error.  The same is true for a keyword (a
symbol whose name starts with ':'), if it is interned in the standard
obarray, except that setting such a symbol to itself is not an error.

     nil ??? 'nil
          => nil
     (setq nil 500)
     error-> Attempt to set constant symbol: nil

 -- Function: keywordp object
     function returns 't' if OBJECT is a symbol whose name starts with
     ':', interned in the standard obarray, and returns 'nil' otherwise.

   These constants are fundamentally different from the constants
defined using the 'defconst' special form (*note Defining Variables::).
A 'defconst' form serves to inform human readers that you do not intend
to change the value of a variable, but Emacs does not raise an error if
you actually change it.

   A small number of additional symbols are made read-only for various
practical reasons.  These include 'enable-multibyte-characters',
'most-positive-fixnum', 'most-negative-fixnum', and a few others.  Any
attempt to set or bind these also signals a 'setting-constant' error.

==============================================================================
File: elisp.info,  Node: |Local_Variables|,  Next: |Void_Variables|,  Prev: |Constant_Variables|,  Up: |Variables|
==============================================================================

                                                               *Local_Variables*

12.3 Local Variables
--------------------

Global variables have values that last until explicitly superseded with
new values.  Sometimes it is useful to give a variable a "local value"--a
value that takes effect only within a certain part of a Lisp program.
When a variable has a local value, we say that it is "locally bound" to
that value, and that it is a "local variable".

   For example, when a function is called, its argument variables
receive local values, which are the actual arguments supplied to the
function call; these local bindings take effect within the body of the
function.  To take another example, the 'let' special form explicitly
establishes local bindings for specific variables, which take effect
only within the body of the 'let' form.

   We also speak of the "global binding", which is where (conceptually)
the global value is kept.

   Establishing a local binding saves away the variable's previous value
(or lack of one).  We say that the previous value is "shadowed".  Both
global and local values may be shadowed.  If a local binding is in
effect, using 'setq' on the local variable stores the specified value in
the local binding.  When that local binding is no longer in effect, the
previously shadowed value (or lack of one) comes back.

   A variable can have more than one local binding at a time (e.g., if
there are nested 'let' forms that bind the variable).  The "current
binding" is the local binding that is actually in effect.  It determines
the value returned by evaluating the variable symbol, and it is the
binding acted on by 'setq'.

   For most purposes, you can think of the current binding as the
innermost local binding, or the global binding if there is no local
binding.  To be more precise, a rule called the "scoping rule"
determines where in a program a local binding takes effect.  The default
scoping rule in Emacs Lisp is called "dynamic scoping", which simply
states that the current binding at any given point in the execution of a
program is the most recently-created binding for that variable that
still exists.  For details about dynamic scoping, and an alternative
scoping rule called "lexical scoping", *Note Variable Scoping::.

   The special forms 'let' and 'let*' exist to create local bindings:

 -- Special Form: let (bindings...) forms...
     This special form sets up local bindings for a certain set of
     variables, as specified by BINDINGS, and then evaluates all of the
     FORMS in textual order.  Its return value is the value of the last
     form in FORMS.  The local bindings set up by 'let' will be in
     effect only within the body of FORMS.

     Each of the BINDINGS is either (i) a symbol, in which case that
     symbol is locally bound to 'nil'; or (ii) a list of the form
     '(SYMBOL VALUE-FORM)', in which case SYMBOL is locally bound to the
     result of evaluating VALUE-FORM.  If VALUE-FORM is omitted, 'nil'
     is used.

     All of the VALUE-FORMs in BINDINGS are evaluated in the order they
     appear and _before_ binding any of the symbols to them.  Here is an
     example of this: 'z' is bound to the old value of 'y', which is 2,
     not the new value of 'y', which is 1.

          (setq y 2)
               => 2

          (let ((y 1)
                (z y))
            (list y z))
               => (1 2)

     On the other hand, the order of _bindings_ is unspecified: in the
     following example, either 1 or 2 might be printed.

          (let ((x 1)
                (x 2))
            (print x))

     Therefore, avoid binding a variable more than once in a single
     'let' form.

 -- Special Form: let* (bindings...) forms...
     This special form is like 'let', but it binds each variable right
     after computing its local value, before computing the local value
     for the next variable.  Therefore, an expression in BINDINGS can
     refer to the preceding symbols bound in this 'let*' form.  Compare
     the following example with the example above for 'let'.

          (setq y 2)
               => 2

          (let* ((y 1)
                 (z y))    ; Use the just-established value of 'y'.
            (list y z))
               => (1 1)

 -- Special Form: letrec (bindings...) forms...
     This special form is like 'let*', but all the variables are bound
     before any of the local values are computed.  The values are then
     assigned to the locally bound variables.  This is only useful when
     lexical binding is in effect, and you want to create closures that
     refer to bindings that would otherwise not yet be in effect when
     using 'let*'.

     For instance, here's a closure that removes itself from a hook
     after being run once:

          (letrec ((hookfun (lambda ()
                              (message "Run once")
                              (remove-hook 'post-command-hook hookfun))))
            (add-hook 'post-command-hook hookfun))

   Here is a complete list of the other facilities that create local
bindings:

   * Function calls (*note Functions::).

   * Macro calls (*note Macros::).

   * 'condition-case' (*note Errors::).

   Variables can also have buffer-local bindings (*note Buffer-Local
Variables::); a few variables have terminal-local bindings (*note
Multiple Terminals::).  These kinds of bindings work somewhat like
ordinary local bindings, but they are localized depending on where you
are in Emacs.

 -- User Option: max-specpdl-size
     This variable defines the limit on the total number of local
     variable bindings and 'unwind-protect' cleanups (see *note Cleaning
     Up from Nonlocal Exits: Cleanups.) that are allowed before Emacs
     signals an error (with data '"Variable binding depth exceeds
     max-specpdl-size"').

     This limit, with the associated error when it is exceeded, is one
     way that Lisp avoids infinite recursion on an ill-defined function.
     'max-lisp-eval-depth' provides another limit on depth of nesting.
     *Note Eval: Definition of max-lisp-eval-depth.

     The default value is 1600.  Entry to the Lisp debugger increases
     the value, if there is little room left, to make sure the debugger
     itself has room to execute.

==============================================================================
File: elisp.info,  Node: |Void_Variables|,  Next: |Defining_Variables|,  Prev: |Local_Variables|,  Up: |Variables|
==============================================================================

                                                                *Void_Variables*

12.4 When a Variable is Void
----------------------------

We say that a variable is void if its symbol has an unassigned value
cell (*note Symbol Components::).

   Under Emacs Lisp's default dynamic scoping rule (*note Variable
Scoping::), the value cell stores the variable's current (local or
global) value.  Note that an unassigned value cell is _not_ the same as
having 'nil' in the value cell.  The symbol 'nil' is a Lisp object and
can be the value of a variable, just as any other object can be; but it
is still a value.  If a variable is void, trying to evaluate the
variable signals a 'void-variable' error, instead of returning a value.

   Under the optional lexical scoping rule, the value cell only holds
the variable's global value--the value outside of any lexical binding
construct.  When a variable is lexically bound, the local value is
determined by the lexical environment; hence, variables can have local
values even if their symbols' value cells are unassigned.

 -- Function: makunbound symbol
     This function empties out the value cell of SYMBOL, making the
     variable void.  It returns SYMBOL.

     If SYMBOL has a dynamic local binding, 'makunbound' voids the
     current binding, and this voidness lasts only as long as the local
     binding is in effect.  Afterwards, the previously shadowed local or
     global binding is reexposed; then the variable will no longer be
     void, unless the reexposed binding is void too.

     Here are some examples (assuming dynamic binding is in effect):

          (setq x 1)               ; Put a value in the global binding.
               => 1
          (let ((x 2))             ; Locally bind it.
            (makunbound 'x)        ; Void the local binding.
            x)
          error-> Symbol's value as variable is void: x
          x                        ; The global binding is unchanged.
               => 1

          (let ((x 2))             ; Locally bind it.
            (let ((x 3))           ; And again.
              (makunbound 'x)      ; Void the innermost-local binding.
              x))                  ; And refer: it's void.
          error-> Symbol's value as variable is void: x

          (let ((x 2))
            (let ((x 3))
              (makunbound 'x))     ; Void inner binding, then remove it.
            x)                     ; Now outer 'let' binding is visible.
               => 2

 -- Function: boundp variable
     This function returns 't' if VARIABLE (a symbol) is not void, and
     'nil' if it is void.

     Here are some examples (assuming dynamic binding is in effect):

          (boundp 'abracadabra)          ; Starts out void.
               => nil
          (let ((abracadabra 5))         ; Locally bind it.
            (boundp 'abracadabra))
               => t
          (boundp 'abracadabra)          ; Still globally void.
               => nil
          (setq abracadabra 5)           ; Make it globally nonvoid.
               => 5
          (boundp 'abracadabra)
               => t

==============================================================================
File: elisp.info,  Node: |Defining_Variables|,  Next: |Tips_for_Defining|,  Prev: |Void_Variables|,  Up: |Variables|
==============================================================================

                                                            *Defining_Variables*

12.5 Defining Global Variables
------------------------------

A "variable definition" is a construct that announces your intention to
use a symbol as a global variable.  It uses the special forms 'defvar'
or 'defconst', which are documented below.

   A variable definition serves three purposes.  First, it informs
people who read the code that the symbol is _intended_ to be used a
certain way (as a variable).  Second, it informs the Lisp system of
this, optionally supplying an initial value and a documentation string.
Third, it provides information to programming tools such as 'etags',
allowing them to find where the variable was defined.

   The difference between 'defconst' and 'defvar' is mainly a matter of
intent, serving to inform human readers of whether the value should ever
change.  Emacs Lisp does not actually prevent you from changing the
value of a variable defined with 'defconst'.  One notable difference
between the two forms is that 'defconst' unconditionally initializes the
variable, whereas 'defvar' initializes it only if it is originally void.

   To define a customizable variable, you should use 'defcustom' (which
calls 'defvar' as a subroutine).  *Note Variable Definitions::.

 -- Special Form: defvar symbol [value [doc-string]]
     This special form defines SYMBOL as a variable.  Note that SYMBOL
     is not evaluated; the symbol to be defined should appear explicitly
     in the 'defvar' form.  The variable is marked as "special", meaning
     that it should always be dynamically bound (*note Variable
     Scoping::).

     If VALUE is specified, and SYMBOL is void (i.e., it has no
     dynamically bound value; *note Void Variables::), then VALUE is
     evaluated and SYMBOL is set to the result.  But if SYMBOL is not
     void, VALUE is not evaluated, and SYMBOL's value is left unchanged.
     If VALUE is omitted, the value of SYMBOL is not changed in any
     case.

     Note that specifying a value, even 'nil', marks the variable as
     special permanently.  Whereas if VALUE is omitted then the variable
     is only marked special locally (i.e. within the current lexical
     scope, or file if at the top-level).  This can be useful for
     suppressing byte compilation warnings, see *note Compiler Errors::.

     If SYMBOL has a buffer-local binding in the current buffer,
     'defvar' acts on the default value, which is buffer-independent,
     rather than the buffer-local binding.  It sets the default value if
     the default value is void.  *Note Buffer-Local Variables::.

     If SYMBOL is already lexically bound (e.g., if the 'defvar' form
     occurs in a 'let' form with lexical binding enabled), then 'defvar'
     sets the dynamic value.  The lexical binding remains in effect
     until its binding construct exits.  *Note Variable Scoping::.

     When you evaluate a top-level 'defvar' form with 'C-M-x' in Emacs
     Lisp mode ('eval-defun'), a special feature of 'eval-defun'
     arranges to set the variable unconditionally, without testing
     whether its value is void.

     If the DOC-STRING argument is supplied, it specifies the
     documentation string for the variable (stored in the symbol's
     'variable-documentation' property).  *Note Documentation::.

     Here are some examples.  This form defines 'foo' but does not
     initialize it:

          (defvar foo)
               => foo

     This example initializes the value of 'bar' to '23', and gives it a
     documentation string:

          (defvar bar 23
            "The normal weight of a bar.")
               => bar

     The 'defvar' form returns SYMBOL, but it is normally used at top
     level in a file where its value does not matter.

     For a more elaborate example of using 'defvar' without a value, see
     *note Local defvar example::.

 -- Special Form: defconst symbol value [doc-string]
     This special form defines SYMBOL as a value and initializes it.  It
     informs a person reading your code that SYMBOL has a standard
     global value, established here, that should not be changed by the
     user or by other programs.  Note that SYMBOL is not evaluated; the
     symbol to be defined must appear explicitly in the 'defconst'.

     The 'defconst' form, like 'defvar', marks the variable as
     "special", meaning that it should always be dynamically bound
     (*note Variable Scoping::).  In addition, it marks the variable as
     risky (*note File Local Variables::).

     'defconst' always evaluates VALUE, and sets the value of SYMBOL to
     the result.  If SYMBOL does have a buffer-local binding in the
     current buffer, 'defconst' sets the default value, not the
     buffer-local value.  (But you should not be making buffer-local
     bindings for a symbol that is defined with 'defconst'.)

     An example of the use of 'defconst' is Emacs's definition of
     'float-pi'--the mathematical constant pi, which ought not to be
     changed by anyone (attempts by the Indiana State Legislature
     notwithstanding).  As the second form illustrates, however,
     'defconst' is only advisory.

          (defconst float-pi 3.141592653589793 "The value of Pi.")
               => float-pi
          (setq float-pi 3)
               => float-pi
          float-pi
               => 3

   Warning: If you use a 'defconst' or 'defvar' special form while the
variable has a local binding (made with 'let', or a function argument),
it sets the local binding rather than the global binding.  This is not
what you usually want.  To prevent this, use these special forms at top
level in a file, where normally no local binding is in effect, and make
sure to load the file before making a local binding for the variable.

==============================================================================
File: elisp.info,  Node: |Tips_for_Defining|,  Next: |Accessing_Variables|,  Prev: |Defining_Variables|,  Up: |Variables|
==============================================================================

                                                             *Tips_for_Defining*

12.6 Tips for Defining Variables Robustly
-----------------------------------------

When you define a variable whose value is a function, or a list of
functions, use a name that ends in '-function' or '-functions',
respectively.

   There are several other variable name conventions; here is a complete
list:

'...-hook'
     The variable is a normal hook (*note Hooks::).

'...-function'
     The value is a function.

'...-functions'
     The value is a list of functions.

'...-form'
     The value is a form (an expression).

'...-forms'
     The value is a list of forms (expressions).

'...-predicate'
     The value is a predicate--a function of one argument that returns
     non-'nil' for success and 'nil' for failure.

'...-flag'
     The value is significant only as to whether it is 'nil' or not.
     Since such variables often end up acquiring more values over time,
     this convention is not strongly recommended.

'...-program'
     The value is a program name.

'...-command'
     The value is a whole shell command.

'...-switches'
     The value specifies options for a command.

'PREFIX--...'
     The variable is intended for internal use and is defined in the
     file 'PREFIX.el'.  (Emacs code contributed before 2018 may follow
     other conventions, which are being phased out.)

'...-internal'
     The variable is intended for internal use and is defined in C code.
     (Emacs code contributed before 2018 may follow other conventions,
     which are being phased out.)

   When you define a variable, always consider whether you should mark
it as safe or risky; see *note File Local Variables::.

   When defining and initializing a variable that holds a complicated
value (such as a keymap with bindings in it), it's best to put the
entire computation of the value into the 'defvar', like this:

     (defvar my-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map "\C-c\C-a" 'my-command)
         ...
         map)
       DOCSTRING)

This method has several benefits.  First, if the user quits while
loading the file, the variable is either still uninitialized or
initialized properly, never in-between.  If it is still uninitialized,
reloading the file will initialize it properly.  Second, reloading the
file once the variable is initialized will not alter it; that is
important if the user has run hooks to alter part of the contents (such
as, to rebind keys).  Third, evaluating the 'defvar' form with 'C-M-x'
will reinitialize the map completely.

   Putting so much code in the 'defvar' form has one disadvantage: it
puts the documentation string far away from the line which names the
variable.  Here's a safe way to avoid that:

     (defvar my-mode-map nil
       DOCSTRING)
     (unless my-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map "\C-c\C-a" 'my-command)
         ...
         (setq my-mode-map map)))

This has all the same advantages as putting the initialization inside
the 'defvar', except that you must type 'C-M-x' twice, once on each
form, if you do want to reinitialize the variable.

==============================================================================
File: elisp.info,  Node: |Accessing_Variables|,  Next: |Setting_Variables|,  Prev: |Tips_for_Defining|,  Up: |Variables|
==============================================================================

                                                           *Accessing_Variables*

12.7 Accessing Variable Values
------------------------------

The usual way to reference a variable is to write the symbol which names
it.  *Note Symbol Forms::.

   Occasionally, you may want to reference a variable which is only
determined at run time.  In that case, you cannot specify the variable
name in the text of the program.  You can use the 'symbol-value'
function to extract the value.

 -- Function: symbol-value symbol
     This function returns the value stored in SYMBOL's value cell.
     This is where the variable's current (dynamic) value is stored.  If
     the variable has no local binding, this is simply its global value.
     If the variable is void, a 'void-variable' error is signaled.

     If the variable is lexically bound, the value reported by
     'symbol-value' is not necessarily the same as the variable's
     lexical value, which is determined by the lexical environment
     rather than the symbol's value cell.  *Note Variable Scoping::.

          (setq abracadabra 5)
               => 5
          (setq foo 9)
               => 9

          ;; Here the symbol 'abracadabra'
          ;;   is the symbol whose value is examined.
          (let ((abracadabra 'foo))
            (symbol-value 'abracadabra))
               => foo

          ;; Here, the value of 'abracadabra',
          ;;   which is 'foo',
          ;;   is the symbol whose value is examined.
          (let ((abracadabra 'foo))
            (symbol-value abracadabra))
               => 9

          (symbol-value 'abracadabra)
               => 5

==============================================================================
File: elisp.info,  Node: |Setting_Variables|,  Next: |Watching_Variables|,  Prev: |Accessing_Variables|,  Up: |Variables|
==============================================================================

                                                             *Setting_Variables*

12.8 Setting Variable Values
----------------------------

The usual way to change the value of a variable is with the special form
'setq'.  When you need to compute the choice of variable at run time,
use the function 'set'.

 -- Special Form: setq [symbol form]...
     This special form is the most common method of changing a
     variable's value.  Each SYMBOL is given a new value, which is the
     result of evaluating the corresponding FORM.  The current binding
     of the symbol is changed.

     'setq' does not evaluate SYMBOL; it sets the symbol that you write.
     We say that this argument is "automatically quoted".  The 'q' in
     'setq' stands for "quoted".

     The value of the 'setq' form is the value of the last FORM.

          (setq x (1+ 2))
               => 3
          x                   ; 'x' now has a global value.
               => 3
          (let ((x 5))
            (setq x 6)        ; The local binding of 'x' is set.
            x)
               => 6
          x                   ; The global value is unchanged.
               => 3

     Note that the first FORM is evaluated, then the first SYMBOL is
     set, then the second FORM is evaluated, then the second SYMBOL is
     set, and so on:

          (setq x 10          ; Notice that 'x' is set before
                y (1+ x))     ;   the value of 'y' is computed.
               => 11

 -- Function: set symbol value
     This function puts VALUE in the value cell of SYMBOL.  Since it is
     a function rather than a special form, the expression written for
     SYMBOL is evaluated to obtain the symbol to set.  The return value
     is VALUE.

     When dynamic variable binding is in effect (the default), 'set' has
     the same effect as 'setq', apart from the fact that 'set' evaluates
     its SYMBOL argument whereas 'setq' does not.  But when a variable
     is lexically bound, 'set' affects its _dynamic_ value, whereas
     'setq' affects its current (lexical) value.  *Note Variable
     Scoping::.

          (set one 1)
          error-> Symbol's value as variable is void: one
          (set 'one 1)
               => 1
          (set 'two 'one)
               => one
          (set two 2)         ; 'two' evaluates to symbol 'one'.
               => 2
          one                 ; So it is 'one' that was set.
               => 2
          (let ((one 1))      ; This binding of 'one' is set,
            (set 'one 3)      ;   not the global value.
            one)
               => 3
          one
               => 2

     If SYMBOL is not actually a symbol, a 'wrong-type-argument' error
     is signaled.

          (set '(x y) 'z)
          error-> Wrong type argument: symbolp, (x y)

==============================================================================
File: elisp.info,  Node: |Watching_Variables|,  Next: |Variable_Scoping|,  Prev: |Setting_Variables|,  Up: |Variables|
==============================================================================

                                                            *Watching_Variables*

12.9 Running a function when a variable is changed.
---------------------------------------------------

It is sometimes useful to take some action when a variable changes its
value.  The "variable watchpoint" facility provides the means to do so.
Some possible uses for this feature include keeping display in sync with
variable settings, and invoking the debugger to track down unexpected
changes to variables (*note Variable Debugging::).

   The following functions may be used to manipulate and query the watch
functions for a variable.

 -- Function: add-variable-watcher symbol watch-function
     This function arranges for WATCH-FUNCTION to be called whenever
     SYMBOL is modified.  Modifications through aliases (*note Variable
     Aliases::) will have the same effect.

     WATCH-FUNCTION will be called, just before changing the value of
     SYMBOL, with 4 arguments: SYMBOL, NEWVAL, OPERATION, and WHERE.
     SYMBOL is the variable being changed.  NEWVAL is the value it will
     be changed to.  (The old value is available to WATCH-FUNCTION as
     the value of SYMBOL, since it was not yet changed to NEWVAL.)
     OPERATION is a symbol representing the kind of change, one of:
     'set', 'let', 'unlet', 'makunbound', or 'defvaralias'.  WHERE is a
     buffer if the buffer-local value of the variable is being changed,
     'nil' otherwise.

 -- Function: remove-variable-watcher symbol watch-function
     This function removes WATCH-FUNCTION from SYMBOL's list of
     watchers.

 -- Function: get-variable-watchers symbol
     This function returns the list of SYMBOL's active watcher
     functions.

12.9.1 Limitations
------------------

There are a couple of ways in which a variable could be modified (or at
least appear to be modified) without triggering a watchpoint.

   Since watchpoints are attached to symbols, modification to the
objects contained within variables (e.g., by a list modification
function *note Modifying Lists::) is not caught by this mechanism.

   Additionally, C code can modify the value of variables directly,
bypassing the watchpoint mechanism.

   A minor limitation of this feature, again because it targets symbols,
is that only variables of dynamic scope may be watched.  This poses
little difficulty, since modifications to lexical variables can be
discovered easily by inspecting the code within the scope of the
variable (unlike dynamic variables, which can be modified by any code at
all, *note Variable Scoping::).

==============================================================================
File: elisp.info,  Node: |Variable_Scoping|,  Next: |Buffer_Local_Variables|,  Prev: |Watching_Variables|,  Up: |Variables|
==============================================================================

                                                              *Variable_Scoping*

12.10 Scoping Rules for Variable Bindings
-----------------------------------------

When you create a local binding for a variable, that binding takes
effect only within a limited portion of the program (*note Local
Variables::).  This section describes exactly what this means.

   Each local binding has a certain "scope" and "extent".  "Scope"
refers to _where_ in the textual source code the binding can be
accessed.  "Extent" refers to _when_, as the program is executing, the
binding exists.

   By default, the local bindings that Emacs creates are "dynamic
bindings".  Such a binding has "dynamic scope", meaning that any part of
the program can potentially access the variable binding.  It also has
"dynamic extent", meaning that the binding lasts only while the binding
construct (such as the body of a 'let' form) is being executed.

   Emacs can optionally create "lexical bindings".  A lexical binding
has "lexical scope", meaning that any reference to the variable must be
located textually within the binding construct(1).  It also has
"indefinite extent", meaning that under some circumstances the binding
can live on even after the binding construct has finished executing, by
means of special objects called "closures".

   The following subsections describe dynamic binding and lexical
binding in greater detail, and how to enable lexical binding in Emacs
Lisp programs.

MENU

* |Dynamic_Binding|::         The default for binding local variables in Emacs.
* |Dynamic_Binding_Tips|::    Avoiding problems with dynamic binding.
* |Lexical_Binding|::         A different type of local variable binding.
* |Using_Lexical_Binding|::   How to enable lexical binding.

   ---------- Footnotes ----------

   (1) With some exceptions; for instance, a lexical binding can also be
accessed from the Lisp debugger.

==============================================================================
File: elisp.info,  Node: |Dynamic_Binding|,  Next: |Dynamic_Binding_Tips|,  Up: |Variable_Scoping|
==============================================================================

                                                               *Dynamic_Binding*

12.10.1 Dynamic Binding
-----------------------

By default, the local variable bindings made by Emacs are dynamic
bindings.  When a variable is dynamically bound, its current binding at
any point in the execution of the Lisp program is simply the most
recently-created dynamic local binding for that symbol, or the global
binding if there is no such local binding.

   Dynamic bindings have dynamic scope and extent, as shown by the
following example:

     (defvar x -99)  ; 'x' receives an initial value of -99.

     (defun getx ()
       x)            ; 'x' is used free in this function.

     (let ((x 1))    ; 'x' is dynamically bound.
       (getx))
          => 1

     ;; After the 'let' form finishes, 'x' reverts to its
     ;; previous value, which is -99.

     (getx)
          => -99

The function 'getx' refers to 'x'.  This is a "free" reference, in the
sense that there is no binding for 'x' within that 'defun' construct
itself.  When we call 'getx' from within a 'let' form in which 'x' is
(dynamically) bound, it retrieves the local value (i.e., 1).  But when
we call 'getx' outside the 'let' form, it retrieves the global value
(i.e., -99).

   Here is another example, which illustrates setting a dynamically
bound variable using 'setq':

     (defvar x -99)      ; 'x' receives an initial value of -99.

     (defun addx ()
       (setq x (1+ x)))  ; Add 1 to 'x' and return its new value.

     (let ((x 1))
       (addx)
       (addx))
          => 3           ; The two 'addx' calls add to 'x' twice.

     ;; After the 'let' form finishes, 'x' reverts to its
     ;; previous value, which is -99.

     (addx)
          => -98

   Dynamic binding is implemented in Emacs Lisp in a simple way.  Each
symbol has a value cell, which specifies its current dynamic value (or
absence of value).  *Note Symbol Components::.  When a symbol is given a
dynamic local binding, Emacs records the contents of the value cell (or
absence thereof) in a stack, and stores the new local value in the value
cell.  When the binding construct finishes executing, Emacs pops the old
value off the stack, and puts it in the value cell.

==============================================================================
File: elisp.info,  Node: |Dynamic_Binding_Tips|,  Next: |Lexical_Binding|,  Prev: |Dynamic_Binding|,  Up: |Variable_Scoping|
==============================================================================

                                                          *Dynamic_Binding_Tips*

12.10.2 Proper Use of Dynamic Binding
-------------------------------------

Dynamic binding is a powerful feature, as it allows programs to refer to
variables that are not defined within their local textual scope.
However, if used without restraint, this can also make programs hard to
understand.  There are two clean ways to use this technique:

   * If a variable has no global definition, use it as a local variable
     only within a binding construct, such as the body of the 'let' form
     where the variable was bound.  If this convention is followed
     consistently throughout a program, the value of the variable will
     not affect, nor be affected by, any uses of the same variable
     symbol elsewhere in the program.

   * Otherwise, define the variable with 'defvar', 'defconst' (*note
     Defining Variables::), or 'defcustom' (*note Variable
     Definitions::).  Usually, the definition should be at top-level in
     an Emacs Lisp file.  As far as possible, it should include a
     documentation string which explains the meaning and purpose of the
     variable.  You should also choose the variable's name to avoid name
     conflicts (*note Coding Conventions::).

     Then you can bind the variable anywhere in a program, knowing
     reliably what the effect will be.  Wherever you encounter the
     variable, it will be easy to refer back to the definition, e.g.,
     via the 'C-h v' command (provided the variable definition has been
     loaded into Emacs).  *Note (emacs)Name Help::.

     For example, it is common to use local bindings for customizable
     variables like 'case-fold-search':

          (defun search-for-abc ()
            "Search for the string \"abc\", ignoring case differences."
            (let ((case-fold-search t))
              (re-search-forward "abc")))

==============================================================================
File: elisp.info,  Node: |Lexical_Binding|,  Next: |Using_Lexical_Binding|,  Prev: |Dynamic_Binding_Tips|,  Up: |Variable_Scoping|
==============================================================================

                                                               *Lexical_Binding*

12.10.3 Lexical Binding
-----------------------

Lexical binding was introduced to Emacs, as an optional feature, in
version 24.1.  We expect its importance to increase with time.  Lexical
binding opens up many more opportunities for optimization, so programs
using it are likely to run faster in future Emacs versions.  Lexical
binding is also more compatible with concurrency, which was added to
Emacs in version 26.1.

   A lexically-bound variable has "lexical scope", meaning that any
reference to the variable must be located textually within the binding
construct.  Here is an example (*note Using Lexical Binding::, for how
to actually enable lexical binding):

     (let ((x 1))    ; 'x' is lexically bound.
       (+ x 3))
          => 4

     (defun getx ()
       x)            ; 'x' is used free in this function.

     (let ((x 1))    ; 'x' is lexically bound.
       (getx))
     error-> Symbol's value as variable is void: x

Here, the variable 'x' has no global value.  When it is lexically bound
within a 'let' form, it can be used in the textual confines of that
'let' form.  But it can _not_ be used from within a 'getx' function
called from the 'let' form, since the function definition of 'getx'
occurs outside the 'let' form itself.

   Here is how lexical binding works.  Each binding construct defines a
"lexical environment", specifying the variables that are bound within
the construct and their local values.  When the Lisp evaluator wants the
current value of a variable, it looks first in the lexical environment;
if the variable is not specified in there, it looks in the symbol's
value cell, where the dynamic value is stored.

   (Internally, the lexical environment is an alist of symbol-value
pairs, with the final element in the alist being the symbol 't' rather
than a cons cell.  Such an alist can be passed as the second argument to
the 'eval' function, in order to specify a lexical environment in which
to evaluate a form.  *Note Eval::.  Most Emacs Lisp programs, however,
should not interact directly with lexical environments in this way; only
specialized programs like debuggers.)

   Lexical bindings have indefinite extent.  Even after a binding
construct has finished executing, its lexical environment can be "kept
around" in Lisp objects called "closures".  A closure is created when
you define a named or anonymous function with lexical binding enabled.
*Note Closures::, for details.

   When a closure is called as a function, any lexical variable
references within its definition use the retained lexical environment.
Here is an example:

     (defvar my-ticker nil)   ; We will use this dynamically bound
                              ; variable to store a closure.

     (let ((x 0))             ; 'x' is lexically bound.
       (setq my-ticker (lambda ()
                         (setq x (1+ x)))))
         => (closure ((x . 0) t) ()
               (setq x (1+ x)))

     (funcall my-ticker)
         => 1

     (funcall my-ticker)
         => 2

     (funcall my-ticker)
         => 3

     x                        ; Note that 'x' has no global value.
     error-> Symbol's value as variable is void: x

The 'let' binding defines a lexical environment in which the variable
'x' is locally bound to 0.  Within this binding construct, we define a
lambda expression which increments 'x' by one and returns the
incremented value.  This lambda expression is automatically turned into
a closure, in which the lexical environment lives on even after the
'let' binding construct has exited.  Each time we evaluate the closure,
it increments 'x', using the binding of 'x' in that lexical environment.

   Note that unlike dynamic variables which are tied to the symbol
object itself, the relationship between lexical variables and symbols is
only present in the interpreter (or compiler).  Therefore, functions
which take a symbol argument (like 'symbol-value', 'boundp', and 'set')
can only retrieve or modify a variable's dynamic binding (i.e., the
contents of its symbol's value cell).

==============================================================================
File: elisp.info,  Node: |Using_Lexical_Binding|,  Prev: |Lexical_Binding|,  Up: |Variable_Scoping|
==============================================================================

                                                         *Using_Lexical_Binding*

12.10.4 Using Lexical Binding
-----------------------------

When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical
binding is enabled if the buffer-local variable 'lexical-binding' is
non-'nil':

 -- Variable: lexical-binding
     If this buffer-local variable is non-'nil', Emacs Lisp files and
     buffers are evaluated using lexical binding instead of dynamic
     binding.  (However, special variables are still dynamically bound;
     see below.)  If 'nil', dynamic binding is used for all local
     variables.  This variable is typically set for a whole Emacs Lisp
     file, as a file local variable (*note File Local Variables::).
     Note that unlike other such variables, this one must be set in the
     first line of a file.

When evaluating Emacs Lisp code directly using an 'eval' call, lexical
binding is enabled if the LEXICAL argument to 'eval' is non-'nil'.
*Note Eval::.

   Lexical binding is also enabled in Lisp Interaction and IELM mode,
used in the 'scratch' and '*ielm*' buffers, and also when evaluating
expressions via 'M-:' ('eval-expression') and when processing the
'--eval' command-line options of Emacs (*note (emacs)Action Arguments::)
and 'emacsclient' (*note (emacs)emacsclient Options::).

   Even when lexical binding is enabled, certain variables will continue
to be dynamically bound.  These are called "special variables".  Every
variable that has been defined with 'defvar', 'defcustom' or 'defconst'
is a special variable (*note Defining Variables::).  All other variables
are subject to lexical binding.

   Using 'defvar' without a value, it is possible to bind a variable
dynamically just in one file, or in just one part of a file while still
binding it lexically elsewhere.  For example:

     (let (_)
       (defvar x)      ; Let-bindings of 'x' will be dynamic within this let.
       (let ((x -99))  ; This is a dynamic binding of 'x'.
         (defun get-dynamic-x ()
           x)))

     (let ((x 'lexical)) ; This is a lexical binding of 'x'.
       (defun get-lexical-x ()
         x))

     (let (_)
       (defvar x)
       (let ((x 'dynamic))
         (list (get-lexical-x)
               (get-dynamic-x))))
         => (lexical dynamic)

 -- Function: special-variable-p symbol
     This function returns non-'nil' if SYMBOL is a special variable
     (i.e., it has a 'defvar', 'defcustom', or 'defconst' variable
     definition).  Otherwise, the return value is 'nil'.

     Note that since this is a function, it can only return non-'nil'
     for variables which are permanently special, but not for those that
     are only special in the current lexical scope.

   The use of a special variable as a formal argument in a function is
discouraged.  Doing so gives rise to unspecified behavior when lexical
binding mode is enabled (it may use lexical binding sometimes, and
dynamic binding other times).

   Converting an Emacs Lisp program to lexical binding is easy.  First,
add a file-local variable setting of 'lexical-binding' to 't' in the
header line of the Emacs Lisp source file (*note File Local
Variables::).  Second, check that every variable in the program which
needs to be dynamically bound has a variable definition, so that it is
not inadvertently bound lexically.

   A simple way to find out which variables need a variable definition
is to byte-compile the source file.  *Note Byte Compilation::.  If a
non-special variable is used outside of a 'let' form, the byte-compiler
will warn about reference or assignment to a free variable.  If a
non-special variable is bound but not used within a 'let' form, the
byte-compiler will warn about an unused lexical variable.  The
byte-compiler will also issue a warning if you use a special variable as
a function argument.

   (To silence byte-compiler warnings about unused variables, just use a
variable name that starts with an underscore.  The byte-compiler
interprets this as an indication that this is a variable known not to be
used.)

==============================================================================
File: elisp.info,  Node: |Buffer_Local_Variables|,  Next: |File_Local_Variables|,  Prev: |Variable_Scoping|,  Up: |Variables|
==============================================================================

                                                        *Buffer_Local_Variables*

12.11 Buffer-Local Variables
----------------------------

Global and local variable bindings are found in most programming
languages in one form or another.  Emacs, however, also supports
additional, unusual kinds of variable binding, such as "buffer-local"
bindings, which apply only in one buffer.  Having different values for a
variable in different buffers is an important customization method.
(Variables can also have bindings that are local to each terminal.
*Note Multiple Terminals::.)

MENU

* |Intro_to_Buffer_Local|::       Introduction and concepts.
* |Creating_Buffer_Local|::       Creating and destroying buffer-local bindings.
* |Default_Value|::               The default value is seen in buffers
                                 that don't have their own buffer-local values.

==============================================================================
File: elisp.info,  Node: |Intro_to_Buffer_Local|,  Next: |Creating_Buffer_Local|,  Up: |Buffer_Local_Variables|
==============================================================================

                                                         *Intro_to_Buffer_Local*

12.11.1 Introduction to Buffer-Local Variables
----------------------------------------------

A buffer-local variable has a buffer-local binding associated with a
particular buffer.  The binding is in effect when that buffer is
current; otherwise, it is not in effect.  If you set the variable while
a buffer-local binding is in effect, the new value goes in that binding,
so its other bindings are unchanged.  This means that the change is
visible only in the buffer where you made it.

   The variable's ordinary binding, which is not associated with any
specific buffer, is called the "default binding".  In most cases, this
is the global binding.

   A variable can have buffer-local bindings in some buffers but not in
other buffers.  The default binding is shared by all the buffers that
don't have their own bindings for the variable.  (This includes all
newly-created buffers.)  If you set the variable in a buffer that does
not have a buffer-local binding for it, this sets the default binding,
so the new value is visible in all the buffers that see the default
binding.

   The most common use of buffer-local bindings is for major modes to
change variables that control the behavior of commands.  For example, C
mode and Lisp mode both set the variable 'paragraph-start' to specify
that only blank lines separate paragraphs.  They do this by making the
variable buffer-local in the buffer that is being put into C mode or
Lisp mode, and then setting it to the new value for that mode.  *Note
Major Modes::.

   The usual way to make a buffer-local binding is with
'make-local-variable', which is what major mode commands typically use.
This affects just the current buffer; all other buffers (including those
yet to be created) will continue to share the default value unless they
are explicitly given their own buffer-local bindings.

   A more powerful operation is to mark the variable as "automatically
buffer-local" by calling 'make-variable-buffer-local'.  You can think of
this as making the variable local in all buffers, even those yet to be
created.  More precisely, the effect is that setting the variable
automatically makes the variable local to the current buffer if it is
not already so.  All buffers start out by sharing the default value of
the variable as usual, but setting the variable creates a buffer-local
binding for the current buffer.  The new value is stored in the
buffer-local binding, leaving the default binding untouched.  This means
that the default value cannot be changed with 'setq' in any buffer; the
only way to change it is with 'setq-default'.

   Warning: When a variable has buffer-local bindings in one or more
buffers, 'let' rebinds the binding that's currently in effect.  For
instance, if the current buffer has a buffer-local value, 'let'
temporarily rebinds that.  If no buffer-local bindings are in effect,
'let' rebinds the default value.  If inside the 'let' you then change to
a different current buffer in which a different binding is in effect,
you won't see the 'let' binding any more.  And if you exit the 'let'
while still in the other buffer, you won't see the unbinding occur
(though it will occur properly).  Here is an example to illustrate:

     (setq foo 'g)
     (set-buffer "a")
     (make-local-variable 'foo)
     (setq foo 'a)
     (let ((foo 'temp))
       ;; foo => 'temp  ; let binding in buffer 'a'
       (set-buffer "b")
       ;; foo => 'g     ; the global value since foo is not local in 'b'
       BODY...)
     foo => 'g        ; exiting restored the local value in buffer 'a',
                      ; but we don't see that in buffer 'b'
     (set-buffer "a") ; verify the local value was restored
     foo => 'a

Note that references to 'foo' in BODY access the buffer-local binding of
buffer 'b'.

   When a file specifies local variable values, these become
buffer-local values when you visit the file.  *Note (emacs)File
Variables::.

   A buffer-local variable cannot be made terminal-local (*note Multiple
Terminals::).

==============================================================================
File: elisp.info,  Node: |Creating_Buffer_Local|,  Next: |Default_Value|,  Prev: |Intro_to_Buffer_Local|,  Up: |Buffer_Local_Variables|
==============================================================================

                                                         *Creating_Buffer_Local*

12.11.2 Creating and Deleting Buffer-Local Bindings
---------------------------------------------------

 -- Command: make-local-variable variable
     This function creates a buffer-local binding in the current buffer
     for VARIABLE (a symbol).  Other buffers are not affected.  The
     value returned is VARIABLE.

     The buffer-local value of VARIABLE starts out as the same value
     VARIABLE previously had.  If VARIABLE was void, it remains void.

          ;; In buffer 'b1':
          (setq foo 5)                ; Affects all buffers.
               => 5
          (make-local-variable 'foo)  ; Now it is local in 'b1'.
               => foo
          foo                         ; That did not change
               => 5                   ;   the value.
          (setq foo 6)                ; Change the value
               => 6                   ;   in 'b1'.
          foo
               => 6

          ;; In buffer 'b2', the value hasn't changed.
          (with-current-buffer "b2"
            foo)
               => 5

     Making a variable buffer-local within a 'let'-binding for that
     variable does not work reliably, unless the buffer in which you do
     this is not current either on entry to or exit from the 'let'.
     This is because 'let' does not distinguish between different kinds
     of bindings; it knows only which variable the binding was made for.

     It is an error to make a constant or a read-only variable
     buffer-local.  *Note Constant Variables::.

     If the variable is terminal-local (*note Multiple Terminals::),
     this function signals an error.  Such variables cannot have
     buffer-local bindings as well.

     Warning: do not use 'make-local-variable' for a hook variable.
     The hook variables are automatically made buffer-local as needed if
     you use the LOCAL argument to 'add-hook' or 'remove-hook'.

 -- Macro: setq-local &rest pairs
     PAIRS is a list of variable and value pairs.  This macro creates a
     buffer-local binding in the current buffer for each of the
     variables, and gives them a buffer-local value.  It is equivalent
     to calling 'make-local-variable' followed by 'setq' for each of the
     variables.  The variables should be unquoted symbols.

          (setq-local var1 "value1"
                      var2 "value2")

 -- Command: make-variable-buffer-local variable
     This function marks VARIABLE (a symbol) automatically buffer-local,
     so that any subsequent attempt to set it will make it local to the
     current buffer at the time.  Unlike 'make-local-variable', with
     which it is often confused, this cannot be undone, and affects the
     behavior of the variable in all buffers.

     A peculiar wrinkle of this feature is that binding the variable
     (with 'let' or other binding constructs) does not create a
     buffer-local binding for it.  Only setting the variable (with 'set'
     or 'setq'), while the variable does not have a 'let'-style binding
     that was made in the current buffer, does so.

     If VARIABLE does not have a default value, then calling this
     command will give it a default value of 'nil'.  If VARIABLE already
     has a default value, that value remains unchanged.  Subsequently
     calling 'makunbound' on VARIABLE will result in a void buffer-local
     value and leave the default value unaffected.

     The value returned is VARIABLE.

     It is an error to make a constant or a read-only variable
     buffer-local.  *Note Constant Variables::.

     Warning: Don't assume that you should use
     'make-variable-buffer-local' for user-option variables, simply
     because users _might_ want to customize them differently in
     different buffers.  Users can make any variable local, when they
     wish to.  It is better to leave the choice to them.

     The time to use 'make-variable-buffer-local' is when it is crucial
     that no two buffers ever share the same binding.  For example, when
     a variable is used for internal purposes in a Lisp program which
     depends on having separate values in separate buffers, then using
     'make-variable-buffer-local' can be the best solution.

 -- Macro: defvar-local variable value &optional docstring
     This macro defines VARIABLE as a variable with initial value VALUE
     and DOCSTRING, and marks it as automatically buffer-local.  It is
     equivalent to calling 'defvar' followed by
     'make-variable-buffer-local'.  VARIABLE should be an unquoted
     symbol.

 -- Function: local-variable-p variable &optional buffer
     This returns 't' if VARIABLE is buffer-local in buffer BUFFER
     (which defaults to the current buffer); otherwise, 'nil'.

 -- Function: local-variable-if-set-p variable &optional buffer
     This returns 't' if VARIABLE either has a buffer-local value in
     buffer BUFFER, or is automatically buffer-local.  Otherwise, it
     returns 'nil'.  If omitted or 'nil', BUFFER defaults to the current
     buffer.

 -- Function: buffer-local-value variable buffer
     This function returns the buffer-local binding of VARIABLE (a
     symbol) in buffer BUFFER.  If VARIABLE does not have a buffer-local
     binding in buffer BUFFER, it returns the default value (*note
     Default Value::) of VARIABLE instead.

 -- Function: buffer-local-variables &optional buffer
     This function returns a list describing the buffer-local variables
     in buffer BUFFER.  (If BUFFER is omitted, the current buffer is
     used.)  Normally, each list element has the form '(SYM . VAL)',
     where SYM is a buffer-local variable (a symbol) and VAL is its
     buffer-local value.  But when a variable's buffer-local binding in
     BUFFER is void, its list element is just SYM.

          (make-local-variable 'foobar)
          (makunbound 'foobar)
          (make-local-variable 'bind-me)
          (setq bind-me 69)
          (setq lcl (buffer-local-variables))
              ;; First, built-in variables local in all buffers:
          => ((mark-active . nil)
              (buffer-undo-list . nil)
              (mode-name . "Fundamental")
              ...
              ;; Next, non-built-in buffer-local variables.
              ;; This one is buffer-local and void:
              foobar
              ;; This one is buffer-local and nonvoid:
              (bind-me . 69))

     Note that storing new values into the CDRs of cons cells in this
     list does _not_ change the buffer-local values of the variables.

 -- Command: kill-local-variable variable
     This function deletes the buffer-local binding (if any) for
     VARIABLE (a symbol) in the current buffer.  As a result, the
     default binding of VARIABLE becomes visible in this buffer.  This
     typically results in a change in the value of VARIABLE, since the
     default value is usually different from the buffer-local value just
     eliminated.

     If you kill the buffer-local binding of a variable that
     automatically becomes buffer-local when set, this makes the default
     value visible in the current buffer.  However, if you set the
     variable again, that will once again create a buffer-local binding
     for it.

     'kill-local-variable' returns VARIABLE.

     This function is a command because it is sometimes useful to kill
     one buffer-local variable interactively, just as it is useful to
     create buffer-local variables interactively.

 -- Function: kill-all-local-variables
     This function eliminates all the buffer-local variable bindings of
     the current buffer except for variables marked as permanent and
     local hook functions that have a non-'nil' 'permanent-local-hook'
     property (*note Setting Hooks::).  As a result, the buffer will see
     the default values of most variables.

     This function also resets certain other information pertaining to
     the buffer: it sets the local keymap to 'nil', the syntax table to
     the value of '(standard-syntax-table)', the case table to
     '(standard-case-table)', and the abbrev table to the value of
     'fundamental-mode-abbrev-table'.

     The very first thing this function does is run the normal hook
     'change-major-mode-hook' (see below).

     Every major mode command begins by calling this function, which has
     the effect of switching to Fundamental mode and erasing most of the
     effects of the previous major mode.  To ensure that this does its
     job, the variables that major modes set should not be marked
     permanent.

     'kill-all-local-variables' returns 'nil'.

 -- Variable: change-major-mode-hook
     The function 'kill-all-local-variables' runs this normal hook
     before it does anything else.  This gives major modes a way to
     arrange for something special to be done if the user switches to a
     different major mode.  It is also useful for buffer-specific minor
     modes that should be forgotten if the user changes the major mode.

     For best results, make this variable buffer-local, so that it will
     disappear after doing its job and will not interfere with the
     subsequent major mode.  *Note Hooks::.

   A buffer-local variable is "permanent" if the variable name (a
symbol) has a 'permanent-local' property that is non-'nil'.  Such
variables are unaffected by 'kill-all-local-variables', and their local
bindings are therefore not cleared by changing major modes.  Permanent
locals are appropriate for data pertaining to where the file came from
or how to save it, rather than with how to edit the contents.

==============================================================================
File: elisp.info,  Node: |Default_Value|,  Prev: |Creating_Buffer_Local|,  Up: |Buffer_Local_Variables|
==============================================================================

                                                                 *Default_Value*

12.11.3 The Default Value of a Buffer-Local Variable
----------------------------------------------------

The global value of a variable with buffer-local bindings is also called
the "default" value, because it is the value that is in effect whenever
neither the current buffer nor the selected frame has its own binding
for the variable.

   The functions 'default-value' and 'setq-default' access and change a
variable's default value regardless of whether the current buffer has a
buffer-local binding.  For example, you could use 'setq-default' to
change the default setting of 'paragraph-start' for most buffers; and
this would work even when you are in a C or Lisp mode buffer that has a
buffer-local value for this variable.

   The special forms 'defvar' and 'defconst' also set the default value
(if they set the variable at all), rather than any buffer-local value.

 -- Function: default-value symbol
     This function returns SYMBOL's default value.  This is the value
     that is seen in buffers and frames that do not have their own
     values for this variable.  If SYMBOL is not buffer-local, this is
     equivalent to 'symbol-value' (*note Accessing Variables::).

 -- Function: default-boundp symbol
     The function 'default-boundp' tells you whether SYMBOL's default
     value is nonvoid.  If '(default-boundp 'foo)' returns 'nil', then
     '(default-value 'foo)' would get an error.

     'default-boundp' is to 'default-value' as 'boundp' is to
     'symbol-value'.

 -- Special Form: setq-default [symbol form]...
     This special form gives each SYMBOL a new default value, which is
     the result of evaluating the corresponding FORM.  It does not
     evaluate SYMBOL, but does evaluate FORM.  The value of the
     'setq-default' form is the value of the last FORM.

     If a SYMBOL is not buffer-local for the current buffer, and is not
     marked automatically buffer-local, 'setq-default' has the same
     effect as 'setq'.  If SYMBOL is buffer-local for the current
     buffer, then this changes the value that other buffers will see (as
     long as they don't have a buffer-local value), but not the value
     that the current buffer sees.

          ;; In buffer 'foo':
          (make-local-variable 'buffer-local)
               => buffer-local
          (setq buffer-local 'value-in-foo)
               => value-in-foo
          (setq-default buffer-local 'new-default)
               => new-default
          buffer-local
               => value-in-foo
          (default-value 'buffer-local)
               => new-default

          ;; In (the new) buffer 'bar':
          buffer-local
               => new-default
          (default-value 'buffer-local)
               => new-default
          (setq buffer-local 'another-default)
               => another-default
          (default-value 'buffer-local)
               => another-default

          ;; Back in buffer 'foo':
          buffer-local
               => value-in-foo
          (default-value 'buffer-local)
               => another-default

 -- Function: set-default symbol value
     This function is like 'setq-default', except that SYMBOL is an
     ordinary evaluated argument.

          (set-default (car '(a b c)) 23)
               => 23
          (default-value 'a)
               => 23

   A variable can be let-bound (*note Local Variables::) to a value.
This makes its global value shadowed by the binding; 'default-value'
will then return the value from that binding, not the global value, and
'set-default' will be prevented from setting the global value (it will
change the let-bound value instead).  The following two functions allow
to reference the global value even if it's shadowed by a let-binding.

 -- Function: default-toplevel-value symbol
     This function returns the "top-level" default value of SYMBOL,
     which is its value outside of any let-binding.

     (defvar variable 'global-value)
         => variable
     (let ((variable 'let-binding))
       (default-value 'variable))
         => let-binding
     (let ((variable 'let-binding))
       (default-toplevel-value 'variable))
         => global-value

 -- Function: set-default-toplevel-value symbol value
     This function sets the top-level default value of SYMBOL to the
     specified VALUE.  This comes in handy when you want to set the
     global value of SYMBOL regardless of whether your code runs in the
     context of SYMBOL's let-binding.

==============================================================================
File: elisp.info,  Node: |File_Local_Variables|,  Next: |Directory_Local_Variables|,  Prev: |Buffer_Local_Variables|,  Up: |Variables|
==============================================================================

                                                          *File_Local_Variables*

12.12 File Local Variables
--------------------------

A file can specify local variable values; Emacs uses these to create
buffer-local bindings for those variables in the buffer visiting that
file.  *Note Local Variables in Files: (emacs)File Variables, for basic
information about file-local variables.  This section describes the
functions and variables that affect how file-local variables are
processed.

   If a file-local variable could specify an arbitrary function or Lisp
expression that would be called later, visiting a file could take over
your Emacs.  Emacs protects against this by automatically setting only
those file-local variables whose specified values are known to be safe.
Other file-local variables are set only if the user agrees.

   For additional safety, 'read-circle' is temporarily bound to 'nil'
when Emacs reads file-local variables (*note Input Functions::).  This
prevents the Lisp reader from recognizing circular and shared Lisp
structures (*note Circular Objects::).

 -- User Option: enable-local-variables
     This variable controls whether to process file-local variables.
     The possible values are:

     't' (the default)
          Set the safe variables, and query (once) about any unsafe
          variables.
     ':safe'
          Set only the safe variables and do not query.
     ':all'
          Set all the variables and do not query.
     'nil'
          Don't set any variables.
     anything else
          Query (once) about all the variables.

 -- Variable: inhibit-local-variables-regexps
     This is a list of regular expressions.  If a file has a name
     matching an element of this list, then it is not scanned for any
     form of file-local variable.  For examples of why you might want to
     use this, *note Auto Major Mode::.

 -- Function: hack-local-variables &optional handle-mode
     This function parses, and binds or evaluates as appropriate, any
     local variables specified by the contents of the current buffer.
     The variable 'enable-local-variables' has its effect here.
     However, this function does not look for the 'mode:' local variable
     in the '-*-' line.  'set-auto-mode' does that, also taking
     'enable-local-variables' into account (*note Auto Major Mode::).

     This function works by walking the alist stored in
     'file-local-variables-alist' and applying each local variable in
     turn.  It calls 'before-hack-local-variables-hook' and
     'hack-local-variables-hook' before and after applying the
     variables, respectively.  It only calls the before-hook if the
     alist is non-'nil'; it always calls the other hook.  This function
     ignores a 'mode' element if it specifies the same major mode as the
     buffer already has.

     If the optional argument HANDLE-MODE is 't', then all this function
     does is return a symbol specifying the major mode, if the '-*-'
     line or the local variables list specifies one, and 'nil'
     otherwise.  It does not set the mode or any other file-local
     variable.  If HANDLE-MODE has any value other than 'nil' or 't',
     any settings of 'mode' in the '-*-' line or the local variables
     list are ignored, and the other settings are applied.  If
     HANDLE-MODE is 'nil', all the file local variables are set.

 -- Variable: file-local-variables-alist
     This buffer-local variable holds the alist of file-local variable
     settings.  Each element of the alist is of the form
     '(VAR . VALUE)', where VAR is a symbol of the local variable and
     VALUE is its value.  When Emacs visits a file, it first collects
     all the file-local variables into this alist, and then the
     'hack-local-variables' function applies them one by one.

 -- Variable: before-hack-local-variables-hook
     Emacs calls this hook immediately before applying file-local
     variables stored in 'file-local-variables-alist'.

 -- Variable: hack-local-variables-hook
     Emacs calls this hook immediately after it finishes applying
     file-local variables stored in 'file-local-variables-alist'.

   You can specify safe values for a variable with a
'safe-local-variable' property.  The property has to be a function of
one argument; any value is safe if the function returns non-'nil' given
that value.  Many commonly-encountered file variables have
'safe-local-variable' properties; these include 'fill-column',
'fill-prefix', and 'indent-tabs-mode'.  For boolean-valued variables
that are safe, use 'booleanp' as the property value.

   If you want to define 'safe-local-variable' properties for variables
defined in C source code, add the names and the properties of those
variables to the list in the "Safe local variables" section of
'files.el'.

   When defining a user option using 'defcustom', you can set its
'safe-local-variable' property by adding the arguments ':safe FUNCTION'
to 'defcustom' (*note Variable Definitions::).  However, a safety
predicate defined using ':safe' will only be known once the package that
contains the 'defcustom' is loaded, which is often too late.  As an
alternative, you can use the autoload cookie (*note Autoload::) to
assign the option its safety predicate, like this:

     ;;;###autoload (put 'VAR 'safe-local-variable 'PRED)

The safe value definitions specified with 'autoload' are copied into the
package's autoloads file ('loaddefs.el' for most packages bundled with
Emacs), and are known to Emacs since the beginning of a session.

 -- User Option: safe-local-variable-values
     This variable provides another way to mark some variable values as
     safe.  It is a list of cons cells '(VAR . VAL)', where VAR is a
     variable name and VAL is a value which is safe for that variable.

     When Emacs asks the user whether or not to obey a set of file-local
     variable specifications, the user can choose to mark them as safe.
     Doing so adds those variable/value pairs to
     'safe-local-variable-values', and saves it to the user's custom
     file.

 -- Function: safe-local-variable-p sym val
     This function returns non-'nil' if it is safe to give SYM the value
     VAL, based on the above criteria.

   Some variables are considered "risky".  If a variable is risky, it is
never entered automatically into 'safe-local-variable-values'; Emacs
always queries before setting a risky variable, unless the user
explicitly allows a value by customizing 'safe-local-variable-values'
directly.

   Any variable whose name has a non-'nil' 'risky-local-variable'
property is considered risky.  When you define a user option using
'defcustom', you can set its 'risky-local-variable' property by adding
the arguments ':risky VALUE' to 'defcustom' (*note Variable
Definitions::).  In addition, any variable whose name ends in any of
'-command', '-frame-alist', '-function', '-functions', '-hook',
'-hooks', '-form', '-forms', '-map', '-map-alist', '-mode-alist',
'-program', or '-predicate' is automatically considered risky.  The
variables 'font-lock-keywords', 'font-lock-keywords' followed by a
digit, and 'font-lock-syntactic-keywords' are also considered risky.

 -- Function: risky-local-variable-p sym
     This function returns non-'nil' if SYM is a risky variable, based
     on the above criteria.

 -- Variable: ignored-local-variables
     This variable holds a list of variables that should not be given
     local values by files.  Any value specified for one of these
     variables is completely ignored.

   The 'Eval:' "variable" is also a potential loophole, so Emacs
normally asks for confirmation before handling it.

 -- User Option: enable-local-eval
     This variable controls processing of 'Eval:' in '-*-' lines or
     local variables lists in files being visited.  A value of 't' means
     process them unconditionally; 'nil' means ignore them; anything
     else means ask the user what to do for each file.  The default
     value is 'maybe'.

 -- User Option: safe-local-eval-forms
     This variable holds a list of expressions that are safe to evaluate
     when found in the 'Eval:' "variable" in a file local variables
     list.

   If the expression is a function call and the function has a
'safe-local-eval-function' property, the property value determines
whether the expression is safe to evaluate.  The property value can be a
predicate to call to test the expression, a list of such predicates
(it's safe if any predicate succeeds), or 't' (always safe provided the
arguments are constant).

   Text properties are also potential loopholes, since their values
could include functions to call.  So Emacs discards all text properties
from string values specified for file-local variables.

==============================================================================
File: elisp.info,  Node: |Directory_Local_Variables|,  Next: |Connection_Local_Variables|,  Prev: |File_Local_Variables|,  Up: |Variables|
==============================================================================

                                                     *Directory_Local_Variables*

12.13 Directory Local Variables
-------------------------------

A directory can specify local variable values common to all files in
that directory; Emacs uses these to create buffer-local bindings for
those variables in buffers visiting any file in that directory.  This is
useful when the files in the directory belong to some "project" and
therefore share the same local variables.

   There are two different methods for specifying directory local
variables: by putting them in a special file, or by defining a "project
class" for that directory.

 -- Constant: dir-locals-file
     This constant is the name of the file where Emacs expects to find
     the directory-local variables.  The name of the file is
     '.dir-locals.el'(1).  A file by that name in a directory causes
     Emacs to apply its settings to any file in that directory or any of
     its subdirectories (optionally, you can exclude subdirectories; see
     below).  If some of the subdirectories have their own
     '.dir-locals.el' files, Emacs uses the settings from the deepest
     file it finds starting from the file's directory and moving up the
     directory tree.  This constant is also used to derive the name of a
     second dir-locals file '.dir-locals-2.el'.  If this second
     dir-locals file is present, then that is loaded in addition to
     '.dir-locals.el'.  This is useful when '.dir-locals.el' is under
     version control in a shared repository and cannot be used for
     personal customizations.  The file specifies local variables as a
     specially formatted list; see *note Per-directory Local Variables:
     (emacs)Directory Variables, for more details.

 -- Function: hack-dir-local-variables
     This function reads the '.dir-locals.el' file and stores the
     directory-local variables in 'file-local-variables-alist' that is
     local to the buffer visiting any file in the directory, without
     applying them.  It also stores the directory-local settings in
     'dir-locals-class-alist', where it defines a special class for the
     directory in which '.dir-locals.el' file was found.  This function
     works by calling 'dir-locals-set-class-variables' and
     'dir-locals-set-directory-class', described below.

 -- Function: hack-dir-local-variables-non-file-buffer
     This function looks for directory-local variables, and immediately
     applies them in the current buffer.  It is intended to be called in
     the mode commands for non-file buffers, such as Dired buffers, to
     let them obey directory-local variable settings.  For non-file
     buffers, Emacs looks for directory-local variables in
     'default-directory' and its parent directories.

 -- Function: dir-locals-set-class-variables class variables
     This function defines a set of variable settings for the named
     CLASS, which is a symbol.  You can later assign the class to one or
     more directories, and Emacs will apply those variable settings to
     all files in those directories.  The list in VARIABLES can be of
     one of the two forms: '(MAJOR-MODE . ALIST)' or '(DIRECTORY .
     LIST)'.  With the first form, if the file's buffer turns on a mode
     that is derived from MAJOR-MODE, then all the variables in the
     associated ALIST are applied; ALIST should be of the form '(NAME .
     VALUE)'.  A special value 'nil' for MAJOR-MODE means the settings
     are applicable to any mode.  In ALIST, you can use a special NAME:
     'subdirs'.  If the associated value is 'nil', the alist is only
     applied to files in the relevant directory, not to those in any
     subdirectories.

     With the second form of VARIABLES, if DIRECTORY is the initial
     substring of the file's directory, then LIST is applied recursively
     by following the above rules; LIST should be of one of the two
     forms accepted by this function in VARIABLES.

 -- Function: dir-locals-set-directory-class directory class &optional
          mtime
     This function assigns CLASS to all the files in 'directory' and its
     subdirectories.  Thereafter, all the variable settings specified
     for CLASS will be applied to any visited file in DIRECTORY and its
     children.  CLASS must have been already defined by
     'dir-locals-set-class-variables'.

     Emacs uses this function internally when it loads directory
     variables from a '.dir-locals.el' file.  In that case, the optional
     argument MTIME holds the file modification time (as returned by
     'file-attributes').  Emacs uses this time to check stored local
     variables are still valid.  If you are assigning a class directly,
     not via a file, this argument should be 'nil'.

 -- Variable: dir-locals-class-alist
     This alist holds the class symbols and the associated variable
     settings.  It is updated by 'dir-locals-set-class-variables'.

 -- Variable: dir-locals-directory-cache
     This alist holds directory names, their assigned class names, and
     modification times of the associated directory local variables file
     (if there is one).  The function 'dir-locals-set-directory-class'
     updates this list.

 -- Variable: enable-dir-local-variables
     If 'nil', directory-local variables are ignored.  This variable may
     be useful for modes that want to ignore directory-locals while
     still respecting file-local variables (*note File Local
     Variables::).

   ---------- Footnotes ----------

   (1) The MS-DOS version of Emacs uses '_dir-locals.el' instead, due to
limitations of the DOS filesystems.

==============================================================================
File: elisp.info,  Node: |Connection_Local_Variables|,  Next: |Variable_Aliases|,  Prev: |Directory_Local_Variables|,  Up: |Variables|
==============================================================================

                                                    *Connection_Local_Variables*

12.14 Connection Local Variables
--------------------------------

Connection-local variables provide a general mechanism for different
variable settings in buffers with a remote connection.  They are bound
and set depending on the remote connection a buffer is dedicated to.

 -- Function: connection-local-set-profile-variables profile variables
     This function defines a set of variable settings for the connection
     PROFILE, which is a symbol.  You can later assign the connection
     profile to one or more remote connections, and Emacs will apply
     those variable settings to all process buffers for those
     connections.  The list in VARIABLES is an alist of the form
     '(NAME . VALUE)'.  Example:

          (connection-local-set-profile-variables
            'remote-bash
            '((shell-file-name . "/bin/bash")
              (shell-command-switch . "-c")
              (shell-interactive-switch . "-i")
              (shell-login-switch . "-l")))

          (connection-local-set-profile-variables
            'remote-ksh
            '((shell-file-name . "/bin/ksh")
              (shell-command-switch . "-c")
              (shell-interactive-switch . "-i")
              (shell-login-switch . "-l")))

          (connection-local-set-profile-variables
            'remote-null-device
            '((null-device . "/dev/null")))

 -- Variable: connection-local-profile-alist
     This alist holds the connection profile symbols and the associated
     variable settings.  It is updated by
     'connection-local-set-profile-variables'.

 -- Function: connection-local-set-profiles criteria &rest profiles
     This function assigns PROFILES, which are symbols, to all remote
     connections identified by CRITERIA.  CRITERIA is a plist
     identifying a connection and the application using this connection.
     Property names might be ':application', ':protocol', ':user' and
     ':machine'.  The property value of ':application' is a symbol, all
     other property values are strings.  All properties are optional; if
     CRITERIA is 'nil', it always applies.  Example:

          (connection-local-set-profiles
            '(:application 'tramp :protocol "ssh" :machine "localhost")
            'remote-bash 'remote-null-device)

          (connection-local-set-profiles
            '(:application 'tramp :protocol "sudo"
              :user "root" :machine "localhost")
            'remote-ksh 'remote-null-device)

     If CRITERIA is 'nil', it applies for all remote connections.
     Therefore, the example above would be equivalent to

          (connection-local-set-profiles
            '(:application 'tramp :protocol "ssh" :machine "localhost")
            'remote-bash)

          (connection-local-set-profiles
            '(:application 'tramp :protocol "sudo"
              :user "root" :machine "localhost")
            'remote-ksh)

          (connection-local-set-profiles
            nil 'remote-null-device)

     Any connection profile of PROFILES must have been already defined
     by 'connection-local-set-profile-variables'.

 -- Variable: connection-local-criteria-alist
     This alist contains connection criteria and their assigned profile
     names.  The function 'connection-local-set-profiles' updates this
     list.

 -- Function: hack-connection-local-variables criteria
     This function collects applicable connection-local variables
     associated with CRITERIA in 'connection-local-variables-alist',
     without applying them.  Example:

          (hack-connection-local-variables
            '(:application 'tramp :protocol "ssh" :machine "localhost"))

          connection-local-variables-alist
               => ((null-device . "/dev/null")
                  (shell-login-switch . "-l")
                  (shell-interactive-switch . "-i")
                  (shell-command-switch . "-c")
                  (shell-file-name . "/bin/bash"))

 -- Function: hack-connection-local-variables-apply criteria
     This function looks for connection-local variables according to
     CRITERIA, and immediately applies them in the current buffer.

 -- Macro: with-connection-local-variables &rest body
     All connection-local variables, which are specified by
     'default-directory', are applied.

     After that, BODY is executed, and the connection-local variables
     are unwound.  Example:

          (connection-local-set-profile-variables
            'remote-perl
            '((perl-command-name . "/usr/local/bin/perl")
              (perl-command-switch . "-e %s")))

          (connection-local-set-profiles
            '(:application 'tramp :protocol "ssh" :machine "remotehost")
            'remote-perl)

          (let ((default-directory "/ssh:remotehost:/working/dir/"))
            (with-connection-local-variables
              do something useful))

 -- Variable: enable-connection-local-variables
     If 'nil', connection-local variables are ignored.  This variable
     shall be changed temporarily only in special modes.

==============================================================================
File: elisp.info,  Node: |Variable_Aliases|,  Next: |Variables_with_Restricted_Values|,  Prev: |Connection_Local_Variables|,  Up: |Variables|
==============================================================================

                                                              *Variable_Aliases*

12.15 Variable Aliases
----------------------

It is sometimes useful to make two variables synonyms, so that both
variables always have the same value, and changing either one also
changes the other.  Whenever you change the name of a variable--either
because you realize its old name was not well chosen, or because its
meaning has partly changed--it can be useful to keep the old name as an
_alias_ of the new one for compatibility.  You can do this with
'defvaralias'.

 -- Function: defvaralias new-alias base-variable &optional docstring
     This function defines the symbol NEW-ALIAS as a variable alias for
     symbol BASE-VARIABLE.  This means that retrieving the value of
     NEW-ALIAS returns the value of BASE-VARIABLE, and changing the
     value of NEW-ALIAS changes the value of BASE-VARIABLE.  The two
     aliased variable names always share the same value and the same
     bindings.

     If the DOCSTRING argument is non-'nil', it specifies the
     documentation for NEW-ALIAS; otherwise, the alias gets the same
     documentation as BASE-VARIABLE has, if any, unless BASE-VARIABLE is
     itself an alias, in which case NEW-ALIAS gets the documentation of
     the variable at the end of the chain of aliases.

     This function returns BASE-VARIABLE.

   Variable aliases are convenient for replacing an old name for a
variable with a new name.  'make-obsolete-variable' declares that the
old name is obsolete and therefore that it may be removed at some stage
in the future.

 -- Function: make-obsolete-variable obsolete-name current-name when
          &optional access-type
     This function makes the byte compiler warn that the variable
     OBSOLETE-NAME is obsolete.  If CURRENT-NAME is a symbol, it is the
     variable's new name; then the warning message says to use
     CURRENT-NAME instead of OBSOLETE-NAME.  If CURRENT-NAME is a
     string, this is the message and there is no replacement variable.
     WHEN should be a string indicating when the variable was first made
     obsolete (usually a version number string).

     The optional argument ACCESS-TYPE, if non-'nil', should specify the
     kind of access that will trigger obsolescence warnings; it can be
     either 'get' or 'set'.

   You can make two variables synonyms and declare one obsolete at the
same time using the macro 'define-obsolete-variable-alias'.

 -- Macro: define-obsolete-variable-alias obsolete-name current-name
          &optional when docstring
     This macro marks the variable OBSOLETE-NAME as obsolete and also
     makes it an alias for the variable CURRENT-NAME.  It is equivalent
     to the following:

          (defvaralias OBSOLETE-NAME CURRENT-NAME DOCSTRING)
          (make-obsolete-variable OBSOLETE-NAME CURRENT-NAME WHEN)

 -- Function: indirect-variable variable
     This function returns the variable at the end of the chain of
     aliases of VARIABLE.  If VARIABLE is not a symbol, or if VARIABLE
     is not defined as an alias, the function returns VARIABLE.

     This function signals a 'cyclic-variable-indirection' error if
     there is a loop in the chain of symbols.

     (defvaralias 'foo 'bar)
     (indirect-variable 'foo)
          => bar
     (indirect-variable 'bar)
          => bar
     (setq bar 2)
     bar
          => 2
     foo
          => 2
     (setq foo 0)
     bar
          => 0
     foo
          => 0

==============================================================================
File: elisp.info,  Node: |Variables_with_Restricted_Values|,  Next: |Generalized_Variables|,  Prev: |Variable_Aliases|,  Up: |Variables|
==============================================================================

                                              *Variables_with_Restricted_Values*

12.16 Variables with Restricted Values
--------------------------------------

Ordinary Lisp variables can be assigned any value that is a valid Lisp
object.  However, certain Lisp variables are not defined in Lisp, but in
C.  Most of these variables are defined in the C code using
'DEFVAR_LISP'.  Like variables defined in Lisp, these can take on any
value.  However, some variables are defined using 'DEFVAR_INT' or
'DEFVAR_BOOL'.  *Note Writing Emacs Primitives: Defining Lisp variables
in C, in particular the description of functions of the type
'syms_of_FILENAME', for a brief discussion of the C implementation.

   Variables of type 'DEFVAR_BOOL' can only take on the values 'nil' or
't'.  Attempting to assign them any other value will set them to 't':

     (let ((display-hourglass 5))
       display-hourglass)
          => t

 -- Variable: byte-boolean-vars
     This variable holds a list of all variables of type 'DEFVAR_BOOL'.

   Variables of type 'DEFVAR_INT' can take on only integer values.
Attempting to assign them any other value will result in an error:

     (setq undo-limit 1000.0)
     error-> Wrong type argument: integerp, 1000.0

==============================================================================
File: elisp.info,  Node: |Generalized_Variables|,  Prev: |Variables_with_Restricted_Values|,  Up: |Variables|
==============================================================================

                                                         *Generalized_Variables*

12.17 Generalized Variables
---------------------------

A "generalized variable" or "place form" is one of the many places in
Lisp memory where values can be stored using the 'setf' macro (*note
Setting Generalized Variables::).  The simplest place form is a regular
Lisp variable.  But the CARs and CDRs of lists, elements of arrays,
properties of symbols, and many other locations are also places where
Lisp values get stored.

   Generalized variables are analogous to lvalues in the C language,
where 'x = a[i]' gets an element from an array and 'a[i] = x' stores an
element using the same notation.  Just as certain forms like 'a[i]' can
be lvalues in C, there is a set of forms that can be generalized
variables in Lisp.

MENU

* |Setting_Generalized_Variables|::   The 'setf' macro.
* |Adding_Generalized_Variables|::    Defining new 'setf' forms.

==============================================================================
File: elisp.info,  Node: |Setting_Generalized_Variables|,  Next: |Adding_Generalized_Variables|,  Up: |Generalized_Variables|
==============================================================================

                                                 *Setting_Generalized_Variables*

12.17.1 The 'setf' Macro
------------------------

The 'setf' macro is the most basic way to operate on generalized
variables.  The 'setf' form is like 'setq', except that it accepts
arbitrary place forms on the left side rather than just symbols.  For
example, '(setf (car a) b)' sets the car of 'a' to 'b', doing the same
operation as '(setcar a b)', but without you having to use two separate
functions for setting and accessing this type of place.

 -- Macro: setf [place form]...
     This macro evaluates FORM and stores it in PLACE, which must be a
     valid generalized variable form.  If there are several PLACE and
     FORM pairs, the assignments are done sequentially just as with
     'setq'.  'setf' returns the value of the last FORM.

   The following Lisp forms are the forms in Emacs that will work as
generalized variables, and so may appear in the PLACE argument of
'setf':

   * A symbol.  In other words, '(setf x y)' is exactly equivalent to
     '(setq x y)', and 'setq' itself is strictly speaking redundant
     given that 'setf' exists.  Most programmers will continue to prefer
     'setq' for setting simple variables, though, for stylistic and
     historical reasons.  The macro '(setf x y)' actually expands to
     '(setq x y)', so there is no performance penalty for using it in
     compiled code.

   * A call to any of the following standard Lisp functions:

          aref      cddr      symbol-function
          car       elt       symbol-plist
          caar      get       symbol-value
          cadr      gethash
          cdr       nth
          cdar      nthcdr

   * A call to any of the following Emacs-specific functions:

          alist-get                     process-get
          frame-parameter               process-sentinel
          terminal-parameter            window-buffer
          keymap-parent                 window-display-table
          match-data                    window-dedicated-p
          overlay-get                   window-hscroll
          overlay-start                 window-parameter
          overlay-end                   window-point
          process-buffer                window-start
          process-filter                default-value

'setf' signals an error if you pass a PLACE form that it does not know
how to handle.

   Note that for 'nthcdr', the list argument of the function must itself
be a valid PLACE form.  For example, '(setf (nthcdr 0 foo) 7)' will set
'foo' itself to 7.

   The macros 'push' (*note List Variables::) and 'pop' (*note List
Elements::) can manipulate generalized variables, not just lists.  '(pop
PLACE)' removes and returns the first element of the list stored in
PLACE.  It is analogous to '(prog1 (car PLACE) (setf PLACE (cdr
PLACE)))', except that it takes care to evaluate all subforms only once.
'(push X PLACE)' inserts X at the front of the list stored in PLACE.  It
is analogous to '(setf PLACE (cons X PLACE))', except for evaluation of
the subforms.  Note that 'push' and 'pop' on an 'nthcdr' place can be
used to insert or delete at any position in a list.

   The 'cl-lib' library defines various extensions for generalized
variables, including additional 'setf' places.  *Note (cl)Generalized
Variables::.

==============================================================================
File: elisp.info,  Node: |Adding_Generalized_Variables|,  Prev: |Setting_Generalized_Variables|,  Up: |Generalized_Variables|
==============================================================================

                                                  *Adding_Generalized_Variables*

12.17.2 Defining new 'setf' forms
---------------------------------

This section describes how to define new forms that 'setf' can operate
on.

 -- Macro: gv-define-simple-setter name setter &optional fix-return
     This macro enables you to easily define 'setf' methods for simple
     cases.  NAME is the name of a function, macro, or special form.
     You can use this macro whenever NAME has a directly corresponding
     SETTER function that updates it, e.g., '(gv-define-simple-setter
     car setcar)'.

     This macro translates a call of the form

          (setf (NAME ARGS...) VALUE)

     into
          (SETTER ARGS... VALUE)

     Such a 'setf' call is documented to return VALUE.  This is no
     problem with, e.g., 'car' and 'setcar', because 'setcar' returns
     the value that it set.  If your SETTER function does not return
     VALUE, use a non-'nil' value for the FIX-RETURN argument of
     'gv-define-simple-setter'.  This expands into something equivalent
     to
          (let ((temp VALUE))
            (SETTER ARGS... temp)
            temp)
     so ensuring that it returns the correct result.

 -- Macro: gv-define-setter name arglist &rest body
     This macro allows for more complex 'setf' expansions than the
     previous form.  You may need to use this form, for example, if
     there is no simple setter function to call, or if there is one but
     it requires different arguments to the place form.

     This macro expands the form '(setf (NAME ARGS...) VALUE)' by first
     binding the 'setf' argument forms '(VALUE ARGS...)' according to
     ARGLIST, and then executing BODY.  BODY should return a Lisp form
     that does the assignment, and finally returns the value that was
     set.  An example of using this macro is:

          (gv-define-setter caar (val x) `(setcar (car ,x) ,val))

 -- Macro: gv-define-expander name handler
     For more control over the expansion, the 'gv-define-expander' macro
     can be used.  For instance, a settable 'substring' could be
     implemented this way:

          (gv-define-expander substring
            (lambda (do place from &optional to)
              (gv-letplace (getter setter) place
                (macroexp-let2* nil ((start from) (end to))
                  (funcall do `(substring ,getter ,start ,end)
                           (lambda (v)
                             (funcall setter `(cl--set-substring
                                               ,getter ,start ,end ,v))))))))

 -- Macro: gv-letplace (getter setter) place &rest body
     The macro 'gv-letplace' can be useful in defining macros that
     perform similarly to 'setf'; for example, the 'incf' macro of
     Common Lisp could be implemented this way:

          (defmacro incf (place &optional n)
            (gv-letplace (getter setter) place
              (macroexp-let2 nil v (or n 1)
                (funcall setter `(+ ,v ,getter)))))

     GETTER will be bound to a copyable expression that returns the
     value of PLACE.  SETTER will be bound to a function that takes an
     expression V and returns a new expression that sets PLACE to V.
     BODY should return a Emacs Lisp expression manipulating PLACE via
     GETTER and SETTER.

   Consult the source file 'gv.el' for more details.

     Common Lisp note: Common Lisp defines another way to specify the
     'setf' behavior of a function, namely 'setf' functions, whose names
     are lists '(setf NAME)' rather than symbols.  For example, '(defun
     (setf foo) ...)' defines the function that is used when 'setf' is
     applied to 'foo'.  Emacs does not support this.  It is a
     compile-time error to use 'setf' on a form that has not already had
     an appropriate expansion defined.  In Common Lisp, this is not an
     error since the function '(setf FUNC)' might be defined later.

==============================================================================
File: elisp.info,  Node: |Functions|,  Next: |Macros|,  Prev: |Variables|,  Up: |Top|
==============================================================================

                                                                     *Functions*

13 Functions
============

A Lisp program is composed mainly of Lisp functions.  This chapter
explains what functions are, how they accept arguments, and how to
define them.

MENU

* |What_Is_a_Function|::          Lisp functions vs. primitives; terminology.
* |Lambda_Expressions|::          How functions are expressed as Lisp objects.
* |Function_Names|::              A symbol can serve as the name of a function.
* |Defining_Functions|::          Lisp expressions for defining functions.
* |Calling_Functions|::           How to use an existing function.
* |Mapping_Functions|::           Applying a function to each element of a list, etc.
* |Anonymous_Functions|::         Lambda expressions are functions with no names.
* |Generic_Functions|::           Polymorphism, Emacs-style.
* |Function_Cells|::              Accessing or setting the function definition
                            of a symbol.
* |Closures|::                    Functions that enclose a lexical environment.
* |Advising_Functions|::          Adding to the definition of a function.
* |Obsolete_Functions|::          Declaring functions obsolete.
* |Inline_Functions|::            Functions that the compiler will expand inline.
* |Declare_Form|::                Adding additional information about a function.
* |Declaring_Functions|::         Telling the compiler that a function is defined.
* |Function_Safety|::             Determining whether a function is safe to call.
* |Related_Topics|::              Cross-references to specific Lisp primitives
                            that have a special bearing on how functions work.

==============================================================================
File: elisp.info,  Node: |What_Is_a_Function|,  Next: |Lambda_Expressions|,  Up: Functions
==============================================================================

                                                            *What_Is_a_Function*

13.1 What Is a Function?
------------------------

In a general sense, a function is a rule for carrying out a computation
given input values called "arguments".  The result of the computation is
called the "value" or "return value" of the function.  The computation
can also have side effects, such as lasting changes in the values of
variables or the contents of data structures (*note Definition of side
effect::).  A "pure function" is a function which, in addition to having
no side effects, always returns the same value for the same combination
of arguments, regardless of external factors such as machine type or
system state.

   In most computer languages, every function has a name.  But in Lisp,
a function in the strictest sense has no name: it is an object which can
_optionally_ be associated with a symbol (e.g., 'car') that serves as
the function name.  *Note Function Names::.  When a function has been
given a name, we usually also refer to that symbol as a "function"
(e.g., we refer to "the function 'car'").  In this manual, the
distinction between a function name and the function object itself is
usually unimportant, but we will take note wherever it is relevant.

   Certain function-like objects, called "special forms" and "macros",
also accept arguments to carry out computations.  However, as explained
below, these are not considered functions in Emacs Lisp.

   Here are important terms for functions and function-like objects:

"lambda expression"
     A function (in the strict sense, i.e., a function object) which is
     written in Lisp.  These are described in the following section.
     *Note Lambda Expressions::.

"primitive"
     A function which is callable from Lisp but is actually written in
     C.  Primitives are also called "built-in functions", or "subrs".
     Examples include functions like 'car' and 'append'.  In addition,
     all special forms (see below) are also considered primitives.

     Usually, a function is implemented as a primitive because it is a
     fundamental part of Lisp (e.g., 'car'), or because it provides a
     low-level interface to operating system services, or because it
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
