     positive prefix argument, this command enables electric action,
     with a negative one it disables it.

   Electric characters insert newlines only when, in addition to the
electric state, the "auto-newline" feature is enabled (indicated by
'/Cla' in the mode line after the mode name).  You can turn this feature
on or off with the command 'C-c C-a':

'C-c C-a'
     Toggle the auto-newline feature ('c-toggle-auto-newline').  With a
     prefix argument, this command turns the auto-newline feature on if
     the argument is positive, and off if it is negative.

   Usually the CC Mode style configures the exact circumstances in which
Emacs inserts auto-newlines.  You can also configure this directly.
*Note (ccmode)Custom Auto-newlines::.

==============================================================================
File: emacs.info,  Node: |Hungry_Delete|,  Next: |Other_C_Commands|,  Prev: |Electric_C|,  Up: |C_Modes|
==============================================================================

                                                                 *Hungry_Delete*

26.12.3 Hungry Delete Feature in C
----------------------------------

If you want to delete an entire block of whitespace at point, you can
use "hungry deletion".  This deletes all the contiguous whitespace
either before point or after point in a single operation.  "Whitespace"
here includes tabs and newlines, but not comments or preprocessor
commands.

'C-c C-<DEL>'
'C-c <DEL>'
     Delete the entire block of whitespace preceding point
     ('c-hungry-delete-backwards').

'C-c C-d'
'C-c C-<Delete>'
'C-c <Delete>'
     Delete the entire block of whitespace after point
     ('c-hungry-delete-forward').

   As an alternative to the above commands, you can enable "hungry
delete mode".  When this feature is enabled (indicated by 'h' after a
'/' in the mode line after the mode name), a single '<DEL>' deletes all
preceding whitespace, not just one space, and a single 'C-d' (but _not_
plain '<Delete>') deletes all following whitespace.

'M-x c-toggle-hungry-state'
     Toggle the hungry-delete feature ('c-toggle-hungry-state').  With a
     prefix argument, this command turns the hungry-delete feature on if
     the argument is positive, and off if it is negative.

   The variable 'c-hungry-delete-key' controls whether the hungry-delete
feature is enabled.

==============================================================================
File: emacs.info,  Node: |Other_C_Commands|,  Prev: |Hungry_Delete|,  Up: |C_Modes|
==============================================================================

                                                              *Other_C_Commands*

26.12.4 Other Commands for C Mode
---------------------------------

'M-x c-context-line-break'
     This command inserts a line break and indents the new line in a
     manner appropriate to the context.  In normal code, it does the
     work of '<RET>' ('newline'), in a C preprocessor line it
     additionally inserts a '\' at the line break, and within comments
     it's like 'M-j' ('c-indent-new-comment-line').

     'c-context-line-break' isn't bound to a key by default, but it
     needs a binding to be useful.  The following code will bind it to
     '<RET>'.  We use 'c-initialization-hook' here to make sure the
     keymap is loaded before we try to change it.

          (defun my-bind-clb ()
            (define-key c-mode-base-map "\C-m"
                        'c-context-line-break))
          (add-hook 'c-initialization-hook 'my-bind-clb)

'C-M-h'
     Put mark at the end of a function definition, and put point at the
     beginning ('c-mark-function').

'M-q'
     Fill a paragraph, handling C and C++ comments ('c-fill-paragraph').
     If any part of the current line is a comment or within a comment,
     this command fills the comment or the paragraph of it that point is
     in, preserving the comment indentation and comment delimiters.

'C-c C-e'
     Run the C preprocessor on the text in the region, and show the
     result, which includes the expansion of all the macro calls
     ('c-macro-expand').  The buffer text before the region is also
     included in preprocessing, for the sake of macros defined there,
     but the output from this part isn't shown.

     When you are debugging C code that uses macros, sometimes it is
     hard to figure out precisely how the macros expand.  With this
     command, you don't have to figure it out; you can see the
     expansions.

'C-c C-\'
     Insert or align '\' characters at the ends of the lines of the
     region ('c-backslash-region').  This is useful after writing or
     editing a C macro definition.

     If a line already ends in '\', this command adjusts the amount of
     whitespace before it.  Otherwise, it inserts a new '\'.  However,
     the last line in the region is treated specially; no '\' is
     inserted on that line, and any '\' there is deleted.

'M-x cpp-highlight-buffer'
     Highlight parts of the text according to its preprocessor
     conditionals.  This command displays another buffer named '*CPP
     Edit*', which serves as a graphic menu for selecting how to display
     particular kinds of conditionals and their contents.  After
     changing various settings, click on '[A]pply these settings' (or go
     to that buffer and type 'a') to rehighlight the C mode buffer
     accordingly.

'C-c C-s'
     Display the syntactic information about the current source line
     ('c-show-syntactic-information').  This information directs how the
     line is indented.

'M-x cwarn-mode'
'M-x global-cwarn-mode'
     CWarn minor mode highlights certain suspicious C and C++
     constructions:

        * Assignments inside expressions.
        * Semicolon following immediately after 'if', 'for', and 'while'
          (except after a 'do ... while' statement);
        * C++ functions with reference parameters.

     You can enable the mode for one buffer with the command 'M-x
     cwarn-mode', or for all suitable buffers with the command 'M-x
     global-cwarn-mode' or by customizing the variable
     'global-cwarn-mode'.  You must also enable Font Lock mode to make
     it work.

'M-x hide-ifdef-mode'
     Hide-ifdef minor mode hides selected code within '#if' and '#ifdef'
     preprocessor blocks.  If you change the variable
     'hide-ifdef-shadow' to 't', Hide-ifdef minor mode shadows
     preprocessor blocks by displaying them with a less prominent face,
     instead of hiding them entirely.  See the documentation string of
     'hide-ifdef-mode' for more information.

'M-x ff-find-related-file'
     Find a file related in a special way to the file visited by the
     current buffer.  Typically this will be the header file
     corresponding to a C/C++ source file, or vice versa.  The variable
     'ff-related-file-alist' specifies how to compute related file
     names.

==============================================================================
File: emacs.info,  Node: |Asm_Mode|,  Next: |Fortran|,  Prev: |C_Modes|,  Up: |Programs|
==============================================================================

                                                                      *Asm_Mode*

26.13 Asm Mode
=====---------

Asm mode is a major mode for editing files of assembler code.  It
defines these commands:

'<TAB>'
     'tab-to-tab-stop'.

'C-j'
     Insert a newline and then indent using 'tab-to-tab-stop'.

':'
     Insert a colon and then remove the indentation from before the
     label preceding colon.  Then do 'tab-to-tab-stop'.

';'
     Insert or align a comment.

   The variable 'asm-comment-char' specifies which character starts
comments in assembler syntax.

==============================================================================
File: emacs.info,  Node: |Fortran|,  Prev: |Asm_Mode|,  Up: |Programs|
==============================================================================

                                                                       *Fortran*

26.14 Fortran Mode
=====-------------

Fortran mode is meant for editing fixed form (and also tab format)
source code (normally Fortran 77).  For editing more modern free-form
source code (Fortran 90, 95, 2003, 2008), use F90 mode ('f90-mode').
Emacs normally uses Fortran mode for files with extension '.f', '.F' or
'.for', and F90 mode for the extensions '.f90', '.f95', '.f03' and
'.f08'.  Customize 'auto-mode-alist' to add more extensions.  GNU
Fortran supports both free and fixed form.  This manual mainly documents
Fortran mode, but the corresponding F90 mode features are mentioned when
relevant.

   Fortran mode provides special motion commands for Fortran statements
and subprograms, and indentation commands that understand Fortran
conventions of nesting, line numbers and continuation statements.
Fortran mode has support for Auto Fill mode that breaks long lines into
proper Fortran continuation lines.  Fortran mode also supports Hideshow
minor mode (*note Hideshow::), and Imenu (*note Imenu::).

   Special commands for comments are provided because Fortran comments
are unlike those of other languages.  Built-in abbrevs optionally save
typing when you insert Fortran keywords.

   Use 'M-x fortran-mode' to switch to this major mode.  This command
runs the hook 'fortran-mode-hook'.  *Note Hooks::.

MENU

* Motion: Fortran Motion.        Moving point by statements or subprograms.
* Indent: Fortran Indent.        Indentation commands for Fortran.
* Comments: Fortran Comments.    Inserting and aligning comments.
* Autofill: Fortran Autofill.    Auto fill support for Fortran.
* Columns: Fortran Columns.      Measuring columns for valid Fortran.
* Abbrev: Fortran Abbrev.        Built-in abbrevs for Fortran keywords.

==============================================================================
File: emacs.info,  Node: |Fortran_Motion|,  Next: |Fortran_Indent|,  Up: |Fortran|
==============================================================================

                                                                *Fortran_Motion*

26.14.1 Motion Commands
-----------------------

In addition to the normal commands for moving by and operating on defuns
(Fortran subprograms--functions and subroutines, as well as modules for
F90 mode, using the commands 'fortran-end-of-subprogram' and
'fortran-beginning-of-subprogram'), Fortran mode provides special
commands to move by statements and other program units.

'C-c C-n'
     Move to the beginning of the next statement
     ('fortran-next-statement'/'f90-next-statement').

'C-c C-p'
     Move to the beginning of the previous statement
     ('fortran-previous-statement'/'f90-previous-statement').  If there
     is no previous statement (i.e., if called from the first statement
     in the buffer), move to the start of the buffer.

'C-c C-e'
     Move point forward to the start of the next code block, or the end
     of the current one, whichever comes first ('f90-next-block').  A
     code block is a subroutine, 'if'-'endif' statement, and so forth.
     This command exists for F90 mode only, not Fortran mode.  With a
     numeric argument, it moves forward that many blocks.

'C-c C-a'
     Move point backward to the previous block ('f90-previous-block').
     This is like 'f90-next-block', but moves backwards.

'C-M-n'
     Move to the end of the current code block
     ('fortran-end-of-block'/'f90-end-of-block').  With a numeric
     argument, move forward that number of blocks.  The mark is set
     before moving point.  The F90 mode version of this command checks
     for consistency of block types and labels (if present), but it does
     not check the outermost block since that may be incomplete.

'C-M-p'
     Move to the start of the current code block
     ('fortran-beginning-of-block'/'f90-beginning-of-block').  This is
     like 'fortran-end-of-block', but moves backwards.

   The commands 'fortran-beginning-of-subprogram' and
'fortran-end-of-subprogram' move to the start or end of the current
subprogram, respectively.  The commands 'fortran-mark-do' and
'fortran-mark-if' mark the end of the current 'do' or 'if' block, and
move point to the start.

==============================================================================
File: emacs.info,  Node: |Fortran_Indent|,  Next: |Fortran_Comments|,  Prev: |Fortran_Motion|,  Up: |Fortran|
==============================================================================

                                                                *Fortran_Indent*

26.14.2 Fortran Indentation
---------------------------

Special commands and features are needed for indenting fixed (or tab)
form Fortran code in order to make sure various syntactic entities (line
numbers, comment line indicators and continuation line flags) appear in
the required columns.

MENU

* Commands: ForIndent Commands.  Commands for indenting and filling Fortran.
* Contline: ForIndent Cont.      How continuation lines indent.
* Numbers:  ForIndent Num.       How line numbers auto-indent.
* Conv:     ForIndent Conv.      Conventions you must obey to avoid trouble.
* Vars:     ForIndent Vars.      Variables controlling Fortran indent style.

==============================================================================
File: emacs.info,  Node: |ForIndent_Commands|,  Next: |ForIndent_Cont|,  Up: |Fortran_Indent|
==============================================================================

                                                            *ForIndent_Commands*

26.14.2.1 Fortran Indentation and Filling Commands
.....---------------------------------------------

'C-M-j'
     Break the current line at point and set up a continuation line
     ('fortran-split-line').

'M-^'
     Join this line to the previous line ('fortran-join-line').

'C-M-q'
     Indent all the lines of the subprogram that point is in
     ('fortran-indent-subprogram').

'M-q'
     Fill a comment block or statement (using 'fortran-fill-paragraph'
     or 'fortran-fill-statement').

   The key 'C-M-q' runs 'fortran-indent-subprogram', a command to
reindent all the lines of the Fortran subprogram (function or
subroutine) containing point.

   The key 'C-M-j' runs 'fortran-split-line', which splits a line in the
appropriate fashion for Fortran.  In a non-comment line, the second half
becomes a continuation line and is indented accordingly.  In a comment
line, both halves become separate comment lines.

   'M-^' or 'C-c C-d' run the command 'fortran-join-line', which joins a
continuation line back to the previous line, roughly as the inverse of
'fortran-split-line'.  The point must be on a continuation line when
this command is invoked.

   'M-q' in Fortran mode fills the comment block or statement that point
is in.  This removes any excess statement continuations.

==============================================================================
File: emacs.info,  Node: |ForIndent_Cont|,  Next: |ForIndent_Num|,  Prev: |ForIndent_Commands|,  Up: |Fortran_Indent|
==============================================================================

                                                                *ForIndent_Cont*

26.14.2.2 Continuation Lines
.....-----------------------

Most Fortran 77 compilers allow two ways of writing continuation lines.
If the first non-space character on a line is in column 5, then that
line is a continuation of the previous line.  We call this "fixed form".
(In GNU Emacs we always count columns from 0; but note that the Fortran
standard counts from 1.  You can customize the variable
'column-number-indicator-zero-based' to make the column display
Fortran-like; *note Optional Mode Line::.)  The variable
'fortran-continuation-string' specifies what character to put in column
5.  A line that starts with a tab character followed by any digit except
'0' is also a continuation line.  We call this style of continuation
"tab format".  (Fortran 90 introduced free-form continuation lines.)

   Fortran mode can use either style of continuation line.  When you
enter Fortran mode, it tries to deduce the proper continuation style
automatically from the buffer contents.  It does this by scanning up to
'fortran-analyze-depth' (default 100) lines from the start of the
buffer.  The first line that begins with either a tab character or six
spaces determines the choice.  If the scan fails (for example, if the
buffer is new and therefore empty), the value of
'fortran-tab-mode-default' ('nil' for fixed form, and non-'nil' for tab
format) is used.  '/t' ('fortran-tab-mode-string') in the mode line
indicates tab format is selected.  Fortran mode sets the value of
'indent-tabs-mode' accordingly.

   If the text on a line starts with the Fortran continuation marker
'$', or if it begins with any non-whitespace character in column 5,
Fortran mode treats it as a continuation line.  When you indent a
continuation line with '<TAB>', it converts the line to the current
continuation style.  When you split a Fortran statement with 'C-M-j',
the continuation marker on the newline is created according to the
continuation style.

   The setting of continuation style affects several other aspects of
editing in Fortran mode.  In fixed form mode, the minimum column number
for the body of a statement is 6.  Lines inside of Fortran blocks that
are indented to larger column numbers must use only the space character
for whitespace.  In tab format mode, the minimum column number for the
statement body is 8, and the whitespace before column 8 must consist of
one tab character.

==============================================================================
File: emacs.info,  Node: |ForIndent_Num|,  Next: |ForIndent_Conv|,  Prev: |ForIndent_Cont|,  Up: |Fortran_Indent|
==============================================================================

                                                                 *ForIndent_Num*

26.14.2.3 Line Numbers
.....-----------------

If a number is the first non-whitespace in the line, Fortran indentation
assumes it is a line number and moves it to columns 0 through 4.
(Columns always count from 0 in Emacs, but setting
'column-number-indicator-zero-based' to 'nil' can change that, *note
Optional Mode Line::.)

   Line numbers of four digits or less are normally indented one space.
The variable 'fortran-line-number-indent' controls this; it specifies
the maximum indentation a line number can have.  The default value of
the variable is 1.  Fortran mode tries to prevent line number digits
passing column 4, reducing the indentation below the specified maximum
if necessary.  If 'fortran-line-number-indent' has the value 5, line
numbers are right-justified to end in column 4.

   Simply inserting a line number is enough to indent it according to
these rules.  As each digit is inserted, the indentation is recomputed.
To turn off this feature, set the variable
'fortran-electric-line-number' to 'nil'.

==============================================================================
File: emacs.info,  Node: |ForIndent_Conv|,  Next: |ForIndent_Vars|,  Prev: |ForIndent_Num|,  Up: |Fortran_Indent|
==============================================================================

                                                                *ForIndent_Conv*

26.14.2.4 Syntactic Conventions
.....--------------------------

Fortran mode assumes that you follow certain conventions that simplify
the task of understanding a Fortran program well enough to indent it
properly:

   * Two nested 'do' loops never share a 'continue' statement.

   * Fortran keywords such as 'if', 'else', 'then', 'do' and others are
     written without embedded whitespace or line breaks.

     Fortran compilers generally ignore whitespace outside of string
     constants, but Fortran mode does not recognize these keywords if
     they are not contiguous.  Constructs such as 'else if' or 'end do'
     are acceptable, but the second word should be on the same line as
     the first and not on a continuation line.

If you fail to follow these conventions, the indentation commands may
indent some lines unaesthetically.  However, a correct Fortran program
retains its meaning when reindented even if the conventions are not
followed.

==============================================================================
File: emacs.info,  Node: |ForIndent_Vars|,  Prev: |ForIndent_Conv|,  Up: |Fortran_Indent|
==============================================================================

                                                                *ForIndent_Vars*

26.14.2.5 Variables for Fortran Indentation
.....--------------------------------------

Several additional variables control how Fortran indentation works:

'fortran-do-indent'
     Extra indentation within each level of 'do' statement (default 3).

'fortran-if-indent'
     Extra indentation within each level of 'if', 'select case', or
     'where' statements (default 3).

'fortran-structure-indent'
     Extra indentation within each level of 'structure', 'union', 'map',
     or 'interface' statements (default 3).

'fortran-continuation-indent'
     Extra indentation for bodies of continuation lines (default 5).

'fortran-check-all-num-for-matching-do'
     In Fortran 77, a numbered 'do' statement is terminated by any
     statement with a matching line number.  It is common (but not
     compulsory) to use a 'continue' statement for this purpose.  If
     this variable has a non-'nil' value, indenting any numbered
     statement must check for a 'do' that ends there.  If you always end
     'do' statements with a 'continue' line (or if you use the more
     modern 'enddo'), then you can speed up indentation by setting this
     variable to 'nil' (the default).

'fortran-blink-matching-if'
     If this is 't', indenting an 'endif' (or 'enddo') statement moves
     the cursor momentarily to the matching 'if' (or 'do') statement to
     show where it is.  The default is 'nil'.

'fortran-minimum-statement-indent-fixed'
     Minimum indentation for Fortran statements when using fixed form
     continuation line style.  Statement bodies are never indented by
     less than this.  The default is 6.

'fortran-minimum-statement-indent-tab'
     Minimum indentation for Fortran statements for tab format
     continuation line style.  Statement bodies are never indented by
     less than this.  The default is 8.

   The following section describes the variables controlling the
indentation of comments.

==============================================================================
File: emacs.info,  Node: |Fortran_Comments|,  Next: |Fortran_Autofill|,  Prev: |Fortran_Indent|,  Up: |Fortran|
==============================================================================

                                                              *Fortran_Comments*

26.14.3 Fortran Comments
------------------------

The usual Emacs comment commands assume that a comment can follow a line
of code.  In Fortran 77, the standard comment syntax requires an entire
line to be just a comment.  Therefore, Fortran mode replaces the
standard Emacs comment commands and defines some new variables.

   Fortran mode can also handle the Fortran 90 comment syntax where
comments start with '!' and can follow other text.  Because only some
Fortran 77 compilers accept this syntax, Fortran mode will not insert
such comments unless you have said in advance to do so.  To do this, set
the variable 'fortran-comment-line-start' to '"!"'.  If you use an
unusual value, you may need to change 'fortran-comment-line-start-skip'.

'M-;'
     Align comment or insert new comment ('comment-dwim').

'C-x ;'
     Applies to nonstandard '!' comments only ('comment-set-column').

'C-c ;'
     Turn all lines of the region into comments, or (with argument) turn
     them back into real code ('fortran-comment-region').

   'M-;' in Fortran mode runs the standard 'comment-dwim'.  This
recognizes any kind of existing comment and aligns its text
appropriately; if there is no existing comment, a comment is inserted
and aligned.  Inserting and aligning comments are not the same in
Fortran mode as in other modes.

   When a new comment must be inserted, if the current line is blank, a
full-line comment is inserted.  On a non-blank line, a nonstandard '!'
comment is inserted if you have said you want to use them.  Otherwise, a
full-line comment is inserted on a new line before the current line.

   Nonstandard '!' comments are aligned like comments in other
languages, but full-line comments are different.  In a standard
full-line comment, the comment delimiter itself must always appear in
column zero.  What can be aligned is the text within the comment.  You
can choose from three styles of alignment by setting the variable
'fortran-comment-indent-style' to one of these values:

'fixed'
     Align the text at a fixed column, which is the sum of
     'fortran-comment-line-extra-indent' and the minimum statement
     indentation.  This is the default.

     The minimum indentation is 'fortran-minimum-statement-indent-tab'
     for tab format continuation line style and
     'fortran-minimum-statement-indent-fixed' for fixed form style.

'relative'
     Align the text as if it were a line of code, but with an additional
     'fortran-comment-line-extra-indent' columns of indentation.

'nil'
     Don't move text in full-line comments automatically.

   In addition, you can specify the character to be used to indent
within full-line comments by setting the variable
'fortran-comment-indent-char' to the single-character string you want to
use.

   Compiler directive lines, or preprocessor lines, have much the same
appearance as comment lines.  It is important, though, that such lines
never be indented at all, no matter what the value of
'fortran-comment-indent-style'.  The variable 'fortran-directive-re' is
a regular expression that specifies which lines are directives.
Matching lines are never indented, and receive distinctive font-locking.

   The normal Emacs comment command 'C-x ;' ('comment-set-column') has
not been redefined.  If you use '!' comments, this command can be used
with them.  Otherwise, it is useless in Fortran mode.

   The command 'C-c ;' ('fortran-comment-region') turns all the lines of
the region into comments by inserting the string 'c$$$' at the front of
each one.  With a numeric argument, it turns the region back into live
code by deleting 'c$$$' from the front of each line in it.  The string
used for these comments can be controlled by setting the variable
'fortran-comment-region'.  Note that here we have an example of a
command and a variable with the same name; these two uses of the name
never conflict because in Lisp and in Emacs it is always clear from the
context which one is meant.

==============================================================================
File: emacs.info,  Node: |Fortran_Autofill|,  Next: |Fortran_Columns|,  Prev: |Fortran_Comments|,  Up: |Fortran|
==============================================================================

                                                              *Fortran_Autofill*

26.14.4 Auto Fill in Fortran Mode
---------------------------------

Fortran mode has specialized support for Auto Fill mode, which is a
minor mode that automatically splits statements as you insert them when
they become too wide.  Splitting a statement involves making
continuation lines using 'fortran-continuation-string' (*note ForIndent
Cont::).  This splitting happens when you type '<SPC>', '<RET>', or
'<TAB>', and also in the Fortran indentation commands.  You activate
Auto Fill in Fortran mode in the normal way.  *Note Auto Fill::.

   Auto Fill breaks lines at spaces or delimiters when the lines get
longer than the desired width (the value of 'fill-column').  The
delimiters (besides whitespace) that Auto Fill can break at are '+',
'-', '/', '*', '=', '<', '>', and ','.  The line break comes after the
delimiter if the variable 'fortran-break-before-delimiters' is 'nil'.
Otherwise (and by default), the break comes before the delimiter.

   To enable Auto Fill in all Fortran buffers, add 'auto-fill-mode' to
'fortran-mode-hook'.  *Note Hooks::.

==============================================================================
File: emacs.info,  Node: |Fortran_Columns|,  Next: |Fortran_Abbrev|,  Prev: |Fortran_Autofill|,  Up: |Fortran|
==============================================================================

                                                               *Fortran_Columns*

26.14.5 Checking Columns in Fortran
-----------------------------------

In standard Fortran 77, anything beyond column 72 is ignored.  Most
compilers provide an option to change this (for example,
'-ffixed-line-length-N' in gfortran).  Customize the variable
'fortran-line-length' to change the line length in Fortran mode.
Anything beyond this point is font-locked as a comment.  (Unless it is
inside a string: strings that extend beyond 'fortran-line-length' will
confuse font-lock.)

'C-c C-r'
     Display a column ruler momentarily above the current line
     ('fortran-column-ruler').

'C-c C-w'
     Split the current window horizontally temporarily so that it is
     'fortran-line-length' columns wide
     ('fortran-window-create-momentarily').  This may help you avoid
     making lines longer than the limit imposed by your Fortran
     compiler.

'C-u C-c C-w'
     Split the current window horizontally so that it is
     'fortran-line-length' columns wide ('fortran-window-create').  You
     can then continue editing.

'M-x fortran-strip-sequence-nos'
     Delete all text in column 'fortran-line-length' and beyond.

   The command 'C-c C-r' ('fortran-column-ruler') shows a column ruler
momentarily above the current line.  The comment ruler is two lines of
text that show you the locations of columns with special significance in
Fortran programs.  Square brackets show the limits of the columns for
line numbers, and curly brackets show the limits of the columns for the
statement body.  Column numbers appear above them.

   Note that the column numbers count from zero, as always in GNU Emacs
(but customizing 'column-number-indicator-zero-based' can change column
display to match that of Fortran; *note Optional Mode Line::.)  As a
result, the numbers may be one less than those you are familiar with;
but the positions they indicate in the line are standard for Fortran.

   The text used to display the column ruler depends on the value of the
variable 'indent-tabs-mode'.  If 'indent-tabs-mode' is 'nil', then the
value of the variable 'fortran-column-ruler-fixed' is used as the column
ruler.  Otherwise, the value of the variable 'fortran-column-ruler-tab'
is displayed.  By changing these variables, you can change the column
ruler display.

   'C-c C-w' ('fortran-window-create-momentarily') temporarily splits
the current window horizontally, making a window 'fortran-line-length'
columns wide, so you can see any lines that are too long.  Type a space
to restore the normal width.

   You can also split the window horizontally and continue editing with
the split in place.  To do this, use 'C-u C-c C-w' ('M-x
fortran-window-create').  By editing in this window you can immediately
see when you make a line too wide to be correct Fortran.

   The command 'M-x fortran-strip-sequence-nos' deletes all text in
column 'fortran-line-length' and beyond, on all lines in the current
buffer.  This is the easiest way to get rid of old sequence numbers.

==============================================================================
File: emacs.info,  Node: |Fortran_Abbrev|,  Prev: |Fortran_Columns|,  Up: |Fortran|
==============================================================================

                                                                *Fortran_Abbrev*

26.14.6 Fortran Keyword Abbrevs
-------------------------------

Fortran mode provides many built-in abbrevs for common keywords and
declarations.  These are the same sort of abbrev that you can define
yourself.  To use them, you must turn on Abbrev mode.  *Note Abbrevs::.

   The built-in abbrevs are unusual in one way: they all start with a
semicolon.  For example, one built-in Fortran abbrev is ';c' for
'continue'.  If you insert ';c' and then insert a punctuation character
such as a space or a newline, the ';c' expands automatically to
'continue', provided Abbrev mode is enabled.

   Type ';?' or ';C-h' to display a list of all the built-in Fortran
abbrevs and what they stand for.

==============================================================================
File: emacs.info,  Node: |Building|,  Next: |Maintaining|,  Prev: |Programs|,  Up: |Top|
==============================================================================

                                                                      *Building*

27 Compiling and Testing Programs
*****============================

The previous chapter discusses the Emacs commands that are useful for
making changes in programs.  This chapter deals with commands that
assist in the process of compiling and testing programs.

MENU

* |Compilation|::         Compiling programs in languages other
                          than Lisp (C, Pascal, etc.).
* |Compilation_Mode|::    The mode for visiting compiler errors.
* |Compilation_Shell|::   Customizing your shell properly
                          for use in the compilation buffer.
* |Grep_Searching|::      Searching with grep.
* |Flymake|::             Finding syntax errors on the fly.
* |Debuggers|::           Running symbolic debuggers for non-Lisp programs.
* |Executing_Lisp|::      Various modes for editing Lisp programs,
                          with different facilities for running
                          the Lisp programs.
* Libraries: Lisp Libraries.      How Lisp programs are loaded into Emacs.
* Eval: Lisp Eval.      Executing a single Lisp expression in Emacs.
* Interaction: Lisp Interaction.  Executing Lisp in an Emacs buffer.
* |External_Lisp|::       Communicating through Emacs with a separate Lisp.

==============================================================================
File: emacs.info,  Node: |Compilation|,  Next: |Compilation_Mode|,  Up: |Building|
==============================================================================

                                                                   *Compilation*

27.1 Running Compilations under Emacs
=====--------------------------------

Emacs can run compilers for languages such as C and Fortran, feeding the
compilation log into an Emacs buffer.  It can also parse the error
messages and show you where the errors occurred.

'M-x compile'
     Run a compiler asynchronously under Emacs, with error messages
     going to the 'compilation' buffer.

'M-x recompile'
'g (Compilation mode)'
     Invoke a compiler with the same command as in the last invocation
     of 'M-x compile'.

'M-x kill-compilation'
     Kill the running compilation subprocess.

   To run 'make' or another compilation command, type 'M-x compile'.
This reads a shell command line using the minibuffer, and then executes
the command by running a shell as a subprocess (or "inferior process")
of Emacs.  The output is inserted in a buffer named 'compilation'.
The current buffer's default directory is used as the working directory
for the execution of the command, so by default compilation takes place
in that directory.

   The default compilation command is 'make -k', which is usually
correct for programs compiled using the 'make' utility (the '-k' flag
tells 'make' to continue compiling as much as possible after an error).
*Note Make: (make)Top.  If you have done 'M-x compile' before, the
command that you specified is automatically stored in the variable
'compile-command'; this is used as the default the next time you type
'M-x compile'.  A file can also specify a file-local value for
'compile-command' (*note File Variables::).

   Starting a compilation displays the 'compilation' buffer in another
window but does not select it.  While the compilation is running, the
word 'run' is shown in the major mode indicator for the 'compilation'
buffer, and the word 'Compiling' appears in all mode lines.  You do not
have to keep the 'compilation' buffer visible while compilation is
running; it continues in any case.  When the compilation ends, for
whatever reason, the mode line of the 'compilation' buffer changes to
say 'exit' (followed by the exit code: '[0]' for a normal exit), or
'signal' (if a signal terminated the process).

   If you want to watch the compilation transcript as it appears, switch
to the 'compilation' buffer and move point to the end of the buffer.
When point is at the end, new compilation output is inserted above
point, which remains at the end.  Otherwise, point remains fixed while
compilation output is added at the end of the buffer.

   While compilation proceeds, the mode line shows the number of errors,
warnings, and informational messages emitted by the compiler so far.

   If you change the variable 'compilation-scroll-output' to a non-'nil'
value, the 'compilation' buffer scrolls automatically to follow the
output.  If the value is 'first-error', scrolling stops when the first
error appears, leaving point at that error.  For any other non-'nil'
value, scrolling continues until there is no more output.

   To rerun the last compilation with the same command, type 'M-x
recompile'.  This reuses the compilation command from the last
invocation of 'M-x compile'.  It also reuses the 'compilation' buffer
and starts the compilation in its default directory, which is the
directory in which the previous compilation was started.  In
'compilation' buffers this command is bound to 'g'.

   Starting a new compilation also kills any compilation already running
in 'compilation', as the buffer can only handle one compilation at any
time.  However, 'M-x compile' and 'M-x recompile' ask for confirmation
before actually killing a compilation that is running; to always
automatically kill the compilation without asking, change the variable
'compilation-always-kill' to 't'.  You can also kill a compilation
process with the command 'M-x kill-compilation'.

   To run two compilations at once, start the first one, then rename the
'compilation' buffer (perhaps using 'rename-uniquely'; *note Misc
Buffer::), then switch buffers and start the other compilation.  This
will create a new 'compilation' buffer.

   You can control the environment passed to the compilation command
with the variable 'compilation-environment'.  Its value is a list of
environment variable settings; each element should be a string of the
form '"ENVVARNAME=VALUE"'.  These environment variable settings override
the usual ones.

==============================================================================
File: emacs.info,  Node: |Compilation_Mode|,  Next: |Compilation_Shell|,  Prev: |Compilation|,  Up: |Building|
==============================================================================

                                                              *Compilation_Mode*

27.2 Compilation Mode
=====----------------

The 'compilation' buffer uses a major mode called Compilation mode.
Compilation mode turns each error message in the buffer into a
hyperlink; you can move point to it and type <RET>, or click on it with
the mouse (*note Mouse References::), to visit the "locus" of the error
message in a separate window.  The locus is the specific position in a
file where that error occurred.

   The appearance of the 'compilation' buffer can be controlled by
customizing the faces which are used to highlight parts of the
'compilation' buffer, e.g., 'compilation-error' or
'compilation-warning', for error and warning messages respectively.
Note that since those faces inherit from the 'error' and 'warning'
faces, it is also possible to customize the parent face directly
instead.

   Use 'M-x customize-group RET compilation' to see the entire list of
customization variables and faces.

   If you change the variable 'compilation-auto-jump-to-first-error' to
a non-'nil' value, Emacs automatically visits the locus of the first
error message that appears in the 'compilation' buffer.

   Compilation mode provides the following additional commands.  These
commands can also be used in 'grep' buffers, where the hyperlinks are
search matches rather than error messages (*note Grep Searching::).

'M-g M-n'
'M-g n'
'C-x `'
     Visit the locus of the next error message or match ('next-error').
'M-g M-p'
'M-g p'
     Visit the locus of the previous error message or match
     ('previous-error').
'M-n'
     Move point to the next error message or match, without visiting its
     locus ('compilation-next-error').
'M-p'
     Move point to the previous error message or match, without visiting
     its locus ('compilation-previous-error').
'M-}'
     Move point to the next error message or match occurring in a
     different file ('compilation-next-file').
'M-{'
     Move point to the previous error message or match occurring in a
     different file ('compilation-previous-file').
'C-c C-f'
     Toggle Next Error Follow minor mode, which makes cursor motion in
     the compilation buffer produce automatic source display.
'g'
     Re-run the last command whose output is shown in the
     'compilation' buffer.
'M-x next-error-select-buffer'
     Select a buffer to be used by next invocation of 'next-error' and
     'previous-error'.

   To visit errors sequentially, type 'C-x `' ('next-error'), or
equivalently 'M-g M-n' or 'M-g n'.  This command can be invoked from any
buffer, not just a Compilation mode buffer.  The first time you invoke
it after a compilation, it visits the locus of the first error message.
Each subsequent 'M-g M-n' visits the next error, in a similar fashion.
If you visit a specific error with <RET> or a mouse click in the
'compilation' buffer, subsequent 'M-g M-n' commands advance from
there.  When 'M-g M-n' finds no more error messages to visit, it signals
an error.  'C-u M-g M-n' starts again from the beginning of the
compilation buffer, and visits the first locus.

   'M-g M-p' or 'M-g p' ('previous-error') iterates through errors in
the opposite direction.

   The 'next-error' and 'previous-error' commands don't just act on the
errors or matches listed in 'compilation' and '*grep*' buffers; they
also know how to iterate through error or match lists produced by other
commands, such as 'M-x occur' (*note Other Repeating Search::).  If the
current buffer contains error messages or matches, these commands will
iterate through them; otherwise, Emacs looks for a buffer containing
error messages or matches amongst the windows of the selected frame (if
the variable 'next-error-find-buffer-function' is customized to the
value 'next-error-buffer-on-selected-frame'), then for a buffer used
previously by 'next-error' or 'previous-error', and finally all other
buffers.  Any buffer these commands iterate through that is not
currently displayed in a window will be displayed.  You can use the
'next-error-select-buffer' command to switch to a different buffer to be
used by the subsequent invocation of 'next-error'.

   By default, the 'next-error' and 'previous-error' commands skip less
important messages.  The variable 'compilation-skip-threshold' controls
this.  The default value, 1, means to skip anything less important than
a warning.  A value of 2 means to skip anything less important than an
error, while 0 means not to skip any messages.

   When Emacs visits the locus of an error message, it momentarily
highlights the relevant source line.  The duration of this highlight is
determined by the variable 'next-error-highlight' for the locus in the
selected buffer, and 'next-error-highlight-no-select' for the locus in
non-selected buffers.

   If the 'compilation' buffer is shown in a window with a left fringe
(*note Fringes::), the locus-visiting commands put an arrow in the
fringe, pointing to the current error message.  If the window has no
left fringe, such as on a text terminal, these commands scroll the
window so that the current message is at the top of the window.  If you
change the variable 'compilation-context-lines' to 't', a visible arrow
is inserted before column zero instead.  If you change the variable to
an integer value N, these commands scroll the window so that the current
error message is N lines from the top, whether or not there is a fringe;
the default value, 'nil', gives the behavior described above.

   To parse messages from the compiler, Compilation mode uses the
variable 'compilation-error-regexp-alist' which lists various error
message formats and tells Emacs how to extract the locus from each.  A
similar variable, 'grep-regexp-alist', tells Emacs how to parse output
from a 'grep' command (*note Grep Searching::).

   Compilation mode also defines the keys <SPC> and <DEL> to scroll by
screenfuls; 'M-n' ('compilation-next-error') and 'M-p'
('compilation-previous-error') to move to the next or previous error
message; and 'M-{' ('compilation-next-file') and 'M-}'
('compilation-previous-file') to move to the next or previous error
message for a different source file.

   You can type 'C-c C-f' to toggle Next Error Follow mode.  In this
minor mode, ordinary cursor motion in the compilation buffer
automatically updates the source buffer, i.e., moving the cursor over an
error message causes the locus of that error to be displayed.

   The features of Compilation mode are also available in a minor mode
called Compilation Minor mode.  This lets you parse error messages in
any buffer, not just a normal compilation output buffer.  Type 'M-x
compilation-minor-mode' to enable the minor mode.  For instance, in an
Rlogin buffer (*note Remote Host::), Compilation minor mode
automatically accesses remote source files by FTP (*note File Names::).

==============================================================================
File: emacs.info,  Node: |Compilation_Shell|,  Next: |Grep_Searching|,  Prev: |Compilation_Mode|,  Up: |Building|
==============================================================================

                                                             *Compilation_Shell*

27.3 Subshells for Compilation
=====-------------------------

This section includes various techniques and advice for using a shell
and its features in compilation buffers.  This material is specific to
local compilations, and will most probably not work in (or be irrelevant
to) compilation buffers whose default directory is on remote hosts.

   The 'M-x compile' command uses a shell to run the compilation
command, but specifies the option for a noninteractive shell.  This
means, in particular, that the shell should start with no prompt.  If
you find your usual shell prompt making an unsightly appearance in the
'compilation' buffer, it means you have made a mistake in your shell's
init file by setting the prompt unconditionally.  (This init file may be
named '.bashrc', '.profile', '.cshrc', '.shrc', etc., depending on what
shell you use.)  The shell init file should set the prompt only if there
already is a prompt.  Here's how to do it in bash:

     if [ "${PS1+set}" = set ]
     then PS1=...
     fi

And here's how to do it in csh:

     if ($?prompt) set prompt = ...

   If you want to customize the value of the 'TERM' environment variable
passed to the compilation subshell, customize the variable
'comint-terminfo-terminal' (*note Shell Options::).

   Emacs does not expect a compiler process to launch asynchronous
subprocesses; if it does, and they keep running after the main compiler
process has terminated, Emacs may kill them or their output may not
arrive in Emacs.  To avoid this problem, make the main compilation
process wait for its subprocesses to finish.  In a shell script, you can
do this using '$!' and 'wait', like this:

     (sleep 10; echo 2nd)& pid=$!  # Record pid of subprocess
     echo first message
     wait $pid                     # Wait for subprocess

If the background process does not output to the compilation buffer, so
you only need to prevent it from being killed when the main compilation
process terminates, this is sufficient:

     nohup COMMAND; sleep 1

   On MS-DOS, asynchronous subprocesses are not supported, so 'M-x
compile' runs the compilation command synchronously (i.e., you must wait
until the command finishes before you can do anything else in Emacs).
*Note MS-DOS::.

==============================================================================
File: emacs.info,  Node: |Grep_Searching|,  Next: |Flymake|,  Prev: |Compilation_Shell|,  Up: |Building|
==============================================================================

                                                                *Grep_Searching*

27.4 Searching with Grep under Emacs
=====-------------------------------

Just as you can run a compiler from Emacs and then visit the lines with
compilation errors, you can also run 'grep' and then visit the lines on
which matches were found.  This works by treating the matches reported
by 'grep' as if they were errors.  The output buffer uses Grep mode,
which is a variant of Compilation mode (*note Compilation Mode::).

'M-x grep'
'M-x lgrep'
     Run 'grep' asynchronously under Emacs, listing matching lines in
     the buffer named 'grep'.
'M-x grep-find'
'M-x find-grep'
'M-x rgrep'
     Run 'grep' via 'find', and collect output in the 'grep' buffer.
'M-x zrgrep'
     Run 'zgrep' and collect output in the 'grep' buffer.
'M-x kill-grep'
     Kill the running 'grep' subprocess.

   To run 'grep', type 'M-x grep', then enter a command line that
specifies how to run 'grep'.  Use the same arguments you would give
'grep' when running it normally: a 'grep'-style regexp (usually in
single-quotes to quote the shell's special characters) followed by file
names, which may use wildcards.  If you specify a prefix argument for
'M-x grep', it finds the identifier (*note Xref::) in the buffer around
point, and puts that into the default 'grep' command.

   Your command need not simply run 'grep'; you can use any shell
command that produces output in the same format.  For instance, you can
chain 'grep' commands, like this:

     grep -nH -e foo *.el | grep bar | grep toto

   The output from 'grep' goes in the 'grep' buffer.  You can find the
corresponding lines in the original files using 'M-g M-n', <RET>, and so
forth, just like compilation errors.  *Note Compilation Mode::, for
detailed description of commands and key bindings available in the
'grep' buffer.

   Some grep programs accept a '--color' option to output special
markers around matches for the purpose of highlighting.  You can make
use of this feature by setting 'grep-highlight-matches' to 't'.  When
displaying a match in the source buffer, the exact match will be
highlighted, instead of the entire source line.

   As with compilation commands (*note Compilation::), while the grep
command runs, the mode line shows the running number of matches found
and highlighted so far.

   The 'grep' commands will offer to save buffers before running.  This
is controlled by the 'grep-save-buffers' variable.  The possible values
are either 'nil' (don't save), 'ask' (ask before saving), or a function
which will be used as a predicate (and is called with the file name as
the parameter and should return non-'nil' if the buffer is to be saved).
Any other non-'nil' value means that all buffers should be saved without
asking.  The default is 'ask'.

   The command 'M-x grep-find' (also available as 'M-x find-grep') is
similar to 'M-x grep', but it supplies a different initial default for
the command--one that runs both 'find' and 'grep', so as to search every
file in a directory tree.  See also the 'find-grep-dired' command, in
*note Dired and Find::.

   The commands 'M-x lgrep' (local grep) and 'M-x rgrep' (recursive
grep) are more user-friendly versions of 'grep' and 'grep-find', which
prompt separately for the regular expression to match, the files to
search, and the base directory for the search.  Case sensitivity of the
search is controlled by the current value of 'case-fold-search'.  The
command 'M-x zrgrep' is similar to 'M-x rgrep', but it calls 'zgrep'
instead of 'grep' to search the contents of gzipped files.

   These commands build the shell commands based on the variables
'grep-template' (for 'lgrep') and 'grep-find-template' (for 'rgrep').
The files to search can use aliases defined in the variable
'grep-files-aliases'.

   Directories listed in the variable 'grep-find-ignored-directories'
are automatically skipped by 'M-x rgrep'.  The default value includes
the data directories used by various version control systems.

   By default, the shell commands constructed for 'lgrep', 'rgrep', and
'zgrep' are abbreviated for display by concealing the part that contains
a long list of files and directories to ignore.  You can reveal the
concealed part by clicking on the button with ellipsis, which represents
them.  You can also interactively toggle viewing the concealed part by
typing 'M-x grep-find-toggle-abbreviation'.  To disable this
abbreviation of the shell commands, customize the option
'grep-find-abbreviate' to a 'nil' value.

==============================================================================
File: emacs.info,  Node: |Flymake|,  Next: |Debuggers|,  Prev: |Grep_Searching|,  Up: |Building|
==============================================================================

                                                                       *Flymake*

27.5 Finding Syntax Errors On The Fly
=====--------------------------------

Flymake mode is a minor mode that performs on-the-fly syntax checking
for many programming and markup languages, including C, C++, Perl, HTML,
and TeX/LaTeX.  It is somewhat analogous to Flyspell mode, which
performs spell checking for ordinary human languages in a similar
fashion (*note Spelling::).  As you edit a file, Flymake mode runs an
appropriate syntax checking tool in the background, using a temporary
copy of the buffer.  It then parses the error and warning messages, and
highlights the erroneous lines in the buffer.  The syntax checking tool
used depends on the language; for example, for C/C++ files this is
usually the C compiler.  Flymake can also use build tools such as 'make'
for checking complicated projects.

   To enable Flymake mode, type 'M-x flymake-mode'.  You can jump to the
errors that it finds by using 'M-x flymake-goto-next-error' and 'M-x
flymake-goto-prev-error'.  To display any error messages associated with
the current line, type 'M-x flymake-display-err-menu-for-current-line'.

   For more details about using Flymake, see *note Flymake:
(flymake)Top.

==============================================================================
File: emacs.info,  Node: |Debuggers|,  Next: |Executing_Lisp|,  Prev: |Flymake|,  Up: |Building|
==============================================================================

                                                                     *Debuggers*

27.6 Running Debuggers Under Emacs
=====-----------------------------

The GUD (Grand Unified Debugger) library provides an Emacs interface to
a wide variety of symbolic debuggers.  It can run the GNU Debugger
(GDB), as well as DBX, SDB, XDB, Guile REPL debug commands, Perl's
debugging mode, the Python debugger PDB, and the Java Debugger JDB.

   Emacs provides a special interface to GDB, which uses extra Emacs
windows to display the state of the debugged program.  *Note GDB
Graphical Interface::.

   Emacs also has a built-in debugger for Emacs Lisp programs.  *Note
The Lisp Debugger: (elisp)Debugging.

MENU

* |Starting_GUD|::        How to start a debugger subprocess.
* |Debugger_Operation|::  Connection between the debugger and source buffers.
* |Commands_of_GUD|::     Key bindings for common commands.
* |GUD_Customization|::   Defining your own commands for GUD.
* |GDB_Graphical_Interface|::  An enhanced mode that uses GDB features to
                        implement a graphical debugging environment.

==============================================================================
File: emacs.info,  Node: |Starting_GUD|,  Next: |Debugger_Operation|,  Up: |Debuggers|
==============================================================================

                                                                  *Starting_GUD*

27.6.1 Starting GUD
-------------------

There are several commands for starting a debugger subprocess, each
corresponding to a particular debugger program.

'M-x gdb'
     Run GDB as a subprocess, and interact with it via an IDE-like Emacs
     interface.  *Note GDB Graphical Interface::, for more information
     about this command.

'M-x gud-gdb'
     Run GDB, using a GUD interaction buffer for input and output to the
     GDB subprocess (*note Debugger Operation::).  If such a buffer
     already exists, switch to it; otherwise, create the buffer and
     switch to it.

     The other commands in this list do the same, for other debugger
     programs.

'M-x perldb'
     Run the Perl interpreter in debug mode.

'M-x jdb'
     Run the Java debugger.

'M-x pdb'
     Run the Python debugger.

'M-x guiler'
     Run Guile REPL for debugging Guile Scheme programs.

'M-x dbx'
     Run the DBX debugger.

'M-x xdb'
     Run the XDB debugger.

'M-x sdb'
     Run the SDB debugger.

   Each of these commands reads a command line to invoke the debugger,
using the minibuffer.  The minibuffer's initial contents contain the
standard executable name and options for the debugger, and sometimes
also a guess for the name of the executable file you want to debug.
Shell wildcards and variables are not allowed in this command line.
Emacs assumes that the first command argument which does not start with
a '-' is the executable file name.

   Tramp provides a facility for remote debugging, whereby both the
debugger and the program being debugged are on the same remote host.
*Note (tramp)Running a debugger on a remote host::, for details.  This
is separate from GDB's remote debugging feature, where the program and
the debugger run on different machines (*note Debugging Remote Programs:
(gdb)Remote Debugging.).

==============================================================================
File: emacs.info,  Node: |Debugger_Operation|,  Next: |Commands_of_GUD|,  Prev: |Starting_GUD|,  Up: |Debuggers|
==============================================================================

                                                            *Debugger_Operation*

27.6.2 Debugger Operation
-------------------------

The "GUD interaction buffer" is an Emacs buffer which is used to send
text commands to a debugger subprocess, and record its output.  This is
the basic interface for interacting with a debugger, used by 'M-x
gud-gdb' and other commands listed in *note Starting GUD::.  The 'M-x
gdb' command extends this interface with additional specialized buffers
for controlling breakpoints, stack frames, and other aspects of the
debugger state (*note GDB Graphical Interface::).

   The GUD interaction buffer uses a variant of Shell mode, so the Emacs
commands defined by Shell mode are available (*note Shell Mode::).
Completion is available for most debugger commands (*note Completion::),
and you can use the usual Shell mode history commands to repeat them.
*Note Commands of GUD::, for special commands that can be used in the
GUD interaction buffer.

   As you debug a program, Emacs displays the relevant source files by
visiting them in Emacs buffers, with an arrow in the left fringe
indicating the current execution line.  (On a text terminal, the arrow
appears as '=>', overlaid on the first two text columns.)  Moving point
in such a buffer does not move the arrow.  You are free to edit these
source files, but note that inserting or deleting lines will throw off
the arrow's positioning, as Emacs has no way to figure out which edited
source line corresponds to the line reported by the debugger subprocess.
To update this information, you typically have to recompile and restart
the program.

   GUD Tooltip mode is a global minor mode that adds tooltip support to
GUD.  To toggle this mode, type 'M-x gud-tooltip-mode'.  It is disabled
by default.  If enabled, you can move the mouse pointer over a variable,
a function, or a macro (collectively called "identifiers") to show their
values in tooltips (*note Tooltips::).  If just placing the mouse
pointer over an expression doesn't show the value of the expression you
had in mind, you can tell Emacs more explicitly what expression to
evaluate by dragging the mouse over the expression, then leaving the
mouse inside the marked area.  The GUD Tooltip mode takes effect in the
GUD interaction buffer, and in all source buffers with major modes
listed in the variable 'gud-tooltip-modes'.  If the variable
'gud-tooltip-echo-area' is non-'nil', or if you turned off the tooltip
mode, values are shown in the echo area instead of a tooltip.

   When using GUD Tooltip mode with 'M-x gud-gdb', displaying an
expression's value in GDB can sometimes expand a macro, potentially
causing side effects in the debugged program.  For that reason, using
tooltips in 'gud-gdb' is disabled.  If you use the 'M-x gdb' interface,
this problem does not occur, as there is special code to avoid
side-effects; furthermore, you can display macro definitions associated
with an identifier when the program is not executing.

==============================================================================
File: emacs.info,  Node: |Commands_of_GUD|,  Next: |GUD_Customization|,  Prev: |Debugger_Operation|,  Up: |Debuggers|
==============================================================================

                                                               *Commands_of_GUD*

27.6.3 Commands of GUD
----------------------

GUD provides commands for setting and clearing breakpoints, selecting
stack frames, and stepping through the program.

'C-x C-a C-b'
     Set a breakpoint on the source line that point is on.

   'C-x C-a C-b' ('gud-break'), when called in a source buffer, sets a
debugger breakpoint on the current source line.  This command is
available only after starting GUD.  If you call it in a buffer that is
not associated with any debugger subprocess, it signals an error.

   The following commands are available both in the GUD interaction
buffer and globally, but with different key bindings.  The keys starting
with 'C-c' are available only in the GUD interaction buffer, while those
starting with 'C-x C-a' are available globally.  Some of these commands
are also available via the tool bar; some are not supported by certain
debuggers.

'C-c C-l'
'C-x C-a C-l'
     Display, in another window, the last source line referred to in the
     GUD interaction buffer ('gud-refresh').

'C-c C-s'
'C-x C-a C-s'
     Execute the next single line of code ('gud-step').  If the line
     contains a function call, execution stops after entering the called
     function.

'C-c C-n'
'C-x C-a C-n'
     Execute the next single line of code, stepping across function
     calls without stopping inside the functions ('gud-next').

'C-c C-i'
'C-x C-a C-i'
     Execute a single machine instruction ('gud-stepi').

'C-c C-p'
'C-x C-a C-p'
     Evaluate the expression at point ('gud-print').  If Emacs does not
     print the exact expression that you want, mark it as a region
     first.

'C-c C-r'
'C-x C-a C-r'
     Continue execution without specifying any stopping point.  The
     program will run until it hits a breakpoint, terminates, or gets a
     signal that the debugger is checking for ('gud-cont').

'C-c C-d'
'C-x C-a C-d'
     Delete the breakpoint(s) on the current source line, if any
     ('gud-remove').  If you use this command in the GUD interaction
     buffer, it applies to the line where the program last stopped.

'C-c C-t'
'C-x C-a C-t'
     Set a temporary breakpoint on the current source line, if any
     ('gud-tbreak').  If you use this command in the GUD interaction
     buffer, it applies to the line where the program last stopped.

'C-c <'
'C-x C-a <'
     Select the next enclosing stack frame ('gud-up').  This is
     equivalent to the GDB command 'up'.

'C-c >'
'C-x C-a >'
     Select the next inner stack frame ('gud-down').  This is equivalent
     to the GDB command 'down'.

'C-c C-u'
'C-x C-a C-u'
     Continue execution to the current line ('gud-until').  The program
     will run until it hits a breakpoint, terminates, gets a signal that
     the debugger is checking for, or reaches the line on which the
     cursor currently sits.

'C-c C-f'
'C-x C-a C-f'
     Run the program until the selected stack frame returns or stops for
     some other reason ('gud-finish').

   If you are using GDB, these additional key bindings are available:

'C-x C-a C-j'
     Only useful in a source buffer, 'gud-jump' transfers the program's
     execution point to the current line.  In other words, the next line
     that the program executes will be the one where you gave the
     command.  If the new execution line is in a different function from
     the previously one, GDB prompts for confirmation since the results
     may be bizarre.  See the GDB manual entry regarding 'jump' for
     details.

'<TAB>'
     With GDB, complete a symbol name ('gud-gdb-complete-command').
     This key is available only in the GUD interaction buffer.

   These commands interpret a numeric argument as a repeat count, when
that makes sense.

   Because <TAB> serves as a completion command, you can't use it to
enter a tab as input to the program you are debugging with GDB.
Instead, type 'C-q <TAB>' to enter a tab.

==============================================================================
File: emacs.info,  Node: |GUD_Customization|,  Next: |GDB_Graphical_Interface|,  Prev: |Commands_of_GUD|,  Up: |Debuggers|
==============================================================================

                                                             *GUD_Customization*

27.6.4 GUD Customization
------------------------

On startup, GUD runs one of the following hooks: 'gdb-mode-hook', if you
are using GDB; 'dbx-mode-hook', if you are using DBX; 'sdb-mode-hook',
if you are using SDB; 'xdb-mode-hook', if you are using XDB;
'guiler-mode-hook' for Guile REPL debugging; 'perldb-mode-hook', for
Perl debugging mode; 'pdb-mode-hook', for PDB; 'jdb-mode-hook', for JDB.
*Note Hooks::.

   The 'gud-def' Lisp macro (*note (elisp)Defining Macros::) provides a
convenient way to define an Emacs command that sends a particular
command string to the debugger, and set up a key binding for in the GUD
interaction buffer:

     (gud-def FUNCTION CMDSTRING BINDING DOCSTRING)

   This defines a command named FUNCTION which sends CMDSTRING to the
debugger process, and gives it the documentation string DOCSTRING.  You
can then use the command FUNCTION in any buffer.  If BINDING is
non-'nil', 'gud-def' also binds the command to 'C-c BINDING' in the GUD
buffer's mode and to 'C-x C-a BINDING' generally.

   The command string CMDSTRING may contain certain '%'-sequences that
stand for data to be filled in at the time FUNCTION is called:

'%f'
     The name of the current source file.  If the current buffer is the
     GUD buffer, then the current source file is the file that the
     program stopped in.

'%l'
     The number of the current source line.  If the current buffer is
     the GUD buffer, then the current source line is the line that the
     program stopped in.

'%e'
     In transient-mark-mode the text in the region, if it is active.
     Otherwise the text of the C lvalue or function-call expression at
     or adjacent to point.

'%a'
     The text of the hexadecimal address at or adjacent to point.

'%p'
     The numeric argument of the called function, as a decimal number.
     If the command is used without a numeric argument, '%p' stands for
     the empty string.

     If you don't use '%p' in the command string, the command you define
     ignores any numeric argument.

'%d'
     The name of the directory of the current source file.

'%c'
     Fully qualified class name derived from the expression surrounding
     point (jdb only).

==============================================================================
File: emacs.info,  Node: |GDB_Graphical_Interface|,  Prev: |GUD_Customization|,  Up: |Debuggers|
==============================================================================

                                                       *GDB_Graphical_Interface*

27.6.5 GDB Graphical Interface
------------------------------

The command 'M-x gdb' starts GDB in an IDE-like interface, with
specialized buffers for controlling breakpoints, stack frames, and other
aspects of the debugger state.  It also provides additional ways to
control the debugging session with the mouse, such as clicking in the
fringe of a source buffer to set a breakpoint there.

   To run GDB using just the GUD interaction buffer interface, without
these additional features, use 'M-x gud-gdb' (*note Starting GUD::).
You must use this if you want to debug multiple programs within one
Emacs session, as that is currently unsupported by 'M-x gdb'.

   Internally, 'M-x gdb' informs GDB that its screen size is unlimited;
for correct operation, you must not change GDB's screen height and width
values during the debugging session.

MENU

* |GDB_User_Interface_Layout|::   Control the number of displayed buffers.
* |Source_Buffers|::              Use the mouse in the fringe/margin to
                                control your program.
* |Breakpoints_Buffer|::          A breakpoint control panel.
* |Threads_Buffer|::              Displays your threads.
* |Stack_Buffer|::                Select a frame from the call stack.
* |Other_GDB_Buffers|::           Other buffers for controlling the GDB state.
* |Watch_Expressions|::           Monitor variable values in the speedbar.
* |Multithreaded_Debugging|::     Debugging programs with several threads.

==============================================================================
File: emacs.info,  Node: |GDB_User_Interface_Layout|,  Next: |Source_Buffers|,  Up: |GDB_Graphical_Interface|
==============================================================================

                                                     *GDB_User_Interface_Layout*

27.6.5.1 GDB User Interface Layout
.....-----------------------------

If the variable 'gdb-many-windows' is 'nil' (the default), 'M-x gdb'
normally displays only the GUD interaction buffer.  However, if the
variable 'gdb-show-main' is also non-'nil', it starts with two windows:
one displaying the GUD interaction buffer, and the other showing the
source for the 'main' function of the program you are debugging.

   If 'gdb-many-windows' is non-'nil', then 'M-x gdb' displays the
following frame layout:

     +--------------------------------+--------------------------------+
     |   GUD interaction buffer       |   Locals/Registers buffer      |
     |--------------------------------+--------------------------------+
     |   Primary Source buffer        |   I/O buffer for debugged pgm  |
     |--------------------------------+--------------------------------+
     |   Stack buffer                 |   Breakpoints/Threads buffer   |
     +--------------------------------+--------------------------------+

   If you ever change the window layout, you can restore the
many-windows layout by typing 'M-x gdb-restore-windows'.  To toggle
between the many windows layout and a simple layout with just the GUD
interaction buffer and a source file, type 'M-x gdb-many-windows'.

   If you have an elaborate window setup, and don't want
'gdb-many-windows' to disrupt that, it is better to invoke 'M-x gdb' in
a separate frame to begin with, then the arrangement of windows on your
original frame will not be affected.  A separate frame for GDB sessions
can come in especially handy if you work on a text-mode terminal, where
the screen estate for windows could be at a premium.

   You may also specify additional GDB-related buffers to display,
either in the same frame or a different one.  Select the buffers you
want by typing 'M-x gdb-display-BUFFERTYPE-buffer' or 'M-x
gdb-frame-BUFFERTYPE-buffer', where BUFFERTYPE is the relevant buffer
type, such as 'breakpoints'.  You can do the same with the menu bar,
with the 'GDB-Windows' and 'GDB-Frames' sub-menus of the 'GUD' menu.

   When you finish debugging, kill the GUD interaction buffer with 'C-x
k', which will also kill all the buffers associated with the session.
However you need not do this if, after editing and re-compiling your
source code within Emacs, you wish to continue debugging.  When you
restart execution, GDB automatically finds the new executable.  Keeping
the GUD interaction buffer has the advantage of keeping the shell
history as well as GDB's breakpoints.  You do need to check that the
breakpoints in recently edited source files are still in the right
places.

==============================================================================
File: emacs.info,  Node: |Source_Buffers|,  Next: |Breakpoints_Buffer|,  Prev: |GDB_User_Interface_Layout|,  Up: |GDB_Graphical_Interface|
==============================================================================

                                                                *Source_Buffers*

27.6.5.2 Source Buffers
.....------------------

'mouse-1' (in fringe)
     Set or clear a breakpoint on that line
     ('gdb-mouse-set-clear-breakpoint').

'C-mouse-1' (in fringe)
     Enable or disable a breakpoint on that line
     ('gdb-mouse-toggle-breakpoint-margin').

'mouse-3' (in fringe)
     Continue execution to that line ('gdb-mouse-until').

'C-mouse-3' (in fringe)
     Jump to that line ('gdb-mouse-jump').

   On a graphical display, you can click 'mouse-1' in the fringe of a
source buffer, to set a breakpoint on that line (*note Fringes::).  A
red dot appears in the fringe, where you clicked.  If a breakpoint
already exists there, the click removes it.  A 'C-mouse-1' click enables
or disables an existing breakpoint; a breakpoint that is disabled, but
not unset, is indicated by a gray dot.

   On a text terminal, or when fringes are disabled, enabled breakpoints
are indicated with a 'B' character in the left margin of the window.
Disabled breakpoints are indicated with 'b'.  (The margin is only
displayed if a breakpoint is present.)

   A solid arrow in the left fringe of a source buffer indicates the
line of the innermost frame where the debugged program has stopped.  A
hollow arrow indicates the current execution line of a higher-level
frame.  If you drag the arrow in the fringe with 'mouse-1', that causes
execution to advance to the line where you release the button.
Alternatively, you can click 'mouse-3' in the fringe to advance to that
line.  You can click 'C-mouse-3' in the fringe to jump to that line
without executing the intermediate lines.  This command allows you to go
backwards, which can be useful for running through code that has already
executed, in order to examine its execution in more detail.

   If the file names of the source files are shown with octal escapes,
set the variable 'gdb-mi-decode-strings' to the appropriate
coding-system, most probably 'utf-8'.  (This is 'nil' by default because
GDB may emit octal escapes in situations where decoding is undesirable,
and also because the program being debugged might use an encoding
different from the one used to encode non-ASCII file names on your
system.)

==============================================================================
File: emacs.info,  Node: |Breakpoints_Buffer|,  Next: |Threads_Buffer|,  Prev: |Source_Buffers|,  Up: |GDB_Graphical_Interface|
==============================================================================

                                                            *Breakpoints_Buffer*

27.6.5.3 Breakpoints Buffer
.....----------------------

The GDB Breakpoints buffer shows the breakpoints, watchpoints and
catchpoints in the debugger session.  *Note (gdb)Breakpoints::.  It
provides the following commands, which mostly apply to the "current
breakpoint" (the breakpoint which point is on):

'<SPC>'
     Enable/disable current breakpoint ('gdb-toggle-breakpoint').  On a
     graphical display, this changes the color of the dot in the fringe
     of the source buffer at that line.  The dot is red when the
     breakpoint is enabled, and gray when it is disabled.

'D'
     Delete the current breakpoint ('gdb-delete-breakpoint').

'<RET>'
     Visit the source line for the current breakpoint
     ('gdb-goto-breakpoint').

'mouse-2'
     Visit the source line for the breakpoint you click on
     ('gdb-goto-breakpoint').

   When 'gdb-many-windows' is non-'nil', the GDB Breakpoints buffer
shares its window with the GDB Threads buffer.  To switch from one to
the other click with 'mouse-1' on the relevant button in the header
line.  If 'gdb-show-threads-by-default' is non-'nil', the GDB Threads
buffer is the one shown by default.

==============================================================================
File: emacs.info,  Node: |Threads_Buffer|,  Next: |Stack_Buffer|,  Prev: |Breakpoints_Buffer|,  Up: |GDB_Graphical_Interface|
==============================================================================

                                                                *Threads_Buffer*

27.6.5.4 Threads Buffer
.....------------------

The GDB Threads buffer displays a summary of the threads in the debugged
program.  *Note Threads: (gdb)Threads.  To select a thread, move point
there and press <RET> ('gdb-select-thread'), or click on it with
'mouse-2'.  This also displays the associated source buffer, and updates
the contents of the other GDB buffers.

   You can customize variables in the 'gdb-buffers' group to select
fields included in GDB Threads buffer.

'gdb-thread-buffer-verbose-names'
     Show long thread names like 'Thread 0x4e2ab70 (LWP 1983)'.

'gdb-thread-buffer-arguments'
     Show arguments of thread top frames.

'gdb-thread-buffer-locations'
     Show file information or library names.

'gdb-thread-buffer-addresses'
     Show addresses for thread frames in threads buffer.

   To view information for several threads simultaneously, use the
following commands from the GDB Threads buffer.

'd'
     Display disassembly buffer for the thread at current line
     ('gdb-display-disassembly-for-thread').

'f'
     Display the GDB Stack buffer for the thread at current line
     ('gdb-display-stack-for-thread').

'l'
     Display the GDB Locals buffer for the thread at current line
     ('gdb-display-locals-for-thread').

'r'
     Display the GDB Registers buffer for the thread at current line
     ('gdb-display-registers-for-thread').

Their upper-case counterparts, 'D', 'F' ,'L' and 'R', display the
corresponding buffer in a new frame.

   When you create a buffer showing information about some specific
thread, it becomes bound to that thread and keeps showing actual
information while you debug your program.  The mode indicator for each
GDB buffer shows the number of the thread whose information that buffer
displays.  The thread number is also included in the name of each bound
buffer.

   Further commands are available in the GDB Threads buffer which depend
on the mode of GDB that is used for controlling execution of your
program.  *Note Multithreaded Debugging::.

==============================================================================
File: emacs.info,  Node: |Stack_Buffer|,  Next: |Other_GDB_Buffers|,  Prev: |Threads_Buffer|,  Up: |GDB_Graphical_Interface|
==============================================================================

                                                                  *Stack_Buffer*

27.6.5.5 Stack Buffer
.....----------------

The GDB Stack buffer displays a "call stack", with one line for each of
the nested subroutine calls ("stack frames") in the debugger session.
*Note Backtraces: (gdb)Backtrace.

   On graphical displays, the selected stack frame is indicated by an
arrow in the fringe.  On text terminals, or when fringes are disabled,
the selected stack frame is displayed in reverse contrast.  To select a
stack frame, move point in its line and type <RET>
('gdb-frames-select'), or click 'mouse-2' on it.  Doing so also updates
the Locals buffer (*note Other GDB Buffers::).

   If you want the frame address to be shown each stack frame, customize
the variable 'gdb-stack-buffer-addresses' to a non-'nil' value.

==============================================================================
File: emacs.info,  Node: |Other_GDB_Buffers|,  Next: |Watch_Expressions|,  Prev: |Stack_Buffer|,  Up: |GDB_Graphical_Interface|
==============================================================================

                                                             *Other_GDB_Buffers*

27.6.5.6 Other GDB Buffers
.....---------------------

Locals Buffer
     This buffer displays the values of local variables of the current
     frame for simple data types (*note Frame Info: (gdb)Frame Info.).
     Press <RET> or click 'mouse-2' on the value if you want to edit it.

     Arrays and structures display their type only.  With GDB 6.4 or
     later, you can examine the value of the local variable at point by
     typing <RET>, or with a 'mouse-2' click.  With earlier versions of
     GDB, use <RET> or 'mouse-2' on the type description
     ('[struct/union]' or '[array]').  *Note Watch Expressions::.

Registers Buffer
     This buffer displays the values held by the registers (*note
     (gdb)Registers::).  Press <RET> or click 'mouse-2' on a register if
     you want to edit its value.  With GDB 6.4 or later, recently
     changed register values display with 'font-lock-warning-face'.

Assembler Buffer
     The assembler buffer displays the current frame as machine code.
     An arrow points to the current instruction, and you can set and
     remove breakpoints as in a source buffer.  Breakpoint icons also
     appear in the fringe or margin.

Memory Buffer
     The memory buffer lets you examine sections of program memory
     (*note Memory: (gdb)Memory.).  Click 'mouse-1' on the appropriate
     part of the header line to change the starting address or number of
     data items that the buffer displays.  Alternatively, use 'S' or 'N'
     respectively.  Click 'mouse-3' on the header line to select the
     display format or unit size for these data items.

   When 'gdb-many-windows' is non-'nil', the locals buffer shares its
window with the registers buffer, just like breakpoints and threads
buffers.  To switch from one to the other, click with 'mouse-1' on the
relevant button in the header line.

==============================================================================
File: emacs.info,  Node: |Watch_Expressions|,  Next: |Multithreaded_Debugging|,  Prev: |Other_GDB_Buffers|,  Up: |GDB_Graphical_Interface|
==============================================================================

                                                             *Watch_Expressions*

27.6.5.7 Watch Expressions
.....---------------------

If you want to see how a variable changes each time your program stops,
move point into the variable name and click on the watch icon in the
tool bar ('gud-watch') or type 'C-x C-a C-w'.  If you specify a prefix
argument, you can enter the variable name in the minibuffer.

   Each watch expression is displayed in the speedbar (*note
Speedbar::).  Complex data types, such as arrays, structures and unions
are represented in a tree format.  Leaves and simple data types show the
name of the expression and its value and, when the speedbar frame is
selected, display the type as a tooltip.  Higher levels show the name,
type and address value for pointers and just the name and type
otherwise.  Root expressions also display the frame address as a tooltip
to help identify the frame in which they were defined.

   To expand or contract a complex data type, click 'mouse-2' or press
<SPC> on the tag to the left of the expression.  Emacs asks for
confirmation before expanding the expression if its number of immediate
children exceeds the value of the variable 'gdb-max-children'.

   To delete a complex watch expression, move point to the root
expression in the speedbar and type 'D' ('gdb-var-delete').

   To edit a variable with a simple data type, or a simple element of a
complex data type, move point there in the speedbar and type <RET>
('gdb-edit-value').  Or you can click 'mouse-2' on a value to edit it.
Either way, this reads the new value using the minibuffer.

   If you set the variable 'gdb-show-changed-values' to non-'nil' (the
default value), Emacs uses 'font-lock-warning-face' to highlight values
that have recently changed and 'shadow' face to make variables which
have gone out of scope less noticeable.  When a variable goes out of
scope you can't edit its value.

   If the variable 'gdb-delete-out-of-scope' is non-'nil' (the default
value), Emacs automatically deletes watch expressions which go out of
scope.  Sometimes, when your program re-enters the same function many
times, it may be useful to set this value to 'nil' so that you don't
need to recreate the watch expression.

   If the variable 'gdb-use-colon-colon-notation' is non-'nil', Emacs
uses the 'FUNCTION::VARIABLE' format.  This allows the user to display
watch expressions which share the same variable name.  The default value
is 'nil'.

   To automatically raise the speedbar every time the display of watch
expressions updates, set 'gdb-speedbar-auto-raise' to non-'nil'.  This
can be useful if you are debugging with a full screen Emacs frame.

==============================================================================
File: emacs.info,  Node: |Multithreaded_Debugging|,  Prev: |Watch_Expressions|,  Up: |GDB_Graphical_Interface|
==============================================================================

                                                       *Multithreaded_Debugging*

27.6.5.8 Multithreaded Debugging
.....---------------------------

In GDB's "all-stop mode", whenever your program stops, all execution
threads stop.  Likewise, whenever you restart the program, all threads
start executing.  *Note All-Stop Mode: (gdb)All-Stop Mode.  For some
multi-threaded targets, GDB supports a further mode of operation, called
"non-stop mode", in which you can examine stopped program threads in the
debugger while other threads continue to execute freely.  *Note Non-Stop
Mode: (gdb)Non-Stop Mode.  Versions of GDB prior to 7.0 do not support
non-stop mode, and it does not work on all targets.

   The variable 'gdb-non-stop-setting' determines whether Emacs runs GDB
in all-stop mode or non-stop mode.  The default is 't', which means it
tries to use non-stop mode if that is available.  If you change the
value to 'nil', or if non-stop mode is unavailable, Emacs runs GDB in
all-stop mode.  The variable takes effect when Emacs begins a debugging
session; if you change its value, you should restart any active
debugging session.

   When a thread stops in non-stop mode, Emacs usually switches to that
thread.  If you don't want Emacs to do this switch if another stopped
thread is already selected, change the variable
'gdb-switch-when-another-stopped' to 'nil'.

   Emacs can decide whether or not to switch to the stopped thread
depending on the reason which caused the stop.  Customize the variable
'gdb-switch-reasons' to select the stop reasons which will cause a
thread switch.

   The variable 'gdb-stopped-functions' allows you to execute your
functions whenever some thread stops.

   In non-stop mode, you can switch between different modes for GUD
execution control commands.

"Non-stop/A"

     When 'gdb-gud-control-all-threads' is 't' (the default value),
     interruption and continuation commands apply to all threads, so you
     can halt or continue all your threads with one command using
     'gud-stop-subjob' and 'gud-cont', respectively.  The 'Go' button is
     shown on the tool bar when at least one thread is stopped, whereas
     'Stop' button is shown when at least one thread is running.

"Non-stop/T"

     When 'gdb-gud-control-all-threads' is 'nil', only the current
     thread is stopped/continued.  'Go' and 'Stop' buttons on the GUD
     tool bar are shown depending on the state of current thread.

   You can change the current value of 'gdb-gud-control-all-threads'
from the tool bar or from 'GUD->GDB-MI' menu.

   Stepping commands always apply to the current thread.

   In non-stop mode, you can interrupt/continue your threads without
selecting them.  Hitting 'i' in threads buffer interrupts thread under
point, 'c' continues it, 's' steps through.  More such commands may be
added in the future.

   Note that when you interrupt a thread, it stops with the 'signal
received' reason.  If that reason is included in your
'gdb-switch-reasons' (it is by default), Emacs will switch to that
thread.

==============================================================================
File: emacs.info,  Node: |Executing_Lisp|,  Next: |Lisp_Libraries|,  Prev: |Debuggers|,  Up: |Building|
==============================================================================

                                                                *Executing_Lisp*

27.7 Executing Lisp Expressions
=====--------------------------

Emacs has major modes for several variants of Lisp.  They use the same
editing commands as other programming language modes (*note Programs::).
In addition, they provide special commands for executing Lisp
expressions.

Emacs Lisp mode
     The mode for editing Emacs Lisp source files.  It defines 'C-M-x'
     to evaluate the current top-level Lisp expression.  *Note Lisp
     Eval::.

Lisp Interaction mode
     The mode for an interactive Emacs Lisp session.  It defines 'C-j'
     to evaluate the expression before point and insert its value in the
     buffer.  *Note Lisp Interaction::.

Lisp mode
     The mode for editing source files of programs that run in Lisps
     other than Emacs Lisp.  It defines 'C-M-x' to evaluate the current
     top-level expression in an external Lisp.  *Note External Lisp::.

Inferior Lisp mode
     The mode for an interactive session with an external Lisp which is
     being run as a subprocess (or "inferior process") of Emacs.  *Note
     External Lisp::.

Scheme mode
     Like Lisp mode, but for Scheme programs.

Inferior Scheme mode
     Like Inferior Lisp mode, but for Scheme.

==============================================================================
File: emacs.info,  Node: |Lisp_Libraries|,  Next: |Lisp_Eval|,  Prev: |Executing_Lisp|,  Up: |Building|
==============================================================================

                                                                *Lisp_Libraries*

27.8 Libraries of Lisp Code for Emacs
=====--------------------------------

Emacs Lisp code is stored in files whose names conventionally end in
'.el'.  Such files are automatically visited in Emacs Lisp mode.

   Emacs Lisp code can be compiled into byte-code, which loads faster,
takes up less space, and executes faster.  By convention, compiled Emacs
Lisp code goes in a separate file whose name ends in '.elc'.  For
example, the compiled code for 'foo.el' goes in 'foo.elc'.  *Note Byte
Compilation: (elisp)Byte Compilation.

   To "load" an Emacs Lisp file, type 'M-x load-file'.  This command
reads a file name using the minibuffer, and executes the contents of
that file as Emacs Lisp code.  It is not necessary to visit the file
first; this command reads the file directly from disk, not from an
existing Emacs buffer.

   If an Emacs Lisp file is installed in the Emacs Lisp "load path"
(defined below), you can load it by typing 'M-x load-library', instead
of using 'M-x load-file'.  The 'M-x load-library' command prompts for a
"library name" rather than a file name; it searches through each
directory in the Emacs Lisp load path, trying to find a file matching
that library name.  If the library name is 'FOO', it tries looking for
files named 'FOO.elc', 'FOO.el', and 'FOO'.  The default behavior is to
load the first file found.  This command prefers '.elc' files over '.el'
files because compiled files load and run faster.  If it finds that
'LIB.el' is newer than 'LIB.elc', it issues a warning, in case someone
made changes to the '.el' file and forgot to recompile it, but loads the
'.elc' file anyway.  (Due to this behavior, you can save unfinished
edits to Emacs Lisp source files, and not recompile until your changes
are ready for use.)  If you set the option 'load-prefer-newer' to a
non-'nil' value, however, then rather than the procedure described
above, Emacs loads whichever version of the file is newest.

   Emacs Lisp programs usually load Emacs Lisp files using the 'load'
function.  This is similar to 'load-library', but is lower-level and
accepts additional arguments.  *Note (elisp)How Programs Do Loading::.

   The Emacs Lisp load path is specified by the variable 'load-path'.
Its value should be a list of directories (strings).  These directories
are searched, in the specified order, by the 'M-x load-library' command,
the lower-level 'load' function, and other Emacs functions that find
Emacs Lisp libraries.  An entry in 'load-path' can also have the special
value 'nil', which stands for the current default directory, but it is
almost always a bad idea to use this, because its meaning will depend on
the buffer that is current when 'load-path' is used by Emacs.  (If you
find yourself wishing that 'nil' were in the list, most likely what you
really want is to use 'M-x load-file'.)

   The default value of 'load-path' is a list of directories where the
Lisp code for Emacs itself is stored.  If you have libraries of your own
in another directory, you can add that directory to the load path.
Unlike most other variables described in this manual, 'load-path' cannot
be changed via the Customize interface (*note Easy Customization::), but
you can add a directory to it by putting a line like this in your init
file (*note Init File::):

     (add-to-list 'load-path "/path/to/my/lisp/library")

   It is customary to put locally installed libraries in the 'site-lisp'
directory that is already in the default value of 'load-path', or in
some subdirectory of 'site-lisp'.  This way, you don't need to modify
the default value of 'load-path'.

   Some commands are "autoloaded"; when you run them, Emacs
automatically loads the associated library first.  For instance, the
'M-x compile' command (*note Compilation::) is autoloaded; if you call
it, Emacs automatically loads the 'compile' library first.  In contrast,
the command 'M-x recompile' is not autoloaded, so it is unavailable
until you load the 'compile' library.

   Automatic loading can also occur when you look up the documentation
of an autoloaded command (*note Name Help::), if the documentation
refers to other functions and variables in its library (loading the
library lets Emacs properly set up the hyperlinks in the 'Help'
buffer).  To disable this feature, change the variable
'help-enable-autoload' to 'nil'.

   Automatic loading also occurs when completing names for
'describe-variable' and 'describe-function', based on the prefix being
completed.  To disable this feature, change the variable
'help-enable-completion-autoload' to 'nil'.

   By default, Emacs refuses to load compiled Lisp files which were
compiled with XEmacs, a modified version of Emacs--they can cause Emacs
to crash.  Set the variable 'load-dangerous-libraries' to 't' if you
want to try loading them.

   Once you put your library in a directory where Emacs can find and
load it, you may wish to make it available at startup.  This is useful
when the library defines features that should be available automatically
on demand, and manually loading the library is thus inconvenient.  In
these cases, make sure the library will be loaded by adding suitable
forms to your init file: either 'load' or 'require' (if you always need
to load the library at startup), or 'autoload' if you need Emacs to load
the library when some command or function is invoked.  For example:

      ;; Loads my-shining-package.elc unconditionally.
      (require 'my-shining-package)
      ;; Will load my-shining-package.elc when my-func is invoked.
      (autoload 'my-func "my-shining-package")

   Note that installing a package using 'package-install' (*note Package
Installation::) takes care of placing the package's Lisp files in a
directory where Emacs will find it, and also writes the necessary
initialization code into your init files, making the above manual
customizations unnecessary.

==============================================================================
File: emacs.info,  Node: |Lisp_Eval|,  Next: |Lisp_Interaction|,  Prev: |Lisp_Libraries|,  Up: |Building|
==============================================================================

                                                                     *Lisp_Eval*

27.9 Evaluating Emacs Lisp Expressions
=====---------------------------------

Emacs Lisp mode is the major mode for editing Emacs Lisp.  Its mode
command is 'M-x emacs-lisp-mode'.

   Emacs provides several commands for evaluating Emacs Lisp
expressions.  You can use these commands in Emacs Lisp mode, to test
your Emacs Lisp code as it is being written.  For example, after
re-writing a function, you can evaluate the function definition to make
it take effect for subsequent function calls.  These commands are also
available globally, and can be used outside Emacs Lisp mode.

'M-:'
     Read a single Emacs Lisp expression in the minibuffer, evaluate it,
     and print the value in the echo area ('eval-expression').
'C-x C-e'
     Evaluate the Emacs Lisp expression before point, and print the
     value in the echo area ('eval-last-sexp').
'C-M-x' (in Emacs Lisp mode)
'M-x eval-defun'
     Evaluate the defun containing or after point, and print the value
     in the echo area ('eval-defun').
'M-x eval-region'
     Evaluate all the Emacs Lisp expressions in the region.
'M-x eval-buffer'
     Evaluate all the Emacs Lisp expressions in the buffer.

   'M-:' ('eval-expression') reads an expression using the minibuffer,
and evaluates it.  (Before evaluating the expression, the current buffer
switches back to the buffer that was current when you typed 'M-:', not
the minibuffer into which you typed the expression.)

   The command 'C-x C-e' ('eval-last-sexp') evaluates the Emacs Lisp
expression preceding point in the buffer, and displays the value in the
echo area.  When the result of an evaluation is an integer, it is
displayed together with the value in other formats (octal, hexadecimal,
and character if 'eval-expression-print-maximum-character', described
below, allows it).

   If 'M-:' or 'C-x C-e' is given a prefix argument, it inserts the
value into the current buffer at point, rather than displaying it in the
echo area.  If the prefix argument is zero, any integer output is
inserted together with its value in other formats (octal, hexadecimal,
and character).  Such a prefix argument also prevents abbreviation of
the output according to the variables 'eval-expression-print-level' and
'eval-expression-print-length' (see below).  Similarly, a prefix
argument of '-1' overrides the effect of 'eval-expression-print-length'.

   The 'eval-defun' command is bound to 'C-M-x' in Emacs Lisp mode.  It
evaluates the top-level Lisp expression containing or following point,
and prints the value in the echo area.  In this context, a top-level
expression is referred to as a "defun", but it need not be an actual
'defun' (function definition).  In particular, this command treats
'defvar' expressions specially.  Normally, evaluating a 'defvar'
expression does nothing if the variable it defines already has a value.
But this command unconditionally resets the variable to the initial
value specified by the 'defvar'; this is convenient for debugging Emacs
Lisp programs.  'defcustom' and 'defface' expressions are treated
similarly.  Note that the other commands documented in this section do
not have this special feature.

   With a prefix argument, 'C-M-x' instruments the function definition
for Edebug, the Emacs Lisp Debugger.  *Note Instrumenting for Edebug:
(elisp)Instrumenting.

   The command 'M-x eval-region' parses the text of the region as one or
more Lisp expressions, evaluating them one by one.  'M-x eval-buffer' is
similar but evaluates the entire buffer.

   The options 'eval-expression-print-level' and
'eval-expression-print-length' control the maximum depth and length of
lists to print in the result of the evaluation commands before
abbreviating them.  Supplying a zero prefix argument to
'eval-expression' or 'eval-last-sexp' causes lists to be printed in
full.  'eval-expression-debug-on-error' controls whether evaluation
errors invoke the debugger when these commands are used; its default is
't'.  'eval-expression-print-maximum-character' prevents integers which
are larger than it from being displayed as characters.

==============================================================================
File: emacs.info,  Node: |Lisp_Interaction|,  Next: |External_Lisp|,  Prev: |Lisp_Eval|,  Up: |Building|
==============================================================================

                                                              *Lisp_Interaction*

27.10 Lisp Interaction Buffers
=====-------------------------

When Emacs starts up, it contains a buffer named 'scratch', which is
provided for evaluating Emacs Lisp expressions interactively.  Its major
mode is Lisp Interaction mode.  You can also enable Lisp Interaction
mode by typing 'M-x lisp-interaction-mode'.

   In the 'scratch' buffer, and other Lisp Interaction mode buffers,
'C-j' ('eval-print-last-sexp') evaluates the Lisp expression before
point, and inserts the value at point.  Thus, as you type expressions
into the buffer followed by 'C-j' after each expression, the buffer
records a transcript of the evaluated expressions and their values.  All
other commands in Lisp Interaction mode are the same as in Emacs Lisp
mode.

   At startup, the 'scratch' buffer contains a short message, in the
form of a Lisp comment, that explains what it is for.  This message is
controlled by the variable 'initial-scratch-message', which should be
either a documentation string, or 'nil' (which means to suppress the
message).

   An alternative way of evaluating Emacs Lisp expressions interactively
is to use Inferior Emacs Lisp mode, which provides an interface rather
like Shell mode (*note Shell Mode::) for evaluating Emacs Lisp
expressions.  Type 'M-x ielm' to create an 'ielm' buffer which uses
this mode.  For more information, see that command's documentation.

==============================================================================
File: emacs.info,  Node: |External_Lisp|,  Prev: |Lisp_Interaction|,  Up: |Building|
==============================================================================

                                                                 *External_Lisp*

27.11 Running an External Lisp
=====-------------------------

Lisp mode is the major mode for editing programs written in
general-purpose Lisp dialects, such as Common Lisp.  Its mode command is
'M-x lisp-mode'.  Emacs uses Lisp mode automatically for files whose
names end in '.l', '.lsp', or '.lisp'.

   You can run an external Lisp session as a subprocess or "inferior
process" of Emacs, and pass expressions to it to be evaluated.  To begin
an external Lisp session, type 'M-x run-lisp'.  This runs the program
named 'lisp', and sets it up so that both input and output go through an
Emacs buffer named 'inferior-lisp'.  To change the name of the Lisp
program run by 'M-x run-lisp', change the variable
'inferior-lisp-program'.

   The major mode for the 'lisp' buffer is Inferior Lisp mode, which
combines the characteristics of Lisp mode and Shell mode (*note Shell
Mode::).  To send input to the Lisp session, go to the end of the
'lisp' buffer and type the input, followed by <RET>.  Terminal output
from the Lisp session is automatically inserted in the buffer.

   When you edit a Lisp program in Lisp mode, you can type 'C-M-x'
('lisp-eval-defun') to send an expression from the Lisp mode buffer to a
Lisp session that you had started with 'M-x run-lisp'.  The expression
sent is the top-level Lisp expression at or following point.  The
resulting value goes as usual into the 'inferior-lisp' buffer.  Note
that the effect of 'C-M-x' in Lisp mode is thus very similar to its
effect in Emacs Lisp mode (*note Lisp Eval::), except that the
expression is sent to a different Lisp environment instead of being
evaluated in Emacs.

   The facilities for editing Scheme code, and for sending expressions
to a Scheme subprocess, are very similar.  Scheme source files are
edited in Scheme mode, which can be explicitly enabled with 'M-x
scheme-mode'.  You can initiate a Scheme session by typing 'M-x
run-scheme' (the buffer for interacting with Scheme is named
'scheme'), and send expressions to it by typing 'C-M-x'.

==============================================================================
File: emacs.info,  Node: |Maintaining|,  Next: |Abbrevs|,  Prev: |Building|,  Up: |Top|
==============================================================================

                                                                   *Maintaining*

28 Maintaining Large Programs
*****========================

This chapter describes Emacs features for maintaining medium- to
large-size programs and packages.  These features include:

   - Unified interface to Support for Version Control Systems (VCS) that
     record the history of changes to source files.

   - Commands for handling programming projects.

   - A specialized mode for maintaining 'ChangeLog' files that provide a
     chronological log of program changes.

   - Xref, a set of commands for displaying definitions of symbols
     (a.k.a. "identifiers") and their references.

   - EDE, the Emacs's own IDE.

   - A mode for merging changes to program sources made on separate
     branches of development.

   If you are maintaining a large Lisp program, then in addition to the
features described here, you may find the Emacs Lisp Regression Testing
(ERT) library useful (*note ERT: (ert)Top.).

MENU

* |Version_Control|::     Using version control systems.
* |Projects|::            Commands for handling source files in a project.
* |Change_Log|::          Maintaining a change history for your program.
* |Xref|::                Find definitions and references of any function,
                          method, struct, macro, ... in your program.
* |EDE|::                 An integrated development environment for Emacs.
* |Emerge|::              A convenient way of merging two versions of a program.

==============================================================================
File: emacs.info,  Node: |Version_Control|,  Next: |Projects|,  Up: |Maintaining|
==============================================================================

                                                               *Version_Control*

28.1 Version Control
=====---------------

A "version control system" is a program that can record multiple
versions of a source file, storing information such as the creation time
of each version, who made it, and a description of what was changed.

   The Emacs version control interface is called "VC".  VC commands work
with several different version control systems; currently, it supports
Bazaar, CVS, Git, Mercurial, Monotone, RCS, SRC, SCCS/CSSC, and
Subversion.  Of these, the GNU project distributes CVS, RCS, and Bazaar.

   VC is enabled automatically whenever you visit a file governed by a
version control system.  To disable VC entirely, set the customizable
variable 'vc-handled-backends' to 'nil' (*note Customizing VC::).

   To update the VC state information for the file visited in the
current buffer, use the command 'vc-refresh-state'.  This command is
useful when you perform version control commands outside Emacs (e.g.,
from the shell prompt), or if you put the buffer's file under a
different version control system, or remove it from version control
entirely.

MENU

* |Introduction_to_VC|::  How version control works in general.
* |VC_Mode_Line|::        How the mode line shows version control status.
* |Basic_VC_Editing|::    How to edit a file under version control.
* |Log_Buffer|::          Features available in log entry buffers.
* |Registering|::         Putting a file under version control.
* |Old_Revisions|::       Examining and comparing old versions.
* |VC_Change_Log|::       Viewing the VC Change Log.
* |VC_Undo|::             Canceling changes before or after committing.
* |VC_Ignore|::           Ignore files under version control system.
* |VC_Directory_Mode|::   Listing files managed by version control.
* |Branches|::            Multiple lines of development.
* |Miscellaneous_VC|::    Various other commands and features of VC.
* |Customizing_VC|::      Variables that change VC's behavior.

==============================================================================
File: emacs.info,  Node: |Introduction_to_VC|,  Next: |VC_Mode_Line|,  Up: Version Control
==============================================================================

                                                            *Introduction_to_VC*

28.1.1 Introduction to Version Control
--------------------------------------

VC allows you to use a version control system from within Emacs,
integrating the version control operations smoothly with editing.  It
provides a uniform interface for common operations in many version
control operations.

   Some uncommon or intricate version control operations, such as
altering repository settings, are not supported in VC.  You should
perform such tasks outside VC, e.g., via the command line.

   This section provides a general overview of version control, and
describes the version control systems that VC supports.  You can skip
this section if you are already familiar with the version control system
you want to use.

MENU

* |Why_Version_Control?|::    Understanding the problems it addresses.
* |Version_Control_Systems|:: Supported version control back-end systems.
* |VCS_Concepts|::            Words and concepts related to version control.
* |VCS_Merging|::             How file conflicts are handled.
* |VCS_Changesets|::          How changes are grouped.
* |VCS_Repositories|::        Where version control repositories are stored.
* |Types_of_Log_File|::       The VCS log in contrast to the ChangeLog.

==============================================================================
File: emacs.info,  Node: |Why_Version_Control?|,  Next: |Version_Control_Systems|,  Up: Introduction to VC
==============================================================================

                                                          *Why_Version_Control?*

28.1.1.1 Understanding the Problems it Addresses
.....-------------------------------------------

Version control systems provide you with three important capabilities:

   * "Reversibility": the ability to back up to a previous state if you
     discover that some modification you did was a mistake or a bad
     idea.

   * "Concurrency": the ability to have many people modifying the same
     collection of files knowing that conflicting modifications can be
     detected and resolved.

   * "History": the ability to attach historical data to your data, such
     as explanatory comments about the intention behind each change.
     Even for a programmer working solo, change histories are an
     important aid to memory; for a multi-person project, they are a
     vitally important form of communication among developers.

==============================================================================
File: emacs.info,  Node: |Version_Control_Systems|,  Next: |VCS_Concepts|,  Prev: |Why_Version_Control?|,  Up: |Introduction_to_VC|
==============================================================================

                                                       *Version_Control_Systems*

28.1.1.2 Supported Version Control Systems
.....-------------------------------------

VC currently works with many different version control systems, which it
refers to as "back ends":

   * SCCS was the first version control system ever built, and was long
     ago superseded by more advanced ones.  VC compensates for certain
     features missing in SCCS (e.g., tag names for releases) by
     implementing them itself.  Other VC features, such as multiple
     branches, are simply unavailable.  Since SCCS is non-free, we
     recommend avoiding it.

   * CSSC is a free replacement for SCCS.  You should use CSSC only if,
     for some reason, you cannot use a more recent and better-designed
     version control system.

   * RCS is the free version control system around which VC was
     initially built.  It is relatively primitive: it cannot be used
     over the network, and works at the level of individual files.
     Almost everything you can do with RCS can be done through VC.

   * CVS is the free version control system that was, until circa 2008,
     used by the majority of free software projects.  Since then, it has
     been superseded by newer systems.  CVS allows concurrent multi-user
     development either locally or over the network.  Unlike newer
     systems, it lacks support for atomic commits and file
     moving/renaming.  VC supports all basic editing operations under
     CVS.

   * Subversion (svn) is a free version control system designed to be
     similar to CVS but without its problems (e.g., it supports atomic
     commits of filesets, and versioning of directories, symbolic links,
     meta-data, renames, copies, and deletes).

   * Git is a decentralized version control system originally invented
     by Linus Torvalds to support development of Linux (his kernel).  VC
     supports many common Git operations, but others, such as repository
     syncing, must be done from the command line.

   * Mercurial (hg) is a decentralized version control system broadly
     resembling Git.  VC supports most Mercurial commands, with the
     exception of repository sync operations.

   * Bazaar (bzr) is a decentralized version control system that
     supports both repository-based and decentralized versioning.  VC
     supports most basic editing operations under Bazaar.

   * SRC (src) is RCS, reloaded--a specialized version-control system
     designed for single-file projects worked on by only one person.  It
     allows multiple files with independent version-control histories to
     exist in one directory, and is thus particularly well suited for
     maintaining small documents, scripts, and dotfiles.  While it uses
     RCS for revision storage, it presents a modern user interface
     featuring lockless operation and integer sequential version
     numbers.  VC supports almost all SRC operations.

==============================================================================
File: emacs.info,  Node: |VCS_Concepts|,  Next: |VCS_Merging|,  Prev: |Version_Control_Systems|,  Up: |Introduction_to_VC|
==============================================================================

                                                                  *VCS_Concepts*

28.1.1.3 Concepts of Version Control
.....-------------------------------

When a file is under version control, we say that it is "registered" in
the version control system.  The system has a "repository" which stores
both the file's present state and its change history--enough to
reconstruct the current version or any earlier version.  The repository
also contains other information, such as "log entries" that describe the
changes made to each file.

   The copy of a version-controlled file that you actually edit is
called the "work file".  You can change each work file as you would an
ordinary file.  After you are done with a set of changes, you may
"commit" (or "check in") the changes; this records the changes in the
repository, along with a descriptive log entry.

   A directory tree of work files is called a "working tree".

   Each commit creates a new "revision" in the repository.  The version
control system keeps track of all past revisions and the changes that
were made in each revision.  Each revision is named by a "revision ID",
whose format depends on the version control system; in the simplest
case, it is just an integer.

   To go beyond these basic concepts, you will need to understand three
aspects in which version control systems differ.  As explained in the
next three sections, they can be lock-based or merge-based; file-based
or changeset-based; and centralized or decentralized.  VC handles all
these modes of operation, but it cannot hide the differences.

==============================================================================
File: emacs.info,  Node: |VCS_Merging|,  Next: |VCS_Changesets|,  Prev: |VCS_Concepts|,  Up: |Introduction_to_VC|
==============================================================================

                                                                   *VCS_Merging*

28.1.1.4 Merge-based vs Lock-based Version Control
.....---------------------------------------------

A version control system typically has some mechanism to coordinate
between users who want to change the same file.  There are two ways to
do this: merging and locking.

   In a version control system that uses merging, each user may modify a
work file at any time.  The system lets you "merge" your work file,
which may contain changes that have not been committed, with the latest
changes that others have committed.

   Older version control systems use a "locking" scheme instead.  Here,
work files are normally read-only.  To edit a file, you ask the version
control system to make it writable for you by "locking" it; only one
user can lock a given file at any given time.  This procedure is
analogous to, but different from, the locking that Emacs uses to detect
simultaneous editing of ordinary files (*note Interlocking::).  When you
commit your changes, that unlocks the file, and the work file becomes
read-only again.  Other users may then lock the file to make their own
changes.

   Both locking and merging systems can have problems when multiple
users try to modify the same file at the same time.  Locking systems
have "lock conflicts"; a user may try to check a file out and be unable
to because it is locked.  In merging systems, "merge conflicts" happen
when you commit a change to a file that conflicts with a change
committed by someone else after your checkout.  Both kinds of conflict
have to be resolved by human judgment and communication.  Experience has
shown that merging is superior to locking, both in convenience to
developers and in minimizing the number and severity of conflicts that
actually occur.

   SCCS always uses locking.  RCS is lock-based by default but can be
told to operate in a merging style.  CVS and Subversion are merge-based
by default but can be told to operate in a locking mode.  Decentralized
version control systems, such as Git and Mercurial, are exclusively
merging-based.

   VC mode supports both locking and merging version control.  The terms
"commit" and "update" are used in newer version control systems; older
lock-based systems use the terms "check in" and "check out".  VC hides
the differences between them as much as possible.

==============================================================================
File: emacs.info,  Node: |VCS_Changesets|,  Next: |VCS_Repositories|,  Prev: |VCS_Merging|,  Up: |Introduction_to_VC|
==============================================================================

                                                                *VCS_Changesets*

28.1.1.5 Changeset-based vs File-based Version Control
.....-------------------------------------------------

On SCCS, RCS, CVS, and other early version control systems (and also in
SRC), version control operations are "file-based": each file has its own
comment and revision history separate from that of all other files.
Newer systems, beginning with Subversion, are "changeset-based": a
commit may include changes to several files, and the entire set of
changes is handled as a unit.  Any comment associated with the change
does not belong to a single file, but to the changeset itself.

   Changeset-based version control is more flexible and powerful than
file-based version control; usually, when a change to multiple files has
to be reversed, it's good to be able to easily identify and remove all
of it.

==============================================================================
File: emacs.info,  Node: |VCS_Repositories|,  Next: |Types_of_Log_File|,  Prev: |VCS_Changesets|,  Up: |Introduction_to_VC|
==============================================================================

                                                              *VCS_Repositories*

28.1.1.6 Decentralized vs Centralized Repositories
.....---------------------------------------------

Early version control systems were designed around a "centralized" model
in which each project has only one repository used by all developers.
SCCS, RCS, CVS, Subversion, and SRC share this kind of model.  One of
its drawbacks is that the repository is a choke point for reliability
and efficiency.

   GNU Arch pioneered the concept of "distributed" or "decentralized"
version control, later implemented in Git, Mercurial, and Bazaar.  A
project may have several different repositories, and these systems
support a sort of super-merge between repositories that tries to
reconcile their change histories.  In effect, there is one repository
for each developer, and repository merges take the place of commit
operations.

   VC helps you manage the traffic between your personal workfiles and a
repository.  Whether the repository is a single master, or one of a
network of peer repositories, is not something VC has to care about.

==============================================================================
File: emacs.info,  Node: |Types_of_Log_File|,  Prev: |VCS_Repositories|,  Up: |Introduction_to_VC|
==============================================================================

                                                             *Types_of_Log_File*

28.1.1.7 Types of Log File
.....---------------------

Projects that use a version control system can have two types of log for
changes.  One is the log maintained by the version control system: each
time you commit a change, you fill out a "log entry" for the change
(*note Log Buffer::).  This is called the "version control log".

   The other kind of log is the file 'ChangeLog' (*note Change Log::).
It provides a chronological record of all changes to a large portion of
a program--typically one directory and its subdirectories.  A small
program would use one 'ChangeLog' file; a large program may have a
'ChangeLog' file in each major directory.  *Note Change Log::.
Programmers have used change logs since long before version control
systems.

   Changeset-based version systems typically maintain a changeset-based
modification log for the entire system, which makes change log files
somewhat redundant.  One advantage that they retain is that it is
sometimes useful to be able to view the transaction history of a single
directory separately from those of other directories.  Another advantage
is that commit logs can't be fixed in many version control systems.

   A project maintained with version control can use just the version
control log, or it can use both kinds of logs.  It can handle some files
one way and some files the other way.  Each project has its policy,
which you should follow.

   When the policy is to use both, you typically want to write an entry
for each change just once, then put it into both logs.  You can write
the entry in 'ChangeLog', then copy it to the log buffer with 'C-c C-a'
when committing the change (*note Log Buffer::).  Or you can write the
entry in the log buffer while committing the change (with the help of
'C-c C-w'), and later use the 'C-x v a' command to copy it to
'ChangeLog' (*note Change Logs and VC::).

==============================================================================
File: emacs.info,  Node: |VC_Mode_Line|,  Next: |Basic_VC_Editing|,  Prev: |Introduction_to_VC|,  Up: |Version_Control|
==============================================================================

                                                                  *VC_Mode_Line*

28.1.2 Version Control and the Mode Line
----------------------------------------

When you visit a file that is under version control, Emacs indicates
this on the mode line.  For example, 'Bzr-1223' says that Bazaar is used
for that file, and the current revision ID is 1223.

   The character between the back-end name and the revision ID indicates
the "version control status" of the work file.  In a merge-based version
control system, a '-' character indicates that the work file is
unmodified, and ':' indicates that it has been modified.  '!' indicates
that the file contains conflicts as result of a recent merge operation
(*note Merging::), or that the file was removed from the version
control.  Finally, '?' means that the file is under version control, but
is missing from the working tree.

   In a lock-based system, '-' indicates an unlocked file, and ':' a
locked file; if the file is locked by another user (for instance,
'jim'), that is displayed as 'RCS:jim:1.3'.  '@' means that the file was
locally added, but not yet committed to the master repository.

   On a graphical display, you can move the mouse over this mode line
indicator to pop up a tool-tip, which displays a more verbose
description of the version control status.  Pressing 'mouse-1' over the
indicator pops up a menu of VC commands, identical to 'Tools / Version
Control' on the menu bar.

   When Auto Revert mode (*note Reverting::) reverts a buffer that is
under version control, it updates the version control information in the
mode line.  However, Auto Revert mode may not properly update this
information if the version control status changes without changes to the
work file, from outside the current Emacs session.  If you set
'auto-revert-check-vc-info' to 't', Auto Revert mode updates the version
control status information every 'auto-revert-interval' seconds, even if
the work file itself is unchanged.  The resulting CPU usage depends on
the version control system, but is usually not excessive.

==============================================================================
File: emacs.info,  Node: |Basic_VC_Editing|,  Next: |Log_Buffer|,  Prev: |VC_Mode_Line|,  Up: |Version_Control|
==============================================================================

                                                              *Basic_VC_Editing*

28.1.3 Basic Editing under Version Control
------------------------------------------

Most VC commands operate on "VC filesets".  A VC fileset is a collection
of one or more files that a VC operation acts on.  When you type VC
commands in a buffer visiting a version-controlled file, the VC fileset
is simply that one file.  When you type them in a VC Directory buffer,
and some files in it are marked, the VC fileset consists of the marked
files (*note VC Directory Mode::).

   On modern changeset-based version control systems (*note VCS
Changesets::), VC commands handle multi-file VC filesets as a group.
For example, committing a multi-file VC fileset generates a single
revision, containing the changes to all those files.  On older
file-based version control systems like CVS, each file in a multi-file
VC fileset is handled individually; for example, a commit generates one
revision for each changed file.

'C-x v v'
     Perform the next appropriate version control operation on the
     current VC fileset.

   The principal VC command is a multi-purpose command, 'C-x v v'
('vc-next-action'), which performs the most appropriate action on the
current VC fileset: either registering it with a version control system,
or committing it, or unlocking it, or merging changes into it.  The
precise actions are described in detail in the following subsections.
You can use 'C-x v v' either in a file-visiting buffer or in a VC
Directory buffer.

   Note that VC filesets are distinct from the named filesets used for
viewing and visiting files in functional groups (*note Filesets::).
Unlike named filesets, VC filesets are not named and don't persist
across sessions.

MENU

* |VC_With_A_Merging_VCS|::  Without locking: default mode for CVS.
* |VC_With_A_Locking_VCS|::  RCS in its default mode, SCCS, and optionally CVS.
* |Advanced_C_x_v_v|::       Advanced features available with a prefix argument.

==============================================================================
File: emacs.info,  Node: |VC_With_A_Merging_VCS|,  Next: |VC_With_A_Locking_VCS|,  Up: |Basic_VC_Editing|
==============================================================================

                                                         *VC_With_A_Merging_VCS*

28.1.3.1 Basic Version Control with Merging
.....--------------------------------------

On a merging-based version control system (i.e., most modern ones; *note
VCS Merging::), 'C-x v v' does the following:

   * If there is more than one file in the VC fileset and the files have
     inconsistent version control statuses, signal an error.  (Note,
     however, that a fileset is allowed to include both newly-added
     files and modified files; *note Registering::.)

   * If none of the files in the VC fileset are registered with a
     version control system, register the VC fileset, i.e., place it
     under version control.  *Note Registering::.  If Emacs cannot find
     a system to register under, it prompts for a repository type,
     creates a new repository, and registers the VC fileset with it.

   * If every work file in the VC fileset is unchanged, do nothing.

   * If every work file in the VC fileset has been modified, commit the
     changes.  To do this, Emacs pops up a 'vc-log' buffer; type the
     desired log entry for the new revision, followed by 'C-c C-c' to
     commit.  *Note Log Buffer::.

     If committing to a shared repository, the commit may fail if the
     repository has been changed since your last update.  In that case,
     you must perform an update before trying again.  On a decentralized
     version control system, use 'C-x v +' (*note Pulling / Pushing::)
     or 'C-x v m' (*note Merging::).  On a centralized version control
     system, type 'C-x v v' again to merge in the repository changes.

   * Finally, if you are using a centralized version control system,
     check if each work file in the VC fileset is up-to-date.  If any
     file has been changed in the repository, offer to update it.

   These rules also apply when you use RCS in its non-locking mode,
except that changes are not automatically merged from the repository.
Nothing informs you if another user has committed changes in the same
file since you began editing it; when you commit your revision, that
other user's changes are removed (however, they remain in the repository
and are thus not irrevocably lost).  Therefore, you must verify that the
current revision is unchanged before committing your changes.  In
addition, locking is possible with RCS even in this mode: 'C-x v v' with
an unmodified file locks the file, just as it does with RCS in its
normal locking mode (*note VC With A Locking VCS::).

==============================================================================
File: emacs.info,  Node: |VC_With_A_Locking_VCS|,  Next: |Advanced_C_x_v_v|,  Prev: |VC_With_A_Merging_VCS|,  Up: |Basic_VC_Editing|
==============================================================================

                                                         *VC_With_A_Locking_VCS*

28.1.3.2 Basic Version Control with Locking
.....--------------------------------------

On a locking-based version control system (such as SCCS, and RCS in its
default mode), 'C-x v v' does the following:

   * If there is more than one file in the VC fileset and the files have
     inconsistent version control statuses, signal an error.

   * If each file in the VC fileset is not registered with a version
     control system, register the VC fileset.  *Note Registering::.  If
     Emacs cannot find a system to register under, it prompts for a
     repository type, creates a new repository, and registers the VC
     fileset with it.

   * If each file is registered and unlocked, lock it and make it
     writable, so that you can begin to edit it.

   * If each file is locked by you and contains changes, commit the
     changes.  To do this, Emacs pops up a 'vc-log' buffer; type the
     desired log entry for the new revision, followed by 'C-c C-c' to
     commit (*note Log Buffer::).

   * If each file is locked by you, but you have not changed it, release
     the lock and make the file read-only again.

   * If each file is locked by another user, ask whether you want to
     steal the lock.  If you say yes, the file becomes locked by you,
     and a warning message is sent to the user who had formerly locked
     the file.

   These rules also apply when you use CVS in locking mode, except that
CVS does not support stealing locks.

==============================================================================
File: emacs.info,  Node: |Advanced_C_x_v_v|,  Prev: |VC_With_A_Locking_VCS|,  Up: |Basic_VC_Editing|
==============================================================================

                                                              *Advanced_C_x_v_v*

28.1.3.3 Advanced Control in 'C-x v v'
.....---------------------------------

When you give a prefix argument to 'vc-next-action' ('C-u C-x v v'), it
still performs the next logical version control operation, but accepts
additional arguments to specify precisely how to do the operation.

   * You can specify the name of a version control system.  This is
     useful if the fileset can be managed by more than one version
     control system, and Emacs fails to detect the correct one.

   * Otherwise, if using CVS, RCS or SRC, you can specify a revision ID.

     If the fileset is modified (or locked), this makes Emacs commit
     with that revision ID.  You can create a new branch by supplying an
     appropriate revision ID (*note Branches::).

     If the fileset is unmodified (and unlocked), this checks the
     specified revision into the working tree.  You can also specify a
     revision on another branch by giving its revision or branch ID
     (*note Switching Branches::).  An empty argument (i.e., 'C-u C-x v
     v <RET>') checks out the latest (head) revision on the current
     branch.

     This is silently ignored on a decentralized version control system.
     Those systems do not let you specify your own revision IDs, nor do
     they use the concept of checking out individual files.

==============================================================================
File: emacs.info,  Node: |Log_Buffer|,  Next: |Registering|,  Prev: |Basic_VC_Editing|,  Up: |Version_Control|
==============================================================================

                                                                    *Log_Buffer*

28.1.4 Features of the Log Entry Buffer
---------------------------------------

When you tell VC to commit a change, it pops up a buffer named
'vc-log'.  In this buffer, you should write a "log entry" describing
the changes you have made (*note Why Version Control?::).  After you are
done, type 'C-c C-c' ('log-edit-done') to exit the buffer and commit the
change, together with your log entry.

   The major mode for the 'vc-log' buffer is Log Edit mode, a variant
of Text mode (*note Text Mode::).  On entering Log Edit mode, Emacs runs
the hooks 'text-mode-hook' and 'vc-log-mode-hook' (*note Hooks::).

   In the 'vc-log' buffer, you can write one or more "header lines",
specifying additional information to be supplied to the version control
system.  Each header line must occupy a single line at the top of the
buffer; the first line that is not a header line is treated as the start
of the log entry.  For example, the following header line states that
the present change was not written by you, but by another developer:

     Author: J. R. Hacker <jrh@example.com>

Apart from the 'Author' header, Emacs recognizes the headers 'Summary'
(a one-line summary of the changeset), 'Date' (a manually-specified
commit time), and 'Fixes' (a reference to a bug fixed by the change).
Not all version control systems recognize all headers.  If you specify a
header for a system that does not support it, the header is treated as
part of the log entry.

   While in the 'vc-log' buffer, the current VC fileset is considered
to be the fileset that will be committed if you type 'C-c C-c'.  To view
a list of the files in the VC fileset, type 'C-c C-f'
('log-edit-show-files').  To view a diff of changes between the VC
fileset and the version from which you started editing (*note Old
Revisions::), type 'C-c C-d' ('log-edit-show-diff').

   To help generate ChangeLog entries, type 'C-c C-w'
('log-edit-generate-changelog-from-diff'), to generate skeleton
ChangeLog entries, listing all changed file and function names based on
the diff of the VC fileset.  Consecutive entries left empty will be
combined by 'C-q' ('fill-paragraph').

   If the VC fileset includes one or more 'ChangeLog' files (*note
Change Log::), type 'C-c C-a' ('log-edit-insert-changelog') to pull the
relevant entries into the 'vc-log' buffer.  If the topmost item in
each 'ChangeLog' was made under your user name on the current date, this
command searches that item for entries matching the file(s) to be
committed, and inserts them.  If you are using CVS or RCS, see *note
Change Logs and VC::, for the opposite way of working--generating
ChangeLog entries from the Log Edit buffer.

   To abort a commit, just _don't_ type 'C-c C-c' in that buffer.  You
can switch buffers and do other editing.  As long as you don't try to
make another commit, the entry you were editing remains in the
'vc-log' buffer, and you can go back to that buffer at any time to
complete the commit.

   You can also browse the history of previous log entries to duplicate
a commit comment.  This can be useful when you want to make several
commits with similar comments.  The commands 'M-n', 'M-p', 'M-s' and
'M-r' for doing this work just like the minibuffer history commands
(*note Minibuffer History::), except that they are used outside the
minibuffer.

==============================================================================
File: emacs.info,  Node: |Registering|,  Next: |Old_Revisions|,  Prev: |Log_Buffer|,  Up: |Version_Control|
==============================================================================

                                                                   *Registering*

28.1.5 Registering a File for Version Control
---------------------------------------------

'C-x v i'
     Register the visited file for version control.

   The command 'C-x v i' ('vc-register') "registers" each file in the
current VC fileset, placing it under version control.  This is
essentially equivalent to the action of 'C-x v v' on an unregistered VC
fileset (*note Basic VC Editing::), except that if the VC fileset is
already registered, 'C-x v i' signals an error whereas 'C-x v v'
performs some other action.

   To register a file, Emacs must choose a version control system.  For
a multi-file VC fileset, the VC Directory buffer specifies the system to
use (*note VC Directory Mode::).  For a single-file VC fileset, if the
file's directory already contains files registered in a version control
system, or if the directory is part of a directory tree controlled by a
version control system, Emacs chooses that system.  In the event that
more than one version control system is applicable, Emacs uses the one
that appears first in the variable 'vc-handled-backends' (*note
Customizing VC::).  If Emacs cannot find a version control system to
register the file under, it prompts for a repository type, creates a new
repository, and registers the file into that repository.

   On most version control systems, registering a file with 'C-x v i' or
'C-x v v' adds it to the working tree but not to the repository.  Such
files are labeled as 'added' in the VC Directory buffer, and show a
revision ID of '@@' in the mode line.  To make the registration take
effect in the repository, you must perform a commit (*note Basic VC
Editing::).  Note that a single commit can include both file additions
and edits to existing files.

   On a locking-based version control system (*note VCS Merging::),
registering a file leaves it unlocked and read-only.  Type 'C-x v v' to
start editing it.

==============================================================================
File: emacs.info,  Node: |Old_Revisions|,  Next: |VC_Change_Log|,  Prev: |Registering|,  Up: |Version_Control|
==============================================================================

                                                                 *Old_Revisions*

28.1.6 Examining And Comparing Old Revisions
--------------------------------------------

'C-x v ='
     Compare the work files in the current VC fileset with the versions
     you started from ('vc-diff').  With a prefix argument, prompt for
     two revisions of the current VC fileset and compare them.  You can
     also call this command from a Dired buffer (*note Dired::).

'M-x vc-ediff'
     Like 'C-x v =', but using Ediff.  *Note Ediff: (ediff)Top.

'C-x v D'
     Compare the entire working tree to the revision you started from
     ('vc-root-diff').  With a prefix argument, prompt for two revisions
     and compare their trees.

'C-x v ~'
     Prompt for a revision of the current file, and visit it in a
     separate buffer ('vc-revision-other-window').

'C-x v g'
     Display an annotated version of the current file: for each line,
     show the latest revision in which it was modified ('vc-annotate').

   'C-x v =' ('vc-diff') displays a "diff" which compares each work file
in the current VC fileset to the version(s) from which you started
editing.  The diff is displayed in another window, in a Diff mode buffer
(note Diff Mode::) named 'vc-diff*'.  The usual Diff mode commands are
available in this buffer.  In particular, the 'g' ('revert-buffer')
command performs the file comparison again, generating a new diff.

   To compare two arbitrary revisions of the current VC fileset, call
'vc-diff' with a prefix argument: 'C-u C-x v ='.  This prompts for two
revision IDs (*note VCS Concepts::), and displays a diff between those
versions of the fileset.  This will not work reliably for multi-file VC
filesets, if the version control system is file-based rather than
changeset-based (e.g., CVS), since then revision IDs for different files
would not be related in any meaningful way.

   Instead of the revision ID, some version control systems let you
specify revisions in other formats.  For instance, under Bazaar you can
enter 'date:yesterday' for the argument to 'C-u C-x v =' (and related
commands) to specify the first revision committed after yesterday.  See
the documentation of the version control system for details.

   If you invoke 'C-x v =' or 'C-u C-x v =' from a Dired buffer (*note
Dired::), the file listed on the current line is treated as the current
VC fileset.

   'M-x vc-ediff' works like 'C-x v =', except that it uses an Ediff
session.  *Note Ediff: (ediff)Top.

   'C-x v D' ('vc-root-diff') is similar to 'C-x v =', but it displays
the changes in the entire current working tree (i.e., the working tree
containing the current VC fileset).  If you invoke this command from a
Dired buffer, it applies to the working tree containing the directory.

   To compare two arbitrary revisions of the whole trees, call
'vc-root-diff' with a prefix argument: 'C-u C-x v D'.  This prompts for
two revision IDs (*note VCS Concepts::), and displays a diff between
those versions of the entire version-controlled directory trees (RCS,
SCCS, CVS, and SRC do not support this feature).

   You can customize the 'diff' options that 'C-x v =' and 'C-x v D' use
for generating diffs.  The options used are taken from the first
non-'nil' value amongst the variables 'vc-BACKEND-diff-switches',
'vc-diff-switches', and 'diff-switches' (*note Comparing Files::), in
that order.  Here, BACKEND stands for the relevant version control
system, e.g., 'bzr' for Bazaar.  Since 'nil' means to check the next
variable in the sequence, either of the first two may use the value 't'
to mean no switches at all.  Most of the 'vc-BACKEND-diff-switches'
variables default to 'nil', but some default to 't'; these are for
version control systems whose 'diff' implementations do not accept
common diff options, such as Subversion.

   To directly examine an older version of a file, visit the work file
and type 'C-x v ~ REVISION <RET>' ('vc-revision-other-window').  This
retrieves the file version corresponding to REVISION, saves it to
'FILENAME.~REVISION~', and visits it in a separate window.

   Many version control systems allow you to view files "annotated" with
per-line revision information, by typing 'C-x v g' ('vc-annotate').
This creates a new "annotate" buffer displaying the file's text, with
each line colored to show how old it is.  Red text is new, blue is old,
and intermediate colors indicate intermediate ages.  By default, the
color is scaled over the full range of ages, such that the oldest
changes are blue, and the newest changes are red.  If the variable
'vc-annotate-background-mode' is non-'nil', the colors expressing the
age of each line are applied to the background color, leaving the
foreground at its default color.

   When you give a prefix argument to this command, Emacs reads two
arguments using the minibuffer: the revision to display and annotate
(instead of the current file contents), and the time span in days the
color range should cover.

   From the "annotate" buffer, these and other color scaling options are
available from the 'VC-Annotate' menu.  In this buffer, you can also use
the following keys to browse the annotations of past revisions, view
diffs, or view log entries:

'p'
     Annotate the previous revision, i.e., the revision before the one
     currently annotated.  A numeric prefix argument is a repeat count,
     so 'C-u 10 p' would take you back 10 revisions.

'n'
     Annotate the next revision, i.e., the revision after the one
     currently annotated.  A numeric prefix argument is a repeat count.

'j'
     Annotate the revision indicated by the current line.

'a'
     Annotate the revision before the one indicated by the current line.
     This is useful to see the state the file was in before the change
     on the current line was made.

'f'
     Show in a buffer the file revision indicated by the current line.

'd'
     Display the diff between the current line's revision and the
     previous revision.  This is useful to see what the current line's
     revision actually changed in the file.

'D'
     Display the diff between the current line's revision and the
     previous revision for all files in the changeset (for VC systems
     that support changesets).  This is useful to see what the current
     line's revision actually changed in the tree.

'l'
     Show the log of the current line's revision.  This is useful to see
     the author's description of the changes in the revision on the
     current line.

'w'
     Annotate the working revision-the one you are editing.  If you used
     'p' and 'n' to browse to other revisions, use this key to return to
     your working revision.

'v'
     Toggle the annotation visibility.  This is useful for looking just
     at the file contents without distraction from the annotations.

==============================================================================
File: emacs.info,  Node: |VC_Change_Log|,  Next: |VC_Undo|,  Prev: |Old_Revisions|,  Up: |Version_Control|
==============================================================================

                                                                 *VC_Change_Log*

28.1.7 VC Change Log
--------------------

'C-x v l'
     Display the change history for the current fileset
     ('vc-print-log').

'C-x v L'
     Display the change history for the current repository
     ('vc-print-root-log').

'C-x v I'
     Display the changes that a "pull" operation will retrieve
     ('vc-log-incoming').

'C-x v O'
     Display the changes that will be sent by the next "push" operation
     ('vc-log-outgoing').

'C-x v h'
     Display the history of changes made in the region of file visited
     by the current buffer ('vc-region-history').

'M-x vc-log-search <RET>'
     Search the change history for a specified pattern.

   'C-x v l' ('vc-print-log') displays a buffer named 'vc-change-log',
showing the history of changes made to the current file, including who
made the changes, the dates, and the log entry for each change (these
are the same log entries you would enter via the 'vc-log' buffer;
*note Log Buffer::).  Point is centered at the revision of the file
currently being visited.  With a prefix argument, the command prompts
for the revision to center on, and the maximum number of revisions to
display.

   If you call 'C-x v l' from a VC Directory buffer (*note VC Directory
Mode::) or a Dired buffer (*note Dired::), it applies to the file listed
on the current line.

   'C-x v L' ('vc-print-root-log') displays a 'vc-change-log' buffer
showing the history of the entire version-controlled directory tree
(RCS, SCCS, CVS, and SRC do not support this feature).  With a prefix
argument, the command prompts for the maximum number of revisions to
display.  A numeric prefix argument specifies the maximum number of
revisions without prompting.  When the numeric prefix argument is 1, as
in 'C-1 C-x v L' or 'C-u 1 C-x v L', the command prompts for the
revision ID, and displays the log entry of that revision together with
the changes (diffs) it introduced.  (Some less capable version control
systems, such as RCS and CVS, don't have commands to show a revision log
with its diffs; for them the command displays only the log entry, and
you can request to show the diffs by typing 'd' or 'D', see below.)

   The 'C-x v L' history is shown in a compact form, usually showing
only the first line of each log entry.  However, you can type <RET>
('log-view-toggle-entry-display') in the 'vc-change-log' buffer to
reveal the entire log entry for the revision at point.  A second <RET>
hides it again.

   On a decentralized version control system, the 'C-x v I'
('vc-log-incoming') command displays a log buffer showing the changes
that will be applied, the next time you run the version control system's
pull command to get new revisions from another repository (*note Pulling
/ Pushing::).  This other repository is the default one from which
changes are pulled, as defined by the version control system; with a
prefix argument, 'vc-log-incoming' prompts for a specific repository.
Similarly, 'C-x v O' ('vc-log-outgoing') shows the changes that will be
sent to another repository, the next time you run the push command; with
a prefix argument, it prompts for a specific destination repository.

   In the 'vc-change-log' buffer, you can use the following keys to
move between the logs of revisions and of files, and to examine and
compare past revisions (*note Old Revisions::):

'p'
     Move to the previous revision entry.  (Revision entries in the log
     buffer are usually in reverse-chronological order, so the previous
     revision-item usually corresponds to a newer revision.)  A numeric
     prefix argument is a repeat count.

'n'
     Move to the next revision entry.  A numeric prefix argument is a
     repeat count.

'P'
     Move to the log of the previous file, if showing logs for a
     multi-file VC fileset.  Otherwise, just move to the beginning of
     the log.  A numeric prefix argument is a repeat count.

'N'
     Move to the log of the next file, if showing logs for a multi-file
     VC fileset.  A numeric prefix argument is a repeat count.

'a'
     Annotate the revision on the current line (*note Old Revisions::).

'e'
     Modify the change comment displayed at point.  Note that not all VC
     systems support modifying change comments.

'f'
     Visit the revision indicated at the current line.

'd'
     Display a diff between the revision at point and the next earlier
     revision, for the specific file.

'D'
     Display the changeset diff between the revision at point and the
     next earlier revision.  This shows the changes to all files made in
     that revision.

'<RET>'
     In a compact-style log buffer (e.g., the one created by 'C-x v L'),
     toggle between showing and hiding the full log entry for the
     revision at point.

   Because fetching many log entries can be slow, the 'vc-change-log'
buffer displays no more than 2000 revisions by default.  The variable
'vc-log-show-limit' specifies this limit; if you set the value to zero,
that removes the limit.  You can also increase the number of revisions
shown in an existing 'vc-change-log' buffer by clicking on the 'Show
2X entries' or 'Show unlimited entries' buttons at the end of the
buffer.  However, RCS, SCCS, CVS, and SRC do not support this feature.

   A useful variant of examining history of changes is provided by the
command 'vc-region-history' (by default bound to 'C-x v h'), which shows
a 'VC-history' buffer with the history of changes made in the region
of the current buffer's file between point and the mark (*note Mark::).
The history of changes includes the commit log messages and also the
changes themselves in the Diff format.

   Invoke this command after marking in the current buffer the region in
whose changes you are interested.  In the 'VC-history' buffer it pops
up, you can use all of the commands available in the 'vc-change-log'
buffer described above, and also the commands defined by Diff mode
(*note Diff Mode::).

   This command is currently available only with Git and Mercurial (hg).

   The command 'vc-log-search' allows searching for a pattern in the log
of changes.  It prompts for a pattern (a regular expression), and
displays all entries in the change history whose log messages match the
pattern.  When invoked with a prefix argument, the command will also
prompt for a specific VCS shell command to run for this purpose.

==============================================================================
File: emacs.info,  Node: |VC_Undo|,  Next: |VC_Ignore|,  Prev: |VC_Change_Log|,  Up: |Version_Control|
==============================================================================

                                                                       *VC_Undo*

28.1.8 Undoing Version Control Actions
--------------------------------------

'C-x v u'
     Revert the work file(s) in the current VC fileset to the last
     revision ('vc-revert').

   If you want to discard all the changes you have made to the current
VC fileset, type 'C-x v u' ('vc-revert').  This shows you a diff between
the work file(s) and the revision from which you started editing, and
asks for confirmation for discarding the changes.  If you agree, the
fileset is reverted.  If you don't want 'C-x v u' to show a diff, set
the variable 'vc-revert-show-diff' to 'nil' (you can still view the diff
directly with 'C-x v ='; *note Old Revisions::).

   On locking-based version control systems, 'C-x v u' leaves files
unlocked; you must lock again to resume editing.  You can also use 'C-x
v u' to unlock a file if you lock it and then decide not to change it.

==============================================================================
File: emacs.info,  Node: |VC_Ignore|,  Next: |VC_Directory_Mode|,  Prev: |VC_Undo|,  Up: |Version_Control|
==============================================================================

                                                                     *VC_Ignore*

28.1.9 Ignore Version Control Files
-----------------------------------

'C-x v G'
     Ignore a file under current version control system.  ('vc-ignore').

   Many source trees contain some files that do not need to be
versioned, such as editor backups, object or bytecode files, and built
programs.  You can simply not add them, but then they'll always crop up
as unknown files.  You can also tell the version control system to
ignore these files by adding them to the ignore file at the top of the
tree.  'C-x v G' ('vc-ignore') can help you do this.  When called with a
prefix argument, you can remove a file from the ignored file list.

==============================================================================
File: emacs.info,  Node: |VC_Directory_Mode|,  Next: |Branches|,  Prev: |VC_Ignore|,  Up: |Version_Control|
==============================================================================

                                                             *VC_Directory_Mode*

28.1.10 VC Directory Mode
-------------------------

The "VC Directory buffer" is a specialized buffer for viewing the
version control statuses of the files in a directory tree, and
performing version control operations on those files.  In particular, it
is used to specify multi-file VC filesets for commands like 'C-x v v' to
act on (*note VC Directory Commands::).

   To use the VC Directory buffer, type 'C-x v d' ('vc-dir').  This
reads a directory's name using the minibuffer, and switches to a VC
Directory buffer for that directory.  By default, the buffer is named
'vc-dir'.  Its contents are described in *note VC Directory Buffer::.

   The 'vc-dir' command automatically detects the version control system
to be used in the specified directory.  In the event that more than one
system is being used in the directory, you should invoke the command
with a prefix argument, 'C-u C-x v d'; this prompts for the version
control system which the VC Directory buffer should use.

   In addition to the VC Directory buffer, Emacs has a similar facility
called PCL-CVS which is specialized for CVS.  *Note About PCL-CVS:
(pcl-cvs)Top.

MENU

* Buffer: VC Directory Buffer.      What the buffer looks like and means.
* Commands: VC Directory Commands.  Commands to use in a VC directory buffer.

==============================================================================
File: emacs.info,  Node: |VC_Directory_Buffer|,  Next: |VC_Directory_Commands|,  Up: |VC_Directory_Mode|
==============================================================================

                                                           *VC_Directory_Buffer*

28.1.10.1 The VC Directory Buffer
.....----------------------------

The VC Directory buffer contains a list of version-controlled files and
their version control statuses.  It lists files in the current directory
(the one specified when you called 'C-x v d') and its subdirectories,
but only those with a noteworthy status.  Files that are up-to-date
(i.e., the same as in the repository) are omitted.  If all the files in
a subdirectory are up-to-date, the subdirectory is not listed either.
As an exception, if a file has become up-to-date as a direct result of a
VC command, it is listed.

   Here is an example of a VC Directory buffer listing:

                          ./
         edited           configure.ac
     *   added            README
         unregistered     temp.txt
                          src/
     *   edited           src/main.c

Two work files have been modified but not committed: 'configure.ac' in
the current directory, and 'main.c' in the 'src/' subdirectory.  The
file named 'README' has been added but is not yet committed, while
'temp.txt' is not under version control (*note Registering::).

   The '*' characters next to the entries for 'README' and 'src/main.c'
indicate that the user has marked these files as the current VC fileset
(*note VC Directory Commands::).

   The above example is typical for a decentralized version control
system like Bazaar, Git, or Mercurial.  Other systems can show other
statuses.  For instance, CVS shows the 'needs-update' status if the
repository has changes that have not been applied to the work file.  RCS
and SCCS show the name of the user locking a file as its status.

   On CVS, the 'vc-dir' command normally contacts the repository, which
may be on a remote machine, to check for updates.  If you change the
variable 'vc-cvs-stay-local' to 'nil' (*note CVS Options::), then Emacs
avoids contacting a remote repository when generating the VC Directory
buffer (it will still contact it when necessary, e.g., when doing a
commit).  This may be desirable if you are working offline or the
network is slow.

   The VC Directory buffer omits subdirectories listed in the variable
'vc-directory-exclusion-list'.  Its default value contains directories
that are used internally by version control systems.

==============================================================================
File: emacs.info,  Node: |VC_Directory_Commands|,  Prev: |VC_Directory_Buffer|,  Up: |VC_Directory_Mode|
==============================================================================

                                                         *VC_Directory_Commands*

28.1.10.2 VC Directory Commands
.....--------------------------

Emacs provides several commands for navigating the VC Directory buffer,
and for marking files as belonging to the current VC fileset.

'n'
'<SPC>'
     Move point to the next entry ('vc-dir-next-line').

'p'
     Move point to the previous entry ('vc-dir-previous-line').

'<TAB>'
     Move to the next directory entry ('vc-dir-next-directory').

'S-<TAB>'
     Move to the previous directory entry ('vc-dir-previous-directory').

'<RET>'
'f'
     Visit the file or directory listed on the current line
     ('vc-dir-find-file').

'o'
     Visit the file or directory on the current line, in a separate
     window ('vc-dir-find-file-other-window').

'm'
     Mark the file or directory on the current line ('vc-dir-mark'),
     putting it in the current VC fileset.  If the region is active,
     mark all files in the region.

     A file cannot be marked with this command if it is already in a
     marked directory, or one of its subdirectories.  Similarly, a
     directory cannot be marked with this command if any file in its
     tree is marked.

'M'
     If point is on a file entry, mark all files with the same status;
     if point is on a directory entry, mark all files in that directory
     tree ('vc-dir-mark-all-files').  With a prefix argument, mark all
     listed files and directories.

'G'
     Add the file under point to the list of files that the VC should
     ignore ('vc-dir-ignore').  For instance, if the VC is Git, it will
     append this file to the '.gitignore' file.  If given a prefix, do
     this with all the marked files.

'q'
     Quit the VC Directory buffer, and bury it ('quit-window').

'u'
     Unmark the file or directory on the current line.  If the region is
     active, unmark all the files in the region ('vc-dir-unmark').

'U'
     If point is on a file entry, unmark all files with the same status;
     if point is on a directory entry, unmark all files in that
     directory tree ('vc-dir-unmark-all-files').  With a prefix
     argument, unmark all files and directories.

'x'
     Hide files with 'up-to-date' or 'ignored' status
     ('vc-dir-hide-up-to-date').  With a prefix argument, hide items
     whose state is that of the item at point.

   While in the VC Directory buffer, all the files that you mark with
'm' ('vc-dir-mark') or 'M' ('vc-dir-mark-all-files') are in the current
VC fileset.  If you mark a directory entry with 'm', all the listed
files in that directory tree are in the current VC fileset.  The files
and directories that belong to the current VC fileset are indicated with
a '*' character in the VC Directory buffer, next to their VC status.  In
this way, you can set up a multi-file VC fileset to be acted on by VC
commands like 'C-x v v' (*note Basic VC Editing::), 'C-x v =' (*note Old
Revisions::), and 'C-x v u' (*note VC Undo::).

   The VC Directory buffer also defines some single-key shortcuts for VC
commands with the 'C-x v' prefix: '=', '+', 'l', 'i', 'D', 'L', 'G',
'I', 'O', and 'v'.

   For example, you can commit a set of edited files by opening a VC
Directory buffer, where the files are listed with the 'edited' status;
marking the files; and typing 'v' or 'C-x v v' ('vc-next-action').  If
the version control system is changeset-based, Emacs will commit the
files in a single revision.

   While in the VC Directory buffer, you can also perform search and
replace on the current VC fileset, with the following commands:

'S'
     Search the fileset ('vc-dir-search').

'Q'
     Do a regular expression query replace on the fileset
     ('vc-dir-query-replace-regexp').

'M-s a C-s'
     Do an incremental search on the fileset ('vc-dir-isearch').

'M-s a C-M-s'
     Do an incremental regular expression search on the fileset
     ('vc-dir-isearch-regexp').

Apart from acting on multiple files, these commands behave much like
their single-buffer counterparts (*note Search::).

   The VC Directory buffer additionally defines some branch-related
commands starting with the prefix 'B':

'B c'
     Create a new branch ('vc-create-tag').

'B l'
     Prompt for the name of a branch and display the change history of
     that branch ('vc-print-branch-log').

'B s'
     Switch to a branch ('vc-retrieve-tag').  *Note Switching
     Branches::.

'd'
     Delete the marked files, or the current file if no marks
     ('vc-dir-clean-delete)'.  The files will not be marked as deleted
     in the version control system, so this function is mostly useful
     for unregistered files.

   The above commands are also available via the menu bar, and via a
context menu invoked by 'mouse-2'.  Furthermore, some VC backends use
the menu to provide extra backend-specific commands.  For example, Git
and Bazaar allow you to manipulate "stashes" and "shelves" (which are a
way to temporarily put aside uncommitted changes, and bring them back at
a later time).

==============================================================================
File: emacs.info,  Node: |Branches|,  Next: |Miscellaneous_VC|,  Prev: |VC_Directory_Mode|,  Up: |Version_Control|
==============================================================================

                                                                      *Branches*

28.1.11 Version Control Branches
--------------------------------

One use of version control is to support multiple independent lines of
development, which are called "branches".  Amongst other things,
branches can be used for maintaining separate stable and development
versions of a program, and for developing unrelated features in
isolation from one another.

   VC's support for branch operations is currently fairly limited.  For
decentralized version control systems, it provides commands for
"updating" one branch with the contents of another, and for "merging"
the changes made to two different branches (*note Merging::).  For
centralized version control systems, it supports checking out different
branches and committing into new or different branches.

MENU

* |Switching_Branches|::    How to get to another existing branch.
* |Pulling_/_Pushing|::     Receiving/sending changes from/to elsewhere.
* |Merging|::               Transferring changes between branches.
* |Creating_Branches|::     How to start a new branch.

==============================================================================
File: emacs.info,  Node: |Switching_Branches|,  Next: |Pulling_/_Pushing|,  Up: |Branches|
==============================================================================

                                                            *Switching_Branches*

28.1.11.1 Switching between Branches
.....-------------------------------

The various version control systems differ in how branches are
implemented, and these differences cannot be entirely concealed by VC.

   On some decentralized version control systems, including Bazaar and
Mercurial in its normal mode of operation, each branch has its own
working directory tree, so switching between branches just involves
switching directories.  On Git, branches are normally "co-located" in
the same directory, and switching between branches is done using the
'git checkout' command, which changes the contents of the working tree
to match the branch you switch to.  Bazaar also supports co-located
branches, in which case the 'bzr switch' command will switch branches in
the current directory.  With Subversion, you switch to another branch
using the 'svn switch' command.  With Mercurial, command 'hg update' is
used to swith to another branch.

   The VC command to switch to another branch in the current directory
is 'C-x v r BRANCH-NAME <RET>' ('vc-retrieve-tag').

   On centralized version control systems, you can also switch between
branches by typing 'C-u C-x v v' in an up-to-date work file (*note
Advanced C-x v v::), and entering the revision ID for a revision on
another branch.  On CVS, for instance, revisions on the "trunk" (the
main line of development) normally have IDs of the form 1.1, 1.2, 1.3,
..., while the first branch created from (say) revision 1.2 has revision
IDs 1.2.1.1, 1.2.1.2, ..., the second branch created from revision 1.2
has revision IDs 1.2.2.1, 1.2.2.2, ..., and so forth.  You can also
specify the "branch ID", which is a branch revision ID omitting its
final component (e.g., 1.2.1), to switch to the latest revision on that
branch.

   On a locking-based system, switching to a different branch also
unlocks (write-protects) the working tree.

   Once you have switched to a branch, VC commands will apply to that
branch until you switch away; for instance, any VC filesets that you
commit will be committed to that specific branch.

==============================================================================
File: emacs.info,  Node: |Pulling_/_Pushing|,  Next: |Merging|,  Prev: |Switching_Branches|,  Up: |Branches|
==============================================================================

                                                             *Pulling_/_Pushing*

28.1.11.2 Pulling/Pushing Changes into/from a Branch
.....-----------------------------------------------

'C-x v P'
     On a decentralized version control system, update another location
     with changes from the current branch (a.k.a.  "push" changes).
     This concept does not exist for centralized version control systems

'C-x v +'
     On a decentralized version control system, update the current
     branch by "pulling in" changes from another location.

     On a centralized version control system, update the current VC
     fileset.

   On a decentralized version control system, the command 'C-x v P'
('vc-push') updates another location with changes from the current
branch.  With a prefix argument, it prompts for the exact version
control command to run, which lets you specify where to push changes;
the default is 'bzr push' with Bazaar, 'git push' with Git, and 'hg
push' with Mercurial.  The default commands always push to a default
location determined by the version control system from your branch
configuration.

   Prior to pushing, you can use 'C-x v O' ('vc-log-outgoing') to view a
log buffer of the changes to be sent.  *Note VC Change Log::.

   This command is currently supported only by Bazaar, Git, and
Mercurial.  The concept of "pushing" does not exist for centralized
version control systems, where this operation is a part of committing a
changeset, so invoking this command on a centralized VCS signals an
error.  This command also signals an error when attempted in a Bazaar
"bound branch", where committing a changeset automatically pushes the
changes to the remote repository to which the local branch is bound.

   On a decentralized version control system, the command 'C-x v +'
('vc-pull') updates the current branch and working tree.  It is
typically used to update a copy of a remote branch.  If you supply a
prefix argument, the command prompts for the exact version control
command to use, which lets you specify where to pull changes from.
Otherwise, it pulls from a default location determined by the version
control system.

   Amongst decentralized version control systems, 'C-x v +' is currently
supported only by Bazaar, Git, and Mercurial.  With Bazaar, it calls
'bzr pull' for ordinary branches (to pull from a master branch into a
mirroring branch), and 'bzr update' for a bound branch (to pull from a
central repository).  With Git, it calls 'git pull' to fetch changes
from a remote repository and merge it into the current branch.  With
Mercurial, it calls 'hg pull -u' to fetch changesets from the default
remote repository and update the working directory.

   Prior to pulling, you can use 'C-x v I' ('vc-log-incoming') to view a
log buffer of the changes to be applied.  *Note VC Change Log::.

   On a centralized version control system like CVS, 'C-x v +' updates
the current VC fileset from the repository.

==============================================================================
File: emacs.info,  Node: |Merging|,  Next: |Creating_Branches|,  Prev: |Pulling_/_Pushing|,  Up: |Branches|
==============================================================================

                                                                       *Merging*

28.1.11.3 Merging Branches
.....---------------------

'C-x v m'
     On a decentralized version control system, merge changes from
     another branch into the current one.

     On a centralized version control system, merge changes from another
     branch into the current VC fileset.

   While developing a branch, you may sometimes need to "merge" in
changes that have already been made in another branch.  This is not a
trivial operation, as overlapping changes may have been made to the two
branches.

   On a decentralized version control system, merging is done with the
command 'C-x v m' ('vc-merge').  On Bazaar, this prompts for the exact
arguments to pass to 'bzr merge', offering a sensible default if
possible.  On Git, this prompts for the name of a branch to merge from,
with completion (based on the branch names known to the current
repository).  With Mercurial, this prompts for argument to pass to 'hg
merge'.  The output from running the merge command is shown in a
separate buffer.

   On a centralized version control system like CVS, 'C-x v m' prompts
for a branch ID, or a pair of revision IDs (*note Switching Branches::);
then it finds the changes from that branch, or the changes between the
two revisions you specified, and merges those changes into the current
VC fileset.  If you just type '<RET>', Emacs simply merges any changes
that were made on the same branch since you checked the file out.

   Immediately after performing a merge, only the working tree is
modified, and you can review the changes produced by the merge with 'C-x
v D' and related commands (*note Old Revisions::).  If the two branches
contained overlapping changes, merging produces a "conflict"; a warning
appears in the output of the merge command, and "conflict markers" are
inserted into each affected work file, surrounding the two sets of
conflicting changes.  You must then resolve the conflict by editing the
conflicted files.  Once you are done, the modified files must be
committed in the usual way for the merge to take effect (*note Basic VC
Editing::).

==============================================================================
File: emacs.info,  Node: |Creating_Branches|,  Prev: |Merging|,  Up: |Branches|
==============================================================================

                                                             *Creating_Branches*

28.1.11.4 Creating New Branches
.....--------------------------

On centralized version control systems like CVS, Emacs supports creating
new branches as part of a commit operation.  When committing a modified
VC fileset, type 'C-u C-x v v' ('vc-next-action' with a prefix argument;
*note Advanced C-x v v::).  Then Emacs prompts for a revision ID for the
new revision.  You should specify a suitable branch ID for a branch
starting at the current revision.  For example, if the current revision
is 2.5, the branch ID should be 2.5.1, 2.5.2, and so on, depending on
the number of existing branches at that point.

   To create a new branch at an older revision (one that is no longer
the head of a branch), first select that revision (*note Switching
Branches::).  Your procedure will then differ depending on whether you
are using a locking or merging-based VCS.

   On a locking VCS, you will need to lock the old revision branch with
'C-x v v'.  You'll be asked to confirm, when you lock the old revision,
that you really mean to create a new branch--if you say no, you'll be
offered a chance to lock the latest revision instead.  On a
merging-based VCS you will skip this step.

   Then make your changes and type 'C-x v v' again to commit a new
revision.  This creates a new branch starting from the selected
revision.

   After the branch is created, subsequent commits create new revisions
on that branch.  To leave the branch, you must explicitly select a
different revision with 'C-u C-x v v'.

==============================================================================
File: emacs.info,  Node: |Miscellaneous_VC|,  Next: |Customizing_VC|,  Prev: |Branches|,  Up: |Version_Control|
==============================================================================

                                                              *Miscellaneous_VC*

28.1.12 Miscellaneous Commands and Features of VC
-------------------------------------------------

This section explains the less-frequently-used features of VC.

MENU

* |Change_Logs_and_VC|::  Generating a change log file from log entries.
* |VC_Delete/Rename|::    Deleting and renaming version-controlled files.
* |Revision_Tags|::       Symbolic names for revisions.
* |Version_Headers|::     Inserting version control headers into working files.

==============================================================================
File: emacs.info,  Node: |Change_Logs_and_VC|,  Next: |VC_Delete/Rename|,  Up: |Miscellaneous_VC|
==============================================================================

                                                            *Change_Logs_and_VC*

28.1.12.1 Change Logs and VC
.....-----------------------

If you use RCS or CVS for a program with a 'ChangeLog' file (*note
Change Log::), you can generate change log entries from the version
control log entries of previous commits.

   Note that this only works with RCS or CVS.  This procedure would be
particularly incorrect on a modern changeset-based version control
system, where changes to the 'ChangeLog' file would normally be
committed as part of a changeset.  In that case, you should write the
change log entries first, then pull them into the 'vc-log' buffer when
you commit (*note Log Buffer::).

'C-x v a'
     Visit the current directory's 'ChangeLog' file and, for registered
     files in that directory, create new entries for versions committed
     since the most recent change log entry ('vc-update-change-log').

'C-u C-x v a'
     As above, but only find entries for the current buffer's file.

   For example, suppose the first line of 'ChangeLog' is dated
1999-04-10, and that the only check-in since then was by Nathaniel
Bowditch to 'rcs2log' on 1999-05-22 with log entry 'Ignore log messages
that start with '#'.'.  Then 'C-x v a' inserts this 'ChangeLog' entry:

     1999-05-22  Nathaniel Bowditch  <nat@apn.org>

             * rcs2log: Ignore log messages that start with '#'.

If the version control log entry specifies a function name (in
parenthesis at the beginning of a line), that is reflected in the
'ChangeLog' entry.  For example, if a log entry for 'vc.el' is
'(vc-do-command): Check call-process status.', the 'ChangeLog' entry is:

     1999-05-06  Nathaniel Bowditch  <nat@apn.org>

             * vc.el (vc-do-command): Check call-process status.

   When 'C-x v a' adds several change log entries at once, it groups
related log entries together if they all are checked in by the same
author at nearly the same time.  If the log entries for several such
files all have the same text, it coalesces them into a single entry.

==============================================================================
File: emacs.info,  Node: |VC_Delete/Rename|,  Next: |Revision_Tags|,  Prev: |Change_Logs_and_VC|,  Up: |Miscellaneous_VC|
==============================================================================

                                                              *VC_Delete/Rename*

28.1.12.2 Deleting and Renaming Version-Controlled Files
.....---------------------------------------------------

'M-x vc-delete-file'
     Prompt for a file name, delete the file from the working tree, and
     schedule the deletion for committing.

'M-x vc-rename-file'
     Prompt for two file names, OLD and NEW, rename them in the working
     tree, and schedule the renaming for committing.  The OLD file
     defaults to the current buffer's file name if it is under VC.

   If you wish to delete a version-controlled file, use the command 'M-x
vc-delete-file'.  This prompts for the file name, and deletes it via the
version control system.  The file is removed from the working tree, and
in the VC Directory buffer (*note VC Directory Mode::), it is displayed
with the 'removed' status.  When you commit it, the deletion takes
effect in the repository.

   To rename a version-controlled file, type 'M-x vc-rename-file'.  This
prompts for two arguments: the name of the file you wish to rename, and
the new name; then it performs the renaming via the version control
system.  The renaming takes effect immediately in the working tree, and
takes effect in the repository when you commit the renamed file.

   On modern version control systems that have built-in support for
renaming, the renamed file retains the full change history of the
original file.  On CVS and older version control systems, the
'vc-rename-file' command actually works by creating a copy of the old
file under the new name, registering it, and deleting the old file.  In
this case, the change history is not preserved.

==============================================================================
File: emacs.info,  Node: |Revision_Tags|,  Next: |Version_Headers|,  Prev: |VC_Delete/Rename|,  Up: |Miscellaneous_VC|
==============================================================================

                                                                 *Revision_Tags*

28.1.12.3 Revision Tags
.....------------------

Most version control systems allow you to apply a "revision tag" to a
specific version of a version-controlled tree.  On modern
changeset-based version control systems, a revision tag is simply a
symbolic name for a particular revision.  On older file-based systems
like CVS, each tag is added to the entire set of version-controlled
files, allowing them to be handled as a unit.  Revision tags are
commonly used to identify releases that are distributed to users.

   There are two basic commands for tags; one makes a tag with a given
name, the other retrieves a named tag.

'C-x v s NAME <RET>'
     Define the working revision of every registered file in or under
     the current directory as a tag named NAME ('vc-create-tag').

'C-x v r NAME <RET>'
     For all registered files at or below the current directory level,
     retrieve the tagged revision NAME.  This command will switch to a
     branch if NAME is a branch name and your VCS distinguishes branches
     from tags.  ('vc-retrieve-tag').

     This command reports an error if any files are locked at or below
     the current directory, without changing anything; this is to avoid
     overwriting work in progress.

   You can give a tag or branch name as an argument to 'C-x v =' or 'C-x
v ~' (*note Old Revisions::).  Thus, you can use it to compare a tagged
version against the current files, or two tagged versions against each
other.

   On SCCS, VC implements tags itself; these tags are visible only
through VC.  Most later systems (including CVS, Subversion, bzr, git,
and hg) have a native tag facility, and VC uses it where available;
those tags will be visible even when you bypass VC.

   In file-based version control systems, when you rename a registered
file you need to rename its master along with it; the command
'vc-rename-file' will do this automatically (*note VC Delete/Rename::).
If you are using SCCS, you must also update the records of the tag, to
mention the file by its new name ('vc-rename-file' does this, too).  An
old tag that refers to a master file that no longer exists under the
recorded name is invalid; VC can no longer retrieve it.  It would be
beyond the scope of this manual to explain enough about RCS and SCCS to
explain how to update the tags by hand.  Using 'vc-rename-file' makes
the tag remain valid for retrieval, but it does not solve all problems.
For example, some of the files in your program probably refer to others
by name.  At the very least, the makefile probably mentions the file
that you renamed.  If you retrieve an old tag, the renamed file is
retrieved under its new name, which is not the name that the makefile
expects.  So the program won't really work as retrieved.

==============================================================================
File: emacs.info,  Node: |Version_Headers|,  Prev: |Revision_Tags|,  Up: |Miscellaneous_VC|
==============================================================================

                                                               *Version_Headers*

28.1.12.4 Inserting Version Control Headers
.....--------------------------------------

On Subversion, CVS, RCS, and SCCS, you can put certain special strings
called "version headers" into a work file.  When the file is committed,
the version control system automatically puts the revision number, the
name of the user who made the commit, and other relevant information
into the version header.

   VC does not normally use the information in the version headers.  As
an exception, when using RCS, Emacs uses the version header, if there is
one, to determine the file version, since it is often more reliable than
the RCS master file.  To inhibit using the version header this way,
change the variable 'vc-consult-headers' to 'nil'.  VC then always uses
the file permissions (if it is supposed to trust them), or else checks
the master file.

   To insert a suitable header string into the current buffer, use the
command 'M-x vc-insert-headers'.  This command works only on Subversion,
CVS, RCS, and SCCS.  The variable 'vc-BACKEND-header' contains the list
of keywords to insert into the version header; for instance, CVS uses
'vc-cvs-header', whose default value is ''("\$Id\$")'.  (The extra
backslashes prevent the string constant from being interpreted as a
header, if the Emacs Lisp file defining it is maintained with version
control.)  The 'vc-insert-headers' command inserts each keyword in the
list on a new line at point, surrounded by tabs, and inside comment
delimiters if necessary.

   The variable 'vc-static-header-alist' specifies further strings to
add based on the name of the buffer.  Its value should be a list of
elements of the form '(REGEXP . FORMAT)'.  Whenever REGEXP matches the
buffer name, FORMAT is also inserted as part of the version header.  A
'%s' in FORMAT is replaced with the file's version control type.

==============================================================================
File: emacs.info,  Node: |Customizing_VC|,  Prev: Miscellaneous VC,  Up: |Version_Control|
==============================================================================

                                                                *Customizing_VC*

28.1.13 Customizing VC
----------------------

The variable 'vc-handled-backends' determines which version control
systems VC should handle.  The default value is '(RCS CVS SVN SCCS SRC
Bzr Git Hg Mtn)', so it contains all the version systems that are
currently supported.  If you want VC to ignore one or more of these
systems, exclude its name from the list.  To disable VC entirely, set
this variable to 'nil'.

   The order of systems in the list is significant: when you visit a
file registered in more than one system, VC uses the system that comes
first in 'vc-handled-backends' by default.  The order is also
significant when you register a file for the first time (*note
Registering::).

MENU

* |General_VC_Options|::  Options that apply to multiple back ends.
* |RCS_and_SCCS|::        Options for RCS and SCCS.
* |CVS_Options|::         Options for CVS.

==============================================================================
File: emacs.info,  Node: |General_VC_Options|,  Next: |RCS_and_SCCS|,  Up: Customizing VC
==============================================================================

                                                            *General_VC_Options*

28.1.13.1 General Options
.....--------------------

Emacs normally does not save backup files for source files that are
maintained with version control.  If you want to make backup files even
for files that use version control, set the variable
'vc-make-backup-files' to a non-'nil' value.

   Editing a version-controlled file through a symbolic link may cause
unexpected results, if you are unaware that the underlying file is
version-controlled.  The variable 'vc-follow-symlinks' controls what
Emacs does if you try to visit a symbolic link pointing to a
version-controlled file.  If the value is 'ask' (the default), Emacs
asks for confirmation.  If it is 'nil', Emacs just displays a warning
message.  If it is 't', Emacs automatically follows the link and visits
the real file instead.

   If 'vc-suppress-confirm' is non-'nil', then 'C-x v v' and 'C-x v i'
can save the current buffer without asking, and 'C-x v u' also operates
without asking for confirmation.

   VC mode does much of its work by running the shell commands for the
appropriate version control system.  If 'vc-command-messages' is
non-'nil', VC displays messages to indicate which shell commands it
runs, and additional messages when the commands finish.

==============================================================================
File: emacs.info,  Node: |RCS_and_SCCS|,  Next: |CVS_Options|,  Prev: |General_VC_Options|,  Up: |Customizing_VC|
==============================================================================

                                                                  *RCS_and_SCCS*

28.1.13.2 Options for RCS and SCCS
.....-----------------------------

By default, RCS uses locking to coordinate the activities of several
users, but there is a mode called "non-strict locking" in which you can
check-in changes without locking the file first.  Use 'rcs -U' to switch
to non-strict locking for a particular file, see the 'rcs' manual page
for details.

   When deducing the version control state of an RCS file, VC first
looks for an RCS version header string in the file (*note Version
Headers::).  If there is no header string, VC normally looks at the file
permissions of the work file; this is fast.  But there might be
situations when the file permissions cannot be trusted.  In this case
the master file has to be consulted, which is rather expensive.  Also
the master file can only tell you _if_ there's any lock on the file, but
not whether your work file really contains that locked version.

   You can tell VC not to use version headers to determine the file
status by setting 'vc-consult-headers' to 'nil'.  VC then always uses
the file permissions (if it is supposed to trust them), or else checks
the master file.

   VC determines the version control state of files under SCCS much as
with RCS.  It does not consider SCCS version headers, though.  Thus, the
variable 'vc-consult-headers' does not affect SCCS use.

==============================================================================
File: emacs.info,  Node: |CVS_Options|,  Prev: |RCS_and_SCCS|,  Up: |Customizing_VC|
==============================================================================

                                                                   *CVS_Options*

28.1.13.3 Options specific for CVS
.....-----------------------------

You can specify additional command line options to pass to all CVS
operations in the variable 'vc-cvs-global-switches'.  These switches are
inserted immediately after the 'cvs' command, before the name of the
operation to invoke.

   When using a CVS repository on a remote machine, VC can try keeping
network interactions to a minimum.  This is controlled by the variable
'vc-cvs-stay-local'.  If 'vc-cvs-stay-local' is 'only-file' (the
default), VC determines the version control status of each file using
only the entry in the local CVS subdirectory and the information
returned by previous CVS commands.  As a consequence, if you have
modified a file and somebody else has checked in other changes, you will
not be notified of the conflict until you try to commit.

   If you change 'vc-cvs-stay-local' to 'nil', VC queries the remote
repository _before_ it decides what to do in 'vc-next-action' ('C-x v
v'), just as it does for local repositories.

   You can also set 'vc-cvs-stay-local' to a regular expression that is
matched against the repository host name; VC then stays local only for
repositories from hosts that match the pattern.

   When using a remote repository, Emacs normally makes "automatic
version backups" of the original versions of each edited file.  These
local backups are made whenever you save the first changes to a file,
and they are removed after you commit your changes to the repository.
(Note that these are not the same as ordinary Emacs backup files; *note
Backup::.)  Commands like 'C-x v =' and 'C-x v u' make use of automatic
version backups, if possible, to avoid having to access the network.

   Setting 'vc-cvs-stay-local' to 'nil' disables the making of automatic
version backups.

   Automatic version backups have names of the form 'FILE.~VERSION.~'.
This is similar to the name that 'C-x v ~' saves old versions to (*note
Old Revisions::), except for the additional dot ('.') after the version.
The relevant VC commands can use both kinds of version backups.  The
main difference is that the manual version backups made by 'C-x v ~' are
not deleted automatically when you commit.

   CVS does not use locking by default, but there are ways to enable
locking-like behavior using its 'CVSREAD' or "watch" feature; see the
CVS documentation for details.  If that case, you can use 'C-x v v' in
Emacs to toggle locking, as you would for a locking-based version
control system (*note VC With A Locking VCS::).

==============================================================================
File: emacs.info,  Node: |Projects|,  Next: |Change_Log|,  Prev: |Version_Control|,  Up: |Maintaining|
==============================================================================

                                                                      *Projects*

28.2 Working with Projects
=====---------------------

A "project" is a collection of files used for producing one or more
programs.  Files that belong to a project are typically stored in a
hierarchy of directories; the top-level directory of the hierarchy is
known as the "project root".

   Whether a given directory is a root of some project is determined by
the project-specific infrastructure, known as "project back-end".  Emacs
currently supports two such back-ends: VC (*note Version Control::),
whereby a VCS repository is considered a project; and EDE (*note EDE::).
This is expected to be extended in the future to support additional
types of projects.

   Which files do or don't belong to a project is also determined by the
project back-end.  For example, the VC back-end doesn't consider
"ignored" files (*note VC Ignore::) to be part of the project.

   Emacs provides commands for handling project files conveniently.
This section describes these commands.

   All of the commands described here share the notion of the "current
project".  The current project is determined by the 'default-directory'
(*note File Names::) of the buffer that is the current buffer when the
command is invoked.  If that directory doesn't seem to belong to a
recognizable project, these commands prompt you for the project
directory.

   The command 'project-find-file' is a convenient way of visiting files
(*note Visiting::) that belong to the current project.  Unlike 'C-x
C-f', this command doesn't require to type the full file name of the
file to visit, you can type only the file's base name (i.e., omit the
leading directories).  In addition, the completion candidates considered
by the command include only the files belonging to the current project,
and nothing else.  If there's a file name at point, this command offers
that file as the default to visit.

   The command 'project-find-regexp' is similar to 'rgrep' (*note Grep
Searching::), but it searches only the files that belong to the current
project.  The command prompts for the regular expression to search, and
pops up an Xref mode buffer with the search results, where you can
select a match using the Xref mode commands (*note Xref Commands::).
When invoked with a prefix argument, this command additionally prompts
for the base directory from which to start the search; this allows, for
example, to limit the search only to project files under a certain
subdirectory of the project root.

   'M-x project-search' is an interactive variant of
'project-find-regexp'.  It prompts for a regular expression to search in
the current project's files, but instead of finding all the matches and
displaying them, it stops when it finds a match and visits the matched
file at the locus of the match, allowing you to edit the matched file.
To find the rest of the matches, type 'M-x fileloop-continue <RET>'.

   'M-x project-query-replace-regexp' is similar to 'project-search',
but it prompts you for whether to replace each match it finds, like
'query-replace' does (*note Query Replace::), and continues to the next
match after you respond.  If your response causes Emacs to exit the
query-replace loop, you can later continue with
'M-x fileloop-continue <RET>'.

==============================================================================
File: emacs.info,  Node: |Change_Log|,  Next: |Xref|,  Prev: |Projects|,  Up: |Maintaining|
==============================================================================

                                                                    *Change_Log*

28.3 Change Logs
=====-----------

Many software projects keep a "change log".  This is a file, normally
named 'ChangeLog', containing a chronological record of when and how the
program was changed.  Sometimes, these files are automatically generated
from the change log entries stored in version control systems, or are
used to generate these change log entries.  Sometimes, there are several
change log files, each recording the changes in one directory or
directory tree.

MENU

* |Change_Log_Commands|:: Commands for editing change log files.
* |Format_of_ChangeLog|:: What the change log file looks like.

==============================================================================
File: emacs.info,  Node: |Change_Log_Commands|,  Next: |Format_of_ChangeLog|,  Up: |Change_Log|
==============================================================================

                                                           *Change_Log_Commands*

28.3.1 Change Log Commands
--------------------------

The Emacs command 'C-x 4 a' adds a new entry to the change log file for
the file you are editing ('add-change-log-entry-other-window').  If that
file is actually a backup file, it makes an entry appropriate for the
file's parent--that is useful for making log entries for functions that
have been deleted in the current version.

   'C-x 4 a' visits the change log file and creates a new entry unless
the most recent entry is for today's date and your name.  It also
creates a new item for the current file.  For many languages, it can
even guess the name of the function or other object that was changed.

   To find the change log file, Emacs searches up the directory tree
from the file you are editing.  By default, it stops if it finds a
directory that seems to be the root of a version-control repository.  To
change this, customize 'change-log-directory-files'.

   When the variable 'add-log-keep-changes-together' is non-'nil', 'C-x
4 a' adds to any existing item for the file, rather than starting a new
item.

   You can combine multiple changes of the same nature.  If you don't
enter any text after the initial 'C-x 4 a', any subsequent 'C-x 4 a'
adds another symbol to the change log entry.

   If 'add-log-always-start-new-record' is non-'nil', 'C-x 4 a' always
makes a new entry, even if the last entry was made by you and on the
same date.

   If the value of the variable 'change-log-version-info-enabled' is
non-'nil', 'C-x 4 a' adds the file's version number to the change log
entry.  It finds the version number by searching the first ten percent
of the file, using regular expressions from the variable
'change-log-version-number-regexp-list'.

   The change log file is visited in Change Log mode.  In this major
mode, each bunch of grouped items counts as one paragraph, and each
entry is considered a page.  This facilitates editing the entries.
'C-j' and auto-fill indent each new line like the previous line; this is
convenient for entering the contents of an entry.

   You can use the command 'change-log-goto-source' (by default bound to
'C-c C-c') to go to the source location of the change log entry near
point, when Change Log mode is on.  Then subsequent invocations of the
'next-error' command (by default bound to 'M-g M-n' and 'C-x `') will
move between entries in the change log.  You will jump to the actual
site in the file that was changed, not just to the next change log
entry.  You can also use 'previous-error' to move back through the
change log entries.

   You can use the command 'M-x change-log-merge' to merge other log
files into a buffer in Change Log Mode, preserving the date ordering of
entries.

   Version control systems are another way to keep track of changes in
your program and keep a change log.  Many projects that use a VCS don't
keep a separate versioned change log file nowadays, so you may wish to
avoid having such a file in the repository.  If the value of
'add-log-dont-create-changelog-file' is non-'nil', commands like 'C-x 4
a' ('add-change-log-entry-other-window') will record changes in a
suitably named temporary buffer instead of a file, if such a file does
not already exist.

   Whether you have a change log file or use a temporary buffer for
change logs, you can type 'C-c C-a' ('log-edit-insert-changelog') in the
VC Log buffer to insert the relevant change log entries, if they exist.
*Note Log Buffer::.

==============================================================================
File: emacs.info,  Node: |Format_of_ChangeLog|,  Prev: |Change_Log_Commands|,  Up: |Change_Log|
==============================================================================

                                                           *Format_of_ChangeLog*

28.3.2 Format of ChangeLog
--------------------------

A change log entry starts with a header line that contains the current
date, your name (taken from the variable 'add-log-full-name'), and your
email address (taken from the variable 'add-log-mailing-address').
Aside from these header lines, every line in the change log starts with
a space or a tab.  The bulk of the entry consists of "items", each of
which starts with a line starting with whitespace and a star.  Here are
two entries, both dated in May 1993, with two items and one item
respectively.

     1993-05-25  Richard Stallman  <rms@gnu.org>

             * man.el: Rename symbols 'man-*' to 'Man-*'.
             (manual-entry): Make prompt string clearer.

             * simple.el (blink-matching-paren-distance):
             Change default to 12,000.

     1993-05-24  Richard Stallman  <rms@gnu.org>

             * vc.el (minor-mode-map-alist): Don't use it if it's void.
             (vc-cancel-version): Doc fix.

   One entry can describe several changes; each change should have its
own item, or its own line in an item.  Normally there should be a blank
line between items.  When items are related (parts of the same change,
in different places), group them by leaving no blank line between them.

   You should put a copyright notice and permission notice at the end of
the change log file.  Here is an example:

     Copyright 1997, 1998 Free Software Foundation, Inc.
     Copying and distribution of this file, with or without modification, are
     permitted provided the copyright notice and this notice are preserved.

Of course, you should substitute the proper years and copyright holder.

==============================================================================
File: emacs.info,  Node: |Xref|,  Next: |EDE|,  Prev: |Change_Log|,  Up: |Maintaining|
==============================================================================

                                                                          *Xref*

28.4 Find Identifier References
=====--------------------------

An "identifier" is a name of a syntactical subunit of the program: a
function, a subroutine, a method, a class, a data type, a macro, etc.
In a programming language, each identifier is a symbol in the language's
syntax.  Program development and maintenance requires capabilities to
quickly find where each identifier was defined and referenced, to rename
identifiers across the entire project, etc.

   These capabilities are also useful for finding references in major
modes other than those defined to support programming languages.  For
example, chapters, sections, appendices, etc. of a text or a TeX
document can be treated as subunits as well, and their names can be used
as identifiers.  In this chapter, we use the term "identifiers" to
collectively refer to the names of any kind of subunits, in program
source and in other kinds of text alike.

   Emacs provides a unified interface to these capabilities, called
'xref'.

   To do its job, 'xref' needs to make use of information and to employ
methods specific to the major mode.  What files to search for
identifiers, how to find references to identifiers, how to complete on
identifiers--all this and more is mode-specific knowledge.  'xref'
delegates the mode-specific parts of its job to a "backend" provided by
the mode; it also includes defaults for some of its commands, for those
modes that don't provide their own.

   A backend can implement its capabilities in a variety of ways.  Here
are a few examples:

  a. Some major modes provide built-in means for looking up the language
     symbols.  For example, Emacs Lisp symbols can be identified by
     searching the package load history, maintained by the Emacs Lisp
     interpreter, and by consulting the built-in documentation strings;
     the Emacs Lisp mode uses these facilities in its backend to allow
     finding definitions of symbols.  (One disadvantage of this kind of
     backend is that it only knows about subunits that were loaded into
     the interpreter.)

  b. An external program can extract references by scanning the relevant
     files, and build a database of these references.  A backend can
     then access this database whenever it needs to list or look up
     references.  The Emacs distribution includes 'etags', a command for
     tagging identifier definitions in programs, which supports many
     programming languages and other major modes, such as HTML, by
     extracting references into "tags tables".  *Note Create Tags
     Table::.  Major modes for languages supported by 'etags' can use
     tags tables as basis for their backend.  (One disadvantage of this
     kind of backend is that tags tables need to be kept reasonably up
     to date, by rebuilding them from time to time.)

MENU

* |Find_Identifiers|::    Commands to find where an identifier is defined
                          or referenced, to list identifiers, etc.
* |Tags_Tables|::         Tags table records which file defines a symbol.
* |Select_Tags_Table|::   How to visit a specific tags table.

==============================================================================
File: emacs.info,  Node: |Find_Identifiers|,  Next: |Tags_Tables|,  Up: |Xref|
==============================================================================

                                                              *Find_Identifiers*

28.4.1 Find Identifiers
-----------------------

This subsection describes the commands that find references to
identifiers and perform various queries about identifiers.  Each such
reference could _define_ an identifier, e.g., provide the implementation
of a program subunit or the text of a document section; or it could
_use_ the identifier, e.g., call a function or a method, assign a value
to a variable, mention a chapter in a cross-reference, etc.

MENU

* |Looking_Up_Identifiers|:: Commands to find the definition of an identifier.
* |Xref_Commands|::          Commands in the 'xref' buffer.
* |Identifier_Search|::      Searching and replacing identifiers.
* |List_Identifiers|::       Listing identifiers and completing on them.

==============================================================================
File: emacs.info,  Node: |Looking_Up_Identifiers|,  Next: |Xref_Commands|,  Up: Find Identifiers
==============================================================================

                                                        *Looking_Up_Identifiers*

28.4.1.1 Looking Up Identifiers
.....--------------------------

The most important thing that 'xref' enables you to do is to find the
definition of a specific identifier.

'M-.'
     Find definitions of an identifier ('xref-find-definitions').
'C-M-. PATTERN <RET>'
     Find all identifiers whose name matches PATTERN
     ('xref-find-apropos').
'C-x 4 . <RET>'
     Find definitions of identifier, but display it in another window
     ('xref-find-definitions-other-window').
'C-x 5 . <RET>'
     Find definition of identifier, and display it in a new frame
     ('xref-find-definitions-other-frame').
'M-x xref-find-definitions-at-mouse'
     Find definition of identifier at mouse click.
'M-,'
     Go back to where you previously invoked 'M-.' and friends
     ('xref-pop-marker-stack').
'M-x xref-etags-mode'
     Switch 'xref' to use the 'etags' backend.

   'M-.' ('xref-find-definitions') shows the definitions of the
identifier at point.  With a prefix argument, or if there's no
identifier at point, it prompts for the identifier.  (If you want it to
always prompt, customize 'xref-prompt-for-identifier' to 't'.)

   If the specified identifier has only one definition, the command
jumps to it.  If the identifier has more than one possible definition
(e.g., in an object-oriented language, or if there's a function and a
variable by the same name), the command shows the candidate definitions
in the 'xref' buffer, together with the files in which these
definitions are found.  Selecting one of these candidates by typing
'<RET>' or clicking 'mouse-2' will pop a buffer showing the
corresponding definition.

   When entering the identifier argument to 'M-.', the usual minibuffer
completion commands can be used (*note Completion::), with the known
identifier names as completion candidates.

   Like most commands that can switch buffers, 'xref-find-definitions'
has a variant that displays the new buffer in another window, and one
that makes a new frame for it.  The former is 'C-x 4 .'
('xref-find-definitions-other-window'), and the latter is 'C-x 5 .'
('xref-find-definitions-other-frame').

   The command 'xref-find-definitions-at-mouse' works like
'xref-find-definitions', but it looks for the identifier name at or
around the place of a mouse event.  This command is intended to be bound
to a mouse event, such as 'C-M-mouse-1', for example.

   The command 'C-M-.' ('xref-find-apropos') finds the definitions of
one or more identifiers that match a specified regular expression.  It
is just like 'M-.' except that it does regexp matching of identifiers
instead of matching symbol names as fixed strings.

   When any of the above commands finds more than one definition, it
presents the 'xref' buffer showing the definition candidates.  In that
buffer, you have several specialized commands, described in *note Xref
Commands::.

   To go back to places _from where_ you found the definition, use 'M-,'
('xref-pop-marker-stack').  It jumps back to the point of the last
invocation of 'M-.'.  Thus you can find and examine the definition of
something with 'M-.' and then return to where you were with 'M-,'.
'M-,' allows you to retrace your steps to a depth determined by the
variable 'xref-marker-ring-length', which defaults to 16.

   Some major modes install 'xref' support facilities that might
sometimes fail to find certain identifiers.  For example, in Emacs Lisp
mode (*note Lisp Eval::) 'M-.' will by default find only functions and
variables from Lisp packages which are loaded into the current Emacs
session or are auto-loaded (*note (elisp)Autoload::).  If 'M-.' fails to
find some identifiers, you can try forcing 'xref' to use the 'etags'
backend (*note Xref::).  To this end, turn on the Xref Etags minor mode
with 'M-x xref-etags-mode', then invoke 'M-.' again.  (For this to work,
be sure to run 'etags' to create the tags table in the directory tree of
the source files, see *note Create Tags Table::.)

==============================================================================
File: emacs.info,  Node: |Xref_Commands|,  Next: |Identifier_Search|,  Prev: |Looking_Up_Identifiers|,  Up: |Find_Identifiers|
==============================================================================

                                                                 *Xref_Commands*

28.4.1.2 Commands Available in the 'xref' Buffer
.....---------------------------------------------

The following commands are provided in the 'xref' buffer by the
special XREF mode:

'<RET>'
'mouse-2'
     Display the reference on the current line.

'n'
'.'
     Move to the next reference and display it in the other window
     ('xref-next-line').

'p'
','
     Move to the previous reference and display it in the other window
     ('xref-prev-line').

'C-o'
     Display the reference on the current line in the other window
     ('xref-show-location-at-point').

'<TAB>'
     Display the reference on the current line and bury the 'xref'
     buffer ('xref-quit-and-goto-xref').

'r PATTERN <RET> REPLACEMENT <RET>'
     Perform interactive query-replace on references that match PATTERN
     ('xref-query-replace-in-results'), replacing the match with
     REPLACEMENT.  *Note Identifier Search::.

'g'
     Refresh the contents of the 'xref' buffer ('xref-revert-buffer'.

'q'
     Quit the window showing the 'xref' buffer ('xref-quit').

   In addition, the usual navigation commands, such as the arrow keys,
'C-n', and 'C-p' are available for moving around the buffer without
displaying the references.

==============================================================================
File: emacs.info,  Node: |Identifier_Search|,  Next: |List_Identifiers|,  Prev: |Xref_Commands|,  Up: |Find_Identifiers|
==============================================================================

                                                             *Identifier_Search*

28.4.1.3 Searching and Replacing with Identifiers
.....--------------------------------------------

The commands in this section perform various search and replace
operations either on identifiers themselves or on files that reference
them.

'M-?'
     Find all the references for the identifier at point.

'M-x xref-query-replace-in-results <RET> REGEXP <RET> REPLACEMENT <RET>'
     Interactively replace REGEXP with REPLACEMENT in the names of all
     the identifiers shown in the 'xref' buffer.

'M-x tags-search <RET> REGEXP <RET>'
     Search for REGEXP through the files in the selected tags table.

'M-x tags-query-replace <RET> REGEXP <RET> REPLACEMENT <RET>'
     Perform a 'query-replace-regexp' on each file in the selected tags
     table.

'M-x fileloop-continue'
     Restart one of the last 2 commands above, from the current location
     of point.

   'M-?' finds all the references for the identifier at point, prompting
for the identifier as needed, with completion.  Depending on the current
backend (*note Xref::), the command may prompt even if it finds a valid
identifier at point.  When invoked with a prefix argument, it always
prompts for the identifier.  (If you want it to prompt always, customize
the value of the variable 'xref-prompt-for-identifier' to 't'; or set it
to 'nil' to prompt only if there's no usable identifier at point.)  The
command then presents the 'xref' buffer with all the references to the
identifier, showing the file name and the line where the identifier is
referenced.  The XREF mode commands are available in this buffer, see
*note Xref Commands::.

   'M-x xref-query-replace-in-results' reads a regexp to match
identifier names and a replacement string, just like ordinary 'M-x
query-replace-regexp'.  It then performs the specified replacement in
the names of the matching identifiers in all the places in all the files
where these identifiers are referenced.  This is useful when you rename
your identifiers as part of refactoring.  This command should be invoked
in the 'xref' buffer generated by 'M-?'.

   'M-x tags-search' reads a regexp using the minibuffer, then searches
for matches in all the files in the selected tags table, one file at a
time.  It displays the name of the file being searched so you can follow
its progress.  As soon as it finds an occurrence, 'tags-search' returns.
This command requires tags tables to be available (*note Tags Tables::).

   Having found one match with 'tags-search', you probably want to find
all the rest.  'M-x fileloop-continue' resumes the 'tags-search',
finding one more match.  This searches the rest of the current buffer,
followed by the remaining files of the tags table.

   'M-x tags-query-replace' performs a single 'query-replace-regexp'
through all the files in the tags table.  It reads a regexp to search
for and a string to replace with, just like ordinary 'M-x
query-replace-regexp'.  It searches much like 'M-x tags-search', but
repeatedly, processing matches according to your input.  *Note Query
Replace::, for more information on query replace.

   You can control the case-sensitivity of tags search commands by
customizing the value of the variable 'tags-case-fold-search'.  The
default is to use the same setting as the value of 'case-fold-search'
(*note Lax Search::).

   It is possible to get through all the files in the tags table with a
single invocation of 'M-x tags-query-replace'.  But often it is useful
to exit temporarily, which you can do with any input event that has no
special query replace meaning.  You can resume the query replace
subsequently by typing 'M-x fileloop-continue'; this command resumes the
last tags search or replace command that you did.  For instance, to skip
the rest of the current file, you can type 'M-> M-x fileloop-continue'.

   Note that the commands described above carry out much broader
searches than the 'xref-find-definitions' family.  The
'xref-find-definitions' commands search only for definitions of
identifiers that match your string or regexp.  The commands
'xref-find-references', 'tags-search', and 'tags-query-replace' find
every occurrence of the identifier or regexp, as ordinary search
commands and replace commands do in the current buffer.

   As an alternative to 'xref-find-references' and 'tags-search', you
can run 'grep' as a subprocess and have Emacs show you the matching
lines one by one.  *Note Grep Searching::.

==============================================================================
File: emacs.info,  Node: |List_Identifiers|,  Prev: |Identifier_Search|,  Up: |Find_Identifiers|
==============================================================================

                                                              *List_Identifiers*

28.4.1.4 Identifier Inquiries
.....------------------------

'C-M-i'
'M-<TAB>'
     Perform completion on the text around point, possibly using the
     selected tags table if one is loaded ('completion-at-point').

'M-x xref-find-apropos <RET> REGEXP <RET>'
     Display a list of all known identifiers matching REGEXP.

'M-x list-tags <RET> FILE <RET>'
     Display a list of the identifiers defined in the program file FILE.

'M-x tags-next-file'
     Visit files recorded in the selected tags table.

   In most programming language modes, you can type 'C-M-i' or 'M-<TAB>'
('completion-at-point') to complete the symbol at point.  Some modes
provide specialized completion for this command tailored to the mode;
for those that don't, if there is a tags table loaded, this command can
use it to generate completion candidates.  *Note Symbol Completion::.

   'M-x list-tags' reads the name of one of the files covered by the
selected tags table, and displays a list of tags defined in that file.
Do not include a directory as part of the file name unless the file name
recorded in the tags table includes a directory.  This command works
only with the etags backend, and requires a tags table for the project
to be available.  *Note Tags Tables::.  If used interactively, the
default tag is file name of the current buffer if used interactively.

   'M-x tags-next-file' visits files covered by the selected tags table.
The first time it is called, it visits the first file covered by the
table.  Each subsequent call visits the next covered file, unless a
prefix argument is supplied, in which case it returns to the first file.
This command requires a tags table to be selected.

==============================================================================
File: emacs.info,  Node: |Tags_Tables|,  Next: |Select_Tags_Table|,  Prev: |Find_Identifiers|,  Up: |Xref|
==============================================================================

                                                                   *Tags_Tables*

28.4.2 Tags Tables
------------------

A "tags table" records the tags(1) extracted by scanning the source code
of a certain program or a certain document.  Tags extracted from
generated files reference the original files, rather than the generated
files that were scanned during tag extraction.  Examples of generated
files include C files generated from Cweb source files, from a Yacc
parser, or from Lex scanner definitions; '.i' preprocessed C files; and
Fortran files produced by preprocessing '.fpp' source files.

   To produce a tags table, you run the 'etags' shell command on a
document or the source code file.  The 'etags' program writes the tags
to a "tags table file", or "tags file" in short.  The conventional name
for a tags file is 'TAGS'.  *Note Create Tags Table::.  (It is also
possible to create a tags table by using one of the commands from other
packages that can produce such tables in the same format.)

   Emacs uses the tags tables via the 'etags' package as one of the
supported backends for 'xref'.  Because tags tables are produced by the
'etags' command that is part of an Emacs distribution, we describe tags
tables in more detail here.

   The Ebrowse facility is similar to 'etags' but specifically tailored
for C++.  *Note Ebrowse: (ebrowse)Top.  The Semantic package provides
another way to generate and use tags, separate from the 'etags'
facility.  *Note Semantic::.

MENU

* |Tag_Syntax|::          Tag syntax for various types of code and text files.
* |Create_Tags_Table|::   Creating a tags table with 'etags'.
* |Etags_Regexps|::       Create arbitrary tags using regular expressions.

   ---------- Footnotes ----------

   (1) A "tag" is a synonym for identifier reference.  Commands and
features based on the 'etags' package traditionally use "tag" with this
meaning, and this subsection follows that tradition.

==============================================================================
File: emacs.info,  Node: |Tag_Syntax|,  Next: |Create_Tags_Table|,  Up: |Tags_Tables|
==============================================================================

                                                                    *Tag_Syntax*

28.4.2.1 Source File Tag Syntax
.....--------------------------

Here is how tag syntax is defined for the most popular languages:

   * In C code, any C function or typedef is a tag, and so are
     definitions of 'struct', 'union' and 'enum'.  '#define' macro
     definitions, '#undef' and 'enum' constants are also tags, unless
     you specify '--no-defines' when making the tags table.  Similarly,
     global variables are tags, unless you specify '--no-globals', and
     so are struct members, unless you specify '--no-members'.  Use of
     '--no-globals', '--no-defines' and '--no-members' can make the tags
     table file much smaller.

     You can tag function declarations and external variables in
     addition to function definitions by giving the '--declarations'
     option to 'etags'.

   * In C++ code, in addition to all the tag constructs of C code,
     member functions are also recognized; member variables are also
     recognized, unless you use the '--no-members' option.  'operator'
     definitions have tag names like 'operator+'.  If you specify the
     '--class-qualify' option, tags for variables and functions in
     classes are named 'CLASS::VARIABLE' and 'CLASS::FUNCTION'.  By
     default, class methods and members are not class-qualified, which
     allows to identify their names in the sources more accurately.

   * In Java code, tags include all the constructs recognized in C++,
     plus the 'interface', 'extends' and 'implements' constructs.  Tags
     for variables and functions in classes are named 'CLASS.VARIABLE'
     and 'CLASS.FUNCTION'.

   * In LaTeX documents, the arguments for '\chapter', '\section',
     '\subsection', '\subsubsection', '\eqno', '\label', '\ref',
     '\cite', '\bibitem', '\part', '\appendix', '\entry', '\index',
     '\def', '\newcommand', '\renewcommand', '\newenvironment' and
     '\renewenvironment' are tags.

     Other commands can make tags as well, if you specify them in the
     environment variable 'TEXTAGS' before invoking 'etags'.  The value
     of this environment variable should be a colon-separated list of
     command names.  For example,

          TEXTAGS="mycommand:myothercommand"
          export TEXTAGS

     specifies (using Bourne shell syntax) that the commands
     '\mycommand' and '\myothercommand' also define tags.

   * In Lisp code, any function defined with 'defun', any variable
     defined with 'defvar' or 'defconst', and in general the first
     argument of any expression that starts with '(def' in column zero
     is a tag.  As an exception, expressions of the form '(defvar FOO)'
     are treated as declarations, and are only tagged if the
     '--declarations' option is given.

   * In Scheme code, tags include anything defined with 'def' or with a
     construct whose name starts with 'def'.  They also include
     variables set with 'set!' at top level in the file.

   Several other languages are also supported:

   * In Ada code, functions, procedures, packages, tasks and types are
     tags.  Use the '--packages-only' option to create tags for packages
     only.

     In Ada, the same name can be used for different kinds of entity
     (e.g., for a procedure and for a function).  Also, for things like
     packages, procedures and functions, there is the spec (i.e., the
     interface) and the body (i.e., the implementation).  To make it
     easier to pick the definition you want, Ada tag names have suffixes
     indicating the type of entity:

     '/b'
          package body.
     '/f'
          function.
     '/k'
          task.
     '/p'
          procedure.
     '/s'
          package spec.
     '/t'
          type.

     Thus, 'M-x find-tag <RET> bidule/b <RET>' will go directly to the
     body of the package 'bidule', while 'M-x find-tag <RET> bidule
     <RET>' will just search for any tag 'bidule'.

   * In assembler code, labels appearing at the start of a line,
     followed by a colon, are tags.

   * In Bison or Yacc input files, each rule defines as a tag the
     nonterminal it constructs.  The portions of the file that contain C
     code are parsed as C code.

   * In Cobol code, tags are paragraph names; that is, any word starting
     in column 8 and followed by a period.

   * In Erlang code, the tags are the functions, records and macros
     defined in the file.

   * In Fortran code, functions, subroutines and block data are tags.

   * In Go code, packages, functions, and types are tags.

   * In HTML input files, the tags are the 'title' and the 'h1', 'h2',
     'h3' headers.  Also, tags are 'name=' in anchors and all
     occurrences of 'id='.

   * In Lua input files, all functions are tags.

   * In makefiles, targets are tags; additionally, variables are tags
     unless you specify '--no-globals'.

   * In Objective C code, tags include Objective C definitions for
     classes, class categories, methods and protocols.  Tags for
     variables and functions in classes are named 'CLASS::VARIABLE' and
     'CLASS::FUNCTION'.

   * In Pascal code, the tags are the functions and procedures defined
     in the file.

   * In Perl code, the tags are the packages, subroutines and variables
     defined by the 'package', 'sub', 'use constant', 'my', and 'local'
     keywords.  Use '--globals' if you want to tag global variables.
     Tags for subroutines are named 'PACKAGE::SUB'.  The name for
     subroutines defined in the default package is 'main::SUB'.

   * In PHP code, tags are functions, classes and defines.  Vars are
     tags too, unless you use the '--no-members' option.

   * In PostScript code, the tags are the functions.

   * In Prolog code, tags are predicates and rules at the beginning of
     line.

   * In Python code, 'def' or 'class' at the beginning of a line
     generate a tag.

   * In Ruby code, 'def' or 'class' or 'module' at the beginning of a
     line generate a tag.  Constants also generate tags.

   You can also generate tags based on regexp matching (*note Etags
Regexps::) to handle other formats and languages.

==============================================================================
File: emacs.info,  Node: |Create_Tags_Table|,  Next: |Etags_Regexps|,  Prev: |Tag_Syntax|,  Up: |Tags_Tables|
==============================================================================

                                                             *Create_Tags_Table*

28.4.2.2 Creating Tags Tables
.....------------------------

The 'etags' program is used to create a tags table file.  It knows the
syntax of several languages, as described in *note Tag Syntax::.  Here
is how to run 'etags':

     etags INPUTFILES...

The 'etags' program reads the specified files, and writes a tags table
named 'TAGS' in the current working directory.  You can optionally
specify a different file name for the tags table by using the
'--output=FILE' option; specifying '-' as a file name prints the tags
table to standard output.  You can also append the newly created tags
table to an existing file by using the '--append' option.

   If the specified files don't exist, 'etags' looks for compressed
versions of them and uncompresses them to read them.  Under MS-DOS,
'etags' also looks for file names like 'mycode.cgz' if it is given
'mycode.c' on the command line and 'mycode.c' does not exist.

   If the tags table becomes outdated due to changes in the files
described in it, you can update it by running the 'etags' program again.
If the tags table does not record a tag, or records it for the wrong
file, then Emacs will not be able to find that definition until you
update the tags table.  But if the position recorded in the tags table
becomes a little bit wrong (due to other editing), Emacs will still be
able to find the right position, with a slight delay.

   Thus, there is no need to update the tags table after each edit.  You
should update a tags table when you define new tags that you want to
have listed, or when you move tag definitions from one file to another,
or when changes become substantial.

   You can make a tags table "include" another tags table, by passing
the '--include=FILE' option to 'etags'.  It then covers all the files
covered by the included tags file, as well as its own.

   If you specify the source files with relative file names when you run
'etags', the tags file will contain file names relative to the directory
where the tags file was initially written.  This way, you can move an
entire directory tree containing both the tags file and the source
files, and the tags file will still refer correctly to the source files.
If the tags file is '-' or is in the '/dev' directory, however, the file
names are made relative to the current working directory.  This is
useful, for example, when writing the tags to the standard output.

   When using a relative file name, it should not be a symbolic link
pointing to a tags file in a different directory, because this would
generally render the file names invalid.

   If you specify absolute file names as arguments to 'etags', then the
tags file will contain absolute file names.  This way, the tags file
will still refer to the same files even if you move it, as long as the
source files remain in the same place.  Absolute file names start with
'/', or with 'DEVICE:/' on MS-DOS and MS-Windows.

   When you want to make a tags table from a great number of files, you
may have problems listing them on the command line, because some systems
have a limit on its length.  You can circumvent this limit by telling
'etags' to read the file names from its standard input, by typing a dash
in place of the file names, like this:

     find . -name "*.[chCH]" -print | etags -

   'etags' recognizes the language used in an input file based on its
file name and contents.  It first tries to match the file's name and
extension to the ones commonly used with certain languages.  Some
languages have interpreters with known names (e.g., 'perl' for Perl or
'pl' for Prolog), so 'etags' next looks for an interpreter specification
of the form '#!INTERP' on the first line of an input file, and matches
that against known interpreters.  If none of that works, or if you want
to override the automatic detection of the language, you can specify the
language explicitly with the '--language=NAME' option.  You can intermix
these options with file names; each one applies to the file names that
follow it.  Specify '--language=auto' to tell 'etags' to resume guessing
the language from the file names and file contents.  Specify
'--language=none' to turn off language-specific processing entirely;
then 'etags' recognizes tags by regexp matching alone (*note Etags
Regexps::).  This comes in handy when an input file uses a language not
yet supported by 'etags', and you want to avoid having 'etags' fall back
on Fortran and C as the default languages.

   The option '--parse-stdin=FILE' is mostly useful when calling 'etags'
from programs.  It can be used (only once) in place of a file name on
the command line.  'etags' will read from standard input and mark the
produced tags as belonging to the file FILE.

   'etags --help' outputs the list of the languages 'etags' knows, and
the file name rules for guessing the language.  It also prints a list of
all the available 'etags' options, together with a short explanation.
If followed by one or more '--language=LANG' options, it outputs
detailed information about how tags are generated for LANG.

==============================================================================
File: emacs.info,  Node: |Etags_Regexps|,  Prev: |Create_Tags_Table|,  Up: |Tags_Tables|
==============================================================================

                                                                 *Etags_Regexps*

28.4.2.3 Etags Regexps
.....-----------------

The '--regex' option to 'etags' allows tags to be recognized by regular
expression matching.  You can intermix this option with file names; each
one applies to the source files that follow it.  If you specify multiple
'--regex' options, all of them are used in parallel.  The syntax is:

     --regex=[{LANGUAGE}]/TAGREGEXP/[NAMEREGEXP/]MODIFIERS

The essential part of the option value is TAGREGEXP, the regexp for
matching tags.  It is always used anchored, that is, it only matches at
the beginning of a line.  If you want to allow indented tags, use a
regexp that matches initial whitespace; start it with '[ \t]*'.

   In these regular expressions, '\' quotes the next character, and all
the C character escape sequences are supported: '\a' for bell, '\b' for
back space, '\e' for escape, '\f' for formfeed, '\n' for newline, '\r'
for carriage return, '\t' for tab, and '\v' for vertical tab.  In
addition, '\d' stands for the 'DEL' character.

   Ideally, TAGREGEXP should not match more characters than are needed
to recognize what you want to tag.  If the syntax requires you to write
TAGREGEXP so it matches more characters beyond the tag itself, you
should add a NAMEREGEXP, to pick out just the tag.  This will enable
Emacs to find tags more accurately and to do completion on tag names
more reliably.  In NAMEREGEXP, it is frequently convenient to use "back
references" (*note Regexp Backslash::) to parenthesized groupings
'\( ... \)' in TAGREGEXP.  For example, '\1' refers to the first such
parenthesized grouping.  You can find some examples of this below.

   The MODIFIERS are a sequence of zero or more characters that modify
the way 'etags' does the matching.  A regexp with no modifiers is
applied sequentially to each line of the input file, in a case-sensitive
way.  The modifiers and their meanings are:

'i'
     Ignore case when matching this regexp.
'm'
     Match this regular expression against the whole file, so that
     multi-line matches are possible.
's'
     Match this regular expression against the whole file, and allow '.'
     in TAGREGEXP to match newlines.

   The '-R' option cancels all the regexps defined by preceding
'--regex' options.  It too applies to the file names following it.
Here's an example:

     etags --regex=/REG1/i voo.doo --regex=/REG2/m \
         bar.ber -R --lang=lisp los.er

Here 'etags' chooses the parsing language for 'voo.doo' and 'bar.ber'
according to their contents.  'etags' also uses REG1 to recognize
additional tags in 'voo.doo', and both REG1 and REG2 to recognize
additional tags in 'bar.ber'.  REG1 is checked against each line of
'voo.doo' and 'bar.ber', in a case-insensitive way, while REG2 is
checked against the whole 'bar.ber' file, permitting multi-line matches,
in a case-sensitive way.  'etags' uses only the Lisp tags rules, with no
user-specified regexp matching, to recognize tags in 'los.er'.

   You can restrict a '--regex' option to match only files of a given
language by using the optional prefix {LANGUAGE}.  ('etags --help'
prints the list of languages recognized by 'etags'.)  This is
particularly useful when storing many predefined regular expressions for
'etags' in a file.  The following example tags the 'DEFVAR' macros in
the Emacs source files, for the C language only:

     --regex='{c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/'

When you have complex regular expressions, you can store the list of
them in a file.  The following option syntax instructs 'etags' to read
two files of regular expressions.  The regular expressions contained in
the second file are matched without regard to case.

     --regex=@CASE-SENSITIVE-FILE --ignore-case-regex=@IGNORE-CASE-FILE

A regex file for 'etags' contains one regular expression per line.
Empty lines, and lines beginning with space or tab are ignored.  When
the first character in a line is '@', 'etags' assumes that the rest of
the line is the name of another file of regular expressions; thus, one
such file can include another file.  All the other lines are taken to be
regular expressions.  If the first non-whitespace text on the line is
'--', that line is a comment.

   For example, we can create a file called 'emacs.tags' with the
following contents:

             -- This is for GNU Emacs C source files
     {c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/

and then use it like this:

     etags --regex=@emacs.tags .[ch] /*.[ch]

   Here are some more examples.  The regexps are quoted to protect them
from shell interpretation.

   * Tag Octave files:

          etags --language=none \
                --regex='/[ \t]function.=[ \t]*\([^ \t]*\)[ \t]*(/\1/' \
                --regex='/###key \(.*\)/\1/' \
                --regex='/[ \t]*global[ \t].*/' \
                *.m

     Note that tags are not generated for scripts, so that you have to
     add a line by yourself of the form '###key SCRIPTNAME' if you want
     to jump to it.

   * Tag Tcl files:

          etags --language=none --regex='/proc[ \t]+\([^ \t]+\)/\1/' *.tcl

   * Tag VHDL files:

          etags --language=none \
            --regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/' \
            --regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
            \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'

==============================================================================
File: emacs.info,  Node: |Select_Tags_Table|,  Prev: Tags Tables,  Up: |Xref|
==============================================================================

                                                             *Select_Tags_Table*

28.4.3 Selecting a Tags Table
-----------------------------

Emacs has at any time at most one "selected" tags table.  All the
commands for working with tags tables use the selected one.  To select a
tags table, type 'M-x visit-tags-table', which reads the tags table file
name as an argument, with 'TAGS' defaulting to the first directory that
contains a file named 'TAGS' encountered when recursively searching
upward from the default directory.

   Emacs does not actually read in the tags table contents until you try
to use them; all 'visit-tags-table' does is store the file name in the
variable 'tags-file-name', and not much more.  The variable's initial
value is 'nil'; that value tells all the commands for working with tags
tables that they must ask for a tags table file name to use.

   Using 'visit-tags-table' when a tags table is already loaded gives
you a choice: you can add the new tags table to the current list of tags
tables, or start a new list.  The tags commands use all the tags tables
in the current list.  If you start a new list, the new tags table is
used _instead_ of others.  If you add the new table to the current list,
it is used _as well as_ the others.

   You can specify a precise list of tags tables by setting the variable
'tags-table-list' to a list of strings, like this:

     (setq tags-table-list
           '("~/.emacs.d" "/usr/local/lib/emacs/src"))

This tells the tags commands to look at the 'TAGS' files in your
'~/.emacs.d' directory and in the '/usr/local/lib/emacs/src' directory.
The order depends on which file you are in and which tags table mentions
that file.

   Do not set both 'tags-file-name' and 'tags-table-list'.

==============================================================================
File: emacs.info,  Node: |EDE|,  Next: |Emerge|,  Prev: |Xref|,  Up: |Maintaining|
==============================================================================

                                                                           *EDE*

28.5 Emacs Development Environment
=====-----------------------------

EDE ("Emacs Development Environment") is a package that simplifies the
task of creating, building, and debugging large programs with Emacs.  It
provides some of the features of an IDE, or "Integrated Development
Environment", in Emacs.

   This section provides a brief description of EDE usage.  For full
details, see *note EDE: (ede)Top.

   EDE is implemented as a global minor mode (*note Minor Modes::).  To
enable it, type 'M-x global-ede-mode' or click on the 'Project Support
(EDE)' item in the 'Tools' menu.  You can also enable EDE each time you
start Emacs, by adding the following line to your initialization file:

     (global-ede-mode t)

Activating EDE adds a menu named 'Development' to the menu bar.  Many
EDE commands, including the ones described below, can be invoked from
this menu.

   EDE organizes files into "projects", which correspond to directory
trees.  The "project root" is the topmost directory of a project.  To
define a new project, visit a file in the desired project root and type
'M-x ede-new'.  This command prompts for a "project type", which refers
to the underlying method that EDE will use to manage the project (*note
EDE: (ede)Creating a project.).  The most common project types are
'Make', which uses Makefiles, and 'Automake', which uses GNU Automake
(*note Automake: (automake)Top.).  In both cases, EDE also creates a
file named 'Project.ede', which stores information about the project.

   A project may contain one or more "targets".  A target can be an
object file, executable program, or some other type of file, which is
built from one or more of the files in the project.

   To add a new "target" to a project, type 'C-c . t' ('M-x
ede-new-target').  This command also asks if you wish to add the current
file to that target, which means that the target is to be built from
that file.  After you have defined a target, you can add more files to
it by typing 'C-c . a' ('ede-add-file').

   To build a target, type 'C-c . c' ('ede-compile-target').  To build
all the targets in the project, type 'C-c . C' ('ede-compile-project').
EDE uses the file types to guess how the target should be built.

==============================================================================
File: emacs.info,  Node: |Emerge|,  Prev: |EDE|,  Up: |Maintaining|
==============================================================================

                                                                        *Emerge*

28.6 Merging Files with Emerge
=====-------------------------

It's not unusual for programmers to get their signals crossed and modify
the same program in two different directions.  To recover from this
confusion, you need to merge the two versions.  Emerge makes this
easier.  For other ways to compare files, see *note Comparing Files::,
and *note Ediff: (ediff)Top.

MENU

* |Overview_of_Emerge|::     How to start Emerge.  Basic concepts.
* |Submodes_of_Emerge|::     Fast mode vs. Edit mode.
                             Skip Prefers mode and Auto Advance mode.
* |State_of_Difference|::    You do the merge by specifying state A or B
                             for each difference.
* |Merge_Commands|::         Commands for selecting a difference,
                             changing states of differences, etc.
* |Exiting_Emerge|::         What to do when you've finished the merge.
* |Combining_in_Emerge|::    How to keep both alternatives for a difference.
* |Fine_Points_of_Emerge|::  Miscellaneous issues.

==============================================================================
File: emacs.info,  Node: |Overview_of_Emerge|,  Next: |Submodes_of_Emerge|,  Up: |Emerge|
==============================================================================

                                                            *Overview_of_Emerge*

28.6.1 Overview of Emerge
-------------------------

To start Emerge, run one of these four commands:

'M-x emerge-files'
     Merge two specified files.

'M-x emerge-files-with-ancestor'
     Merge two specified files, with reference to a common ancestor.

'M-x emerge-buffers'
     Merge two buffers.

'M-x emerge-buffers-with-ancestor'
     Merge two buffers with reference to a common ancestor in a third
     buffer.

   The Emerge commands compare two files or buffers, and display the
comparison in three buffers: one for each input text (the "A buffer" and
the "B buffer"), and one (the "merge buffer") where merging takes place.
The merge buffer shows the full merged text, not just the differences.
Wherever the two input texts differ, you can choose which one of them to
include in the merge buffer.

   The Emerge commands that take input from existing buffers use only
the accessible portions of those buffers, if they are narrowed.  *Note
Narrowing::.

   If a common ancestor version is available, from which the two texts
to be merged were both derived, Emerge can use it to guess which
alternative is right.  Wherever one current version agrees with the
ancestor, Emerge presumes that the other current version is a deliberate
change which should be kept in the merged version.  Use the
'with-ancestor' commands if you want to specify a common ancestor text.
These commands read three file or buffer names--variant A, variant B, and
the common ancestor.

   After the comparison is done and the buffers are prepared, the
interactive merging starts.  You control the merging by typing special
"merge commands" in the merge buffer (*note Merge Commands::).  For each
run of differences between the input texts, you can choose which one of
them to keep, or edit them both together.

   The merge buffer uses a special major mode, Emerge mode, with
commands for making these choices.  But you can also edit the buffer
with ordinary Emacs commands.

   At any given time, the attention of Emerge is focused on one
particular difference, called the "selected" difference.  This
difference is marked off in the three buffers like this:

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

Emerge numbers all the differences sequentially and the mode line always
shows the number of the selected difference.

   Normally, the merge buffer starts out with the A version of the text.
But when the A version of a difference agrees with the common ancestor,
then the B version is initially preferred for that difference.

   Emerge leaves the merged text in the merge buffer when you exit.  At
that point, you can save it in a file with 'C-x C-w'.  If you give a
numeric argument to 'emerge-files' or 'emerge-files-with-ancestor', it
reads the name of the output file using the minibuffer.  (This is the
last file name those commands read.)  Then exiting from Emerge saves the
merged text in the output file.

   Normally, Emerge commands save the output buffer in its file when you
exit.  If you abort Emerge with 'C-]', the Emerge command does not save
the output buffer, but you can save it yourself if you wish.

==============================================================================
File: emacs.info,  Node: |Submodes_of_Emerge|,  Next: |State_of_Difference|,  Prev: |Overview_of_Emerge|,  Up: |Emerge|
==============================================================================

                                                            *Submodes_of_Emerge*

28.6.2 Submodes of Emerge
-------------------------

You can choose between two modes for giving merge commands: Fast mode
and Edit mode.  In Fast mode, basic merge commands are single
characters, but ordinary Emacs commands are disabled.  This is
convenient if you use only merge commands.  In Edit mode, all merge
commands start with the prefix key 'C-c C-c', and the normal Emacs
commands are also available.  This allows editing the merge buffer, but
slows down Emerge operations.

   Use 'e' to switch to Edit mode, and 'C-c C-c f' to switch to Fast
mode.  The mode line indicates Edit and Fast modes with 'E' and 'F'.

   Emerge has two additional submodes that affect how particular merge
commands work: Auto Advance mode and Skip Prefers mode.

   If Auto Advance mode is in effect, the 'a' and 'b' commands advance
to the next difference.  This lets you go through the merge faster as
long as you simply choose one of the alternatives from the input.  The
mode line indicates Auto Advance mode with 'A'.

   If Skip Prefers mode is in effect, the 'n' and 'p' commands skip over
differences in states "prefer-A" and "prefer-B" (*note State of
Difference::).  Thus you see only differences for which neither version
is presumed correct.  The mode line indicates Skip Prefers mode with
'S'.  This mode is only relevant when there is an ancestor.

   Use the command 's a' ('emerge-auto-advance') to set or clear Auto
Advance mode.  Use 's s' ('emerge-skip-prefers') to set or clear Skip
Prefers mode.  These commands turn on the mode with a positive argument,
turn it off with a negative or zero argument, and toggle the mode with
no argument.

==============================================================================
File: emacs.info,  Node: |State_of_Difference|,  Next: |Merge_Commands|,  Prev: |Submodes_of_Emerge|,  Up: |Emerge|
==============================================================================

                                                           *State_of_Difference*

28.6.3 State of a Difference
----------------------------

In the merge buffer, a difference is marked with lines of 'v' and '^'
characters.  Each difference has one of these seven states:

A
     The difference is showing the A version.  The 'a' command always
     produces this state; the mode line indicates it with 'A'.

B
     The difference is showing the B version.  The 'b' command always
     produces this state; the mode line indicates it with 'B'.
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
