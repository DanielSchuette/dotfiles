     'MISALIGNED_INDIRECT_REF' expression.

'load_multiple'
     Load several consecutive memory locations into consecutive
     registers.  Operand 0 is the first of the consecutive registers,
     operand 1 is the first memory location, and operand 2 is a
     constant: the number of consecutive registers.

     Define this only if the target machine really has such an
     instruction; do not define this if the most efficient way of
     loading consecutive registers from memory is to do them one at a
     time.

     On some machines, there are restrictions as to which consecutive
     registers can be stored into memory, such as particular starting or
     ending register numbers or only a range of valid counts.  For those
     machines, use a 'define_expand' (*note Expander Definitions::) and
     make the pattern fail if the restrictions are not met.

     Write the generated insn as a 'parallel' with elements being a
     'set' of one register from the appropriate memory location (you may
     also need 'use' or 'clobber' elements).  Use a 'match_parallel'
     (*note RTL Template::) to recognize the insn.  See 'rs6000.md' for
     examples of the use of this insn pattern.

'store_multiple'
     Similar to 'load_multiple', but store several consecutive registers
     into consecutive memory locations.  Operand 0 is the first of the
     consecutive memory locations, operand 1 is the first register, and
     operand 2 is a constant: the number of consecutive registers.

'vec_load_lanesMN'
     Perform an interleaved load of several vectors from memory operand
     1 into register operand 0.  Both operands have mode M.  The
     register operand is viewed as holding consecutive vectors of mode
     N, while the memory operand is a flat array that contains the same
     number of elements.  The operation is equivalent to:

          int c = GET_MODE_SIZE (M) / GET_MODE_SIZE (N);
          for (j = 0; j < GET_MODE_NUNITS (N); j++)
            for (i = 0; i < c; i++)
              operand0[i][j] = operand1[j * c + i];

     For example, 'vec_load_lanestiv4hi' loads 8 16-bit values from
     memory into a register of mode 'TI'.  The register contains two
     consecutive vectors of mode 'V4HI'.

     This pattern can only be used if:
          TARGET_ARRAY_MODE_SUPPORTED_P (N, C)
     is true.  GCC assumes that, if a target supports this kind of
     instruction for some mode N, it also supports unaligned loads for
     vectors of mode N.

     This pattern is not allowed to 'FAIL'.

'vec_mask_load_lanesMN'
     Like 'vec_load_lanesMN', but takes an additional mask operand
     (operand 2) that specifies which elements of the destination
     vectors should be loaded.  Other elements of the destination
     vectors are set to zero.  The operation is equivalent to:

          int c = GET_MODE_SIZE (M) / GET_MODE_SIZE (N);
          for (j = 0; j < GET_MODE_NUNITS (N); j++)
            if (operand2[j])
              for (i = 0; i < c; i++)
                operand0[i][j] = operand1[j * c + i];
            else
              for (i = 0; i < c; i++)
                operand0[i][j] = 0;

     This pattern is not allowed to 'FAIL'.

'vec_store_lanesMN'
     Equivalent to 'vec_load_lanesMN', with the memory and register
     operands reversed.  That is, the instruction is equivalent to:

          int c = GET_MODE_SIZE (M) / GET_MODE_SIZE (N);
          for (j = 0; j < GET_MODE_NUNITS (N); j++)
            for (i = 0; i < c; i++)
              operand0[j * c + i] = operand1[i][j];

     for a memory operand 0 and register operand 1.

     This pattern is not allowed to 'FAIL'.

'vec_mask_store_lanesMN'
     Like 'vec_store_lanesMN', but takes an additional mask operand
     (operand 2) that specifies which elements of the source vectors
     should be stored.  The operation is equivalent to:

          int c = GET_MODE_SIZE (M) / GET_MODE_SIZE (N);
          for (j = 0; j < GET_MODE_NUNITS (N); j++)
            if (operand2[j])
              for (i = 0; i < c; i++)
                operand0[j * c + i] = operand1[i][j];

     This pattern is not allowed to 'FAIL'.

'gather_loadMN'
     Load several separate memory locations into a vector of mode M.
     Operand 1 is a scalar base address and operand 2 is a vector of
     mode N containing offsets from that base.  Operand 0 is a
     destination vector with the same number of elements as N.  For each
     element index I:

        * extend the offset element I to address width, using zero
          extension if operand 3 is 1 and sign extension if operand 3 is
          zero;
        * multiply the extended offset by operand 4;
        * add the result to the base; and
        * load the value at that address into element I of operand 0.

     The value of operand 3 does not matter if the offsets are already
     address width.

'mask_gather_loadMN'
     Like 'gather_loadMN', but takes an extra mask operand as operand 5.
     Bit I of the mask is set if element I of the result should be
     loaded from memory and clear if element I of the result should be
     set to zero.

'scatter_storeMN'
     Store a vector of mode M into several distinct memory locations.
     Operand 0 is a scalar base address and operand 1 is a vector of
     mode N containing offsets from that base.  Operand 4 is the vector
     of values that should be stored, which has the same number of
     elements as N.  For each element index I:

        * extend the offset element I to address width, using zero
          extension if operand 2 is 1 and sign extension if operand 2 is
          zero;
        * multiply the extended offset by operand 3;
        * add the result to the base; and
        * store element I of operand 4 to that address.

     The value of operand 2 does not matter if the offsets are already
     address width.

'mask_scatter_storeMN'
     Like 'scatter_storeMN', but takes an extra mask operand as operand
     5.  Bit I of the mask is set if element I of the result should be
     stored to memory.

'vec_setM'
     Set given field in the vector value.  Operand 0 is the vector to
     modify, operand 1 is new value of field and operand 2 specify the
     field index.

'vec_extractMN'
     Extract given field from the vector value.  Operand 1 is the
     vector, operand 2 specify field index and operand 0 place to store
     value into.  The N mode is the mode of the field or vector of
     fields that should be extracted, should be either element mode of
     the vector mode M, or a vector mode with the same element mode and
     smaller number of elements.  If N is a vector mode, the index is
     counted in units of that mode.

'vec_initMN'
     Initialize the vector to given values.  Operand 0 is the vector to
     initialize and operand 1 is parallel containing values for
     individual fields.  The N mode is the mode of the elements, should
     be either element mode of the vector mode M, or a vector mode with
     the same element mode and smaller number of elements.

'vec_duplicateM'
     Initialize vector output operand 0 so that each element has the
     value given by scalar input operand 1.  The vector has mode M and
     the scalar has the mode appropriate for one element of M.

     This pattern only handles duplicates of non-constant inputs.
     Constant vectors go through the 'movM' pattern instead.

     This pattern is not allowed to 'FAIL'.

'vec_seriesM'
     Initialize vector output operand 0 so that element I is equal to
     operand 1 plus I times operand 2.  In other words, create a linear
     series whose base value is operand 1 and whose step is operand 2.

     The vector output has mode M and the scalar inputs have the mode
     appropriate for one element of M.  This pattern is not used for
     floating-point vectors, in order to avoid having to specify the
     rounding behavior for I > 1.

     This pattern is not allowed to 'FAIL'.

'while_ultMN'
     Set operand 0 to a mask that is true while incrementing operand 1
     gives a value that is less than operand 2.  Operand 0 has mode N
     and operands 1 and 2 are scalar integers of mode M.  The operation
     is equivalent to:

          operand0[0] = operand1 < operand2;
          for (i = 1; i < GET_MODE_NUNITS (N); i++)
            operand0[i] = operand0[i - 1] && (operand1 + i < operand2);

'check_raw_ptrsM'
     Check whether, given two pointers A and B and a length LEN, a write
     of LEN bytes at A followed by a read of LEN bytes at B can be split
     into interleaved byte accesses 'A[0], B[0], A[1], B[1], ...'
     without affecting the dependencies between the bytes.  Set operand
     0 to true if the split is possible and false otherwise.

     Operands 1, 2 and 3 provide the values of A, B and LEN
     respectively.  Operand 4 is a constant integer that provides the
     known common alignment of A and B.  All inputs have mode M.

     This split is possible if:

          A == B || A + LEN <= B || B + LEN <= A

     You should only define this pattern if the target has a way of
     accelerating the test without having to do the individual
     comparisons.

'check_war_ptrsM'
     Like 'check_raw_ptrsM', but with the read and write swapped round.
     The split is possible in this case if:

          B <= A || A + LEN <= B

'vec_cmpMN'
     Output a vector comparison.  Operand 0 of mode N is the destination
     for predicate in operand 1 which is a signed vector comparison with
     operands of mode M in operands 2 and 3.  Predicate is computed by
     element-wise evaluation of the vector comparison with a truth value
     of all-ones and a false value of all-zeros.

'vec_cmpuMN'
     Similar to 'vec_cmpMN' but perform unsigned vector comparison.

'vec_cmpeqMN'
     Similar to 'vec_cmpMN' but perform equality or non-equality vector
     comparison only.  If 'vec_cmpMN' or 'vec_cmpuMN' instruction
     pattern is supported, it will be preferred over 'vec_cmpeqMN', so
     there is no need to define this instruction pattern if the others
     are supported.

'vcondMN'
     Output a conditional vector move.  Operand 0 is the destination to
     receive a combination of operand 1 and operand 2, which are of mode
     M, dependent on the outcome of the predicate in operand 3 which is
     a signed vector comparison with operands of mode N in operands 4
     and 5.  The modes M and N should have the same size.  Operand 0
     will be set to the value OP1 & MSK | OP2 & ~MSK where MSK is
     computed by element-wise evaluation of the vector comparison with a
     truth value of all-ones and a false value of all-zeros.

'vconduMN'
     Similar to 'vcondMN' but performs unsigned vector comparison.

'vcondeqMN'
     Similar to 'vcondMN' but performs equality or non-equality vector
     comparison only.  If 'vcondMN' or 'vconduMN' instruction pattern is
     supported, it will be preferred over 'vcondeqMN', so there is no
     need to define this instruction pattern if the others are
     supported.

'vcond_mask_MN'
     Similar to 'vcondMN' but operand 3 holds a pre-computed result of
     vector comparison.

'maskloadMN'
     Perform a masked load of vector from memory operand 1 of mode M
     into register operand 0.  Mask is provided in register operand 2 of
     mode N.

     This pattern is not allowed to 'FAIL'.

'maskstoreMN'
     Perform a masked store of vector from register operand 1 of mode M
     into memory operand 0.  Mask is provided in register operand 2 of
     mode N.

     This pattern is not allowed to 'FAIL'.

'vec_permM'
     Output a (variable) vector permutation.  Operand 0 is the
     destination to receive elements from operand 1 and operand 2, which
     are of mode M.  Operand 3 is the "selector".  It is an integral
     mode vector of the same width and number of elements as mode M.

     The input elements are numbered from 0 in operand 1 through 2*N-1
     in operand 2.  The elements of the selector must be computed modulo
     2*N.  Note that if 'rtx_equal_p(operand1, operand2)', this can be
     implemented with just operand 1 and selector elements modulo N.

     In order to make things easy for a number of targets, if there is
     no 'vec_perm' pattern for mode M, but there is for mode Q where Q
     is a vector of 'QImode' of the same width as M, the middle-end will
     lower the mode M 'VEC_PERM_EXPR' to mode Q.

     See also 'TARGET_VECTORIZER_VEC_PERM_CONST', which performs the
     analogous operation for constant selectors.

'pushM1'
     Output a push instruction.  Operand 0 is value to push.  Used only
     when 'PUSH_ROUNDING' is defined.  For historical reason, this
     pattern may be missing and in such case an 'mov' expander is used
     instead, with a 'MEM' expression forming the push operation.  The
     'mov' expander method is deprecated.

'addM3'
     Add operand 2 and operand 1, storing the result in operand 0.  All
     operands must have mode M.  This can be used even on two-address
     machines, by means of constraints requiring operands 1 and 0 to be
     the same location.

'ssaddM3', 'usaddM3'
'subM3', 'sssubM3', 'ussubM3'
'mulM3', 'ssmulM3', 'usmulM3'
'divM3', 'ssdivM3'
'udivM3', 'usdivM3'
'modM3', 'umodM3'
'uminM3', 'umaxM3'
'andM3', 'iorM3', 'xorM3'
     Similar, for other arithmetic operations.

'addvM4'
     Like 'addM3' but takes a 'code_label' as operand 3 and emits code
     to jump to it if signed overflow occurs during the addition.  This
     pattern is used to implement the built-in functions performing
     signed integer addition with overflow checking.

'subvM4', 'mulvM4'
     Similar, for other signed arithmetic operations.

'uaddvM4'
     Like 'addvM4' but for unsigned addition.  That is to say, the
     operation is the same as signed addition but the jump is taken only
     on unsigned overflow.

'usubvM4', 'umulvM4'
     Similar, for other unsigned arithmetic operations.

'addptrM3'
     Like 'addM3' but is guaranteed to only be used for address
     calculations.  The expanded code is not allowed to clobber the
     condition code.  It only needs to be defined if 'addM3' sets the
     condition code.  If adds used for address calculations and normal
     adds are not compatible it is required to expand a distinct pattern
     (e.g. using an unspec).  The pattern is used by LRA to emit address
     calculations.  'addM3' is used if 'addptrM3' is not defined.

'fmaM4'
     Multiply operand 2 and operand 1, then add operand 3, storing the
     result in operand 0 without doing an intermediate rounding step.
     All operands must have mode M.  This pattern is used to implement
     the 'fma', 'fmaf', and 'fmal' builtin functions from the ISO C99
     standard.

'fmsM4'
     Like 'fmaM4', except operand 3 subtracted from the product instead
     of added to the product.  This is represented in the rtl as

          (fma:M OP1 OP2 (neg:M OP3))

'fnmaM4'
     Like 'fmaM4' except that the intermediate product is negated before
     being added to operand 3.  This is represented in the rtl as

          (fma:M (neg:M OP1) OP2 OP3)

'fnmsM4'
     Like 'fmsM4' except that the intermediate product is negated before
     subtracting operand 3.  This is represented in the rtl as

          (fma:M (neg:M OP1) OP2 (neg:M OP3))

'sminM3', 'smaxM3'
     Signed minimum and maximum operations.  When used with floating
     point, if both operands are zeros, or if either operand is 'NaN',
     then it is unspecified which of the two operands is returned as the
     result.

'fminM3', 'fmaxM3'
     IEEE-conformant minimum and maximum operations.  If one operand is
     a quiet 'NaN', then the other operand is returned.  If both
     operands are quiet 'NaN', then a quiet 'NaN' is returned.  In the
     case when gcc supports signaling 'NaN' (-fsignaling-nans) an
     invalid floating point exception is raised and a quiet 'NaN' is
     returned.

     All operands have mode M, which is a scalar or vector
     floating-point mode.  These patterns are not allowed to 'FAIL'.

'reduc_smin_scal_M', 'reduc_smax_scal_M'
     Find the signed minimum/maximum of the elements of a vector.  The
     vector is operand 1, and operand 0 is the scalar result, with mode
     equal to the mode of the elements of the input vector.

'reduc_umin_scal_M', 'reduc_umax_scal_M'
     Find the unsigned minimum/maximum of the elements of a vector.  The
     vector is operand 1, and operand 0 is the scalar result, with mode
     equal to the mode of the elements of the input vector.

'reduc_plus_scal_M'
     Compute the sum of the elements of a vector.  The vector is operand
     1, and operand 0 is the scalar result, with mode equal to the mode
     of the elements of the input vector.

'reduc_and_scal_M'
'reduc_ior_scal_M'
'reduc_xor_scal_M'
     Compute the bitwise 'AND'/'IOR'/'XOR' reduction of the elements of
     a vector of mode M.  Operand 1 is the vector input and operand 0 is
     the scalar result.  The mode of the scalar result is the same as
     one element of M.

'extract_last_M'
     Find the last set bit in mask operand 1 and extract the associated
     element of vector operand 2.  Store the result in scalar operand 0.
     Operand 2 has vector mode M while operand 0 has the mode
     appropriate for one element of M.  Operand 1 has the usual mask
     mode for vectors of mode M; see 'TARGET_VECTORIZE_GET_MASK_MODE'.

'fold_extract_last_M'
     If any bits of mask operand 2 are set, find the last set bit,
     extract the associated element from vector operand 3, and store the
     result in operand 0.  Store operand 1 in operand 0 otherwise.
     Operand 3 has mode M and operands 0 and 1 have the mode appropriate
     for one element of M.  Operand 2 has the usual mask mode for
     vectors of mode M; see 'TARGET_VECTORIZE_GET_MASK_MODE'.

'fold_left_plus_M'
     Take scalar operand 1 and successively add each element from vector
     operand 2.  Store the result in scalar operand 0.  The vector has
     mode M and the scalars have the mode appropriate for one element of
     M.  The operation is strictly in-order: there is no reassociation.

'mask_fold_left_plus_M'
     Like 'fold_left_plus_M', but takes an additional mask operand
     (operand 3) that specifies which elements of the source vector
     should be added.

'sdot_prodM'
'udot_prodM'
     Compute the sum of the products of two signed/unsigned elements.
     Operand 1 and operand 2 are of the same mode.  Their product, which
     is of a wider mode, is computed and added to operand 3.  Operand 3
     is of a mode equal or wider than the mode of the product.  The
     result is placed in operand 0, which is of the same mode as operand
     3.

'ssadM'
'usadM'
     Compute the sum of absolute differences of two signed/unsigned
     elements.  Operand 1 and operand 2 are of the same mode.  Their
     absolute difference, which is of a wider mode, is computed and
     added to operand 3.  Operand 3 is of a mode equal or wider than the
     mode of the absolute difference.  The result is placed in operand
     0, which is of the same mode as operand 3.

'widen_ssumM3'
'widen_usumM3'
     Operands 0 and 2 are of the same mode, which is wider than the mode
     of operand 1.  Add operand 1 to operand 2 and place the widened
     result in operand 0.  (This is used express accumulation of
     elements into an accumulator of a wider mode.)

'smulhsM3'
'umulhsM3'
     Signed/unsigned multiply high with scale.  This is equivalent to
     the C code:
          narrow op0, op1, op2;
          ...
          op0 = (narrow) (((wide) op1 * (wide) op2) >> (N / 2 - 1));
     where the sign of 'narrow' determines whether this is a signed or
     unsigned operation, and N is the size of 'wide' in bits.

'smulhrsM3'
'umulhrsM3'
     Signed/unsigned multiply high with round and scale.  This is
     equivalent to the C code:
          narrow op0, op1, op2;
          ...
          op0 = (narrow) (((((wide) op1 * (wide) op2) >> (N / 2 - 2)) + 1) >> 1);
     where the sign of 'narrow' determines whether this is a signed or
     unsigned operation, and N is the size of 'wide' in bits.

'sdiv_pow2M3'
'sdiv_pow2M3'
     Signed division by power-of-2 immediate.  Equivalent to:
          signed op0, op1;
          ...
          op0 = op1 / (1 << imm);

'vec_shl_insert_M'
     Shift the elements in vector input operand 1 left one element (i.e.
     away from element 0) and fill the vacated element 0 with the scalar
     in operand 2.  Store the result in vector output operand 0.
     Operands 0 and 1 have mode M and operand 2 has the mode appropriate
     for one element of M.

'vec_shl_M'
     Whole vector left shift in bits, i.e. away from element 0.  Operand
     1 is a vector to be shifted.  Operand 2 is an integer shift amount
     in bits.  Operand 0 is where the resulting shifted vector is
     stored.  The output and input vectors should have the same modes.

'vec_shr_M'
     Whole vector right shift in bits, i.e. towards element 0.  Operand
     1 is a vector to be shifted.  Operand 2 is an integer shift amount
     in bits.  Operand 0 is where the resulting shifted vector is
     stored.  The output and input vectors should have the same modes.

'vec_pack_trunc_M'
     Narrow (demote) and merge the elements of two vectors.  Operands 1
     and 2 are vectors of the same mode having N integral or floating
     point elements of size S.  Operand 0 is the resulting vector in
     which 2*N elements of size S/2 are concatenated after narrowing
     them down using truncation.

'vec_pack_sbool_trunc_M'
     Narrow and merge the elements of two vectors.  Operands 1 and 2 are
     vectors of the same type having N boolean elements.  Operand 0 is
     the resulting vector in which 2*N elements are concatenated.  The
     last operand (operand 3) is the number of elements in the output
     vector 2*N as a 'CONST_INT'.  This instruction pattern is used when
     all the vector input and output operands have the same scalar mode
     M and thus using 'vec_pack_trunc_M' would be ambiguous.

'vec_pack_ssat_M', 'vec_pack_usat_M'
     Narrow (demote) and merge the elements of two vectors.  Operands 1
     and 2 are vectors of the same mode having N integral elements of
     size S. Operand 0 is the resulting vector in which the elements of
     the two input vectors are concatenated after narrowing them down
     using signed/unsigned saturating arithmetic.

'vec_pack_sfix_trunc_M', 'vec_pack_ufix_trunc_M'
     Narrow, convert to signed/unsigned integral type and merge the
     elements of two vectors.  Operands 1 and 2 are vectors of the same
     mode having N floating point elements of size S.  Operand 0 is the
     resulting vector in which 2*N elements of size S/2 are
     concatenated.

'vec_packs_float_M', 'vec_packu_float_M'
     Narrow, convert to floating point type and merge the elements of
     two vectors.  Operands 1 and 2 are vectors of the same mode having
     N signed/unsigned integral elements of size S.  Operand 0 is the
     resulting vector in which 2*N elements of size S/2 are
     concatenated.

'vec_unpacks_hi_M', 'vec_unpacks_lo_M'
     Extract and widen (promote) the high/low part of a vector of signed
     integral or floating point elements.  The input vector (operand 1)
     has N elements of size S.  Widen (promote) the high/low elements of
     the vector using signed or floating point extension and place the
     resulting N/2 values of size 2*S in the output vector (operand 0).

'vec_unpacku_hi_M', 'vec_unpacku_lo_M'
     Extract and widen (promote) the high/low part of a vector of
     unsigned integral elements.  The input vector (operand 1) has N
     elements of size S. Widen (promote) the high/low elements of the
     vector using zero extension and place the resulting N/2 values of
     size 2*S in the output vector (operand 0).

'vec_unpacks_sbool_hi_M', 'vec_unpacks_sbool_lo_M'
     Extract the high/low part of a vector of boolean elements that have
     scalar mode M.  The input vector (operand 1) has N elements, the
     output vector (operand 0) has N/2 elements.  The last operand
     (operand 2) is the number of elements of the input vector N as a
     'CONST_INT'.  These patterns are used if both the input and output
     vectors have the same scalar mode M and thus using
     'vec_unpacks_hi_M' or 'vec_unpacks_lo_M' would be ambiguous.

'vec_unpacks_float_hi_M', 'vec_unpacks_float_lo_M'
'vec_unpacku_float_hi_M', 'vec_unpacku_float_lo_M'
     Extract, convert to floating point type and widen the high/low part
     of a vector of signed/unsigned integral elements.  The input vector
     (operand 1) has N elements of size S.  Convert the high/low
     elements of the vector using floating point conversion and place
     the resulting N/2 values of size 2*S in the output vector (operand
     0).

'vec_unpack_sfix_trunc_hi_M',
'vec_unpack_sfix_trunc_lo_M'
'vec_unpack_ufix_trunc_hi_M'
'vec_unpack_ufix_trunc_lo_M'
     Extract, convert to signed/unsigned integer type and widen the
     high/low part of a vector of floating point elements.  The input
     vector (operand 1) has N elements of size S.  Convert the high/low
     elements of the vector to integers and place the resulting N/2
     values of size 2*S in the output vector (operand 0).

'vec_widen_umult_hi_M', 'vec_widen_umult_lo_M'
'vec_widen_smult_hi_M', 'vec_widen_smult_lo_M'
'vec_widen_umult_even_M', 'vec_widen_umult_odd_M'
'vec_widen_smult_even_M', 'vec_widen_smult_odd_M'
     Signed/Unsigned widening multiplication.  The two inputs (operands
     1 and 2) are vectors with N signed/unsigned elements of size S.
     Multiply the high/low or even/odd elements of the two vectors, and
     put the N/2 products of size 2*S in the output vector (operand 0).
     A target shouldn't implement even/odd pattern pair if it is less
     efficient than lo/hi one.

'vec_widen_ushiftl_hi_M', 'vec_widen_ushiftl_lo_M'
'vec_widen_sshiftl_hi_M', 'vec_widen_sshiftl_lo_M'
     Signed/Unsigned widening shift left.  The first input (operand 1)
     is a vector with N signed/unsigned elements of size S.  Operand 2
     is a constant.  Shift the high/low elements of operand 1, and put
     the N/2 results of size 2*S in the output vector (operand 0).

'mulhisi3'
     Multiply operands 1 and 2, which have mode 'HImode', and store a
     'SImode' product in operand 0.

'mulqihi3', 'mulsidi3'
     Similar widening-multiplication instructions of other widths.

'umulqihi3', 'umulhisi3', 'umulsidi3'
     Similar widening-multiplication instructions that do unsigned
     multiplication.

'usmulqihi3', 'usmulhisi3', 'usmulsidi3'
     Similar widening-multiplication instructions that interpret the
     first operand as unsigned and the second operand as signed, then do
     a signed multiplication.

'smulM3_highpart'
     Perform a signed multiplication of operands 1 and 2, which have
     mode M, and store the most significant half of the product in
     operand 0.  The least significant half of the product is discarded.

'umulM3_highpart'
     Similar, but the multiplication is unsigned.

'maddMN4'
     Multiply operands 1 and 2, sign-extend them to mode N, add operand
     3, and store the result in operand 0.  Operands 1 and 2 have mode M
     and operands 0 and 3 have mode N.  Both modes must be integer or
     fixed-point modes and N must be twice the size of M.

     In other words, 'maddMN4' is like 'mulMN3' except that it also adds
     operand 3.

     These instructions are not allowed to 'FAIL'.

'umaddMN4'
     Like 'maddMN4', but zero-extend the multiplication operands instead
     of sign-extending them.

'ssmaddMN4'
     Like 'maddMN4', but all involved operations must be
     signed-saturating.

'usmaddMN4'
     Like 'umaddMN4', but all involved operations must be
     unsigned-saturating.

'msubMN4'
     Multiply operands 1 and 2, sign-extend them to mode N, subtract the
     result from operand 3, and store the result in operand 0.  Operands
     1 and 2 have mode M and operands 0 and 3 have mode N.  Both modes
     must be integer or fixed-point modes and N must be twice the size
     of M.

     In other words, 'msubMN4' is like 'mulMN3' except that it also
     subtracts the result from operand 3.

     These instructions are not allowed to 'FAIL'.

'umsubMN4'
     Like 'msubMN4', but zero-extend the multiplication operands instead
     of sign-extending them.

'ssmsubMN4'
     Like 'msubMN4', but all involved operations must be
     signed-saturating.

'usmsubMN4'
     Like 'umsubMN4', but all involved operations must be
     unsigned-saturating.

'divmodM4'
     Signed division that produces both a quotient and a remainder.
     Operand 1 is divided by operand 2 to produce a quotient stored in
     operand 0 and a remainder stored in operand 3.

     For machines with an instruction that produces both a quotient and
     a remainder, provide a pattern for 'divmodM4' but do not provide
     patterns for 'divM3' and 'modM3'.  This allows optimization in the
     relatively common case when both the quotient and remainder are
     computed.

     If an instruction that just produces a quotient or just a remainder
     exists and is more efficient than the instruction that produces
     both, write the output routine of 'divmodM4' to call
     'find_reg_note' and look for a 'REG_UNUSED' note on the quotient or
     remainder and generate the appropriate instruction.

'udivmodM4'
     Similar, but does unsigned division.

'ashlM3', 'ssashlM3', 'usashlM3'
     Arithmetic-shift operand 1 left by a number of bits specified by
     operand 2, and store the result in operand 0.  Here M is the mode
     of operand 0 and operand 1; operand 2's mode is specified by the
     instruction pattern, and the compiler will convert the operand to
     that mode before generating the instruction.  The shift or rotate
     expander or instruction pattern should explicitly specify the mode
     of the operand 2, it should never be 'VOIDmode'.  The meaning of
     out-of-range shift counts can optionally be specified by
     'TARGET_SHIFT_TRUNCATION_MASK'.  *Note
     TARGET_SHIFT_TRUNCATION_MASK::.  Operand 2 is always a scalar type.

'ashrM3', 'lshrM3', 'rotlM3', 'rotrM3'
     Other shift and rotate instructions, analogous to the 'ashlM3'
     instructions.  Operand 2 is always a scalar type.

'vashlM3', 'vashrM3', 'vlshrM3', 'vrotlM3', 'vrotrM3'
     Vector shift and rotate instructions that take vectors as operand 2
     instead of a scalar type.

'avgM3_floor'
'uavgM3_floor'
     Signed and unsigned average instructions.  These instructions add
     operands 1 and 2 without truncation, divide the result by 2, round
     towards -Inf, and store the result in operand 0.  This is
     equivalent to the C code:
          narrow op0, op1, op2;
          ...
          op0 = (narrow) (((wide) op1 + (wide) op2) >> 1);
     where the sign of 'narrow' determines whether this is a signed or
     unsigned operation.

'avgM3_ceil'
'uavgM3_ceil'
     Like 'avgM3_floor' and 'uavgM3_floor', but round towards +Inf.
     This is equivalent to the C code:
          narrow op0, op1, op2;
          ...
          op0 = (narrow) (((wide) op1 + (wide) op2 + 1) >> 1);

'bswapM2'
     Reverse the order of bytes of operand 1 and store the result in
     operand 0.

'negM2', 'ssnegM2', 'usnegM2'
     Negate operand 1 and store the result in operand 0.

'negvM3'
     Like 'negM2' but takes a 'code_label' as operand 2 and emits code
     to jump to it if signed overflow occurs during the negation.

'absM2'
     Store the absolute value of operand 1 into operand 0.

'sqrtM2'
     Store the square root of operand 1 into operand 0.  Both operands
     have mode M, which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'rsqrtM2'
     Store the reciprocal of the square root of operand 1 into operand
     0.  Both operands have mode M, which is a scalar or vector
     floating-point mode.

     On most architectures this pattern is only approximate, so either
     its C condition or the 'TARGET_OPTAB_SUPPORTED_P' hook should check
     for the appropriate math flags.  (Using the C condition is more
     direct, but using 'TARGET_OPTAB_SUPPORTED_P' can be useful if a
     target-specific built-in also uses the 'rsqrtM2' pattern.)

     This pattern is not allowed to 'FAIL'.

'fmodM3'
     Store the remainder of dividing operand 1 by operand 2 into operand
     0, rounded towards zero to an integer.  All operands have mode M,
     which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'remainderM3'
     Store the remainder of dividing operand 1 by operand 2 into operand
     0, rounded to the nearest integer.  All operands have mode M, which
     is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'scalbM3'
     Raise 'FLT_RADIX' to the power of operand 2, multiply it by operand
     1, and store the result in operand 0.  All operands have mode M,
     which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'ldexpM3'
     Raise 2 to the power of operand 2, multiply it by operand 1, and
     store the result in operand 0.  Operands 0 and 1 have mode M, which
     is a scalar or vector floating-point mode.  Operand 2's mode has
     the same number of elements as M and each element is wide enough to
     store an 'int'.  The integers are signed.

     This pattern is not allowed to 'FAIL'.

'cosM2'
     Store the cosine of operand 1 into operand 0.  Both operands have
     mode M, which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'sinM2'
     Store the sine of operand 1 into operand 0.  Both operands have
     mode M, which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'sincosM3'
     Store the cosine of operand 2 into operand 0 and the sine of
     operand 2 into operand 1.  All operands have mode M, which is a
     scalar or vector floating-point mode.

     Targets that can calculate the sine and cosine simultaneously can
     implement this pattern as opposed to implementing individual
     'sinM2' and 'cosM2' patterns.  The 'sin' and 'cos' built-in
     functions will then be expanded to the 'sincosM3' pattern, with one
     of the output values left unused.

'tanM2'
     Store the tangent of operand 1 into operand 0.  Both operands have
     mode M, which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'asinM2'
     Store the arc sine of operand 1 into operand 0.  Both operands have
     mode M, which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'acosM2'
     Store the arc cosine of operand 1 into operand 0.  Both operands
     have mode M, which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'atanM2'
     Store the arc tangent of operand 1 into operand 0.  Both operands
     have mode M, which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'expM2'
     Raise e (the base of natural logarithms) to the power of operand 1
     and store the result in operand 0.  Both operands have mode M,
     which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'expm1M2'
     Raise e (the base of natural logarithms) to the power of operand 1,
     subtract 1, and store the result in operand 0.  Both operands have
     mode M, which is a scalar or vector floating-point mode.

     For inputs close to zero, the pattern is expected to be more
     accurate than a separate 'expM2' and 'subM3' would be.

     This pattern is not allowed to 'FAIL'.

'exp10M2'
     Raise 10 to the power of operand 1 and store the result in operand
     0.  Both operands have mode M, which is a scalar or vector
     floating-point mode.

     This pattern is not allowed to 'FAIL'.

'exp2M2'
     Raise 2 to the power of operand 1 and store the result in operand
     0.  Both operands have mode M, which is a scalar or vector
     floating-point mode.

     This pattern is not allowed to 'FAIL'.

'logM2'
     Store the natural logarithm of operand 1 into operand 0.  Both
     operands have mode M, which is a scalar or vector floating-point
     mode.

     This pattern is not allowed to 'FAIL'.

'log1pM2'
     Add 1 to operand 1, compute the natural logarithm, and store the
     result in operand 0.  Both operands have mode M, which is a scalar
     or vector floating-point mode.

     For inputs close to zero, the pattern is expected to be more
     accurate than a separate 'addM3' and 'logM2' would be.

     This pattern is not allowed to 'FAIL'.

'log10M2'
     Store the base-10 logarithm of operand 1 into operand 0.  Both
     operands have mode M, which is a scalar or vector floating-point
     mode.

     This pattern is not allowed to 'FAIL'.

'log2M2'
     Store the base-2 logarithm of operand 1 into operand 0.  Both
     operands have mode M, which is a scalar or vector floating-point
     mode.

     This pattern is not allowed to 'FAIL'.

'logbM2'
     Store the base-'FLT_RADIX' logarithm of operand 1 into operand 0.
     Both operands have mode M, which is a scalar or vector
     floating-point mode.

     This pattern is not allowed to 'FAIL'.

'significandM2'
     Store the significand of floating-point operand 1 in operand 0.
     Both operands have mode M, which is a scalar or vector
     floating-point mode.

     This pattern is not allowed to 'FAIL'.

'powM3'
     Store the value of operand 1 raised to the exponent operand 2 into
     operand 0.  All operands have mode M, which is a scalar or vector
     floating-point mode.

     This pattern is not allowed to 'FAIL'.

'atan2M3'
     Store the arc tangent (inverse tangent) of operand 1 divided by
     operand 2 into operand 0, using the signs of both arguments to
     determine the quadrant of the result.  All operands have mode M,
     which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'floorM2'
     Store the largest integral value not greater than operand 1 in
     operand 0.  Both operands have mode M, which is a scalar or vector
     floating-point mode.  If '-ffp-int-builtin-inexact' is in effect,
     the "inexact" exception may be raised for noninteger operands;
     otherwise, it may not.

     This pattern is not allowed to 'FAIL'.

'btruncM2'
     Round operand 1 to an integer, towards zero, and store the result
     in operand 0.  Both operands have mode M, which is a scalar or
     vector floating-point mode.  If '-ffp-int-builtin-inexact' is in
     effect, the "inexact" exception may be raised for noninteger
     operands; otherwise, it may not.

     This pattern is not allowed to 'FAIL'.

'roundM2'
     Round operand 1 to the nearest integer, rounding away from zero in
     the event of a tie, and store the result in operand 0.  Both
     operands have mode M, which is a scalar or vector floating-point
     mode.  If '-ffp-int-builtin-inexact' is in effect, the "inexact"
     exception may be raised for noninteger operands; otherwise, it may
     not.

     This pattern is not allowed to 'FAIL'.

'ceilM2'
     Store the smallest integral value not less than operand 1 in
     operand 0.  Both operands have mode M, which is a scalar or vector
     floating-point mode.  If '-ffp-int-builtin-inexact' is in effect,
     the "inexact" exception may be raised for noninteger operands;
     otherwise, it may not.

     This pattern is not allowed to 'FAIL'.

'nearbyintM2'
     Round operand 1 to an integer, using the current rounding mode, and
     store the result in operand 0.  Do not raise an inexact condition
     when the result is different from the argument.  Both operands have
     mode M, which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'rintM2'
     Round operand 1 to an integer, using the current rounding mode, and
     store the result in operand 0.  Raise an inexact condition when the
     result is different from the argument.  Both operands have mode M,
     which is a scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'lrintMN2'
     Convert operand 1 (valid for floating point mode M) to fixed point
     mode N as a signed number according to the current rounding mode
     and store in operand 0 (which has mode N).

'lroundMN2'
     Convert operand 1 (valid for floating point mode M) to fixed point
     mode N as a signed number rounding to nearest and away from zero
     and store in operand 0 (which has mode N).

'lfloorMN2'
     Convert operand 1 (valid for floating point mode M) to fixed point
     mode N as a signed number rounding down and store in operand 0
     (which has mode N).

'lceilMN2'
     Convert operand 1 (valid for floating point mode M) to fixed point
     mode N as a signed number rounding up and store in operand 0 (which
     has mode N).

'copysignM3'
     Store a value with the magnitude of operand 1 and the sign of
     operand 2 into operand 0.  All operands have mode M, which is a
     scalar or vector floating-point mode.

     This pattern is not allowed to 'FAIL'.

'xorsignM3'
     Equivalent to 'op0 = op1 * copysign (1.0, op2)': store a value with
     the magnitude of operand 1 and the sign of operand 2 into operand
     0.  All operands have mode M, which is a scalar or vector
     floating-point mode.

     This pattern is not allowed to 'FAIL'.

'ffsM2'
     Store into operand 0 one plus the index of the least significant
     1-bit of operand 1.  If operand 1 is zero, store zero.

     M is either a scalar or vector integer mode.  When it is a scalar,
     operand 1 has mode M but operand 0 can have whatever scalar integer
     mode is suitable for the target.  The compiler will insert
     conversion instructions as necessary (typically to convert the
     result to the same width as 'int').  When M is a vector, both
     operands must have mode M.

     This pattern is not allowed to 'FAIL'.

'clrsbM2'
     Count leading redundant sign bits.  Store into operand 0 the number
     of redundant sign bits in operand 1, starting at the most
     significant bit position.  A redundant sign bit is defined as any
     sign bit after the first.  As such, this count will be one less
     than the count of leading sign bits.

     M is either a scalar or vector integer mode.  When it is a scalar,
     operand 1 has mode M but operand 0 can have whatever scalar integer
     mode is suitable for the target.  The compiler will insert
     conversion instructions as necessary (typically to convert the
     result to the same width as 'int').  When M is a vector, both
     operands must have mode M.

     This pattern is not allowed to 'FAIL'.

'clzM2'
     Store into operand 0 the number of leading 0-bits in operand 1,
     starting at the most significant bit position.  If operand 1 is 0,
     the 'CLZ_DEFINED_VALUE_AT_ZERO' (*note Misc::) macro defines if the
     result is undefined or has a useful value.

     M is either a scalar or vector integer mode.  When it is a scalar,
     operand 1 has mode M but operand 0 can have whatever scalar integer
     mode is suitable for the target.  The compiler will insert
     conversion instructions as necessary (typically to convert the
     result to the same width as 'int').  When M is a vector, both
     operands must have mode M.

     This pattern is not allowed to 'FAIL'.

'ctzM2'
     Store into operand 0 the number of trailing 0-bits in operand 1,
     starting at the least significant bit position.  If operand 1 is 0,
     the 'CTZ_DEFINED_VALUE_AT_ZERO' (*note Misc::) macro defines if the
     result is undefined or has a useful value.

     M is either a scalar or vector integer mode.  When it is a scalar,
     operand 1 has mode M but operand 0 can have whatever scalar integer
     mode is suitable for the target.  The compiler will insert
     conversion instructions as necessary (typically to convert the
     result to the same width as 'int').  When M is a vector, both
     operands must have mode M.

     This pattern is not allowed to 'FAIL'.

'popcountM2'
     Store into operand 0 the number of 1-bits in operand 1.

     M is either a scalar or vector integer mode.  When it is a scalar,
     operand 1 has mode M but operand 0 can have whatever scalar integer
     mode is suitable for the target.  The compiler will insert
     conversion instructions as necessary (typically to convert the
     result to the same width as 'int').  When M is a vector, both
     operands must have mode M.

     This pattern is not allowed to 'FAIL'.

'parityM2'
     Store into operand 0 the parity of operand 1, i.e. the number of
     1-bits in operand 1 modulo 2.

     M is either a scalar or vector integer mode.  When it is a scalar,
     operand 1 has mode M but operand 0 can have whatever scalar integer
     mode is suitable for the target.  The compiler will insert
     conversion instructions as necessary (typically to convert the
     result to the same width as 'int').  When M is a vector, both
     operands must have mode M.

     This pattern is not allowed to 'FAIL'.

'one_cmplM2'
     Store the bitwise-complement of operand 1 into operand 0.

'cpymemM'
     Block copy instruction.  The destination and source blocks of
     memory are the first two operands, and both are 'mem:BLK's with an
     address in mode 'Pmode'.

     The number of bytes to copy is the third operand, in mode M.
     Usually, you specify 'Pmode' for M.  However, if you can generate
     better code knowing the range of valid lengths is smaller than
     those representable in a full Pmode pointer, you should provide a
     pattern with a mode corresponding to the range of values you can
     handle efficiently (e.g., 'QImode' for values in the range 0-127;
     note we avoid numbers that appear negative) and also a pattern with
     'Pmode'.

     The fourth operand is the known shared alignment of the source and
     destination, in the form of a 'const_int' rtx.  Thus, if the
     compiler knows that both source and destination are word-aligned,
     it may provide the value 4 for this operand.

     Optional operands 5 and 6 specify expected alignment and size of
     block respectively.  The expected alignment differs from alignment
     in operand 4 in a way that the blocks are not required to be
     aligned according to it in all cases.  This expected alignment is
     also in bytes, just like operand 4.  Expected size, when unknown,
     is set to '(const_int -1)'.

     Descriptions of multiple 'cpymemM' patterns can only be beneficial
     if the patterns for smaller modes have fewer restrictions on their
     first, second and fourth operands.  Note that the mode M in
     'cpymemM' does not impose any restriction on the mode of
     individually copied data units in the block.

     The 'cpymemM' patterns need not give special consideration to the
     possibility that the source and destination strings might overlap.
     These patterns are used to do inline expansion of
     '__builtin_memcpy'.

'movmemM'
     Block move instruction.  The destination and source blocks of
     memory are the first two operands, and both are 'mem:BLK's with an
     address in mode 'Pmode'.

     The number of bytes to copy is the third operand, in mode M.
     Usually, you specify 'Pmode' for M.  However, if you can generate
     better code knowing the range of valid lengths is smaller than
     those representable in a full Pmode pointer, you should provide a
     pattern with a mode corresponding to the range of values you can
     handle efficiently (e.g., 'QImode' for values in the range 0-127;
     note we avoid numbers that appear negative) and also a pattern with
     'Pmode'.

     The fourth operand is the known shared alignment of the source and
     destination, in the form of a 'const_int' rtx.  Thus, if the
     compiler knows that both source and destination are word-aligned,
     it may provide the value 4 for this operand.

     Optional operands 5 and 6 specify expected alignment and size of
     block respectively.  The expected alignment differs from alignment
     in operand 4 in a way that the blocks are not required to be
     aligned according to it in all cases.  This expected alignment is
     also in bytes, just like operand 4.  Expected size, when unknown,
     is set to '(const_int -1)'.

     Descriptions of multiple 'movmemM' patterns can only be beneficial
     if the patterns for smaller modes have fewer restrictions on their
     first, second and fourth operands.  Note that the mode M in
     'movmemM' does not impose any restriction on the mode of
     individually copied data units in the block.

     The 'movmemM' patterns must correctly handle the case where the
     source and destination strings overlap.  These patterns are used to
     do inline expansion of '__builtin_memmove'.

'movstr'
     String copy instruction, with 'stpcpy' semantics.  Operand 0 is an
     output operand in mode 'Pmode'.  The addresses of the destination
     and source strings are operands 1 and 2, and both are 'mem:BLK's
     with addresses in mode 'Pmode'.  The execution of the expansion of
     this pattern should store in operand 0 the address in which the
     'NUL' terminator was stored in the destination string.

     This pattern has also several optional operands that are same as in
     'setmem'.

'setmemM'
     Block set instruction.  The destination string is the first
     operand, given as a 'mem:BLK' whose address is in mode 'Pmode'.
     The number of bytes to set is the second operand, in mode M.  The
     value to initialize the memory with is the third operand.  Targets
     that only support the clearing of memory should reject any value
     that is not the constant 0.  See 'cpymemM' for a discussion of the
     choice of mode.

     The fourth operand is the known alignment of the destination, in
     the form of a 'const_int' rtx.  Thus, if the compiler knows that
     the destination is word-aligned, it may provide the value 4 for
     this operand.

     Optional operands 5 and 6 specify expected alignment and size of
     block respectively.  The expected alignment differs from alignment
     in operand 4 in a way that the blocks are not required to be
     aligned according to it in all cases.  This expected alignment is
     also in bytes, just like operand 4.  Expected size, when unknown,
     is set to '(const_int -1)'.  Operand 7 is the minimal size of the
     block and operand 8 is the maximal size of the block (NULL if it
     cannot be represented as CONST_INT). Operand 9 is the probable
     maximal size (i.e. we cannot rely on it for correctness, but it can
     be used for choosing proper code sequence for a given size).

     The use for multiple 'setmemM' is as for 'cpymemM'.

'cmpstrnM'
     String compare instruction, with five operands.  Operand 0 is the
     output; it has mode M.  The remaining four operands are like the
     operands of 'cpymemM'.  The two memory blocks specified are
     compared byte by byte in lexicographic order starting at the
     beginning of each string.  The instruction is not allowed to
     prefetch more than one byte at a time since either string may end
     in the first byte and reading past that may access an invalid page
     or segment and cause a fault.  The comparison terminates early if
     the fetched bytes are different or if they are equal to zero.  The
     effect of the instruction is to store a value in operand 0 whose
     sign indicates the result of the comparison.

'cmpstrM'
     String compare instruction, without known maximum length.  Operand
     0 is the output; it has mode M.  The second and third operand are
     the blocks of memory to be compared; both are 'mem:BLK' with an
     address in mode 'Pmode'.

     The fourth operand is the known shared alignment of the source and
     destination, in the form of a 'const_int' rtx.  Thus, if the
     compiler knows that both source and destination are word-aligned,
     it may provide the value 4 for this operand.

     The two memory blocks specified are compared byte by byte in
     lexicographic order starting at the beginning of each string.  The
     instruction is not allowed to prefetch more than one byte at a time
     since either string may end in the first byte and reading past that
     may access an invalid page or segment and cause a fault.  The
     comparison will terminate when the fetched bytes are different or
     if they are equal to zero.  The effect of the instruction is to
     store a value in operand 0 whose sign indicates the result of the
     comparison.

'cmpmemM'
     Block compare instruction, with five operands like the operands of
     'cmpstrM'.  The two memory blocks specified are compared byte by
     byte in lexicographic order starting at the beginning of each
     block.  Unlike 'cmpstrM' the instruction can prefetch any bytes in
     the two memory blocks.  Also unlike 'cmpstrM' the comparison will
     not stop if both bytes are zero.  The effect of the instruction is
     to store a value in operand 0 whose sign indicates the result of
     the comparison.

'strlenM'
     Compute the length of a string, with three operands.  Operand 0 is
     the result (of mode M), operand 1 is a 'mem' referring to the first
     character of the string, operand 2 is the character to search for
     (normally zero), and operand 3 is a constant describing the known
     alignment of the beginning of the string.

'floatMN2'
     Convert signed integer operand 1 (valid for fixed point mode M) to
     floating point mode N and store in operand 0 (which has mode N).

'floatunsMN2'
     Convert unsigned integer operand 1 (valid for fixed point mode M)
     to floating point mode N and store in operand 0 (which has mode N).

'fixMN2'
     Convert operand 1 (valid for floating point mode M) to fixed point
     mode N as a signed number and store in operand 0 (which has mode
     N).  This instruction's result is defined only when the value of
     operand 1 is an integer.

     If the machine description defines this pattern, it also needs to
     define the 'ftrunc' pattern.

'fixunsMN2'
     Convert operand 1 (valid for floating point mode M) to fixed point
     mode N as an unsigned number and store in operand 0 (which has mode
     N).  This instruction's result is defined only when the value of
     operand 1 is an integer.

'ftruncM2'
     Convert operand 1 (valid for floating point mode M) to an integer
     value, still represented in floating point mode M, and store it in
     operand 0 (valid for floating point mode M).

'fix_truncMN2'
     Like 'fixMN2' but works for any floating point value of mode M by
     converting the value to an integer.

'fixuns_truncMN2'
     Like 'fixunsMN2' but works for any floating point value of mode M
     by converting the value to an integer.

'truncMN2'
     Truncate operand 1 (valid for mode M) to mode N and store in
     operand 0 (which has mode N).  Both modes must be fixed point or
     both floating point.

'extendMN2'
     Sign-extend operand 1 (valid for mode M) to mode N and store in
     operand 0 (which has mode N).  Both modes must be fixed point or
     both floating point.

'zero_extendMN2'
     Zero-extend operand 1 (valid for mode M) to mode N and store in
     operand 0 (which has mode N).  Both modes must be fixed point.

'fractMN2'
     Convert operand 1 of mode M to mode N and store in operand 0 (which
     has mode N).  Mode M and mode N could be fixed-point to
     fixed-point, signed integer to fixed-point, fixed-point to signed
     integer, floating-point to fixed-point, or fixed-point to
     floating-point.  When overflows or underflows happen, the results
     are undefined.

'satfractMN2'
     Convert operand 1 of mode M to mode N and store in operand 0 (which
     has mode N).  Mode M and mode N could be fixed-point to
     fixed-point, signed integer to fixed-point, or floating-point to
     fixed-point.  When overflows or underflows happen, the instruction
     saturates the results to the maximum or the minimum.

'fractunsMN2'
     Convert operand 1 of mode M to mode N and store in operand 0 (which
     has mode N).  Mode M and mode N could be unsigned integer to
     fixed-point, or fixed-point to unsigned integer.  When overflows or
     underflows happen, the results are undefined.

'satfractunsMN2'
     Convert unsigned integer operand 1 of mode M to fixed-point mode N
     and store in operand 0 (which has mode N).  When overflows or
     underflows happen, the instruction saturates the results to the
     maximum or the minimum.

'extvM'
     Extract a bit-field from register operand 1, sign-extend it, and
     store it in operand 0.  Operand 2 specifies the width of the field
     in bits and operand 3 the starting bit, which counts from the most
     significant bit if 'BITS_BIG_ENDIAN' is true and from the least
     significant bit otherwise.

     Operands 0 and 1 both have mode M.  Operands 2 and 3 have a
     target-specific mode.

'extvmisalignM'
     Extract a bit-field from memory operand 1, sign extend it, and
     store it in operand 0.  Operand 2 specifies the width in bits and
     operand 3 the starting bit.  The starting bit is always somewhere
     in the first byte of operand 1; it counts from the most significant
     bit if 'BITS_BIG_ENDIAN' is true and from the least significant bit
     otherwise.

     Operand 0 has mode M while operand 1 has 'BLK' mode.  Operands 2
     and 3 have a target-specific mode.

     The instruction must not read beyond the last byte of the
     bit-field.

'extzvM'
     Like 'extvM' except that the bit-field value is zero-extended.

'extzvmisalignM'
     Like 'extvmisalignM' except that the bit-field value is
     zero-extended.

'insvM'
     Insert operand 3 into a bit-field of register operand 0.  Operand 1
     specifies the width of the field in bits and operand 2 the starting
     bit, which counts from the most significant bit if
     'BITS_BIG_ENDIAN' is true and from the least significant bit
     otherwise.

     Operands 0 and 3 both have mode M.  Operands 1 and 2 have a
     target-specific mode.

'insvmisalignM'
     Insert operand 3 into a bit-field of memory operand 0.  Operand 1
     specifies the width of the field in bits and operand 2 the starting
     bit.  The starting bit is always somewhere in the first byte of
     operand 0; it counts from the most significant bit if
     'BITS_BIG_ENDIAN' is true and from the least significant bit
     otherwise.

     Operand 3 has mode M while operand 0 has 'BLK' mode.  Operands 1
     and 2 have a target-specific mode.

     The instruction must not read or write beyond the last byte of the
     bit-field.

'extv'
     Extract a bit-field from operand 1 (a register or memory operand),
     where operand 2 specifies the width in bits and operand 3 the
     starting bit, and store it in operand 0.  Operand 0 must have mode
     'word_mode'.  Operand 1 may have mode 'byte_mode' or 'word_mode';
     often 'word_mode' is allowed only for registers.  Operands 2 and 3
     must be valid for 'word_mode'.

     The RTL generation pass generates this instruction only with
     constants for operands 2 and 3 and the constant is never zero for
     operand 2.

     The bit-field value is sign-extended to a full word integer before
     it is stored in operand 0.

     This pattern is deprecated; please use 'extvM' and 'extvmisalignM'
     instead.

'extzv'
     Like 'extv' except that the bit-field value is zero-extended.

     This pattern is deprecated; please use 'extzvM' and
     'extzvmisalignM' instead.

'insv'
     Store operand 3 (which must be valid for 'word_mode') into a
     bit-field in operand 0, where operand 1 specifies the width in bits
     and operand 2 the starting bit.  Operand 0 may have mode
     'byte_mode' or 'word_mode'; often 'word_mode' is allowed only for
     registers.  Operands 1 and 2 must be valid for 'word_mode'.

     The RTL generation pass generates this instruction only with
     constants for operands 1 and 2 and the constant is never zero for
     operand 1.

     This pattern is deprecated; please use 'insvM' and 'insvmisalignM'
     instead.

'movMODEcc'
     Conditionally move operand 2 or operand 3 into operand 0 according
     to the comparison in operand 1.  If the comparison is true, operand
     2 is moved into operand 0, otherwise operand 3 is moved.

     The mode of the operands being compared need not be the same as the
     operands being moved.  Some machines, sparc64 for example, have
     instructions that conditionally move an integer value based on the
     floating point condition codes and vice versa.

     If the machine does not have conditional move instructions, do not
     define these patterns.

'addMODEcc'
     Similar to 'movMODEcc' but for conditional addition.  Conditionally
     move operand 2 or (operands 2 + operand 3) into operand 0 according
     to the comparison in operand 1.  If the comparison is false,
     operand 2 is moved into operand 0, otherwise (operand 2 + operand
     3) is moved.

'cond_addMODE'
'cond_subMODE'
'cond_mulMODE'
'cond_divMODE'
'cond_udivMODE'
'cond_modMODE'
'cond_umodMODE'
'cond_andMODE'
'cond_iorMODE'
'cond_xorMODE'
'cond_sminMODE'
'cond_smaxMODE'
'cond_uminMODE'
'cond_umaxMODE'
     When operand 1 is true, perform an operation on operands 2 and 3
     and store the result in operand 0, otherwise store operand 4 in
     operand 0.  The operation works elementwise if the operands are
     vectors.

     The scalar case is equivalent to:

          op0 = op1 ? op2 OP op3 : op4;

     while the vector case is equivalent to:

          for (i = 0; i < GET_MODE_NUNITS (M); i++)
            op0[i] = op1[i] ? op2[i] OP op3[i] : op4[i];

     where, for example, OP is '+' for 'cond_addMODE'.

     When defined for floating-point modes, the contents of 'op3[i]' are
     not interpreted if 'op1[i]' is false, just like they would not be
     in a normal C '?:' condition.

     Operands 0, 2, 3 and 4 all have mode M.  Operand 1 is a scalar
     integer if M is scalar, otherwise it has the mode returned by
     'TARGET_VECTORIZE_GET_MASK_MODE'.

'cond_fmaMODE'
'cond_fmsMODE'
'cond_fnmaMODE'
'cond_fnmsMODE'
     Like 'cond_addM', except that the conditional operation takes 3
     operands rather than two.  For example, the vector form of
     'cond_fmaMODE' is equivalent to:

          for (i = 0; i < GET_MODE_NUNITS (M); i++)
            op0[i] = op1[i] ? fma (op2[i], op3[i], op4[i]) : op5[i];

'negMODEcc'
     Similar to 'movMODEcc' but for conditional negation.  Conditionally
     move the negation of operand 2 or the unchanged operand 3 into
     operand 0 according to the comparison in operand 1.  If the
     comparison is true, the negation of operand 2 is moved into operand
     0, otherwise operand 3 is moved.

'notMODEcc'
     Similar to 'negMODEcc' but for conditional complement.
     Conditionally move the bitwise complement of operand 2 or the
     unchanged operand 3 into operand 0 according to the comparison in
     operand 1.  If the comparison is true, the complement of operand 2
     is moved into operand 0, otherwise operand 3 is moved.

'cstoreMODE4'
     Store zero or nonzero in operand 0 according to whether a
     comparison is true.  Operand 1 is a comparison operator.  Operand 2
     and operand 3 are the first and second operand of the comparison,
     respectively.  You specify the mode that operand 0 must have when
     you write the 'match_operand' expression.  The compiler
     automatically sees which mode you have used and supplies an operand
     of that mode.

     The value stored for a true condition must have 1 as its low bit,
     or else must be negative.  Otherwise the instruction is not
     suitable and you should omit it from the machine description.  You
     describe to the compiler exactly which value is stored by defining
     the macro 'STORE_FLAG_VALUE' (*note Misc::).  If a description
     cannot be found that can be used for all the possible comparison
     operators, you should pick one and use a 'define_expand' to map all
     results onto the one you chose.

     These operations may 'FAIL', but should do so only in relatively
     uncommon cases; if they would 'FAIL' for common cases involving
     integer comparisons, it is best to restrict the predicates to not
     allow these operands.  Likewise if a given comparison operator will
     always fail, independent of the operands (for floating-point modes,
     the 'ordered_comparison_operator' predicate is often useful in this
     case).

     If this pattern is omitted, the compiler will generate a
     conditional branch--for example, it may copy a constant one to the
     target and branching around an assignment of zero to the target--or
     a libcall.  If the predicate for operand 1 only rejects some
     operators, it will also try reordering the operands and/or
     inverting the result value (e.g. by an exclusive OR). These
     possibilities could be cheaper or equivalent to the instructions
     used for the 'cstoreMODE4' pattern followed by those required to
     convert a positive result from 'STORE_FLAG_VALUE' to 1; in this
     case, you can and should make operand 1's predicate reject some
     operators in the 'cstoreMODE4' pattern, or remove the pattern
     altogether from the machine description.

'cbranchMODE4'
     Conditional branch instruction combined with a compare instruction.
     Operand 0 is a comparison operator.  Operand 1 and operand 2 are
     the first and second operands of the comparison, respectively.
     Operand 3 is the 'code_label' to jump to.

'jump'
     A jump inside a function; an unconditional branch.  Operand 0 is
     the 'code_label' to jump to.  This pattern name is mandatory on all
     machines.

'call'
     Subroutine call instruction returning no value.  Operand 0 is the
     function to call; operand 1 is the number of bytes of arguments
     pushed as a 'const_int'; operand 2 is the number of registers used
     as operands.

     On most machines, operand 2 is not actually stored into the RTL
     pattern.  It is supplied for the sake of some RISC machines which
     need to put this information into the assembler code; they can put
     it in the RTL instead of operand 1.

     Operand 0 should be a 'mem' RTX whose address is the address of the
     function.  Note, however, that this address can be a 'symbol_ref'
     expression even if it would not be a legitimate memory address on
     the target machine.  If it is also not a valid argument for a call
     instruction, the pattern for this operation should be a
     'define_expand' (*note Expander Definitions::) that places the
     address into a register and uses that register in the call
     instruction.

'call_value'
     Subroutine call instruction returning a value.  Operand 0 is the
     hard register in which the value is returned.  There are three more
     operands, the same as the three operands of the 'call' instruction
     (but with numbers increased by one).

     Subroutines that return 'BLKmode' objects use the 'call' insn.

'call_pop', 'call_value_pop'
     Similar to 'call' and 'call_value', except used if defined and if
     'RETURN_POPS_ARGS' is nonzero.  They should emit a 'parallel' that
     contains both the function call and a 'set' to indicate the
     adjustment made to the frame pointer.

     For machines where 'RETURN_POPS_ARGS' can be nonzero, the use of
     these patterns increases the number of functions for which the
     frame pointer can be eliminated, if desired.

'untyped_call'
     Subroutine call instruction returning a value of any type.  Operand
     0 is the function to call; operand 1 is a memory location where the
     result of calling the function is to be stored; operand 2 is a
     'parallel' expression where each element is a 'set' expression that
     indicates the saving of a function return value into the result
     block.

     This instruction pattern should be defined to support
     '__builtin_apply' on machines where special instructions are needed
     to call a subroutine with arbitrary arguments or to save the value
     returned.  This instruction pattern is required on machines that
     have multiple registers that can hold a return value (i.e.
     'FUNCTION_VALUE_REGNO_P' is true for more than one register).

'return'
     Subroutine return instruction.  This instruction pattern name
     should be defined only if a single instruction can do all the work
     of returning from a function.

     Like the 'movM' patterns, this pattern is also used after the RTL
     generation phase.  In this case it is to support machines where
     multiple instructions are usually needed to return from a function,
     but some class of functions only requires one instruction to
     implement a return.  Normally, the applicable functions are those
     which do not need to save any registers or allocate stack space.

     It is valid for this pattern to expand to an instruction using
     'simple_return' if no epilogue is required.

'simple_return'
     Subroutine return instruction.  This instruction pattern name
     should be defined only if a single instruction can do all the work
     of returning from a function on a path where no epilogue is
     required.  This pattern is very similar to the 'return' instruction
     pattern, but it is emitted only by the shrink-wrapping optimization
     on paths where the function prologue has not been executed, and a
     function return should occur without any of the effects of the
     epilogue.  Additional uses may be introduced on paths where both
     the prologue and the epilogue have executed.

     For such machines, the condition specified in this pattern should
     only be true when 'reload_completed' is nonzero and the function's
     epilogue would only be a single instruction.  For machines with
     register windows, the routine 'leaf_function_p' may be used to
     determine if a register window push is required.

     Machines that have conditional return instructions should define
     patterns such as

          (define_insn ""
            [(set (pc)
                  (if_then_else (match_operator
                                   0 "comparison_operator"
                                   [(cc0) (const_int 0)])
                                (return)
                                (pc)))]
            "CONDITION"
            "...")

     where CONDITION would normally be the same condition specified on
     the named 'return' pattern.

'untyped_return'
     Untyped subroutine return instruction.  This instruction pattern
     should be defined to support '__builtin_return' on machines where
     special instructions are needed to return a value of any type.

     Operand 0 is a memory location where the result of calling a
     function with '__builtin_apply' is stored; operand 1 is a
     'parallel' expression where each element is a 'set' expression that
     indicates the restoring of a function return value from the result
     block.

'nop'
     No-op instruction.  This instruction pattern name should always be
     defined to output a no-op in assembler code.  '(const_int 0)' will
     do as an RTL pattern.

'indirect_jump'
     An instruction to jump to an address which is operand zero.  This
     pattern name is mandatory on all machines.

'casesi'
     Instruction to jump through a dispatch table, including bounds
     checking.  This instruction takes five operands:

       1. The index to dispatch on, which has mode 'SImode'.

       2. The lower bound for indices in the table, an integer constant.

       3. The total range of indices in the table--the largest index
          minus the smallest one (both inclusive).

       4. A label that precedes the table itself.

       5. A label to jump to if the index has a value outside the
          bounds.

     The table is an 'addr_vec' or 'addr_diff_vec' inside of a
     'jump_table_data'.  The number of elements in the table is one plus
     the difference between the upper bound and the lower bound.

'tablejump'
     Instruction to jump to a variable address.  This is a low-level
     capability which can be used to implement a dispatch table when
     there is no 'casesi' pattern.

     This pattern requires two operands: the address or offset, and a
     label which should immediately precede the jump table.  If the
     macro 'CASE_VECTOR_PC_RELATIVE' evaluates to a nonzero value then
     the first operand is an offset which counts from the address of the
     table; otherwise, it is an absolute address to jump to.  In either
     case, the first operand has mode 'Pmode'.

     The 'tablejump' insn is always the last insn before the jump table
     it uses.  Its assembler code normally has no need to use the second
     operand, but you should incorporate it in the RTL pattern so that
     the jump optimizer will not delete the table as unreachable code.

'doloop_end'
     Conditional branch instruction that decrements a register and jumps
     if the register is nonzero.  Operand 0 is the register to decrement
     and test; operand 1 is the label to jump to if the register is
     nonzero.  *Note Looping Patterns::.

     This optional instruction pattern should be defined for machines
     with low-overhead looping instructions as the loop optimizer will
     try to modify suitable loops to utilize it.  The target hook
     'TARGET_CAN_USE_DOLOOP_P' controls the conditions under which
     low-overhead loops can be used.

'doloop_begin'
     Companion instruction to 'doloop_end' required for machines that
     need to perform some initialization, such as loading a special
     counter register.  Operand 1 is the associated 'doloop_end' pattern
     and operand 0 is the register that it decrements.

     If initialization insns do not always need to be emitted, use a
     'define_expand' (*note Expander Definitions::) and make it fail.

'canonicalize_funcptr_for_compare'
     Canonicalize the function pointer in operand 1 and store the result
     into operand 0.

     Operand 0 is always a 'reg' and has mode 'Pmode'; operand 1 may be
     a 'reg', 'mem', 'symbol_ref', 'const_int', etc and also has mode
     'Pmode'.

     Canonicalization of a function pointer usually involves computing
     the address of the function which would be called if the function
     pointer were used in an indirect call.

     Only define this pattern if function pointers on the target machine
     can have different values but still call the same function when
     used in an indirect call.

'save_stack_block'
'save_stack_function'
'save_stack_nonlocal'
'restore_stack_block'
'restore_stack_function'
'restore_stack_nonlocal'
     Most machines save and restore the stack pointer by copying it to
     or from an object of mode 'Pmode'.  Do not define these patterns on
     such machines.

     Some machines require special handling for stack pointer saves and
     restores.  On those machines, define the patterns corresponding to
     the non-standard cases by using a 'define_expand' (*note Expander
     Definitions::) that produces the required insns.  The three types
     of saves and restores are:

       1. 'save_stack_block' saves the stack pointer at the start of a
          block that allocates a variable-sized object, and
          'restore_stack_block' restores the stack pointer when the
          block is exited.

       2. 'save_stack_function' and 'restore_stack_function' do a
          similar job for the outermost block of a function and are used
          when the function allocates variable-sized objects or calls
          'alloca'.  Only the epilogue uses the restored stack pointer,
          allowing a simpler save or restore sequence on some machines.

       3. 'save_stack_nonlocal' is used in functions that contain labels
          branched to by nested functions.  It saves the stack pointer
          in such a way that the inner function can use
          'restore_stack_nonlocal' to restore the stack pointer.  The
          compiler generates code to restore the frame and argument
          pointer registers, but some machines require saving and
          restoring additional data such as register window information
          or stack backchains.  Place insns in these patterns to save
          and restore any such required data.

     When saving the stack pointer, operand 0 is the save area and
     operand 1 is the stack pointer.  The mode used to allocate the save
     area defaults to 'Pmode' but you can override that choice by
     defining the 'STACK_SAVEAREA_MODE' macro (*note Storage Layout::).
     You must specify an integral mode, or 'VOIDmode' if no save area is
     needed for a particular type of save (either because no save is
     needed or because a machine-specific save area can be used).
     Operand 0 is the stack pointer and operand 1 is the save area for
     restore operations.  If 'save_stack_block' is defined, operand 0
     must not be 'VOIDmode' since these saves can be arbitrarily nested.

     A save area is a 'mem' that is at a constant offset from
     'virtual_stack_vars_rtx' when the stack pointer is saved for use by
     nonlocal gotos and a 'reg' in the other two cases.

'allocate_stack'
     Subtract (or add if 'STACK_GROWS_DOWNWARD' is undefined) operand 1
     from the stack pointer to create space for dynamically allocated
     data.

     Store the resultant pointer to this space into operand 0.  If you
     are allocating space from the main stack, do this by emitting a
     move insn to copy 'virtual_stack_dynamic_rtx' to operand 0.  If you
     are allocating the space elsewhere, generate code to copy the
     location of the space to operand 0.  In the latter case, you must
     ensure this space gets freed when the corresponding space on the
     main stack is free.

     Do not define this pattern if all that must be done is the
     subtraction.  Some machines require other operations such as stack
     probes or maintaining the back chain.  Define this pattern to emit
     those operations in addition to updating the stack pointer.

'check_stack'
     If stack checking (*note Stack Checking::) cannot be done on your
     system by probing the stack, define this pattern to perform the
     needed check and signal an error if the stack has overflowed.  The
     single operand is the address in the stack farthest from the
     current stack pointer that you need to validate.  Normally, on
     platforms where this pattern is needed, you would obtain the stack
     limit from a global or thread-specific variable or register.

'probe_stack_address'
     If stack checking (*note Stack Checking::) can be done on your
     system by probing the stack but without the need to actually access
     it, define this pattern and signal an error if the stack has
     overflowed.  The single operand is the memory address in the stack
     that needs to be probed.

'probe_stack'
     If stack checking (*note Stack Checking::) can be done on your
     system by probing the stack but doing it with a "store zero"
     instruction is not valid or optimal, define this pattern to do the
     probing differently and signal an error if the stack has
     overflowed.  The single operand is the memory reference in the
     stack that needs to be probed.

'nonlocal_goto'
     Emit code to generate a non-local goto, e.g., a jump from one
     function to a label in an outer function.  This pattern has four
     arguments, each representing a value to be used in the jump.  The
     first argument is to be loaded into the frame pointer, the second
     is the address to branch to (code to dispatch to the actual label),
     the third is the address of a location where the stack is saved,
     and the last is the address of the label, to be placed in the
     location for the incoming static chain.

     On most machines you need not define this pattern, since GCC will
     already generate the correct code, which is to load the frame
     pointer and static chain, restore the stack (using the
     'restore_stack_nonlocal' pattern, if defined), and jump indirectly
     to the dispatcher.  You need only define this pattern if this code
     will not work on your machine.

'nonlocal_goto_receiver'
     This pattern, if defined, contains code needed at the target of a
     nonlocal goto after the code already generated by GCC.  You will
     not normally need to define this pattern.  A typical reason why you
     might need this pattern is if some value, such as a pointer to a
     global table, must be restored when the frame pointer is restored.
     Note that a nonlocal goto only occurs within a unit-of-translation,
     so a global table pointer that is shared by all functions of a
     given module need not be restored.  There are no arguments.

'exception_receiver'
     This pattern, if defined, contains code needed at the site of an
     exception handler that isn't needed at the site of a nonlocal goto.
     You will not normally need to define this pattern.  A typical
     reason why you might need this pattern is if some value, such as a
     pointer to a global table, must be restored after control flow is
     branched to the handler of an exception.  There are no arguments.

'builtin_setjmp_setup'
     This pattern, if defined, contains additional code needed to
     initialize the 'jmp_buf'.  You will not normally need to define
     this pattern.  A typical reason why you might need this pattern is
     if some value, such as a pointer to a global table, must be
     restored.  Though it is preferred that the pointer value be
     recalculated if possible (given the address of a label for
     instance).  The single argument is a pointer to the 'jmp_buf'.
     Note that the buffer is five words long and that the first three
     are normally used by the generic mechanism.

'builtin_setjmp_receiver'
     This pattern, if defined, contains code needed at the site of a
     built-in setjmp that isn't needed at the site of a nonlocal goto.
     You will not normally need to define this pattern.  A typical
     reason why you might need this pattern is if some value, such as a
     pointer to a global table, must be restored.  It takes one
     argument, which is the label to which builtin_longjmp transferred
     control; this pattern may be emitted at a small offset from that
     label.

'builtin_longjmp'
     This pattern, if defined, performs the entire action of the
     longjmp.  You will not normally need to define this pattern unless
     you also define 'builtin_setjmp_setup'.  The single argument is a
     pointer to the 'jmp_buf'.

'eh_return'
     This pattern, if defined, affects the way '__builtin_eh_return',
     and thence the call frame exception handling library routines, are
     built.  It is intended to handle non-trivial actions needed along
     the abnormal return path.

     The address of the exception handler to which the function should
     return is passed as operand to this pattern.  It will normally need
     to copied by the pattern to some special register or memory
     location.  If the pattern needs to determine the location of the
     target call frame in order to do so, it may use
     'EH_RETURN_STACKADJ_RTX', if defined; it will have already been
     assigned.

     If this pattern is not defined, the default action will be to
     simply copy the return address to 'EH_RETURN_HANDLER_RTX'.  Either
     that macro or this pattern needs to be defined if call frame
     exception handling is to be used.

'prologue'
     This pattern, if defined, emits RTL for entry to a function.  The
     function entry is responsible for setting up the stack frame,
     initializing the frame pointer register, saving callee saved
     registers, etc.

     Using a prologue pattern is generally preferred over defining
     'TARGET_ASM_FUNCTION_PROLOGUE' to emit assembly code for the
     prologue.

     The 'prologue' pattern is particularly useful for targets which
     perform instruction scheduling.

'window_save'
     This pattern, if defined, emits RTL for a register window save.  It
     should be defined if the target machine has register windows but
     the window events are decoupled from calls to subroutines.  The
     canonical example is the SPARC architecture.

'epilogue'
     This pattern emits RTL for exit from a function.  The function exit
     is responsible for deallocating the stack frame, restoring callee
     saved registers and emitting the return instruction.

     Using an epilogue pattern is generally preferred over defining
     'TARGET_ASM_FUNCTION_EPILOGUE' to emit assembly code for the
     epilogue.

     The 'epilogue' pattern is particularly useful for targets which
     perform instruction scheduling or which have delay slots for their
     return instruction.

'sibcall_epilogue'
     This pattern, if defined, emits RTL for exit from a function
     without the final branch back to the calling function.  This
     pattern will be emitted before any sibling call (aka tail call)
     sites.

     The 'sibcall_epilogue' pattern must not clobber any arguments used
     for parameter passing or any stack slots for arguments passed to
     the current function.

'trap'
     This pattern, if defined, signals an error, typically by causing
     some kind of signal to be raised.

'ctrapMM4'
     Conditional trap instruction.  Operand 0 is a piece of RTL which
     performs a comparison, and operands 1 and 2 are the arms of the
     comparison.  Operand 3 is the trap code, an integer.

     A typical 'ctrap' pattern looks like

          (define_insn "ctrapsi4"
            [(trap_if (match_operator 0 "trap_operator"
                       [(match_operand 1 "register_operand")
                        (match_operand 2 "immediate_operand")])
                      (match_operand 3 "const_int_operand" "i"))]
            ""
            "...")

'prefetch'
     This pattern, if defined, emits code for a non-faulting data
     prefetch instruction.  Operand 0 is the address of the memory to
     prefetch.  Operand 1 is a constant 1 if the prefetch is preparing
     for a write to the memory address, or a constant 0 otherwise.
     Operand 2 is the expected degree of temporal locality of the data
     and is a value between 0 and 3, inclusive; 0 means that the data
     has no temporal locality, so it need not be left in the cache after
     the access; 3 means that the data has a high degree of temporal
     locality and should be left in all levels of cache possible; 1 and
     2 mean, respectively, a low or moderate degree of temporal
     locality.

     Targets that do not support write prefetches or locality hints can
     ignore the values of operands 1 and 2.

'blockage'
     This pattern defines a pseudo insn that prevents the instruction
     scheduler and other passes from moving instructions and using
     register equivalences across the boundary defined by the blockage
     insn.  This needs to be an UNSPEC_VOLATILE pattern or a volatile
     ASM.

'memory_blockage'
     This pattern, if defined, represents a compiler memory barrier, and
     will be placed at points across which RTL passes may not propagate
     memory accesses.  This instruction needs to read and write volatile
     BLKmode memory.  It does not need to generate any machine
     instruction.  If this pattern is not defined, the compiler falls
     back to emitting an instruction corresponding to 'asm volatile (""
     ::: "memory")'.

'memory_barrier'
     If the target memory model is not fully synchronous, then this
     pattern should be defined to an instruction that orders both loads
     and stores before the instruction with respect to loads and stores
     after the instruction.  This pattern has no operands.

'speculation_barrier'
     If the target can support speculative execution, then this pattern
     should be defined to an instruction that will block subsequent
     execution until any prior speculation conditions has been resolved.
     The pattern must also ensure that the compiler cannot move memory
     operations past the barrier, so it needs to be an UNSPEC_VOLATILE
     pattern.  The pattern has no operands.

     If this pattern is not defined then the default expansion of
     '__builtin_speculation_safe_value' will emit a warning.  You can
     suppress this warning by defining this pattern with a final
     condition of '0' (zero), which tells the compiler that a
     speculation barrier is not needed for this target.

'sync_compare_and_swapMODE'
     This pattern, if defined, emits code for an atomic compare-and-swap
     operation.  Operand 1 is the memory on which the atomic operation
     is performed.  Operand 2 is the "old" value to be compared against
     the current contents of the memory location.  Operand 3 is the
     "new" value to store in the memory if the compare succeeds.
     Operand 0 is the result of the operation; it should contain the
     contents of the memory before the operation.  If the compare
     succeeds, this should obviously be a copy of operand 2.

     This pattern must show that both operand 0 and operand 1 are
     modified.

     This pattern must issue any memory barrier instructions such that
     all memory operations before the atomic operation occur before the
     atomic operation and all memory operations after the atomic
     operation occur after the atomic operation.

     For targets where the success or failure of the compare-and-swap
     operation is available via the status flags, it is possible to
     avoid a separate compare operation and issue the subsequent branch
     or store-flag operation immediately after the compare-and-swap.  To
     this end, GCC will look for a 'MODE_CC' set in the output of
     'sync_compare_and_swapMODE'; if the machine description includes
     such a set, the target should also define special 'cbranchcc4'
     and/or 'cstorecc4' instructions.  GCC will then be able to take the
     destination of the 'MODE_CC' set and pass it to the 'cbranchcc4' or
     'cstorecc4' pattern as the first operand of the comparison (the
     second will be '(const_int 0)').

     For targets where the operating system may provide support for this
     operation via library calls, the 'sync_compare_and_swap_optab' may
     be initialized to a function with the same interface as the
     '__sync_val_compare_and_swap_N' built-in.  If the entire set of
     __SYNC builtins are supported via library calls, the target can
     initialize all of the optabs at once with 'init_sync_libfuncs'.
     For the purposes of C++11 'std::atomic::is_lock_free', it is
     assumed that these library calls do _not_ use any kind of
     interruptable locking.

'sync_addMODE', 'sync_subMODE'
'sync_iorMODE', 'sync_andMODE'
'sync_xorMODE', 'sync_nandMODE'
     These patterns emit code for an atomic operation on memory.
     Operand 0 is the memory on which the atomic operation is performed.
     Operand 1 is the second operand to the binary operator.

     This pattern must issue any memory barrier instructions such that
     all memory operations before the atomic operation occur before the
     atomic operation and all memory operations after the atomic
     operation occur after the atomic operation.

     If these patterns are not defined, the operation will be
     constructed from a compare-and-swap operation, if defined.

'sync_old_addMODE', 'sync_old_subMODE'
'sync_old_iorMODE', 'sync_old_andMODE'
'sync_old_xorMODE', 'sync_old_nandMODE'
     These patterns emit code for an atomic operation on memory, and
     return the value that the memory contained before the operation.
     Operand 0 is the result value, operand 1 is the memory on which the
     atomic operation is performed, and operand 2 is the second operand
     to the binary operator.

     This pattern must issue any memory barrier instructions such that
     all memory operations before the atomic operation occur before the
     atomic operation and all memory operations after the atomic
     operation occur after the atomic operation.

     If these patterns are not defined, the operation will be
     constructed from a compare-and-swap operation, if defined.

'sync_new_addMODE', 'sync_new_subMODE'
'sync_new_iorMODE', 'sync_new_andMODE'
'sync_new_xorMODE', 'sync_new_nandMODE'
     These patterns are like their 'sync_old_OP' counterparts, except
     that they return the value that exists in the memory location after
     the operation, rather than before the operation.

'sync_lock_test_and_setMODE'
     This pattern takes two forms, based on the capabilities of the
     target.  In either case, operand 0 is the result of the operand,
     operand 1 is the memory on which the atomic operation is performed,
     and operand 2 is the value to set in the lock.

     In the ideal case, this operation is an atomic exchange operation,
     in which the previous value in memory operand is copied into the
     result operand, and the value operand is stored in the memory
     operand.

     For less capable targets, any value operand that is not the
     constant 1 should be rejected with 'FAIL'.  In this case the target
     may use an atomic test-and-set bit operation.  The result operand
     should contain 1 if the bit was previously set and 0 if the bit was
     previously clear.  The true contents of the memory operand are
     implementation defined.

     This pattern must issue any memory barrier instructions such that
     the pattern as a whole acts as an acquire barrier, that is all
     memory operations after the pattern do not occur until the lock is
     acquired.

     If this pattern is not defined, the operation will be constructed
     from a compare-and-swap operation, if defined.

'sync_lock_releaseMODE'
     This pattern, if defined, releases a lock set by
     'sync_lock_test_and_setMODE'.  Operand 0 is the memory that
     contains the lock; operand 1 is the value to store in the lock.

     If the target doesn't implement full semantics for
     'sync_lock_test_and_setMODE', any value operand which is not the
     constant 0 should be rejected with 'FAIL', and the true contents of
     the memory operand are implementation defined.

     This pattern must issue any memory barrier instructions such that
     the pattern as a whole acts as a release barrier, that is the lock
     is released only after all previous memory operations have
     completed.

     If this pattern is not defined, then a 'memory_barrier' pattern
     will be emitted, followed by a store of the value to the memory
     operand.

'atomic_compare_and_swapMODE'
     This pattern, if defined, emits code for an atomic compare-and-swap
     operation with memory model semantics.  Operand 2 is the memory on
     which the atomic operation is performed.  Operand 0 is an output
     operand which is set to true or false based on whether the
     operation succeeded.  Operand 1 is an output operand which is set
     to the contents of the memory before the operation was attempted.
     Operand 3 is the value that is expected to be in memory.  Operand 4
     is the value to put in memory if the expected value is found there.
     Operand 5 is set to 1 if this compare and swap is to be treated as
     a weak operation.  Operand 6 is the memory model to be used if the
     operation is a success.  Operand 7 is the memory model to be used
     if the operation fails.

     If memory referred to in operand 2 contains the value in operand 3,
     then operand 4 is stored in memory pointed to by operand 2 and
     fencing based on the memory model in operand 6 is issued.

     If memory referred to in operand 2 does not contain the value in
     operand 3, then fencing based on the memory model in operand 7 is
     issued.

     If a target does not support weak compare-and-swap operations, or
     the port elects not to implement weak operations, the argument in
     operand 5 can be ignored.  Note a strong implementation must be
     provided.

     If this pattern is not provided, the '__atomic_compare_exchange'
     built-in functions will utilize the legacy 'sync_compare_and_swap'
     pattern with an '__ATOMIC_SEQ_CST' memory model.

'atomic_loadMODE'
     This pattern implements an atomic load operation with memory model
     semantics.  Operand 1 is the memory address being loaded from.
     Operand 0 is the result of the load.  Operand 2 is the memory model
     to be used for the load operation.

     If not present, the '__atomic_load' built-in function will either
     resort to a normal load with memory barriers, or a compare-and-swap
     operation if a normal load would not be atomic.

'atomic_storeMODE'
     This pattern implements an atomic store operation with memory model
     semantics.  Operand 0 is the memory address being stored to.
     Operand 1 is the value to be written.  Operand 2 is the memory
     model to be used for the operation.

     If not present, the '__atomic_store' built-in function will attempt
     to perform a normal store and surround it with any required memory
     fences.  If the store would not be atomic, then an
     '__atomic_exchange' is attempted with the result being ignored.

'atomic_exchangeMODE'
     This pattern implements an atomic exchange operation with memory
     model semantics.  Operand 1 is the memory location the operation is
     performed on.  Operand 0 is an output operand which is set to the
     original value contained in the memory pointed to by operand 1.
     Operand 2 is the value to be stored.  Operand 3 is the memory model
     to be used.

     If this pattern is not present, the built-in function
     '__atomic_exchange' will attempt to preform the operation with a
     compare and swap loop.

'atomic_addMODE', 'atomic_subMODE'
'atomic_orMODE', 'atomic_andMODE'
'atomic_xorMODE', 'atomic_nandMODE'
     These patterns emit code for an atomic operation on memory with
     memory model semantics.  Operand 0 is the memory on which the
     atomic operation is performed.  Operand 1 is the second operand to
     the binary operator.  Operand 2 is the memory model to be used by
     the operation.

     If these patterns are not defined, attempts will be made to use
     legacy 'sync' patterns, or equivalent patterns which return a
     result.  If none of these are available a compare-and-swap loop
     will be used.

'atomic_fetch_addMODE', 'atomic_fetch_subMODE'
'atomic_fetch_orMODE', 'atomic_fetch_andMODE'
'atomic_fetch_xorMODE', 'atomic_fetch_nandMODE'
     These patterns emit code for an atomic operation on memory with
     memory model semantics, and return the original value.  Operand 0
     is an output operand which contains the value of the memory
     location before the operation was performed.  Operand 1 is the
     memory on which the atomic operation is performed.  Operand 2 is
     the second operand to the binary operator.  Operand 3 is the memory
     model to be used by the operation.

     If these patterns are not defined, attempts will be made to use
     legacy 'sync' patterns.  If none of these are available a
     compare-and-swap loop will be used.

'atomic_add_fetchMODE', 'atomic_sub_fetchMODE'
'atomic_or_fetchMODE', 'atomic_and_fetchMODE'
'atomic_xor_fetchMODE', 'atomic_nand_fetchMODE'
     These patterns emit code for an atomic operation on memory with
     memory model semantics and return the result after the operation is
     performed.  Operand 0 is an output operand which contains the value
     after the operation.  Operand 1 is the memory on which the atomic
     operation is performed.  Operand 2 is the second operand to the
     binary operator.  Operand 3 is the memory model to be used by the
     operation.

     If these patterns are not defined, attempts will be made to use
     legacy 'sync' patterns, or equivalent patterns which return the
     result before the operation followed by the arithmetic operation
     required to produce the result.  If none of these are available a
     compare-and-swap loop will be used.

'atomic_test_and_set'
     This pattern emits code for '__builtin_atomic_test_and_set'.
     Operand 0 is an output operand which is set to true if the previous
     previous contents of the byte was "set", and false otherwise.
     Operand 1 is the 'QImode' memory to be modified.  Operand 2 is the
     memory model to be used.

     The specific value that defines "set" is implementation defined,
     and is normally based on what is performed by the native atomic
     test and set instruction.

'atomic_bit_test_and_setMODE'
'atomic_bit_test_and_complementMODE'
'atomic_bit_test_and_resetMODE'
     These patterns emit code for an atomic bitwise operation on memory
     with memory model semantics, and return the original value of the
     specified bit.  Operand 0 is an output operand which contains the
     value of the specified bit from the memory location before the
     operation was performed.  Operand 1 is the memory on which the
     atomic operation is performed.  Operand 2 is the bit within the
     operand, starting with least significant bit.  Operand 3 is the
     memory model to be used by the operation.  Operand 4 is a flag - it
     is 'const1_rtx' if operand 0 should contain the original value of
     the specified bit in the least significant bit of the operand, and
     'const0_rtx' if the bit should be in its original position in the
     operand.  'atomic_bit_test_and_setMODE' atomically sets the
     specified bit after remembering its original value,
     'atomic_bit_test_and_complementMODE' inverts the specified bit and
     'atomic_bit_test_and_resetMODE' clears the specified bit.

     If these patterns are not defined, attempts will be made to use
     'atomic_fetch_orMODE', 'atomic_fetch_xorMODE' or
     'atomic_fetch_andMODE' instruction patterns, or their 'sync'
     counterparts.  If none of these are available a compare-and-swap
     loop will be used.

'mem_thread_fence'
     This pattern emits code required to implement a thread fence with
     memory model semantics.  Operand 0 is the memory model to be used.

     For the '__ATOMIC_RELAXED' model no instructions need to be issued
     and this expansion is not invoked.

     The compiler always emits a compiler memory barrier regardless of
     what expanding this pattern produced.

     If this pattern is not defined, the compiler falls back to
     expanding the 'memory_barrier' pattern, then to emitting
     '__sync_synchronize' library call, and finally to just placing a
     compiler memory barrier.

'get_thread_pointerMODE'
'set_thread_pointerMODE'
     These patterns emit code that reads/sets the TLS thread pointer.
     Currently, these are only needed if the target needs to support the
     '__builtin_thread_pointer' and '__builtin_set_thread_pointer'
     builtins.

     The get/set patterns have a single output/input operand
     respectively, with MODE intended to be 'Pmode'.

'stack_protect_combined_set'
     This pattern, if defined, moves a 'ptr_mode' value from an address
     whose declaration RTX is given in operand 1 to the memory in
     operand 0 without leaving the value in a register afterward.  If
     several instructions are needed by the target to perform the
     operation (eg.  to load the address from a GOT entry then load the
     'ptr_mode' value and finally store it), it is the backend's
     responsibility to ensure no intermediate result gets spilled.  This
     is to avoid leaking the value some place that an attacker might use
     to rewrite the stack guard slot after having clobbered it.

     If this pattern is not defined, then the address declaration is
     expanded first in the standard way and a 'stack_protect_set'
     pattern is then generated to move the value from that address to
     the address in operand 0.

'stack_protect_set'
     This pattern, if defined, moves a 'ptr_mode' value from the valid
     memory location in operand 1 to the memory in operand 0 without
     leaving the value in a register afterward.  This is to avoid
     leaking the value some place that an attacker might use to rewrite
     the stack guard slot after having clobbered it.

     Note: on targets where the addressing modes do not allow to load
     directly from stack guard address, the address is expanded in a
     standard way first which could cause some spills.

     If this pattern is not defined, then a plain move pattern is
     generated.

'stack_protect_combined_test'
     This pattern, if defined, compares a 'ptr_mode' value from an
     address whose declaration RTX is given in operand 1 with the memory
     in operand 0 without leaving the value in a register afterward and
     branches to operand 2 if the values were equal.  If several
     instructions are needed by the target to perform the operation (eg.
     to load the address from a GOT entry then load the 'ptr_mode' value
     and finally store it), it is the backend's responsibility to ensure
     no intermediate result gets spilled.  This is to avoid leaking the
     value some place that an attacker might use to rewrite the stack
     guard slot after having clobbered it.

     If this pattern is not defined, then the address declaration is
     expanded first in the standard way and a 'stack_protect_test'
     pattern is then generated to compare the value from that address to
     the value at the memory in operand 0.

'stack_protect_test'
     This pattern, if defined, compares a 'ptr_mode' value from the
     valid memory location in operand 1 with the memory in operand 0
     without leaving the value in a register afterward and branches to
     operand 2 if the values were equal.

     If this pattern is not defined, then a plain compare pattern and
     conditional branch pattern is used.

'clear_cache'
     This pattern, if defined, flushes the instruction cache for a
     region of memory.  The region is bounded to by the Pmode pointers
     in operand 0 inclusive and operand 1 exclusive.

     If this pattern is not defined, a call to the library function
     '__clear_cache' is used.

==============================================================================
File: gccint.info,  Node: |Pattern_Ordering|,  Next: |Dependent_Patterns|,  Prev: |Standard_Names|,  Up: |Machine_Desc|
==============================================================================

                                                              *Pattern_Ordering*

17.10 When the Order of Patterns Matters
=====-----------------------------------

Sometimes an insn can match more than one instruction pattern.  Then the
pattern that appears first in the machine description is the one used.
Therefore, more specific patterns (patterns that will match fewer
things) and faster instructions (those that will produce better code
when they do match) should usually go first in the description.

 In some cases the effect of ordering the patterns can be used to hide a
pattern when it is not valid.  For example, the 68000 has an instruction
for converting a fullword to floating point and another for converting a
byte to floating point.  An instruction converting an integer to
floating point could match either one.  We put the pattern to convert
the fullword first to make sure that one will be used rather than the
other.  (Otherwise a large integer might be generated as a single-byte
immediate quantity, which would not work.)  Instead of using this
pattern ordering it would be possible to make the pattern for
convert-a-byte smart enough to deal properly with any constant value.

==============================================================================
File: gccint.info,  Node: |Dependent_Patterns|,  Next: |Jump_Patterns|,  Prev: |Pattern_Ordering|,  Up: |Machine_Desc|
==============================================================================

                                                            *Dependent_Patterns*

17.11 Interdependence of Patterns
=====----------------------------

In some cases machines support instructions identical except for the
machine mode of one or more operands.  For example, there may be
"sign-extend halfword" and "sign-extend byte" instructions whose
patterns are

     (set (match_operand:SI 0 ...)
          (extend:SI (match_operand:HI 1 ...)))

     (set (match_operand:SI 0 ...)
          (extend:SI (match_operand:QI 1 ...)))

Constant integers do not specify a machine mode, so an instruction to
extend a constant value could match either pattern.  The pattern it
actually will match is the one that appears first in the file.  For
correct results, this must be the one for the widest possible mode
('HImode', here).  If the pattern matches the 'QImode' instruction, the
results will be incorrect if the constant value does not actually fit
that mode.

 Such instructions to extend constants are rarely generated because they
are optimized away, but they do occasionally happen in nonoptimized
compilations.

 If a constraint in a pattern allows a constant, the reload pass may
replace a register with a constant permitted by the constraint in some
cases.  Similarly for memory references.  Because of this substitution,
you should not provide separate patterns for increment and decrement
instructions.  Instead, they should be generated from the same pattern
that supports register-register add insns by examining the operands and
generating the appropriate machine instruction.

==============================================================================
File: gccint.info,  Node: |Jump_Patterns|,  Next: |Looping_Patterns|,  Prev: |Dependent_Patterns|,  Up: |Machine_Desc|
==============================================================================

                                                                 *Jump_Patterns*

17.12 Defining Jump Instruction Patterns
=====-----------------------------------

GCC does not assume anything about how the machine realizes jumps.  The
machine description should define a single pattern, usually a
'define_expand', which expands to all the required insns.

 Usually, this would be a comparison insn to set the condition code and
a separate branch insn testing the condition code and branching or not
according to its value.  For many machines, however, separating compares
and branches is limiting, which is why the more flexible approach with
one 'define_expand' is used in GCC. The machine description becomes
clearer for architectures that have compare-and-branch instructions but
no condition code.  It also works better when different sets of
comparison operators are supported by different kinds of conditional
branches (e.g. integer vs. floating-point), or by conditional branches
with respect to conditional stores.

 Two separate insns are always used if the machine description
represents a condition code register using the legacy RTL expression
'(cc0)', and on most machines that use a separate condition code
register (*note Condition Code::).  For machines that use '(cc0)', in
fact, the set and use of the condition code must be separate and
adjacent(1), thus allowing flags in 'cc_status' to be used (*note
Condition Code::) and so that the comparison and branch insns could be
located from each other by using the functions 'prev_cc0_setter' and
'next_cc0_user'.

 Even in this case having a single entry point for conditional branches
is advantageous, because it handles equally well the case where a single
comparison instruction records the results of both signed and unsigned
comparison of the given operands (with the branch insns coming in
distinct signed and unsigned flavors) as in the x86 or SPARC, and the
case where there are distinct signed and unsigned compare instructions
and only one set of conditional branch instructions as in the PowerPC.

   ---------- Footnotes ----------

   (1) 'note' insns can separate them, though.

==============================================================================
File: gccint.info,  Node: |Looping_Patterns|,  Next: |Insn_Canonicalizations|,  Prev: |Jump_Patterns|,  Up: |Machine_Desc|
==============================================================================

                                                              *Looping_Patterns*

17.13 Defining Looping Instruction Patterns
=====--------------------------------------

Some machines have special jump instructions that can be utilized to
make loops more efficient.  A common example is the 68000 'dbra'
instruction which performs a decrement of a register and a branch if the
result was greater than zero.  Other machines, in particular digital
signal processors (DSPs), have special block repeat instructions to
provide low-overhead loop support.  For example, the TI TMS320C3x/C4x
DSPs have a block repeat instruction that loads special registers to
mark the top and end of a loop and to count the number of loop
iterations.  This avoids the need for fetching and executing a
'dbra'-like instruction and avoids pipeline stalls associated with the
jump.

 GCC has two special named patterns to support low overhead looping.
They are 'doloop_begin' and 'doloop_end'.  These are emitted by the loop
optimizer for certain well-behaved loops with a finite number of loop
iterations using information collected during strength reduction.

 The 'doloop_end' pattern describes the actual looping instruction (or
the implicit looping operation) and the 'doloop_begin' pattern is an
optional companion pattern that can be used for initialization needed
for some low-overhead looping instructions.

 Note that some machines require the actual looping instruction to be
emitted at the top of the loop (e.g., the TMS320C3x/C4x DSPs).  Emitting
the true RTL for a looping instruction at the top of the loop can cause
problems with flow analysis.  So instead, a dummy 'doloop' insn is
emitted at the end of the loop.  The machine dependent reorg pass checks
for the presence of this 'doloop' insn and then searches back to the top
of the loop, where it inserts the true looping insn (provided there are
no instructions in the loop which would cause problems).  Any additional
labels can be emitted at this point.  In addition, if the desired
special iteration counter register was not allocated, this machine
dependent reorg pass could emit a traditional compare and jump
instruction pair.

 For the 'doloop_end' pattern, the loop optimizer allocates an
additional pseudo register as an iteration counter.  This pseudo
register cannot be used within the loop (i.e., general induction
variables cannot be derived from it), however, in many cases the loop
induction variable may become redundant and removed by the flow pass.

 The 'doloop_end' pattern must have a specific structure to be handled
correctly by GCC. The example below is taken (slightly simplified) from
the PDP-11 target:

     (define_expand "doloop_end"
       [(parallel [(set (pc)
                        (if_then_else
                         (ne (match_operand:HI 0 "nonimmediate_operand" "+r,!m")
                             (const_int 1))
                         (label_ref (match_operand 1 "" ""))
                         (pc)))
                   (set (match_dup 0)
                        (plus:HI (match_dup 0)
                              (const_int -1)))])]
       ""
       "{
         if (GET_MODE (operands[0]) != HImode)
           FAIL;
       }")

     (define_insn "doloop_end_insn"
       [(set (pc)
             (if_then_else
              (ne (match_operand:HI 0 "nonimmediate_operand" "+r,!m")
                  (const_int 1))
              (label_ref (match_operand 1 "" ""))
              (pc)))
        (set (match_dup 0)
             (plus:HI (match_dup 0)
                   (const_int -1)))]
       ""

       {
         if (which_alternative == 0)
           return "sob %0,%l1";

         /* emulate sob */
         output_asm_insn ("dec %0", operands);
         return "bne %l1";
       })

 The first part of the pattern describes the branch condition.  GCC
supports three cases for the way the target machine handles the loop
counter:
   * Loop terminates when the loop register decrements to zero.  This is
     represented by a 'ne' comparison of the register (its old value)
     with constant 1 (as in the example above).
   * Loop terminates when the loop register decrements to -1.  This is
     represented by a 'ne' comparison of the register with constant
     zero.
   * Loop terminates when the loop register decrements to a negative
     value.  This is represented by a 'ge' comparison of the register
     with constant zero.  For this case, GCC will attach a 'REG_NONNEG'
     note to the 'doloop_end' insn if it can determine that the register
     will be non-negative.

 Since the 'doloop_end' insn is a jump insn that also has an output, the
reload pass does not handle the output operand.  Therefore, the
constraint must allow for that operand to be in memory rather than a
register.  In the example shown above, that is handled (in the
'doloop_end_insn' pattern) by using a loop instruction sequence that can
handle memory operands when the memory alternative appears.

 GCC does not check the mode of the loop register operand when
generating the 'doloop_end' pattern.  If the pattern is only valid for
some modes but not others, the pattern should be a 'define_expand'
pattern that checks the operand mode in the preparation code, and issues
'FAIL' if an unsupported mode is found.  The example above does this,
since the machine instruction to be used only exists for 'HImode'.

 If the 'doloop_end' pattern is a 'define_expand', there must also be a
'define_insn' or 'define_insn_and_split' matching the generated pattern.
Otherwise, the compiler will fail during loop optimization.

==============================================================================
File: gccint.info,  Node: |Insn_Canonicalizations|,  Next: |Expander_Definitions|,  Prev: |Looping_Patterns|,  Up: |Machine_Desc|
==============================================================================

                                                        *Insn_Canonicalizations*

17.14 Canonicalization of Instructions
=====---------------------------------

There are often cases where multiple RTL expressions could represent an
operation performed by a single machine instruction.  This situation is
most commonly encountered with logical, branch, and multiply-accumulate
instructions.  In such cases, the compiler attempts to convert these
multiple RTL expressions into a single canonical form to reduce the
number of insn patterns required.

 In addition to algebraic simplifications, following canonicalizations
are performed:

   * For commutative and comparison operators, a constant is always made
     the second operand.  If a machine only supports a constant as the
     second operand, only patterns that match a constant in the second
     operand need be supplied.

   * For associative operators, a sequence of operators will always
     chain to the left; for instance, only the left operand of an
     integer 'plus' can itself be a 'plus'.  'and', 'ior', 'xor',
     'plus', 'mult', 'smin', 'smax', 'umin', and 'umax' are associative
     when applied to integers, and sometimes to floating-point.

   * For these operators, if only one operand is a 'neg', 'not', 'mult',
     'plus', or 'minus' expression, it will be the first operand.

   * In combinations of 'neg', 'mult', 'plus', and 'minus', the 'neg'
     operations (if any) will be moved inside the operations as far as
     possible.  For instance, '(neg (mult A B))' is canonicalized as
     '(mult (neg A) B)', but '(plus (mult (neg B) C) A)' is
     canonicalized as '(minus A (mult B C))'.

   * For the 'compare' operator, a constant is always the second operand
     if the first argument is a condition code register or '(cc0)'.

   * For instructions that inherently set a condition code register, the
     'compare' operator is always written as the first RTL expression of
     the 'parallel' instruction pattern.  For example,

          (define_insn ""
            [(set (reg:CCZ FLAGS_REG)
          	(compare:CCZ
          	  (plus:SI
          	    (match_operand:SI 1 "register_operand" "%r")
          	    (match_operand:SI 2 "register_operand" "r"))
          	  (const_int 0)))
             (set (match_operand:SI 0 "register_operand" "=r")
          	(plus:SI (match_dup 1) (match_dup 2)))]
            ""
            "addl %0, %1, %2")

   * An operand of 'neg', 'not', 'mult', 'plus', or 'minus' is made the
     first operand under the same conditions as above.

   * '(ltu (plus A B) B)' is converted to '(ltu (plus A B) A)'.
     Likewise with 'geu' instead of 'ltu'.

   * '(minus X (const_int N))' is converted to '(plus X (const_int
     -N))'.

   * Within address computations (i.e., inside 'mem'), a left shift is
     converted into the appropriate multiplication by a power of two.

   * De Morgan's Law is used to move bitwise negation inside a bitwise
     logical-and or logical-or operation.  If this results in only one
     operand being a 'not' expression, it will be the first one.

     A machine that has an instruction that performs a bitwise
     logical-and of one operand with the bitwise negation of the other
     should specify the pattern for that instruction as

          (define_insn ""
            [(set (match_operand:M 0 ...)
                  (and:M (not:M (match_operand:M 1 ...))
                               (match_operand:M 2 ...)))]
            "..."
            "...")

     Similarly, a pattern for a "NAND" instruction should be written

          (define_insn ""
            [(set (match_operand:M 0 ...)
                  (ior:M (not:M (match_operand:M 1 ...))
                               (not:M (match_operand:M 2 ...))))]
            "..."
            "...")

     In both cases, it is not necessary to include patterns for the many
     logically equivalent RTL expressions.

   * The only possible RTL expressions involving both bitwise
     exclusive-or and bitwise negation are '(xor:M X Y)' and '(not:M
     (xor:M X Y))'.

   * The sum of three items, one of which is a constant, will only
     appear in the form

          (plus:M (plus:M X Y) CONSTANT)

   * Equality comparisons of a group of bits (usually a single bit) with
     zero will be written using 'zero_extract' rather than the
     equivalent 'and' or 'sign_extract' operations.

   * '(sign_extend:M1 (mult:M2 (sign_extend:M2 X) (sign_extend:M2 Y)))'
     is converted to '(mult:M1 (sign_extend:M1 X) (sign_extend:M1 Y))',
     and likewise for 'zero_extend'.

   * '(sign_extend:M1 (mult:M2 (ashiftrt:M2 X S) (sign_extend:M2 Y)))'
     is converted to '(mult:M1 (sign_extend:M1 (ashiftrt:M2 X S))
     (sign_extend:M1 Y))', and likewise for patterns using 'zero_extend'
     and 'lshiftrt'.  If the second operand of 'mult' is also a shift,
     then that is extended also.  This transformation is only applied
     when it can be proven that the original operation had sufficient
     precision to prevent overflow.

 Further canonicalization rules are defined in the function
'commutative_operand_precedence' in 'gcc/rtlanal.c'.

==============================================================================
File: gccint.info,  Node: |Expander_Definitions|,  Next: |Insn_Splitting|,  Prev: |Insn_Canonicalizations|,  Up: |Machine_Desc|
==============================================================================

                                                          *Expander_Definitions*

17.15 Defining RTL Sequences for Code Generation
=====-------------------------------------------

On some target machines, some standard pattern names for RTL generation
cannot be handled with single insn, but a sequence of RTL insns can
represent them.  For these target machines, you can write a
'define_expand' to specify how to generate the sequence of RTL.

 A 'define_expand' is an RTL expression that looks almost like a
'define_insn'; but, unlike the latter, a 'define_expand' is used only
for RTL generation and it can produce more than one RTL insn.

 A 'define_expand' RTX has four operands:

   * The name.  Each 'define_expand' must have a name, since the only
     use for it is to refer to it by name.

   * The RTL template.  This is a vector of RTL expressions representing
     a sequence of separate instructions.  Unlike 'define_insn', there
     is no implicit surrounding 'PARALLEL'.

   * The condition, a string containing a C expression.  This expression
     is used to express how the availability of this pattern depends on
     subclasses of target machine, selected by command-line options when
     GCC is run.  This is just like the condition of a 'define_insn'
     that has a standard name.  Therefore, the condition (if present)
     may not depend on the data in the insn being matched, but only the
     target-machine-type flags.  The compiler needs to test these
     conditions during initialization in order to learn exactly which
     named instructions are available in a particular run.

   * The preparation statements, a string containing zero or more C
     statements which are to be executed before RTL code is generated
     from the RTL template.

     Usually these statements prepare temporary registers for use as
     internal operands in the RTL template, but they can also generate
     RTL insns directly by calling routines such as 'emit_insn', etc.
     Any such insns precede the ones that come from the RTL template.

   * Optionally, a vector containing the values of attributes.  *Note
     Insn Attributes::.

 Every RTL insn emitted by a 'define_expand' must match some
'define_insn' in the machine description.  Otherwise, the compiler will
crash when trying to generate code for the insn or trying to optimize
it.

 The RTL template, in addition to controlling generation of RTL insns,
also describes the operands that need to be specified when this pattern
is used.  In particular, it gives a predicate for each operand.

 A true operand, which needs to be specified in order to generate RTL
from the pattern, should be described with a 'match_operand' in its
first occurrence in the RTL template.  This enters information on the
operand's predicate into the tables that record such things.  GCC uses
the information to preload the operand into a register if that is
required for valid RTL code.  If the operand is referred to more than
once, subsequent references should use 'match_dup'.

 The RTL template may also refer to internal "operands" which are
temporary registers or labels used only within the sequence made by the
'define_expand'.  Internal operands are substituted into the RTL
template with 'match_dup', never with 'match_operand'.  The values of
the internal operands are not passed in as arguments by the compiler
when it requests use of this pattern.  Instead, they are computed within
the pattern, in the preparation statements.  These statements compute
the values and store them into the appropriate elements of 'operands' so
that 'match_dup' can find them.

 There are two special macros defined for use in the preparation
statements: 'DONE' and 'FAIL'.  Use them with a following semicolon, as
a statement.

'DONE'
     Use the 'DONE' macro to end RTL generation for the pattern.  The
     only RTL insns resulting from the pattern on this occasion will be
     those already emitted by explicit calls to 'emit_insn' within the
     preparation statements; the RTL template will not be generated.

'FAIL'
     Make the pattern fail on this occasion.  When a pattern fails, it
     means that the pattern was not truly available.  The calling
     routines in the compiler will try other strategies for code
     generation using other patterns.

     Failure is currently supported only for binary (addition,
     multiplication, shifting, etc.)  and bit-field ('extv', 'extzv',
     and 'insv') operations.

 If the preparation falls through (invokes neither 'DONE' nor 'FAIL'),
then the 'define_expand' acts like a 'define_insn' in that the RTL
template is used to generate the insn.

 The RTL template is not used for matching, only for generating the
initial insn list.  If the preparation statement always invokes 'DONE'
or 'FAIL', the RTL template may be reduced to a simple list of operands,
such as this example:

     (define_expand "addsi3"
       [(match_operand:SI 0 "register_operand" "")
        (match_operand:SI 1 "register_operand" "")
        (match_operand:SI 2 "register_operand" "")]
       ""
       "
     {
       handle_add (operands[0], operands[1], operands[2]);
       DONE;
     }")

 Here is an example, the definition of left-shift for the SPUR chip:

     (define_expand "ashlsi3"
       [(set (match_operand:SI 0 "register_operand" "")
             (ashift:SI
               (match_operand:SI 1 "register_operand" "")
               (match_operand:SI 2 "nonmemory_operand" "")))]
       ""
       "

     {
       if (GET_CODE (operands[2]) != CONST_INT
           || (unsigned) INTVAL (operands[2]) > 3)
         FAIL;
     }")

This example uses 'define_expand' so that it can generate an RTL insn
for shifting when the shift-count is in the supported range of 0 to 3
but fail in other cases where machine insns aren't available.  When it
fails, the compiler tries another strategy using different patterns
(such as, a library call).

 If the compiler were able to handle nontrivial condition-strings in
patterns with names, then it would be possible to use a 'define_insn' in
that case.  Here is another case (zero-extension on the 68000) which
makes more use of the power of 'define_expand':

     (define_expand "zero_extendhisi2"
       [(set (match_operand:SI 0 "general_operand" "")
             (const_int 0))
        (set (strict_low_part
               (subreg:HI
                 (match_dup 0)
                 0))
             (match_operand:HI 1 "general_operand" ""))]
       ""
       "operands[1] = make_safe_from (operands[1], operands[0]);")

Here two RTL insns are generated, one to clear the entire output operand
and the other to copy the input operand into its low half.  This
sequence is incorrect if the input operand refers to [the old value of]
the output operand, so the preparation statement makes sure this isn't
so.  The function 'make_safe_from' copies the 'operands[1]' into a
temporary register if it refers to 'operands[0]'.  It does this by
emitting another RTL insn.

 Finally, a third example shows the use of an internal operand.
Zero-extension on the SPUR chip is done by 'and'-ing the result against
a halfword mask.  But this mask cannot be represented by a 'const_int'
because the constant value is too large to be legitimate on this
machine.  So it must be copied into a register with 'force_reg' and then
the register used in the 'and'.

     (define_expand "zero_extendhisi2"
       [(set (match_operand:SI 0 "register_operand" "")
             (and:SI (subreg:SI
                       (match_operand:HI 1 "register_operand" "")
                       0)
                     (match_dup 2)))]
       ""
       "operands[2]
          = force_reg (SImode, GEN_INT (65535)); ")

 _Note:_ If the 'define_expand' is used to serve a standard binary or
unary arithmetic operation or a bit-field operation, then the last insn
it generates must not be a 'code_label', 'barrier' or 'note'.  It must
be an 'insn', 'jump_insn' or 'call_insn'.  If you don't need a real insn
at the end, emit an insn to copy the result of the operation into
itself.  Such an insn will generate no code, but it can avoid problems
in the compiler.

==============================================================================
File: gccint.info,  Node: |Insn_Splitting|,  Next: |Including_Patterns|,  Prev: |Expander_Definitions|,  Up: |Machine_Desc|
==============================================================================

                                                                *Insn_Splitting*

17.16 Defining How to Split Instructions
=====-----------------------------------

There are two cases where you should specify how to split a pattern into
multiple insns.  On machines that have instructions requiring delay
slots (*note Delay Slots::) or that have instructions whose output is
not available for multiple cycles (*note Processor pipeline
description::), the compiler phases that optimize these cases need to be
able to move insns into one-instruction delay slots.  However, some
insns may generate more than one machine instruction.  These insns
cannot be placed into a delay slot.

 Often you can rewrite the single insn as a list of individual insns,
each corresponding to one machine instruction.  The disadvantage of
doing so is that it will cause the compilation to be slower and require
more space.  If the resulting insns are too complex, it may also
suppress some optimizations.  The compiler splits the insn if there is a
reason to believe that it might improve instruction or delay slot
scheduling.

 The insn combiner phase also splits putative insns.  If three insns are
merged into one insn with a complex expression that cannot be matched by
some 'define_insn' pattern, the combiner phase attempts to split the
complex pattern into two insns that are recognized.  Usually it can
break the complex pattern into two patterns by splitting out some
subexpression.  However, in some other cases, such as performing an
addition of a large constant in two insns on a RISC machine, the way to
split the addition into two insns is machine-dependent.

 The 'define_split' definition tells the compiler how to split a complex
insn into several simpler insns.  It looks like this:

     (define_split
       [INSN-PATTERN]
       "CONDITION"
       [NEW-INSN-PATTERN-1
        NEW-INSN-PATTERN-2
        ...]
       "PREPARATION-STATEMENTS")

 INSN-PATTERN is a pattern that needs to be split and CONDITION is the
final condition to be tested, as in a 'define_insn'.  When an insn
matching INSN-PATTERN and satisfying CONDITION is found, it is replaced
in the insn list with the insns given by NEW-INSN-PATTERN-1,
NEW-INSN-PATTERN-2, etc.

 The PREPARATION-STATEMENTS are similar to those statements that are
specified for 'define_expand' (*note Expander Definitions::) and are
executed before the new RTL is generated to prepare for the generated
code or emit some insns whose pattern is not fixed.  Unlike those in
'define_expand', however, these statements must not generate any new
pseudo-registers.  Once reload has completed, they also must not
allocate any space in the stack frame.

 There are two special macros defined for use in the preparation
statements: 'DONE' and 'FAIL'.  Use them with a following semicolon, as
a statement.

'DONE'
     Use the 'DONE' macro to end RTL generation for the splitter.  The
     only RTL insns generated as replacement for the matched input insn
     will be those already emitted by explicit calls to 'emit_insn'
     within the preparation statements; the replacement pattern is not
     used.

'FAIL'
     Make the 'define_split' fail on this occasion.  When a
     'define_split' fails, it means that the splitter was not truly
     available for the inputs it was given, and the input insn will not
     be split.

 If the preparation falls through (invokes neither 'DONE' nor 'FAIL'),
then the 'define_split' uses the replacement template.

 Patterns are matched against INSN-PATTERN in two different
circumstances.  If an insn needs to be split for delay slot scheduling
or insn scheduling, the insn is already known to be valid, which means
that it must have been matched by some 'define_insn' and, if
'reload_completed' is nonzero, is known to satisfy the constraints of
that 'define_insn'.  In that case, the new insn patterns must also be
insns that are matched by some 'define_insn' and, if 'reload_completed'
is nonzero, must also satisfy the constraints of those definitions.

 As an example of this usage of 'define_split', consider the following
example from 'a29k.md', which splits a 'sign_extend' from 'HImode' to
'SImode' into a pair of shift insns:

     (define_split
       [(set (match_operand:SI 0 "gen_reg_operand" "")
             (sign_extend:SI (match_operand:HI 1 "gen_reg_operand" "")))]
       ""
       [(set (match_dup 0)
             (ashift:SI (match_dup 1)
                        (const_int 16)))
        (set (match_dup 0)
             (ashiftrt:SI (match_dup 0)
                          (const_int 16)))]
       "
     { operands[1] = gen_lowpart (SImode, operands[1]); }")

 When the combiner phase tries to split an insn pattern, it is always
the case that the pattern is _not_ matched by any 'define_insn'.  The
combiner pass first tries to split a single 'set' expression and then
the same 'set' expression inside a 'parallel', but followed by a
'clobber' of a pseudo-reg to use as a scratch register.  In these cases,
the combiner expects exactly one or two new insn patterns to be
generated.  It will verify that these patterns match some 'define_insn'
definitions, so you need not do this test in the 'define_split' (of
course, there is no point in writing a 'define_split' that will never
produce insns that match).

 Here is an example of this use of 'define_split', taken from
'rs6000.md':

     (define_split
       [(set (match_operand:SI 0 "gen_reg_operand" "")
             (plus:SI (match_operand:SI 1 "gen_reg_operand" "")
                      (match_operand:SI 2 "non_add_cint_operand" "")))]
       ""
       [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 3)))
        (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]
     "
     {
       int low = INTVAL (operands[2]) & 0xffff;
       int high = (unsigned) INTVAL (operands[2]) >> 16;

       if (low & 0x8000)
         high++, low |= 0xffff0000;

       operands[3] = GEN_INT (high << 16);
       operands[4] = GEN_INT (low);
     }")

 Here the predicate 'non_add_cint_operand' matches any 'const_int' that
is _not_ a valid operand of a single add insn.  The add with the smaller
displacement is written so that it can be substituted into the address
of a subsequent operation.

 An example that uses a scratch register, from the same file, generates
an equality comparison of a register and a large constant:

     (define_split
       [(set (match_operand:CC 0 "cc_reg_operand" "")
             (compare:CC (match_operand:SI 1 "gen_reg_operand" "")
                         (match_operand:SI 2 "non_short_cint_operand" "")))
        (clobber (match_operand:SI 3 "gen_reg_operand" ""))]
       "find_single_use (operands[0], insn, 0)
        && (GET_CODE (*find_single_use (operands[0], insn, 0)) == EQ
            || GET_CODE (*find_single_use (operands[0], insn, 0)) == NE)"
       [(set (match_dup 3) (xor:SI (match_dup 1) (match_dup 4)))
        (set (match_dup 0) (compare:CC (match_dup 3) (match_dup 5)))]
       "
     {
       /* Get the constant we are comparing against, C, and see what it
          looks like sign-extended to 16 bits.  Then see what constant
          could be XOR'ed with C to get the sign-extended value.  */

       int c = INTVAL (operands[2]);
       int sextc = (c << 16) >> 16;
       int xorv = c ^ sextc;

       operands[4] = GEN_INT (xorv);
       operands[5] = GEN_INT (sextc);
     }")

 To avoid confusion, don't write a single 'define_split' that accepts
some insns that match some 'define_insn' as well as some insns that
don't.  Instead, write two separate 'define_split' definitions, one for
the insns that are valid and one for the insns that are not valid.

 The splitter is allowed to split jump instructions into sequence of
jumps or create new jumps in while splitting non-jump instructions.  As
the control flow graph and branch prediction information needs to be
updated, several restriction apply.

 Splitting of jump instruction into sequence that over by another jump
instruction is always valid, as compiler expect identical behavior of
new jump.  When new sequence contains multiple jump instructions or new
labels, more assistance is needed.  Splitter is required to create only
unconditional jumps, or simple conditional jump instructions.
Additionally it must attach a 'REG_BR_PROB' note to each conditional
jump.  A global variable 'split_branch_probability' holds the
probability of the original branch in case it was a simple conditional
jump, -1 otherwise.  To simplify recomputing of edge frequencies, the
new sequence is required to have only forward jumps to the newly created
labels.

 For the common case where the pattern of a define_split exactly matches
the pattern of a define_insn, use 'define_insn_and_split'.  It looks
like this:

     (define_insn_and_split
       [INSN-PATTERN]
       "CONDITION"
       "OUTPUT-TEMPLATE"
       "SPLIT-CONDITION"
       [NEW-INSN-PATTERN-1
        NEW-INSN-PATTERN-2
        ...]
       "PREPARATION-STATEMENTS"
       [INSN-ATTRIBUTES])


 INSN-PATTERN, CONDITION, OUTPUT-TEMPLATE, and INSN-ATTRIBUTES are used
as in 'define_insn'.  The NEW-INSN-PATTERN vector and the
PREPARATION-STATEMENTS are used as in a 'define_split'.  The
SPLIT-CONDITION is also used as in 'define_split', with the additional
behavior that if the condition starts with '&&', the condition used for
the split will be the constructed as a logical "and" of the split
condition with the insn condition.  For example, from i386.md:

     (define_insn_and_split "zero_extendhisi2_and"
       [(set (match_operand:SI 0 "register_operand" "=r")
          (zero_extend:SI (match_operand:HI 1 "register_operand" "0")))
        (clobber (reg:CC 17))]
       "TARGET_ZERO_EXTEND_WITH_AND && !optimize_size"
       "#"
       "&& reload_completed"
       [(parallel [(set (match_dup 0)
                        (and:SI (match_dup 0) (const_int 65535)))
                   (clobber (reg:CC 17))])]
       ""
       [(set_attr "type" "alu1")])


 In this case, the actual split condition will be
'TARGET_ZERO_EXTEND_WITH_AND && !optimize_size && reload_completed'.

 The 'define_insn_and_split' construction provides exactly the same
functionality as two separate 'define_insn' and 'define_split' patterns.
It exists for compactness, and as a maintenance tool to prevent having
to ensure the two patterns' templates match.

 It is sometimes useful to have a 'define_insn_and_split' that replaces
specific operands of an instruction but leaves the rest of the
instruction pattern unchanged.  You can do this directly with a
'define_insn_and_split', but it requires a NEW-INSN-PATTERN-1 that
repeats most of the original INSN-PATTERN.  There is also the
complication that an implicit 'parallel' in INSN-PATTERN must become an
explicit 'parallel' in NEW-INSN-PATTERN-1, which is easy to overlook.  A
simpler alternative is to use 'define_insn_and_rewrite', which is a form
of 'define_insn_and_split' that automatically generates
NEW-INSN-PATTERN-1 by replacing each 'match_operand' in INSN-PATTERN
with a corresponding 'match_dup', and each 'match_operator' in the
pattern with a corresponding 'match_op_dup'.  The arguments are
otherwise identical to 'define_insn_and_split':

     (define_insn_and_rewrite
       [INSN-PATTERN]
       "CONDITION"
       "OUTPUT-TEMPLATE"
       "SPLIT-CONDITION"
       "PREPARATION-STATEMENTS"
       [INSN-ATTRIBUTES])

 The 'match_dup's and 'match_op_dup's in the new instruction pattern use
any new operand values that the PREPARATION-STATEMENTS store in the
'operands' array, as for a normal 'define_insn_and_split'.
PREPARATION-STATEMENTS can also emit additional instructions before the
new instruction.  They can even emit an entirely different sequence of
instructions and use 'DONE' to avoid emitting a new form of the original
instruction.

 The split in a 'define_insn_and_rewrite' is only intended to apply to
existing instructions that match INSN-PATTERN.  SPLIT-CONDITION must
therefore start with '&&', so that the split condition applies on top of
CONDITION.

 Here is an example from the AArch64 SVE port, in which operand 1 is
known to be equivalent to an all-true constant and isn't used by the
output template:

     (define_insn_and_rewrite "*while_ult<GPI:mode><PRED_ALL:mode>_cc"
       [(set (reg:CC CC_REGNUM)
             (compare:CC
               (unspec:SI [(match_operand:PRED_ALL 1)
                           (unspec:PRED_ALL
                             [(match_operand:GPI 2 "aarch64_reg_or_zero" "rZ")
                              (match_operand:GPI 3 "aarch64_reg_or_zero" "rZ")]
                             UNSPEC_WHILE_LO)]
                          UNSPEC_PTEST_PTRUE)
               (const_int 0)))
        (set (match_operand:PRED_ALL 0 "register_operand" "=Upa")
             (unspec:PRED_ALL [(match_dup 2)
                               (match_dup 3)]
                              UNSPEC_WHILE_LO))]
       "TARGET_SVE"
       "whilelo\t%0.<PRED_ALL:Vetype>, %<w>2, %<w>3"
       ;; Force the compiler to drop the unused predicate operand, so that we
       ;; don't have an unnecessary PTRUE.
       "&& !CONSTANT_P (operands[1])"
       {
         operands[1] = CONSTM1_RTX (<MODE>mode);
       }
     )

 The splitter in this case simply replaces operand 1 with the constant
value that it is known to have.  The equivalent 'define_insn_and_split'
would be:

     (define_insn_and_split "*while_ult<GPI:mode><PRED_ALL:mode>_cc"
       [(set (reg:CC CC_REGNUM)
             (compare:CC
               (unspec:SI [(match_operand:PRED_ALL 1)
                           (unspec:PRED_ALL
                             [(match_operand:GPI 2 "aarch64_reg_or_zero" "rZ")
                              (match_operand:GPI 3 "aarch64_reg_or_zero" "rZ")]
                             UNSPEC_WHILE_LO)]
                          UNSPEC_PTEST_PTRUE)
               (const_int 0)))
        (set (match_operand:PRED_ALL 0 "register_operand" "=Upa")
             (unspec:PRED_ALL [(match_dup 2)
                               (match_dup 3)]
                              UNSPEC_WHILE_LO))]
       "TARGET_SVE"
       "whilelo\t%0.<PRED_ALL:Vetype>, %<w>2, %<w>3"
       ;; Force the compiler to drop the unused predicate operand, so that we
       ;; don't have an unnecessary PTRUE.
       "&& !CONSTANT_P (operands[1])"
       [(parallel
          [(set (reg:CC CC_REGNUM)
                (compare:CC
                  (unspec:SI [(match_dup 1)
                              (unspec:PRED_ALL [(match_dup 2)
                                                (match_dup 3)]
                                               UNSPEC_WHILE_LO)]
                             UNSPEC_PTEST_PTRUE)
                  (const_int 0)))
           (set (match_dup 0)
                (unspec:PRED_ALL [(match_dup 2)
                                  (match_dup 3)]
                                 UNSPEC_WHILE_LO))])]
       {
         operands[1] = CONSTM1_RTX (<MODE>mode);
       }
     )

==============================================================================
File: gccint.info,  Node: |Including_Patterns|,  Next: |Peephole_Definitions|,  Prev: |Insn_Splitting|,  Up: |Machine_Desc|
==============================================================================

                                                            *Including_Patterns*

17.17 Including Patterns in Machine Descriptions.
=====--------------------------------------------

The 'include' pattern tells the compiler tools where to look for
patterns that are in files other than in the file '.md'.  This is used
only at build time and there is no preprocessing allowed.

 It looks like:


     (include
       PATHNAME)

 For example:


     (include "filestuff")


 Where PATHNAME is a string that specifies the location of the file,
specifies the include file to be in 'gcc/config/target/filestuff'.  The
directory 'gcc/config/target' is regarded as the default directory.

 Machine descriptions may be split up into smaller more manageable
subsections and placed into subdirectories.

 By specifying:


     (include "BOGUS/filestuff")


 the include file is specified to be in
'gcc/config/TARGET/BOGUS/filestuff'.

 Specifying an absolute path for the include file such as;

     (include "/u2/BOGUS/filestuff")

 is permitted but is not encouraged.

17.17.1 RTL Generation Tool Options for Directory Search
--------------------------------------------------------

The '-IDIR' option specifies directories to search for machine
descriptions.  For example:


     genrecog -I/p1/abc/proc1 -I/p2/abcd/pro2 target.md


 Add the directory DIR to the head of the list of directories to be
searched for header files.  This can be used to override a system
machine definition file, substituting your own version, since these
directories are searched before the default machine description file
directories.  If you use more than one '-I' option, the directories are
scanned in left-to-right order; the standard default directory come
after.

==============================================================================
File: gccint.info,  Node: |Peephole_Definitions|,  Next: |Insn_Attributes|,  Prev: |Including_Patterns|,  Up: |Machine_Desc|
==============================================================================

                                                          *Peephole_Definitions*

17.18 Machine-Specific Peephole Optimizers
=====-------------------------------------

In addition to instruction patterns the 'md' file may contain
definitions of machine-specific peephole optimizations.

 The combiner does not notice certain peephole optimizations when the
data flow in the program does not suggest that it should try them.  For
example, sometimes two consecutive insns related in purpose can be
combined even though the second one does not appear to use a register
computed in the first one.  A machine-specific peephole optimizer can
detect such opportunities.

 There are two forms of peephole definitions that may be used.  The
original 'define_peephole' is run at assembly output time to match insns
and substitute assembly text.  Use of 'define_peephole' is deprecated.

 A newer 'define_peephole2' matches insns and substitutes new insns.
The 'peephole2' pass is run after register allocation but before
scheduling, which may result in much better code for targets that do
scheduling.

MENU

* |define_peephole|::     RTL to Text Peephole Optimizers
* |define_peephole2|::    RTL to RTL Peephole Optimizers

==============================================================================
File: gccint.info,  Node: |define_peephole|,  Next: |define_peephole2|,  Up: |Peephole_Definitions|
==============================================================================

                                                               *define_peephole*

17.18.1 RTL to Text Peephole Optimizers
---------------------------------------

A definition looks like this:

     (define_peephole
       [INSN-PATTERN-1
        INSN-PATTERN-2
        ...]
       "CONDITION"
       "TEMPLATE"
       "OPTIONAL-INSN-ATTRIBUTES")

The last string operand may be omitted if you are not using any
machine-specific information in this machine description.  If present,
it must obey the same rules as in a 'define_insn'.

 In this skeleton, INSN-PATTERN-1 and so on are patterns to match
consecutive insns.  The optimization applies to a sequence of insns when
INSN-PATTERN-1 matches the first one, INSN-PATTERN-2 matches the next,
and so on.

 Each of the insns matched by a peephole must also match a
'define_insn'.  Peepholes are checked only at the last stage just before
code generation, and only optionally.  Therefore, any insn which would
match a peephole but no 'define_insn' will cause a crash in code
generation in an unoptimized compilation, or at various optimization
stages.

 The operands of the insns are matched with 'match_operands',
'match_operator', and 'match_dup', as usual.  What is not usual is that
the operand numbers apply to all the insn patterns in the definition.
So, you can check for identical operands in two insns by using
'match_operand' in one insn and 'match_dup' in the other.

 The operand constraints used in 'match_operand' patterns do not have
any direct effect on the applicability of the peephole, but they will be
validated afterward, so make sure your constraints are general enough to
apply whenever the peephole matches.  If the peephole matches but the
constraints are not satisfied, the compiler will crash.

 It is safe to omit constraints in all the operands of the peephole; or
you can write constraints which serve as a double-check on the criteria
previously tested.

 Once a sequence of insns matches the patterns, the CONDITION is
checked.  This is a C expression which makes the final decision whether
to perform the optimization (we do so if the expression is nonzero).  If
CONDITION is omitted (in other words, the string is empty) then the
optimization is applied to every sequence of insns that matches the
patterns.

 The defined peephole optimizations are applied after register
allocation is complete.  Therefore, the peephole definition can check
which operands have ended up in which kinds of registers, just by
looking at the operands.

 The way to refer to the operands in CONDITION is to write 'operands[I]'
for operand number I (as matched by '(match_operand I ...)').  Use the
variable 'insn' to refer to the last of the insns being matched; use
'prev_active_insn' to find the preceding insns.

 When optimizing computations with intermediate results, you can use
CONDITION to match only when the intermediate results are not used
elsewhere.  Use the C expression 'dead_or_set_p (INSN, OP)', where INSN
is the insn in which you expect the value to be used for the last time
(from the value of 'insn', together with use of 'prev_nonnote_insn'),
and OP is the intermediate value (from 'operands[I]').

 Applying the optimization means replacing the sequence of insns with
one new insn.  The TEMPLATE controls ultimate output of assembler code
for this combined insn.  It works exactly like the template of a
'define_insn'.  Operand numbers in this template are the same ones used
in matching the original sequence of insns.

 The result of a defined peephole optimizer does not need to match any
of the insn patterns in the machine description; it does not even have
an opportunity to match them.  The peephole optimizer definition itself
serves as the insn pattern to control how the insn is output.

 Defined peephole optimizers are run as assembler code is being output,
so the insns they produce are never combined or rearranged in any way.

 Here is an example, taken from the 68000 machine description:

     (define_peephole
       [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))
        (set (match_operand:DF 0 "register_operand" "=f")
             (match_operand:DF 1 "register_operand" "ad"))]
       "FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])"
     {
       rtx xoperands[2];
       xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);
     #ifdef MOTOROLA
       output_asm_insn ("move.l %1,(sp)", xoperands);
       output_asm_insn ("move.l %1,-(sp)", operands);
       return "fmove.d (sp)+,%0";
     #else
       output_asm_insn ("movel %1,sp@", xoperands);
       output_asm_insn ("movel %1,sp@-", operands);
       return "fmoved sp@+,%0";
     #endif
     })

 The effect of this optimization is to change

     jbsr _foobar
     addql #4,sp
     movel d1,sp@-
     movel d0,sp@-
     fmoved sp@+,fp0

into

     jbsr _foobar
     movel d1,sp@
     movel d0,sp@-
     fmoved sp@+,fp0

 INSN-PATTERN-1 and so on look _almost_ like the second operand of
'define_insn'.  There is one important difference: the second operand of
'define_insn' consists of one or more RTX's enclosed in square brackets.
Usually, there is only one: then the same action can be written as an
element of a 'define_peephole'.  But when there are multiple actions in
a 'define_insn', they are implicitly enclosed in a 'parallel'.  Then you
must explicitly write the 'parallel', and the square brackets within it,
in the 'define_peephole'.  Thus, if an insn pattern looks like this,

     (define_insn "divmodsi4"
       [(set (match_operand:SI 0 "general_operand" "=d")
             (div:SI (match_operand:SI 1 "general_operand" "0")
                     (match_operand:SI 2 "general_operand" "dmsK")))
        (set (match_operand:SI 3 "general_operand" "=d")
             (mod:SI (match_dup 1) (match_dup 2)))]
       "TARGET_68020"
       "divsl%.l %2,%3:%0")

then the way to mention this insn in a peephole is as follows:

     (define_peephole
       [...
        (parallel
         [(set (match_operand:SI 0 "general_operand" "=d")
               (div:SI (match_operand:SI 1 "general_operand" "0")
                       (match_operand:SI 2 "general_operand" "dmsK")))
          (set (match_operand:SI 3 "general_operand" "=d")
               (mod:SI (match_dup 1) (match_dup 2)))])
        ...]
       ...)

==============================================================================
File: gccint.info,  Node: |define_peephole2|,  Prev: |define_peephole|,  Up: |Peephole_Definitions|
==============================================================================

                                                              *define_peephole2*

17.18.2 RTL to RTL Peephole Optimizers
--------------------------------------

The 'define_peephole2' definition tells the compiler how to substitute
one sequence of instructions for another sequence, what additional
scratch registers may be needed and what their lifetimes must be.

     (define_peephole2
       [INSN-PATTERN-1
        INSN-PATTERN-2
        ...]
       "CONDITION"
       [NEW-INSN-PATTERN-1
        NEW-INSN-PATTERN-2
        ...]
       "PREPARATION-STATEMENTS")

 The definition is almost identical to 'define_split' (*note Insn
Splitting::) except that the pattern to match is not a single
instruction, but a sequence of instructions.

 It is possible to request additional scratch registers for use in the
output template.  If appropriate registers are not free, the pattern
will simply not match.

 Scratch registers are requested with a 'match_scratch' pattern at the
top level of the input pattern.  The allocated register (initially) will
be dead at the point requested within the original sequence.  If the
scratch is used at more than a single point, a 'match_dup' pattern at
the top level of the input pattern marks the last position in the input
sequence at which the register must be available.

 Here is an example from the IA-32 machine description:

     (define_peephole2
       [(match_scratch:SI 2 "r")
        (parallel [(set (match_operand:SI 0 "register_operand" "")
                        (match_operator:SI 3 "arith_or_logical_operator"
                          [(match_dup 0)
                           (match_operand:SI 1 "memory_operand" "")]))
                   (clobber (reg:CC 17))])]
       "! optimize_size && ! TARGET_READ_MODIFY"
       [(set (match_dup 2) (match_dup 1))
        (parallel [(set (match_dup 0)
                        (match_op_dup 3 [(match_dup 0) (match_dup 2)]))
                   (clobber (reg:CC 17))])]
       "")

This pattern tries to split a load from its use in the hopes that we'll
be able to schedule around the memory load latency.  It allocates a
single 'SImode' register of class 'GENERAL_REGS' ('"r"') that needs to
be live only at the point just before the arithmetic.

 A real example requiring extended scratch lifetimes is harder to come
by, so here's a silly made-up example:

     (define_peephole2
       [(match_scratch:SI 4 "r")
        (set (match_operand:SI 0 "" "") (match_operand:SI 1 "" ""))
        (set (match_operand:SI 2 "" "") (match_dup 1))
        (match_dup 4)
        (set (match_operand:SI 3 "" "") (match_dup 1))]
       "/* determine 1 does not overlap 0 and 2 */"
       [(set (match_dup 4) (match_dup 1))
        (set (match_dup 0) (match_dup 4))
        (set (match_dup 2) (match_dup 4))
        (set (match_dup 3) (match_dup 4))]
       "")

 There are two special macros defined for use in the preparation
statements: 'DONE' and 'FAIL'.  Use them with a following semicolon, as
a statement.

'DONE'
     Use the 'DONE' macro to end RTL generation for the peephole.  The
     only RTL insns generated as replacement for the matched input insn
     will be those already emitted by explicit calls to 'emit_insn'
     within the preparation statements; the replacement pattern is not
     used.

'FAIL'
     Make the 'define_peephole2' fail on this occasion.  When a
     'define_peephole2' fails, it means that the replacement was not
     truly available for the particular inputs it was given.  In that
     case, GCC may still apply a later 'define_peephole2' that also
     matches the given insn pattern.  (Note that this is different from
     'define_split', where 'FAIL' prevents the input insn from being
     split at all.)

 If the preparation falls through (invokes neither 'DONE' nor 'FAIL'),
then the 'define_peephole2' uses the replacement template.

If we had not added the '(match_dup 4)' in the middle of the input
sequence, it might have been the case that the register we chose at the
beginning of the sequence is killed by the first or second 'set'.

==============================================================================
File: gccint.info,  Node: |Insn_Attributes|,  Next: |Conditional_Execution|,  Prev: |Peephole_Definitions|,  Up: |Machine_Desc|
==============================================================================

                                                               *Insn_Attributes*

17.19 Instruction Attributes
=====-----------------------

In addition to describing the instruction supported by the target
machine, the 'md' file also defines a group of "attributes" and a set of
values for each.  Every generated insn is assigned a value for each
attribute.  One possible attribute would be the effect that the insn has
on the machine's condition code.  This attribute can then be used by
'NOTICE_UPDATE_CC' to track the condition codes.

MENU

* |Defining_Attributes|:: Specifying attributes and their values.
* |Expressions|::         Valid expressions for attribute values.
* |Tagging_Insns|::       Assigning attribute values to insns.
* |Attr_Example|::        An example of assigning attributes.
* |Insn_Lengths|::        Computing the length of insns.
* |Constant_Attributes|:: Defining attributes that are constant.
* |Mnemonic_Attribute|::  Obtain the instruction mnemonic as attribute value.
* |Delay_Slots|::         Defining delay slots required for a machine.
* |Processor_pipeline_description|:: Specifying information for insn scheduling.

==============================================================================
File: gccint.info,  Node: |Defining_Attributes|,  Next: |Expressions|,  Up: |Insn_Attributes|
==============================================================================

                                                           *Defining_Attributes*

17.19.1 Defining Attributes and their Values
--------------------------------------------

The 'define_attr' expression is used to define each attribute required
by the target machine.  It looks like:

     (define_attr NAME LIST-OF-VALUES DEFAULT)

 NAME is a string specifying the name of the attribute being defined.
Some attributes are used in a special way by the rest of the compiler.
The 'enabled' attribute can be used to conditionally enable or disable
insn alternatives (*note Disable Insn Alternatives::).  The 'predicable'
attribute, together with a suitable 'define_cond_exec' (*note
Conditional Execution::), can be used to automatically generate
conditional variants of instruction patterns.  The 'mnemonic' attribute
can be used to check for the instruction mnemonic (*note Mnemonic
Attribute::).  The compiler internally uses the names 'ce_enabled' and
'nonce_enabled', so they should not be used elsewhere as alternative
names.

 LIST-OF-VALUES is either a string that specifies a comma-separated list
of values that can be assigned to the attribute, or a null string to
indicate that the attribute takes numeric values.

 DEFAULT is an attribute expression that gives the value of this
attribute for insns that match patterns whose definition does not
include an explicit value for this attribute.  *Note Attr Example::, for
more information on the handling of defaults.  *Note Constant
Attributes::, for information on attributes that do not depend on any
particular insn.

 For each defined attribute, a number of definitions are written to the
'insn-attr.h' file.  For cases where an explicit set of values is
specified for an attribute, the following are defined:

   * A '#define' is written for the symbol 'HAVE_ATTR_NAME'.

   * An enumerated class is defined for 'attr_NAME' with elements of the
     form 'UPPER-NAME_UPPER-VALUE' where the attribute name and value
     are first converted to uppercase.

   * A function 'get_attr_NAME' is defined that is passed an insn and
     returns the attribute value for that insn.

 For example, if the following is present in the 'md' file:

     (define_attr "type" "branch,fp,load,store,arith" ...)

the following lines will be written to the file 'insn-attr.h'.

     #define HAVE_ATTR_type 1
     enum attr_type {TYPE_BRANCH, TYPE_FP, TYPE_LOAD,
                      TYPE_STORE, TYPE_ARITH};
     extern enum attr_type get_attr_type ();

 If the attribute takes numeric values, no 'enum' type will be defined
and the function to obtain the attribute's value will return 'int'.

 There are attributes which are tied to a specific meaning.  These
attributes are not free to use for other purposes:

'length'
     The 'length' attribute is used to calculate the length of emitted
     code chunks.  This is especially important when verifying branch
     distances.  *Note Insn Lengths::.

'enabled'
     The 'enabled' attribute can be defined to prevent certain
     alternatives of an insn definition from being used during code
     generation.  *Note Disable Insn Alternatives::.

'mnemonic'
     The 'mnemonic' attribute can be defined to implement instruction
     specific checks in e.g. the pipeline description.  *Note Mnemonic
     Attribute::.

 For each of these special attributes, the corresponding
'HAVE_ATTR_NAME' '#define' is also written when the attribute is not
defined; in that case, it is defined as '0'.

 Another way of defining an attribute is to use:

     (define_enum_attr "ATTR" "ENUM" DEFAULT)

 This works in just the same way as 'define_attr', except that the list
of values is taken from a separate enumeration called ENUM (*note
define_enum::).  This form allows you to use the same list of values for
several attributes without having to repeat the list each time.  For
example:

     (define_enum "processor" [
       model_a
       model_b
       ...
     ])
     (define_enum_attr "arch" "processor"
       (const (symbol_ref "target_arch")))
     (define_enum_attr "tune" "processor"
       (const (symbol_ref "target_tune")))

 defines the same attributes as:

     (define_attr "arch" "model_a,model_b,..."
       (const (symbol_ref "target_arch")))
     (define_attr "tune" "model_a,model_b,..."
       (const (symbol_ref "target_tune")))

 but without duplicating the processor list.  The second example defines
two separate C enums ('attr_arch' and 'attr_tune') whereas the first
defines a single C enum ('processor').

==============================================================================
File: gccint.info,  Node: |Expressions|,  Next: |Tagging_Insns|,  Prev: |Defining_Attributes|,  Up: |Insn_Attributes|
==============================================================================

                                                                   *Expressions*

17.19.2 Attribute Expressions
-----------------------------

RTL expressions used to define attributes use the codes described above
plus a few specific to attribute definitions, to be discussed below.
Attribute value expressions must have one of the following forms:

'(const_int I)'
     The integer I specifies the value of a numeric attribute.  I must
     be non-negative.

     The value of a numeric attribute can be specified either with a
     'const_int', or as an integer represented as a string in
     'const_string', 'eq_attr' (see below), 'attr', 'symbol_ref', simple
     arithmetic expressions, and 'set_attr' overrides on specific
     instructions (*note Tagging Insns::).

'(const_string VALUE)'
     The string VALUE specifies a constant attribute value.  If VALUE is
     specified as '"*"', it means that the default value of the
     attribute is to be used for the insn containing this expression.
     '"*"' obviously cannot be used in the DEFAULT expression of a
     'define_attr'.

     If the attribute whose value is being specified is numeric, VALUE
     must be a string containing a non-negative integer (normally
     'const_int' would be used in this case).  Otherwise, it must
     contain one of the valid values for the attribute.

'(if_then_else TEST TRUE-VALUE FALSE-VALUE)'
     TEST specifies an attribute test, whose format is defined below.
     The value of this expression is TRUE-VALUE if TEST is true,
     otherwise it is FALSE-VALUE.

'(cond [TEST1 VALUE1 ...] DEFAULT)'
     The first operand of this expression is a vector containing an even
     number of expressions and consisting of pairs of TEST and VALUE
     expressions.  The value of the 'cond' expression is that of the
     VALUE corresponding to the first true TEST expression.  If none of
     the TEST expressions are true, the value of the 'cond' expression
     is that of the DEFAULT expression.

 TEST expressions can have one of the following forms:

'(const_int I)'
     This test is true if I is nonzero and false otherwise.

'(not TEST)'
'(ior TEST1 TEST2)'
'(and TEST1 TEST2)'
     These tests are true if the indicated logical function is true.

'(match_operand:M N PRED CONSTRAINTS)'
     This test is true if operand N of the insn whose attribute value is
     being determined has mode M (this part of the test is ignored if M
     is 'VOIDmode') and the function specified by the string PRED
     returns a nonzero value when passed operand N and mode M (this part
     of the test is ignored if PRED is the null string).

     The CONSTRAINTS operand is ignored and should be the null string.

'(match_test C-EXPR)'
     The test is true if C expression C-EXPR is true.  In non-constant
     attributes, C-EXPR has access to the following variables:

     INSN
          The rtl instruction under test.
     WHICH_ALTERNATIVE
          The 'define_insn' alternative that INSN matches.  *Note Output
          Statement::.
     OPERANDS
          An array of INSN's rtl operands.

     C-EXPR behaves like the condition in a C 'if' statement, so there
     is no need to explicitly convert the expression into a boolean 0 or
     1 value.  For example, the following two tests are equivalent:

          (match_test "x & 2")
          (match_test "(x & 2) != 0")

'(le ARITH1 ARITH2)'
'(leu ARITH1 ARITH2)'
'(lt ARITH1 ARITH2)'
'(ltu ARITH1 ARITH2)'
'(gt ARITH1 ARITH2)'
'(gtu ARITH1 ARITH2)'
'(ge ARITH1 ARITH2)'
'(geu ARITH1 ARITH2)'
'(ne ARITH1 ARITH2)'
'(eq ARITH1 ARITH2)'
     These tests are true if the indicated comparison of the two
     arithmetic expressions is true.  Arithmetic expressions are formed
     with 'plus', 'minus', 'mult', 'div', 'mod', 'abs', 'neg', 'and',
     'ior', 'xor', 'not', 'ashift', 'lshiftrt', and 'ashiftrt'
     expressions.

     'const_int' and 'symbol_ref' are always valid terms (*note Insn
     Lengths::,for additional forms).  'symbol_ref' is a string denoting
     a C expression that yields an 'int' when evaluated by the
     'get_attr_...' routine.  It should normally be a global variable.

'(eq_attr NAME VALUE)'
     NAME is a string specifying the name of an attribute.

     VALUE is a string that is either a valid value for attribute NAME,
     a comma-separated list of values, or '!' followed by a value or
     list.  If VALUE does not begin with a '!', this test is true if the
     value of the NAME attribute of the current insn is in the list
     specified by VALUE.  If VALUE begins with a '!', this test is true
     if the attribute's value is _not_ in the specified list.

     For example,

          (eq_attr "type" "load,store")

     is equivalent to

          (ior (eq_attr "type" "load") (eq_attr "type" "store"))

     If NAME specifies an attribute of 'alternative', it refers to the
     value of the compiler variable 'which_alternative' (*note Output
     Statement::) and the values must be small integers.  For example,

          (eq_attr "alternative" "2,3")

     is equivalent to

          (ior (eq (symbol_ref "which_alternative") (const_int 2))
               (eq (symbol_ref "which_alternative") (const_int 3)))

     Note that, for most attributes, an 'eq_attr' test is simplified in
     cases where the value of the attribute being tested is known for
     all insns matching a particular pattern.  This is by far the most
     common case.

'(attr_flag NAME)'
     The value of an 'attr_flag' expression is true if the flag
     specified by NAME is true for the 'insn' currently being scheduled.

     NAME is a string specifying one of a fixed set of flags to test.
     Test the flags 'forward' and 'backward' to determine the direction
     of a conditional branch.

     This example describes a conditional branch delay slot which can be
     nullified for forward branches that are taken (annul-true) or for
     backward branches which are not taken (annul-false).

          (define_delay (eq_attr "type" "cbranch")
            [(eq_attr "in_branch_delay" "true")
             (and (eq_attr "in_branch_delay" "true")
                  (attr_flag "forward"))
             (and (eq_attr "in_branch_delay" "true")
                  (attr_flag "backward"))])

     The 'forward' and 'backward' flags are false if the current 'insn'
     being scheduled is not a conditional branch.

     'attr_flag' is only used during delay slot scheduling and has no
     meaning to other passes of the compiler.

'(attr NAME)'
     The value of another attribute is returned.  This is most useful
     for numeric attributes, as 'eq_attr' and 'attr_flag' produce more
     efficient code for non-numeric attributes.

==============================================================================
File: gccint.info,  Node: |Tagging_Insns|,  Next: |Attr_Example|,  Prev: |Expressions|,  Up: |Insn_Attributes|
==============================================================================

                                                                 *Tagging_Insns*

17.19.3 Assigning Attribute Values to Insns
-------------------------------------------

The value assigned to an attribute of an insn is primarily determined by
which pattern is matched by that insn (or which 'define_peephole'
generated it).  Every 'define_insn' and 'define_peephole' can have an
optional last argument to specify the values of attributes for matching
insns.  The value of any attribute not specified in a particular insn is
set to the default value for that attribute, as specified in its
'define_attr'.  Extensive use of default values for attributes permits
the specification of the values for only one or two attributes in the
definition of most insn patterns, as seen in the example in the next
section.

 The optional last argument of 'define_insn' and 'define_peephole' is a
vector of expressions, each of which defines the value for a single
attribute.  The most general way of assigning an attribute's value is to
use a 'set' expression whose first operand is an 'attr' expression
giving the name of the attribute being set.  The second operand of the
'set' is an attribute expression (*note Expressions::) giving the value
of the attribute.

 When the attribute value depends on the 'alternative' attribute (i.e.,
which is the applicable alternative in the constraint of the insn), the
'set_attr_alternative' expression can be used.  It allows the
specification of a vector of attribute expressions, one for each
alternative.

 When the generality of arbitrary attribute expressions is not required,
the simpler 'set_attr' expression can be used, which allows specifying a
string giving either a single attribute value or a list of attribute
values, one for each alternative.

 The form of each of the above specifications is shown below.  In each
case, NAME is a string specifying the attribute to be set.

'(set_attr NAME VALUE-STRING)'
     VALUE-STRING is either a string giving the desired attribute value,
     or a string containing a comma-separated list giving the values for
     succeeding alternatives.  The number of elements must match the
     number of alternatives in the constraint of the insn pattern.

     Note that it may be useful to specify '*' for some alternative, in
     which case the attribute will assume its default value for insns
     matching that alternative.

'(set_attr_alternative NAME [VALUE1 VALUE2 ...])'
     Depending on the alternative of the insn, the value will be one of
     the specified values.  This is a shorthand for using a 'cond' with
     tests on the 'alternative' attribute.

'(set (attr NAME) VALUE)'
     The first operand of this 'set' must be the special RTL expression
     'attr', whose sole operand is a string giving the name of the
     attribute being set.  VALUE is the value of the attribute.

 The following shows three different ways of representing the same
attribute value specification:

     (set_attr "type" "load,store,arith")

     (set_attr_alternative "type"
                           [(const_string "load") (const_string "store")
                            (const_string "arith")])

     (set (attr "type")
          (cond [(eq_attr "alternative" "1") (const_string "load")
                 (eq_attr "alternative" "2") (const_string "store")]
                (const_string "arith")))

 The 'define_asm_attributes' expression provides a mechanism to specify
the attributes assigned to insns produced from an 'asm' statement.  It
has the form:

     (define_asm_attributes [ATTR-SETS])

where ATTR-SETS is specified the same as for both the 'define_insn' and
the 'define_peephole' expressions.

 These values will typically be the "worst case" attribute values.  For
example, they might indicate that the condition code will be clobbered.

 A specification for a 'length' attribute is handled specially.  The way
to compute the length of an 'asm' insn is to multiply the length
specified in the expression 'define_asm_attributes' by the number of
machine instructions specified in the 'asm' statement, determined by
counting the number of semicolons and newlines in the string.
Therefore, the value of the 'length' attribute specified in a
'define_asm_attributes' should be the maximum possible length of a
single machine instruction.

==============================================================================
File: gccint.info,  Node: |Attr_Example|,  Next: |Insn_Lengths|,  Prev: |Tagging_Insns|,  Up: |Insn_Attributes|
==============================================================================

                                                                  *Attr_Example*

17.19.4 Example of Attribute Specifications
-------------------------------------------

The judicious use of defaulting is important in the efficient use of
insn attributes.  Typically, insns are divided into "types" and an
attribute, customarily called 'type', is used to represent this value.
This attribute is normally used only to define the default value for
other attributes.  An example will clarify this usage.

 Assume we have a RISC machine with a condition code and in which only
full-word operations are performed in registers.  Let us assume that we
can divide all insns into loads, stores, (integer) arithmetic
operations, floating point operations, and branches.

 Here we will concern ourselves with determining the effect of an insn
on the condition code and will limit ourselves to the following possible
effects: The condition code can be set unpredictably (clobbered), not be
changed, be set to agree with the results of the operation, or only
changed if the item previously set into the condition code has been
modified.

 Here is part of a sample 'md' file for such a machine:

     (define_attr "type" "load,store,arith,fp,branch" (const_string "arith"))

     (define_attr "cc" "clobber,unchanged,set,change0"
                  (cond [(eq_attr "type" "load")
                             (const_string "change0")
                         (eq_attr "type" "store,branch")
                             (const_string "unchanged")
                         (eq_attr "type" "arith")
                             (if_then_else (match_operand:SI 0 "" "")
                                           (const_string "set")
                                           (const_string "clobber"))]
                        (const_string "clobber")))

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r,r,m")
             (match_operand:SI 1 "general_operand" "r,m,r"))]
       ""
       "@
        move %0,%1
        load %0,%1
        store %0,%1"
       [(set_attr "type" "arith,load,store")])

 Note that we assume in the above example that arithmetic operations
performed on quantities smaller than a machine word clobber the
condition code since they will set the condition code to a value
corresponding to the full-word result.

==============================================================================
File: gccint.info,  Node: |Insn_Lengths|,  Next: |Constant_Attributes|,  Prev: |Attr_Example|,  Up: |Insn_Attributes|
==============================================================================

                                                                  *Insn_Lengths*

17.19.5 Computing the Length of an Insn
---------------------------------------

For many machines, multiple types of branch instructions are provided,
each for different length branch displacements.  In most cases, the
assembler will choose the correct instruction to use.  However, when the
assembler cannot do so, GCC can when a special attribute, the 'length'
attribute, is defined.  This attribute must be defined to have numeric
values by specifying a null string in its 'define_attr'.

 In the case of the 'length' attribute, two additional forms of
arithmetic terms are allowed in test expressions:

'(match_dup N)'
     This refers to the address of operand N of the current insn, which
     must be a 'label_ref'.

'(pc)'
     For non-branch instructions and backward branch instructions, this
     refers to the address of the current insn.  But for forward branch
     instructions, this refers to the address of the next insn, because
     the length of the current insn is to be computed.

 For normal insns, the length will be determined by value of the
'length' attribute.  In the case of 'addr_vec' and 'addr_diff_vec' insn
patterns, the length is computed as the number of vectors multiplied by
the size of each vector.

 Lengths are measured in addressable storage units (bytes).

 Note that it is possible to call functions via the 'symbol_ref'
mechanism to compute the length of an insn.  However, if you use this
mechanism you must provide dummy clauses to express the maximum length
without using the function call.  You can an example of this in the 'pa'
machine description for the 'call_symref' pattern.

 The following macros can be used to refine the length computation:

'ADJUST_INSN_LENGTH (INSN, LENGTH)'
     If defined, modifies the length assigned to instruction INSN as a
     function of the context in which it is used.  LENGTH is an lvalue
     that contains the initially computed length of the insn and should
     be updated with the correct length of the insn.

     This macro will normally not be required.  A case in which it is
     required is the ROMP.  On this machine, the size of an 'addr_vec'
     insn must be increased by two to compensate for the fact that
     alignment may be required.

 The routine that returns 'get_attr_length' (the value of the 'length'
attribute) can be used by the output routine to determine the form of
the branch instruction to be written, as the example below illustrates.

 As an example of the specification of variable-length branches,
consider the IBM 360.  If we adopt the convention that a register will
be set to the starting address of a function, we can jump to labels
within 4k of the start using a four-byte instruction.  Otherwise, we
need a six-byte sequence to load the address from memory and then branch
to it.

 On such a machine, a pattern for a branch instruction might be
specified as follows:

     (define_insn "jump"
       [(set (pc)
             (label_ref (match_operand 0 "" "")))]
       ""
     {
        return (get_attr_length (insn) == 4
                ? "b %l0" : "l r15,=a(%l0); br r15");
     }
       [(set (attr "length")
             (if_then_else (lt (match_dup 0) (const_int 4096))
                           (const_int 4)
                           (const_int 6)))])

==============================================================================
File: gccint.info,  Node: |Constant_Attributes|,  Next: |Mnemonic_Attribute|,  Prev: |Insn_Lengths|,  Up: |Insn_Attributes|
==============================================================================

                                                           *Constant_Attributes*

17.19.6 Constant Attributes
---------------------------

A special form of 'define_attr', where the expression for the default
value is a 'const' expression, indicates an attribute that is constant
for a given run of the compiler.  Constant attributes may be used to
specify which variety of processor is used.  For example,

     (define_attr "cpu" "m88100,m88110,m88000"
      (const
       (cond [(symbol_ref "TARGET_88100") (const_string "m88100")
              (symbol_ref "TARGET_88110") (const_string "m88110")]
             (const_string "m88000"))))

     (define_attr "memory" "fast,slow"
      (const
       (if_then_else (symbol_ref "TARGET_FAST_MEM")
                     (const_string "fast")
                     (const_string "slow"))))

 The routine generated for constant attributes has no parameters as it
does not depend on any particular insn.  RTL expressions used to define
the value of a constant attribute may use the 'symbol_ref' form, but may
not use either the 'match_operand' form or 'eq_attr' forms involving
insn attributes.

==============================================================================
File: gccint.info,  Node: |Mnemonic_Attribute|,  Next: |Delay_Slots|,  Prev: |Constant_Attributes|,  Up: |Insn_Attributes|
==============================================================================

                                                            *Mnemonic_Attribute*

17.19.7 Mnemonic Attribute
--------------------------

The 'mnemonic' attribute is a string type attribute holding the
instruction mnemonic for an insn alternative.  The attribute values will
automatically be generated by the machine description parser if there is
an attribute definition in the md file:

     (define_attr "mnemonic" "unknown" (const_string "unknown"))

 The default value can be freely chosen as long as it does not collide
with any of the instruction mnemonics.  This value will be used whenever
the machine description parser is not able to determine the mnemonic
string.  This might be the case for output templates containing more
than a single instruction as in '"mvcle\t%0,%1,0\;jo\t.-4"'.

 The 'mnemonic' attribute set is not generated automatically if the
instruction string is generated via C code.

 An existing 'mnemonic' attribute set in an insn definition will not be
overriden by the md file parser.  That way it is possible to manually
set the instruction mnemonics for the cases where the md file parser
fails to determine it automatically.

 The 'mnemonic' attribute is useful for dealing with instruction
specific properties in the pipeline description without defining
additional insn attributes.

     (define_attr "ooo_expanded" ""
       (cond [(eq_attr "mnemonic" "dlr,dsgr,d,dsgf,stam,dsgfr,dlgr")
              (const_int 1)]
             (const_int 0)))

==============================================================================
File: gccint.info,  Node: |Delay_Slots|,  Next: |Processor_pipeline_description|,  Prev: |Mnemonic_Attribute|,  Up: |Insn_Attributes|
==============================================================================

                                                                   *Delay_Slots*

17.19.8 Delay Slot Scheduling
-----------------------------

The insn attribute mechanism can be used to specify the requirements for
delay slots, if any, on a target machine.  An instruction is said to
require a "delay slot" if some instructions that are physically after
the instruction are executed as if they were located before it.  Classic
examples are branch and call instructions, which often execute the
following instruction before the branch or call is performed.

 On some machines, conditional branch instructions can optionally
"annul" instructions in the delay slot.  This means that the instruction
will not be executed for certain branch outcomes.  Both instructions
that annul if the branch is true and instructions that annul if the
branch is false are supported.

 Delay slot scheduling differs from instruction scheduling in that
determining whether an instruction needs a delay slot is dependent only
on the type of instruction being generated, not on data flow between the
instructions.  See the next section for a discussion of data-dependent
instruction scheduling.

 The requirement of an insn needing one or more delay slots is indicated
via the 'define_delay' expression.  It has the following form:

     (define_delay TEST
                   [DELAY-1 ANNUL-TRUE-1 ANNUL-FALSE-1
                    DELAY-2 ANNUL-TRUE-2 ANNUL-FALSE-2
                    ...])

 TEST is an attribute test that indicates whether this 'define_delay'
applies to a particular insn.  If so, the number of required delay slots
is determined by the length of the vector specified as the second
argument.  An insn placed in delay slot N must satisfy attribute test
DELAY-N.  ANNUL-TRUE-N is an attribute test that specifies which insns
may be annulled if the branch is true.  Similarly, ANNUL-FALSE-N
specifies which insns in the delay slot may be annulled if the branch is
false.  If annulling is not supported for that delay slot, '(nil)'
should be coded.

 For example, in the common case where branch and call insns require a
single delay slot, which may contain any insn other than a branch or
call, the following would be placed in the 'md' file:

     (define_delay (eq_attr "type" "branch,call")
                   [(eq_attr "type" "!branch,call") (nil) (nil)])

 Multiple 'define_delay' expressions may be specified.  In this case,
each such expression specifies different delay slot requirements and
there must be no insn for which tests in two 'define_delay' expressions
are both true.

 For example, if we have a machine that requires one delay slot for
branches but two for calls, no delay slot can contain a branch or call
insn, and any valid insn in the delay slot for the branch can be
annulled if the branch is true, we might represent this as follows:

     (define_delay (eq_attr "type" "branch")
        [(eq_attr "type" "!branch,call")
         (eq_attr "type" "!branch,call")
         (nil)])

     (define_delay (eq_attr "type" "call")
                   [(eq_attr "type" "!branch,call") (nil) (nil)
                    (eq_attr "type" "!branch,call") (nil) (nil)])

==============================================================================
File: gccint.info,  Node: |Processor_pipeline_description|,  Prev: |Delay_Slots|,  Up: |Insn_Attributes|
==============================================================================

                                                *Processor_pipeline_description*

17.19.9 Specifying processor pipeline description
-------------------------------------------------

To achieve better performance, most modern processors (super-pipelined,
superscalar RISC, and VLIW processors) have many "functional units" on
which several instructions can be executed simultaneously.  An
instruction starts execution if its issue conditions are satisfied.  If
not, the instruction is stalled until its conditions are satisfied.
Such "interlock (pipeline) delay" causes interruption of the fetching of
successor instructions (or demands nop instructions, e.g. for some MIPS
processors).

 There are two major kinds of interlock delays in modern processors.
The first one is a data dependence delay determining "instruction
latency time".  The instruction execution is not started until all
source data have been evaluated by prior instructions (there are more
complex cases when the instruction execution starts even when the data
are not available but will be ready in given time after the instruction
execution start).  Taking the data dependence delays into account is
simple.  The data dependence (true, output, and anti-dependence) delay
between two instructions is given by a constant.  In most cases this
approach is adequate.  The second kind of interlock delays is a
reservation delay.  The reservation delay means that two instructions
under execution will be in need of shared processors resources, i.e.
buses, internal registers, and/or functional units, which are reserved
for some time.  Taking this kind of delay into account is complex
especially for modern RISC processors.

 The task of exploiting more processor parallelism is solved by an
instruction scheduler.  For a better solution to this problem, the
instruction scheduler has to have an adequate description of the
processor parallelism (or "pipeline description").  GCC machine
descriptions describe processor parallelism and functional unit
reservations for groups of instructions with the aid of "regular
expressions".

 The GCC instruction scheduler uses a "pipeline hazard recognizer" to
figure out the possibility of the instruction issue by the processor on
a given simulated processor cycle.  The pipeline hazard recognizer is
automatically generated from the processor pipeline description.  The
pipeline hazard recognizer generated from the machine description is
based on a deterministic finite state automaton (DFA): the instruction
issue is possible if there is a transition from one automaton state to
another one.  This algorithm is very fast, and furthermore, its speed is
not dependent on processor complexity(1).

 The rest of this section describes the directives that constitute an
automaton-based processor pipeline description.  The order of these
constructions within the machine description file is not important.

 The following optional construction describes names of automata
generated and used for the pipeline hazards recognition.  Sometimes the
generated finite state automaton used by the pipeline hazard recognizer
is large.  If we use more than one automaton and bind functional units
to the automata, the total size of the automata is usually less than the
size of the single automaton.  If there is no one such construction,
only one finite state automaton is generated.

     (define_automaton AUTOMATA-NAMES)

 AUTOMATA-NAMES is a string giving names of the automata.  The names are
separated by commas.  All the automata should have unique names.  The
automaton name is used in the constructions 'define_cpu_unit' and
'define_query_cpu_unit'.

 Each processor functional unit used in the description of instruction
reservations should be described by the following construction.

     (define_cpu_unit UNIT-NAMES [AUTOMATON-NAME])

 UNIT-NAMES is a string giving the names of the functional units
separated by commas.  Don't use name 'nothing', it is reserved for other
goals.

 AUTOMATON-NAME is a string giving the name of the automaton with which
the unit is bound.  The automaton should be described in construction
'define_automaton'.  You should give "automaton-name", if there is a
defined automaton.

 The assignment of units to automata are constrained by the uses of the
units in insn reservations.  The most important constraint is: if a unit
reservation is present on a particular cycle of an alternative for an
insn reservation, then some unit from the same automaton must be present
on the same cycle for the other alternatives of the insn reservation.
The rest of the constraints are mentioned in the description of the
subsequent constructions.

 The following construction describes CPU functional units analogously
to 'define_cpu_unit'.  The reservation of such units can be queried for
an automaton state.  The instruction scheduler never queries reservation
of functional units for given automaton state.  So as a rule, you don't
need this construction.  This construction could be used for future code
generation goals (e.g. to generate VLIW insn templates).

     (define_query_cpu_unit UNIT-NAMES [AUTOMATON-NAME])

 UNIT-NAMES is a string giving names of the functional units separated
by commas.

 AUTOMATON-NAME is a string giving the name of the automaton with which
the unit is bound.

 The following construction is the major one to describe pipeline
characteristics of an instruction.

     (define_insn_reservation INSN-NAME DEFAULT_LATENCY
                              CONDITION REGEXP)

 DEFAULT_LATENCY is a number giving latency time of the instruction.
There is an important difference between the old description and the
automaton based pipeline description.  The latency time is used for all
dependencies when we use the old description.  In the automaton based
pipeline description, the given latency time is only used for true
dependencies.  The cost of anti-dependencies is always zero and the cost
of output dependencies is the difference between latency times of the
producing and consuming insns (if the difference is negative, the cost
is considered to be zero).  You can always change the default costs for
any description by using the target hook 'TARGET_SCHED_ADJUST_COST'
(*note Scheduling::).

 INSN-NAME is a string giving the internal name of the insn.  The
internal names are used in constructions 'define_bypass' and in the
automaton description file generated for debugging.  The internal name
has nothing in common with the names in 'define_insn'.  It is a good
practice to use insn classes described in the processor manual.

 CONDITION defines what RTL insns are described by this construction.
You should remember that you will be in trouble if CONDITION for two or
more different 'define_insn_reservation' constructions is TRUE for an
insn.  In this case what reservation will be used for the insn is not
defined.  Such cases are not checked during generation of the pipeline
hazards recognizer because in general recognizing that two conditions
may have the same value is quite difficult (especially if the conditions
contain 'symbol_ref').  It is also not checked during the pipeline
hazard recognizer work because it would slow down the recognizer
considerably.

 REGEXP is a string describing the reservation of the cpu's functional
units by the instruction.  The reservations are described by a regular
expression according to the following syntax:

            regexp = regexp "," oneof
                   | oneof

            oneof = oneof "|" allof
                  | allof

            allof = allof "+" repeat
                  | repeat

            repeat = element "*" number
                   | element

            element = cpu_function_unit_name
                    | reservation_name
                    | result_name
                    | "nothing"
                    | "(" regexp ")"

   * ',' is used for describing the start of the next cycle in the
     reservation.

   * '|' is used for describing a reservation described by the first
     regular expression or a reservation described by the second
     regular expression or etc.

   * '+' is used for describing a reservation described by the first
     regular expression and a reservation described by the second
     regular expression and etc.

   * '*' is used for convenience and simply means a sequence in which
     the regular expression are repeated NUMBER times with cycle
     advancing (see ',').

   * 'cpu_function_unit_name' denotes reservation of the named
     functional unit.

   * 'reservation_name' -- see description of construction
     'define_reservation'.

   * 'nothing' denotes no unit reservations.

 Sometimes unit reservations for different insns contain common parts.
In such case, you can simplify the pipeline description by describing
the common part by the following construction

     (define_reservation RESERVATION-NAME REGEXP)

 RESERVATION-NAME is a string giving name of REGEXP.  Functional unit
names and reservation names are in the same name space.  So the
reservation names should be different from the functional unit names and
cannot be the reserved name 'nothing'.

 The following construction is used to describe exceptions in the
latency time for given instruction pair.  This is so called bypasses.

     (define_bypass NUMBER OUT_INSN_NAMES IN_INSN_NAMES
                    [GUARD])

 NUMBER defines when the result generated by the instructions given in
string OUT_INSN_NAMES will be ready for the instructions given in string
IN_INSN_NAMES.  Each of these strings is a comma-separated list of
filename-style globs and they refer to the names of
'define_insn_reservation's.  For example:
     (define_bypass 1 "cpu1_load_*, cpu1_store_*" "cpu1_load_*")
 defines a bypass between instructions that start with 'cpu1_load_' or
'cpu1_store_' and those that start with 'cpu1_load_'.

 GUARD is an optional string giving the name of a C function which
defines an additional guard for the bypass.  The function will get the
two insns as parameters.  If the function returns zero the bypass will
be ignored for this case.  The additional guard is necessary to
recognize complicated bypasses, e.g. when the consumer is only an
address of insn 'store' (not a stored value).

 If there are more one bypass with the same output and input insns, the
chosen bypass is the first bypass with a guard in description whose
guard function returns nonzero.  If there is no such bypass, then bypass
without the guard function is chosen.

 The following five constructions are usually used to describe VLIW
processors, or more precisely, to describe a placement of small
instructions into VLIW instruction slots.  They can be used for RISC
processors, too.

     (exclusion_set UNIT-NAMES UNIT-NAMES)
     (presence_set UNIT-NAMES PATTERNS)
     (final_presence_set UNIT-NAMES PATTERNS)
     (absence_set UNIT-NAMES PATTERNS)
     (final_absence_set UNIT-NAMES PATTERNS)

 UNIT-NAMES is a string giving names of functional units separated by
commas.

 PATTERNS is a string giving patterns of functional units separated by
comma.  Currently pattern is one unit or units separated by
white-spaces.

 The first construction ('exclusion_set') means that each functional
unit in the first string cannot be reserved simultaneously with a unit
whose name is in the second string and vice versa.  For example, the
construction is useful for describing processors (e.g. some SPARC
processors) with a fully pipelined floating point functional unit which
can execute simultaneously only single floating point insns or only
double floating point insns.

 The second construction ('presence_set') means that each functional
unit in the first string cannot be reserved unless at least one of
pattern of units whose names are in the second string is reserved.  This
is an asymmetric relation.  For example, it is useful for description
that VLIW 'slot1' is reserved after 'slot0' reservation.  We could
describe it by the following construction

     (presence_set "slot1" "slot0")

 Or 'slot1' is reserved only after 'slot0' and unit 'b0' reservation.
In this case we could write

     (presence_set "slot1" "slot0 b0")

 The third construction ('final_presence_set') is analogous to
'presence_set'.  The difference between them is when checking is done.
When an instruction is issued in given automaton state reflecting all
current and planned unit reservations, the automaton state is changed.
The first state is a source state, the second one is a result state.
Checking for 'presence_set' is done on the source state reservation,
checking for 'final_presence_set' is done on the result reservation.
This construction is useful to describe a reservation which is actually
two subsequent reservations.  For example, if we use

     (presence_set "slot1" "slot0")

 the following insn will be never issued (because 'slot1' requires
'slot0' which is absent in the source state).

     (define_reservation "insn_and_nop" "slot0 + slot1")

 but it can be issued if we use analogous 'final_presence_set'.

 The forth construction ('absence_set') means that each functional unit
in the first string can be reserved only if each pattern of units whose
names are in the second string is not reserved.  This is an asymmetric
relation (actually 'exclusion_set' is analogous to this one but it is
symmetric).  For example it might be useful in a VLIW description to say
that 'slot0' cannot be reserved after either 'slot1' or 'slot2' have
been reserved.  This can be described as:

     (absence_set "slot0" "slot1, slot2")

 Or 'slot2' cannot be reserved if 'slot0' and unit 'b0' are reserved or
'slot1' and unit 'b1' are reserved.  In this case we could write

     (absence_set "slot2" "slot0 b0, slot1 b1")

 All functional units mentioned in a set should belong to the same
automaton.

 The last construction ('final_absence_set') is analogous to
'absence_set' but checking is done on the result (state) reservation.
See comments for 'final_presence_set'.

 You can control the generator of the pipeline hazard recognizer with
the following construction.

     (automata_option OPTIONS)

 OPTIONS is a string giving options which affect the generated code.
Currently there are the following options:

   * "no-minimization" makes no minimization of the automaton.  This is
     only worth to do when we are debugging the description and need to
     look more accurately at reservations of states.

   * "time" means printing time statistics about the generation of
     automata.

   * "stats" means printing statistics about the generated automata such
     as the number of DFA states, NDFA states and arcs.

   * "v" means a generation of the file describing the result automata.
     The file has suffix '.dfa' and can be used for the description
     verification and debugging.

   * "w" means a generation of warning instead of error for non-critical
     errors.

   * "no-comb-vect" prevents the automaton generator from generating two
     data structures and comparing them for space efficiency.  Using a
     comb vector to represent transitions may be better, but it can be
     very expensive to construct.  This option is useful if the build
     process spends an unacceptably long time in genautomata.

   * "ndfa" makes nondeterministic finite state automata.  This affects
     the treatment of operator '|' in the regular expressions.  The
     usual treatment of the operator is to try the first alternative
     and, if the reservation is not possible, the second alternative.
     The nondeterministic treatment means trying all alternatives, some
     of them may be rejected by reservations in the subsequent insns.

   * "collapse-ndfa" modifies the behavior of the generator when
     producing an automaton.  An additional state transition to collapse
     a nondeterministic NDFA state to a deterministic DFA state is
     generated.  It can be triggered by passing 'const0_rtx' to
     state_transition.  In such an automaton, cycle advance transitions
     are available only for these collapsed states.  This option is
     useful for ports that want to use the 'ndfa' option, but also want
     to use 'define_query_cpu_unit' to assign units to insns issued in a
     cycle.

   * "progress" means output of a progress bar showing how many states
     were generated so far for automaton being processed.  This is
     useful during debugging a DFA description.  If you see too many
     generated states, you could interrupt the generator of the pipeline
     hazard recognizer and try to figure out a reason for generation of
     the huge automaton.

 As an example, consider a superscalar RISC machine which can issue
three insns (two integer insns and one floating point insn) on the cycle
but can finish only two insns.  To describe this, we define the
following functional units.

     (define_cpu_unit "i0_pipeline, i1_pipeline, f_pipeline")
     (define_cpu_unit "port0, port1")

 All simple integer insns can be executed in any integer pipeline and
their result is ready in two cycles.  The simple integer insns are
issued into the first pipeline unless it is reserved, otherwise they are
issued into the second pipeline.  Integer division and multiplication
insns can be executed only in the second integer pipeline and their
results are ready correspondingly in 9 and 4 cycles.  The integer
division is not pipelined, i.e. the subsequent integer division insn
cannot be issued until the current division insn finished.  Floating
point insns are fully pipelined and their results are ready in 3 cycles.
Where the result of a floating point insn is used by an integer insn, an
additional delay of one cycle is incurred.  To describe all of this we
could specify

     (define_cpu_unit "div")

     (define_insn_reservation "simple" 2 (eq_attr "type" "int")
                              "(i0_pipeline | i1_pipeline), (port0 | port1)")

     (define_insn_reservation "mult" 4 (eq_attr "type" "mult")
                              "i1_pipeline, nothing*2, (port0 | port1)")

     (define_insn_reservation "div" 9 (eq_attr "type" "div")
                              "i1_pipeline, div*7, div + (port0 | port1)")

     (define_insn_reservation "float" 3 (eq_attr "type" "float")
                              "f_pipeline, nothing, (port0 | port1))

     (define_bypass 4 "float" "simple,mult,div")

 To simplify the description we could describe the following reservation

     (define_reservation "finish" "port0|port1")

 and use it in all 'define_insn_reservation' as in the following
construction

     (define_insn_reservation "simple" 2 (eq_attr "type" "int")
                              "(i0_pipeline | i1_pipeline), finish")

   ---------- Footnotes ----------

   (1) However, the size of the automaton depends on processor
complexity.  To limit this effect, machine descriptions can split
orthogonal parts of the machine description among several automata: but
then, since each of these must be stepped independently, this does cause
a small decrease in the algorithm's performance.

==============================================================================
File: gccint.info,  Node: |Conditional_Execution|,  Next: |Define_Subst|,  Prev: |Insn_Attributes|,  Up: |Machine_Desc|
==============================================================================

                                                         *Conditional_Execution*

17.20 Conditional Execution
=====----------------------

A number of architectures provide for some form of conditional
execution, or predication.  The hallmark of this feature is the ability
to nullify most of the instructions in the instruction set.  When the
instruction set is large and not entirely symmetric, it can be quite
tedious to describe these forms directly in the '.md' file.  An
alternative is the 'define_cond_exec' template.

     (define_cond_exec
       [PREDICATE-PATTERN]
       "CONDITION"
       "OUTPUT-TEMPLATE"
       "OPTIONAL-INSN-ATTRIBUES")

 PREDICATE-PATTERN is the condition that must be true for the insn to be
executed at runtime and should match a relational operator.  One can use
'match_operator' to match several relational operators at once.  Any
'match_operand' operands must have no more than one alternative.

 CONDITION is a C expression that must be true for the generated pattern
to match.

 OUTPUT-TEMPLATE is a string similar to the 'define_insn' output
template (*note Output Template::), except that the '*' and '@' special
cases do not apply.  This is only useful if the assembly text for the
predicate is a simple prefix to the main insn.  In order to handle the
general case, there is a global variable 'current_insn_predicate' that
will contain the entire predicate if the current insn is predicated, and
will otherwise be 'NULL'.

 OPTIONAL-INSN-ATTRIBUTES is an optional vector of attributes that gets
appended to the insn attributes of the produced cond_exec rtx.  It can
be used to add some distinguishing attribute to cond_exec rtxs produced
that way.  An example usage would be to use this attribute in
conjunction with attributes on the main pattern to disable particular
alternatives under certain conditions.

 When 'define_cond_exec' is used, an implicit reference to the
'predicable' instruction attribute is made.  *Note Insn Attributes::.
This attribute must be a boolean (i.e. have exactly two elements in its
LIST-OF-VALUES), with the possible values being 'no' and 'yes'.  The
default and all uses in the insns must be a simple constant, not a
complex expressions.  It may, however, depend on the alternative, by
using a comma-separated list of values.  If that is the case, the port
should also define an 'enabled' attribute (*note Disable Insn
Alternatives::), which should also allow only 'no' and 'yes' as its
values.

 For each 'define_insn' for which the 'predicable' attribute is true, a
new 'define_insn' pattern will be generated that matches a predicated
version of the instruction.  For example,

     (define_insn "addsi"
       [(set (match_operand:SI 0 "register_operand" "r")
             (plus:SI (match_operand:SI 1 "register_operand" "r")
                      (match_operand:SI 2 "register_operand" "r")))]
       "TEST1"
       "add %2,%1,%0")

     (define_cond_exec
       [(ne (match_operand:CC 0 "register_operand" "c")
            (const_int 0))]
       "TEST2"
       "(%0)")

generates a new pattern

     (define_insn ""
       [(cond_exec
          (ne (match_operand:CC 3 "register_operand" "c") (const_int 0))
          (set (match_operand:SI 0 "register_operand" "r")
               (plus:SI (match_operand:SI 1 "register_operand" "r")
                        (match_operand:SI 2 "register_operand" "r"))))]
       "(TEST2) && (TEST1)"
       "(%3) add %2,%1,%0")

==============================================================================
File: gccint.info,  Node: |Define_Subst|,  Next: |Constant_Definitions|,  Prev: |Conditional_Execution|,  Up: |Machine_Desc|
==============================================================================

                                                                  *Define_Subst*

17.21 RTL Templates Transformations
=====------------------------------

For some hardware architectures there are common cases when the RTL
templates for the instructions can be derived from the other RTL
templates using simple transformations.  E.g., 'i386.md' contains an RTL
template for the ordinary 'sub' instruction-- '*subsi_1', and for the
'sub' instruction with subsequent zero-extension--'*subsi_1_zext'.  Such
cases can be easily implemented by a single meta-template capable of
generating a modified case based on the initial one:

     (define_subst "NAME"
       [INPUT-TEMPLATE]
       "CONDITION"
       [OUTPUT-TEMPLATE])
 INPUT-TEMPLATE is a pattern describing the source RTL template, which
will be transformed.

 CONDITION is a C expression that is conjunct with the condition from
the input-template to generate a condition to be used in the
output-template.

 OUTPUT-TEMPLATE is a pattern that will be used in the resulting
template.

 'define_subst' mechanism is tightly coupled with the notion of the
subst attribute (*note Subst Iterators::).  The use of 'define_subst' is
triggered by a reference to a subst attribute in the transforming RTL
template.  This reference initiates duplication of the source RTL
template and substitution of the attributes with their values.  The
source RTL template is left unchanged, while the copy is transformed by
'define_subst'.  This transformation can fail in the case when the
source RTL template is not matched against the input-template of the
'define_subst'.  In such case the copy is deleted.

 'define_subst' can be used only in 'define_insn' and 'define_expand',
it cannot be used in other expressions (e.g. in
'define_insn_and_split').

MENU

* |Define_Subst_Example|::	    Example of 'define_subst' work.
* |Define_Subst_Pattern_Matching|::   Process of template comparison.
* |Define_Subst_Output_Template|::    Generation of output template.

==============================================================================
File: gccint.info,  Node: |Define_Subst_Example|,  Next: |Define_Subst_Pattern_Matching|,  Up: |Define_Subst|
==============================================================================

                                                          *Define_Subst_Example*

17.21.1 'define_subst' Example
------------------------------

To illustrate how 'define_subst' works, let us examine a simple template
transformation.

 Suppose there are two kinds of instructions: one that touches flags and
the other that does not.  The instructions of the second type could be
generated with the following 'define_subst':

     (define_subst "add_clobber_subst"
       [(set (match_operand:SI 0 "" "")
             (match_operand:SI 1 "" ""))]
       ""
       [(set (match_dup 0)
             (match_dup 1))
        (clobber (reg:CC FLAGS_REG))])

 This 'define_subst' can be applied to any RTL pattern containing 'set'
of mode SI and generates a copy with clobber when it is applied.

 Assume there is an RTL template for a 'max' instruction to be used in
'define_subst' mentioned above:

     (define_insn "maxsi"
       [(set (match_operand:SI 0 "register_operand" "=r")
             (max:SI
               (match_operand:SI 1 "register_operand" "r")
               (match_operand:SI 2 "register_operand" "r")))]
       ""
       "max\t{%2, %1, %0|%0, %1, %2}"
      [...])

 To mark the RTL template for 'define_subst' application,
subst-attributes are used.  They should be declared in advance:

     (define_subst_attr "add_clobber_name" "add_clobber_subst" "_noclobber" "_clobber")

 Here 'add_clobber_name' is the attribute name, 'add_clobber_subst' is
the name of the corresponding 'define_subst', the third argument
('_noclobber') is the attribute value that would be substituted into the
unchanged version of the source RTL template, and the last argument
('_clobber') is the value that would be substituted into the second,
transformed, version of the RTL template.

 Once the subst-attribute has been defined, it should be used in RTL
templates which need to be processed by the 'define_subst'.  So, the
original RTL template should be changed:

     (define_insn "maxsi<add_clobber_name>"
       [(set (match_operand:SI 0 "register_operand" "=r")
             (max:SI
               (match_operand:SI 1 "register_operand" "r")
               (match_operand:SI 2 "register_operand" "r")))]
       ""
       "max\t{%2, %1, %0|%0, %1, %2}"
      [...])

 The result of the 'define_subst' usage would look like the following:

     (define_insn "maxsi_noclobber"
       [(set (match_operand:SI 0 "register_operand" "=r")
             (max:SI
               (match_operand:SI 1 "register_operand" "r")
               (match_operand:SI 2 "register_operand" "r")))]
       ""
       "max\t{%2, %1, %0|%0, %1, %2}"
      [...])
     (define_insn "maxsi_clobber"
       [(set (match_operand:SI 0 "register_operand" "=r")
             (max:SI
               (match_operand:SI 1 "register_operand" "r")
               (match_operand:SI 2 "register_operand" "r")))
        (clobber (reg:CC FLAGS_REG))]
       ""
       "max\t{%2, %1, %0|%0, %1, %2}"
      [...])

==============================================================================
File: gccint.info,  Node: |Define_Subst_Pattern_Matching|,  Next: |Define_Subst_Output_Template|,  Prev: |Define_Subst_Example|,  Up: |Define_Subst|
==============================================================================

                                                 *Define_Subst_Pattern_Matching*

17.21.2 Pattern Matching in 'define_subst'
------------------------------------------

All expressions, allowed in 'define_insn' or 'define_expand', are
allowed in the input-template of 'define_subst', except 'match_par_dup',
'match_scratch', 'match_parallel'.  The meanings of expressions in the
input-template were changed:

 'match_operand' matches any expression (possibly, a subtree in
RTL-template), if modes of the 'match_operand' and this expression are
the same, or mode of the 'match_operand' is 'VOIDmode', or this
expression is 'match_dup', 'match_op_dup'.  If the expression is
'match_operand' too, and predicate of 'match_operand' from the input
pattern is not empty, then the predicates are compared.  That can be
used for more accurate filtering of accepted RTL-templates.

 'match_operator' matches common operators (like 'plus', 'minus'),
'unspec', 'unspec_volatile' operators and 'match_operator's from the
original pattern if the modes match and 'match_operator' from the input
pattern has the same number of operands as the operator from the
original pattern.

==============================================================================
File: gccint.info,  Node: |Define_Subst_Output_Template|,  Prev: |Define_Subst_Pattern_Matching|,  Up: |Define_Subst|
==============================================================================

                                                  *Define_Subst_Output_Template*

17.21.3 Generation of output template in 'define_subst'
-------------------------------------------------------

If all necessary checks for 'define_subst' application pass, a new
RTL-pattern, based on the output-template, is created to replace the old
template.  Like in input-patterns, meanings of some RTL expressions are
changed when they are used in output-patterns of a 'define_subst'.
Thus, 'match_dup' is used for copying the whole expression from the
original pattern, which matched corresponding 'match_operand' from the
input pattern.

 'match_dup N' is used in the output template to be replaced with the
expression from the original pattern, which matched 'match_operand N'
from the input pattern.  As a consequence, 'match_dup' cannot be used to
point to 'match_operand's from the output pattern, it should always
refer to a 'match_operand' from the input pattern.  If a 'match_dup N'
occurs more than once in the output template, its first occurrence is
replaced with the expression from the original pattern, and the
subsequent expressions are replaced with 'match_dup N', i.e., a
reference to the first expression.

 In the output template one can refer to the expressions from the
original pattern and create new ones.  For instance, some operands could
be added by means of standard 'match_operand'.

 After replacing 'match_dup' with some RTL-subtree from the original
pattern, it could happen that several 'match_operand's in the output
pattern have the same indexes.  It is unknown, how many and what indexes
would be used in the expression which would replace 'match_dup', so such
conflicts in indexes are inevitable.  To overcome this issue,
'match_operands' and 'match_operators', which were introduced into the
output pattern, are renumerated when all 'match_dup's are replaced.

 Number of alternatives in 'match_operand's introduced into the output
template 'M' could differ from the number of alternatives in the
original pattern 'N', so in the resultant pattern there would be 'N*M'
alternatives.  Thus, constraints from the original pattern would be
duplicated 'N' times, constraints from the output pattern would be
duplicated 'M' times, producing all possible combinations.

==============================================================================
File: gccint.info,  Node: |Constant_Definitions|,  Next: |Iterators|,  Prev: |Define_Subst|,  Up: |Machine_Desc|
==============================================================================

                                                          *Constant_Definitions*

17.22 Constant Definitions
=====---------------------

Using literal constants inside instruction patterns reduces legibility
and can be a maintenance problem.

 To overcome this problem, you may use the 'define_constants'
expression.  It contains a vector of name-value pairs.  From that point
on, wherever any of the names appears in the MD file, it is as if the
corresponding value had been written instead.  You may use
'define_constants' multiple times; each appearance adds more constants
to the table.  It is an error to redefine a constant with a different
value.

 To come back to the a29k load multiple example, instead of

     (define_insn ""
       [(match_parallel 0 "load_multiple_operation"
          [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
                (match_operand:SI 2 "memory_operand" "m"))
           (use (reg:SI 179))
           (clobber (reg:SI 179))])]
       ""
       "loadm 0,0,%1,%2")

 You could write:

     (define_constants [
         (R_BP 177)
         (R_FC 178)
         (R_CR 179)
         (R_Q  180)
     ])
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
