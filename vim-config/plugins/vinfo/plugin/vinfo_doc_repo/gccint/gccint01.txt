'arm_acq_rel'
     ARM target supports acquire-release instructions.

'arm_v8_2a_fp16_scalar_ok'
     ARM target supports options to generate instructions for ARMv8.2-A
     and scalar instructions from the FP16 extension.  Some multilibs
     may be incompatible with these options.

'arm_v8_2a_fp16_scalar_hw'
     ARM target supports executing instructions for ARMv8.2-A and scalar
     instructions from the FP16 extension.  Some multilibs may be
     incompatible with these options.  Implies arm_v8_2a_fp16_neon_ok.

'arm_v8_2a_fp16_neon_ok'
     ARM target supports options to generate instructions from ARMv8.2-A
     with the FP16 extension.  Some multilibs may be incompatible with
     these options.  Implies arm_v8_2a_fp16_scalar_ok.

'arm_v8_2a_fp16_neon_hw'
     ARM target supports executing instructions from ARMv8.2-A with the
     FP16 extension.  Some multilibs may be incompatible with these
     options.  Implies arm_v8_2a_fp16_neon_ok and
     arm_v8_2a_fp16_scalar_hw.

'arm_v8_2a_dotprod_neon_ok'
     ARM target supports options to generate instructions from ARMv8.2-A
     with the Dot Product extension.  Some multilibs may be incompatible
     with these options.

'arm_v8_2a_dotprod_neon_hw'
     ARM target supports executing instructions from ARMv8.2-A with the
     Dot Product extension.  Some multilibs may be incompatible with
     these options.  Implies arm_v8_2a_dotprod_neon_ok.

'arm_fp16fml_neon_ok'
     ARM target supports extensions to generate the 'VFMAL' and 'VFMLS'
     half-precision floating-point instructions available from ARMv8.2-A
     and onwards.  Some multilibs may be incompatible with these
     options.

'arm_v8_2a_bf16_neon_ok'
     ARM target supports options to generate instructions from ARMv8.2-A
     with the BFloat16 extension (bf16).  Some multilibs may be
     incompatible with these options.

'arm_v8_2a_i8mm_ok'
     ARM target supports options to generate instructions from ARMv8.2-A
     with the 8-Bit Integer Matrix Multiply extension (i8mm).  Some
     multilibs may be incompatible with these options.

'arm_v8_1m_mve_ok'
     ARM target supports options to generate instructions from ARMv8.1-M
     with the M-Profile Vector Extension (MVE). Some multilibs may be
     incompatible with these options.

'arm_v8_1m_mve_fp_ok'
     ARM target supports options to generate instructions from ARMv8.1-M
     with the Half-precision floating-point instructions (HP),
     Floating-point Extension (FP) along with M-Profile Vector Extension
     (MVE). Some multilibs may be incompatible with these options.

'arm_mve_hw'
     Test system supports executing MVE instructions.

'arm_v8m_main_cde'
     ARM target supports options to generate instructions from ARMv8-M
     with the Custom Datapath Extension (CDE). Some multilibs may be
     incompatible with these options.

'arm_v8m_main_cde_fp'
     ARM target supports options to generate instructions from ARMv8-M
     with the Custom Datapath Extension (CDE) and floating-point (VFP).
     Some multilibs may be incompatible with these options.

'arm_v8_1m_main_cde_mve'
     ARM target supports options to generate instructions from ARMv8.1-M
     with the Custom Datapath Extension (CDE) and M-Profile Vector
     Extension (MVE). Some multilibs may be incompatible with these
     options.

'arm_prefer_ldrd_strd'
     ARM target prefers 'LDRD' and 'STRD' instructions over 'LDM' and
     'STM' instructions.

'arm_thumb1_movt_ok'
     ARM target generates Thumb-1 code for '-mthumb' with 'MOVW' and
     'MOVT' instructions available.

'arm_thumb1_cbz_ok'
     ARM target generates Thumb-1 code for '-mthumb' with 'CBZ' and
     'CBNZ' instructions available.

'arm_divmod_simode'
     ARM target for which divmod transform is disabled, if it supports
     hardware div instruction.

'arm_cmse_ok'
     ARM target supports ARMv8-M Security Extensions, enabled by the
     '-mcmse' option.

'arm_coproc1_ok'
     ARM target supports the following coprocessor instructions: 'CDP',
     'LDC', 'STC', 'MCR' and 'MRC'.

'arm_coproc2_ok'
     ARM target supports all the coprocessor instructions also listed as
     supported in *note arm_coproc1_ok:: in addition to the following:
     'CDP2', 'LDC2', 'LDC2l', 'STC2', 'STC2l', 'MCR2' and 'MRC2'.

'arm_coproc3_ok'
     ARM target supports all the coprocessor instructions also listed as
     supported in *note arm_coproc2_ok:: in addition the following:
     'MCRR' and 'MRRC'.

'arm_coproc4_ok'
     ARM target supports all the coprocessor instructions also listed as
     supported in *note arm_coproc3_ok:: in addition the following:
     'MCRR2' and 'MRRC2'.

'arm_simd32_ok'
     ARM Target supports options suitable for accessing the SIMD32
     intrinsics from 'arm_acle.h'.  Some multilibs may be incompatible
     with these options.

'arm_qbit_ok'
     ARM Target supports options suitable for accessing the Q-bit
     manipulation intrinsics from 'arm_acle.h'.  Some multilibs may be
     incompatible with these options.

'arm_softfp_ok'
     ARM target supports the '-mfloat-abi=softfp' option.

'arm_hard_ok'
     ARM target supports the '-mfloat-abi=hard' option.

7.2.3.8 AArch64-specific attributes
-----------------------------------

'aarch64_asm_<ext>_ok'
     AArch64 assembler supports the architecture extension 'ext' via the
     '.arch_extension' pseudo-op.
'aarch64_tiny'
     AArch64 target which generates instruction sequences for tiny
     memory model.
'aarch64_small'
     AArch64 target which generates instruction sequences for small
     memory model.
'aarch64_large'
     AArch64 target which generates instruction sequences for large
     memory model.
'aarch64_little_endian'
     AArch64 target which generates instruction sequences for little
     endian.
'aarch64_big_endian'
     AArch64 target which generates instruction sequences for big
     endian.
'aarch64_small_fpic'
     Binutils installed on test system supports relocation types
     required by -fpic for AArch64 small memory model.
'aarch64_sve_hw'
     AArch64 target that is able to generate and execute SVE code
     (regardless of whether it does so by default).
'aarch64_sve128_hw'
'aarch64_sve256_hw'
'aarch64_sve512_hw'
'aarch64_sve1024_hw'
'aarch64_sve2048_hw'
     Like 'aarch64_sve_hw', but also test for an exact hardware vector
     length.

7.2.3.9 MIPS-specific attributes
--------------------------------

'mips64'
     MIPS target supports 64-bit instructions.

'nomips16'
     MIPS target does not produce MIPS16 code.

'mips16_attribute'
     MIPS target can generate MIPS16 code.

'mips_loongson'
     MIPS target is a Loongson-2E or -2F target using an ABI that
     supports the Loongson vector modes.

'mips_msa'
     MIPS target supports '-mmsa', MIPS SIMD Architecture (MSA).

'mips_newabi_large_long_double'
     MIPS target supports 'long double' larger than 'double' when using
     the new ABI.

'mpaired_single'
     MIPS target supports '-mpaired-single'.

7.2.3.10 PowerPC-specific attributes
------------------------------------

'dfp_hw'
     PowerPC target supports executing hardware DFP instructions.

'p8vector_hw'
     PowerPC target supports executing VSX instructions (ISA 2.07).

'powerpc64'
     Test system supports executing 64-bit instructions.

'powerpc_altivec'
     PowerPC target supports AltiVec.

'powerpc_altivec_ok'
     PowerPC target supports '-maltivec'.

'powerpc_eabi_ok'
     PowerPC target supports '-meabi'.

'powerpc_elfv2'
     PowerPC target supports '-mabi=elfv2'.

'powerpc_fprs'
     PowerPC target supports floating-point registers.

'powerpc_hard_double'
     PowerPC target supports hardware double-precision floating-point.

'powerpc_htm_ok'
     PowerPC target supports '-mhtm'

'powerpc_p8vector_ok'
     PowerPC target supports '-mpower8-vector'

'powerpc_popcntb_ok'
     PowerPC target supports the 'popcntb' instruction, indicating that
     this target supports '-mcpu=power5'.

'powerpc_ppu_ok'
     PowerPC target supports '-mcpu=cell'.

'powerpc_spe'
     PowerPC target supports PowerPC SPE.

'powerpc_spe_nocache'
     Including the options used to compile this particular test, the
     PowerPC target supports PowerPC SPE.

'powerpc_spu'
     PowerPC target supports PowerPC SPU.

'powerpc_vsx_ok'
     PowerPC target supports '-mvsx'.

'powerpc_405_nocache'
     Including the options used to compile this particular test, the
     PowerPC target supports PowerPC 405.

'ppc_recip_hw'
     PowerPC target supports executing reciprocal estimate instructions.

'vmx_hw'
     PowerPC target supports executing AltiVec instructions.

'vsx_hw'
     PowerPC target supports executing VSX instructions (ISA 2.06).

7.2.3.11 Other hardware attributes
----------------------------------

'autoincdec'
     Target supports autoincrement/decrement addressing.

'avx'
     Target supports compiling 'avx' instructions.

'avx_runtime'
     Target supports the execution of 'avx' instructions.

'avx2'
     Target supports compiling 'avx2' instructions.

'avx2_runtime'
     Target supports the execution of 'avx2' instructions.

'avx512f'
     Target supports compiling 'avx512f' instructions.

'avx512f_runtime'
     Target supports the execution of 'avx512f' instructions.

'avx512vp2intersect'
     Target supports the execution of 'avx512vp2intersect' instructions.

'cell_hw'
     Test system can execute AltiVec and Cell PPU instructions.

'coldfire_fpu'
     Target uses a ColdFire FPU.

'divmod'
     Target supporting hardware divmod insn or divmod libcall.

'divmod_simode'
     Target supporting hardware divmod insn or divmod libcall for
     SImode.

'hard_float'
     Target supports FPU instructions.

'non_strict_align'
     Target does not require strict alignment.

'pie_copyreloc'
     The x86-64 target linker supports PIE with copy reloc.

'rdrand'
     Target supports x86 'rdrand' instruction.

'sqrt_insn'
     Target has a square root instruction that the compiler can
     generate.

'sse'
     Target supports compiling 'sse' instructions.

'sse_runtime'
     Target supports the execution of 'sse' instructions.

'sse2'
     Target supports compiling 'sse2' instructions.

'sse2_runtime'
     Target supports the execution of 'sse2' instructions.

'sync_char_short'
     Target supports atomic operations on 'char' and 'short'.

'sync_int_long'
     Target supports atomic operations on 'int' and 'long'.

'ultrasparc_hw'
     Test environment appears to run executables on a simulator that
     accepts only 'EM_SPARC' executables and chokes on 'EM_SPARC32PLUS'
     or 'EM_SPARCV9' executables.

'vect_cmdline_needed'
     Target requires a command line argument to enable a SIMD
     instruction set.

'xorsign'
     Target supports the xorsign optab expansion.

7.2.3.12 Environment attributes
-------------------------------

'c'
     The language for the compiler under test is C.

'c++'
     The language for the compiler under test is C++.

'c99_runtime'
     Target provides a full C99 runtime.

'correct_iso_cpp_string_wchar_protos'
     Target 'string.h' and 'wchar.h' headers provide C++ required
     overloads for 'strchr' etc.  functions.

'd_runtime'
     Target provides the D runtime.

'd_runtime_has_std_library'
     Target provides the D standard library (Phobos).

'dummy_wcsftime'
     Target uses a dummy 'wcsftime' function that always returns zero.

'fd_truncate'
     Target can truncate a file from a file descriptor, as used by
     'libgfortran/io/unix.c:fd_truncate'; i.e. 'ftruncate' or 'chsize'.

'fenv'
     Target provides 'fenv.h' include file.

'fenv_exceptions'
     Target supports 'fenv.h' with all the standard IEEE exceptions and
     floating-point exceptions are raised by arithmetic operations.

'fileio'
     Target offers such file I/O library functions as 'fopen', 'fclose',
     'tmpnam', and 'remove'.  This is a link-time requirement for the
     presence of the functions in the library; even if they fail at
     runtime, the requirement is still regarded as satisfied.

'freestanding'
     Target is 'freestanding' as defined in section 4 of the C99
     standard.  Effectively, it is a target which supports no extra
     headers or libraries other than what is considered essential.

'gettimeofday'
     Target supports 'gettimeofday'.

'init_priority'
     Target supports constructors with initialization priority
     arguments.

'inttypes_types'
     Target has the basic signed and unsigned types in 'inttypes.h'.
     This is for tests that GCC's notions of these types agree with
     those in the header, as some systems have only 'inttypes.h'.

'lax_strtofp'
     Target might have errors of a few ULP in string to floating-point
     conversion functions and overflow is not always detected correctly
     by those functions.

'mempcpy'
     Target provides 'mempcpy' function.

'mmap'
     Target supports 'mmap'.

'newlib'
     Target supports Newlib.

'newlib_nano_io'
     GCC was configured with '--enable-newlib-nano-formatted-io', which
     reduces the code size of Newlib formatted I/O functions.

'pow10'
     Target provides 'pow10' function.

'pthread'
     Target can compile using 'pthread.h' with no errors or warnings.

'pthread_h'
     Target has 'pthread.h'.

'run_expensive_tests'
     Expensive testcases (usually those that consume excessive amounts
     of CPU time) should be run on this target.  This can be enabled by
     setting the 'GCC_TEST_RUN_EXPENSIVE' environment variable to a
     non-empty string.

'simulator'
     Test system runs executables on a simulator (i.e. slowly) rather
     than hardware (i.e. fast).

'signal'
     Target has 'signal.h'.

'stabs'
     Target supports the stabs debugging format.

'stdint_types'
     Target has the basic signed and unsigned C types in 'stdint.h'.
     This will be obsolete when GCC ensures a working 'stdint.h' for all
     targets.

'stpcpy'
     Target provides 'stpcpy' function.

'trampolines'
     Target supports trampolines.

'uclibc'
     Target supports uClibc.

'unwrapped'
     Target does not use a status wrapper.

'vxworks_kernel'
     Target is a VxWorks kernel.

'vxworks_rtp'
     Target is a VxWorks RTP.

'wchar'
     Target supports wide characters.

7.2.3.13 Other attributes
-------------------------

'automatic_stack_alignment'
     Target supports automatic stack alignment.

'branch_cost'
     Target supports '-branch-cost=N'.

'cxa_atexit'
     Target uses '__cxa_atexit'.

'default_packed'
     Target has packed layout of structure members by default.

'exceptions'
     Target supports exceptions.

'exceptions_enabled'
     Target supports exceptions and they are enabled in the current
     testing configuration.

'fgraphite'
     Target supports Graphite optimizations.

'fixed_point'
     Target supports fixed-point extension to C.

'fopenacc'
     Target supports OpenACC via '-fopenacc'.

'fopenmp'
     Target supports OpenMP via '-fopenmp'.

'fpic'
     Target supports '-fpic' and '-fPIC'.

'freorder'
     Target supports '-freorder-blocks-and-partition'.

'fstack_protector'
     Target supports '-fstack-protector'.

'gas'
     Target uses GNU 'as'.

'gc_sections'
     Target supports '--gc-sections'.

'gld'
     Target uses GNU 'ld'.

'keeps_null_pointer_checks'
     Target keeps null pointer checks, either due to the use of
     '-fno-delete-null-pointer-checks' or hardwired into the target.

'llvm_binutils'
     Target is using an LLVM assembler and/or linker, instead of GNU
     Binutils.

'lto'
     Compiler has been configured to support link-time optimization
     (LTO).

'lto_incremental'
     Compiler and linker support link-time optimization relocatable
     linking with '-r' and '-flto' options.

'naked_functions'
     Target supports the 'naked' function attribute.

'named_sections'
     Target supports named sections.

'natural_alignment_32'
     Target uses natural alignment (aligned to type size) for types of
     32 bits or less.

'target_natural_alignment_64'
     Target uses natural alignment (aligned to type size) for types of
     64 bits or less.

'noinit'
     Target supports the 'noinit' variable attribute.

'nonpic'
     Target does not generate PIC by default.

'offload_gcn'
     Target has been configured for OpenACC/OpenMP offloading on AMD
     GCN.

'pie_enabled'
     Target generates PIE by default.

'pcc_bitfield_type_matters'
     Target defines 'PCC_BITFIELD_TYPE_MATTERS'.

'pe_aligned_commons'
     Target supports '-mpe-aligned-commons'.

'pie'
     Target supports '-pie', '-fpie' and '-fPIE'.

'rdynamic'
     Target supports '-rdynamic'.

'scalar_all_fma'
     Target supports all four fused multiply-add optabs for both 'float'
     and 'double'.  These optabs are: 'fma_optab', 'fms_optab',
     'fnma_optab' and 'fnms_optab'.

'section_anchors'
     Target supports section anchors.

'short_enums'
     Target defaults to short enums.

'stack_size'
     Target has limited stack size.  The stack size limit can be
     obtained using the STACK_SIZE macro defined by *note
     'dg-add-options' feature 'stack_size': stack_size_ao.

'static'
     Target supports '-static'.

'static_libgfortran'
     Target supports statically linking 'libgfortran'.

'string_merging'
     Target supports merging string constants at link time.

'ucn'
     Target supports compiling and assembling UCN.

'ucn_nocache'
     Including the options used to compile this particular test, the
     target supports compiling and assembling UCN.

'unaligned_stack'
     Target does not guarantee that its 'STACK_BOUNDARY' is greater than
     or equal to the required vector alignment.

'vector_alignment_reachable'
     Vector alignment is reachable for types of 32 bits or less.

'vector_alignment_reachable_for_64bit'
     Vector alignment is reachable for types of 64 bits or less.

'wchar_t_char16_t_compatible'
     Target supports 'wchar_t' that is compatible with 'char16_t'.

'wchar_t_char32_t_compatible'
     Target supports 'wchar_t' that is compatible with 'char32_t'.

'comdat_group'
     Target uses comdat groups.

'indirect_calls'
     Target supports indirect calls, i.e.  calls where the target is not
     constant.

7.2.3.14 Local to tests in 'gcc.target/i386'
--------------------------------------------

'3dnow'
     Target supports compiling '3dnow' instructions.

'aes'
     Target supports compiling 'aes' instructions.

'fma4'
     Target supports compiling 'fma4' instructions.

'mfentry'
     Target supports the '-mfentry' option that alters the position of
     profiling calls such that they precede the prologue.

'ms_hook_prologue'
     Target supports attribute 'ms_hook_prologue'.

'pclmul'
     Target supports compiling 'pclmul' instructions.

'sse3'
     Target supports compiling 'sse3' instructions.

'sse4'
     Target supports compiling 'sse4' instructions.

'sse4a'
     Target supports compiling 'sse4a' instructions.

'ssse3'
     Target supports compiling 'ssse3' instructions.

'vaes'
     Target supports compiling 'vaes' instructions.

'vpclmul'
     Target supports compiling 'vpclmul' instructions.

'xop'
     Target supports compiling 'xop' instructions.

7.2.3.15 Local to tests in 'gcc.test-framework'
-----------------------------------------------

'no'
     Always returns 0.

'yes'
     Always returns 1.

==============================================================================
File: gccint.info,  Node: |Add_Options|,  Next: |Require_Support|,  Prev: |Effective_Target_Keywords|,  Up: |Test_Directives|
==============================================================================

                                                                   *Add_Options*

7.2.4 Features for 'dg-add-options'
-----------------------------------

The supported values of FEATURE for directive 'dg-add-options' are:

'arm_fp'
     '__ARM_FP' definition.  Only ARM targets support this feature, and
     only then in certain modes; see the *note arm_fp_ok effective
     target keyword: arm_fp_ok.

'arm_fp_dp'
     '__ARM_FP' definition with double-precision support.  Only ARM
     targets support this feature, and only then in certain modes; see
     the *note arm_fp_dp_ok effective target keyword: arm_fp_dp_ok.

'arm_neon'
     NEON support.  Only ARM targets support this feature, and only then
     in certain modes; see the *note arm_neon_ok effective target
     keyword: arm_neon_ok.

'arm_fp16'
     VFP half-precision floating point support.  This does not select
     the FP16 format; for that, use *note arm_fp16_ieee: arm_fp16_ieee.
     or *note arm_fp16_alternative: arm_fp16_alternative. instead.  This
     feature is only supported by ARM targets and then only in certain
     modes; see the *note arm_fp16_ok effective target keyword:
     arm_fp16_ok.

'arm_fp16_ieee'
     ARM IEEE 754-2008 format VFP half-precision floating point support.
     This feature is only supported by ARM targets and then only in
     certain modes; see the *note arm_fp16_ok effective target keyword:
     arm_fp16_ok.

'arm_fp16_alternative'
     ARM Alternative format VFP half-precision floating point support.
     This feature is only supported by ARM targets and then only in
     certain modes; see the *note arm_fp16_ok effective target keyword:
     arm_fp16_ok.

'arm_neon_fp16'
     NEON and half-precision floating point support.  Only ARM targets
     support this feature, and only then in certain modes; see the *note
     arm_neon_fp16_ok effective target keyword: arm_neon_fp16_ok.

'arm_vfp3'
     arm vfp3 floating point support; see the *note arm_vfp3_ok
     effective target keyword: arm_vfp3_ok.

'arm_arch_v8a_hard'
     Add options for ARMv8-A and the hard-float variant of the AAPCS, if
     this is supported by the compiler; see the *note
     arm_arch_v8a_hard_ok: arm_arch_v8a_hard_ok. effective target
     keyword.

'arm_v8_1a_neon'
     Add options for ARMv8.1-A with Adv.SIMD support, if this is
     supported by the target; see the *note arm_v8_1a_neon_ok:
     arm_v8_1a_neon_ok. effective target keyword.

'arm_v8_2a_fp16_scalar'
     Add options for ARMv8.2-A with scalar FP16 support, if this is
     supported by the target; see the *note arm_v8_2a_fp16_scalar_ok:
     arm_v8_2a_fp16_scalar_ok. effective target keyword.

'arm_v8_2a_fp16_neon'
     Add options for ARMv8.2-A with Adv.SIMD FP16 support, if this is
     supported by the target; see the *note arm_v8_2a_fp16_neon_ok:
     arm_v8_2a_fp16_neon_ok. effective target keyword.

'arm_v8_2a_dotprod_neon'
     Add options for ARMv8.2-A with Adv.SIMD Dot Product support, if
     this is supported by the target; see the *note
     arm_v8_2a_dotprod_neon_ok:: effective target keyword.

'arm_fp16fml_neon'
     Add options to enable generation of the 'VFMAL' and 'VFMSL'
     instructions, if this is supported by the target; see the *note
     arm_fp16fml_neon_ok:: effective target keyword.

'bind_pic_locally'
     Add the target-specific flags needed to enable functions to bind
     locally when using pic/PIC passes in the testsuite.

'floatN'
     Add the target-specific flags needed to use the '_FloatN' type.

'floatNx'
     Add the target-specific flags needed to use the '_FloatNx' type.

'ieee'
     Add the target-specific flags needed to enable full IEEE compliance
     mode.

'mips16_attribute'
     'mips16' function attributes.  Only MIPS targets support this
     feature, and only then in certain modes.

'stack_size'
     Add the flags needed to define macro STACK_SIZE and set it to the
     stack size limit associated with the *note 'stack_size' effective
     target: stack_size_et.

'sqrt_insn'
     Add the target-specific flags needed to enable hardware square root
     instructions, if any.

'tls'
     Add the target-specific flags needed to use thread-local storage.

==============================================================================
File: gccint.info,  Node: |Require_Support|,  Next: |Final_Actions|,  Prev: |Add_Options|,  Up: |Test_Directives|
==============================================================================

                                                               *Require_Support*

7.2.5 Variants of 'dg-require-SUPPORT'
--------------------------------------

A few of the 'dg-require' directives take arguments.

'dg-require-iconv CODESET'
     Skip the test if the target does not support iconv.  CODESET is the
     codeset to convert to.

'dg-require-profiling PROFOPT'
     Skip the test if the target does not support profiling with option
     PROFOPT.

'dg-require-stack-check CHECK'
     Skip the test if the target does not support the '-fstack-check'
     option.  If CHECK is '""', support for '-fstack-check' is checked,
     for '-fstack-check=("CHECK")' otherwise.

'dg-require-stack-size SIZE'
     Skip the test if the target does not support a stack size of SIZE.

'dg-require-visibility VIS'
     Skip the test if the target does not support the 'visibility'
     attribute.  If VIS is '""', support for 'visibility("hidden")' is
     checked, for 'visibility("VIS")' otherwise.

 The original 'dg-require' directives were defined before there was
support for effective-target keywords.  The directives that do not take
arguments could be replaced with effective-target keywords.

'dg-require-alias ""'
     Skip the test if the target does not support the 'alias' attribute.

'dg-require-ascii-locale ""'
     Skip the test if the host does not support an ASCII locale.

'dg-require-compat-dfp ""'
     Skip this test unless both compilers in a 'compat' testsuite
     support decimal floating point.

'dg-require-cxa-atexit ""'
     Skip the test if the target does not support '__cxa_atexit'.  This
     is equivalent to 'dg-require-effective-target cxa_atexit'.

'dg-require-dll ""'
     Skip the test if the target does not support DLL attributes.

'dg-require-dot ""'
     Skip the test if the host does not have 'dot'.

'dg-require-fork ""'
     Skip the test if the target does not support 'fork'.

'dg-require-gc-sections ""'
     Skip the test if the target's linker does not support the
     '--gc-sections' flags.  This is equivalent to
     'dg-require-effective-target gc-sections'.

'dg-require-host-local ""'
     Skip the test if the host is remote, rather than the same as the
     build system.  Some tests are incompatible with DejaGnu's handling
     of remote hosts, which involves copying the source file to the host
     and compiling it with a relative path and "'-o a.out'".

'dg-require-mkfifo ""'
     Skip the test if the target does not support 'mkfifo'.

'dg-require-named-sections ""'
     Skip the test is the target does not support named sections.  This
     is equivalent to 'dg-require-effective-target named_sections'.

'dg-require-weak ""'
     Skip the test if the target does not support weak symbols.

'dg-require-weak-override ""'
     Skip the test if the target does not support overriding weak
     symbols.

==============================================================================
File: gccint.info,  Node: |Final_Actions|,  Prev: |Require_Support|,  Up: |Test_Directives|
==============================================================================

                                                                 *Final_Actions*

7.2.6 Commands for use in 'dg-final'
------------------------------------

The GCC testsuite defines the following directives to be used within
'dg-final'.

7.2.6.1 Scan a particular file
------------------------------

'scan-file FILENAME REGEXP [{ target/xfail SELECTOR }]'
     Passes if REGEXP matches text in FILENAME.
'scan-file-not FILENAME REGEXP [{ target/xfail SELECTOR }]'
     Passes if REGEXP does not match text in FILENAME.
'scan-module MODULE REGEXP [{ target/xfail SELECTOR }]'
     Passes if REGEXP matches in Fortran module MODULE.
'dg-check-dot FILENAME'
     Passes if FILENAME is a valid '.dot' file (by running 'dot -Tpng'
     on it, and verifying the exit code is 0).

7.2.6.2 Scan the assembly output
--------------------------------

'scan-assembler REGEX [{ target/xfail SELECTOR }]'
     Passes if REGEX matches text in the test's assembler output.

'scan-assembler-not REGEX [{ target/xfail SELECTOR }]'
     Passes if REGEX does not match text in the test's assembler output.

'scan-assembler-times REGEX NUM [{ target/xfail SELECTOR }]'
     Passes if REGEX is matched exactly NUM times in the test's
     assembler output.

'scan-assembler-dem REGEX [{ target/xfail SELECTOR }]'
     Passes if REGEX matches text in the test's demangled assembler
     output.

'scan-assembler-dem-not REGEX [{ target/xfail SELECTOR }]'
     Passes if REGEX does not match text in the test's demangled
     assembler output.

'scan-hidden SYMBOL [{ target/xfail SELECTOR }]'
     Passes if SYMBOL is defined as a hidden symbol in the test's
     assembly output.

'scan-not-hidden SYMBOL [{ target/xfail SELECTOR }]'
     Passes if SYMBOL is not defined as a hidden symbol in the test's
     assembly output.

'check-function-bodies PREFIX TERMINATOR [OPTIONS [{ target/xfail SELECTOR }]]'
     Looks through the source file for comments that give the expected
     assembly output for selected functions.  Each line of expected
     output starts with the prefix string PREFIX and the expected output
     for a function as a whole is followed by a line that starts with
     the string TERMINATOR.  Specifying an empty terminator is
     equivalent to specifying '"*/"'.

     OPTIONS, if specified, is a list of regular expressions, each of
     which matches a full command-line option.  A non-empty list
     prevents the test from running unless all of the given options are
     present on the command line.  This can help if a source file is
     compiled both with and without optimization, since it is rarely
     useful to check the full function body for unoptimized code.

     The first line of the expected output for a function FN has the
     form:

          PREFIX FN:  [{ target/xfail SELECTOR }]

     Subsequent lines of the expected output also start with PREFIX.  In
     both cases, whitespace after PREFIX is not significant.

     The test discards assembly directives such as '.cfi_startproc' and
     local label definitions such as '.LFB0' from the compiler's
     assembly output.  It then matches the result against the expected
     output for a function as a single regular expression.  This means
     that later lines can use backslashes to refer back to '(...)'
     captures on earlier lines.  For example:

          /* { dg-final { check-function-bodies "**" "" "-DCHECK_ASM" } } */
          ...
          /*
          ** add_w0_s8_m:
          **	mov	(z[0-9]+\.b), w0
          **	add	z0\.b, p0/m, z0\.b, \1
          **	ret
          */
          svint8_t add_w0_s8_m (...) { ... }
          ...
          /*
          ** add_b0_s8_m:
          **	mov	(z[0-9]+\.b), b0
          **	add	z1\.b, p0/m, z1\.b, \1
          **	ret
          */
          svint8_t add_b0_s8_m (...) { ... }

     checks whether the implementations of 'add_w0_s8_m' and
     'add_b0_s8_m' match the regular expressions given.  The test only
     runs when '-DCHECK_ASM' is passed on the command line.

     It is possible to create non-capturing multi-line regular
     expression groups of the form '(A|B|...)' by putting the '(', '|'
     and ')' on separate lines (each still using PREFIX).  For example:

          /*
          ** cmple_f16_tied:
          ** (
          **	fcmge	p0\.h, p0/z, z1\.h, z0\.h
          ** |
          **	fcmle	p0\.h, p0/z, z0\.h, z1\.h
          ** )
          **	ret
          */
          svbool_t cmple_f16_tied (...) { ... }

     checks whether 'cmple_f16_tied' is implemented by the 'fcmge'
     instruction followed by 'ret' or by the 'fcmle' instruction
     followed by 'ret'.  The test is still a single regular rexpression.

     A line containing just:

          PREFIX ...

     stands for zero or more unmatched lines; the whitespace after
     PREFIX is again not significant.

7.2.6.3 Scan optimization dump files
------------------------------------

These commands are available for KIND of 'tree', 'ltrans-tree',
'offload-tree', 'rtl', 'offload-rtl', 'ipa', and 'wpa-ipa'.

'scan-KIND-dump REGEX SUFFIX [{ target/xfail SELECTOR }]'
     Passes if REGEX matches text in the dump file with suffix SUFFIX.

'scan-KIND-dump-not REGEX SUFFIX [{ target/xfail SELECTOR }]'
     Passes if REGEX does not match text in the dump file with suffix
     SUFFIX.

'scan-KIND-dump-times REGEX NUM SUFFIX [{ target/xfail SELECTOR }]'
     Passes if REGEX is found exactly NUM times in the dump file with
     suffix SUFFIX.

'scan-KIND-dump-dem REGEX SUFFIX [{ target/xfail SELECTOR }]'
     Passes if REGEX matches demangled text in the dump file with suffix
     SUFFIX.

'scan-KIND-dump-dem-not REGEX SUFFIX [{ target/xfail SELECTOR }]'
     Passes if REGEX does not match demangled text in the dump file with
     suffix SUFFIX.

7.2.6.4 Check for output files
------------------------------

'output-exists [{ target/xfail SELECTOR }]'
     Passes if compiler output file exists.

'output-exists-not [{ target/xfail SELECTOR }]'
     Passes if compiler output file does not exist.

'scan-symbol REGEXP [{ target/xfail SELECTOR }]'
     Passes if the pattern is present in the final executable.

'scan-symbol-not REGEXP [{ target/xfail SELECTOR }]'
     Passes if the pattern is absent from the final executable.

7.2.6.5 Checks for 'gcov' tests
-------------------------------

'run-gcov SOURCEFILE'
     Check line counts in 'gcov' tests.

'run-gcov [branches] [calls] { OPTS SOURCEFILE }'
     Check branch and/or call counts, in addition to line counts, in
     'gcov' tests.

7.2.6.6 Clean up generated test files
-------------------------------------

Usually the test-framework removes files that were generated during
testing.  If a testcase, for example, uses any dumping mechanism to
inspect a passes dump file, the testsuite recognized the dump option
passed to the tool and schedules a final cleanup to remove these files.

 There are, however, following additional cleanup directives that can be
used to annotate a testcase "manually".
'cleanup-coverage-files'
     Removes coverage data files generated for this test.

'cleanup-modules "LIST-OF-EXTRA-MODULES"'
     Removes Fortran module files generated for this test, excluding the
     module names listed in keep-modules.  Cleaning up module files is
     usually done automatically by the testsuite by looking at the
     source files and removing the modules after the test has been
     executed.
          module MoD1
          end module MoD1
          module Mod2
          end module Mod2
          module moD3
          end module moD3
          module mod4
          end module mod4
          ! { dg-final { cleanup-modules "mod1 mod2" } } ! redundant
          ! { dg-final { keep-modules "mod3 mod4" } }

'keep-modules "LIST-OF-MODULES-NOT-TO-DELETE"'
     Whitespace separated list of module names that should not be
     deleted by cleanup-modules.  If the list of modules is empty, all
     modules defined in this file are kept.
          module maybe_unneeded
          end module maybe_unneeded
          module keep1
          end module keep1
          module keep2
          end module keep2
          ! { dg-final { keep-modules "keep1 keep2" } } ! just keep these two
          ! { dg-final { keep-modules "" } } ! keep all

'dg-keep-saved-temps "LIST-OF-SUFFIXES-NOT-TO-DELETE"'
     Whitespace separated list of suffixes that should not be deleted
     automatically in a testcase that uses '-save-temps'.
          // { dg-options "-save-temps -fpch-preprocess -I." }
          int main() { return 0; }
          // { dg-keep-saved-temps ".s" } ! just keep assembler file
          // { dg-keep-saved-temps ".s" ".i" } ! ... and .i
          // { dg-keep-saved-temps ".ii" ".o" } ! or just .ii and .o

'cleanup-profile-file'
     Removes profiling files generated for this test.

==============================================================================
File: gccint.info,  Node: |Ada_Tests|,  Next: |C_Tests|,  Prev: |Test_Directives|,  Up: |Testsuites|
==============================================================================

                                                                     *Ada_Tests*

7.3 Ada Language Testsuites
---------------------------

The Ada testsuite includes executable tests from the ACATS testsuite,
publicly available at <http://www.ada-auth.org/acats.html>.

 These tests are integrated in the GCC testsuite in the 'ada/acats'
directory, and enabled automatically when running 'make check', assuming
the Ada language has been enabled when configuring GCC.

 You can also run the Ada testsuite independently, using 'make
check-ada', or run a subset of the tests by specifying which chapter to
run, e.g.:

     $ make check-ada CHAPTERS="c3 c9"

 The tests are organized by directory, each directory corresponding to a
chapter of the Ada Reference Manual.  So for example, 'c9' corresponds
to chapter 9, which deals with tasking features of the language.

 The tests are run using two 'sh' scripts: 'run_acats' and 'run_all.sh'.
To run the tests using a simulator or a cross target, see the small
customization section at the top of 'run_all.sh'.

 These tests are run using the build tree: they can be run without doing
a 'make install'.

==============================================================================
File: gccint.info,  Node: |C_Tests|,  Next: |LTO_Testing|,  Prev: |Ada_Tests|,  Up: |Testsuites|
==============================================================================

                                                                       *C_Tests*

7.4 C Language Testsuites
-------------------------

GCC contains the following C language testsuites, in the 'gcc/testsuite'
directory:

'gcc.dg'
     This contains tests of particular features of the C compiler, using
     the more modern 'dg' harness.  Correctness tests for various
     compiler features should go here if possible.

     Magic comments determine whether the file is preprocessed,
     compiled, linked or run.  In these tests, error and warning message
     texts are compared against expected texts or regular expressions
     given in comments.  These tests are run with the options '-ansi
     -pedantic' unless other options are given in the test.  Except as
     noted below they are not run with multiple optimization options.
'gcc.dg/compat'
     This subdirectory contains tests for binary compatibility using
     'lib/compat.exp', which in turn uses the language-independent
     support (*note Support for testing binary compatibility: compat
     Testing.).
'gcc.dg/cpp'
     This subdirectory contains tests of the preprocessor.
'gcc.dg/debug'
     This subdirectory contains tests for debug formats.  Tests in this
     subdirectory are run for each debug format that the compiler
     supports.
'gcc.dg/format'
     This subdirectory contains tests of the '-Wformat' format checking.
     Tests in this directory are run with and without '-DWIDE'.
'gcc.dg/noncompile'
     This subdirectory contains tests of code that should not compile
     and does not need any special compilation options.  They are run
     with multiple optimization options, since sometimes invalid code
     crashes the compiler with optimization.
'gcc.dg/special'
     FIXME: describe this.

'gcc.c-torture'
     This contains particular code fragments which have historically
     broken easily.  These tests are run with multiple optimization
     options, so tests for features which only break at some
     optimization levels belong here.  This also contains tests to check
     that certain optimizations occur.  It might be worthwhile to
     separate the correctness tests cleanly from the code quality tests,
     but it hasn't been done yet.

'gcc.c-torture/compat'
     FIXME: describe this.

     This directory should probably not be used for new tests.
'gcc.c-torture/compile'
     This testsuite contains test cases that should compile, but do not
     need to link or run.  These test cases are compiled with several
     different combinations of optimization options.  All warnings are
     disabled for these test cases, so this directory is not suitable if
     you wish to test for the presence or absence of compiler warnings.
     While special options can be set, and tests disabled on specific
     platforms, by the use of '.x' files, mostly these test cases should
     not contain platform dependencies.  FIXME: discuss how defines such
     as 'STACK_SIZE' are used.
'gcc.c-torture/execute'
     This testsuite contains test cases that should compile, link and
     run; otherwise the same comments as for 'gcc.c-torture/compile'
     apply.
'gcc.c-torture/execute/ieee'
     This contains tests which are specific to IEEE floating point.
'gcc.c-torture/unsorted'
     FIXME: describe this.

     This directory should probably not be used for new tests.
'gcc.misc-tests'
     This directory contains C tests that require special handling.
     Some of these tests have individual expect files, and others share
     special-purpose expect files:

     'bprob*.c'
          Test '-fbranch-probabilities' using
          'gcc.misc-tests/bprob.exp', which in turn uses the generic,
          language-independent framework (*note Support for testing
          profile-directed optimizations: profopt Testing.).

     'gcov*.c'
          Test 'gcov' output using 'gcov.exp', which in turn uses the
          language-independent support (*note Support for testing gcov:
          gcov Testing.).

     'i386-pf-*.c'
          Test i386-specific support for data prefetch using
          'i386-prefetch.exp'.

'gcc.test-framework'
     'dg-*.c'
          Test the testsuite itself using
          'gcc.test-framework/test-framework.exp'.

 FIXME: merge in 'testsuite/README.gcc' and discuss the format of test
cases and magic comments more.

==============================================================================
File: gccint.info,  Node: |LTO_Testing|,  Next: |gcov_Testing|,  Prev: |C_Tests|,  Up: |Testsuites|
==============================================================================

                                                                   *LTO_Testing*

7.5 Support for testing link-time optimizations
-----------------------------------------------

Tests for link-time optimizations usually require multiple source files
that are compiled separately, perhaps with different sets of options.
There are several special-purpose test directives used for these tests.

'{ dg-lto-do DO-WHAT-KEYWORD }'
     DO-WHAT-KEYWORD specifies how the test is compiled and whether it
     is executed.  It is one of:

     'assemble'
          Compile with '-c' to produce a relocatable object file.
     'link'
          Compile, assemble, and link to produce an executable file.
     'run'
          Produce and run an executable file, which is expected to
          return an exit code of 0.

     The default is 'assemble'.  That can be overridden for a set of
     tests by redefining 'dg-do-what-default' within the '.exp' file for
     those tests.

     Unlike 'dg-do', 'dg-lto-do' does not support an optional 'target'
     or 'xfail' list.  Use 'dg-skip-if', 'dg-xfail-if', or
     'dg-xfail-run-if'.

'{ dg-lto-options { { OPTIONS } [{ OPTIONS }] } [{ target SELECTOR }]}'
     This directive provides a list of one or more sets of compiler
     options to override LTO_OPTIONS.  Each test will be compiled and
     run with each of these sets of options.

'{ dg-extra-ld-options OPTIONS [{ target SELECTOR }]}'
     This directive adds OPTIONS to the linker options used.

'{ dg-suppress-ld-options OPTIONS [{ target SELECTOR }]}'
     This directive removes OPTIONS from the set of linker options used.

==============================================================================
File: gccint.info,  Node: |gcov_Testing|,  Next: |profopt_Testing|,  Prev: |LTO_Testing|,  Up: |Testsuites|
==============================================================================

                                                                  *gcov_Testing*

7.6 Support for testing 'gcov'
------------------------------

Language-independent support for testing 'gcov', and for checking that
branch profiling produces expected values, is provided by the expect
file 'lib/gcov.exp'.  'gcov' tests also rely on procedures in
'lib/gcc-dg.exp' to compile and run the test program.  A typical 'gcov'
test contains the following DejaGnu commands within comments:

     { dg-options "--coverage" }
     { dg-do run { target native } }
     { dg-final { run-gcov sourcefile } }

 Checks of 'gcov' output can include line counts, branch percentages,
and call return percentages.  All of these checks are requested via
commands that appear in comments in the test's source file.  Commands to
check line counts are processed by default.  Commands to check branch
percentages and call return percentages are processed if the 'run-gcov'
command has arguments 'branches' or 'calls', respectively.  For example,
the following specifies checking both, as well as passing '-b' to
'gcov':

     { dg-final { run-gcov branches calls { -b sourcefile } } }

 A line count command appears within a comment on the source line that
is expected to get the specified count and has the form 'count(CNT)'.  A
test should only check line counts for lines that will get the same
count for any architecture.

 Commands to check branch percentages ('branch') and call return
percentages ('returns') are very similar to each other.  A beginning
command appears on or before the first of a range of lines that will
report the percentage, and the ending command follows that range of
lines.  The beginning command can include a list of percentages, all of
which are expected to be found within the range.  A range is terminated
by the next command of the same kind.  A command 'branch(end)' or
'returns(end)' marks the end of a range without starting a new one.  For
example:

     if (i > 10 && j > i && j < 20)  /* branch(27 50 75) */
                                     /* branch(end) */
       foo (i, j);

 For a call return percentage, the value specified is the percentage of
calls reported to return.  For a branch percentage, the value is either
the expected percentage or 100 minus that value, since the direction of
a branch can differ depending on the target or the optimization level.

 Not all branches and calls need to be checked.  A test should not check
for branches that might be optimized away or replaced with predicated
instructions.  Don't check for calls inserted by the compiler or ones
that might be inlined or optimized away.

 A single test can check for combinations of line counts, branch
percentages, and call return percentages.  The command to check a line
count must appear on the line that will report that count, but commands
to check branch percentages and call return percentages can bracket the
lines that report them.

==============================================================================
File: gccint.info,  Node: |profopt_Testing|,  Next: |compat_Testing|,  Prev: |gcov_Testing|,  Up: |Testsuites|
==============================================================================

                                                               *profopt_Testing*

7.7 Support for testing profile-directed optimizations
------------------------------------------------------

The file 'profopt.exp' provides language-independent support for
checking correct execution of a test built with profile-directed
optimization.  This testing requires that a test program be built and
executed twice.  The first time it is compiled to generate profile data,
and the second time it is compiled to use the data that was generated
during the first execution.  The second execution is to verify that the
test produces the expected results.

 To check that the optimization actually generated better code, a test
can be built and run a third time with normal optimizations to verify
that the performance is better with the profile-directed optimizations.
'profopt.exp' has the beginnings of this kind of support.

 'profopt.exp' provides generic support for profile-directed
optimizations.  Each set of tests that uses it provides information
about a specific optimization:

'tool'
     tool being tested, e.g., 'gcc'

'profile_option'
     options used to generate profile data

'feedback_option'
     options used to optimize using that profile data

'prof_ext'
     suffix of profile data files

'PROFOPT_OPTIONS'
     list of options with which to run each test, similar to the lists
     for torture tests

'{ dg-final-generate { LOCAL-DIRECTIVE } }'
     This directive is similar to 'dg-final', but the LOCAL-DIRECTIVE is
     run after the generation of profile data.

'{ dg-final-use { LOCAL-DIRECTIVE } }'
     The LOCAL-DIRECTIVE is run after the profile data have been used.

==============================================================================
File: gccint.info,  Node: |compat_Testing|,  Next: |Torture_Tests|,  Prev: |profopt_Testing|,  Up: |Testsuites|
==============================================================================

                                                                *compat_Testing*

7.8 Support for testing binary compatibility
--------------------------------------------

The file 'compat.exp' provides language-independent support for binary
compatibility testing.  It supports testing interoperability of two
compilers that follow the same ABI, or of multiple sets of compiler
options that should not affect binary compatibility.  It is intended to
be used for testsuites that complement ABI testsuites.

 A test supported by this framework has three parts, each in a separate
source file: a main program and two pieces that interact with each other
to split up the functionality being tested.

'TESTNAME_main.SUFFIX'
     Contains the main program, which calls a function in file
     'TESTNAME_x.SUFFIX'.

'TESTNAME_x.SUFFIX'
     Contains at least one call to a function in 'TESTNAME_y.SUFFIX'.

'TESTNAME_y.SUFFIX'
     Shares data with, or gets arguments from, 'TESTNAME_x.SUFFIX'.

 Within each test, the main program and one functional piece are
compiled by the GCC under test.  The other piece can be compiled by an
alternate compiler.  If no alternate compiler is specified, then all
three source files are all compiled by the GCC under test.  You can
specify pairs of sets of compiler options.  The first element of such a
pair specifies options used with the GCC under test, and the second
element of the pair specifies options used with the alternate compiler.
Each test is compiled with each pair of options.

 'compat.exp' defines default pairs of compiler options.  These can be
overridden by defining the environment variable 'COMPAT_OPTIONS' as:

     COMPAT_OPTIONS="[list [list {TST1} {ALT1}]
       ...[list {TSTN} {ALTN}]]"

 where TSTI and ALTI are lists of options, with TSTI used by the
compiler under test and ALTI used by the alternate compiler.  For
example, with '[list [list {-g -O0} {-O3}] [list {-fpic} {-fPIC -O2}]]',
the test is first built with '-g -O0' by the compiler under test and
with '-O3' by the alternate compiler.  The test is built a second time
using '-fpic' by the compiler under test and '-fPIC -O2' by the
alternate compiler.

 An alternate compiler is specified by defining an environment variable
to be the full pathname of an installed compiler; for C define
'ALT_CC_UNDER_TEST', and for C++ define 'ALT_CXX_UNDER_TEST'.  These
will be written to the 'site.exp' file used by DejaGnu.  The default is
to build each test with the compiler under test using the first of each
pair of compiler options from 'COMPAT_OPTIONS'.  When
'ALT_CC_UNDER_TEST' or 'ALT_CXX_UNDER_TEST' is 'same', each test is
built using the compiler under test but with combinations of the options
from 'COMPAT_OPTIONS'.

 To run only the C++ compatibility suite using the compiler under test
and another version of GCC using specific compiler options, do the
following from 'OBJDIR/gcc':

     rm site.exp
     make -k \
       ALT_CXX_UNDER_TEST=${alt_prefix}/bin/g++ \
       COMPAT_OPTIONS="LISTS AS SHOWN ABOVE" \
       check-c++ \
       RUNTESTFLAGS="compat.exp"

 A test that fails when the source files are compiled with different
compilers, but passes when the files are compiled with the same
compiler, demonstrates incompatibility of the generated code or runtime
support.  A test that fails for the alternate compiler but passes for
the compiler under test probably tests for a bug that was fixed in the
compiler under test but is present in the alternate compiler.

 The binary compatibility tests support a small number of test framework
commands that appear within comments in a test file.

'dg-require-*'
     These commands can be used in 'TESTNAME_main.SUFFIX' to skip the
     test if specific support is not available on the target.

'dg-options'
     The specified options are used for compiling this particular source
     file, appended to the options from 'COMPAT_OPTIONS'.  When this
     command appears in 'TESTNAME_main.SUFFIX' the options are also used
     to link the test program.

'dg-xfail-if'
     This command can be used in a secondary source file to specify that
     compilation is expected to fail for particular options on
     particular targets.

==============================================================================
File: gccint.info,  Node: |Torture_Tests|,  Next: |GIMPLE_Tests|,  Prev: |compat_Testing|,  Up: |Testsuites|
==============================================================================

                                                                 *Torture_Tests*

7.9 Support for torture testing using multiple options
------------------------------------------------------

Throughout the compiler testsuite there are several directories whose
tests are run multiple times, each with a different set of options.
These are known as torture tests.  'lib/torture-options.exp' defines
procedures to set up these lists:

'torture-init'
     Initialize use of torture lists.
'set-torture-options'
     Set lists of torture options to use for tests with and without
     loops.  Optionally combine a set of torture options with a set of
     other options, as is done with Objective-C runtime options.
'torture-finish'
     Finalize use of torture lists.

 The '.exp' file for a set of tests that use torture options must
include calls to these three procedures if:

   * It calls 'gcc-dg-runtest' and overrides DG_TORTURE_OPTIONS.

   * It calls ${TOOL}'-torture' or ${TOOL}'-torture-execute', where TOOL
     is 'c', 'fortran', or 'objc'.

   * It calls 'dg-pch'.

 It is not necessary for a '.exp' file that calls 'gcc-dg-runtest' to
call the torture procedures if the tests should use the list in
DG_TORTURE_OPTIONS defined in 'gcc-dg.exp'.

 Most uses of torture options can override the default lists by defining
TORTURE_OPTIONS or add to the default list by defining
ADDITIONAL_TORTURE_OPTIONS.  Define these in a '.dejagnurc' file or add
them to the 'site.exp' file; for example

     set ADDITIONAL_TORTURE_OPTIONS  [list \
       { -O2 -ftree-loop-linear } \
       { -O2 -fpeel-loops } ]

==============================================================================
File: gccint.info,  Node: |GIMPLE_Tests|,  Next: |RTL_Tests|,  Prev: |Torture_Tests|,  Up: |Testsuites|
==============================================================================

                                                                  *GIMPLE_Tests*

7.10 Support for testing GIMPLE passes
--------------------------------------

As of gcc 7, C functions can be tagged with '__GIMPLE' to indicate that
the function body will be GIMPLE, rather than C. The compiler requires
the option '-fgimple' to enable this functionality.  For example:

     /* { dg-do compile } */
     /* { dg-options "-O -fgimple" } */

     void __GIMPLE (startwith ("dse2")) foo ()
     {
       int a;

     bb_2:
       if (a > 4)
         goto bb_3;
       else
         goto bb_4;

     bb_3:
       a_2 = 10;
       goto bb_5;

     bb_4:
       a_3 = 20;

     bb_5:
       a_1 = __PHI (bb_3: a_2, bb_4: a_3);
       a_4 = a_1 + 4;

       return;
     }

 The 'startwith' argument indicates at which pass to begin.

 Use the dump modifier '-gimple' (e.g. '-fdump-tree-all-gimple') to make
tree dumps more closely follow the format accepted by the GIMPLE parser.

 Example DejaGnu tests of GIMPLE can be seen in the source tree at
'gcc/testsuite/gcc.dg/gimplefe-*.c'.

 The '__GIMPLE' parser is integrated with the C tokenizer and
preprocessor, so it should be possible to use macros to build out test
coverage.

==============================================================================
File: gccint.info,  Node: |RTL_Tests|,  Prev: |GIMPLE_Tests|,  Up: |Testsuites|
==============================================================================

                                                                     *RTL_Tests*

7.11 Support for testing RTL passes
-----------------------------------

As of gcc 7, C functions can be tagged with '__RTL' to indicate that the
function body will be RTL, rather than C. For example:

     double __RTL (startwith ("ira")) test (struct foo *f, const struct bar *b)
     {
       (function "test"
          [...snip; various directives go in here...]
       ) ;; function "test"
     }

 The 'startwith' argument indicates at which pass to begin.

 The parser expects the RTL body to be in the format emitted by this
dumping function:

     DEBUG_FUNCTION void
     print_rtx_function (FILE *outfile, function *fn, bool compact);

 when "compact" is true.  So you can capture RTL in the correct format
from the debugger using:

     (gdb) print_rtx_function (stderr, cfun, true);

 and copy and paste the output into the body of the C function.

 Example DejaGnu tests of RTL can be seen in the source tree under
'gcc/testsuite/gcc.dg/rtl'.

 The '__RTL' parser is not integrated with the C tokenizer or
preprocessor, and works simply by reading the relevant lines within the
braces.  In particular, the RTL body must be on separate lines from the
enclosing braces, and the preprocessor is not usable within it.

==============================================================================
File: gccint.info,  Node: |Options|,  Next: |Passes|,  Prev: |Testsuites|,  Up: |Top|
==============================================================================

                                                                       *Options*

8 Option specification files
============================

Most GCC command-line options are described by special option definition
files, the names of which conventionally end in '.opt'.  This chapter
describes the format of these files.

MENU

* |Option_file_format|::   The general layout of the files
* |Option_properties|::    Supported option properties

==============================================================================
File: gccint.info,  Node: |Option_file_format|,  Next: |Option_properties|,  Up: |Options|
==============================================================================

                                                            *Option_file_format*

8.1 Option file format
----------------------

Option files are a simple list of records in which each field occupies
its own line and in which the records themselves are separated by blank
lines.  Comments may appear on their own line anywhere within the file
and are preceded by semicolons.  Whitespace is allowed before the
semicolon.

 The files can contain the following types of record:

   * A language definition record.  These records have two fields: the
     string 'Language' and the name of the language.  Once a language
     has been declared in this way, it can be used as an option
     property.  *Note Option properties::.

   * A target specific save record to save additional information.
     These records have two fields: the string 'TargetSave', and a
     declaration type to go in the 'cl_target_option' structure.

   * A variable record to define a variable used to store option
     information.  These records have two fields: the string 'Variable',
     and a declaration of the type and name of the variable, optionally
     with an initializer (but without any trailing ';').  These records
     may be used for variables used for many options where declaring the
     initializer in a single option definition record, or duplicating it
     in many records, would be inappropriate, or for variables set in
     option handlers rather than referenced by 'Var' properties.

   * A variable record to define a variable used to store option
     information.  These records have two fields: the string
     'TargetVariable', and a declaration of the type and name of the
     variable, optionally with an initializer (but without any trailing
     ';').  'TargetVariable' is a combination of 'Variable' and
     'TargetSave' records in that the variable is defined in the
     'gcc_options' structure, but these variables are also stored in the
     'cl_target_option' structure.  The variables are saved in the
     target save code and restored in the target restore code.

   * A variable record to record any additional files that the
     'options.h' file should include.  This is useful to provide
     enumeration or structure definitions needed for target variables.
     These records have two fields: the string 'HeaderInclude' and the
     name of the include file.

   * A variable record to record any additional files that the
     'options.c' or 'options-save.c' file should include.  This is
     useful to provide inline functions needed for target variables
     and/or '#ifdef' sequences to properly set up the initialization.
     These records have two fields: the string 'SourceInclude' and the
     name of the include file.

   * An enumeration record to define a set of strings that may be used
     as arguments to an option or options.  These records have three
     fields: the string 'Enum', a space-separated list of properties and
     help text used to describe the set of strings in '--help' output.
     Properties use the same format as option properties; the following
     are valid:
     'Name(NAME)'
          This property is required; NAME must be a name (suitable for
          use in C identifiers) used to identify the set of strings in
          'Enum' option properties.

     'Type(TYPE)'
          This property is required; TYPE is the C type for variables
          set by options using this enumeration together with 'Var'.

     'UnknownError(MESSAGE)'
          The message MESSAGE will be used as an error message if the
          argument is invalid; for enumerations without 'UnknownError',
          a generic error message is used.  MESSAGE should contain a
          single '%qs' format, which will be used to format the invalid
          argument.

   * An enumeration value record to define one of the strings in a set
     given in an 'Enum' record.  These records have two fields: the
     string 'EnumValue' and a space-separated list of properties.
     Properties use the same format as option properties; the following
     are valid:
     'Enum(NAME)'
          This property is required; NAME says which 'Enum' record this
          'EnumValue' record corresponds to.

     'String(STRING)'
          This property is required; STRING is the string option
          argument being described by this record.

     'Value(VALUE)'
          This property is required; it says what value (representable
          as 'int') should be used for the given string.

     'Canonical'
          This property is optional.  If present, it says the present
          string is the canonical one among all those with the given
          value.  Other strings yielding that value will be mapped to
          this one so specs do not need to handle them.

     'DriverOnly'
          This property is optional.  If present, the present string
          will only be accepted by the driver.  This is used for cases
          such as '-march=native' that are processed by the driver so
          that 'gcc -v' shows how the options chosen depended on the
          system on which the compiler was run.

   * An option definition record.  These records have the following
     fields:
       1. the name of the option, with the leading "-" removed
       2. a space-separated list of option properties (*note Option
          properties::)
       3. the help text to use for '--help' (omitted if the second field
          contains the 'Undocumented' property).

     By default, all options beginning with "f", "W" or "m" are
     implicitly assumed to take a "no-" form.  This form should not be
     listed separately.  If an option beginning with one of these
     letters does not have a "no-" form, you can use the
     'RejectNegative' property to reject it.

     The help text is automatically line-wrapped before being displayed.
     Normally the name of the option is printed on the left-hand side of
     the output and the help text is printed on the right.  However, if
     the help text contains a tab character, the text to the left of the
     tab is used instead of the option's name and the text to the right
     of the tab forms the help text.  This allows you to elaborate on
     what type of argument the option takes.

   * A target mask record.  These records have one field of the form
     'Mask(X)'.  The options-processing script will automatically
     allocate a bit in 'target_flags' (*note Run-time Target::) for each
     mask name X and set the macro 'MASK_X' to the appropriate bitmask.
     It will also declare a 'TARGET_X' macro that has the value 1 when
     bit 'MASK_X' is set and 0 otherwise.

     They are primarily intended to declare target masks that are not
     associated with user options, either because these masks represent
     internal switches or because the options are not available on all
     configurations and yet the masks always need to be defined.

==============================================================================
File: gccint.info,  Node: |Option_properties|,  Prev: |Option_file_format|,  Up: |Options|
==============================================================================

                                                             *Option_properties*

8.2 Option properties
---------------------

The second field of an option record can specify any of the following
properties.  When an option takes an argument, it is enclosed in
parentheses following the option property name.  The parser that handles
option files is quite simplistic, and will be tricked by any nested
parentheses within the argument text itself; in this case, the entire
option argument can be wrapped in curly braces within the parentheses to
demarcate it, e.g.:

     Condition({defined (USE_CYGWIN_LIBSTDCXX_WRAPPERS)})

'Common'
     The option is available for all languages and targets.

'Target'
     The option is available for all languages but is target-specific.

'Driver'
     The option is handled by the compiler driver using code not shared
     with the compilers proper ('cc1' etc.).

'LANGUAGE'
     The option is available when compiling for the given language.

     It is possible to specify several different languages for the same
     option.  Each LANGUAGE must have been declared by an earlier
     'Language' record.  *Note Option file format::.

'RejectDriver'
     The option is only handled by the compilers proper ('cc1' etc.) and
     should not be accepted by the driver.

'RejectNegative'
     The option does not have a "no-" form.  All options beginning with
     "f", "W" or "m" are assumed to have a "no-" form unless this
     property is used.

'Negative(OTHERNAME)'
     The option will turn off another option OTHERNAME, which is the
     option name with the leading "-" removed.  This chain action will
     propagate through the 'Negative' property of the option to be
     turned off.  The driver will prune options, removing those that are
     turned off by some later option.  This pruning is not done for
     options with 'Joined' or 'JoinedOrMissing' properties, unless the
     options have either 'RejectNegative' property or the 'Negative'
     property mentions an option other than itself.

     As a consequence, if you have a group of mutually-exclusive
     options, their 'Negative' properties should form a circular chain.
     For example, if options '-A', '-B' and '-C' are mutually exclusive,
     their respective 'Negative' properties should be 'Negative(B)',
     'Negative(C)' and 'Negative(A)'.

'Joined'
'Separate'
     The option takes a mandatory argument.  'Joined' indicates that the
     option and argument can be included in the same 'argv' entry (as
     with '-mflush-func=NAME', for example).  'Separate' indicates that
     the option and argument can be separate 'argv' entries (as with
     '-o').  An option is allowed to have both of these properties.

'JoinedOrMissing'
     The option takes an optional argument.  If the argument is given,
     it will be part of the same 'argv' entry as the option itself.

     This property cannot be used alongside 'Joined' or 'Separate'.

'MissingArgError(MESSAGE)'
     For an option marked 'Joined' or 'Separate', the message MESSAGE
     will be used as an error message if the mandatory argument is
     missing; for options without 'MissingArgError', a generic error
     message is used.  MESSAGE should contain a single '%qs' format,
     which will be used to format the name of the option passed.

'Args(N)'
     For an option marked 'Separate', indicate that it takes N
     arguments.  The default is 1.

'UInteger'
     The option's argument is a non-negative integer consisting of
     either decimal or hexadecimal digits interpreted as 'int'.
     Hexadecimal integers may optionally start with the '0x' or '0X'
     prefix.  The option parser validates and converts the argument
     before passing it to the relevant option handler.  'UInteger'
     should also be used with options like '-falign-loops' where both
     '-falign-loops' and '-falign-loops'=N are supported to make sure
     the saved options are given a full integer.  Positive values of the
     argument in excess of 'INT_MAX' wrap around zero.

'Host_Wide_Int'
     The option's argument is a non-negative integer consisting of
     either decimal or hexadecimal digits interpreted as the widest
     integer type on the host.  As with an 'UInteger' argument,
     hexadecimal integers may optionally start with the '0x' or '0X'
     prefix.  The option parser validates and converts the argument
     before passing it to the relevant option handler.  'Host_Wide_Int'
     should be used with options that need to accept very large values.
     Positive values of the argument in excess of 'HOST_WIDE_INT_M1U'
     are assigned 'HOST_WIDE_INT_M1U'.

'IntegerRange(N, M)'
     The options's arguments are integers of type 'int'.  The option's
     parser validates that the value of an option integer argument is
     within the closed range [N, M].

'ByteSize'
     A property applicable only to 'UInteger' or 'Host_Wide_Int'
     arguments.  The option's integer argument is interpreted as if in
     infinite precision using saturation arithmetic in the corresponding
     type.  The argument may be followed by a 'byte-size' suffix
     designating a multiple of bytes such as 'kB' and 'KiB' for kilobyte
     and kibibyte, respectively, 'MB' and 'MiB' for megabyte and
     mebibyte, 'GB' and 'GiB' for gigabyte and gigibyte, and so on.
     'ByteSize' should be used for with options that take a very large
     argument representing a size in bytes, such as '-Wlarger-than='.

'ToLower'
     The option's argument should be converted to lowercase as part of
     putting it in canonical form, and before comparing with the strings
     indicated by any 'Enum' property.

'NoDriverArg'
     For an option marked 'Separate', the option only takes an argument
     in the compiler proper, not in the driver.  This is for
     compatibility with existing options that are used both directly and
     via '-Wp,'; new options should not have this property.

'Var(VAR)'
     The state of this option should be stored in variable VAR (actually
     a macro for 'global_options.x_VAR').  The way that the state is
     stored depends on the type of option:

'WarnRemoved'
     The option is removed and every usage of such option will result in
     a warning.  We use it option backward compatibility.

'Var(VAR, SET)'
     The option controls an integer variable VAR and is active when VAR
     equals SET.  The option parser will set VAR to SET when the
     positive form of the option is used and '!SET' when the "no-" form
     is used.

     VAR is declared in the same way as for the single-argument form
     described above.

        * If the option uses the 'Mask' or 'InverseMask' properties, VAR
          is the integer variable that contains the mask.

        * If the option is a normal on/off switch, VAR is an integer
          variable that is nonzero when the option is enabled.  The
          options parser will set the variable to 1 when the positive
          form of the option is used and 0 when the "no-" form is used.

        * If the option takes an argument and has the 'UInteger'
          property, VAR is an integer variable that stores the value of
          the argument.

        * If the option takes an argument and has the 'Enum' property,
          VAR is a variable (type given in the 'Type' property of the
          'Enum' record whose 'Name' property has the same argument as
          the 'Enum' property of this option) that stores the value of
          the argument.

        * If the option has the 'Defer' property, VAR is a pointer to a
          'VEC(cl_deferred_option,heap)' that stores the option for
          later processing.  (VAR is declared with type 'void *' and
          needs to be cast to 'VEC(cl_deferred_option,heap)' before
          use.)

        * Otherwise, if the option takes an argument, VAR is a pointer
          to the argument string.  The pointer will be null if the
          argument is optional and wasn't given.

     The option-processing script will usually zero-initialize VAR.  You
     can modify this behavior using 'Init'.

'Init(VALUE)'
     The variable specified by the 'Var' property should be statically
     initialized to VALUE.  If more than one option using the same
     variable specifies 'Init', all must specify the same initializer.

'Mask(NAME)'
     The option is associated with a bit in the 'target_flags' variable
     (*note Run-time Target::) and is active when that bit is set.  You
     may also specify 'Var' to select a variable other than
     'target_flags'.

     The options-processing script will automatically allocate a unique
     bit for the option.  If the option is attached to 'target_flags',
     the script will set the macro 'MASK_NAME' to the appropriate
     bitmask.  It will also declare a 'TARGET_NAME' macro that has the
     value 1 when the option is active and 0 otherwise.  If you use
     'Var' to attach the option to a different variable, the bitmask
     macro with be called 'OPTION_MASK_NAME'.

'InverseMask(OTHERNAME)'
'InverseMask(OTHERNAME, THISNAME)'
     The option is the inverse of another option that has the
     'Mask(OTHERNAME)' property.  If THISNAME is given, the
     options-processing script will declare a 'TARGET_THISNAME' macro
     that is 1 when the option is active and 0 otherwise.

'Enum(NAME)'
     The option's argument is a string from the set of strings
     associated with the corresponding 'Enum' record.  The string is
     checked and converted to the integer specified in the corresponding
     'EnumValue' record before being passed to option handlers.

'Defer'
     The option should be stored in a vector, specified with 'Var', for
     later processing.

'Alias(OPT)'
'Alias(OPT, ARG)'
'Alias(OPT, POSARG, NEGARG)'
     The option is an alias for '-OPT' (or the negative form of that
     option, depending on 'NegativeAlias').  In the first form, any
     argument passed to the alias is considered to be passed to '-OPT',
     and '-OPT' is considered to be negated if the alias is used in
     negated form.  In the second form, the alias may not be negated or
     have an argument, and POSARG is considered to be passed as an
     argument to '-OPT'.  In the third form, the alias may not have an
     argument, if the alias is used in the positive form then POSARG is
     considered to be passed to '-OPT', and if the alias is used in the
     negative form then NEGARG is considered to be passed to '-OPT'.

     Aliases should not specify 'Var' or 'Mask' or 'UInteger'.  Aliases
     should normally specify the same languages as the target of the
     alias; the flags on the target will be used to determine any
     diagnostic for use of an option for the wrong language, while those
     on the alias will be used to identify what command-line text is the
     option and what text is any argument to that option.

     When an 'Alias' definition is used for an option, driver specs do
     not need to handle it and no 'OPT_' enumeration value is defined
     for it; only the canonical form of the option will be seen in those
     places.

'NegativeAlias'
     For an option marked with 'Alias(OPT)', the option is considered to
     be an alias for the positive form of '-OPT' if negated and for the
     negative form of '-OPT' if not negated.  'NegativeAlias' may not be
     used with the forms of 'Alias' taking more than one argument.

'Ignore'
     This option is ignored apart from printing any warning specified
     using 'Warn'.  The option will not be seen by specs and no 'OPT_'
     enumeration value is defined for it.

'SeparateAlias'
     For an option marked with 'Joined', 'Separate' and 'Alias', the
     option only acts as an alias when passed a separate argument; with
     a joined argument it acts as a normal option, with an 'OPT_'
     enumeration value.  This is for compatibility with the Java '-d'
     option and should not be used for new options.

'Warn(MESSAGE)'
     If this option is used, output the warning MESSAGE.  MESSAGE is a
     format string, either taking a single operand with a '%qs' format
     which is the option name, or not taking any operands, which is
     passed to the 'warning' function.  If an alias is marked 'Warn',
     the target of the alias must not also be marked 'Warn'.

'Report'
     The state of the option should be printed by '-fverbose-asm'.

'Warning'
     This is a warning option and should be shown as such in '--help'
     output.  This flag does not currently affect anything other than
     '--help'.

'Optimization'
     This is an optimization option.  It should be shown as such in
     '--help' output, and any associated variable named using 'Var'
     should be saved and restored when the optimization level is changed
     with 'optimize' attributes.

'PerFunction'
     This is an option that can be overridden on a per-function basis.
     'Optimization' implies 'PerFunction', but options that do not
     affect executable code generation may use this flag instead, so
     that the option is not taken into account in ways that might affect
     executable code generation.

'Param'
     This is an option that is a parameter.

'Undocumented'
     The option is deliberately missing documentation and should not be
     included in the '--help' output.

'Condition(COND)'
     The option should only be accepted if preprocessor condition COND
     is true.  Note that any C declarations associated with the option
     will be present even if COND is false; COND simply controls whether
     the option is accepted and whether it is printed in the '--help'
     output.

'Save'
     Build the 'cl_target_option' structure to hold a copy of the
     option, add the functions 'cl_target_option_save' and
     'cl_target_option_restore' to save and restore the options.

'SetByCombined'
     The option may also be set by a combined option such as
     '-ffast-math'.  This causes the 'gcc_options' struct to have a
     field 'frontend_set_NAME', where 'NAME' is the name of the field
     holding the value of this option (without the leading 'x_').  This
     gives the front end a way to indicate that the value has been set
     explicitly and should not be changed by the combined option.  For
     example, some front ends use this to prevent '-ffast-math' and
     '-fno-fast-math' from changing the value of '-fmath-errno' for
     languages that do not use 'errno'.

'EnabledBy(OPT)'
'EnabledBy(OPT || OPT2)'
'EnabledBy(OPT && OPT2)'
     If not explicitly set, the option is set to the value of '-OPT';
     multiple options can be given, separated by '||'.  The third form
     using '&&' specifies that the option is only set if both OPT and
     OPT2 are set.  The options OPT and OPT2 must have the 'Common'
     property; otherwise, use 'LangEnabledBy'.

'LangEnabledBy(LANGUAGE, OPT)'
'LangEnabledBy(LANGUAGE, OPT, POSARG, NEGARG)'
     When compiling for the given language, the option is set to the
     value of '-OPT', if not explicitly set.  OPT can be also a list of
     '||' separated options.  In the second form, if OPT is used in the
     positive form then POSARG is considered to be passed to the option,
     and if OPT is used in the negative form then NEGARG is considered
     to be passed to the option.  It is possible to specify several
     different languages.  Each LANGUAGE must have been declared by an
     earlier 'Language' record.  *Note Option file format::.

'NoDWARFRecord'
     The option is omitted from the producer string written by
     '-grecord-gcc-switches'.

'PchIgnore'
     Even if this is a target option, this option will not be recorded /
     compared to determine if a precompiled header file matches.

'CPP(VAR)'
     The state of this option should be kept in sync with the
     preprocessor option VAR.  If this property is set, then properties
     'Var' and 'Init' must be set as well.

'CppReason(CPP_W_ENUM)'
     This warning option corresponds to 'cpplib.h' warning reason code
     CPP_W_ENUM.  This should only be used for warning options of the
     C-family front-ends.

==============================================================================
File: gccint.info,  Node: |Passes|,  Next: |poly_int|,  Prev: |Options|,  Up: |Top|
==============================================================================

                                                                        *Passes*

9 Passes and Files of the Compiler
==================================

This chapter is dedicated to giving an overview of the optimization and
code generation passes of the compiler.  In the process, it describes
some of the language front end interface, though this description is no
where near complete.

MENU

* |Parsing_pass|::         The language front end turns text into bits.
* |Gimplification_pass|::  The bits are turned into something we can optimize.
* |Pass_manager|::         Sequencing the optimization passes.
* |IPA_passes|::           Inter-procedural optimizations.
* |Tree_SSA_passes|::      Optimizations on a high-level representation.
* |RTL_passes|::           Optimizations on a low-level representation.
* |Optimization_info|::    Dumping optimization information from passes.

==============================================================================
File: gccint.info,  Node: |Parsing_pass|,  Next: |Gimplification_pass|,  Up: |Passes|
==============================================================================

                                                                  *Parsing_pass*

9.1 Parsing pass
----------------

The language front end is invoked only once, via
'lang_hooks.parse_file', to parse the entire input.  The language front
end may use any intermediate language representation deemed appropriate.
The C front end uses GENERIC trees (*note GENERIC::), plus a double
handful of language specific tree codes defined in 'c-common.def'.  The
Fortran front end uses a completely different private representation.

 At some point the front end must translate the representation used in
the front end to a representation understood by the language-independent
portions of the compiler.  Current practice takes one of two forms.  The
C front end manually invokes the gimplifier (*note GIMPLE::) on each
function, and uses the gimplifier callbacks to convert the
language-specific tree nodes directly to GIMPLE before passing the
function off to be compiled.  The Fortran front end converts from a
private representation to GENERIC, which is later lowered to GIMPLE when
the function is compiled.  Which route to choose probably depends on how
well GENERIC (plus extensions) can be made to match up with the source
language and necessary parsing data structures.

 BUG: Gimplification must occur before nested function lowering, and
nested function lowering must be done by the front end before passing
the data off to cgraph.

 TODO: Cgraph should control nested function lowering.  It would only be
invoked when it is certain that the outer-most function is used.

 TODO: Cgraph needs a gimplify_function callback.  It should be invoked
when (1) it is certain that the function is used, (2) warning flags
specified by the user require some amount of compilation in order to
honor, (3) the language indicates that semantic analysis is not complete
until gimplification occurs.  Hum... this sounds overly complicated.
Perhaps we should just have the front end gimplify always; in most cases
it's only one function call.

 The front end needs to pass all function definitions and top level
declarations off to the middle-end so that they can be compiled and
emitted to the object file.  For a simple procedural language, it is
usually most convenient to do this as each top level declaration or
definition is seen.  There is also a distinction to be made between
generating functional code and generating complete debug information.
The only thing that is absolutely required for functional code is that
function and data _definitions_ be passed to the middle-end.  For
complete debug information, function, data and type declarations should
all be passed as well.

 In any case, the front end needs each complete top-level function or
data declaration, and each data definition should be passed to
'rest_of_decl_compilation'.  Each complete type definition should be
passed to 'rest_of_type_compilation'.  Each function definition should
be passed to 'cgraph_finalize_function'.

 TODO: I know rest_of_compilation currently has all sorts of RTL
generation semantics.  I plan to move all code generation bits (both
Tree and RTL) to compile_function.  Should we hide cgraph from the front
ends and move back to rest_of_compilation as the official interface?
Possibly we should rename all three interfaces such that the names match
in some meaningful way and that is more descriptive than "rest_of".

 The middle-end will, at its option, emit the function and data
definitions immediately or queue them for later processing.

==============================================================================
File: gccint.info,  Node: |Gimplification_pass|,  Next: |Pass_manager|,  Prev: |Parsing_pass|,  Up: |Passes|
==============================================================================

                                                           *Gimplification_pass*

9.2 Gimplification pass
-----------------------

"Gimplification" is a whimsical term for the process of converting the
intermediate representation of a function into the GIMPLE language
(*note GIMPLE::).  The term stuck, and so words like "gimplification",
"gimplify", "gimplifier" and the like are sprinkled throughout this
section of code.

 While a front end may certainly choose to generate GIMPLE directly if
it chooses, this can be a moderately complex process unless the
intermediate language used by the front end is already fairly simple.
Usually it is easier to generate GENERIC trees plus extensions and let
the language-independent gimplifier do most of the work.

 The main entry point to this pass is 'gimplify_function_tree' located
in 'gimplify.c'.  From here we process the entire function gimplifying
each statement in turn.  The main workhorse for this pass is
'gimplify_expr'.  Approximately everything passes through here at least
once, and it is from here that we invoke the 'lang_hooks.gimplify_expr'
callback.

 The callback should examine the expression in question and return
'GS_UNHANDLED' if the expression is not a language specific construct
that requires attention.  Otherwise it should alter the expression in
some way to such that forward progress is made toward producing valid
GIMPLE.  If the callback is certain that the transformation is complete
and the expression is valid GIMPLE, it should return 'GS_ALL_DONE'.
Otherwise it should return 'GS_OK', which will cause the expression to
be processed again.  If the callback encounters an error during the
transformation (because the front end is relying on the gimplification
process to finish semantic checks), it should return 'GS_ERROR'.

==============================================================================
File: gccint.info,  Node: |Pass_manager|,  Next: |IPA_passes|,  Prev: |Gimplification_pass|,  Up: |Passes|
==============================================================================

                                                                  *Pass_manager*

9.3 Pass manager
----------------

The pass manager is located in 'passes.c', 'tree-optimize.c' and
'tree-pass.h'.  It processes passes as described in 'passes.def'.  Its
job is to run all of the individual passes in the correct order, and
take care of standard bookkeeping that applies to every pass.

 The theory of operation is that each pass defines a structure that
represents everything we need to know about that pass--when it should be
run, how it should be run, what intermediate language form or
on-the-side data structures it needs.  We register the pass to be run in
some particular order, and the pass manager arranges for everything to
happen in the correct order.

 The actuality doesn't completely live up to the theory at present.
Command-line switches and 'timevar_id_t' enumerations must still be
defined elsewhere.  The pass manager validates constraints but does not
attempt to (re-)generate data structures or lower intermediate language
form based on the requirements of the next pass.  Nevertheless, what is
present is useful, and a far sight better than nothing at all.

 Each pass should have a unique name.  Each pass may have its own dump
file (for GCC debugging purposes).  Passes with a name starting with a
star do not dump anything.  Sometimes passes are supposed to share a
dump file / option name.  To still give these unique names, you can use
a prefix that is delimited by a space from the part that is used for the
dump file / option name.  E.g.  When the pass name is "ud dce", the name
used for dump file/options is "dce".

 TODO: describe the global variables set up by the pass manager, and a
brief description of how a new pass should use it.  I need to look at
what info RTL passes use first...

==============================================================================
File: gccint.info,  Node: |IPA_passes|,  Next: |Tree_SSA_passes|,  Prev: |Pass_manager|,  Up: |Passes|
==============================================================================

                                                                    *IPA_passes*

9.4 Inter-procedural optimization passes
----------------------------------------

The inter-procedural optimization (IPA) passes use call graph
information to perform transformations across function boundaries.  IPA
is a critical part of link-time optimization (LTO) and whole-program
(WHOPR) optimization, and these passes are structured with the needs of
LTO and WHOPR in mind by dividing their operations into stages.  For
detailed discussion of the LTO/WHOPR IPA pass stages and interfaces, see
*note IPA::.

 The following briefly describes the inter-procedural optimization (IPA)
passes, which are split into small IPA passes, regular IPA passes, and
late IPA passes, according to the LTO/WHOPR processing model.

MENU

* |Small_IPA_passes|::
* |Regular_IPA_passes|::
* |Late_IPA_passes|::

==============================================================================
File: gccint.info,  Node: |Small_IPA_passes|,  Next: |Regular_IPA_passes|,  Up: |IPA_passes|
==============================================================================

                                                              *Small_IPA_passes*

9.4.1 Small IPA passes
----------------------

A small IPA pass is a pass derived from 'simple_ipa_opt_pass'.  As
described in *note IPA::, it does everything at once and defines only
the _Execute_ stage.  During this stage it accesses and modifies the
function bodies.  No 'generate_summary', 'read_summary', or
'write_summary' hooks are defined.

   * IPA free lang data

     This pass frees resources that are used by the front end but are
     not needed once it is done.  It is located in 'tree.c' and is
     described by 'pass_ipa_free_lang_data'.

   * IPA function and variable visibility

     This is a local function pass handling visibilities of all symbols.
     This happens before LTO streaming, so '-fwhole-program' should be
     ignored at this level.  It is located in 'ipa-visibility.c' and is
     described by 'pass_ipa_function_and_variable_visibility'.

   * IPA remove symbols

     This pass performs reachability analysis and reclaims all
     unreachable nodes.  It is located in 'passes.c' and is described by
     'pass_ipa_remove_symbols'.

   * IPA OpenACC

     This is a pass group for OpenACC processing.  It is located in
     'tree-ssa-loop.c' and is described by 'pass_ipa_oacc'.

   * IPA points-to analysis

     This is a tree-based points-to analysis pass.  The idea behind this
     analyzer is to generate set constraints from the program, then
     solve the resulting constraints in order to generate the points-to
     sets.  It is located in 'tree-ssa-structalias.c' and is described
     by 'pass_ipa_pta'.

   * IPA OpenACC kernels

     This is a pass group for processing OpenACC kernels regions.  It is
     a subpass of the IPA OpenACC pass group that runs on offloaded
     functions containing OpenACC kernels loops.  It is located in
     'tree-ssa-loop.c' and is described by 'pass_ipa_oacc_kernels'.

   * Target clone

     This is a pass for parsing functions with multiple target
     attributes.  It is located in 'multiple_target.c' and is described
     by 'pass_target_clone'.

   * IPA auto profile

     This pass uses AutoFDO profiling data to annotate the control flow
     graph.  It is located in 'auto-profile.c' and is described by
     'pass_ipa_auto_profile'.

   * IPA tree profile

     This pass does profiling for all functions in the call graph.  It
     calculates branch probabilities and basic block execution counts.
     It is located in 'tree-profile.c' and is described by
     'pass_ipa_tree_profile'.

   * IPA free function summary

     This pass is a small IPA pass when argument 'small_p' is true.  It
     releases inline function summaries and call summaries.  It is
     located in 'ipa-fnsummary.c' and is described by
     'pass_ipa_free_free_fn_summary'.

   * IPA increase alignment

     This pass increases the alignment of global arrays to improve
     vectorization.  It is located in 'tree-vectorizer.c' and is
     described by 'pass_ipa_increase_alignment'.

   * IPA transactional memory

     This pass is for transactional memory support.  It is located in
     'trans-mem.c' and is described by 'pass_ipa_tm'.

   * IPA lower emulated TLS

     This pass lowers thread-local storage (TLS) operations to emulation
     functions provided by libgcc.  It is located in 'tree-emutls.c' and
     is described by 'pass_ipa_lower_emutls'.

==============================================================================
File: gccint.info,  Node: |Regular_IPA_passes|,  Next: |Late_IPA_passes|,  Prev: |Small_IPA_passes|,  Up: |IPA_passes|
==============================================================================

                                                            *Regular_IPA_passes*

9.4.2 Regular IPA passes
------------------------

A regular IPA pass is a pass derived from 'ipa_opt_pass_d' that is
executed in WHOPR compilation.  Regular IPA passes may have summary
hooks implemented in any of the LGEN, WPA or LTRANS stages (*note
IPA::).

   * IPA whole program visibility

     This pass performs various optimizations involving symbol
     visibility with '-fwhole-program', including symbol privatization,
     discovering local functions, and dismantling comdat groups.  It is
     located in 'ipa-visibility.c' and is described by
     'pass_ipa_whole_program_visibility'.

   * IPA profile

     The IPA profile pass propagates profiling frequencies across the
     call graph.  It is located in 'ipa-profile.c' and is described by
     'pass_ipa_profile'.

   * IPA identical code folding

     This is the inter-procedural identical code folding pass.  The goal
     of this transformation is to discover functions and read-only
     variables that have exactly the same semantics.  It is located in
     'ipa-icf.c' and is described by 'pass_ipa_icf'.

   * IPA devirtualization

     This pass performs speculative devirtualization based on the type
     inheritance graph.  When a polymorphic call has only one likely
     target in the unit, it is turned into a speculative call.  It is
     located in 'ipa-devirt.c' and is described by 'pass_ipa_devirt'.

   * IPA constant propagation

     The goal of this pass is to discover functions that are always
     invoked with some arguments with the same known constant values and
     to modify the functions accordingly.  It can also do partial
     specialization and type-based devirtualization.  It is located in
     'ipa-cp.c' and is described by 'pass_ipa_cp'.

   * IPA scalar replacement of aggregates

     This pass can replace an aggregate parameter with a set of other
     parameters representing part of the original, turning those passed
     by reference into new ones which pass the value directly.  It also
     removes unused function return values and unused function
     parameters.  This pass is located in 'ipa-sra.c' and is described
     by 'pass_ipa_sra'.

   * IPA constructor/destructor merge

     This pass merges multiple constructors and destructors for static
     objects into single functions.  It's only run at LTO time unless
     the target doesn't support constructors and destructors natively.
     The pass is located in 'ipa.c' and is described by
     'pass_ipa_cdtor_merge'.

   * IPA HSA

     This pass is part of the GCC support for HSA (Heterogeneous System
     Architecture) accelerators.  It is responsible for creation of HSA
     clones and emitting HSAIL instructions for them.  It is located in
     'ipa-hsa.c' and is described by 'pass_ipa_hsa'.

   * IPA function summary

     This pass provides function analysis for inter-procedural passes.
     It collects estimates of function body size, execution time, and
     frame size for each function.  It also estimates information about
     function calls: call statement size, time and how often the
     parameters change for each call.  It is located in
     'ipa-fnsummary.c' and is described by 'pass_ipa_fn_summary'.

   * IPA inline

     The IPA inline pass handles function inlining with whole-program
     knowledge.  Small functions that are candidates for inlining are
     ordered in increasing badness, bounded by unit growth parameters.
     Unreachable functions are removed from the call graph.  Functions
     called once and not exported from the unit are inlined.  This pass
     is located in 'ipa-inline.c' and is described by 'pass_ipa_inline'.

   * IPA pure/const analysis

     This pass marks functions as being either const ('TREE_READONLY')
     or pure ('DECL_PURE_P').  The per-function information is produced
     by 'pure_const_generate_summary', then the global information is
     computed by performing a transitive closure over the call graph.
     It is located in 'ipa-pure-const.c' and is described by
     'pass_ipa_pure_const'.

   * IPA free function summary

     This pass is a regular IPA pass when argument 'small_p' is false.
     It releases inline function summaries and call summaries.  It is
     located in 'ipa-fnsummary.c' and is described by
     'pass_ipa_free_fn_summary'.

   * IPA reference

     This pass gathers information about how variables whose scope is
     confined to the compilation unit are used.  It is located in
     'ipa-reference.c' and is described by 'pass_ipa_reference'.

   * IPA single use

     This pass checks whether variables are used by a single function.
     It is located in 'ipa.c' and is described by 'pass_ipa_single_use'.

   * IPA comdats

     This pass looks for static symbols that are used exclusively within
     one comdat group, and moves them into that comdat group.  It is
     located in 'ipa-comdats.c' and is described by 'pass_ipa_comdats'.

==============================================================================
File: gccint.info,  Node: |Late_IPA_passes|,  Prev: |Regular_IPA_passes|,  Up: |IPA_passes|
==============================================================================

                                                               *Late_IPA_passes*

9.4.3 Late IPA passes
---------------------

Late IPA passes are simple IPA passes executed after the regular passes.
In WHOPR mode the passes are executed after partitioning and thus see
just parts of the compiled unit.

   * Materialize all clones

     Once all functions from compilation unit are in memory, produce all
     clones and update all calls.  It is located in 'ipa.c' and is
     described by 'pass_materialize_all_clones'.

   * IPA points-to analysis

     Points-to analysis; this is the same as the points-to-analysis pass
     run with the small IPA passes (*note Small IPA passes::).

   * OpenMP simd clone

     This is the OpenMP constructs' SIMD clone pass.  It creates the
     appropriate SIMD clones for functions tagged as elemental SIMD
     functions.  It is located in 'omp-simd-clone.c' and is described by
     'pass_omp_simd_clone'.

==============================================================================
File: gccint.info,  Node: |Tree_SSA_passes|,  Next: |RTL_passes|,  Prev: |IPA_passes|,  Up: |Passes|
==============================================================================

                                                               *Tree_SSA_passes*

9.5 Tree SSA passes
-------------------

The following briefly describes the Tree optimization passes that are
run after gimplification and what source files they are located in.

   * Remove useless statements

     This pass is an extremely simple sweep across the gimple code in
     which we identify obviously dead code and remove it.  Here we do
     things like simplify 'if' statements with constant conditions,
     remove exception handling constructs surrounding code that
     obviously cannot throw, remove lexical bindings that contain no
     variables, and other assorted simplistic cleanups.  The idea is to
     get rid of the obvious stuff quickly rather than wait until later
     when it's more work to get rid of it.  This pass is located in
     'tree-cfg.c' and described by 'pass_remove_useless_stmts'.

   * OpenMP lowering

     If OpenMP generation ('-fopenmp') is enabled, this pass lowers
     OpenMP constructs into GIMPLE.

     Lowering of OpenMP constructs involves creating replacement
     expressions for local variables that have been mapped using data
     sharing clauses, exposing the control flow of most synchronization
     directives and adding region markers to facilitate the creation of
     the control flow graph.  The pass is located in 'omp-low.c' and is
     described by 'pass_lower_omp'.

   * OpenMP expansion

     If OpenMP generation ('-fopenmp') is enabled, this pass expands
     parallel regions into their own functions to be invoked by the
     thread library.  The pass is located in 'omp-low.c' and is
     described by 'pass_expand_omp'.

   * Lower control flow

     This pass flattens 'if' statements ('COND_EXPR') and moves lexical
     bindings ('BIND_EXPR') out of line.  After this pass, all 'if'
     statements will have exactly two 'goto' statements in its 'then'
     and 'else' arms.  Lexical binding information for each statement
     will be found in 'TREE_BLOCK' rather than being inferred from its
     position under a 'BIND_EXPR'.  This pass is found in 'gimple-low.c'
     and is described by 'pass_lower_cf'.

   * Lower exception handling control flow

     This pass decomposes high-level exception handling constructs
     ('TRY_FINALLY_EXPR' and 'TRY_CATCH_EXPR') into a form that
     explicitly represents the control flow involved.  After this pass,
     'lookup_stmt_eh_region' will return a non-negative number for any
     statement that may have EH control flow semantics; examine
     'tree_can_throw_internal' or 'tree_can_throw_external' for exact
     semantics.  Exact control flow may be extracted from
     'foreach_reachable_handler'.  The EH region nesting tree is defined
     in 'except.h' and built in 'except.c'.  The lowering pass itself is
     in 'tree-eh.c' and is described by 'pass_lower_eh'.

   * Build the control flow graph

     This pass decomposes a function into basic blocks and creates all
     of the edges that connect them.  It is located in 'tree-cfg.c' and
     is described by 'pass_build_cfg'.

   * Find all referenced variables

     This pass walks the entire function and collects an array of all
     variables referenced in the function, 'referenced_vars'.  The index
     at which a variable is found in the array is used as a UID for the
     variable within this function.  This data is needed by the SSA
     rewriting routines.  The pass is located in 'tree-dfa.c' and is
     described by 'pass_referenced_vars'.

   * Enter static single assignment form

     This pass rewrites the function such that it is in SSA form.  After
     this pass, all 'is_gimple_reg' variables will be referenced by
     'SSA_NAME', and all occurrences of other variables will be
     annotated with 'VDEFS' and 'VUSES'; PHI nodes will have been
     inserted as necessary for each basic block.  This pass is located
     in 'tree-ssa.c' and is described by 'pass_build_ssa'.

   * Warn for uninitialized variables

     This pass scans the function for uses of 'SSA_NAME's that are fed
     by default definition.  For non-parameter variables, such uses are
     uninitialized.  The pass is run twice, before and after
     optimization (if turned on).  In the first pass we only warn for
     uses that are positively uninitialized; in the second pass we warn
     for uses that are possibly uninitialized.  The pass is located in
     'tree-ssa.c' and is defined by 'pass_early_warn_uninitialized' and
     'pass_late_warn_uninitialized'.

   * Dead code elimination

     This pass scans the function for statements without side effects
     whose result is unused.  It does not do memory life analysis, so
     any value that is stored in memory is considered used.  The pass is
     run multiple times throughout the optimization process.  It is
     located in 'tree-ssa-dce.c' and is described by 'pass_dce'.

   * Dominator optimizations

     This pass performs trivial dominator-based copy and constant
     propagation, expression simplification, and jump threading.  It is
     run multiple times throughout the optimization process.  It is
     located in 'tree-ssa-dom.c' and is described by 'pass_dominator'.

   * Forward propagation of single-use variables

     This pass attempts to remove redundant computation by substituting
     variables that are used once into the expression that uses them and
     seeing if the result can be simplified.  It is located in
     'tree-ssa-forwprop.c' and is described by 'pass_forwprop'.

   * Copy Renaming

     This pass attempts to change the name of compiler temporaries
     involved in copy operations such that SSA->normal can coalesce the
     copy away.  When compiler temporaries are copies of user variables,
     it also renames the compiler temporary to the user variable
     resulting in better use of user symbols.  It is located in
     'tree-ssa-copyrename.c' and is described by 'pass_copyrename'.

   * PHI node optimizations

     This pass recognizes forms of PHI inputs that can be represented as
     conditional expressions and rewrites them into straight line code.
     It is located in 'tree-ssa-phiopt.c' and is described by
     'pass_phiopt'.

   * May-alias optimization

     This pass performs a flow sensitive SSA-based points-to analysis.
     The resulting may-alias, must-alias, and escape analysis
     information is used to promote variables from in-memory addressable
     objects to non-aliased variables that can be renamed into SSA form.
     We also update the 'VDEF'/'VUSE' memory tags for non-renameable
     aggregates so that we get fewer false kills.  The pass is located
     in 'tree-ssa-alias.c' and is described by 'pass_may_alias'.

     Interprocedural points-to information is located in
     'tree-ssa-structalias.c' and described by 'pass_ipa_pta'.

   * Profiling

     This pass instruments the function in order to collect runtime
     block and value profiling data.  Such data may be fed back into the
     compiler on a subsequent run so as to allow optimization based on
     expected execution frequencies.  The pass is located in
     'tree-profile.c' and is described by 'pass_ipa_tree_profile'.

   * Static profile estimation

     This pass implements series of heuristics to guess propababilities
     of branches.  The resulting predictions are turned into edge
     profile by propagating branches across the control flow graphs.
     The pass is located in 'tree-profile.c' and is described by
     'pass_profile'.

   * Lower complex arithmetic

     This pass rewrites complex arithmetic operations into their
     component scalar arithmetic operations.  The pass is located in
     'tree-complex.c' and is described by 'pass_lower_complex'.

   * Scalar replacement of aggregates

     This pass rewrites suitable non-aliased local aggregate variables
     into a set of scalar variables.  The resulting scalar variables are
     rewritten into SSA form, which allows subsequent optimization
     passes to do a significantly better job with them.  The pass is
     located in 'tree-sra.c' and is described by 'pass_sra'.

   * Dead store elimination

     This pass eliminates stores to memory that are subsequently
     overwritten by another store, without any intervening loads.  The
     pass is located in 'tree-ssa-dse.c' and is described by 'pass_dse'.

   * Tail recursion elimination

     This pass transforms tail recursion into a loop.  It is located in
     'tree-tailcall.c' and is described by 'pass_tail_recursion'.

   * Forward store motion

     This pass sinks stores and assignments down the flowgraph closer to
     their use point.  The pass is located in 'tree-ssa-sink.c' and is
     described by 'pass_sink_code'.

   * Partial redundancy elimination

     This pass eliminates partially redundant computations, as well as
     performing load motion.  The pass is located in 'tree-ssa-pre.c'
     and is described by 'pass_pre'.

     Just before partial redundancy elimination, if
     '-funsafe-math-optimizations' is on, GCC tries to convert divisions
     to multiplications by the reciprocal.  The pass is located in
     'tree-ssa-math-opts.c' and is described by 'pass_cse_reciprocal'.

   * Full redundancy elimination

     This is a simpler form of PRE that only eliminates redundancies
     that occur on all paths.  It is located in 'tree-ssa-pre.c' and
     described by 'pass_fre'.

   * Loop optimization

     The main driver of the pass is placed in 'tree-ssa-loop.c' and
     described by 'pass_loop'.

     The optimizations performed by this pass are:

     Loop invariant motion.  This pass moves only invariants that would
     be hard to handle on RTL level (function calls, operations that
     expand to nontrivial sequences of insns).  With '-funswitch-loops'
     it also moves operands of conditions that are invariant out of the
     loop, so that we can use just trivial invariantness analysis in
     loop unswitching.  The pass also includes store motion.  The pass
     is implemented in 'tree-ssa-loop-im.c'.

     Canonical induction variable creation.  This pass creates a simple
     counter for number of iterations of the loop and replaces the exit
     condition of the loop using it, in case when a complicated analysis
     is necessary to determine the number of iterations.  Later
     optimizations then may determine the number easily.  The pass is
     implemented in 'tree-ssa-loop-ivcanon.c'.

     Induction variable optimizations.  This pass performs standard
     induction variable optimizations, including strength reduction,
     induction variable merging and induction variable elimination.  The
     pass is implemented in 'tree-ssa-loop-ivopts.c'.

     Loop unswitching.  This pass moves the conditional jumps that are
     invariant out of the loops.  To achieve this, a duplicate of the
     loop is created for each possible outcome of conditional jump(s).
     The pass is implemented in 'tree-ssa-loop-unswitch.c'.

     Loop splitting.  If a loop contains a conditional statement that is
     always true for one part of the iteration space and false for the
     other this pass splits the loop into two, one dealing with one side
     the other only with the other, thereby removing one inner-loop
     conditional.  The pass is implemented in 'tree-ssa-loop-split.c'.

     The optimizations also use various utility functions contained in
     'tree-ssa-loop-manip.c', 'cfgloop.c', 'cfgloopanal.c' and
     'cfgloopmanip.c'.

     Vectorization.  This pass transforms loops to operate on vector
     types instead of scalar types.  Data parallelism across loop
     iterations is exploited to group data elements from consecutive
     iterations into a vector and operate on them in parallel.
     Depending on available target support the loop is conceptually
     unrolled by a factor 'VF' (vectorization factor), which is the
     number of elements operated upon in parallel in each iteration, and
     the 'VF' copies of each scalar operation are fused to form a vector
     operation.  Additional loop transformations such as peeling and
     versioning may take place to align the number of iterations, and to
     align the memory accesses in the loop.  The pass is implemented in
     'tree-vectorizer.c' (the main driver), 'tree-vect-loop.c' and
     'tree-vect-loop-manip.c' (loop specific parts and general loop
     utilities), 'tree-vect-slp' (loop-aware SLP functionality),
     'tree-vect-stmts.c' and 'tree-vect-data-refs.c'.  Analysis of data
     references is in 'tree-data-ref.c'.

     SLP Vectorization.  This pass performs vectorization of
     straight-line code.  The pass is implemented in 'tree-vectorizer.c'
     (the main driver), 'tree-vect-slp.c', 'tree-vect-stmts.c' and
     'tree-vect-data-refs.c'.

     Autoparallelization.  This pass splits the loop iteration space to
     run into several threads.  The pass is implemented in
     'tree-parloops.c'.

     Graphite is a loop transformation framework based on the polyhedral
     model.  Graphite stands for Gimple Represented as Polyhedra.  The
     internals of this infrastructure are documented in
     <http://gcc.gnu.org/wiki/Graphite>.  The passes working on this
     representation are implemented in the various 'graphite-*' files.

   * Tree level if-conversion for vectorizer

     This pass applies if-conversion to simple loops to help vectorizer.
     We identify if convertible loops, if-convert statements and merge
     basic blocks in one big block.  The idea is to present loop in such
     form so that vectorizer can have one to one mapping between
     statements and available vector operations.  This pass is located
     in 'tree-if-conv.c' and is described by 'pass_if_conversion'.

   * Conditional constant propagation

     This pass relaxes a lattice of values in order to identify those
     that must be constant even in the presence of conditional branches.
     The pass is located in 'tree-ssa-ccp.c' and is described by
     'pass_ccp'.

     A related pass that works on memory loads and stores, and not just
     register values, is located in 'tree-ssa-ccp.c' and described by
     'pass_store_ccp'.

   * Conditional copy propagation

     This is similar to constant propagation but the lattice of values
     is the "copy-of" relation.  It eliminates redundant copies from the
     code.  The pass is located in 'tree-ssa-copy.c' and described by
     'pass_copy_prop'.

     A related pass that works on memory copies, and not just register
     copies, is located in 'tree-ssa-copy.c' and described by
     'pass_store_copy_prop'.

   * Value range propagation

     This transformation is similar to constant propagation but instead
     of propagating single constant values, it propagates known value
     ranges.  The implementation is based on Patterson's range
     propagation algorithm (Accurate Static Branch Prediction by Value
     Range Propagation, J. R. C. Patterson, PLDI '95).  In contrast to
     Patterson's algorithm, this implementation does not propagate
     branch probabilities nor it uses more than a single range per SSA
     name.  This means that the current implementation cannot be used
     for branch prediction (though adapting it would not be difficult).
     The pass is located in 'tree-vrp.c' and is described by 'pass_vrp'.

   * Folding built-in functions

     This pass simplifies built-in functions, as applicable, with
     constant arguments or with inferable string lengths.  It is located
     in 'tree-ssa-ccp.c' and is described by 'pass_fold_builtins'.

   * Split critical edges

     This pass identifies critical edges and inserts empty basic blocks
     such that the edge is no longer critical.  The pass is located in
     'tree-cfg.c' and is described by 'pass_split_crit_edges'.

   * Control dependence dead code elimination

     This pass is a stronger form of dead code elimination that can
     eliminate unnecessary control flow statements.  It is located in
     'tree-ssa-dce.c' and is described by 'pass_cd_dce'.

   * Tail call elimination

     This pass identifies function calls that may be rewritten into
     jumps.  No code transformation is actually applied here, but the
     data and control flow problem is solved.  The code transformation
     requires target support, and so is delayed until RTL.  In the
     meantime 'CALL_EXPR_TAILCALL' is set indicating the possibility.
     The pass is located in 'tree-tailcall.c' and is described by
     'pass_tail_calls'.  The RTL transformation is handled by
     'fixup_tail_calls' in 'calls.c'.

   * Warn for function return without value

     For non-void functions, this pass locates return statements that do
     not specify a value and issues a warning.  Such a statement may
     have been injected by falling off the end of the function.  This
     pass is run last so that we have as much time as possible to prove
     that the statement is not reachable.  It is located in 'tree-cfg.c'
     and is described by 'pass_warn_function_return'.

   * Leave static single assignment form

     This pass rewrites the function such that it is in normal form.  At
     the same time, we eliminate as many single-use temporaries as
     possible, so the intermediate language is no longer GIMPLE, but
     GENERIC.  The pass is located in 'tree-outof-ssa.c' and is
     described by 'pass_del_ssa'.

   * Merge PHI nodes that feed into one another

     This is part of the CFG cleanup passes.  It attempts to join PHI
     nodes from a forwarder CFG block into another block with PHI nodes.
     The pass is located in 'tree-cfgcleanup.c' and is described by
     'pass_merge_phi'.

   * Return value optimization

     If a function always returns the same local variable, and that
     local variable is an aggregate type, then the variable is replaced
     with the return value for the function (i.e., the function's
     DECL_RESULT). This is equivalent to the C++ named return value
     optimization applied to GIMPLE.  The pass is located in
     'tree-nrv.c' and is described by 'pass_nrv'.

   * Return slot optimization

     If a function returns a memory object and is called as 'var =
     foo()', this pass tries to change the call so that the address of
     'var' is sent to the caller to avoid an extra memory copy.  This
     pass is located in 'tree-nrv.c' and is described by
     'pass_return_slot'.

   * Optimize calls to '__builtin_object_size'

     This is a propagation pass similar to CCP that tries to remove
     calls to '__builtin_object_size' when the size of the object can be
     computed at compile-time.  This pass is located in
     'tree-object-size.c' and is described by 'pass_object_sizes'.

   * Loop invariant motion

     This pass removes expensive loop-invariant computations out of
     loops.  The pass is located in 'tree-ssa-loop.c' and described by
     'pass_lim'.

   * Loop nest optimizations

     This is a family of loop transformations that works on loop nests.
     It includes loop interchange, scaling, skewing and reversal and
     they are all geared to the optimization of data locality in array
     traversals and the removal of dependencies that hamper
     optimizations such as loop parallelization and vectorization.  The
     pass is located in 'tree-loop-linear.c' and described by
     'pass_linear_transform'.

   * Removal of empty loops

     This pass removes loops with no code in them.  The pass is located
     in 'tree-ssa-loop-ivcanon.c' and described by 'pass_empty_loop'.

   * Unrolling of small loops

     This pass completely unrolls loops with few iterations.  The pass
     is located in 'tree-ssa-loop-ivcanon.c' and described by
     'pass_complete_unroll'.

   * Predictive commoning

     This pass makes the code reuse the computations from the previous
     iterations of the loops, especially loads and stores to memory.  It
     does so by storing the values of these computations to a bank of
     temporary variables that are rotated at the end of loop.  To avoid
     the need for this rotation, the loop is then unrolled and the
     copies of the loop body are rewritten to use the appropriate
     version of the temporary variable.  This pass is located in
     'tree-predcom.c' and described by 'pass_predcom'.

   * Array prefetching

     This pass issues prefetch instructions for array references inside
     loops.  The pass is located in 'tree-ssa-loop-prefetch.c' and
     described by 'pass_loop_prefetch'.

   * Reassociation

     This pass rewrites arithmetic expressions to enable optimizations
     that operate on them, like redundancy elimination and
     vectorization.  The pass is located in 'tree-ssa-reassoc.c' and
     described by 'pass_reassoc'.

   * Optimization of 'stdarg' functions

     This pass tries to avoid the saving of register arguments into the
     stack on entry to 'stdarg' functions.  If the function doesn't use
     any 'va_start' macros, no registers need to be saved.  If
     'va_start' macros are used, the 'va_list' variables don't escape
     the function, it is only necessary to save registers that will be
     used in 'va_arg' macros.  For instance, if 'va_arg' is only used
     with integral types in the function, floating point registers don't
     need to be saved.  This pass is located in 'tree-stdarg.c' and
     described by 'pass_stdarg'.

==============================================================================
File: gccint.info,  Node: |RTL_passes|,  Next: |Optimization_info|,  Prev: |Tree_SSA_passes|,  Up: |Passes|
==============================================================================

                                                                    *RTL_passes*

9.6 RTL passes
--------------

The following briefly describes the RTL generation and optimization
passes that are run after the Tree optimization passes.

   * RTL generation

     The source files for RTL generation include 'stmt.c', 'calls.c',
     'expr.c', 'explow.c', 'expmed.c', 'function.c', 'optabs.c' and
     'emit-rtl.c'.  Also, the file 'insn-emit.c', generated from the
     machine description by the program 'genemit', is used in this pass.
     The header file 'expr.h' is used for communication within this
     pass.

     The header files 'insn-flags.h' and 'insn-codes.h', generated from
     the machine description by the programs 'genflags' and 'gencodes',
     tell this pass which standard names are available for use and which
     patterns correspond to them.

   * Generation of exception landing pads

     This pass generates the glue that handles communication between the
     exception handling library routines and the exception handlers
     within the function.  Entry points in the function that are invoked
     by the exception handling library are called "landing pads".  The
     code for this pass is located in 'except.c'.

   * Control flow graph cleanup

     This pass removes unreachable code, simplifies jumps to next, jumps
     to jump, jumps across jumps, etc.  The pass is run multiple times.
     For historical reasons, it is occasionally referred to as the "jump
     optimization pass".  The bulk of the code for this pass is in
     'cfgcleanup.c', and there are support routines in 'cfgrtl.c' and
     'jump.c'.

   * Forward propagation of single-def values

     This pass attempts to remove redundant computation by substituting
     variables that come from a single definition, and seeing if the
     result can be simplified.  It performs copy propagation and
     addressing mode selection.  The pass is run twice, with values
     being propagated into loops only on the second run.  The code is
     located in 'fwprop.c'.

   * Common subexpression elimination

     This pass removes redundant computation within basic blocks, and
     optimizes addressing modes based on cost.  The pass is run twice.
     The code for this pass is located in 'cse.c'.

   * Global common subexpression elimination

     This pass performs two different types of GCSE depending on whether
     you are optimizing for size or not (LCM based GCSE tends to
     increase code size for a gain in speed, while Morel-Renvoise based
     GCSE does not).  When optimizing for size, GCSE is done using
     Morel-Renvoise Partial Redundancy Elimination, with the exception
     that it does not try to move invariants out of loops--that is left
     to the loop optimization pass.  If MR PRE GCSE is done, code
     hoisting (aka unification) is also done, as well as load motion.
     If you are optimizing for speed, LCM (lazy code motion) based GCSE
     is done.  LCM is based on the work of Knoop, Ruthing, and Steffen.
     LCM based GCSE also does loop invariant code motion.  We also
     perform load and store motion when optimizing for speed.
     Regardless of which type of GCSE is used, the GCSE pass also
     performs global constant and copy propagation.  The source file for
     this pass is 'gcse.c', and the LCM routines are in 'lcm.c'.

   * Loop optimization

     This pass performs several loop related optimizations.  The source
     files 'cfgloopanal.c' and 'cfgloopmanip.c' contain generic loop
     analysis and manipulation code.  Initialization and finalization of
     loop structures is handled by 'loop-init.c'.  A loop invariant
     motion pass is implemented in 'loop-invariant.c'.  Basic block
     level optimizations--unrolling, and peeling loops-- are implemented
     in 'loop-unroll.c'.  Replacing of the exit condition of loops by
     special machine-dependent instructions is handled by
     'loop-doloop.c'.

   * Jump bypassing

     This pass is an aggressive form of GCSE that transforms the control
     flow graph of a function by propagating constants into conditional
     branch instructions.  The source file for this pass is 'gcse.c'.

   * If conversion

     This pass attempts to replace conditional branches and surrounding
     assignments with arithmetic, boolean value producing comparison
     instructions, and conditional move instructions.  In the very last
     invocation after reload/LRA, it will generate predicated
     instructions when supported by the target.  The code is located in
     'ifcvt.c'.

   * Web construction

     This pass splits independent uses of each pseudo-register.  This
     can improve effect of the other transformation, such as CSE or
     register allocation.  The code for this pass is located in 'web.c'.

   * Instruction combination

     This pass attempts to combine groups of two or three instructions
     that are related by data flow into single instructions.  It
     combines the RTL expressions for the instructions by substitution,
     simplifies the result using algebra, and then attempts to match the
     result against the machine description.  The code is located in
     'combine.c'.

   * Mode switching optimization

     This pass looks for instructions that require the processor to be
     in a specific "mode" and minimizes the number of mode changes
     required to satisfy all users.  What these modes are, and what they
     apply to are completely target-specific.  The code for this pass is
     located in 'mode-switching.c'.

   * Modulo scheduling

     This pass looks at innermost loops and reorders their instructions
     by overlapping different iterations.  Modulo scheduling is
     performed immediately before instruction scheduling.  The code for
     this pass is located in 'modulo-sched.c'.

   * Instruction scheduling

     This pass looks for instructions whose output will not be available
     by the time that it is used in subsequent instructions.  Memory
     loads and floating point instructions often have this behavior on
     RISC machines.  It re-orders instructions within a basic block to
     try to separate the definition and use of items that otherwise
     would cause pipeline stalls.  This pass is performed twice, before
     and after register allocation.  The code for this pass is located
     in 'haifa-sched.c', 'sched-deps.c', 'sched-ebb.c', 'sched-rgn.c'
     and 'sched-vis.c'.

   * Register allocation

     These passes make sure that all occurrences of pseudo registers are
     eliminated, either by allocating them to a hard register, replacing
     them by an equivalent expression (e.g. a constant) or by placing
     them on the stack.  This is done in several subpasses:

        * The integrated register allocator (IRA).  It is called
          integrated because coalescing, register live range splitting,
          and hard register preferencing are done on-the-fly during
          coloring.  It also has better integration with the reload/LRA
          pass.  Pseudo-registers spilled by the allocator or the
          reload/LRA have still a chance to get hard-registers if the
          reload/LRA evicts some pseudo-registers from hard-registers.
          The allocator helps to choose better pseudos for spilling
          based on their live ranges and to coalesce stack slots
          allocated for the spilled pseudo-registers.  IRA is a regional
          register allocator which is transformed into Chaitin-Briggs
          allocator if there is one region.  By default, IRA chooses
          regions using register pressure but the user can force it to
          use one region or regions corresponding to all loops.

          Source files of the allocator are 'ira.c', 'ira-build.c',
          'ira-costs.c', 'ira-conflicts.c', 'ira-color.c', 'ira-emit.c',
          'ira-lives', plus header files 'ira.h' and 'ira-int.h' used
          for the communication between the allocator and the rest of
          the compiler and between the IRA files.

        * Reloading.  This pass renumbers pseudo registers with the
          hardware registers numbers they were allocated.  Pseudo
          registers that did not get hard registers are replaced with
          stack slots.  Then it finds instructions that are invalid
          because a value has failed to end up in a register, or has
          ended up in a register of the wrong kind.  It fixes up these
          instructions by reloading the problematical values temporarily
          into registers.  Additional instructions are generated to do
          the copying.

          The reload pass also optionally eliminates the frame pointer
          and inserts instructions to save and restore call-clobbered
          registers around calls.

          Source files are 'reload.c' and 'reload1.c', plus the header
          'reload.h' used for communication between them.

        * This pass is a modern replacement of the reload pass.  Source
          files are 'lra.c', 'lra-assign.c', 'lra-coalesce.c',
          'lra-constraints.c', 'lra-eliminations.c', 'lra-lives.c',
          'lra-remat.c', 'lra-spills.c', the header 'lra-int.h' used for
          communication between them, and the header 'lra.h' used for
          communication between LRA and the rest of compiler.

          Unlike the reload pass, intermediate LRA decisions are
          reflected in RTL as much as possible.  This reduces the number
          of target-dependent macros and hooks, leaving instruction
          constraints as the primary source of control.

          LRA is run on targets for which TARGET_LRA_P returns true.

   * Basic block reordering

     This pass implements profile guided code positioning.  If profile
     information is not available, various types of static analysis are
     performed to make the predictions normally coming from the profile
     feedback (IE execution frequency, branch probability, etc).  It is
     implemented in the file 'bb-reorder.c', and the various prediction
     routines are in 'predict.c'.

   * Variable tracking

     This pass computes where the variables are stored at each position
     in code and generates notes describing the variable locations to
     RTL code.  The location lists are then generated according to these
     notes to debug information if the debugging information format
     supports location lists.  The code is located in 'var-tracking.c'.

   * Delayed branch scheduling

     This optional pass attempts to find instructions that can go into
     the delay slots of other instructions, usually jumps and calls.
     The code for this pass is located in 'reorg.c'.

   * Branch shortening

     On many RISC machines, branch instructions have a limited range.
     Thus, longer sequences of instructions must be used for long
     branches.  In this pass, the compiler figures out what how far each
     instruction will be from each other instruction, and therefore
     whether the usual instructions, or the longer sequences, must be
     used for each branch.  The code for this pass is located in
     'final.c'.

   * Register-to-stack conversion

     Conversion from usage of some hard registers to usage of a register
     stack may be done at this point.  Currently, this is supported only
     for the floating-point registers of the Intel 80387 coprocessor.
     The code for this pass is located in 'reg-stack.c'.

   * Final

     This pass outputs the assembler code for the function.  The source
     files are 'final.c' plus 'insn-output.c'; the latter is generated
     automatically from the machine description by the tool 'genoutput'.
     The header file 'conditions.h' is used for communication between
     these files.

   * Debugging information output

     This is run after final because it must output the stack slot
     offsets for pseudo registers that did not get hard registers.
     Source files are 'dbxout.c' for DBX symbol table format,
     'dwarfout.c' for DWARF symbol table format, files 'dwarf2out.c' and
     'dwarf2asm.c' for DWARF2 symbol table format, and 'vmsdbgout.c' for
     VMS debug symbol table format.

==============================================================================
File: gccint.info,  Node: |Optimization_info|,  Prev: |RTL_passes|,  Up: |Passes|
==============================================================================

                                                             *Optimization_info*

9.7 Optimization info
---------------------

This section is describes dump infrastructure which is common to both
pass dumps as well as optimization dumps.  The goal for this
infrastructure is to provide both gcc developers and users detailed
information about various compiler transformations and optimizations.

MENU

* |Dump_setup|::                         Setup of optimization dumps.
* |Optimization_groups|::                Groups made up of optimization passes.
* |Dump_files_and_streams|::             Dump output file names and streams.
* |Dump_output_verbosity|::              How much information to dump.
* |Dump_types|::                         Various types of dump functions.
* |Dump_examples|::                      Sample usage.

==============================================================================
File: gccint.info,  Node: |Dump_setup|,  Next: |Optimization_groups|,  Up: |Optimization_info|
==============================================================================

                                                                    *Dump_setup*

9.7.1 Dump setup
----------------

A dump_manager class is defined in 'dumpfile.h'.  Various passes
register dumping pass-specific information via 'dump_register' in
'passes.c'.  During the registration, an optimization pass can select
its optimization group (*note Optimization groups::).  After that
optimization information corresponding to the entire group (presumably
from multiple passes) can be output via command-line switches.  Note
that if a pass does not fit into any of the pre-defined groups, it can
select 'OPTGROUP_NONE'.

 Note that in general, a pass need not know its dump output file name,
whether certain flags are enabled, etc.  However, for legacy reasons,
passes could also call 'dump_begin' which returns a stream in case the
particular pass has optimization dumps enabled.  A pass could call
'dump_end' when the dump has ended.  These methods should go away once
all the passes are converted to use the new dump infrastructure.

 The recommended way to setup the dump output is via 'dump_start' and
'dump_end'.

==============================================================================
File: gccint.info,  Node: |Optimization_groups|,  Next: |Dump_files_and_streams|,  Prev: |Dump_setup|,  Up: |Optimization_info|
==============================================================================

                                                           *Optimization_groups*

9.7.2 Optimization groups
-------------------------

The optimization passes are grouped into several categories.  Currently
defined categories in 'dumpfile.h' are

'OPTGROUP_IPA'
     IPA optimization passes.  Enabled by '-ipa'

'OPTGROUP_LOOP'
     Loop optimization passes.  Enabled by '-loop'.

'OPTGROUP_INLINE'
     Inlining passes.  Enabled by '-inline'.

'OPTGROUP_OMP'
     OMP (Offloading and Multi Processing) passes.  Enabled by '-omp'.

'OPTGROUP_VEC'
     Vectorization passes.  Enabled by '-vec'.

'OPTGROUP_OTHER'
     All other optimization passes which do not fall into one of the
     above.

'OPTGROUP_ALL'
     All optimization passes.  Enabled by '-optall'.

 By using groups a user could selectively enable optimization
information only for a group of passes.  By default, the optimization
information for all the passes is dumped.

==============================================================================
File: gccint.info,  Node: |Dump_files_and_streams|,  Next: |Dump_output_verbosity|,  Prev: |Optimization_groups|,  Up: |Optimization_info|
==============================================================================

                                                        *Dump_files_and_streams*

9.7.3 Dump files and streams
----------------------------

There are two separate output streams available for outputting
optimization information from passes.  Note that both these streams
accept 'stderr' and 'stdout' as valid streams and thus it is possible to
dump output to standard output or error.  This is specially handy for
outputting all available information in a single file by redirecting
'stderr'.

'pstream'
     This stream is for pass-specific dump output.  For example,
     '-fdump-tree-vect=foo.v' dumps tree vectorization pass output into
     the given file name 'foo.v'.  If the file name is not provided, the
     default file name is based on the source file and pass number.
     Note that one could also use special file names 'stdout' and
     'stderr' for dumping to standard output and standard error
     respectively.

'alt_stream'
     This steam is used for printing optimization specific output in
     response to the '-fopt-info'.  Again a file name can be given.  If
     the file name is not given, it defaults to 'stderr'.

==============================================================================
File: gccint.info,  Node: |Dump_output_verbosity|,  Next: |Dump_types|,  Prev: |Dump_files_and_streams|,  Up: |Optimization_info|
==============================================================================

                                                         *Dump_output_verbosity*

9.7.4 Dump output verbosity
---------------------------

The dump verbosity has the following options

'optimized'
     Print information when an optimization is successfully applied.  It
     is up to a pass to decide which information is relevant.  For
     example, the vectorizer passes print the source location of loops
     which got successfully vectorized.

'missed'
     Print information about missed optimizations.  Individual passes
     control which information to include in the output.  For example,

          gcc -O2 -ftree-vectorize -fopt-info-vec-missed

     will print information about missed optimization opportunities from
     vectorization passes on stderr.

'note'
     Print verbose information about optimizations, such as certain
     transformations, more detailed messages about decisions etc.

'all'
     Print detailed optimization information.  This includes OPTIMIZED,
     MISSED, and NOTE.

==============================================================================
File: gccint.info,  Node: |Dump_types|,  Next: |Dump_examples|,  Prev: |Dump_output_verbosity|,  Up: |Optimization_info|
==============================================================================

                                                                    *Dump_types*

9.7.5 Dump types
----------------

'dump_printf'

     This is a generic method for doing formatted output.  It takes an
     additional argument 'dump_kind' which signifies the type of dump.
     This method outputs information only when the dumps are enabled for
     this particular 'dump_kind'.  Note that the caller doesn't need to
     know if the particular dump is enabled or not, or even the file
     name.  The caller only needs to decide which dump output
     information is relevant, and under what conditions.  This
     determines the associated flags.

     Consider the following example from 'loop-unroll.c' where an
     informative message about a loop (along with its location) is
     printed when any of the following flags is enabled

        - optimization messages
        - RTL dumps
        - detailed dumps

          int report_flags = MSG_OPTIMIZED_LOCATIONS | TDF_RTL | TDF_DETAILS;
          dump_printf_loc (report_flags, insn,
                           "loop turned into non-loop; it never loops.\n");

'dump_basic_block'
     Output basic block.
'dump_generic_expr'
     Output generic expression.
'dump_gimple_stmt'
     Output gimple statement.

     Note that the above methods also have variants prefixed with
     '_loc', such as 'dump_printf_loc', which are similar except they
     also output the source location information.  The '_loc' variants
     take a 'const dump_location_t &'.  This class can be constructed
     from a 'gimple *' or from a 'rtx_insn *', and so callers can pass a
     'gimple *' or a 'rtx_insn *' as the '_loc' argument.  The
     'dump_location_t' constructor will extract the source location from
     the statement or instruction, along with the profile count, and the
     location in GCC's own source code (or the plugin) from which the
     dump call was emitted.  Only the source location is currently used.
     There is also a 'dump_user_location_t' class, capturing the source
     location and profile count, but not the dump emission location, so
     that locations in the user's code can be passed around.  This can
     also be constructed from a 'gimple *' and from a 'rtx_insn *', and
     it too can be passed as the '_loc' argument.

==============================================================================
File: gccint.info,  Node: |Dump_examples|,  Prev: |Dump_types|,  Up: |Optimization_info|
==============================================================================

                                                                 *Dump_examples*

9.7.6 Dump examples
-------------------

     gcc -O3 -fopt-info-missed=missed.all

 outputs missed optimization report from all the passes into
'missed.all'.

 As another example,
     gcc -O3 -fopt-info-inline-optimized-missed=inline.txt

 will output information about missed optimizations as well as optimized
locations from all the inlining passes into 'inline.txt'.

 If the FILENAME is provided, then the dumps from all the applicable
optimizations are concatenated into the 'filename'.  Otherwise the dump
is output onto 'stderr'.  If OPTIONS is omitted, it defaults to
'optimized-optall', which means dump all information about successful
optimizations from all the passes.  In the following example, the
optimization information is output on to 'stderr'.

     gcc -O3 -fopt-info

 Note that '-fopt-info-vec-missed' behaves the same as
'-fopt-info-missed-vec'.  The order of the optimization group names and
message types listed after '-fopt-info' does not matter.

 As another example, consider

     gcc -fopt-info-vec-missed=vec.miss -fopt-info-loop-optimized=loop.opt

 Here the two output file names 'vec.miss' and 'loop.opt' are in
conflict since only one output file is allowed.  In this case, only the
first option takes effect and the subsequent options are ignored.  Thus
only the 'vec.miss' is produced which containts dumps from the
vectorizer about missed opportunities.

==============================================================================
File: gccint.info,  Node: |poly_int|,  Next: |GENERIC|,  Prev: |Passes|,  Up: |Top|
==============================================================================

                                                                      *poly_int*

10 Sizes and offsets as runtime invariants
==========================================

GCC allows the size of a hardware register to be a runtime invariant
rather than a compile-time constant.  This in turn means that various
sizes and offsets must also be runtime invariants rather than
compile-time constants, such as:

   * the size of a general 'machine_mode' (*note Machine Modes::);

   * the size of a spill slot;

   * the offset of something within a stack frame;

   * the number of elements in a vector;

   * the size and offset of a 'mem' rtx (*note Regs and Memory::); and

   * the byte offset in a 'subreg' rtx (*note Regs and Memory::).

 The motivating example is the Arm SVE ISA, whose vector registers can
be any multiple of 128 bits between 128 and 2048 inclusive.  The
compiler normally produces code that works for all SVE register sizes,
with the actual size only being known at runtime.

 GCC's main representation of such runtime invariants is the 'poly_int'
class.  This chapter describes what 'poly_int' does, lists the available
operations, and gives some general usage guidelines.

MENU

* |Overview_of_poly_int|::
* |Consequences_of_using_poly_int|::
* |Comparisons_involving_poly_int|::
* |Arithmetic_on_poly_ints|::
* |Alignment_of_poly_ints|::
* |Computing_bounds_on_poly_ints|::
* |Converting_poly_ints|::
* |Miscellaneous_poly_int_routines|::
* |Guidelines_for_using_poly_int|::

==============================================================================
File: gccint.info,  Node: |Overview_of_poly_int|,  Next: |Consequences_of_using_poly_int|,  Up: |poly_int|
==============================================================================

                                                          *Overview_of_poly_int*

10.1 Overview of 'poly_int'
---------------------------

We define indeterminates X1, ..., XN whose values are only known at
runtime and use polynomials of the form:

     C0 + C1 * X1 + ... + CN * XN

 to represent a size or offset whose value might depend on some of these
indeterminates.  The coefficients C0, ..., CN are always known at
compile time, with the C0 term being the "constant" part that does not
depend on any runtime value.

 GCC uses the 'poly_int' class to represent these coefficients.  The
class has two template parameters: the first specifies the number of
coefficients (N + 1) and the second specifies the type of the
coefficients.  For example, 'poly_int<2, unsigned short>' represents a
polynomial with two coefficients (and thus one indeterminate), with each
coefficient having type 'unsigned short'.  When N is 0, the class
degenerates to a single compile-time constant C0.

 The number of coefficients needed for compilation is a fixed property
of each target and is specified by the configuration macro
'NUM_POLY_INT_COEFFS'.  The default value is 1, since most targets do
not have such runtime invariants.  Targets that need a different value
should '#define' the macro in their 'CPU-modes.def' file.  *Note Back
End::.

 'poly_int' makes the simplifying requirement that each indeterminate
must be a nonnegative integer.  An indeterminate value of 0 should
usually represent the minimum possible runtime value, with C0 specifying
the value in that case.

 For example, when targetting the Arm SVE ISA, the single indeterminate
represents the number of 128-bit blocks in a vector _beyond the minimum
length of 128 bits_.  Thus the number of 64-bit doublewords in a vector
is 2 + 2 * X1.  If an aggregate has a single SVE vector and 16
additional bytes, its total size is 32 + 16 * X1 bytes.

 The header file 'poly-int-types.h' provides typedefs for the most
common forms of 'poly_int', all having 'NUM_POLY_INT_COEFFS'
coefficients:

'poly_uint16'
     a 'poly_int' with 'unsigned short' coefficients.

'poly_int64'
     a 'poly_int' with 'HOST_WIDE_INT' coefficients.

'poly_uint64'
     a 'poly_int' with 'unsigned HOST_WIDE_INT' coefficients.

'poly_offset_int'
     a 'poly_int' with 'offset_int' coefficients.

'poly_wide_int'
     a 'poly_int' with 'wide_int' coefficients.

'poly_widest_int'
     a 'poly_int' with 'widest_int' coefficients.

 Since the main purpose of 'poly_int' is to represent sizes and offsets,
the last two typedefs are only rarely used.

==============================================================================
File: gccint.info,  Node: |Consequences_of_using_poly_int|,  Next: |Comparisons_involving_poly_int|,  Prev: |Overview_of_poly_int|,  Up: |poly_int|
==============================================================================

                                                *Consequences_of_using_poly_int*

10.2 Consequences of using 'poly_int'
-------------------------------------

The two main consequences of using polynomial sizes and offsets are
that:

   * there is no total ordering between the values at compile time, and

   * some operations might yield results that cannot be expressed as a
     'poly_int'.

 For example, if X is a runtime invariant, we cannot tell at compile
time whether:

     3 + 4X <= 1 + 5X

 since the condition is false when X <= 1 and true when X >= 2.

 Similarly, 'poly_int' cannot represent the result of:

     (3 + 4X) * (1 + 5X)

 since it cannot (and in practice does not need to) store powers greater
than one.  It also cannot represent the result of:

     (3 + 4X) / (1 + 5X)

 The following sections describe how we deal with these restrictions.

 As described earlier, a 'poly_int<1, T>' has no indeterminates and so
degenerates to a compile-time constant of type T.  It would be possible
in that case to do all normal arithmetic on the T, and to compare the T
using the normal C++ operators.  We deliberately prevent
target-independent code from doing this, since the compiler needs to
support other 'poly_int<N, T>' as well, regardless of the current
target's 'NUM_POLY_INT_COEFFS'.

 However, it would be very artificial to force target-specific code to
follow these restrictions if the target has no runtime indeterminates.
There is therefore an implicit conversion from 'poly_int<1, T>' to T
when compiling target-specific translation units.

==============================================================================
File: gccint.info,  Node: |Comparisons_involving_poly_int|,  Next: |Arithmetic_on_poly_ints|,  Prev: |Consequences_of_using_poly_int|,  Up: |poly_int|
==============================================================================

                                                *Comparisons_involving_poly_int*

10.3 Comparisons involving 'poly_int'
-------------------------------------

In general we need to compare sizes and offsets in two situations: those
in which the values need to be ordered, and those in which the values
can be unordered.  More loosely, the distinction is often between values
that have a definite link (usually because they refer to the same
underlying register or memory location) and values that have no definite
link.  An example of the former is the relationship between the inner
and outer sizes of a subreg, where we must know at compile time whether
the subreg is paradoxical, partial, or complete.  An example of the
latter is alias analysis: we might want to check whether two arbitrary
memory references overlap.

 Referring back to the examples in the previous section, it makes sense
to ask whether a memory reference of size '3 + 4X' overlaps one of size
'1 + 5X', but it does not make sense to have a subreg in which the outer
mode has '3 + 4X' bytes and the inner mode has '1 + 5X' bytes (or vice
versa).  Such subregs are always invalid and should trigger an internal
compiler error if formed.

 The underlying operators are the same in both cases, but the
distinction affects how they are used.

MENU

* |Comparison_functions_for_poly_int|::
* |Properties_of_the_poly_int_comparisons|::
* |Comparing_potentially_unordered_poly_ints|::
* |Comparing_ordered_poly_ints|::
* |Checking_for_a_poly_int_marker_value|::
* |Range_checks_on_poly_ints|::
* |Sorting_poly_ints|::

==============================================================================
File: gccint.info,  Node: |Comparison_functions_for_poly_int|,  Next: |Properties_of_the_poly_int_comparisons|,  Up: |Comparisons_involving_poly_int|
==============================================================================

                                             *Comparison_functions_for_poly_int*

10.3.1 Comparison functions for 'poly_int'
------------------------------------------

'poly_int' provides the following routines for checking whether a
particular condition "may be" (might be) true:

     maybe_lt maybe_le maybe_eq maybe_ge maybe_gt
                       maybe_ne

 The functions have their natural meaning:

'maybe_lt(A, B)'
     Return true if A might be less than B.

'maybe_le(A, B)'
     Return true if A might be less than or equal to B.

'maybe_eq(A, B)'
     Return true if A might be equal to B.

'maybe_ne(A, B)'
     Return true if A might not be equal to B.

'maybe_ge(A, B)'
     Return true if A might be greater than or equal to B.

'maybe_gt(A, B)'
     Return true if A might be greater than B.

 For readability, 'poly_int' also provides "known" inverses of these
functions:

     known_lt (A, B) == !maybe_ge (A, B)
     known_le (A, B) == !maybe_gt (A, B)
     known_eq (A, B) == !maybe_ne (A, B)
     known_ge (A, B) == !maybe_lt (A, B)
     known_gt (A, B) == !maybe_le (A, B)
     known_ne (A, B) == !maybe_eq (A, B)

==============================================================================
File: gccint.info,  Node: |Properties_of_the_poly_int_comparisons|,  Next: |Comparing_potentially_unordered_poly_ints|,  Prev: |Comparison_functions_for_poly_int|,  Up: |Comparisons_involving_poly_int|
==============================================================================

                                        *Properties_of_the_poly_int_comparisons*

10.3.2 Properties of the 'poly_int' comparisons
-----------------------------------------------

All "maybe" relations except 'maybe_ne' are transitive, so for example:

     maybe_lt (A, B) && maybe_lt (B, C) implies maybe_lt (A, C)

 for all A, B and C.  'maybe_lt', 'maybe_gt' and 'maybe_ne' are
irreflexive, so for example:

     !maybe_lt (A, A)

 is true for all A.  'maybe_le', 'maybe_eq' and 'maybe_ge' are
reflexive, so for example:

     maybe_le (A, A)

 is true for all A.  'maybe_eq' and 'maybe_ne' are symmetric, so:

     maybe_eq (A, B) == maybe_eq (B, A)
     maybe_ne (A, B) == maybe_ne (B, A)

 for all A and B.  In addition:

     maybe_le (A, B) == maybe_lt (A, B) || maybe_eq (A, B)
     maybe_ge (A, B) == maybe_gt (A, B) || maybe_eq (A, B)
     maybe_lt (A, B) == maybe_gt (B, A)
     maybe_le (A, B) == maybe_ge (B, A)

 However:

     maybe_le (A, B) && maybe_le (B, A) does not imply !maybe_ne (A, B) [== known_eq (A, B)]
     maybe_ge (A, B) && maybe_ge (B, A) does not imply !maybe_ne (A, B) [== known_eq (A, B)]

 One example is again 'A == 3 + 4X' and 'B == 1 + 5X', where 'maybe_le
(A, B)', 'maybe_ge (A, B)' and 'maybe_ne (A, B)' all hold.  'maybe_le'
and 'maybe_ge' are therefore not antisymetric and do not form a partial
order.

 From the above, it follows that:

   * All "known" relations except 'known_ne' are transitive.

   * 'known_lt', 'known_ne' and 'known_gt' are irreflexive.

   * 'known_le', 'known_eq' and 'known_ge' are reflexive.

 Also:

     known_lt (A, B) == known_gt (B, A)
     known_le (A, B) == known_ge (B, A)
     known_lt (A, B) implies !known_lt (B, A)  [asymmetry]
     known_gt (A, B) implies !known_gt (B, A)
     known_le (A, B) && known_le (B, A) == known_eq (A, B) [== !maybe_ne (A, B)]
     known_ge (A, B) && known_ge (B, A) == known_eq (A, B) [== !maybe_ne (A, B)]

 'known_le' and 'known_ge' are therefore antisymmetric and are partial
orders.  However:

     known_le (A, B) does not imply known_lt (A, B) || known_eq (A, B)
     known_ge (A, B) does not imply known_gt (A, B) || known_eq (A, B)

 For example, 'known_le (4, 4 + 4X)' holds because the runtime
indeterminate X is a nonnegative integer, but neither 'known_lt (4, 4 +
4X)' nor 'known_eq (4, 4 + 4X)' hold.

==============================================================================
File: gccint.info,  Node: |Comparing_potentially_unordered_poly_ints|,  Next: |Comparing_ordered_poly_ints|,  Prev: |Properties_of_the_poly_int_comparisons|,  Up: |Comparisons_involving_poly_int|
==============================================================================

                                     *Comparing_potentially_unordered_poly_ints*

10.3.3 Comparing potentially-unordered 'poly_int's
--------------------------------------------------

In cases where there is no definite link between two 'poly_int's, we can
usually make a conservatively-correct assumption.  For example, the
conservative assumption for alias analysis is that two references
_might_ alias.

 One way of checking whether [BEGIN1, END1) might overlap [BEGIN2, END2)
using the 'poly_int' comparisons is:

     maybe_gt (END1, BEGIN2) && maybe_gt (END2, BEGIN1)

 and another (equivalent) way is:

     !(known_le (END1, BEGIN2) || known_le (END2, BEGIN1))

 However, in this particular example, it is better to use the range
helper functions instead.  *Note Range checks on poly_ints::.

==============================================================================
File: gccint.info,  Node: |Comparing_ordered_poly_ints|,  Next: |Checking_for_a_poly_int_marker_value|,  Prev: |Comparing_potentially_unordered_poly_ints|,  Up: |Comparisons_involving_poly_int|
==============================================================================

                                                   *Comparing_ordered_poly_ints*

10.3.4 Comparing ordered 'poly_int's
------------------------------------

In cases where there is a definite link between two 'poly_int's, such as
the outer and inner sizes of subregs, we usually require the sizes to be
ordered by the 'known_le' partial order.  'poly_int' provides the
following utility functions for ordered values:

'ordered_p (A, B)'
     Return true if A and B are ordered by the 'known_le' partial order.

'ordered_min (A, B)'
     Assert that A and B are ordered by 'known_le' and return the
     minimum of the two.  When using this function, please add a comment
     explaining why the values are known to be ordered.

'ordered_max (A, B)'
     Assert that A and B are ordered by 'known_le' and return the
     maximum of the two.  When using this function, please add a comment
     explaining why the values are known to be ordered.

 For example, if a subreg has an outer mode of size OUTER and an inner
mode of size INNER:

   * the subreg is complete if known_eq (INNER, OUTER)

   * otherwise, the subreg is paradoxical if known_le (INNER, OUTER)

   * otherwise, the subreg is partial if known_le (OUTER, INNER)

   * otherwise, the subreg is ill-formed

 Thus the subreg is only valid if 'ordered_p (OUTER, INNER)' is true.
If this condition is already known to be true then:

   * the subreg is complete if known_eq (INNER, OUTER)

   * the subreg is paradoxical if maybe_lt (INNER, OUTER)

   * the subreg is partial if maybe_lt (OUTER, INNER)

 with the three conditions being mutually exclusive.

 Code that checks whether a subreg is valid would therefore generally
check whether 'ordered_p' holds (in addition to whatever other checks
are required for subreg validity).  Code that is dealing with existing
subregs can assert that 'ordered_p' holds and use either of the
classifications above.

==============================================================================
File: gccint.info,  Node: |Checking_for_a_poly_int_marker_value|,  Next: |Range_checks_on_poly_ints|,  Prev: |Comparing_ordered_poly_ints|,  Up: |Comparisons_involving_poly_int|
==============================================================================

                                          *Checking_for_a_poly_int_marker_value*

10.3.5 Checking for a 'poly_int' marker value
---------------------------------------------

It is sometimes useful to have a special "marker value" that is not
meant to be taken literally.  For example, some code uses a size of -1
to represent an unknown size, rather than having to carry around a
separate boolean to say whether the size is known.

 The best way of checking whether something is a marker value is
'known_eq'.  Conversely the best way of checking whether something is
_not_ a marker value is 'maybe_ne'.

 Thus in the size example just mentioned, 'known_eq (size, -1)' would
check for an unknown size and 'maybe_ne (size, -1)' would check for a
known size.

==============================================================================
File: gccint.info,  Node: |Range_checks_on_poly_ints|,  Next: |Sorting_poly_ints|,  Prev: |Checking_for_a_poly_int_marker_value|,  Up: |Comparisons_involving_poly_int|
==============================================================================

                                                     *Range_checks_on_poly_ints*

10.3.6 Range checks on 'poly_int's
----------------------------------

As well as the core comparisons (*note Comparison functions for
poly_int::), 'poly_int' provides utilities for various kinds of range
check.  In each case the range is represented by a start position and a
size rather than a start position and an end position; this is because
the former is used much more often than the latter in GCC.  Also, the
sizes can be -1 (or all ones for unsigned sizes) to indicate a range
with a known start position but an unknown size.  All other sizes must
be nonnegative.  A range of size 0 does not contain anything or overlap
anything.

'known_size_p (SIZE)'
     Return true if SIZE represents a known range size, false if it is
     -1 or all ones (for signed and unsigned types respectively).

'ranges_maybe_overlap_p (POS1, SIZE1, POS2, SIZE2)'
     Return true if the range described by POS1 and SIZE1 _might_
     overlap the range described by POS2 and SIZE2 (in other words,
     return true if we cannot prove that the ranges are disjoint).

'ranges_known_overlap_p (POS1, SIZE1, POS2, SIZE2)'
     Return true if the range described by POS1 and SIZE1 is known to
     overlap the range described by POS2 and SIZE2.

'known_subrange_p (POS1, SIZE1, POS2, SIZE2)'
     Return true if the range described by POS1 and SIZE1 is known to be
     contained in the range described by POS2 and SIZE2.

'maybe_in_range_p (VALUE, POS, SIZE)'
     Return true if VALUE _might_ be in the range described by POS and
     SIZE (in other words, return true if we cannot prove that VALUE is
     outside that range).

'known_in_range_p (VALUE, POS, SIZE)'
     Return true if VALUE is known to be in the range described by POS
     and SIZE.

'endpoint_representable_p (POS, SIZE)'
     Return true if the range described by POS and SIZE is open-ended or
     if the endpoint (POS + SIZE) is representable in the same type as
     POS and SIZE.  The function returns false if adding SIZE to POS
     makes conceptual sense but could overflow.

 There is also a 'poly_int' version of the 'IN_RANGE_P' macro:

'coeffs_in_range_p (X, LOWER, UPPER)'
     Return true if every coefficient of X is in the inclusive range
     [LOWER, UPPER].  This function can be useful when testing whether
     an operation would cause the values of coefficients to overflow.

     Note that the function does not indicate whether X itself is in the
     given range.  X can be either a constant or a 'poly_int'.

==============================================================================
File: gccint.info,  Node: |Sorting_poly_ints|,  Prev: |Range_checks_on_poly_ints|,  Up: |Comparisons_involving_poly_int|
==============================================================================

                                                             *Sorting_poly_ints*

10.3.7 Sorting 'poly_int's
--------------------------

'poly_int' provides the following routine for sorting:

'compare_sizes_for_sort (A, B)'
     Compare A and B in reverse lexicographical order (that is, compare
     the highest-indexed coefficients first).  This can be useful when
     sorting data structures, since it has the effect of separating
     constant and non-constant values.  If all values are nonnegative,
     the constant values come first.

     Note that the values do not necessarily end up in numerical order.
     For example, '1 + 1X' would come after '100' in the sort order, but
     may well be less than '100' at run time.

==============================================================================
File: gccint.info,  Node: |Arithmetic_on_poly_ints|,  Next: |Alignment_of_poly_ints|,  Prev: |Comparisons_involving_poly_int|,  Up: |poly_int|
==============================================================================

                                                       *Arithmetic_on_poly_ints*

10.4 Arithmetic on 'poly_int's
------------------------------

Addition, subtraction, negation and bit inversion all work normally for
'poly_int's.  Multiplication by a constant multiplier and left shifting
by a constant shift amount also work normally.  General multiplication
of two 'poly_int's is not supported and is not useful in practice.

 Other operations are only conditionally supported: the operation might
succeed or might fail, depending on the inputs.

 This section describes both types of operation.

MENU

* |Using_poly_int_with_C++_arithmetic_operators|::
* |wi_arithmetic_on_poly_ints|::
* |Division_of_poly_ints|::
* |Other_poly_int_arithmetic|::

==============================================================================
File: gccint.info,  Node: |Using_poly_int_with_C++_arithmetic_operators|,  Next: |wi_arithmetic_on_poly_ints|,  Up: |Arithmetic_on_poly_ints|
==============================================================================

                                  *Using_poly_int_with_C++_arithmetic_operators*

10.4.1 Using 'poly_int' with C++ arithmetic operators
-----------------------------------------------------

The following C++ expressions are supported, where P1 and P2 are
'poly_int's and where C1 and C2 are scalars:

     -P1
     ~P1

     P1 + P2
     P1 + C2
     C1 + P2

     P1 - P2
     P1 - C2
     C1 - P2

     C1 * P2
     P1 * C2

     P1 << C2

     P1 += P2
     P1 += C2

     P1 -= P2
     P1 -= C2

     P1 *= C2
     P1 <<= C2

 These arithmetic operations handle integer ranks in a similar way to
C++.  The main difference is that every coefficient narrower than
'HOST_WIDE_INT' promotes to 'HOST_WIDE_INT', whereas in C++ everything
narrower than 'int' promotes to 'int'.  For example:

     poly_uint16     + int          -> poly_int64
     unsigned int    + poly_uint16  -> poly_int64
     poly_int64      + int          -> poly_int64
     poly_int32      + poly_uint64  -> poly_uint64
     uint64          + poly_int64   -> poly_uint64
     poly_offset_int + int32        -> poly_offset_int
     offset_int      + poly_uint16  -> poly_offset_int

 In the first two examples, both coefficients are narrower than
'HOST_WIDE_INT', so the result has coefficients of type 'HOST_WIDE_INT'.
In the other examples, the coefficient with the highest rank "wins".

 If one of the operands is 'wide_int' or 'poly_wide_int', the rules are
the same as for 'wide_int' arithmetic.

==============================================================================
File: gccint.info,  Node: |wi_arithmetic_on_poly_ints|,  Next: |Division_of_poly_ints|,  Prev: |Using_poly_int_with_C++_arithmetic_operators|,  Up: |Arithmetic_on_poly_ints|
==============================================================================

                                                    *wi_arithmetic_on_poly_ints*

10.4.2 'wi' arithmetic on 'poly_int's
-------------------------------------

As well as the C++ operators, 'poly_int' supports the following 'wi'
routines:

     wi::neg (P1, &OVERFLOW)

     wi::add (P1, P2)
     wi::add (P1, C2)
     wi::add (C1, P1)
     wi::add (P1, P2, SIGN, &OVERFLOW)

     wi::sub (P1, P2)
     wi::sub (P1, C2)
     wi::sub (C1, P1)
     wi::sub (P1, P2, SIGN, &OVERFLOW)

     wi::mul (P1, C2)
     wi::mul (C1, P1)
     wi::mul (P1, C2, SIGN, &OVERFLOW)

     wi::lshift (P1, C2)

 These routines just check whether overflow occurs on any individual
coefficient; it is not possible to know at compile time whether the
final runtime value would overflow.

==============================================================================
File: gccint.info,  Node: |Division_of_poly_ints|,  Next: |Other_poly_int_arithmetic|,  Prev: |wi_arithmetic_on_poly_ints|,  Up: |Arithmetic_on_poly_ints|
==============================================================================

                                                         *Division_of_poly_ints*

10.4.3 Division of 'poly_int's
------------------------------

Division of 'poly_int's is possible for certain inputs.  The functions
for division return true if the operation is possible and in most cases
return the results by pointer.  The routines are:

'multiple_p (A, B)'
'multiple_p (A, B, &QUOTIENT)'
     Return true if A is an exact multiple of B, storing the result in
     QUOTIENT if so.  There are overloads for various combinations of
     polynomial and constant A, B and QUOTIENT.

'constant_multiple_p (A, B)'
'constant_multiple_p (A, B, &QUOTIENT)'
     Like 'multiple_p', but also test whether the multiple is a
     compile-time constant.

'can_div_trunc_p (A, B, &QUOTIENT)'
'can_div_trunc_p (A, B, &QUOTIENT, &REMAINDER)'
     Return true if we can calculate 'trunc (A / B)' at compile time,
     storing the result in QUOTIENT and REMAINDER if so.

'can_div_away_from_zero_p (A, B, &QUOTIENT)'
     Return true if we can calculate 'A / B' at compile time, rounding
     away from zero.  Store the result in QUOTIENT if so.

     Note that this is true if and only if 'can_div_trunc_p' is true.
     The only difference is in the rounding of the result.

 There is also an asserting form of division:

'exact_div (A, B)'
     Assert that A is a multiple of B and return 'A / B'.  The result is
     a 'poly_int' if A is a 'poly_int'.

==============================================================================
File: gccint.info,  Node: |Other_poly_int_arithmetic|,  Prev: |Division_of_poly_ints|,  Up: |Arithmetic_on_poly_ints|
==============================================================================

                                                     *Other_poly_int_arithmetic*

10.4.4 Other 'poly_int' arithmetic
----------------------------------

There are tentative routines for other operations besides division:

'can_ior_p (A, B, &RESULT)'
     Return true if we can calculate 'A | B' at compile time, storing
     the result in RESULT if so.

 Also, ANDs with a value '(1 << Y) - 1' or its inverse can be treated as
alignment operations.  *Note Alignment of poly_ints::.

 In addition, the following miscellaneous routines are available:

'coeff_gcd (A)'
     Return the greatest common divisor of all nonzero coefficients in
     A, or zero if A is known to be zero.

'common_multiple (A, B)'
     Return a value that is a multiple of both A and B, where one value
     is a 'poly_int' and the other is a scalar.  The result will be the
     least common multiple for some indeterminate values but not
     necessarily for all.

'force_common_multiple (A, B)'
     Return a value that is a multiple of both 'poly_int' A and
     'poly_int' B, asserting that such a value exists.  The result will
     be the least common multiple for some indeterminate values but not
     necessarily for all.

     When using this routine, please add a comment explaining why the
     assertion is known to hold.

 Please add any other operations that you find to be useful.

==============================================================================
File: gccint.info,  Node: |Alignment_of_poly_ints|,  Next: |Computing_bounds_on_poly_ints|,  Prev: |Arithmetic_on_poly_ints|,  Up: |poly_int|
==============================================================================

                                                        *Alignment_of_poly_ints*

10.5 Alignment of 'poly_int's
-----------------------------

'poly_int' provides various routines for aligning values and for
querying misalignments.  In each case the alignment must be a power of
2.

'can_align_p (VALUE, ALIGN)'
     Return true if we can align VALUE up or down to the nearest
     multiple of ALIGN at compile time.  The answer is the same for both
     directions.

'can_align_down (VALUE, ALIGN, &ALIGNED)'
     Return true if 'can_align_p'; if so, set ALIGNED to the greatest
     aligned value that is less than or equal to VALUE.

'can_align_up (VALUE, ALIGN, &ALIGNED)'
     Return true if 'can_align_p'; if so, set ALIGNED to the lowest
     aligned value that is greater than or equal to VALUE.

'known_equal_after_align_down (A, B, ALIGN)'
     Return true if we can align A and B down to the nearest ALIGN
     boundary at compile time and if the two results are equal.

'known_equal_after_align_up (A, B, ALIGN)'
     Return true if we can align A and B up to the nearest ALIGN
     boundary at compile time and if the two results are equal.

'aligned_lower_bound (VALUE, ALIGN)'
     Return a result that is no greater than VALUE and that is aligned
     to ALIGN.  The result will the closest aligned value for some
     indeterminate values but not necessarily for all.

     For example, suppose we are allocating an object of SIZE bytes in a
     downward-growing stack whose current limit is given by LIMIT.  If
     the object requires ALIGN bytes of alignment, the new stack limit
     is given by:

          aligned_lower_bound (LIMIT - SIZE, ALIGN)

'aligned_upper_bound (VALUE, ALIGN)'
     Likewise return a result that is no less than VALUE and that is
     aligned to ALIGN.  This is the routine that would be used for
     upward-growing stacks in the scenario just described.

'known_misalignment (VALUE, ALIGN, &MISALIGN)'
     Return true if we can calculate the misalignment of VALUE with
     respect to ALIGN at compile time, storing the result in MISALIGN if
     so.

'known_alignment (VALUE)'
     Return the minimum alignment that VALUE is known to have (in other
     words, the largest alignment that can be guaranteed whatever the
     values of the indeterminates turn out to be).  Return 0 if VALUE is
     known to be 0.

'force_align_down (VALUE, ALIGN)'
     Assert that VALUE can be aligned down to ALIGN at compile time and
     return the result.  When using this routine, please add a comment
     explaining why the assertion is known to hold.

'force_align_up (VALUE, ALIGN)'
     Likewise, but aligning up.

'force_align_down_and_div (VALUE, ALIGN)'
     Divide the result of 'force_align_down' by ALIGN.  Again, please
     add a comment explaining why the assertion in 'force_align_down' is
     known to hold.

'force_align_up_and_div (VALUE, ALIGN)'
     Likewise for 'force_align_up'.

'force_get_misalignment (VALUE, ALIGN)'
     Assert that we can calculate the misalignment of VALUE with respect
     to ALIGN at compile time and return the misalignment.  When using
     this function, please add a comment explaining why the assertion is
     known to hold.

==============================================================================
File: gccint.info,  Node: |Computing_bounds_on_poly_ints|,  Next: |Converting_poly_ints|,  Prev: |Alignment_of_poly_ints|,  Up: |poly_int|
==============================================================================

                                                 *Computing_bounds_on_poly_ints*

10.6 Computing bounds on 'poly_int's
------------------------------------

'poly_int' also provides routines for calculating lower and upper
bounds:

'constant_lower_bound (A)'
     Assert that A is nonnegative and return the smallest value it can
     have.

'constant_lower_bound_with_limit (A, B)'
     Return the least value A can have, given that the context in which
     A appears guarantees that the answer is no less than B.  In other
     words, the caller is asserting that A is greater than or equal to B
     even if 'known_ge (A, B)' doesn't hold.

'constant_upper_bound_with_limit (A, B)'
     Return the greatest value A can have, given that the context in
     which A appears guarantees that the answer is no greater than B.
     In other words, the caller is asserting that A is less than or
     equal to B even if 'known_le (A, B)' doesn't hold.

'lower_bound (A, B)'
     Return a value that is always less than or equal to both A and B.
     It will be the greatest such value for some indeterminate values
     but necessarily for all.

'upper_bound (A, B)'
     Return a value that is always greater than or equal to both A and
     B.  It will be the least such value for some indeterminate values
     but necessarily for all.

==============================================================================
File: gccint.info,  Node: |Converting_poly_ints|,  Next: |Miscellaneous_poly_int_routines|,  Prev: |Computing_bounds_on_poly_ints|,  Up: |poly_int|
==============================================================================

                                                          *Converting_poly_ints*

10.7 Converting 'poly_int's
---------------------------

A 'poly_int<N, T>' can be constructed from up to N individual T
coefficients, with the remaining coefficients being implicitly zero.  In
particular, this means that every 'poly_int<N, T>' can be constructed
from a single scalar T, or something compatible with T.

 Also, a 'poly_int<N, T>' can be constructed from a 'poly_int<N, U>' if
T can be constructed from U.

 The following functions provide other forms of conversion, or test
whether such a conversion would succeed.

'VALUE.is_constant ()'
     Return true if 'poly_int' VALUE is a compile-time constant.

'VALUE.is_constant (&C1)'
     Return true if 'poly_int' VALUE is a compile-time constant, storing
     it in C1 if so.  C1 must be able to hold all constant values of
     VALUE without loss of precision.

'VALUE.to_constant ()'
     Assert that VALUE is a compile-time constant and return its value.
     When using this function, please add a comment explaining why the
     condition is known to hold (for example, because an earlier phase
     of analysis rejected non-constants).

'VALUE.to_shwi (&P2)'
     Return true if 'poly_int<N, T>' VALUE can be represented without
     loss of precision as a 'poly_int<N, 'HOST_WIDE_INT'>', storing it
     in that form in P2 if so.

'VALUE.to_uhwi (&P2)'
     Return true if 'poly_int<N, T>' VALUE can be represented without
     loss of precision as a 'poly_int<N, 'unsigned HOST_WIDE_INT'>',
     storing it in that form in P2 if so.

'VALUE.force_shwi ()'
     Forcibly convert each coefficient of 'poly_int<N, T>' VALUE to
     'HOST_WIDE_INT', truncating any that are out of range.  Return the
     result as a 'poly_int<N, 'HOST_WIDE_INT'>'.

'VALUE.force_uhwi ()'
     Forcibly convert each coefficient of 'poly_int<N, T>' VALUE to
     'unsigned HOST_WIDE_INT', truncating any that are out of range.
     Return the result as a 'poly_int<N, 'unsigned HOST_WIDE_INT'>'.

'wi::shwi (VALUE, PRECISION)'
     Return a 'poly_int' with the same value as VALUE, but with the
     coefficients converted from 'HOST_WIDE_INT' to 'wide_int'.
     PRECISION specifies the precision of the 'wide_int' cofficients; if
     this is wider than a 'HOST_WIDE_INT', the coefficients of VALUE
     will be sign-extended to fit.

'wi::uhwi (VALUE, PRECISION)'
     Like 'wi::shwi', except that VALUE has coefficients of type
     'unsigned HOST_WIDE_INT'.  If PRECISION is wider than a
     'HOST_WIDE_INT', the coefficients of VALUE will be zero-extended to
     fit.

'wi::sext (VALUE, PRECISION)'
     Return a 'poly_int' of the same type as VALUE, sign-extending every
     coefficient from the low PRECISION bits.  This in effect applies
     'wi::sext' to each coefficient individually.

'wi::zext (VALUE, PRECISION)'
     Like 'wi::sext', but for zero extension.

'poly_wide_int::from (VALUE, PRECISION, SIGN)'
     Convert VALUE to a 'poly_wide_int' in which each coefficient has
     PRECISION bits.  Extend the coefficients according to SIGN if the
     coefficients have fewer bits.

'poly_offset_int::from (VALUE, SIGN)'
     Convert VALUE to a 'poly_offset_int', extending its coefficients
     according to SIGN if they have fewer bits than 'offset_int'.

'poly_widest_int::from (VALUE, SIGN)'
     Convert VALUE to a 'poly_widest_int', extending its coefficients
     according to SIGN if they have fewer bits than 'widest_int'.

==============================================================================
File: gccint.info,  Node: |Miscellaneous_poly_int_routines|,  Next: |Guidelines_for_using_poly_int|,  Prev: |Converting_poly_ints|,  Up: |poly_int|
==============================================================================

                                               *Miscellaneous_poly_int_routines*

10.8 Miscellaneous 'poly_int' routines
--------------------------------------

'print_dec (VALUE, FILE, SIGN)'
'print_dec (VALUE, FILE)'
     Print VALUE to FILE as a decimal value, interpreting the
     coefficients according to SIGN.  The final argument is optional if
     VALUE has an inherent sign; for example, 'poly_int64' values print
     as signed by default and 'poly_uint64' values print as unsigned by
     default.

     This is a simply a 'poly_int' version of a wide-int routine.

==============================================================================
File: gccint.info,  Node: |Guidelines_for_using_poly_int|,  Prev: |Miscellaneous_poly_int_routines|,  Up: |poly_int|
==============================================================================

                                                 *Guidelines_for_using_poly_int*

10.9 Guidelines for using 'poly_int'
------------------------------------

One of the main design goals of 'poly_int' was to make it easy to write
target-independent code that handles variable-sized registers even when
the current target has fixed-sized registers.  There are two aspects to
this:

   * The set of 'poly_int' operations should be complete enough that the
     question in most cases becomes "Can we do this operation on these
     particular 'poly_int' values?  If not, bail out" rather than "Are
     these 'poly_int' values constant?  If so, do the operation,
     otherwise bail out".

   * If target-independent code compiles and runs correctly on a target
     with one value of 'NUM_POLY_INT_COEFFS', and if the code does not
     use asserting functions like 'to_constant', it is reasonable to
     assume that the code also works on targets with other values of
     'NUM_POLY_INT_COEFFS'.  There is no need to check this during
     everyday development.

 So the general principle is: if target-independent code is dealing with
a 'poly_int' value, it is better to operate on it as a 'poly_int' if at
all possible, choosing conservatively-correct behavior if a particular
operation fails.  For example, the following code handles an index 'pos'
into a sequence of vectors that each have 'nunits' elements:

     /* Calculate which vector contains the result, and which lane of
        that vector we need.  */
     if (!can_div_trunc_p (pos, nunits, &vec_entry, &vec_index))
       {
         if (dump_enabled_p ())
           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
                            "Cannot determine which vector holds the"
                            " final result.\n");
         return false;
       }

 However, there are some contexts in which operating on a 'poly_int' is
not possible or does not make sense.  One example is when handling
static initializers, since no current target supports the concept of a
variable-length static initializer.  In these situations, a reasonable
fallback is:

     if (POLY_VALUE.is_constant (&CONST_VALUE))
       {
         ...
         /* Operate on CONST_VALUE.  */
         ...
       }
     else
       {
         ...
         /* Conservatively correct fallback.  */
         ...
       }

 'poly_int' also provides some asserting functions like 'to_constant'.
Please only use these functions if there is a good theoretical reason to
believe that the assertion cannot fire.  For example, if some work is
divided into an analysis phase and an implementation phase, the analysis
phase might reject inputs that are not 'is_constant', in which case the
implementation phase can reasonably use 'to_constant' on the remaining
inputs.  The assertions should not be used to discover whether a
condition ever occurs "in the field"; in other words, they should not be
used to restrict code to constants at first, with the intention of only
implementing a 'poly_int' version if a user hits the assertion.

 If a particular asserting function like 'to_constant' is needed more
than once for the same reason, it is probably worth adding a helper
function or macro for that situation, so that the justification only
needs to be given once.  For example:

     /* Return the size of an element in a vector of size SIZE, given that
        the vector has NELTS elements.  The return value is in the same units
        as SIZE (either bits or bytes).

        to_constant () is safe in this situation because vector elements are
        always constant-sized scalars.  */
     #define vector_element_size(SIZE, NELTS) \
       (exact_div (SIZE, NELTS).to_constant ())

 Target-specific code in 'config/CPU' only needs to handle non-constant
'poly_int's if 'NUM_POLY_INT_COEFFS' is greater than one.  For other
targets, 'poly_int' degenerates to a compile-time constant and is often
interchangable with a normal scalar integer.  There are two main
exceptions:

   * Sometimes an explicit cast to an integer type might be needed, such
     as to resolve ambiguities in a '?:' expression, or when passing
     values through '...' to things like print functions.

   * Target macros are included in target-independent code and so do not
     have access to the implicit conversion to a scalar integer.  If
     this becomes a problem for a particular target macro, the possible
     solutions, in order of preference, are:

        * Convert the target macro to a target hook (for all targets).

        * Put the target's implementation of the target macro in its
          'CPU.c' file and call it from the target macro in the 'CPU.h'
          file.

        * Add 'to_constant ()' calls where necessary.  The previous
          option is preferable because it will help with any future
          conversion of the macro to a hook.

==============================================================================
File: gccint.info,  Node: |GENERIC|,  Next: |GIMPLE|,  Prev: |poly_int|,  Up: |Top|
==============================================================================

                                                                       *GENERIC*

11 GENERIC
==========

The purpose of GENERIC is simply to provide a language-independent way
of representing an entire function in trees.  To this end, it was
necessary to add a few new tree codes to the back end, but almost
everything was already there.  If you can express it with the codes in
'gcc/tree.def', it's GENERIC.

 Early on, there was a great deal of debate about how to think about
statements in a tree IL.  In GENERIC, a statement is defined as any
expression whose value, if any, is ignored.  A statement will always
have 'TREE_SIDE_EFFECTS' set (or it will be discarded), but a
non-statement expression may also have side effects.  A 'CALL_EXPR', for
instance.

 It would be possible for some local optimizations to work on the
GENERIC form of a function; indeed, the adapted tree inliner works fine
on GENERIC, but the current compiler performs inlining after lowering to
GIMPLE (a restricted form described in the next section).  Indeed,
currently the frontends perform this lowering before handing off to
'tree_rest_of_compilation', but this seems inelegant.

MENU

* |Deficiencies|::                Topics net yet covered in this document.
* |Tree_overview|::               All about 'tree's.
* |Types|::                       Fundamental and aggregate types.
* |Declarations|::                Type declarations and variables.
* |Attributes|::                  Declaration and type attributes.
* Expressions: Expression trees.            Operating on data.
* |Statements|::                  Control flow and related trees.
* |Functions|::           	Function bodies, linkage, and other aspects.
* |Language_dependent_trees|::    Topics and trees specific to language front ends.
* |C_and_C++_Trees|::     	Trees specific to C and C++.

==============================================================================
File: gccint.info,  Node: |Deficiencies|,  Next: |Tree_overview|,  Up: |GENERIC|
==============================================================================

                                                                  *Deficiencies*

11.1 Deficiencies
-----------------

There are many places in which this document is incomplet and incorrekt.
It is, as of yet, only _preliminary_ documentation.

==============================================================================
File: gccint.info,  Node: |Tree_overview|,  Next: |Types|,  Prev: |Deficiencies|,  Up: |GENERIC|
==============================================================================

                                                                 *Tree_overview*

11.2 Overview
-------------

The central data structure used by the internal representation is the
'tree'.  These nodes, while all of the C type 'tree', are of many
varieties.  A 'tree' is a pointer type, but the object to which it
points may be of a variety of types.  From this point forward, we will
refer to trees in ordinary type, rather than in 'this font', except when
talking about the actual C type 'tree'.

 You can tell what kind of node a particular tree is by using the
'TREE_CODE' macro.  Many, many macros take trees as input and return
trees as output.  However, most macros require a certain kind of tree
node as input.  In other words, there is a type-system for trees, but it
is not reflected in the C type-system.

 For safety, it is useful to configure GCC with '--enable-checking'.
Although this results in a significant performance penalty (since all
tree types are checked at run-time), and is therefore inappropriate in a
release version, it is extremely helpful during the development process.

 Many macros behave as predicates.  Many, although not all, of these
predicates end in '_P'.  Do not rely on the result type of these macros
being of any particular type.  You may, however, rely on the fact that
the type can be compared to '0', so that statements like
     if (TEST_P (t) && !TEST_P (y))
       x = 1;
and
     int i = (TEST_P (t) != 0);
are legal.  Macros that return 'int' values now may be changed to return
'tree' values, or other pointers in the future.  Even those that
continue to return 'int' may return multiple nonzero codes where
previously they returned only zero and one.  Therefore, you should not
write code like
     if (TEST_P (t) == 1)
as this code is not guaranteed to work correctly in the future.

 You should not take the address of values returned by the macros or
functions described here.  In particular, no guarantee is given that the
values are lvalues.

 In general, the names of macros are all in uppercase, while the names
of functions are entirely in lowercase.  There are rare exceptions to
this rule.  You should assume that any macro or function whose name is
made up entirely of uppercase letters may evaluate its arguments more
than once.  You may assume that a macro or function whose name is made
up entirely of lowercase letters will evaluate its arguments only once.

 The 'error_mark_node' is a special tree.  Its tree code is
'ERROR_MARK', but since there is only ever one node with that code, the
usual practice is to compare the tree against 'error_mark_node'.  (This
test is just a test for pointer equality.)  If an error has occurred
during front-end processing the flag 'errorcount' will be set.  If the
front end has encountered code it cannot handle, it will issue a message
to the user and set 'sorrycount'.  When these flags are set, any macro
or function which normally returns a tree of a particular kind may
instead return the 'error_mark_node'.  Thus, if you intend to do any
processing of erroneous code, you must be prepared to deal with the
'error_mark_node'.

 Occasionally, a particular tree slot (like an operand to an expression,
or a particular field in a declaration) will be referred to as "reserved
for the back end".  These slots are used to store RTL when the tree is
converted to RTL for use by the GCC back end.  However, if that process
is not taking place (e.g., if the front end is being hooked up to an
intelligent editor), then those slots may be used by the back end
presently in use.

 If you encounter situations that do not match this documentation, such
as tree nodes of types not mentioned here, or macros documented to
return entities of a particular kind that instead return entities of
some different kind, you have found a bug, either in the front end or in
the documentation.  Please report these bugs as you would any other bug.

MENU

* |Macros_and_Functions|::Macros and functions that can be used with all trees.
* |Identifiers|::         The names of things.
* |Containers|::          Lists and vectors.

==============================================================================
File: gccint.info,  Node: |Macros_and_Functions|,  Next: |Identifiers|,  Up: |Tree_overview|
==============================================================================

                                                          *Macros_and_Functions*

11.2.1 Trees
------------

All GENERIC trees have two fields in common.  First, 'TREE_CHAIN' is a
pointer that can be used as a singly-linked list to other trees.  The
other is 'TREE_TYPE'.  Many trees store the type of an expression or
declaration in this field.

 These are some other functions for handling trees:

'tree_size'
     Return the number of bytes a tree takes.

'build0'
'build1'
'build2'
'build3'
'build4'
'build5'
'build6'

     These functions build a tree and supply values to put in each
     parameter.  The basic signature is 'code, type, [operands]'.
     'code' is the 'TREE_CODE', and 'type' is a tree representing the
     'TREE_TYPE'.  These are followed by the operands, each of which is
     also a tree.

==============================================================================
File: gccint.info,  Node: |Identifiers|,  Next: |Containers|,  Prev: |Macros_and_Functions|,  Up: |Tree_overview|
==============================================================================

                                                                   *Identifiers*

11.2.2 Identifiers
------------------

An 'IDENTIFIER_NODE' represents a slightly more general concept than the
standard C or C++ concept of identifier.  In particular, an
'IDENTIFIER_NODE' may contain a '$', or other extraordinary characters.

 There are never two distinct 'IDENTIFIER_NODE's representing the same
identifier.  Therefore, you may use pointer equality to compare
'IDENTIFIER_NODE's, rather than using a routine like 'strcmp'.  Use
'get_identifier' to obtain the unique 'IDENTIFIER_NODE' for a supplied
string.

 You can use the following macros to access identifiers:
'IDENTIFIER_POINTER'
     The string represented by the identifier, represented as a 'char*'.
     This string is always 'NUL'-terminated, and contains no embedded
     'NUL' characters.

'IDENTIFIER_LENGTH'
     The length of the string returned by 'IDENTIFIER_POINTER', not
     including the trailing 'NUL'.  This value of 'IDENTIFIER_LENGTH
     (x)' is always the same as 'strlen (IDENTIFIER_POINTER (x))'.

'IDENTIFIER_OPNAME_P'
     This predicate holds if the identifier represents the name of an
     overloaded operator.  In this case, you should not depend on the
     contents of either the 'IDENTIFIER_POINTER' or the
     'IDENTIFIER_LENGTH'.

'IDENTIFIER_TYPENAME_P'
     This predicate holds if the identifier represents the name of a
     user-defined conversion operator.  In this case, the 'TREE_TYPE' of
     the 'IDENTIFIER_NODE' holds the type to which the conversion
     operator converts.

==============================================================================
File: gccint.info,  Node: |Containers|,  Prev: |Identifiers|,  Up: |Tree_overview|
==============================================================================

                                                                    *Containers*

11.2.3 Containers
-----------------

Two common container data structures can be represented directly with
tree nodes.  A 'TREE_LIST' is a singly linked list containing two trees
per node.  These are the 'TREE_PURPOSE' and 'TREE_VALUE' of each node.
(Often, the 'TREE_PURPOSE' contains some kind of tag, or additional
information, while the 'TREE_VALUE' contains the majority of the
payload.  In other cases, the 'TREE_PURPOSE' is simply 'NULL_TREE',
while in still others both the 'TREE_PURPOSE' and 'TREE_VALUE' are of
equal stature.)  Given one 'TREE_LIST' node, the next node is found by
following the 'TREE_CHAIN'.  If the 'TREE_CHAIN' is 'NULL_TREE', then
you have reached the end of the list.

 A 'TREE_VEC' is a simple vector.  The 'TREE_VEC_LENGTH' is an integer
(not a tree) giving the number of nodes in the vector.  The nodes
themselves are accessed using the 'TREE_VEC_ELT' macro, which takes two
arguments.  The first is the 'TREE_VEC' in question; the second is an
integer indicating which element in the vector is desired.  The elements
are indexed from zero.

==============================================================================
File: gccint.info,  Node: |Types|,  Next: |Declarations|,  Prev: |Tree_overview|,  Up: |GENERIC|
==============================================================================

                                                                         *Types*

11.3 Types
----------

All types have corresponding tree nodes.  However, you should not assume
that there is exactly one tree node corresponding to each type.  There
are often multiple nodes corresponding to the same type.

 For the most part, different kinds of types have different tree codes.
(For example, pointer types use a 'POINTER_TYPE' code while arrays use
an 'ARRAY_TYPE' code.)  However, pointers to member functions use the
'RECORD_TYPE' code.  Therefore, when writing a 'switch' statement that
depends on the code associated with a particular type, you should take
care to handle pointers to member functions under the 'RECORD_TYPE' case
label.

 The following functions and macros deal with cv-qualification of types:
'TYPE_MAIN_VARIANT'
     This macro returns the unqualified version of a type.  It may be
     applied to an unqualified type, but it is not always the identity
     function in that case.

 A few other macros and functions are usable with all types:
'TYPE_SIZE'
     The number of bits required to represent the type, represented as
     an 'INTEGER_CST'.  For an incomplete type, 'TYPE_SIZE' will be
     'NULL_TREE'.

'TYPE_ALIGN'
     The alignment of the type, in bits, represented as an 'int'.

'TYPE_NAME'
     This macro returns a declaration (in the form of a 'TYPE_DECL') for
     the type.  (Note this macro does _not_ return an 'IDENTIFIER_NODE',
     as you might expect, given its name!)  You can look at the
     'DECL_NAME' of the 'TYPE_DECL' to obtain the actual name of the
     type.  The 'TYPE_NAME' will be 'NULL_TREE' for a type that is not a
     built-in type, the result of a typedef, or a named class type.

'TYPE_CANONICAL'
     This macro returns the "canonical" type for the given type node.
     Canonical types are used to improve performance in the C++ and
     Objective-C++ front ends by allowing efficient comparison between
     two type nodes in 'same_type_p': if the 'TYPE_CANONICAL' values of
     the types are equal, the types are equivalent; otherwise, the types
     are not equivalent.  The notion of equivalence for canonical types
     is the same as the notion of type equivalence in the language
     itself.  For instance,

     When 'TYPE_CANONICAL' is 'NULL_TREE', there is no canonical type
     for the given type node.  In this case, comparison between this
     type and any other type requires the compiler to perform a deep,
     "structural" comparison to see if the two type nodes have the same
     form and properties.

     The canonical type for a node is always the most fundamental type
     in the equivalence class of types.  For instance, 'int' is its own
     canonical type.  A typedef 'I' of 'int' will have 'int' as its
     canonical type.  Similarly, 'I*' and a typedef 'IP' (defined to
     'I*') will has 'int*' as their canonical type.  When building a new
     type node, be sure to set 'TYPE_CANONICAL' to the appropriate
     canonical type.  If the new type is a compound type (built from
     other types), and any of those other types require structural
     equality, use 'SET_TYPE_STRUCTURAL_EQUALITY' to ensure that the new
     type also requires structural equality.  Finally, if for some
     reason you cannot guarantee that 'TYPE_CANONICAL' will point to the
     canonical type, use 'SET_TYPE_STRUCTURAL_EQUALITY' to make sure
     that the new type-and any type constructed based on it-requires
     structural equality.  If you suspect that the canonical type system
     is miscomparing types, pass '--param verify-canonical-types=1' to
     the compiler or configure with '--enable-checking' to force the
     compiler to verify its canonical-type comparisons against the
     structural comparisons; the compiler will then print any warnings
     if the canonical types miscompare.

'TYPE_STRUCTURAL_EQUALITY_P'
     This predicate holds when the node requires structural equality
     checks, e.g., when 'TYPE_CANONICAL' is 'NULL_TREE'.

'SET_TYPE_STRUCTURAL_EQUALITY'
     This macro states that the type node it is given requires
     structural equality checks, e.g., it sets 'TYPE_CANONICAL' to
     'NULL_TREE'.

'same_type_p'
     This predicate takes two types as input, and holds if they are the
     same type.  For example, if one type is a 'typedef' for the other,
     or both are 'typedef's for the same type.  This predicate also
     holds if the two trees given as input are simply copies of one
     another; i.e., there is no difference between them at the source
     level, but, for whatever reason, a duplicate has been made in the
     representation.  You should never use '==' (pointer equality) to
     compare types; always use 'same_type_p' instead.

 Detailed below are the various kinds of types, and the macros that can
be used to access them.  Although other kinds of types are used
elsewhere in G++, the types described here are the only ones that you
will encounter while examining the intermediate representation.

'VOID_TYPE'
     Used to represent the 'void' type.

'INTEGER_TYPE'
     Used to represent the various integral types, including 'char',
     'short', 'int', 'long', and 'long long'.  This code is not used for
     enumeration types, nor for the 'bool' type.  The 'TYPE_PRECISION'
     is the number of bits used in the representation, represented as an
     'unsigned int'.  (Note that in the general case this is not the
     same value as 'TYPE_SIZE'; suppose that there were a 24-bit integer
     type, but that alignment requirements for the ABI required 32-bit
     alignment.  Then, 'TYPE_SIZE' would be an 'INTEGER_CST' for 32,
     while 'TYPE_PRECISION' would be 24.)  The integer type is unsigned
     if 'TYPE_UNSIGNED' holds; otherwise, it is signed.

     The 'TYPE_MIN_VALUE' is an 'INTEGER_CST' for the smallest integer
     that may be represented by this type.  Similarly, the
     'TYPE_MAX_VALUE' is an 'INTEGER_CST' for the largest integer that
     may be represented by this type.

'REAL_TYPE'
     Used to represent the 'float', 'double', and 'long double' types.
     The number of bits in the floating-point representation is given by
     'TYPE_PRECISION', as in the 'INTEGER_TYPE' case.

'FIXED_POINT_TYPE'
     Used to represent the 'short _Fract', '_Fract', 'long _Fract',
     'long long _Fract', 'short _Accum', '_Accum', 'long _Accum', and
     'long long _Accum' types.  The number of bits in the fixed-point
     representation is given by 'TYPE_PRECISION', as in the
     'INTEGER_TYPE' case.  There may be padding bits, fractional bits
     and integral bits.  The number of fractional bits is given by
     'TYPE_FBIT', and the number of integral bits is given by
     'TYPE_IBIT'.  The fixed-point type is unsigned if 'TYPE_UNSIGNED'
     holds; otherwise, it is signed.  The fixed-point type is saturating
     if 'TYPE_SATURATING' holds; otherwise, it is not saturating.

'COMPLEX_TYPE'
     Used to represent GCC built-in '__complex__' data types.  The
     'TREE_TYPE' is the type of the real and imaginary parts.

'ENUMERAL_TYPE'
     Used to represent an enumeration type.  The 'TYPE_PRECISION' gives
     (as an 'int'), the number of bits used to represent the type.  If
     there are no negative enumeration constants, 'TYPE_UNSIGNED' will
     hold.  The minimum and maximum enumeration constants may be
     obtained with 'TYPE_MIN_VALUE' and 'TYPE_MAX_VALUE', respectively;
     each of these macros returns an 'INTEGER_CST'.

     The actual enumeration constants themselves may be obtained by
     looking at the 'TYPE_VALUES'.  This macro will return a
     'TREE_LIST', containing the constants.  The 'TREE_PURPOSE' of each
     node will be an 'IDENTIFIER_NODE' giving the name of the constant;
     the 'TREE_VALUE' will be an 'INTEGER_CST' giving the value assigned
     to that constant.  These constants will appear in the order in
     which they were declared.  The 'TREE_TYPE' of each of these
     constants will be the type of enumeration type itself.

'BOOLEAN_TYPE'
     Used to represent the 'bool' type.

'POINTER_TYPE'
     Used to represent pointer types, and pointer to data member types.
     The 'TREE_TYPE' gives the type to which this type points.

'REFERENCE_TYPE'
     Used to represent reference types.  The 'TREE_TYPE' gives the type
     to which this type refers.

'FUNCTION_TYPE'
     Used to represent the type of non-member functions and of static
     member functions.  The 'TREE_TYPE' gives the return type of the
     function.  The 'TYPE_ARG_TYPES' are a 'TREE_LIST' of the argument
     types.  The 'TREE_VALUE' of each node in this list is the type of
     the corresponding argument; the 'TREE_PURPOSE' is an expression for
     the default argument value, if any.  If the last node in the list
     is 'void_list_node' (a 'TREE_LIST' node whose 'TREE_VALUE' is the
     'void_type_node'), then functions of this type do not take variable
     arguments.  Otherwise, they do take a variable number of arguments.

     Note that in C (but not in C++) a function declared like 'void f()'
     is an unprototyped function taking a variable number of arguments;
     the 'TYPE_ARG_TYPES' of such a function will be 'NULL'.

'METHOD_TYPE'
     Used to represent the type of a non-static member function.  Like a
     'FUNCTION_TYPE', the return type is given by the 'TREE_TYPE'.  The
     type of '*this', i.e., the class of which functions of this type
     are a member, is given by the 'TYPE_METHOD_BASETYPE'.  The
     'TYPE_ARG_TYPES' is the parameter list, as for a 'FUNCTION_TYPE',
     and includes the 'this' argument.

'ARRAY_TYPE'
     Used to represent array types.  The 'TREE_TYPE' gives the type of
     the elements in the array.  If the array-bound is present in the
     type, the 'TYPE_DOMAIN' is an 'INTEGER_TYPE' whose 'TYPE_MIN_VALUE'
     and 'TYPE_MAX_VALUE' will be the lower and upper bounds of the
     array, respectively.  The 'TYPE_MIN_VALUE' will always be an
     'INTEGER_CST' for zero, while the 'TYPE_MAX_VALUE' will be one less
     than the number of elements in the array, i.e., the highest value
     which may be used to index an element in the array.

'RECORD_TYPE'
     Used to represent 'struct' and 'class' types, as well as pointers
     to member functions and similar constructs in other languages.
     'TYPE_FIELDS' contains the items contained in this type, each of
     which can be a 'FIELD_DECL', 'VAR_DECL', 'CONST_DECL', or
     'TYPE_DECL'.  You may not make any assumptions about the ordering
     of the fields in the type or whether one or more of them overlap.

'UNION_TYPE'
     Used to represent 'union' types.  Similar to 'RECORD_TYPE' except
     that all 'FIELD_DECL' nodes in 'TYPE_FIELD' start at bit position
     zero.

'QUAL_UNION_TYPE'
     Used to represent part of a variant record in Ada.  Similar to
     'UNION_TYPE' except that each 'FIELD_DECL' has a 'DECL_QUALIFIER'
     field, which contains a boolean expression that indicates whether
     the field is present in the object.  The type will only have one
     field, so each field's 'DECL_QUALIFIER' is only evaluated if none
     of the expressions in the previous fields in 'TYPE_FIELDS' are
     nonzero.  Normally these expressions will reference a field in the
     outer object using a 'PLACEHOLDER_EXPR'.

'LANG_TYPE'
     This node is used to represent a language-specific type.  The front
     end must handle it.

'OFFSET_TYPE'
     This node is used to represent a pointer-to-data member.  For a
     data member 'X::m' the 'TYPE_OFFSET_BASETYPE' is 'X' and the
     'TREE_TYPE' is the type of 'm'.

 There are variables whose values represent some of the basic types.
These include:
'void_type_node'
     A node for 'void'.

'integer_type_node'
     A node for 'int'.

'unsigned_type_node.'
     A node for 'unsigned int'.

'char_type_node.'
     A node for 'char'.
It may sometimes be useful to compare one of these variables with a type
in hand, using 'same_type_p'.

==============================================================================
File: gccint.info,  Node: |Declarations|,  Next: |Attributes|,  Prev: |Types|,  Up: |GENERIC|
==============================================================================

                                                                  *Declarations*

11.4 Declarations
-----------------

This section covers the various kinds of declarations that appear in the
internal representation, except for declarations of functions
(represented by 'FUNCTION_DECL' nodes), which are described in *note
Functions::.

MENU

* |Working_with_declarations|::  Macros and functions that work on
declarations.
* |Internal_structure|:: How declaration nodes are represented.

==============================================================================
File: gccint.info,  Node: |Working_with_declarations|,  Next: |Internal_structure|,  Up: Declarations
==============================================================================

                                                     *Working_with_declarations*

11.4.1 Working with declarations
--------------------------------

Some macros can be used with any kind of declaration.  These include:
'DECL_NAME'
     This macro returns an 'IDENTIFIER_NODE' giving the name of the
     entity.

'TREE_TYPE'
     This macro returns the type of the entity declared.

'EXPR_FILENAME'
     This macro returns the name of the file in which the entity was
     declared, as a 'char*'.  For an entity declared implicitly by the
     compiler (like '__builtin_memcpy'), this will be the string
     '"<internal>"'.

'EXPR_LINENO'
     This macro returns the line number at which the entity was
     declared, as an 'int'.

'DECL_ARTIFICIAL'
     This predicate holds if the declaration was implicitly generated by
     the compiler.  For example, this predicate will hold of an
     implicitly declared member function, or of the 'TYPE_DECL'
     implicitly generated for a class type.  Recall that in C++ code
     like:
          struct S {};
     is roughly equivalent to C code like:
          struct S {};
          typedef struct S S;
     The implicitly generated 'typedef' declaration is represented by a
     'TYPE_DECL' for which 'DECL_ARTIFICIAL' holds.

 The various kinds of declarations include:
'LABEL_DECL'
     These nodes are used to represent labels in function bodies.  For
     more information, see *note Functions::.  These nodes only appear
     in block scopes.

'CONST_DECL'
     These nodes are used to represent enumeration constants.  The value
     of the constant is given by 'DECL_INITIAL' which will be an
     'INTEGER_CST' with the same type as the 'TREE_TYPE' of the
     'CONST_DECL', i.e., an 'ENUMERAL_TYPE'.

'RESULT_DECL'
     These nodes represent the value returned by a function.  When a
     value is assigned to a 'RESULT_DECL', that indicates that the value
     should be returned, via bitwise copy, by the function.  You can use
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
