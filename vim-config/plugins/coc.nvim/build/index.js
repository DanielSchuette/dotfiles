(function () {
  var v = process.version
  var parts = v.slice(1).split('.')
  var major = parseInt(parts[0], 10)
  var minor = parseInt(parts[1], 10)
  if (major < 12 || (major == 12 && minor < 12)) {
    throw new Error('coc.nvim requires node >= v12.12.0, current version: ' + v)
  }
})(); 
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse5(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse5(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter2 = createDebug.formatters[format2];
            if (typeof formatter2 === "function") {
              const val = args[index];
              match = formatter2.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name2)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os10 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os10.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util4 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util4.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util4.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util4.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util4.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports2, module2) {
    "use strict";
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      var refs = [];
      var refsNew = [];
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            var index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/log4js/lib/configuration.js
var require_configuration = __commonJS({
  "node_modules/log4js/lib/configuration.js"(exports2, module2) {
    var util4 = require("util");
    var debug = require_src()("log4js:configuration");
    var preProcessingListeners = [];
    var listeners = [];
    var not = (thing) => !thing;
    var anObject = (thing) => thing && typeof thing === "object" && !Array.isArray(thing);
    var validIdentifier = (thing) => /^[A-Za-z][A-Za-z0-9_]*$/g.test(thing);
    var anInteger = (thing) => thing && typeof thing === "number" && Number.isInteger(thing);
    var addListener = (fn) => {
      listeners.push(fn);
      debug(`Added listener, now ${listeners.length} listeners`);
    };
    var addPreProcessingListener = (fn) => {
      preProcessingListeners.push(fn);
      debug(`Added pre-processing listener, now ${preProcessingListeners.length} listeners`);
    };
    var throwExceptionIf = (config, checks, message) => {
      const tests = Array.isArray(checks) ? checks : [checks];
      tests.forEach((test) => {
        if (test) {
          throw new Error(`Problem with log4js configuration: (${util4.inspect(config, { depth: 5 })}) - ${message}`);
        }
      });
    };
    var configure = (candidate) => {
      debug("New configuration to be validated: ", candidate);
      throwExceptionIf(candidate, not(anObject(candidate)), "must be an object.");
      debug(`Calling pre-processing listeners (${preProcessingListeners.length})`);
      preProcessingListeners.forEach((listener) => listener(candidate));
      debug("Configuration pre-processing finished.");
      debug(`Calling configuration listeners (${listeners.length})`);
      listeners.forEach((listener) => listener(candidate));
      debug("Configuration finished.");
    };
    module2.exports = {
      configure,
      addListener,
      addPreProcessingListener,
      throwExceptionIf,
      anObject,
      anInteger,
      validIdentifier,
      not
    };
  }
});

// node_modules/date-format/lib/index.js
var require_lib = __commonJS({
  "node_modules/date-format/lib/index.js"(exports2, module2) {
    "use strict";
    function padWithZeros(vNumber, width) {
      var numAsString = vNumber.toString();
      while (numAsString.length < width) {
        numAsString = "0" + numAsString;
      }
      return numAsString;
    }
    function addZero(vNumber) {
      return padWithZeros(vNumber, 2);
    }
    function offset(timezoneOffset) {
      var os10 = Math.abs(timezoneOffset);
      var h = String(Math.floor(os10 / 60));
      var m = String(os10 % 60);
      if (h.length === 1) {
        h = "0" + h;
      }
      if (m.length === 1) {
        m = "0" + m;
      }
      return timezoneOffset < 0 ? "+" + h + m : "-" + h + m;
    }
    function asString(format2, date) {
      if (typeof format2 !== "string") {
        date = format2;
        format2 = module2.exports.ISO8601_FORMAT;
      }
      if (!date) {
        date = module2.exports.now();
      }
      var vDay = addZero(date.getDate());
      var vMonth = addZero(date.getMonth() + 1);
      var vYearLong = addZero(date.getFullYear());
      var vYearShort = addZero(vYearLong.substring(2, 4));
      var vYear = format2.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
      var vHour = addZero(date.getHours());
      var vMinute = addZero(date.getMinutes());
      var vSecond = addZero(date.getSeconds());
      var vMillisecond = padWithZeros(date.getMilliseconds(), 3);
      var vTimeZone = offset(date.getTimezoneOffset());
      var formatted = format2.replace(/dd/g, vDay).replace(/MM/g, vMonth).replace(/y{1,4}/g, vYear).replace(/hh/g, vHour).replace(/mm/g, vMinute).replace(/ss/g, vSecond).replace(/SSS/g, vMillisecond).replace(/O/g, vTimeZone);
      return formatted;
    }
    function setDatePart(date, part, value, local) {
      date["set" + (local ? "" : "UTC") + part](value);
    }
    function extractDateParts(pattern, str, missingValuesDate) {
      var local = pattern.indexOf("O") < 0;
      var matchers = [
        {
          pattern: /y{1,4}/,
          regexp: "\\d{1,4}",
          fn: function(date2, value) {
            setDatePart(date2, "FullYear", value, local);
          }
        },
        {
          pattern: /MM/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Month", value - 1, local);
          }
        },
        {
          pattern: /dd/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Date", value, local);
          }
        },
        {
          pattern: /hh/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Hours", value, local);
          }
        },
        {
          pattern: /mm/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Minutes", value, local);
          }
        },
        {
          pattern: /ss/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Seconds", value, local);
          }
        },
        {
          pattern: /SSS/,
          regexp: "\\d\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Milliseconds", value, local);
          }
        },
        {
          pattern: /O/,
          regexp: "[+-]\\d{3,4}|Z",
          fn: function(date2, value) {
            if (value === "Z") {
              value = 0;
            }
            var offset2 = Math.abs(value);
            var timezoneOffset = (value > 0 ? -1 : 1) * (offset2 % 100 + Math.floor(offset2 / 100) * 60);
            date2.setUTCMinutes(date2.getUTCMinutes() + timezoneOffset);
          }
        }
      ];
      var parsedPattern = matchers.reduce(function(p, m) {
        if (m.pattern.test(p.regexp)) {
          m.index = p.regexp.match(m.pattern).index;
          p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
        } else {
          m.index = -1;
        }
        return p;
      }, { regexp: pattern, index: [] });
      var dateFns = matchers.filter(function(m) {
        return m.index > -1;
      });
      dateFns.sort(function(a, b) {
        return a.index - b.index;
      });
      var matcher = new RegExp(parsedPattern.regexp);
      var matches = matcher.exec(str);
      if (matches) {
        var date = missingValuesDate || module2.exports.now();
        dateFns.forEach(function(f, i) {
          f.fn(date, matches[i + 1]);
        });
        return date;
      }
      throw new Error("String '" + str + "' could not be parsed as '" + pattern + "'");
    }
    function parse5(pattern, str, missingValuesDate) {
      if (!pattern) {
        throw new Error("pattern must be supplied");
      }
      return extractDateParts(pattern, str, missingValuesDate);
    }
    function now() {
      return new Date();
    }
    module2.exports = asString;
    module2.exports.asString = asString;
    module2.exports.parse = parse5;
    module2.exports.now = now;
    module2.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
    module2.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
    module2.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
    module2.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
  }
});

// node_modules/log4js/lib/layouts.js
var require_layouts = __commonJS({
  "node_modules/log4js/lib/layouts.js"(exports2, module2) {
    var dateFormat = require_lib();
    var os10 = require("os");
    var util4 = require("util");
    var path36 = require("path");
    var styles3 = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [90, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [91, 39],
      yellow: [33, 39]
    };
    function colorizeStart(style2) {
      return style2 ? `[${styles3[style2][0]}m` : "";
    }
    function colorizeEnd(style2) {
      return style2 ? `[${styles3[style2][1]}m` : "";
    }
    function colorize(str, style2) {
      return colorizeStart(style2) + str + colorizeEnd(style2);
    }
    function timestampLevelAndCategory(loggingEvent, colour) {
      return colorize(util4.format("[%s] [%s] %s - ", dateFormat.asString(loggingEvent.startTime), loggingEvent.level.toString(), loggingEvent.categoryName), colour);
    }
    function basicLayout(loggingEvent) {
      return timestampLevelAndCategory(loggingEvent) + util4.format(...loggingEvent.data);
    }
    function colouredLayout(loggingEvent) {
      return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util4.format(...loggingEvent.data);
    }
    function messagePassThroughLayout(loggingEvent) {
      return util4.format(...loggingEvent.data);
    }
    function dummyLayout(loggingEvent) {
      return loggingEvent.data[0];
    }
    function patternLayout(pattern, tokens) {
      const TTCC_CONVERSION_PATTERN = "%r %p %c - %m%n";
      const regex = /%(-?[0-9]+)?(\.?-?[0-9]+)?([[\]cdhmnprzxXyflos%])(\{([^}]+)\})?|([^%]+)/;
      pattern = pattern || TTCC_CONVERSION_PATTERN;
      function categoryName(loggingEvent, specifier) {
        let loggerName = loggingEvent.categoryName;
        if (specifier) {
          const precision = parseInt(specifier, 10);
          const loggerNameBits = loggerName.split(".");
          if (precision < loggerNameBits.length) {
            loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join(".");
          }
        }
        return loggerName;
      }
      function formatAsDate(loggingEvent, specifier) {
        let format2 = dateFormat.ISO8601_FORMAT;
        if (specifier) {
          format2 = specifier;
          if (format2 === "ISO8601") {
            format2 = dateFormat.ISO8601_FORMAT;
          } else if (format2 === "ISO8601_WITH_TZ_OFFSET") {
            format2 = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;
          } else if (format2 === "ABSOLUTE") {
            format2 = dateFormat.ABSOLUTETIME_FORMAT;
          } else if (format2 === "DATE") {
            format2 = dateFormat.DATETIME_FORMAT;
          }
        }
        return dateFormat.asString(format2, loggingEvent.startTime);
      }
      function hostname() {
        return os10.hostname().toString();
      }
      function formatMessage(loggingEvent) {
        return util4.format(...loggingEvent.data);
      }
      function endOfLine() {
        return os10.EOL;
      }
      function logLevel(loggingEvent) {
        return loggingEvent.level.toString();
      }
      function startTime(loggingEvent) {
        return dateFormat.asString("hh:mm:ss", loggingEvent.startTime);
      }
      function startColour(loggingEvent) {
        return colorizeStart(loggingEvent.level.colour);
      }
      function endColour(loggingEvent) {
        return colorizeEnd(loggingEvent.level.colour);
      }
      function percent() {
        return "%";
      }
      function pid(loggingEvent) {
        return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();
      }
      function clusterInfo() {
        return pid();
      }
      function userDefined(loggingEvent, specifier) {
        if (typeof tokens[specifier] !== "undefined") {
          return typeof tokens[specifier] === "function" ? tokens[specifier](loggingEvent) : tokens[specifier];
        }
        return null;
      }
      function contextDefined(loggingEvent, specifier) {
        const resolver = loggingEvent.context[specifier];
        if (typeof resolver !== "undefined") {
          return typeof resolver === "function" ? resolver(loggingEvent) : resolver;
        }
        return null;
      }
      function fileName(loggingEvent, specifier) {
        let filename = loggingEvent.fileName || "";
        if (specifier) {
          const fileDepth = parseInt(specifier, 10);
          const fileList = filename.split(path36.sep);
          if (fileList.length > fileDepth) {
            filename = fileList.slice(-fileDepth).join(path36.sep);
          }
        }
        return filename;
      }
      function lineNumber(loggingEvent) {
        return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : "";
      }
      function columnNumber(loggingEvent) {
        return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : "";
      }
      function callStack(loggingEvent) {
        return loggingEvent.callStack || "";
      }
      const replacers = {
        c: categoryName,
        d: formatAsDate,
        h: hostname,
        m: formatMessage,
        n: endOfLine,
        p: logLevel,
        r: startTime,
        "[": startColour,
        "]": endColour,
        y: clusterInfo,
        z: pid,
        "%": percent,
        x: userDefined,
        X: contextDefined,
        f: fileName,
        l: lineNumber,
        o: columnNumber,
        s: callStack
      };
      function replaceToken(conversionCharacter, loggingEvent, specifier) {
        return replacers[conversionCharacter](loggingEvent, specifier);
      }
      function truncate(truncation, toTruncate) {
        let len;
        if (truncation) {
          len = parseInt(truncation.substr(1), 10);
          return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);
        }
        return toTruncate;
      }
      function pad2(padding, toPad) {
        let len;
        if (padding) {
          if (padding.charAt(0) === "-") {
            len = parseInt(padding.substr(1), 10);
            while (toPad.length < len) {
              toPad += " ";
            }
          } else {
            len = parseInt(padding, 10);
            while (toPad.length < len) {
              toPad = ` ${toPad}`;
            }
          }
        }
        return toPad;
      }
      function truncateAndPad(toTruncAndPad, truncation, padding) {
        let replacement = toTruncAndPad;
        replacement = truncate(truncation, replacement);
        replacement = pad2(padding, replacement);
        return replacement;
      }
      return function(loggingEvent) {
        let formattedString = "";
        let result;
        let searchString = pattern;
        while ((result = regex.exec(searchString)) !== null) {
          const padding = result[1];
          const truncation = result[2];
          const conversionCharacter = result[3];
          const specifier = result[5];
          const text = result[6];
          if (text) {
            formattedString += text.toString();
          } else {
            const replacement = replaceToken(conversionCharacter, loggingEvent, specifier);
            formattedString += truncateAndPad(replacement, truncation, padding);
          }
          searchString = searchString.substr(result.index + result[0].length);
        }
        return formattedString;
      };
    }
    var layoutMakers = {
      messagePassThrough() {
        return messagePassThroughLayout;
      },
      basic() {
        return basicLayout;
      },
      colored() {
        return colouredLayout;
      },
      coloured() {
        return colouredLayout;
      },
      pattern(config) {
        return patternLayout(config && config.pattern, config && config.tokens);
      },
      dummy() {
        return dummyLayout;
      }
    };
    module2.exports = {
      basicLayout,
      messagePassThroughLayout,
      patternLayout,
      colouredLayout,
      coloredLayout: colouredLayout,
      dummyLayout,
      addLayout(name2, serializerGenerator) {
        layoutMakers[name2] = serializerGenerator;
      },
      layout(name2, config) {
        return layoutMakers[name2] && layoutMakers[name2](config);
      }
    };
  }
});

// node_modules/log4js/lib/levels.js
var require_levels = __commonJS({
  "node_modules/log4js/lib/levels.js"(exports2, module2) {
    var configuration = require_configuration();
    var validColours = [
      "white",
      "grey",
      "black",
      "blue",
      "cyan",
      "green",
      "magenta",
      "red",
      "yellow"
    ];
    var Level = class {
      constructor(level, levelStr, colour) {
        this.level = level;
        this.levelStr = levelStr;
        this.colour = colour;
      }
      toString() {
        return this.levelStr;
      }
      static getLevel(sArg, defaultLevel) {
        if (!sArg) {
          return defaultLevel;
        }
        if (sArg instanceof Level) {
          return sArg;
        }
        if (sArg instanceof Object && sArg.levelStr) {
          sArg = sArg.levelStr;
        }
        return Level[sArg.toString().toUpperCase()] || defaultLevel;
      }
      static addLevels(customLevels) {
        if (customLevels) {
          const levels = Object.keys(customLevels);
          levels.forEach((l) => {
            const levelStr = l.toUpperCase();
            Level[levelStr] = new Level(customLevels[l].value, levelStr, customLevels[l].colour);
            const existingLevelIndex = Level.levels.findIndex((lvl) => lvl.levelStr === levelStr);
            if (existingLevelIndex > -1) {
              Level.levels[existingLevelIndex] = Level[levelStr];
            } else {
              Level.levels.push(Level[levelStr]);
            }
          });
          Level.levels.sort((a, b) => a.level - b.level);
        }
      }
      isLessThanOrEqualTo(otherLevel) {
        if (typeof otherLevel === "string") {
          otherLevel = Level.getLevel(otherLevel);
        }
        return this.level <= otherLevel.level;
      }
      isGreaterThanOrEqualTo(otherLevel) {
        if (typeof otherLevel === "string") {
          otherLevel = Level.getLevel(otherLevel);
        }
        return this.level >= otherLevel.level;
      }
      isEqualTo(otherLevel) {
        if (typeof otherLevel === "string") {
          otherLevel = Level.getLevel(otherLevel);
        }
        return this.level === otherLevel.level;
      }
    };
    Level.levels = [];
    Level.addLevels({
      ALL: { value: Number.MIN_VALUE, colour: "grey" },
      TRACE: { value: 5e3, colour: "blue" },
      DEBUG: { value: 1e4, colour: "cyan" },
      INFO: { value: 2e4, colour: "green" },
      WARN: { value: 3e4, colour: "yellow" },
      ERROR: { value: 4e4, colour: "red" },
      FATAL: { value: 5e4, colour: "magenta" },
      MARK: { value: 9007199254740992, colour: "grey" },
      OFF: { value: Number.MAX_VALUE, colour: "grey" }
    });
    configuration.addListener((config) => {
      const levelConfig = config.levels;
      if (levelConfig) {
        configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig)), "levels must be an object");
        const newLevels = Object.keys(levelConfig);
        newLevels.forEach((l) => {
          configuration.throwExceptionIf(config, configuration.not(configuration.validIdentifier(l)), `level name "${l}" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`);
          configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig[l])), `level "${l}" must be an object`);
          configuration.throwExceptionIf(config, configuration.not(levelConfig[l].value), `level "${l}" must have a 'value' property`);
          configuration.throwExceptionIf(config, configuration.not(configuration.anInteger(levelConfig[l].value)), `level "${l}".value must have an integer value`);
          configuration.throwExceptionIf(config, configuration.not(levelConfig[l].colour), `level "${l}" must have a 'colour' property`);
          configuration.throwExceptionIf(config, configuration.not(validColours.indexOf(levelConfig[l].colour) > -1), `level "${l}".colour must be one of ${validColours.join(", ")}`);
        });
      }
    });
    configuration.addListener((config) => {
      Level.addLevels(config.levels);
    });
    module2.exports = Level;
  }
});

// node_modules/flatted/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  default: () => esm_default,
  parse: () => parse,
  stringify: () => stringify
});
var Flatted, esm_default, parse, stringify;
var init_esm = __esm({
  "node_modules/flatted/esm/index.js"() {
    Flatted = function(Primitive, primitive) {
      var Flatted2 = {
        parse: function parse5(text, reviver) {
          var input = JSON.parse(text, Primitives).map(primitives);
          var value = input[0];
          var $ = reviver || noop;
          var tmp = typeof value === "object" && value ? revive(input, new Set(), value, $) : value;
          return $.call({ "": tmp }, "", tmp);
        },
        stringify: function stringify3(value, replacer, space) {
          for (var firstRun, known = new Map(), input = [], output = [], $ = replacer && typeof replacer === typeof input ? function(k, v) {
            if (k === "" || -1 < replacer.indexOf(k))
              return v;
          } : replacer || noop, i = +set(known, input, $.call({ "": value }, "", value)), replace = function(key, value2) {
            if (firstRun) {
              firstRun = !firstRun;
              return value2;
            }
            var after = $.call(this, key, value2);
            switch (typeof after) {
              case "object":
                if (after === null)
                  return after;
              case primitive:
                return known.get(after) || set(known, input, after);
            }
            return after;
          }; i < input.length; i++) {
            firstRun = true;
            output[i] = JSON.stringify(input[i], replace, space);
          }
          return "[" + output.join(",") + "]";
        }
      };
      return Flatted2;
      function noop(key, value) {
        return value;
      }
      function revive(input, parsed, output, $) {
        return Object.keys(output).reduce(function(output2, key) {
          var value = output2[key];
          if (value instanceof Primitive) {
            var tmp = input[value];
            if (typeof tmp === "object" && !parsed.has(tmp)) {
              parsed.add(tmp);
              output2[key] = $.call(output2, key, revive(input, parsed, tmp, $));
            } else {
              output2[key] = $.call(output2, key, tmp);
            }
          } else
            output2[key] = $.call(output2, key, value);
          return output2;
        }, output);
      }
      function set(known, input, value) {
        var index = Primitive(input.push(value) - 1);
        known.set(value, index);
        return index;
      }
      function primitives(value) {
        return value instanceof Primitive ? Primitive(value) : value;
      }
      function Primitives(key, value) {
        return typeof value === primitive ? new Primitive(value) : value;
      }
    }(String, "string");
    esm_default = Flatted;
    parse = Flatted.parse;
    stringify = Flatted.stringify;
  }
});

// node_modules/log4js/lib/LoggingEvent.js
var require_LoggingEvent = __commonJS({
  "node_modules/log4js/lib/LoggingEvent.js"(exports2, module2) {
    var flatted = (init_esm(), esm_exports);
    var levels = require_levels();
    var LoggingEvent = class {
      constructor(categoryName, level, data, context, location) {
        this.startTime = new Date();
        this.categoryName = categoryName;
        this.data = data;
        this.level = level;
        this.context = Object.assign({}, context);
        this.pid = process.pid;
        if (location) {
          this.functionName = location.functionName;
          this.fileName = location.fileName;
          this.lineNumber = location.lineNumber;
          this.columnNumber = location.columnNumber;
          this.callStack = location.callStack;
        }
      }
      serialise() {
        const logData = this.data.map((e) => {
          if (e && e.message && e.stack) {
            e = Object.assign({ message: e.message, stack: e.stack }, e);
          }
          return e;
        });
        this.data = logData;
        return flatted.stringify(this);
      }
      static deserialise(serialised) {
        let event;
        try {
          const rehydratedEvent = flatted.parse(serialised);
          rehydratedEvent.data = rehydratedEvent.data.map((e) => {
            if (e && e.message && e.stack) {
              const fakeError = new Error(e);
              Object.keys(e).forEach((key) => {
                fakeError[key] = e[key];
              });
              e = fakeError;
            }
            return e;
          });
          event = new LoggingEvent(rehydratedEvent.categoryName, levels.getLevel(rehydratedEvent.level.levelStr), rehydratedEvent.data, rehydratedEvent.context);
          event.startTime = new Date(rehydratedEvent.startTime);
          event.pid = rehydratedEvent.pid;
          event.cluster = rehydratedEvent.cluster;
        } catch (e) {
          event = new LoggingEvent("log4js", levels.ERROR, ["Unable to parse log:", serialised, "because: ", e]);
        }
        return event;
      }
    };
    module2.exports = LoggingEvent;
  }
});

// node_modules/log4js/lib/clustering.js
var require_clustering = __commonJS({
  "node_modules/log4js/lib/clustering.js"(exports2, module2) {
    var debug = require_src()("log4js:clustering");
    var LoggingEvent = require_LoggingEvent();
    var configuration = require_configuration();
    var disabled = false;
    var cluster = null;
    try {
      cluster = require("cluster");
    } catch (e) {
      debug("cluster module not present");
      disabled = true;
    }
    var listeners = [];
    var pm2 = false;
    var pm2InstanceVar = "NODE_APP_INSTANCE";
    var isPM2Master = () => pm2 && process.env[pm2InstanceVar] === "0";
    var isMaster = () => disabled || cluster.isMaster || isPM2Master();
    var sendToListeners = (logEvent) => {
      listeners.forEach((l) => l(logEvent));
    };
    var receiver = (worker, message) => {
      debug("cluster message received from worker ", worker, ": ", message);
      if (worker.topic && worker.data) {
        message = worker;
        worker = void 0;
      }
      if (message && message.topic && message.topic === "log4js:message") {
        debug("received message: ", message.data);
        const logEvent = LoggingEvent.deserialise(message.data);
        sendToListeners(logEvent);
      }
    };
    if (!disabled) {
      configuration.addListener((config) => {
        listeners.length = 0;
        ({
          pm2,
          disableClustering: disabled,
          pm2InstanceVar = "NODE_APP_INSTANCE"
        } = config);
        debug(`clustering disabled ? ${disabled}`);
        debug(`cluster.isMaster ? ${cluster && cluster.isMaster}`);
        debug(`pm2 enabled ? ${pm2}`);
        debug(`pm2InstanceVar = ${pm2InstanceVar}`);
        debug(`process.env[${pm2InstanceVar}] = ${process.env[pm2InstanceVar]}`);
        if (pm2) {
          process.removeListener("message", receiver);
        }
        if (cluster && cluster.removeListener) {
          cluster.removeListener("message", receiver);
        }
        if (disabled || config.disableClustering) {
          debug("Not listening for cluster messages, because clustering disabled.");
        } else if (isPM2Master()) {
          debug("listening for PM2 broadcast messages");
          process.on("message", receiver);
        } else if (cluster.isMaster) {
          debug("listening for cluster messages");
          cluster.on("message", receiver);
        } else {
          debug("not listening for messages, because we are not a master process");
        }
      });
    }
    module2.exports = {
      onlyOnMaster: (fn, notMaster) => isMaster() ? fn() : notMaster,
      isMaster,
      send: (msg) => {
        if (isMaster()) {
          sendToListeners(msg);
        } else {
          if (!pm2) {
            msg.cluster = {
              workerId: cluster.worker.id,
              worker: process.pid
            };
          }
          process.send({ topic: "log4js:message", data: msg.serialise() });
        }
      },
      onMessage: (listener) => {
        listeners.push(listener);
      }
    };
  }
});

// node_modules/log4js/lib/appenders/adapters.js
var require_adapters = __commonJS({
  "node_modules/log4js/lib/appenders/adapters.js"(exports2, module2) {
    function maxFileSizeUnitTransform(maxLogSize) {
      if (typeof maxLogSize === "number" && Number.isInteger(maxLogSize)) {
        return maxLogSize;
      }
      const units = {
        K: 1024,
        M: 1024 * 1024,
        G: 1024 * 1024 * 1024
      };
      const validUnit = Object.keys(units);
      const unit = maxLogSize.substr(maxLogSize.length - 1).toLocaleUpperCase();
      const value = maxLogSize.substring(0, maxLogSize.length - 1).trim();
      if (validUnit.indexOf(unit) < 0 || !Number.isInteger(Number(value))) {
        throw Error(`maxLogSize: "${maxLogSize}" is invalid`);
      } else {
        return value * units[unit];
      }
    }
    function adapter(configAdapter, config) {
      const newConfig = Object.assign({}, config);
      Object.keys(configAdapter).forEach((key) => {
        if (newConfig[key]) {
          newConfig[key] = configAdapter[key](config[key]);
        }
      });
      return newConfig;
    }
    function fileAppenderAdapter(config) {
      const configAdapter = {
        maxLogSize: maxFileSizeUnitTransform
      };
      return adapter(configAdapter, config);
    }
    var adapters = {
      file: fileAppenderAdapter,
      fileSync: fileAppenderAdapter
    };
    module2.exports.modifyConfig = (config) => adapters[config.type] ? adapters[config.type](config) : config;
  }
});

// node_modules/log4js/lib/appenders/console.js
var require_console = __commonJS({
  "node_modules/log4js/lib/appenders/console.js"(exports2, module2) {
    var consoleLog = console.log.bind(console);
    function consoleAppender(layout, timezoneOffset) {
      return (loggingEvent) => {
        consoleLog(layout(loggingEvent, timezoneOffset));
      };
    }
    function configure(config, layouts) {
      let layout = layouts.colouredLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return consoleAppender(layout, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/stdout.js
var require_stdout = __commonJS({
  "node_modules/log4js/lib/appenders/stdout.js"(exports2) {
    function stdoutAppender(layout, timezoneOffset) {
      return (loggingEvent) => {
        process.stdout.write(`${layout(loggingEvent, timezoneOffset)}
`);
      };
    }
    function configure(config, layouts) {
      let layout = layouts.colouredLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return stdoutAppender(layout, config.timezoneOffset);
    }
    exports2.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/stderr.js
var require_stderr = __commonJS({
  "node_modules/log4js/lib/appenders/stderr.js"(exports2, module2) {
    function stderrAppender(layout, timezoneOffset) {
      return (loggingEvent) => {
        process.stderr.write(`${layout(loggingEvent, timezoneOffset)}
`);
      };
    }
    function configure(config, layouts) {
      let layout = layouts.colouredLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return stderrAppender(layout, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/logLevelFilter.js
var require_logLevelFilter = __commonJS({
  "node_modules/log4js/lib/appenders/logLevelFilter.js"(exports2, module2) {
    function logLevelFilter(minLevelString, maxLevelString, appender, levels) {
      const minLevel = levels.getLevel(minLevelString);
      const maxLevel = levels.getLevel(maxLevelString, levels.FATAL);
      return (logEvent) => {
        const eventLevel = logEvent.level;
        if (eventLevel.isGreaterThanOrEqualTo(minLevel) && eventLevel.isLessThanOrEqualTo(maxLevel)) {
          appender(logEvent);
        }
      };
    }
    function configure(config, layouts, findAppender, levels) {
      const appender = findAppender(config.appender);
      return logLevelFilter(config.level, config.maxLevel, appender, levels);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/categoryFilter.js
var require_categoryFilter = __commonJS({
  "node_modules/log4js/lib/appenders/categoryFilter.js"(exports2, module2) {
    var debug = require_src()("log4js:categoryFilter");
    function categoryFilter(excludes, appender) {
      if (typeof excludes === "string")
        excludes = [excludes];
      return (logEvent) => {
        debug(`Checking ${logEvent.categoryName} against ${excludes}`);
        if (excludes.indexOf(logEvent.categoryName) === -1) {
          debug("Not excluded, sending to appender");
          appender(logEvent);
        }
      };
    }
    function configure(config, layouts, findAppender) {
      const appender = findAppender(config.appender);
      return categoryFilter(config.exclude, appender);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/noLogFilter.js
var require_noLogFilter = __commonJS({
  "node_modules/log4js/lib/appenders/noLogFilter.js"(exports2, module2) {
    var debug = require_src()("log4js:noLogFilter");
    function removeNullOrEmptyRegexp(regexp) {
      const filtered = regexp.filter((el) => el != null && el !== "");
      return filtered;
    }
    function noLogFilter(filters, appender) {
      return (logEvent) => {
        debug(`Checking data: ${logEvent.data} against filters: ${filters}`);
        if (typeof filters === "string") {
          filters = [filters];
        }
        filters = removeNullOrEmptyRegexp(filters);
        const regex = new RegExp(filters.join("|"), "i");
        if (filters.length === 0 || logEvent.data.findIndex((value) => regex.test(value)) < 0) {
          debug("Not excluded, sending to appender");
          appender(logEvent);
        }
      };
    }
    function configure(config, layouts, findAppender) {
      const appender = findAppender(config.appender);
      return noLogFilter(config.exclude, appender);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function() {
        if (typeof arguments[arguments.length - 1] === "function")
          fn.apply(this, arguments);
        else {
          return new Promise((resolve3, reject) => {
            arguments[arguments.length] = (err, res) => {
              if (err)
                return reject(err);
              resolve3(res);
            };
            arguments.length++;
            fn.apply(this, arguments);
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function() {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, arguments);
        else
          fn.apply(this, arguments).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform3 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs27) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs27);
      }
      if (!fs27.lutimes) {
        patchLutimes(fs27);
      }
      fs27.chown = chownFix(fs27.chown);
      fs27.fchown = chownFix(fs27.fchown);
      fs27.lchown = chownFix(fs27.lchown);
      fs27.chmod = chmodFix(fs27.chmod);
      fs27.fchmod = chmodFix(fs27.fchmod);
      fs27.lchmod = chmodFix(fs27.lchmod);
      fs27.chownSync = chownFixSync(fs27.chownSync);
      fs27.fchownSync = chownFixSync(fs27.fchownSync);
      fs27.lchownSync = chownFixSync(fs27.lchownSync);
      fs27.chmodSync = chmodFixSync(fs27.chmodSync);
      fs27.fchmodSync = chmodFixSync(fs27.fchmodSync);
      fs27.lchmodSync = chmodFixSync(fs27.lchmodSync);
      fs27.stat = statFix(fs27.stat);
      fs27.fstat = statFix(fs27.fstat);
      fs27.lstat = statFix(fs27.lstat);
      fs27.statSync = statFixSync(fs27.statSync);
      fs27.fstatSync = statFixSync(fs27.fstatSync);
      fs27.lstatSync = statFixSync(fs27.lstatSync);
      if (!fs27.lchmod) {
        fs27.lchmod = function(path36, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs27.lchmodSync = function() {
        };
      }
      if (!fs27.lchown) {
        fs27.lchown = function(path36, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs27.lchownSync = function() {
        };
      }
      if (platform3 === "win32") {
        fs27.rename = function(fs$rename) {
          return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs27.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          };
        }(fs27.rename);
      }
      fs27.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs27, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs27, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs27.read);
      fs27.readSync = function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs27, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs27.readSync);
      function patchLchmod(fs28) {
        fs28.lchmod = function(path36, mode, callback) {
          fs28.open(path36, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs28.fchmod(fd, mode, function(err2) {
              fs28.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs28.lchmodSync = function(path36, mode) {
          var fd = fs28.openSync(path36, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs28.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs28.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs28.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs28) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs28.lutimes = function(path36, at, mt, cb) {
            fs28.open(path36, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs28.futimes(fd, at, mt, function(er2) {
                fs28.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs28.lutimesSync = function(path36, at, mt) {
            var fd = fs28.openSync(path36, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs28.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs28.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs28.closeSync(fd);
              }
            }
            return ret;
          };
        } else {
          fs28.lutimes = function(_a2, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs28.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs27, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs27, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs27, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs27, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs27, target, options, callback) : orig.call(fs27, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs27, target, options) : orig.call(fs27, target);
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs27) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path36, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path36, options);
        Stream.call(this);
        var self2 = this;
        this.path = path36;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs27.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path36, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path36, options);
        Stream.call(this);
        this.path = path36;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs27.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs27 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util4 = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util4.debuglog)
      debug = util4.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util4.format.apply(util4, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs27[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs27, queue);
      fs27.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs27, fd, function(err) {
            if (!err) {
              retry();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs27.close);
      fs27.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs27, arguments);
          retry();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs27.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs27[gracefulQueue]);
          require("assert").equal(fs27[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs27[gracefulQueue]);
    }
    module2.exports = patch(clone(fs27));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs27.__patched) {
      module2.exports = patch(fs27);
      fs27.__patched = true;
    }
    function patch(fs28) {
      polyfills(fs28);
      fs28.gracefulify = patch;
      fs28.createReadStream = createReadStream;
      fs28.createWriteStream = createWriteStream;
      var fs$readFile = fs28.readFile;
      fs28.readFile = readFile2;
      function readFile2(path36, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path36, options, cb);
        function go$readFile(path37, options2, cb2) {
          return fs$readFile(path37, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path37, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$writeFile = fs28.writeFile;
      fs28.writeFile = writeFile2;
      function writeFile2(path36, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path36, data, options, cb);
        function go$writeFile(path37, data2, options2, cb2) {
          return fs$writeFile(path37, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path37, data2, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$appendFile = fs28.appendFile;
      if (fs$appendFile)
        fs28.appendFile = appendFile;
      function appendFile(path36, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path36, data, options, cb);
        function go$appendFile(path37, data2, options2, cb2) {
          return fs$appendFile(path37, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path37, data2, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$copyFile = fs28.copyFile;
      if (fs$copyFile)
        fs28.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return fs$copyFile(src, dest, flags, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([fs$copyFile, [src, dest, flags, cb]]);
          else {
            if (typeof cb === "function")
              cb.apply(this, arguments);
            retry();
          }
        });
      }
      var fs$readdir = fs28.readdir;
      fs28.readdir = readdir;
      function readdir(path36, options, cb) {
        var args = [path36];
        if (typeof options !== "function") {
          args.push(options);
        } else {
          cb = options;
        }
        args.push(go$readdir$cb);
        return go$readdir(args);
        function go$readdir$cb(err, files) {
          if (files && files.sort)
            files.sort();
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readdir, [args]]);
          else {
            if (typeof cb === "function")
              cb.apply(this, arguments);
            retry();
          }
        }
      }
      function go$readdir(args) {
        return fs$readdir.apply(fs28, args);
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs28);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs28.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs28.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs28, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs28, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs28, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs28, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path36, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path36, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path36, options) {
        return new fs28.ReadStream(path36, options);
      }
      function createWriteStream(path36, options) {
        return new fs28.WriteStream(path36, options);
      }
      var fs$open = fs28.open;
      fs28.open = open;
      function open(path36, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path36, flags, mode, cb);
        function go$open(path37, flags2, mode2, cb2) {
          return fs$open(path37, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path37, flags2, mode2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      return fs28;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs27[gracefulQueue].push(elem);
    }
    function retry() {
      var elem = fs27[gracefulQueue].shift();
      if (elem) {
        debug("RETRY", elem[0].name, elem[1]);
        elem[0].apply(null, elem[1]);
      }
    }
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs27 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchown",
      "lchmod",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "readFile",
      "readdir",
      "readlink",
      "realpath",
      "rename",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs27[key] === "function";
    });
    Object.keys(fs27).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports2[key] = fs27[key];
    });
    api.forEach((method) => {
      exports2[method] = u(fs27[method]);
    });
    exports2.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs27.exists(filename, callback);
      }
      return new Promise((resolve3) => {
        return fs27.exists(filename, resolve3);
      });
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs27.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve3, reject) => {
        fs27.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs27.write(fd, buffer, ...args);
      }
      return new Promise((resolve3, reject) => {
        fs27.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs27.realpath.native === "function") {
      exports2.realpath.native = u(fs27.realpath.native);
    }
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/win32.js
var require_win32 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/win32.js"(exports2, module2) {
    "use strict";
    var path36 = require("path");
    function getRootPath(p) {
      p = path36.normalize(path36.resolve(p)).split(path36.sep);
      if (p.length > 0)
        return p[0];
      return null;
    }
    var INVALID_PATH_CHARS = /[<>:"|?*]/;
    function invalidWin32Path(p) {
      const rp = getRootPath(p);
      p = p.replace(rp, "");
      return INVALID_PATH_CHARS.test(p);
    }
    module2.exports = {
      getRootPath,
      invalidWin32Path
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs.js
var require_mkdirs = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var invalidWin32Path = require_win32().invalidWin32Path;
    var o777 = parseInt("0777", 8);
    function mkdirs(p, opts, callback, made) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      if (process.platform === "win32" && invalidWin32Path(p)) {
        const errInval = new Error(p + " contains invalid WIN32 path characters.");
        errInval.code = "EINVAL";
        return callback(errInval);
      }
      let mode = opts.mode;
      const xfs = opts.fs || fs27;
      if (mode === void 0) {
        mode = o777 & ~process.umask();
      }
      if (!made)
        made = null;
      callback = callback || function() {
      };
      p = path36.resolve(p);
      xfs.mkdir(p, mode, (er) => {
        if (!er) {
          made = made || p;
          return callback(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path36.dirname(p) === p)
              return callback(er);
            mkdirs(path36.dirname(p), opts, (er2, made2) => {
              if (er2)
                callback(er2, made2);
              else
                mkdirs(p, opts, callback, made2);
            });
            break;
          default:
            xfs.stat(p, (er2, stat) => {
              if (er2 || !stat.isDirectory())
                callback(er, made);
              else
                callback(null, made);
            });
            break;
        }
      });
    }
    module2.exports = mkdirs;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js
var require_mkdirs_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var invalidWin32Path = require_win32().invalidWin32Path;
    var o777 = parseInt("0777", 8);
    function mkdirsSync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      let mode = opts.mode;
      const xfs = opts.fs || fs27;
      if (process.platform === "win32" && invalidWin32Path(p)) {
        const errInval = new Error(p + " contains invalid WIN32 path characters.");
        errInval.code = "EINVAL";
        throw errInval;
      }
      if (mode === void 0) {
        mode = o777 & ~process.umask();
      }
      if (!made)
        made = null;
      p = path36.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        if (err0.code === "ENOENT") {
          if (path36.dirname(p) === p)
            throw err0;
          made = mkdirsSync(path36.dirname(p), opts, made);
          mkdirsSync(p, opts, made);
        } else {
          let stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
        }
      }
      return made;
    }
    module2.exports = mkdirsSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var mkdirs = u(require_mkdirs());
    var mkdirsSync = require_mkdirs_sync();
    module2.exports = {
      mkdirs,
      mkdirsSync,
      mkdirp: mkdirs,
      mkdirpSync: mkdirsSync,
      ensureDir: mkdirs,
      ensureDirSync: mkdirsSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var os10 = require("os");
    var path36 = require("path");
    function hasMillisResSync() {
      let tmpfile = path36.join("millis-test-sync" + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path36.join(os10.tmpdir(), tmpfile);
      const d = new Date(1435410243862);
      fs27.writeFileSync(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141");
      const fd = fs27.openSync(tmpfile, "r+");
      fs27.futimesSync(fd, d, d);
      fs27.closeSync(fd);
      return fs27.statSync(tmpfile).mtime > 1435410243e3;
    }
    function hasMillisRes(callback) {
      let tmpfile = path36.join("millis-test" + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path36.join(os10.tmpdir(), tmpfile);
      const d = new Date(1435410243862);
      fs27.writeFile(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141", (err) => {
        if (err)
          return callback(err);
        fs27.open(tmpfile, "r+", (err2, fd) => {
          if (err2)
            return callback(err2);
          fs27.futimes(fd, d, d, (err3) => {
            if (err3)
              return callback(err3);
            fs27.close(fd, (err4) => {
              if (err4)
                return callback(err4);
              fs27.stat(tmpfile, (err5, stats) => {
                if (err5)
                  return callback(err5);
                callback(null, stats.mtime > 1435410243e3);
              });
            });
          });
        });
      });
    }
    function timeRemoveMillis(timestamp) {
      if (typeof timestamp === "number") {
        return Math.floor(timestamp / 1e3) * 1e3;
      } else if (timestamp instanceof Date) {
        return new Date(Math.floor(timestamp.getTime() / 1e3) * 1e3);
      } else {
        throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
      }
    }
    function utimesMillis(path37, atime, mtime, callback) {
      fs27.open(path37, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs27.futimes(fd, atime, mtime, (futimesErr) => {
          fs27.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path37, atime, mtime) {
      const fd = fs27.openSync(path37, "r+");
      fs27.futimesSync(fd, atime, mtime);
      return fs27.closeSync(fd);
    }
    module2.exports = {
      hasMillisRes,
      hasMillisResSync,
      timeRemoveMillis,
      utimesMillis,
      utimesMillisSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var NODE_VERSION_MAJOR_WITH_BIGINT = 10;
    var NODE_VERSION_MINOR_WITH_BIGINT = 5;
    var NODE_VERSION_PATCH_WITH_BIGINT = 0;
    var nodeVersion = process.versions.node.split(".");
    var nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);
    var nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);
    var nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);
    function nodeSupportsBigInt() {
      if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
        return true;
      } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
        if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
          return true;
        } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
          if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
            return true;
          }
        }
      }
      return false;
    }
    function getStats(src, dest, cb) {
      if (nodeSupportsBigInt()) {
        fs27.stat(src, { bigint: true }, (err, srcStat) => {
          if (err)
            return cb(err);
          fs27.stat(dest, { bigint: true }, (err2, destStat) => {
            if (err2) {
              if (err2.code === "ENOENT")
                return cb(null, { srcStat, destStat: null });
              return cb(err2);
            }
            return cb(null, { srcStat, destStat });
          });
        });
      } else {
        fs27.stat(src, (err, srcStat) => {
          if (err)
            return cb(err);
          fs27.stat(dest, (err2, destStat) => {
            if (err2) {
              if (err2.code === "ENOENT")
                return cb(null, { srcStat, destStat: null });
              return cb(err2);
            }
            return cb(null, { srcStat, destStat });
          });
        });
      }
    }
    function getStatsSync(src, dest) {
      let srcStat, destStat;
      if (nodeSupportsBigInt()) {
        srcStat = fs27.statSync(src, { bigint: true });
      } else {
        srcStat = fs27.statSync(src);
      }
      try {
        if (nodeSupportsBigInt()) {
          destStat = fs27.statSync(dest, { bigint: true });
        } else {
          destStat = fs27.statSync(dest);
        }
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, cb) {
      getStats(src, dest, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName) {
      const { srcStat, destStat } = getStatsSync(src, dest);
      if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path36.resolve(path36.dirname(src));
      const destParent = path36.resolve(path36.dirname(dest));
      if (destParent === srcParent || destParent === path36.parse(destParent).root)
        return cb();
      if (nodeSupportsBigInt()) {
        fs27.stat(destParent, { bigint: true }, (err, destStat) => {
          if (err) {
            if (err.code === "ENOENT")
              return cb();
            return cb(err);
          }
          if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
            return cb(new Error(errMsg(src, dest, funcName)));
          }
          return checkParentPaths(src, srcStat, destParent, funcName, cb);
        });
      } else {
        fs27.stat(destParent, (err, destStat) => {
          if (err) {
            if (err.code === "ENOENT")
              return cb();
            return cb(err);
          }
          if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
            return cb(new Error(errMsg(src, dest, funcName)));
          }
          return checkParentPaths(src, srcStat, destParent, funcName, cb);
        });
      }
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path36.resolve(path36.dirname(src));
      const destParent = path36.resolve(path36.dirname(dest));
      if (destParent === srcParent || destParent === path36.parse(destParent).root)
        return;
      let destStat;
      try {
        if (nodeSupportsBigInt()) {
          destStat = fs27.statSync(destParent, { bigint: true });
        } else {
          destStat = fs27.statSync(destParent);
        }
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path36.resolve(src).split(path36.sep).filter((i) => i);
      const destArr = path36.resolve(dest).split(path36.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/buffer.js
var require_buffer = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/util/buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = function(size) {
      if (typeof Buffer.allocUnsafe === "function") {
        try {
          return Buffer.allocUnsafe(size);
        } catch (e) {
          return new Buffer(size);
        }
      }
      return new Buffer(size);
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var mkdirpSync = require_mkdirs2().mkdirsSync;
    var utimesSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy");
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      return handleFilterAndCopy(destStat, src, dest, opts);
    }
    function handleFilterAndCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path36.dirname(dest);
      if (!fs27.existsSync(destParent))
        mkdirpSync(destParent);
      return startCopy(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs27.statSync : fs27.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs27.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      if (typeof fs27.copyFileSync === "function") {
        fs27.copyFileSync(src, dest);
        fs27.chmodSync(dest, srcStat.mode);
        if (opts.preserveTimestamps) {
          return utimesSync(dest, srcStat.atime, srcStat.mtime);
        }
        return;
      }
      return copyFileFallback(srcStat, src, dest, opts);
    }
    function copyFileFallback(srcStat, src, dest, opts) {
      const BUF_LENGTH = 64 * 1024;
      const _buff = require_buffer()(BUF_LENGTH);
      const fdr = fs27.openSync(src, "r");
      const fdw = fs27.openSync(dest, "w", srcStat.mode);
      let pos = 0;
      while (pos < srcStat.size) {
        const bytesRead = fs27.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        fs27.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }
      if (opts.preserveTimestamps)
        fs27.futimesSync(fdw, srcStat.atime, srcStat.mtime);
      fs27.closeSync(fdr);
      fs27.closeSync(fdw);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat, src, dest, opts);
      if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcStat, src, dest, opts) {
      fs27.mkdirSync(dest);
      copyDir(src, dest, opts);
      return fs27.chmodSync(dest, srcStat.mode);
    }
    function copyDir(src, dest, opts) {
      fs27.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path36.join(src, item);
      const destItem = path36.join(dest, item);
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy");
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs27.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path36.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs27.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs27.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs27.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path36.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs27.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs27.unlinkSync(dest);
      return fs27.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copySync: require_copy_sync()
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs27 = require_fs();
    function pathExists(path36) {
      return fs27.access(path36).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs27.existsSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var mkdirp = require_mkdirs2().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimes = require_utimes().utimesMillis;
    var stat = require_stat();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      stat.checkPaths(src, dest, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          if (opts.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
          return checkParentDir(destStat, src, dest, opts, cb);
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path36.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return startCopy(destStat, src, dest, opts, cb);
        mkdirp(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return startCopy(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include)
          return onInclude(destStat, src, dest, opts, cb);
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat2 = opts.dereference ? fs27.stat : fs27.lstat;
      stat2(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs27.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      if (typeof fs27.copyFile === "function") {
        return fs27.copyFile(src, dest, (err) => {
          if (err)
            return cb(err);
          return setDestModeAndTimestamps(srcStat, dest, opts, cb);
        });
      }
      return copyFileFallback(srcStat, src, dest, opts, cb);
    }
    function copyFileFallback(srcStat, src, dest, opts, cb) {
      const rs = fs27.createReadStream(src);
      rs.on("error", (err) => cb(err)).once("open", () => {
        const ws = fs27.createWriteStream(dest, { mode: srcStat.mode });
        ws.on("error", (err) => cb(err)).on("open", () => rs.pipe(ws)).once("close", () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
      });
    }
    function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
      fs27.chmod(dest, srcStat.mode, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps) {
          return utimes(dest, srcStat.atime, srcStat.mtime, cb);
        }
        return cb();
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat, src, dest, opts, cb);
      if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcStat, src, dest, opts, cb) {
      fs27.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return fs27.chmod(dest, srcStat.mode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs27.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path36.join(src, item);
      const destItem = path36.join(dest, item);
      stat.checkPaths(srcItem, destItem, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs27.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path36.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs27.symlink(resolvedSrc, dest, cb);
        } else {
          fs27.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs27.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path36.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs27.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs27.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      copy: u(require_copy())
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var assert = require("assert");
    var isWindows4 = process.platform === "win32";
    function defaults2(options) {
      const methods2 = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods2.forEach((m) => {
        options[m] = options[m] || fs27[m];
        m = m + "Sync";
        options[m] = options[m] || fs27[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf(p, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults2(options);
      rimraf_(p, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p, options, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows4) {
          return fixWinEPERM(p, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir(p, options, er, cb);
        }
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows4 ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir(p, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      if (er) {
        assert(er instanceof Error);
      }
      options.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options, er) {
      let stats;
      assert(p);
      assert(options);
      if (er) {
        assert(er instanceof Error);
      }
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options.rmdir(p, cb);
        files.forEach((f) => {
          rimraf(path36.join(p, f), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options) {
      let st;
      options = options || {};
      defaults2(options);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows4) {
          fixWinEPERMSync(p, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows4 ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p, options, er);
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path36.join(p, f), options));
      if (isWindows4) {
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p, options);
            return ret;
          } catch (er) {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options.rmdirSync(p, options);
        return ret;
      }
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var rimraf = require_rimraf();
    module2.exports = {
      remove: u(rimraf),
      removeSync: rimraf.sync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var mkdir = require_mkdirs2();
    var remove = require_remove();
    var emptyDir = u(function emptyDir2(dir, callback) {
      callback = callback || function() {
      };
      fs27.readdir(dir, (err, items) => {
        if (err)
          return mkdir.mkdirs(dir, callback);
        items = items.map((item) => path36.join(dir, item));
        deleteItem();
        function deleteItem() {
          const item = items.pop();
          if (!item)
            return callback();
          remove.remove(item, (err2) => {
            if (err2)
              return callback(err2);
            deleteItem();
          });
        }
      });
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs27.readdirSync(dir);
      } catch (err) {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path36.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path36 = require("path");
    var fs27 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function createFile(file, callback) {
      function makeFile() {
        fs27.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs27.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path36.dirname(file);
        pathExists(dir, (err2, dirExists) => {
          if (err2)
            return callback(err2);
          if (dirExists)
            return makeFile();
          mkdir.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeFile();
          });
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs27.statSync(file);
      } catch (e) {
      }
      if (stats && stats.isFile())
        return;
      const dir = path36.dirname(file);
      if (!fs27.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs27.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path36 = require("path");
    var fs27 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs27.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        fs27.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          const dir = path36.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      const destinationExists = fs27.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      try {
        fs27.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path36.dirname(dstpath);
      const dirExists = fs27.existsSync(dir);
      if (dirExists)
        return fs27.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs27.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path36 = require("path");
    var fs27 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path36.isAbsolute(srcpath)) {
        return fs27.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            "toCwd": srcpath,
            "toDst": srcpath
          });
        });
      } else {
        const dstdir = path36.dirname(dstpath);
        const relativeToDst = path36.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              "toCwd": relativeToDst,
              "toDst": srcpath
            });
          } else {
            return fs27.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                "toCwd": srcpath,
                "toDst": path36.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path36.isAbsolute(srcpath)) {
        exists = fs27.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          "toCwd": srcpath,
          "toDst": srcpath
        };
      } else {
        const dstdir = path36.dirname(dstpath);
        const relativeToDst = path36.join(dstdir, srcpath);
        exists = fs27.existsSync(relativeToDst);
        if (exists) {
          return {
            "toCwd": relativeToDst,
            "toDst": srcpath
          };
        } else {
          exists = fs27.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            "toCwd": srcpath,
            "toDst": path36.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs27.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs27.lstatSync(srcpath);
      } catch (e) {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path36 = require("path");
    var fs27 = require_graceful_fs();
    var _mkdirs = require_mkdirs2();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        symlinkPaths(srcpath, dstpath, (err2, relative) => {
          if (err2)
            return callback(err2);
          srcpath = relative.toDst;
          symlinkType(relative.toCwd, type, (err3, type2) => {
            if (err3)
              return callback(err3);
            const dir = path36.dirname(dstpath);
            pathExists(dir, (err4, dirExists) => {
              if (err4)
                return callback(err4);
              if (dirExists)
                return fs27.symlink(srcpath, dstpath, type2, callback);
              mkdirs(dir, (err5) => {
                if (err5)
                  return callback(err5);
                fs27.symlink(srcpath, dstpath, type2, callback);
              });
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      const destinationExists = fs27.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path36.dirname(dstpath);
      const exists = fs27.existsSync(dir);
      if (exists)
        return fs27.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs27.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var file = require_file();
    var link = require_link();
    var symlink = require_symlink();
    module2.exports = {
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };
  }
});

// node_modules/streamroller/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/streamroller/node_modules/jsonfile/index.js"(exports2, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    function readFile2(file, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      if (typeof options === "string") {
        options = { encoding: options };
      }
      options = options || {};
      var fs27 = options.fs || _fs;
      var shouldThrow = true;
      if ("throws" in options) {
        shouldThrow = options.throws;
      }
      fs27.readFile(file, options, function(err, data) {
        if (err)
          return callback(err);
        data = stripBom(data);
        var obj;
        try {
          obj = JSON.parse(data, options ? options.reviver : null);
        } catch (err2) {
          if (shouldThrow) {
            err2.message = file + ": " + err2.message;
            return callback(err2);
          } else {
            return callback(null, null);
          }
        }
        callback(null, obj);
      });
    }
    function readFileSync(file, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { encoding: options };
      }
      var fs27 = options.fs || _fs;
      var shouldThrow = true;
      if ("throws" in options) {
        shouldThrow = options.throws;
      }
      try {
        var content = fs27.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = file + ": " + err.message;
          throw err;
        } else {
          return null;
        }
      }
    }
    function stringify3(obj, options) {
      var spaces;
      var EOL2 = "\n";
      if (typeof options === "object" && options !== null) {
        if (options.spaces) {
          spaces = options.spaces;
        }
        if (options.EOL) {
          EOL2 = options.EOL;
        }
      }
      var str = JSON.stringify(obj, options ? options.replacer : null, spaces);
      return str.replace(/\n/g, EOL2) + EOL2;
    }
    function writeFile2(file, obj, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      options = options || {};
      var fs27 = options.fs || _fs;
      var str = "";
      try {
        str = stringify3(obj, options);
      } catch (err) {
        if (callback)
          callback(err, null);
        return;
      }
      fs27.writeFile(file, str, options, callback);
    }
    function writeFileSync(file, obj, options) {
      options = options || {};
      var fs27 = options.fs || _fs;
      var str = stringify3(obj, options);
      return fs27.writeFileSync(file, str, options);
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      content = content.replace(/^\uFEFF/, "");
      return content;
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync,
      writeFile: writeFile2,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var jsonFile = require_jsonfile();
    module2.exports = {
      readJson: u(jsonFile.readFile),
      readJsonSync: jsonFile.readFileSync,
      writeJson: u(jsonFile.writeFile),
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var path36 = require("path");
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    var jsonFile = require_jsonfile2();
    function outputJson(file, data, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      const dir = path36.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return jsonFile.writeJson(file, data, options, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          jsonFile.writeJson(file, data, options, callback);
        });
      });
    }
    module2.exports = outputJson;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var mkdir = require_mkdirs2();
    var jsonFile = require_jsonfile2();
    function outputJsonSync(file, data, options) {
      const dir = path36.dirname(file);
      if (!fs27.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      jsonFile.writeJsonSync(file, data, options);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var copySync = require_copy_sync2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs2().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat } = stat.checkPathsSync(src, dest, "move");
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      mkdirpSync(path36.dirname(dest));
      return doRename(src, dest, overwrite);
    }
    function doRename(src, dest, overwrite) {
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs27.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs27.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      moveSync: require_move_sync()
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs2().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat = require_stat();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const overwrite = opts.overwrite || opts.clobber || false;
      stat.checkPaths(src, dest, "move", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          mkdirp(path36.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, cb);
          });
        });
      });
    }
    function doRename(src, dest, overwrite, cb) {
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs27.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module2.exports = move;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      move: u(require_move())
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/output/index.js
var require_output = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/output/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path36.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs27.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs27.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path36.dirname(file);
      if (fs27.existsSync(dir)) {
        return fs27.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs27.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.assign({}, require_fs(), require_copy_sync2(), require_copy2(), require_empty(), require_ensure(), require_json(), require_mkdirs2(), require_move_sync2(), require_move2(), require_output(), require_path_exists(), require_remove());
    var fs27 = require("fs");
    if (Object.getOwnPropertyDescriptor(fs27, "promises")) {
      Object.defineProperty(module2.exports, "promises", {
        get() {
          return fs27.promises;
        }
      });
    }
  }
});

// node_modules/streamroller/lib/now.js
var require_now = __commonJS({
  "node_modules/streamroller/lib/now.js"(exports2, module2) {
    module2.exports = () => new Date();
  }
});

// node_modules/streamroller/node_modules/date-format/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/streamroller/node_modules/date-format/lib/index.js"(exports2, module2) {
    "use strict";
    function padWithZeros(vNumber, width) {
      var numAsString = vNumber.toString();
      while (numAsString.length < width) {
        numAsString = "0" + numAsString;
      }
      return numAsString;
    }
    function addZero(vNumber) {
      return padWithZeros(vNumber, 2);
    }
    function offset(timezoneOffset) {
      var os10 = Math.abs(timezoneOffset);
      var h = String(Math.floor(os10 / 60));
      var m = String(os10 % 60);
      if (h.length === 1) {
        h = "0" + h;
      }
      if (m.length === 1) {
        m = "0" + m;
      }
      return timezoneOffset < 0 ? "+" + h + m : "-" + h + m;
    }
    function datePart(date, displayUTC, part) {
      return displayUTC ? date["getUTC" + part]() : date["get" + part]();
    }
    function asString(format2, date) {
      if (typeof format2 !== "string") {
        date = format2;
        format2 = module2.exports.ISO8601_FORMAT;
      }
      if (!date) {
        date = module2.exports.now();
      }
      var displayUTC = format2.indexOf("O") > -1;
      var vDay = addZero(datePart(date, displayUTC, "Date"));
      var vMonth = addZero(datePart(date, displayUTC, "Month") + 1);
      var vYearLong = addZero(datePart(date, displayUTC, "FullYear"));
      var vYearShort = addZero(vYearLong.substring(2, 4));
      var vYear = format2.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
      var vHour = addZero(datePart(date, displayUTC, "Hours"));
      var vMinute = addZero(datePart(date, displayUTC, "Minutes"));
      var vSecond = addZero(datePart(date, displayUTC, "Seconds"));
      var vMillisecond = padWithZeros(datePart(date, displayUTC, "Milliseconds"), 3);
      var vTimeZone = offset(date.getTimezoneOffset());
      var formatted = format2.replace(/dd/g, vDay).replace(/MM/g, vMonth).replace(/y{1,4}/g, vYear).replace(/hh/g, vHour).replace(/mm/g, vMinute).replace(/ss/g, vSecond).replace(/SSS/g, vMillisecond).replace(/O/g, vTimeZone);
      return formatted;
    }
    function extractDateParts(pattern, str, missingValuesDate) {
      var matchers = [
        {
          pattern: /y{1,4}/,
          regexp: "\\d{1,4}",
          fn: function(date2, value) {
            date2.setFullYear(value);
          }
        },
        {
          pattern: /MM/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            date2.setMonth(value - 1);
          }
        },
        {
          pattern: /dd/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            date2.setDate(value);
          }
        },
        {
          pattern: /hh/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            date2.setHours(value);
          }
        },
        {
          pattern: /mm/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            date2.setMinutes(value);
          }
        },
        {
          pattern: /ss/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            date2.setSeconds(value);
          }
        },
        {
          pattern: /SSS/,
          regexp: "\\d\\d\\d",
          fn: function(date2, value) {
            date2.setMilliseconds(value);
          }
        },
        {
          pattern: /O/,
          regexp: "[+-]\\d{3,4}|Z",
          fn: function(date2, value) {
            if (value === "Z") {
              value = 0;
            }
            var offset2 = Math.abs(value);
            var minutes = offset2 % 100 + Math.floor(offset2 / 100) * 60;
            date2.setMinutes(date2.getMinutes() + (value > 0 ? minutes : -minutes));
          }
        }
      ];
      var parsedPattern = matchers.reduce(function(p, m) {
        if (m.pattern.test(p.regexp)) {
          m.index = p.regexp.match(m.pattern).index;
          p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
        } else {
          m.index = -1;
        }
        return p;
      }, { regexp: pattern, index: [] });
      var dateFns = matchers.filter(function(m) {
        return m.index > -1;
      });
      dateFns.sort(function(a, b) {
        return a.index - b.index;
      });
      var matcher = new RegExp(parsedPattern.regexp);
      var matches = matcher.exec(str);
      if (matches) {
        var date = missingValuesDate || module2.exports.now();
        dateFns.forEach(function(f, i) {
          f.fn(date, matches[i + 1]);
        });
        return date;
      }
      throw new Error("String '" + str + "' could not be parsed as '" + pattern + "'");
    }
    function parse5(pattern, str, missingValuesDate) {
      if (!pattern) {
        throw new Error("pattern must be supplied");
      }
      return extractDateParts(pattern, str, missingValuesDate);
    }
    function now() {
      return new Date();
    }
    module2.exports = asString;
    module2.exports.asString = asString;
    module2.exports.parse = parse5;
    module2.exports.now = now;
    module2.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
    module2.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
    module2.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
    module2.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
  }
});

// node_modules/streamroller/lib/fileNameFormatter.js
var require_fileNameFormatter = __commonJS({
  "node_modules/streamroller/lib/fileNameFormatter.js"(exports2, module2) {
    var debug = require_src()("streamroller:fileNameFormatter");
    var path36 = require("path");
    var FILENAME_SEP = ".";
    var ZIP_EXT = ".gz";
    module2.exports = ({
      file,
      keepFileExt,
      needsIndex,
      alwaysIncludeDate,
      compress
    }) => {
      const dirAndName = path36.join(file.dir, file.name);
      const ext = (f) => f + file.ext;
      const index = (f, i, d) => (needsIndex || !d) && i ? f + FILENAME_SEP + i : f;
      const date = (f, i, d) => {
        return (i > 0 || alwaysIncludeDate) && d ? f + FILENAME_SEP + d : f;
      };
      const gzip = (f, i) => i && compress ? f + ZIP_EXT : f;
      const parts = keepFileExt ? [date, index, ext, gzip] : [ext, date, index, gzip];
      return ({ date: date2, index: index2 }) => {
        debug(`_formatFileName: date=${date2}, index=${index2}`);
        return parts.reduce((filename, part) => part(filename, index2, date2), dirAndName);
      };
    };
  }
});

// node_modules/streamroller/lib/fileNameParser.js
var require_fileNameParser = __commonJS({
  "node_modules/streamroller/lib/fileNameParser.js"(exports2, module2) {
    var debug = require_src()("streamroller:fileNameParser");
    var FILENAME_SEP = ".";
    var ZIP_EXT = ".gz";
    var format2 = require_lib3();
    module2.exports = ({ file, keepFileExt, pattern }) => {
      const zip = (f, p) => {
        if (f.endsWith(ZIP_EXT)) {
          debug("it is gzipped");
          p.isCompressed = true;
          return f.slice(0, -1 * ZIP_EXT.length);
        }
        return f;
      };
      const __NOT_MATCHING__ = "__NOT_MATCHING__";
      const extAtEnd = (f) => {
        if (f.startsWith(file.name) && f.endsWith(file.ext)) {
          debug("it starts and ends with the right things");
          return f.slice(file.name.length + 1, -1 * file.ext.length);
        }
        return __NOT_MATCHING__;
      };
      const extInMiddle = (f) => {
        if (f.startsWith(file.base)) {
          debug("it starts with the right things");
          return f.slice(file.base.length + 1);
        }
        return __NOT_MATCHING__;
      };
      const dateAndIndex = (f, p) => {
        const items = f.split(FILENAME_SEP);
        let indexStr = items[items.length - 1];
        debug("items: ", items, ", indexStr: ", indexStr);
        let dateStr = f;
        if (indexStr !== void 0 && indexStr.match(/^\d+$/)) {
          dateStr = f.slice(0, -1 * (indexStr.length + 1));
          debug(`dateStr is ${dateStr}`);
          if (pattern && !dateStr) {
            dateStr = indexStr;
            indexStr = "0";
          }
        } else {
          indexStr = "0";
        }
        try {
          const date = format2.parse(pattern, dateStr, new Date(0, 0));
          if (format2.asString(pattern, date) !== dateStr)
            return f;
          p.index = parseInt(indexStr, 10);
          p.date = dateStr;
          p.timestamp = date.getTime();
          return "";
        } catch (e) {
          debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);
          return f;
        }
      };
      const index = (f, p) => {
        if (f.match(/^\d+$/)) {
          debug("it has an index");
          p.index = parseInt(f, 10);
          return "";
        }
        return f;
      };
      let parts = [
        zip,
        keepFileExt ? extAtEnd : extInMiddle,
        pattern ? dateAndIndex : index
      ];
      return (filename) => {
        let result = { filename, index: 0, isCompressed: false };
        let whatsLeftOver = parts.reduce((remains, part) => part(remains, result), filename);
        return whatsLeftOver ? null : result;
      };
    };
  }
});

// node_modules/streamroller/lib/moveAndMaybeCompressFile.js
var require_moveAndMaybeCompressFile = __commonJS({
  "node_modules/streamroller/lib/moveAndMaybeCompressFile.js"(exports2, module2) {
    var debug = require_src()("streamroller:moveAndMaybeCompressFile");
    var fs27 = require_lib2();
    var zlib = require("zlib");
    var moveAndMaybeCompressFile = async (sourceFilePath, targetFilePath, needCompress) => {
      if (sourceFilePath === targetFilePath) {
        debug(`moveAndMaybeCompressFile: source and target are the same, not doing anything`);
        return;
      }
      if (await fs27.pathExists(sourceFilePath)) {
        debug(`moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${needCompress ? "with" : "without"} compress`);
        if (needCompress) {
          await new Promise((resolve3, reject) => {
            fs27.createReadStream(sourceFilePath).pipe(zlib.createGzip()).pipe(fs27.createWriteStream(targetFilePath)).on("finish", () => {
              debug(`moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`);
              fs27.unlink(sourceFilePath).then(resolve3).catch(() => {
                debug(`Deleting ${sourceFilePath} failed, truncating instead`);
                fs27.truncate(sourceFilePath).then(resolve3).catch(reject);
              });
            });
          });
        } else {
          debug(`moveAndMaybeCompressFile: deleting file=${targetFilePath}, renaming ${sourceFilePath} to ${targetFilePath}`);
          try {
            await fs27.move(sourceFilePath, targetFilePath, { overwrite: true });
          } catch (e) {
            debug(`moveAndMaybeCompressFile: error moving ${sourceFilePath} to ${targetFilePath}`, e);
            debug(`Trying copy+truncate instead`);
            await fs27.copy(sourceFilePath, targetFilePath, { overwrite: true });
            await fs27.truncate(sourceFilePath);
          }
        }
      }
    };
    module2.exports = moveAndMaybeCompressFile;
  }
});

// node_modules/streamroller/lib/RollingFileWriteStream.js
var require_RollingFileWriteStream = __commonJS({
  "node_modules/streamroller/lib/RollingFileWriteStream.js"(exports2, module2) {
    var debug = require_src()("streamroller:RollingFileWriteStream");
    var fs27 = require_lib2();
    var path36 = require("path");
    var newNow = require_now();
    var format2 = require_lib3();
    var { Writable } = require("stream");
    var fileNameFormatter = require_fileNameFormatter();
    var fileNameParser = require_fileNameParser();
    var moveAndMaybeCompressFile = require_moveAndMaybeCompressFile();
    var RollingFileWriteStream = class extends Writable {
      constructor(filePath, options) {
        debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);
        super(options);
        this.options = this._parseOption(options);
        this.fileObject = path36.parse(filePath);
        if (this.fileObject.dir === "") {
          this.fileObject = path36.parse(path36.join(process.cwd(), filePath));
        }
        this.fileFormatter = fileNameFormatter({
          file: this.fileObject,
          alwaysIncludeDate: this.options.alwaysIncludePattern,
          needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,
          compress: this.options.compress,
          keepFileExt: this.options.keepFileExt
        });
        this.fileNameParser = fileNameParser({
          file: this.fileObject,
          keepFileExt: this.options.keepFileExt,
          pattern: this.options.pattern
        });
        this.state = {
          currentSize: 0
        };
        if (this.options.pattern) {
          this.state.currentDate = format2(this.options.pattern, newNow());
        }
        this.filename = this.fileFormatter({
          index: 0,
          date: this.state.currentDate
        });
        if (["a", "a+", "as", "as+"].includes(this.options.flags)) {
          this._setExistingSizeAndDate();
        }
        debug(`constructor: create new file ${this.filename}, state=${JSON.stringify(this.state)}`);
        this._renewWriteStream();
      }
      _setExistingSizeAndDate() {
        try {
          const stats = fs27.statSync(this.filename);
          this.state.currentSize = stats.size;
          if (this.options.pattern) {
            this.state.currentDate = format2(this.options.pattern, stats.mtime);
          }
        } catch (e) {
          return;
        }
      }
      _parseOption(rawOptions) {
        const defaultOptions2 = {
          maxSize: Number.MAX_SAFE_INTEGER,
          numToKeep: Number.MAX_SAFE_INTEGER,
          encoding: "utf8",
          mode: parseInt("0644", 8),
          flags: "a",
          compress: false,
          keepFileExt: false,
          alwaysIncludePattern: false
        };
        const options = Object.assign({}, defaultOptions2, rawOptions);
        if (options.maxSize <= 0) {
          throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);
        }
        if (options.numToKeep <= 0) {
          throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);
        }
        debug(`_parseOption: creating stream with option=${JSON.stringify(options)}`);
        return options;
      }
      _final(callback) {
        this.currentFileStream.end("", this.options.encoding, callback);
      }
      _write(chunk, encoding, callback) {
        this._shouldRoll().then(() => {
          debug(`_write: writing chunk. file=${this.currentFileStream.path} state=${JSON.stringify(this.state)} chunk=${chunk}`);
          this.currentFileStream.write(chunk, encoding, (e) => {
            this.state.currentSize += chunk.length;
            callback(e);
          });
        });
      }
      async _shouldRoll() {
        if (this._dateChanged() || this._tooBig()) {
          debug(`_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`);
          await this._roll();
        }
      }
      _dateChanged() {
        return this.state.currentDate && this.state.currentDate !== format2(this.options.pattern, newNow());
      }
      _tooBig() {
        return this.state.currentSize >= this.options.maxSize;
      }
      _roll() {
        debug(`_roll: closing the current stream`);
        return new Promise((resolve3, reject) => {
          this.currentFileStream.end("", this.options.encoding, () => {
            this._moveOldFiles().then(resolve3).catch(reject);
          });
        });
      }
      async _moveOldFiles() {
        const files = await this._getExistingFiles();
        const todaysFiles = this.state.currentDate ? files.filter((f) => f.date === this.state.currentDate) : files;
        for (let i = todaysFiles.length; i >= 0; i--) {
          debug(`_moveOldFiles: i = ${i}`);
          const sourceFilePath = this.fileFormatter({
            date: this.state.currentDate,
            index: i
          });
          const targetFilePath = this.fileFormatter({
            date: this.state.currentDate,
            index: i + 1
          });
          await moveAndMaybeCompressFile(sourceFilePath, targetFilePath, this.options.compress && i === 0);
        }
        this.state.currentSize = 0;
        this.state.currentDate = this.state.currentDate ? format2(this.options.pattern, newNow()) : null;
        debug(`_moveOldFiles: finished rolling files. state=${JSON.stringify(this.state)}`);
        this._renewWriteStream();
        await new Promise((resolve3, reject) => {
          this.currentFileStream.write("", "utf8", () => {
            this._clean().then(resolve3).catch(reject);
          });
        });
      }
      async _getExistingFiles() {
        const files = await fs27.readdir(this.fileObject.dir).catch(() => []);
        debug(`_getExistingFiles: files=${files}`);
        const existingFileDetails = files.map((n) => this.fileNameParser(n)).filter((n) => n);
        const getKey = (n) => (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;
        existingFileDetails.sort((a, b) => getKey(a) - getKey(b));
        return existingFileDetails;
      }
      _renewWriteStream() {
        fs27.ensureDirSync(this.fileObject.dir);
        const filePath = this.fileFormatter({
          date: this.state.currentDate,
          index: 0
        });
        const ops = {
          flags: this.options.flags,
          encoding: this.options.encoding,
          mode: this.options.mode
        };
        this.currentFileStream = fs27.createWriteStream(filePath, ops);
        this.currentFileStream.on("error", (e) => {
          this.emit("error", e);
        });
      }
      async _clean() {
        const existingFileDetails = await this._getExistingFiles();
        debug(`_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`);
        debug("_clean: existing files are: ", existingFileDetails);
        if (this._tooManyFiles(existingFileDetails.length)) {
          const fileNamesToRemove = existingFileDetails.slice(0, existingFileDetails.length - this.options.numToKeep - 1).map((f) => path36.format({ dir: this.fileObject.dir, base: f.filename }));
          await deleteFiles(fileNamesToRemove);
        }
      }
      _tooManyFiles(numFiles) {
        return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;
      }
    };
    var deleteFiles = (fileNames) => {
      debug(`deleteFiles: files to delete: ${fileNames}`);
      return Promise.all(fileNames.map((f) => fs27.unlink(f).catch((e) => {
        debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);
      })));
    };
    module2.exports = RollingFileWriteStream;
  }
});

// node_modules/streamroller/lib/RollingFileStream.js
var require_RollingFileStream = __commonJS({
  "node_modules/streamroller/lib/RollingFileStream.js"(exports2, module2) {
    var RollingFileWriteStream = require_RollingFileWriteStream();
    var RollingFileStream = class extends RollingFileWriteStream {
      constructor(filename, size, backups, options) {
        if (!options) {
          options = {};
        }
        if (size) {
          options.maxSize = size;
        }
        if (!backups) {
          backups = 1;
        }
        options.numToKeep = backups;
        super(filename, options);
        this.backups = this.options.numToKeep;
        this.size = this.options.maxSize;
      }
      get theStream() {
        return this.currentFileStream;
      }
    };
    module2.exports = RollingFileStream;
  }
});

// node_modules/streamroller/lib/DateRollingFileStream.js
var require_DateRollingFileStream = __commonJS({
  "node_modules/streamroller/lib/DateRollingFileStream.js"(exports2, module2) {
    var RollingFileWriteStream = require_RollingFileWriteStream();
    var DateRollingFileStream = class extends RollingFileWriteStream {
      constructor(filename, pattern, options) {
        if (pattern && typeof pattern === "object") {
          options = pattern;
          pattern = null;
        }
        if (!options) {
          options = {};
        }
        if (!pattern) {
          pattern = "yyyy-MM-dd";
        }
        if (options.daysToKeep) {
          options.numToKeep = options.daysToKeep;
        }
        if (pattern.startsWith(".")) {
          pattern = pattern.substring(1);
        }
        options.pattern = pattern;
        super(filename, options);
        this.mode = this.options.mode;
      }
      get theStream() {
        return this.currentFileStream;
      }
    };
    module2.exports = DateRollingFileStream;
  }
});

// node_modules/streamroller/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/streamroller/lib/index.js"(exports2, module2) {
    module2.exports = {
      RollingFileWriteStream: require_RollingFileWriteStream(),
      RollingFileStream: require_RollingFileStream(),
      DateRollingFileStream: require_DateRollingFileStream()
    };
  }
});

// node_modules/log4js/lib/appenders/file.js
var require_file2 = __commonJS({
  "node_modules/log4js/lib/appenders/file.js"(exports2, module2) {
    var debug = require_src()("log4js:file");
    var path36 = require("path");
    var streams = require_lib4();
    var os10 = require("os");
    var eol = os10.EOL;
    function openTheStream(file, fileSize, numFiles, options) {
      const stream = new streams.RollingFileStream(file, fileSize, numFiles, options);
      stream.on("error", (err) => {
        console.error("log4js.fileAppender - Writing to file %s, error happened ", file, err);
      });
      stream.on("drain", () => {
        process.emit("log4js:pause", false);
      });
      return stream;
    }
    function fileAppender(file, layout, logSize, numBackups, options, timezoneOffset) {
      file = path36.normalize(file);
      numBackups = numBackups === void 0 ? 5 : numBackups;
      numBackups = numBackups === 0 ? 1 : numBackups;
      debug("Creating file appender (", file, ", ", logSize, ", ", numBackups, ", ", options, ", ", timezoneOffset, ")");
      let writer = openTheStream(file, logSize, numBackups, options);
      const app = function(loggingEvent) {
        if (options.removeColor === true) {
          const regex = /\x1b[[0-9;]*m/g;
          loggingEvent.data = loggingEvent.data.map((d) => {
            if (typeof d === "string")
              return d.replace(regex, "");
            return d;
          });
        }
        if (!writer.write(layout(loggingEvent, timezoneOffset) + eol, "utf8")) {
          process.emit("log4js:pause", true);
        }
      };
      app.reopen = function() {
        writer.end(() => {
          writer = openTheStream(file, logSize, numBackups, options);
        });
      };
      app.sighupHandler = function() {
        debug("SIGHUP handler called.");
        app.reopen();
      };
      app.shutdown = function(complete) {
        process.removeListener("SIGHUP", app.sighupHandler);
        writer.end("", "utf-8", complete);
      };
      process.on("SIGHUP", app.sighupHandler);
      return app;
    }
    function configure(config, layouts) {
      let layout = layouts.basicLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/dateFile.js
var require_dateFile = __commonJS({
  "node_modules/log4js/lib/appenders/dateFile.js"(exports2, module2) {
    var streams = require_lib4();
    var os10 = require("os");
    var eol = os10.EOL;
    function appender(filename, pattern, layout, options, timezoneOffset) {
      options.maxSize = options.maxLogSize;
      const logFile = new streams.DateRollingFileStream(filename, pattern, options);
      logFile.on("drain", () => {
        process.emit("log4js:pause", false);
      });
      const app = function(logEvent) {
        if (!logFile.write(layout(logEvent, timezoneOffset) + eol, "utf8")) {
          process.emit("log4js:pause", true);
        }
      };
      app.shutdown = function(complete) {
        logFile.write("", "utf-8", () => {
          logFile.end(complete);
        });
      };
      return app;
    }
    function configure(config, layouts) {
      let layout = layouts.basicLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      if (!config.alwaysIncludePattern) {
        config.alwaysIncludePattern = false;
      }
      return appender(config.filename, config.pattern, layout, config, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/fileSync.js
var require_fileSync = __commonJS({
  "node_modules/log4js/lib/appenders/fileSync.js"(exports2, module2) {
    var debug = require_src()("log4js:fileSync");
    var path36 = require("path");
    var fs27 = require("fs");
    var os10 = require("os");
    var eol = os10.EOL || "\n";
    function touchFile(file, options) {
      if (fs27.existsSync(file)) {
        return;
      }
      const id = fs27.openSync(file, options.flags, options.mode);
      fs27.closeSync(id);
    }
    var RollingFileSync = class {
      constructor(filename, size, backups, options) {
        debug("In RollingFileStream");
        function throwErrorIfArgumentsAreNotValid() {
          if (!filename || !size || size <= 0) {
            throw new Error("You must specify a filename and file size");
          }
        }
        throwErrorIfArgumentsAreNotValid();
        this.filename = filename;
        this.size = size;
        this.backups = backups || 1;
        this.options = options;
        this.currentSize = 0;
        function currentFileSize(file) {
          let fileSize = 0;
          try {
            fileSize = fs27.statSync(file).size;
          } catch (e) {
            touchFile(file, options);
          }
          return fileSize;
        }
        this.currentSize = currentFileSize(this.filename);
      }
      shouldRoll() {
        debug("should roll with current size %d, and max size %d", this.currentSize, this.size);
        return this.currentSize >= this.size;
      }
      roll(filename) {
        const that = this;
        const nameMatcher = new RegExp(`^${path36.basename(filename)}`);
        function justTheseFiles(item) {
          return nameMatcher.test(item);
        }
        function index(filename_) {
          return parseInt(filename_.substring(`${path36.basename(filename)}.`.length), 10) || 0;
        }
        function byIndex(a, b) {
          if (index(a) > index(b)) {
            return 1;
          }
          if (index(a) < index(b)) {
            return -1;
          }
          return 0;
        }
        function increaseFileIndex(fileToRename) {
          const idx = index(fileToRename);
          debug(`Index of ${fileToRename} is ${idx}`);
          if (idx < that.backups) {
            try {
              fs27.unlinkSync(`${filename}.${idx + 1}`);
            } catch (e) {
            }
            debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);
            fs27.renameSync(path36.join(path36.dirname(filename), fileToRename), `${filename}.${idx + 1}`);
          }
        }
        function renameTheFiles() {
          debug("Renaming the old files");
          const files = fs27.readdirSync(path36.dirname(filename));
          files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);
        }
        debug("Rolling, rolling, rolling");
        renameTheFiles();
      }
      write(chunk, encoding) {
        const that = this;
        function writeTheChunk() {
          debug("writing the chunk to the file");
          that.currentSize += chunk.length;
          fs27.appendFileSync(that.filename, chunk);
        }
        debug("in write");
        if (this.shouldRoll()) {
          this.currentSize = 0;
          this.roll(this.filename);
        }
        writeTheChunk();
      }
    };
    function fileAppender(file, layout, logSize, numBackups, timezoneOffset, options) {
      debug("fileSync appender created");
      file = path36.normalize(file);
      numBackups = numBackups === void 0 ? 5 : numBackups;
      numBackups = numBackups === 0 ? 1 : numBackups;
      function openTheStream(filePath, fileSize, numFiles) {
        let stream;
        if (fileSize) {
          stream = new RollingFileSync(filePath, fileSize, numFiles, options);
        } else {
          stream = ((f) => {
            touchFile(f, options);
            return {
              write(data) {
                fs27.appendFileSync(f, data);
              }
            };
          })(filePath);
        }
        return stream;
      }
      const logFile = openTheStream(file, logSize, numBackups);
      return (loggingEvent) => {
        logFile.write(layout(loggingEvent, timezoneOffset) + eol);
      };
    }
    function configure(config, layouts) {
      let layout = layouts.basicLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      const options = {
        flags: config.flags || "a",
        encoding: config.encoding || "utf8",
        mode: config.mode || 420
      };
      return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config.timezoneOffset, options);
    }
    module2.exports.configure = configure;
  }
});

// env-ns:node_modules/log4js/lib/appenders
var require_appenders = __commonJS({
  "env-ns:node_modules/log4js/lib/appenders"(exports2, module2) {
    var path36 = require("path");
    var debug = require_src()("log4js:appenders");
    var configuration = require_configuration();
    var clustering = require_clustering();
    var levels = require_levels();
    var layouts = require_layouts();
    var adapters = require_adapters();
    var coreAppenders = new Map();
    coreAppenders.set("console", require_console());
    coreAppenders.set("stdout", require_stdout());
    coreAppenders.set("stderr", require_stderr());
    coreAppenders.set("logLevelFilter", require_logLevelFilter());
    coreAppenders.set("categoryFilter", require_categoryFilter());
    coreAppenders.set("noLogFilter", require_noLogFilter());
    coreAppenders.set("file", require_file2());
    coreAppenders.set("dateFile", require_dateFile());
    coreAppenders.set("fileSync", require_fileSync());
    var appenders = new Map();
    var tryLoading = (modulePath, config) => {
      debug("Loading module from ", modulePath);
      try {
        return require(modulePath);
      } catch (e) {
        configuration.throwExceptionIf(config, e.code !== "MODULE_NOT_FOUND", `appender "${modulePath}" could not be loaded (error was: ${e})`);
        return void 0;
      }
    };
    var loadAppenderModule = (type, config) => coreAppenders.get(type) || tryLoading(`./${type}`, config) || tryLoading(type, config) || "" || tryLoading(path36.join(process.cwd(), type), config);
    var appendersLoading = new Set();
    var getAppender = (name2, config) => {
      if (appenders.has(name2))
        return appenders.get(name2);
      if (!config.appenders[name2])
        return false;
      if (appendersLoading.has(name2))
        throw new Error(`Dependency loop detected for appender ${name2}.`);
      appendersLoading.add(name2);
      debug(`Creating appender ${name2}`);
      const appender = createAppender(name2, config);
      appendersLoading.delete(name2);
      appenders.set(name2, appender);
      return appender;
    };
    var createAppender = (name2, config) => {
      const appenderConfig = config.appenders[name2];
      const appenderModule = appenderConfig.type.configure ? appenderConfig.type : loadAppenderModule(appenderConfig.type, config);
      configuration.throwExceptionIf(config, configuration.not(appenderModule), `appender "${name2}" is not valid (type "${appenderConfig.type}" could not be found)`);
      if (appenderModule.appender) {
        debug(`DEPRECATION: Appender ${appenderConfig.type} exports an appender function.`);
      }
      if (appenderModule.shutdown) {
        debug(`DEPRECATION: Appender ${appenderConfig.type} exports a shutdown function.`);
      }
      debug(`${name2}: clustering.isMaster ? ${clustering.isMaster()}`);
      debug(`${name2}: appenderModule is ${require("util").inspect(appenderModule)}`);
      return clustering.onlyOnMaster(() => {
        debug(`calling appenderModule.configure for ${name2} / ${appenderConfig.type}`);
        return appenderModule.configure(adapters.modifyConfig(appenderConfig), layouts, (appender) => getAppender(appender, config), levels);
      }, () => {
      });
    };
    var setup = (config) => {
      appenders.clear();
      appendersLoading.clear();
      const usedAppenders = [];
      Object.values(config.categories).forEach((category) => {
        usedAppenders.push(...category.appenders);
      });
      Object.keys(config.appenders).forEach((name2) => {
        if (usedAppenders.includes(name2) || config.appenders[name2].type === "tcp-server") {
          getAppender(name2, config);
        }
      });
    };
    setup({ appenders: { out: { type: "stdout" } }, categories: { default: { appenders: ["out"], level: "trace" } } });
    configuration.addListener((config) => {
      configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.appenders)), 'must have a property "appenders" of type object.');
      const appenderNames = Object.keys(config.appenders);
      configuration.throwExceptionIf(config, configuration.not(appenderNames.length), "must define at least one appender.");
      appenderNames.forEach((name2) => {
        configuration.throwExceptionIf(config, configuration.not(config.appenders[name2].type), `appender "${name2}" is not valid (must be an object with property "type")`);
      });
    });
    configuration.addListener(setup);
    module2.exports = appenders;
  }
});

// node_modules/log4js/lib/categories.js
var require_categories = __commonJS({
  "node_modules/log4js/lib/categories.js"(exports2, module2) {
    var debug = require_src()("log4js:categories");
    var configuration = require_configuration();
    var levels = require_levels();
    var appenders = require_appenders();
    var categories = new Map();
    function inheritFromParent(config, category, categoryName) {
      if (category.inherit === false)
        return;
      const lastDotIndex = categoryName.lastIndexOf(".");
      if (lastDotIndex < 0)
        return;
      const parentCategoryName = categoryName.substring(0, lastDotIndex);
      let parentCategory = config.categories[parentCategoryName];
      if (!parentCategory) {
        parentCategory = { inherit: true, appenders: [] };
      }
      inheritFromParent(config, parentCategory, parentCategoryName);
      if (!config.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) {
        config.categories[parentCategoryName] = parentCategory;
      }
      category.appenders = category.appenders || [];
      category.level = category.level || parentCategory.level;
      parentCategory.appenders.forEach((ap) => {
        if (!category.appenders.includes(ap)) {
          category.appenders.push(ap);
        }
      });
      category.parent = parentCategory;
    }
    function addCategoryInheritance(config) {
      if (!config.categories)
        return;
      const categoryNames = Object.keys(config.categories);
      categoryNames.forEach((name2) => {
        const category = config.categories[name2];
        inheritFromParent(config, category, name2);
      });
    }
    configuration.addPreProcessingListener((config) => addCategoryInheritance(config));
    configuration.addListener((config) => {
      configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.categories)), 'must have a property "categories" of type object.');
      const categoryNames = Object.keys(config.categories);
      configuration.throwExceptionIf(config, configuration.not(categoryNames.length), "must define at least one category.");
      categoryNames.forEach((name2) => {
        const category = config.categories[name2];
        configuration.throwExceptionIf(config, [
          configuration.not(category.appenders),
          configuration.not(category.level)
        ], `category "${name2}" is not valid (must be an object with properties "appenders" and "level")`);
        configuration.throwExceptionIf(config, configuration.not(Array.isArray(category.appenders)), `category "${name2}" is not valid (appenders must be an array of appender names)`);
        configuration.throwExceptionIf(config, configuration.not(category.appenders.length), `category "${name2}" is not valid (appenders must contain at least one appender name)`);
        if (Object.prototype.hasOwnProperty.call(category, "enableCallStack")) {
          configuration.throwExceptionIf(config, typeof category.enableCallStack !== "boolean", `category "${name2}" is not valid (enableCallStack must be boolean type)`);
        }
        category.appenders.forEach((appender) => {
          configuration.throwExceptionIf(config, configuration.not(appenders.get(appender)), `category "${name2}" is not valid (appender "${appender}" is not defined)`);
        });
        configuration.throwExceptionIf(config, configuration.not(levels.getLevel(category.level)), `category "${name2}" is not valid (level "${category.level}" not recognised; valid levels are ${levels.levels.join(", ")})`);
      });
      configuration.throwExceptionIf(config, configuration.not(config.categories.default), 'must define a "default" category.');
    });
    var setup = (config) => {
      categories.clear();
      const categoryNames = Object.keys(config.categories);
      categoryNames.forEach((name2) => {
        const category = config.categories[name2];
        const categoryAppenders = [];
        category.appenders.forEach((appender) => {
          categoryAppenders.push(appenders.get(appender));
          debug(`Creating category ${name2}`);
          categories.set(name2, {
            appenders: categoryAppenders,
            level: levels.getLevel(category.level),
            enableCallStack: category.enableCallStack || false
          });
        });
      });
    };
    setup({ categories: { default: { appenders: ["out"], level: "OFF" } } });
    configuration.addListener(setup);
    var configForCategory = (category) => {
      debug(`configForCategory: searching for config for ${category}`);
      if (categories.has(category)) {
        debug(`configForCategory: ${category} exists in config, returning it`);
        return categories.get(category);
      }
      if (category.indexOf(".") > 0) {
        debug(`configForCategory: ${category} has hierarchy, searching for parents`);
        return configForCategory(category.substring(0, category.lastIndexOf(".")));
      }
      debug("configForCategory: returning config for default category");
      return configForCategory("default");
    };
    var appendersForCategory = (category) => configForCategory(category).appenders;
    var getLevelForCategory = (category) => configForCategory(category).level;
    var setLevelForCategory = (category, level) => {
      let categoryConfig = categories.get(category);
      debug(`setLevelForCategory: found ${categoryConfig} for ${category}`);
      if (!categoryConfig) {
        const sourceCategoryConfig = configForCategory(category);
        debug(`setLevelForCategory: no config found for category, found ${sourceCategoryConfig} for parents of ${category}`);
        categoryConfig = { appenders: sourceCategoryConfig.appenders };
      }
      categoryConfig.level = level;
      categories.set(category, categoryConfig);
    };
    var getEnableCallStackForCategory = (category) => configForCategory(category).enableCallStack === true;
    var setEnableCallStackForCategory = (category, useCallStack) => {
      configForCategory(category).enableCallStack = useCallStack;
    };
    module2.exports = {
      appendersForCategory,
      getLevelForCategory,
      setLevelForCategory,
      getEnableCallStackForCategory,
      setEnableCallStackForCategory
    };
  }
});

// node_modules/log4js/lib/logger.js
var require_logger = __commonJS({
  "node_modules/log4js/lib/logger.js"(exports2, module2) {
    var debug = require_src()("log4js:logger");
    var LoggingEvent = require_LoggingEvent();
    var levels = require_levels();
    var clustering = require_clustering();
    var categories = require_categories();
    var configuration = require_configuration();
    var stackReg = /at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/;
    function defaultParseCallStack(data, skipIdx = 4) {
      const stacklines = data.stack.split("\n").slice(skipIdx);
      const lineMatch = stackReg.exec(stacklines[0]);
      if (lineMatch && lineMatch.length === 6) {
        return {
          functionName: lineMatch[1],
          fileName: lineMatch[2],
          lineNumber: parseInt(lineMatch[3], 10),
          columnNumber: parseInt(lineMatch[4], 10),
          callStack: stacklines.join("\n")
        };
      }
      return null;
    }
    var Logger2 = class {
      constructor(name2) {
        if (!name2) {
          throw new Error("No category provided.");
        }
        this.category = name2;
        this.context = {};
        this.parseCallStack = defaultParseCallStack;
        debug(`Logger created (${this.category}, ${this.level})`);
      }
      get level() {
        return levels.getLevel(categories.getLevelForCategory(this.category), levels.TRACE);
      }
      set level(level) {
        categories.setLevelForCategory(this.category, levels.getLevel(level, this.level));
      }
      get useCallStack() {
        return categories.getEnableCallStackForCategory(this.category);
      }
      set useCallStack(bool) {
        categories.setEnableCallStackForCategory(this.category, bool === true);
      }
      log(level, ...args) {
        const logLevel = levels.getLevel(level, levels.INFO);
        if (this.isLevelEnabled(logLevel)) {
          this._log(logLevel, args);
        }
      }
      isLevelEnabled(otherLevel) {
        return this.level.isLessThanOrEqualTo(otherLevel);
      }
      _log(level, data) {
        debug(`sending log data (${level}) to appenders`);
        const loggingEvent = new LoggingEvent(this.category, level, data, this.context, this.useCallStack && this.parseCallStack(new Error()));
        clustering.send(loggingEvent);
      }
      addContext(key, value) {
        this.context[key] = value;
      }
      removeContext(key) {
        delete this.context[key];
      }
      clearContext() {
        this.context = {};
      }
      setParseCallStackFunction(parseFunction) {
        this.parseCallStack = parseFunction;
      }
    };
    function addLevelMethods(target) {
      const level = levels.getLevel(target);
      const levelStrLower = level.toString().toLowerCase();
      const levelMethod = levelStrLower.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
      const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);
      Logger2.prototype[`is${isLevelMethod}Enabled`] = function() {
        return this.isLevelEnabled(level);
      };
      Logger2.prototype[levelMethod] = function(...args) {
        this.log(level, ...args);
      };
    }
    levels.levels.forEach(addLevelMethods);
    configuration.addListener(() => {
      levels.levels.forEach(addLevelMethods);
    });
    module2.exports = Logger2;
  }
});

// node_modules/log4js/lib/connect-logger.js
var require_connect_logger = __commonJS({
  "node_modules/log4js/lib/connect-logger.js"(exports2, module2) {
    var levels = require_levels();
    var DEFAULT_FORMAT = ':remote-addr - - ":method :url HTTP/:http-version" :status :content-length ":referrer" ":user-agent"';
    function getUrl(req) {
      return req.originalUrl || req.url;
    }
    function assembleTokens(req, res, customTokens) {
      const arrayUniqueTokens = (array) => {
        const a = array.concat();
        for (let i = 0; i < a.length; ++i) {
          for (let j = i + 1; j < a.length; ++j) {
            if (a[i].token == a[j].token) {
              a.splice(j--, 1);
            }
          }
        }
        return a;
      };
      const defaultTokens = [];
      defaultTokens.push({ token: ":url", replacement: getUrl(req) });
      defaultTokens.push({ token: ":protocol", replacement: req.protocol });
      defaultTokens.push({ token: ":hostname", replacement: req.hostname });
      defaultTokens.push({ token: ":method", replacement: req.method });
      defaultTokens.push({
        token: ":status",
        replacement: res.__statusCode || res.statusCode
      });
      defaultTokens.push({
        token: ":response-time",
        replacement: res.responseTime
      });
      defaultTokens.push({ token: ":date", replacement: new Date().toUTCString() });
      defaultTokens.push({
        token: ":referrer",
        replacement: req.headers.referer || req.headers.referrer || ""
      });
      defaultTokens.push({
        token: ":http-version",
        replacement: `${req.httpVersionMajor}.${req.httpVersionMinor}`
      });
      defaultTokens.push({
        token: ":remote-addr",
        replacement: req.headers["x-forwarded-for"] || req.ip || req._remoteAddress || req.socket && (req.socket.remoteAddress || req.socket.socket && req.socket.socket.remoteAddress)
      });
      defaultTokens.push({
        token: ":user-agent",
        replacement: req.headers["user-agent"]
      });
      defaultTokens.push({
        token: ":content-length",
        replacement: res.getHeader("content-length") || res.__headers && res.__headers["Content-Length"] || "-"
      });
      defaultTokens.push({
        token: /:req\[([^\]]+)]/g,
        replacement(_, field) {
          return req.headers[field.toLowerCase()];
        }
      });
      defaultTokens.push({
        token: /:res\[([^\]]+)]/g,
        replacement(_, field) {
          return res.getHeader(field.toLowerCase()) || res.__headers && res.__headers[field];
        }
      });
      return arrayUniqueTokens(customTokens.concat(defaultTokens));
    }
    function format2(str, tokens) {
      for (let i = 0; i < tokens.length; i++) {
        str = str.replace(tokens[i].token, tokens[i].replacement);
      }
      return str;
    }
    function createNoLogCondition(nolog) {
      let regexp = null;
      if (nolog instanceof RegExp) {
        regexp = nolog;
      }
      if (typeof nolog === "string") {
        regexp = new RegExp(nolog);
      }
      if (Array.isArray(nolog)) {
        const regexpsAsStrings = nolog.map((reg) => reg.source ? reg.source : reg);
        regexp = new RegExp(regexpsAsStrings.join("|"));
      }
      return regexp;
    }
    function matchRules(statusCode, currentLevel, ruleSet) {
      let level = currentLevel;
      if (ruleSet) {
        const matchedRule = ruleSet.find((rule) => {
          let ruleMatched = false;
          if (rule.from && rule.to) {
            ruleMatched = statusCode >= rule.from && statusCode <= rule.to;
          } else {
            ruleMatched = rule.codes.indexOf(statusCode) !== -1;
          }
          return ruleMatched;
        });
        if (matchedRule) {
          level = levels.getLevel(matchedRule.level, level);
        }
      }
      return level;
    }
    module2.exports = function getLogger(logger4js, options) {
      if (typeof options === "string" || typeof options === "function") {
        options = { format: options };
      } else {
        options = options || {};
      }
      const thisLogger = logger4js;
      let level = levels.getLevel(options.level, levels.INFO);
      const fmt = options.format || DEFAULT_FORMAT;
      const nolog = createNoLogCondition(options.nolog);
      return (req, res, next) => {
        if (req._logging)
          return next();
        if (nolog && nolog.test(req.originalUrl))
          return next();
        if (thisLogger.isLevelEnabled(level) || options.level === "auto") {
          const start = new Date();
          const { writeHead } = res;
          req._logging = true;
          res.writeHead = (code, headers) => {
            res.writeHead = writeHead;
            res.writeHead(code, headers);
            res.__statusCode = code;
            res.__headers = headers || {};
          };
          res.on("finish", () => {
            res.responseTime = new Date() - start;
            if (res.statusCode && options.level === "auto") {
              level = levels.INFO;
              if (res.statusCode >= 300)
                level = levels.WARN;
              if (res.statusCode >= 400)
                level = levels.ERROR;
            }
            level = matchRules(res.statusCode, level, options.statusRules);
            const combinedTokens = assembleTokens(req, res, options.tokens || []);
            if (options.context)
              thisLogger.addContext("res", res);
            if (typeof fmt === "function") {
              const line = fmt(req, res, (str) => format2(str, combinedTokens));
              if (line)
                thisLogger.log(level, line);
            } else {
              thisLogger.log(level, format2(fmt, combinedTokens));
            }
            if (options.context)
              thisLogger.removeContext("res");
          });
        }
        return next();
      };
    };
  }
});

// node_modules/log4js/lib/log4js.js
var require_log4js = __commonJS({
  "node_modules/log4js/lib/log4js.js"(exports2, module2) {
    var debug = require_src()("log4js:main");
    var fs27 = require("fs");
    var deepClone2 = require_rfdc()({ proto: true });
    var configuration = require_configuration();
    var layouts = require_layouts();
    var levels = require_levels();
    var appenders = require_appenders();
    var categories = require_categories();
    var Logger2 = require_logger();
    var clustering = require_clustering();
    var connectLogger = require_connect_logger();
    var enabled = false;
    function sendLogEventToAppender(logEvent) {
      if (!enabled)
        return;
      debug("Received log event ", logEvent);
      const categoryAppenders = categories.appendersForCategory(logEvent.categoryName);
      categoryAppenders.forEach((appender) => {
        appender(logEvent);
      });
    }
    function loadConfigurationFile(filename) {
      debug(`Loading configuration from ${filename}`);
      try {
        return JSON.parse(fs27.readFileSync(filename, "utf8"));
      } catch (e) {
        throw new Error(`Problem reading config from file "${filename}". Error was ${e.message}`, e);
      }
    }
    function configure(configurationFileOrObject) {
      let configObject = configurationFileOrObject;
      if (typeof configObject === "string") {
        configObject = loadConfigurationFile(configurationFileOrObject);
      }
      debug(`Configuration is ${configObject}`);
      configuration.configure(deepClone2(configObject));
      clustering.onMessage(sendLogEventToAppender);
      enabled = true;
      return log4js2;
    }
    function shutdown(cb) {
      debug("Shutdown called. Disabling all log writing.");
      enabled = false;
      const appendersToCheck = Array.from(appenders.values());
      const shutdownFunctions = appendersToCheck.reduceRight((accum, next) => next.shutdown ? accum + 1 : accum, 0);
      let completed = 0;
      let error;
      debug(`Found ${shutdownFunctions} appenders with shutdown functions.`);
      function complete(err) {
        error = error || err;
        completed += 1;
        debug(`Appender shutdowns complete: ${completed} / ${shutdownFunctions}`);
        if (completed >= shutdownFunctions) {
          debug("All shutdown functions completed.");
          if (cb) {
            cb(error);
          }
        }
      }
      if (shutdownFunctions === 0) {
        debug("No appenders with shutdown functions found.");
        return cb !== void 0 && cb();
      }
      appendersToCheck.filter((a) => a.shutdown).forEach((a) => a.shutdown(complete));
      return null;
    }
    function getLogger(category) {
      if (!enabled) {
        configure(process.env.LOG4JS_CONFIG || {
          appenders: { out: { type: "stdout" } },
          categories: { default: { appenders: ["out"], level: "OFF" } }
        });
      }
      return new Logger2(category || "default");
    }
    var log4js2 = {
      getLogger,
      configure,
      shutdown,
      connectLogger,
      levels,
      addLayout: layouts.addLayout
    };
    module2.exports = log4js2;
  }
});

// node_modules/fs-extra/node_modules/universalify/index.js
var require_universalify2 = __commonJS({
  "node_modules/fs-extra/node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve3, reject) => {
            fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve3(res));
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs2 = __commonJS({
  "node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var fs27 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs27[key] === "function";
    });
    Object.keys(fs27).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports2[key] = fs27[key];
    });
    api.forEach((method) => {
      exports2[method] = u(fs27[method]);
    });
    exports2.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs27.exists(filename, callback);
      }
      return new Promise((resolve3) => {
        return fs27.exists(filename, resolve3);
      });
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs27.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve3, reject) => {
        fs27.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs27.write(fd, buffer, ...args);
      }
      return new Promise((resolve3, reject) => {
        fs27.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs27.writev === "function") {
      exports2.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs27.writev(fd, buffers, ...args);
        }
        return new Promise((resolve3, reject) => {
          fs27.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err)
              return reject(err);
            resolve3({ bytesWritten, buffers: buffers2 });
          });
        });
      };
    }
    if (typeof fs27.realpath.native === "function") {
      exports2.realpath.native = u(fs27.realpath.native);
    }
  }
});

// node_modules/at-least-node/index.js
var require_at_least_node = __commonJS({
  "node_modules/at-least-node/index.js"(exports2, module2) {
    module2.exports = (r) => {
      const n = process.versions.node.split(".").map((x) => parseInt(x, 10));
      r = r.split(".").map((x) => parseInt(x, 10));
      return n[0] > r[0] || n[0] === r[0] && (n[1] > r[1] || n[1] === r[1] && n[2] >= r[2]);
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports2, module2) {
    "use strict";
    var fs27 = require_fs2();
    var path36 = require("path");
    var atLeastNode = require_at_least_node();
    var useNativeRecursiveOption = atLeastNode("10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path36.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var processOptions = (options) => {
      const defaults2 = { mode: 511 };
      if (typeof options === "number")
        options = { mode: options };
      return __spreadValues(__spreadValues({}, defaults2), options);
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    module2.exports.makeDir = async (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption) {
        const pth = path36.resolve(input);
        return fs27.mkdir(pth, {
          mode: options.mode,
          recursive: true
        });
      }
      const make = async (pth) => {
        try {
          await fs27.mkdir(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path36.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path36.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await fs27.stat(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
      };
      return make(path36.resolve(input));
    };
    module2.exports.makeDirSync = (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption) {
        const pth = path36.resolve(input);
        return fs27.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
      }
      const make = (pth) => {
        try {
          fs27.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path36.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path36.dirname(pth));
            return make(pth);
          }
          try {
            if (!fs27.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
      };
      return make(path36.resolve(input));
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs3 = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes2 = __commonJS({
  "node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    function utimesMillis(path36, atime, mtime, callback) {
      fs27.open(path36, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs27.futimes(fd, atime, mtime, (futimesErr) => {
          fs27.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path36, atime, mtime) {
      const fd = fs27.openSync(path36, "r+");
      fs27.futimesSync(fd, atime, mtime);
      return fs27.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat2 = __commonJS({
  "node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    var fs27 = require_fs2();
    var path36 = require("path");
    var util4 = require("util");
    var atLeastNode = require_at_least_node();
    var nodeSupportsBigInt = atLeastNode("10.5.0");
    var stat = (file) => nodeSupportsBigInt ? fs27.stat(file, { bigint: true }) : fs27.stat(file);
    var statSync = (file) => nodeSupportsBigInt ? fs27.statSync(file, { bigint: true }) : fs27.statSync(file);
    function getStats(src, dest) {
      return Promise.all([
        stat(src),
        stat(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest) {
      let destStat;
      const srcStat = statSync(src);
      try {
        destStat = statSync(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, cb) {
      util4.callbackify(getStats)(src, dest, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat && areIdentical(srcStat, destStat)) {
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName) {
      const { srcStat, destStat } = getStatsSync(src, dest);
      if (destStat && areIdentical(srcStat, destStat)) {
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path36.resolve(path36.dirname(src));
      const destParent = path36.resolve(path36.dirname(dest));
      if (destParent === srcParent || destParent === path36.parse(destParent).root)
        return cb();
      const callback = (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      };
      if (nodeSupportsBigInt)
        fs27.stat(destParent, { bigint: true }, callback);
      else
        fs27.stat(destParent, callback);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path36.resolve(path36.dirname(src));
      const destParent = path36.resolve(path36.dirname(dest));
      if (destParent === srcParent || destParent === path36.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = statSync(destParent);
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
          return true;
        }
        if (destStat.size === srcStat.size && destStat.mode === srcStat.mode && destStat.nlink === srcStat.nlink && destStat.atimeMs === srcStat.atimeMs && destStat.mtimeMs === srcStat.mtimeMs && destStat.ctimeMs === srcStat.ctimeMs && destStat.birthtimeMs === srcStat.birthtimeMs) {
          return true;
        }
      }
      return false;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path36.resolve(src).split(path36.sep).filter((i) => i);
      const destArr = path36.resolve(dest).split(path36.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir
    };
  }
});

// node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync3 = __commonJS({
  "node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var mkdirsSync = require_mkdirs3().mkdirsSync;
    var utimesMillisSync = require_utimes2().utimesMillisSync;
    var stat = require_stat2();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy");
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      return handleFilterAndCopy(destStat, src, dest, opts);
    }
    function handleFilterAndCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path36.dirname(dest);
      if (!fs27.existsSync(destParent))
        mkdirsSync(destParent);
      return startCopy(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs27.statSync : fs27.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs27.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs27.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs27.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs27.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs27.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs27.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path36.join(src, item);
      const destItem = path36.join(dest, item);
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy");
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs27.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path36.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs27.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs27.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs27.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path36.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs27.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs27.unlinkSync(dest);
      return fs27.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync4 = __commonJS({
  "node_modules/fs-extra/lib/copy-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copySync: require_copy_sync3()
    };
  }
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists2 = __commonJS({
  "node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var fs27 = require_fs2();
    function pathExists(path36) {
      return fs27.access(path36).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs27.existsSync
    };
  }
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy3 = __commonJS({
  "node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var mkdirs = require_mkdirs3().mkdirs;
    var pathExists = require_path_exists2().pathExists;
    var utimesMillis = require_utimes2().utimesMillis;
    var stat = require_stat2();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      stat.checkPaths(src, dest, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          if (opts.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
          return checkParentDir(destStat, src, dest, opts, cb);
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path36.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return startCopy(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return startCopy(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include)
          return onInclude(destStat, src, dest, opts, cb);
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat2 = opts.dereference ? fs27.stat : fs27.lstat;
      stat2(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs27.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      fs27.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs27.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs27.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs27.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs27.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path36.join(src, item);
      const destItem = path36.join(dest, item);
      stat.checkPaths(srcItem, destItem, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs27.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path36.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs27.symlink(resolvedSrc, dest, cb);
        } else {
          fs27.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs27.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path36.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs27.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs27.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy4 = __commonJS({
  "node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    module2.exports = {
      copy: u(require_copy3())
    };
  }
});

// node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf2 = __commonJS({
  "node_modules/fs-extra/lib/remove/rimraf.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var assert = require("assert");
    var isWindows4 = process.platform === "win32";
    function defaults2(options) {
      const methods2 = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods2.forEach((m) => {
        options[m] = options[m] || fs27[m];
        m = m + "Sync";
        options[m] = options[m] || fs27[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf(p, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults2(options);
      rimraf_(p, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p, options, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows4) {
          return fixWinEPERM(p, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir(p, options, er, cb);
        }
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows4 ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir(p, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options, er) {
      let stats;
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options.rmdir(p, cb);
        files.forEach((f) => {
          rimraf(path36.join(p, f), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options) {
      let st;
      options = options || {};
      defaults2(options);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows4) {
          fixWinEPERMSync(p, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows4 ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p, options, er);
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path36.join(p, f), options));
      if (isWindows4) {
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p, options);
            return ret;
          } catch {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options.rmdirSync(p, options);
        return ret;
      }
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove2 = __commonJS({
  "node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var rimraf = require_rimraf2();
    module2.exports = {
      remove: u(rimraf),
      removeSync: rimraf.sync
    };
  }
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty2 = __commonJS({
  "node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var mkdir = require_mkdirs3();
    var remove = require_remove2();
    var emptyDir = u(function emptyDir2(dir, callback) {
      callback = callback || function() {
      };
      fs27.readdir(dir, (err, items) => {
        if (err)
          return mkdir.mkdirs(dir, callback);
        items = items.map((item) => path36.join(dir, item));
        deleteItem();
        function deleteItem() {
          const item = items.pop();
          if (!item)
            return callback();
          remove.remove(item, (err2) => {
            if (err2)
              return callback(err2);
            deleteItem();
          });
        }
      });
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs27.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path36.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file3 = __commonJS({
  "node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var path36 = require("path");
    var fs27 = require_graceful_fs();
    var mkdir = require_mkdirs3();
    function createFile(file, callback) {
      function makeFile() {
        fs27.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs27.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path36.dirname(file);
        fs27.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs27.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs27.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path36.dirname(file);
      try {
        if (!fs27.statSync(dir).isDirectory()) {
          fs27.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err;
      }
      fs27.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var path36 = require("path");
    var fs27 = require_graceful_fs();
    var mkdir = require_mkdirs3();
    var pathExists = require_path_exists2().pathExists;
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs27.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        fs27.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          const dir = path36.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      const destinationExists = fs27.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      try {
        fs27.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path36.dirname(dstpath);
      const dirExists = fs27.existsSync(dir);
      if (dirExists)
        return fs27.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs27.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path36 = require("path");
    var fs27 = require_graceful_fs();
    var pathExists = require_path_exists2().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path36.isAbsolute(srcpath)) {
        return fs27.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path36.dirname(dstpath);
        const relativeToDst = path36.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs27.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path36.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path36.isAbsolute(srcpath)) {
        exists = fs27.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path36.dirname(dstpath);
        const relativeToDst = path36.join(dstdir, srcpath);
        exists = fs27.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists = fs27.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path36.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs27.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs27.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var path36 = require("path");
    var fs27 = require_graceful_fs();
    var _mkdirs = require_mkdirs3();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths2();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type2();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists2().pathExists;
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        symlinkPaths(srcpath, dstpath, (err2, relative) => {
          if (err2)
            return callback(err2);
          srcpath = relative.toDst;
          symlinkType(relative.toCwd, type, (err3, type2) => {
            if (err3)
              return callback(err3);
            const dir = path36.dirname(dstpath);
            pathExists(dir, (err4, dirExists) => {
              if (err4)
                return callback(err4);
              if (dirExists)
                return fs27.symlink(srcpath, dstpath, type2, callback);
              mkdirs(dir, (err5) => {
                if (err5)
                  return callback(err5);
                fs27.symlink(srcpath, dstpath, type2, callback);
              });
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      const destinationExists = fs27.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path36.dirname(dstpath);
      const exists = fs27.existsSync(dir);
      if (exists)
        return fs27.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs27.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var file = require_file3();
    var link = require_link2();
    var symlink = require_symlink2();
    module2.exports = {
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };
  }
});

// node_modules/jsonfile/node_modules/universalify/index.js
var require_universalify3 = __commonJS({
  "node_modules/jsonfile/node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve3, reject) => {
            fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve3(res));
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils = __commonJS({
  "node_modules/jsonfile/utils.js"(exports2, module2) {
    function stringify3(obj, { EOL: EOL2 = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL2 : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL2) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify: stringify3, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile3 = __commonJS({
  "node_modules/jsonfile/index.js"(exports2, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    var universalify = require_universalify3();
    var { stringify: stringify3, stripBom } = require_utils();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs27 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs27.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile2 = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs27 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs27.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs27 = options.fs || _fs;
      const str = stringify3(obj, options);
      await universalify.fromCallback(fs27.writeFile)(file, str, options);
    }
    var writeFile2 = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs27 = options.fs || _fs;
      const str = stringify3(obj, options);
      return fs27.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync,
      writeFile: writeFile2,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile4 = __commonJS({
  "node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var jsonFile = require_jsonfile3();
    module2.exports = {
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/fs-extra/lib/output/index.js
var require_output2 = __commonJS({
  "node_modules/fs-extra/lib/output/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var mkdir = require_mkdirs3();
    var pathExists = require_path_exists2().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path36.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs27.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs27.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path36.dirname(file);
      if (fs27.existsSync(dir)) {
        return fs27.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs27.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json2 = __commonJS({
  "node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var { stringify: stringify3 } = require_utils();
    var { outputFile } = require_output2();
    async function outputJson(file, data, options = {}) {
      const str = stringify3(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync2 = __commonJS({
  "node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var { stringify: stringify3 } = require_utils();
    var { outputFileSync } = require_output2();
    function outputJsonSync(file, data, options) {
      const str = stringify3(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/fs-extra/lib/json/index.js
var require_json2 = __commonJS({
  "node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var jsonFile = require_jsonfile4();
    jsonFile.outputJson = u(require_output_json2());
    jsonFile.outputJsonSync = require_output_json_sync2();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync3 = __commonJS({
  "node_modules/fs-extra/lib/move-sync/move-sync.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var copySync = require_copy_sync4().copySync;
    var removeSync = require_remove2().removeSync;
    var mkdirpSync = require_mkdirs3().mkdirpSync;
    var stat = require_stat2();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat } = stat.checkPathsSync(src, dest, "move");
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      mkdirpSync(path36.dirname(dest));
      return doRename(src, dest, overwrite);
    }
    function doRename(src, dest, overwrite) {
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs27.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs27.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync4 = __commonJS({
  "node_modules/fs-extra/lib/move-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      moveSync: require_move_sync3()
    };
  }
});

// node_modules/fs-extra/lib/move/move.js
var require_move3 = __commonJS({
  "node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    var fs27 = require_graceful_fs();
    var path36 = require("path");
    var copy = require_copy4().copy;
    var remove = require_remove2().remove;
    var mkdirp = require_mkdirs3().mkdirp;
    var pathExists = require_path_exists2().pathExists;
    var stat = require_stat2();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const overwrite = opts.overwrite || opts.clobber || false;
      stat.checkPaths(src, dest, "move", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          mkdirp(path36.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, cb);
          });
        });
      });
    }
    function doRename(src, dest, overwrite, cb) {
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs27.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module2.exports = move;
  }
});

// node_modules/fs-extra/lib/move/index.js
var require_move4 = __commonJS({
  "node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    module2.exports = {
      move: u(require_move3())
    };
  }
});

// node_modules/fs-extra/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, require_fs2()), require_copy_sync4()), require_copy4()), require_empty2()), require_ensure2()), require_json2()), require_mkdirs3()), require_move_sync4()), require_move4()), require_output2()), require_path_exists2()), require_remove2());
    var fs27 = require("fs");
    if (Object.getOwnPropertyDescriptor(fs27, "promises")) {
      Object.defineProperty(module2.exports, "promises", {
        get() {
          return fs27.promises;
        }
      });
    }
  }
});

// src/util/logger.ts
var require_logger2 = __commonJS({
  "src/util/logger.ts"(exports2, module2) {
    var import_fs38 = __toModule(require("fs"));
    var import_log4js2 = __toModule(require_log4js());
    var import_path38 = __toModule(require("path"));
    var import_os10 = __toModule(require("os"));
    var import_fs_extra10 = __toModule(require_lib5());
    function getLogFile() {
      let file = process.env.NVIM_COC_LOG_FILE;
      if (file)
        return file;
      let dir = process.env.XDG_RUNTIME_DIR;
      if (dir) {
        try {
          import_fs38.default.accessSync(dir, import_fs38.default.constants.R_OK | import_fs38.default.constants.W_OK);
          return import_path38.default.join(dir, `coc-nvim-${process.pid}.log`);
        } catch (err) {
        }
      }
      let tmpdir = import_os10.default.tmpdir();
      dir = import_path38.default.join(tmpdir, `coc.nvim-${process.pid}`);
      if (!import_fs38.default.existsSync(dir))
        (0, import_fs_extra10.mkdirpSync)(dir);
      return import_path38.default.join(dir, `coc-nvim.log`);
    }
    var MAX_LOG_SIZE = 1024 * 1024;
    var MAX_LOG_BACKUPS = 10;
    var logfile = getLogFile();
    var level = process.env.NVIM_COC_LOG_LEVEL || "info";
    if (import_fs38.default.existsSync(logfile)) {
      try {
        import_fs38.default.writeFileSync(logfile, "", { encoding: "utf8", mode: 438 });
      } catch (e) {
      }
    }
    import_log4js2.default.configure({
      disableClustering: true,
      appenders: {
        out: {
          type: "file",
          mode: 438,
          filename: logfile,
          maxLogSize: MAX_LOG_SIZE,
          backups: MAX_LOG_BACKUPS,
          layout: {
            type: "pattern",
            pattern: `%d{ISO8601} %p (pid:${process.pid}) [%c] - %m`
          }
        }
      },
      categories: {
        default: { appenders: ["out"], level }
      }
    });
    module2.exports = (name2 = "coc-nvim") => {
      let logger113 = import_log4js2.default.getLogger(name2);
      logger113.getLogFile = () => logfile;
      return logger113;
    };
  }
});

// src/util/extensions.ts
var require_extensions = __commonJS({
  "src/util/extensions.ts"() {
    Promise.prototype.logError = function() {
      this.catch((e) => {
        require_logger2()("extensions").error(e);
      });
    };
  }
});

// node_modules/msgpack-lite/lib/buffer-global.js
var require_buffer_global = __commonJS({
  "node_modules/msgpack-lite/lib/buffer-global.js"(exports2, module2) {
    module2.exports = c(typeof Buffer !== "undefined" && Buffer) || c(exports2.Buffer) || c(typeof window !== "undefined" && window.Buffer) || exports2.Buffer;
    function c(B) {
      return B && B.isBuffer && B;
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/msgpack-lite/lib/bufferish-array.js
var require_bufferish_array = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-array.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var exports2 = module2.exports = alloc(0);
    exports2.alloc = alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Array(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return Array.prototype.slice.call(value);
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-buffer.js
var require_bufferish_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-buffer.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var Buffer4 = Bufferish.global;
    var exports2 = module2.exports = Bufferish.hasBuffer ? alloc(0) : [];
    exports2.alloc = Bufferish.hasBuffer && Buffer4.alloc || alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Buffer4(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (Buffer4.from && Buffer4.from.length !== 1) {
        return Buffer4.from(value);
      } else {
        return new Buffer4(value);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-uint8array.js
var require_bufferish_uint8array = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-uint8array.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var exports2 = module2.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];
    exports2.alloc = alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Uint8Array(size);
    }
    function from(value) {
      if (Bufferish.isView(value)) {
        var byteOffset = value.byteOffset;
        var byteLength2 = value.byteLength;
        value = value.buffer;
        if (value.byteLength !== byteLength2) {
          if (value.slice) {
            value = value.slice(byteOffset, byteOffset + byteLength2);
          } else {
            value = new Uint8Array(value);
            if (value.byteLength !== byteLength2) {
              value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength2);
            }
          }
        }
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return new Uint8Array(value);
    }
  }
});

// node_modules/msgpack-lite/lib/buffer-lite.js
var require_buffer_lite = __commonJS({
  "node_modules/msgpack-lite/lib/buffer-lite.js"(exports2) {
    exports2.copy = copy;
    exports2.toString = toString;
    exports2.write = write;
    function write(string2, offset) {
      var buffer = this;
      var index = offset || (offset |= 0);
      var length = string2.length;
      var chr = 0;
      var i = 0;
      while (i < length) {
        chr = string2.charCodeAt(i++);
        if (chr < 128) {
          buffer[index++] = chr;
        } else if (chr < 2048) {
          buffer[index++] = 192 | chr >>> 6;
          buffer[index++] = 128 | chr & 63;
        } else if (chr < 55296 || chr > 57343) {
          buffer[index++] = 224 | chr >>> 12;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        } else {
          chr = (chr - 55296 << 10 | string2.charCodeAt(i++) - 56320) + 65536;
          buffer[index++] = 240 | chr >>> 18;
          buffer[index++] = 128 | chr >>> 12 & 63;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        }
      }
      return index - offset;
    }
    function toString(encoding, start, end) {
      var buffer = this;
      var index = start | 0;
      if (!end)
        end = buffer.length;
      var string2 = "";
      var chr = 0;
      while (index < end) {
        chr = buffer[index++];
        if (chr < 128) {
          string2 += String.fromCharCode(chr);
          continue;
        }
        if ((chr & 224) === 192) {
          chr = (chr & 31) << 6 | buffer[index++] & 63;
        } else if ((chr & 240) === 224) {
          chr = (chr & 15) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        } else if ((chr & 248) === 240) {
          chr = (chr & 7) << 18 | (buffer[index++] & 63) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        }
        if (chr >= 65536) {
          chr -= 65536;
          string2 += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
        } else {
          string2 += String.fromCharCode(chr);
        }
      }
      return string2;
    }
    function copy(target, targetStart, start, end) {
      var i;
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (!targetStart)
        targetStart = 0;
      var len = end - start;
      if (target === this && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; i--) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        for (i = 0; i < len; i++) {
          target[i + targetStart] = this[i + start];
        }
      }
      return len;
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-proto.js
var require_bufferish_proto = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-proto.js"(exports2) {
    var BufferLite = require_buffer_lite();
    exports2.copy = copy;
    exports2.slice = slice;
    exports2.toString = toString;
    exports2.write = gen("write");
    var Bufferish = require_bufferish();
    var Buffer4 = Bufferish.global;
    var isBufferShim = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer4;
    var brokenTypedArray = isBufferShim && !Buffer4.TYPED_ARRAY_SUPPORT;
    function copy(target, targetStart, start, end) {
      var thisIsBuffer = Bufferish.isBuffer(this);
      var targetIsBuffer = Bufferish.isBuffer(target);
      if (thisIsBuffer && targetIsBuffer) {
        return this.copy(target, targetStart, start, end);
      } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {
        var buffer = start || end != null ? slice.call(this, start, end) : this;
        target.set(buffer, targetStart);
        return buffer.length;
      } else {
        return BufferLite.copy.call(this, target, targetStart, start, end);
      }
    }
    function slice(start, end) {
      var f = this.slice || !brokenTypedArray && this.subarray;
      if (f)
        return f.call(this, start, end);
      var target = Bufferish.alloc.call(this, end - start);
      copy.call(this, target, 0, start, end);
      return target;
    }
    function toString(encoding, start, end) {
      var f = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;
      return f.apply(this, arguments);
    }
    function gen(method) {
      return wrap;
      function wrap() {
        var f = this[method] || BufferLite[method];
        return f.apply(this, arguments);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish.js
var require_bufferish = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish.js"(exports2) {
    var Buffer4 = exports2.global = require_buffer_global();
    var hasBuffer = exports2.hasBuffer = Buffer4 && !!Buffer4.isBuffer;
    var hasArrayBuffer = exports2.hasArrayBuffer = typeof ArrayBuffer !== "undefined";
    var isArray = exports2.isArray = require_isarray();
    exports2.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
    var isBuffer = exports2.isBuffer = hasBuffer ? Buffer4.isBuffer : _false;
    var isView = exports2.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
    exports2.alloc = alloc;
    exports2.concat = concat;
    exports2.from = from;
    var BufferArray = exports2.Array = require_bufferish_array();
    var BufferBuffer = exports2.Buffer = require_bufferish_buffer();
    var BufferUint8Array = exports2.Uint8Array = require_bufferish_uint8array();
    var BufferProto = exports2.prototype = require_bufferish_proto();
    function from(value) {
      if (typeof value === "string") {
        return fromString.call(this, value);
      } else {
        return auto(this).from(value);
      }
    }
    function alloc(size) {
      return auto(this).alloc(size);
    }
    function concat(list2, length) {
      if (!length) {
        length = 0;
        Array.prototype.forEach.call(list2, dryrun);
      }
      var ref = this !== exports2 && this || list2[0];
      var result = alloc.call(ref, length);
      var offset = 0;
      Array.prototype.forEach.call(list2, append);
      return result;
      function dryrun(buffer) {
        length += buffer.length;
      }
      function append(buffer) {
        offset += BufferProto.copy.call(buffer, result, offset);
      }
    }
    var _isArrayBuffer = _is("ArrayBuffer");
    function isArrayBuffer(value) {
      return value instanceof ArrayBuffer || _isArrayBuffer(value);
    }
    function fromString(value) {
      var expected = value.length * 3;
      var that = alloc.call(this, expected);
      var actual = BufferProto.write.call(that, value);
      if (expected !== actual) {
        that = BufferProto.slice.call(that, 0, actual);
      }
      return that;
    }
    function auto(that) {
      return isBuffer(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
    }
    function _false() {
      return false;
    }
    function _is(name2, key) {
      name2 = "[object " + name2 + "]";
      return function(value) {
        return value != null && {}.toString.call(key ? value[key] : value) === name2;
      };
    }
  }
});

// node_modules/msgpack-lite/lib/ext-buffer.js
var require_ext_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/ext-buffer.js"(exports2) {
    exports2.ExtBuffer = ExtBuffer;
    var Bufferish = require_bufferish();
    function ExtBuffer(buffer, type) {
      if (!(this instanceof ExtBuffer))
        return new ExtBuffer(buffer, type);
      this.buffer = Bufferish.from(buffer);
      this.type = type;
    }
  }
});

// node_modules/msgpack-lite/lib/ext-packer.js
var require_ext_packer = __commonJS({
  "node_modules/msgpack-lite/lib/ext-packer.js"(exports2) {
    exports2.setExtPackers = setExtPackers;
    var Bufferish = require_bufferish();
    var Buffer4 = Bufferish.global;
    var packTypedArray = Bufferish.Uint8Array.from;
    var _encode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtPackers(codec) {
      codec.addExtPacker(14, Error, [packError, encode]);
      codec.addExtPacker(1, EvalError, [packError, encode]);
      codec.addExtPacker(2, RangeError, [packError, encode]);
      codec.addExtPacker(3, ReferenceError, [packError, encode]);
      codec.addExtPacker(4, SyntaxError, [packError, encode]);
      codec.addExtPacker(5, TypeError, [packError, encode]);
      codec.addExtPacker(6, URIError, [packError, encode]);
      codec.addExtPacker(10, RegExp, [packRegExp, encode]);
      codec.addExtPacker(11, Boolean, [packValueOf, encode]);
      codec.addExtPacker(12, String, [packValueOf, encode]);
      codec.addExtPacker(13, Date, [Number, encode]);
      codec.addExtPacker(15, Number, [packValueOf, encode]);
      if (typeof Uint8Array !== "undefined") {
        codec.addExtPacker(17, Int8Array, packTypedArray);
        codec.addExtPacker(18, Uint8Array, packTypedArray);
        codec.addExtPacker(19, Int16Array, packTypedArray);
        codec.addExtPacker(20, Uint16Array, packTypedArray);
        codec.addExtPacker(21, Int32Array, packTypedArray);
        codec.addExtPacker(22, Uint32Array, packTypedArray);
        codec.addExtPacker(23, Float32Array, packTypedArray);
        if (typeof Float64Array !== "undefined") {
          codec.addExtPacker(24, Float64Array, packTypedArray);
        }
        if (typeof Uint8ClampedArray !== "undefined") {
          codec.addExtPacker(25, Uint8ClampedArray, packTypedArray);
        }
        codec.addExtPacker(26, ArrayBuffer, packTypedArray);
        codec.addExtPacker(29, DataView, packTypedArray);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtPacker(27, Buffer4, Bufferish.from);
      }
    }
    function encode(input) {
      if (!_encode)
        _encode = require_encode().encode;
      return _encode(input);
    }
    function packValueOf(value) {
      return value.valueOf();
    }
    function packRegExp(value) {
      value = RegExp.prototype.toString.call(value).split("/");
      value.shift();
      var out = [value.pop()];
      out.unshift(value.join("/"));
      return out;
    }
    function packError(value) {
      var out = {};
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    }
  }
});

// node_modules/int64-buffer/int64-buffer.js
var require_int64_buffer = __commonJS({
  "node_modules/int64-buffer/int64-buffer.js"(exports2) {
    var Uint64BE;
    var Int64BE;
    var Uint64LE;
    var Int64LE;
    !function(exports3) {
      var UNDEFINED = "undefined";
      var BUFFER = UNDEFINED !== typeof Buffer && Buffer;
      var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
      var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
      var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
      var isArray = Array.isArray || _isArray;
      var BIT32 = 4294967296;
      var BIT24 = 16777216;
      var storage;
      Uint64BE = factory("Uint64BE", true, true);
      Int64BE = factory("Int64BE", true, false);
      Uint64LE = factory("Uint64LE", false, true);
      Int64LE = factory("Int64LE", false, false);
      function factory(name2, bigendian, unsigned) {
        var posH = bigendian ? 0 : 4;
        var posL = bigendian ? 4 : 0;
        var pos0 = bigendian ? 0 : 3;
        var pos1 = bigendian ? 1 : 2;
        var pos2 = bigendian ? 2 : 1;
        var pos3 = bigendian ? 3 : 0;
        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
        var proto = Int64.prototype;
        var isName = "is" + name2;
        var _isInt64 = "_" + isName;
        proto.buffer = void 0;
        proto.offset = 0;
        proto[_isInt64] = true;
        proto.toNumber = toNumber;
        proto.toString = toString;
        proto.toJSON = toNumber;
        proto.toArray = toArray;
        if (BUFFER)
          proto.toBuffer = toBuffer;
        if (UINT8ARRAY)
          proto.toArrayBuffer = toArrayBuffer;
        Int64[isName] = isInt64;
        exports3[name2] = Int64;
        return Int64;
        function Int64(buffer, offset, value, raddix) {
          if (!(this instanceof Int64))
            return new Int64(buffer, offset, value, raddix);
          return init(this, buffer, offset, value, raddix);
        }
        function isInt64(b) {
          return !!(b && b[_isInt64]);
        }
        function init(that, buffer, offset, value, raddix) {
          if (UINT8ARRAY && ARRAYBUFFER) {
            if (buffer instanceof ARRAYBUFFER)
              buffer = new UINT8ARRAY(buffer);
            if (value instanceof ARRAYBUFFER)
              value = new UINT8ARRAY(value);
          }
          if (!buffer && !offset && !value && !storage) {
            that.buffer = newArray(ZERO, 0);
            return;
          }
          if (!isValidBuffer(buffer, offset)) {
            var _storage = storage || Array;
            raddix = offset;
            value = buffer;
            offset = 0;
            buffer = new _storage(8);
          }
          that.buffer = buffer;
          that.offset = offset |= 0;
          if (UNDEFINED === typeof value)
            return;
          if (typeof value === "string") {
            fromString(buffer, offset, value, raddix || 10);
          } else if (isValidBuffer(value, raddix)) {
            fromArray(buffer, offset, value, raddix);
          } else if (typeof raddix === "number") {
            writeInt32(buffer, offset + posH, value);
            writeInt32(buffer, offset + posL, raddix);
          } else if (value > 0) {
            fromPositive(buffer, offset, value);
          } else if (value < 0) {
            fromNegative(buffer, offset, value);
          } else {
            fromArray(buffer, offset, ZERO, 0);
          }
        }
        function fromString(buffer, offset, str, raddix) {
          var pos = 0;
          var len = str.length;
          var high = 0;
          var low = 0;
          if (str[0] === "-")
            pos++;
          var sign = pos;
          while (pos < len) {
            var chr = parseInt(str[pos++], raddix);
            if (!(chr >= 0))
              break;
            low = low * raddix + chr;
            high = high * raddix + Math.floor(low / BIT32);
            low %= BIT32;
          }
          if (sign) {
            high = ~high;
            if (low) {
              low = BIT32 - low;
            } else {
              high++;
            }
          }
          writeInt32(buffer, offset + posH, high);
          writeInt32(buffer, offset + posL, low);
        }
        function toNumber() {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          if (!unsigned)
            high |= 0;
          return high ? high * BIT32 + low : low;
        }
        function toString(radix) {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          var str = "";
          var sign = !unsigned && high & 2147483648;
          if (sign) {
            high = ~high;
            low = BIT32 - low;
          }
          radix = radix || 10;
          while (1) {
            var mod = high % radix * BIT32 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str = (mod % radix).toString(radix) + str;
            if (!high && !low)
              break;
          }
          if (sign) {
            str = "-" + str;
          }
          return str;
        }
        function writeInt32(buffer, offset, value) {
          buffer[offset + pos3] = value & 255;
          value = value >> 8;
          buffer[offset + pos2] = value & 255;
          value = value >> 8;
          buffer[offset + pos1] = value & 255;
          value = value >> 8;
          buffer[offset + pos0] = value & 255;
        }
        function readInt32(buffer, offset) {
          return buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16) + (buffer[offset + pos2] << 8) + buffer[offset + pos3];
        }
      }
      function toArray(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = null;
        if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer))
          return buffer;
        return newArray(buffer, offset);
      }
      function toBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = BUFFER;
        if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer))
          return buffer;
        var dest = new BUFFER(8);
        fromArray(dest, 0, buffer, offset);
        return dest;
      }
      function toArrayBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        var arrbuf = buffer.buffer;
        storage = UINT8ARRAY;
        if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
          return arrbuf;
        var dest = new UINT8ARRAY(8);
        fromArray(dest, 0, buffer, offset);
        return dest.buffer;
      }
      function isValidBuffer(buffer, offset) {
        var len = buffer && buffer.length;
        offset |= 0;
        return len && offset + 8 <= len && typeof buffer[offset] !== "string";
      }
      function fromArray(destbuf, destoff, srcbuf, srcoff) {
        destoff |= 0;
        srcoff |= 0;
        for (var i = 0; i < 8; i++) {
          destbuf[destoff++] = srcbuf[srcoff++] & 255;
        }
      }
      function newArray(buffer, offset) {
        return Array.prototype.slice.call(buffer, offset, offset + 8);
      }
      function fromPositiveBE(buffer, offset, value) {
        var pos = offset + 8;
        while (pos > offset) {
          buffer[--pos] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeBE(buffer, offset, value) {
        var pos = offset + 8;
        value++;
        while (pos > offset) {
          buffer[--pos] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function fromPositiveLE(buffer, offset, value) {
        var end = offset + 8;
        while (offset < end) {
          buffer[offset++] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeLE(buffer, offset, value) {
        var end = offset + 8;
        value++;
        while (offset < end) {
          buffer[offset++] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function _isArray(val) {
        return !!val && Object.prototype.toString.call(val) == "[object Array]";
      }
    }(typeof exports2 === "object" && typeof exports2.nodeName !== "string" ? exports2 : exports2 || {});
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/msgpack-lite/lib/write-uint8.js
var require_write_uint8 = __commonJS({
  "node_modules/msgpack-lite/lib/write-uint8.js"(exports2) {
    var constant = exports2.uint8 = new Array(256);
    for (var i = 0; i <= 255; i++) {
      constant[i] = write0(i);
    }
    function write0(type) {
      return function(encoder) {
        var offset = encoder.reserve(1);
        encoder.buffer[offset] = type;
      };
    }
  }
});

// node_modules/msgpack-lite/lib/write-token.js
var require_write_token = __commonJS({
  "node_modules/msgpack-lite/lib/write-token.js"(exports2) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var uint8 = require_write_uint8().uint8;
    var Bufferish = require_bufferish();
    var Buffer4 = Bufferish.global;
    var IS_BUFFER_SHIM = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer4;
    var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer4.TYPED_ARRAY_SUPPORT;
    var Buffer_prototype = Bufferish.hasBuffer && Buffer4.prototype || {};
    exports2.getWriteToken = getWriteToken;
    function getWriteToken(options) {
      if (options && options.uint8array) {
        return init_uint8array();
      } else if (NO_TYPED_ARRAY || Bufferish.hasBuffer && options && options.safe) {
        return init_safe();
      } else {
        return init_token();
      }
    }
    function init_uint8array() {
      var token = init_token();
      token[202] = writeN(202, 4, writeFloatBE);
      token[203] = writeN(203, 8, writeDoubleBE);
      return token;
    }
    function init_token() {
      var token = uint8.slice();
      token[196] = write1(196);
      token[197] = write2(197);
      token[198] = write4(198);
      token[199] = write1(199);
      token[200] = write2(200);
      token[201] = write4(201);
      token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
      token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
      token[204] = write1(204);
      token[205] = write2(205);
      token[206] = write4(206);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = write1(208);
      token[209] = write2(209);
      token[210] = write4(210);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = write1(217);
      token[218] = write2(218);
      token[219] = write4(219);
      token[220] = write2(220);
      token[221] = write4(221);
      token[222] = write2(222);
      token[223] = write4(223);
      return token;
    }
    function init_safe() {
      var token = uint8.slice();
      token[196] = writeN(196, 1, Buffer4.prototype.writeUInt8);
      token[197] = writeN(197, 2, Buffer4.prototype.writeUInt16BE);
      token[198] = writeN(198, 4, Buffer4.prototype.writeUInt32BE);
      token[199] = writeN(199, 1, Buffer4.prototype.writeUInt8);
      token[200] = writeN(200, 2, Buffer4.prototype.writeUInt16BE);
      token[201] = writeN(201, 4, Buffer4.prototype.writeUInt32BE);
      token[202] = writeN(202, 4, Buffer4.prototype.writeFloatBE);
      token[203] = writeN(203, 8, Buffer4.prototype.writeDoubleBE);
      token[204] = writeN(204, 1, Buffer4.prototype.writeUInt8);
      token[205] = writeN(205, 2, Buffer4.prototype.writeUInt16BE);
      token[206] = writeN(206, 4, Buffer4.prototype.writeUInt32BE);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = writeN(208, 1, Buffer4.prototype.writeInt8);
      token[209] = writeN(209, 2, Buffer4.prototype.writeInt16BE);
      token[210] = writeN(210, 4, Buffer4.prototype.writeInt32BE);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = writeN(217, 1, Buffer4.prototype.writeUInt8);
      token[218] = writeN(218, 2, Buffer4.prototype.writeUInt16BE);
      token[219] = writeN(219, 4, Buffer4.prototype.writeUInt32BE);
      token[220] = writeN(220, 2, Buffer4.prototype.writeUInt16BE);
      token[221] = writeN(221, 4, Buffer4.prototype.writeUInt32BE);
      token[222] = writeN(222, 2, Buffer4.prototype.writeUInt16BE);
      token[223] = writeN(223, 4, Buffer4.prototype.writeUInt32BE);
      return token;
    }
    function write1(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(2);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset] = value;
      };
    }
    function write2(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(3);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function write4(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(5);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 24;
        buffer[offset++] = value >>> 16;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function writeN(type, len, method, noAssert) {
      return function(encoder, value) {
        var offset = encoder.reserve(len + 1);
        encoder.buffer[offset++] = type;
        method.call(encoder.buffer, value, offset, noAssert);
      };
    }
    function writeUInt64BE(value, offset) {
      new Uint64BE(this, offset, value);
    }
    function writeInt64BE(value, offset) {
      new Int64BE(this, offset, value);
    }
    function writeFloatBE(value, offset) {
      ieee754.write(this, value, offset, false, 23, 4);
    }
    function writeDoubleBE(value, offset) {
      ieee754.write(this, value, offset, false, 52, 8);
    }
  }
});

// node_modules/msgpack-lite/lib/write-type.js
var require_write_type = __commonJS({
  "node_modules/msgpack-lite/lib/write-type.js"(exports2) {
    var IS_ARRAY = require_isarray();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var WriteToken = require_write_token();
    var uint8 = require_write_uint8().uint8;
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var HAS_UINT8ARRAY = typeof Uint8Array !== "undefined";
    var HAS_MAP = typeof Map !== "undefined";
    var extmap = [];
    extmap[1] = 212;
    extmap[2] = 213;
    extmap[4] = 214;
    extmap[8] = 215;
    extmap[16] = 216;
    exports2.getWriteType = getWriteType;
    function getWriteType(options) {
      var token = WriteToken.getWriteToken(options);
      var useraw = options && options.useraw;
      var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
      var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
      var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
      var usemap = HAS_MAP && options && options.usemap;
      var map = usemap ? map_to_map : obj_to_map;
      var writeType = {
        "boolean": bool,
        "function": nil,
        "number": number2,
        "object": useraw ? object_raw : object,
        "string": _string(useraw ? raw_head_size : str_head_size),
        "symbol": nil,
        "undefined": nil
      };
      return writeType;
      function bool(encoder, value) {
        var type = value ? 195 : 194;
        token[type](encoder, value);
      }
      function number2(encoder, value) {
        var ivalue = value | 0;
        var type;
        if (value !== ivalue) {
          type = 203;
          token[type](encoder, value);
          return;
        } else if (-32 <= ivalue && ivalue <= 127) {
          type = ivalue & 255;
        } else if (0 <= ivalue) {
          type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
        } else {
          type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
        }
        token[type](encoder, ivalue);
      }
      function uint64(encoder, value) {
        var type = 207;
        token[type](encoder, value.toArray());
      }
      function int64(encoder, value) {
        var type = 211;
        token[type](encoder, value.toArray());
      }
      function str_head_size(length) {
        return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
      }
      function raw_head_size(length) {
        return length < 32 ? 1 : length <= 65535 ? 3 : 5;
      }
      function _string(head_size) {
        return string2;
        function string2(encoder, value) {
          var length = value.length;
          var maxsize = 5 + length * 3;
          encoder.offset = encoder.reserve(maxsize);
          var buffer = encoder.buffer;
          var expected = head_size(length);
          var start = encoder.offset + expected;
          length = BufferProto.write.call(buffer, value, start);
          var actual = head_size(length);
          if (expected !== actual) {
            var targetStart = start + actual - expected;
            var end = start + length;
            BufferProto.copy.call(buffer, buffer, targetStart, start, end);
          }
          var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
          token[type](encoder, length);
          encoder.offset += length;
        }
      }
      function object(encoder, value) {
        if (value === null)
          return nil(encoder, value);
        if (isBuffer(value))
          return bin(encoder, value);
        if (IS_ARRAY(value))
          return array(encoder, value);
        if (Uint64BE.isUint64BE(value))
          return uint64(encoder, value);
        if (Int64BE.isInt64BE(value))
          return int64(encoder, value);
        var packer = encoder.codec.getExtPacker(value);
        if (packer)
          value = packer(value);
        if (value instanceof ExtBuffer)
          return ext(encoder, value);
        map(encoder, value);
      }
      function object_raw(encoder, value) {
        if (isBuffer(value))
          return raw(encoder, value);
        object(encoder, value);
      }
      function nil(encoder, value) {
        var type = 192;
        token[type](encoder, value);
      }
      function array(encoder, value) {
        var length = value.length;
        var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        for (var i = 0; i < length; i++) {
          encode(encoder, value[i]);
        }
      }
      function bin_buffer(encoder, value) {
        var length = value.length;
        var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
        token[type](encoder, length);
        encoder.send(value);
      }
      function bin_arraybuffer(encoder, value) {
        bin_buffer(encoder, new Uint8Array(value));
      }
      function ext(encoder, value) {
        var buffer = value.buffer;
        var length = buffer.length;
        var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
        token[type](encoder, length);
        uint8[value.type](encoder);
        encoder.send(buffer);
      }
      function obj_to_map(encoder, value) {
        var keys = Object.keys(value);
        var length = keys.length;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        keys.forEach(function(key) {
          encode(encoder, key);
          encode(encoder, value[key]);
        });
      }
      function map_to_map(encoder, value) {
        if (!(value instanceof Map))
          return obj_to_map(encoder, value);
        var length = value.size;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        value.forEach(function(val, key, m) {
          encode(encoder, key);
          encode(encoder, val);
        });
      }
      function raw(encoder, value) {
        var length = value.length;
        var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
        token[type](encoder, length);
        encoder.send(value);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/codec-base.js
var require_codec_base = __commonJS({
  "node_modules/msgpack-lite/lib/codec-base.js"(exports2) {
    var IS_ARRAY = require_isarray();
    exports2.createCodec = createCodec;
    exports2.install = install;
    exports2.filter = filter;
    var Bufferish = require_bufferish();
    function Codec(options) {
      if (!(this instanceof Codec))
        return new Codec(options);
      this.options = options;
      this.init();
    }
    Codec.prototype.init = function() {
      var options = this.options;
      if (options && options.uint8array) {
        this.bufferish = Bufferish.Uint8Array;
      }
      return this;
    };
    function install(props) {
      for (var key in props) {
        Codec.prototype[key] = add(Codec.prototype[key], props[key]);
      }
    }
    function add(a, b) {
      return a && b ? ab : a || b;
      function ab() {
        a.apply(this, arguments);
        return b.apply(this, arguments);
      }
    }
    function join2(filters) {
      filters = filters.slice();
      return function(value) {
        return filters.reduce(iterator, value);
      };
      function iterator(value, filter2) {
        return filter2(value);
      }
    }
    function filter(filter2) {
      return IS_ARRAY(filter2) ? join2(filter2) : filter2;
    }
    function createCodec(options) {
      return new Codec(options);
    }
    exports2.preset = createCodec({ preset: true });
  }
});

// node_modules/msgpack-lite/lib/write-core.js
var require_write_core = __commonJS({
  "node_modules/msgpack-lite/lib/write-core.js"(exports2) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtPacker = require_ext_packer();
    var WriteType = require_write_type();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtPacker,
      getExtPacker,
      init
    });
    exports2.preset = init.call(CodecBase.preset);
    function getEncoder(options) {
      var writeType = WriteType.getWriteType(options);
      return encode;
      function encode(encoder, value) {
        var func2 = writeType[typeof value];
        if (!func2)
          throw new Error('Unsupported type "' + typeof value + '": ' + value);
        func2(encoder, value);
      }
    }
    function init() {
      var options = this.options;
      this.encode = getEncoder(options);
      if (options && options.preset) {
        ExtPacker.setExtPackers(this);
      }
      return this;
    }
    function addExtPacker(etype, Class, packer) {
      packer = CodecBase.filter(packer);
      var name2 = Class.name;
      if (name2 && name2 !== "Object") {
        var packers = this.extPackers || (this.extPackers = {});
        packers[name2] = extPacker;
      } else {
        var list2 = this.extEncoderList || (this.extEncoderList = []);
        list2.unshift([Class, extPacker]);
      }
      function extPacker(value) {
        if (packer)
          value = packer(value);
        return new ExtBuffer(value, etype);
      }
    }
    function getExtPacker(value) {
      var packers = this.extPackers || (this.extPackers = {});
      var c = value.constructor;
      var e = c && c.name && packers[c.name];
      if (e)
        return e;
      var list2 = this.extEncoderList || (this.extEncoderList = []);
      var len = list2.length;
      for (var i = 0; i < len; i++) {
        var pair = list2[i];
        if (c === pair[0])
          return pair[1];
      }
    }
  }
});

// node_modules/msgpack-lite/lib/flex-buffer.js
var require_flex_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/flex-buffer.js"(exports2) {
    exports2.FlexDecoder = FlexDecoder;
    exports2.FlexEncoder = FlexEncoder;
    var Bufferish = require_bufferish();
    var MIN_BUFFER_SIZE = 2048;
    var MAX_BUFFER_SIZE = 65536;
    var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
    function FlexDecoder() {
      if (!(this instanceof FlexDecoder))
        return new FlexDecoder();
    }
    function FlexEncoder() {
      if (!(this instanceof FlexEncoder))
        return new FlexEncoder();
    }
    FlexDecoder.mixin = mixinFactory(getDecoderMethods());
    FlexDecoder.mixin(FlexDecoder.prototype);
    FlexEncoder.mixin = mixinFactory(getEncoderMethods());
    FlexEncoder.mixin(FlexEncoder.prototype);
    function getDecoderMethods() {
      return {
        bufferish: Bufferish,
        write: write2,
        fetch: fetch2,
        flush,
        push,
        pull,
        read,
        reserve,
        offset: 0
      };
      function write2(chunk) {
        var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
        this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
        this.offset = 0;
      }
      function flush() {
        while (this.offset < this.buffer.length) {
          var start = this.offset;
          var value;
          try {
            value = this.fetch();
          } catch (e) {
            if (e && e.message != BUFFER_SHORTAGE)
              throw e;
            this.offset = start;
            break;
          }
          this.push(value);
        }
      }
      function reserve(length) {
        var start = this.offset;
        var end = start + length;
        if (end > this.buffer.length)
          throw new Error(BUFFER_SHORTAGE);
        this.offset = end;
        return start;
      }
    }
    function getEncoderMethods() {
      return {
        bufferish: Bufferish,
        write,
        fetch: fetch3,
        flush,
        push,
        pull: pull2,
        read,
        reserve,
        send,
        maxBufferSize: MAX_BUFFER_SIZE,
        minBufferSize: MIN_BUFFER_SIZE,
        offset: 0,
        start: 0
      };
      function fetch3() {
        var start = this.start;
        if (start < this.offset) {
          var end = this.start = this.offset;
          return Bufferish.prototype.slice.call(this.buffer, start, end);
        }
      }
      function flush() {
        while (this.start < this.offset) {
          var value = this.fetch();
          if (value)
            this.push(value);
        }
      }
      function pull2() {
        var buffers = this.buffers || (this.buffers = []);
        var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
        buffers.length = 0;
        return chunk;
      }
      function reserve(length) {
        var req = length | 0;
        if (this.buffer) {
          var size = this.buffer.length;
          var start = this.offset | 0;
          var end = start + req;
          if (end < size) {
            this.offset = end;
            return start;
          }
          this.flush();
          length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
        }
        length = Math.max(length, this.minBufferSize);
        this.buffer = this.bufferish.alloc(length);
        this.start = 0;
        this.offset = req;
        return 0;
      }
      function send(buffer) {
        var length = buffer.length;
        if (length > this.minBufferSize) {
          this.flush();
          this.push(buffer);
        } else {
          var offset = this.reserve(length);
          Bufferish.prototype.copy.call(buffer, this.buffer, offset);
        }
      }
    }
    function write() {
      throw new Error("method not implemented: write()");
    }
    function fetch2() {
      throw new Error("method not implemented: fetch()");
    }
    function read() {
      var length = this.buffers && this.buffers.length;
      if (!length)
        return this.fetch();
      this.flush();
      return this.pull();
    }
    function push(chunk) {
      var buffers = this.buffers || (this.buffers = []);
      buffers.push(chunk);
    }
    function pull() {
      var buffers = this.buffers || (this.buffers = []);
      return buffers.shift();
    }
    function mixinFactory(source) {
      return mixin2;
      function mixin2(target) {
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
    }
  }
});

// node_modules/msgpack-lite/lib/encode-buffer.js
var require_encode_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/encode-buffer.js"(exports2) {
    exports2.EncodeBuffer = EncodeBuffer;
    var preset = require_write_core().preset;
    var FlexEncoder = require_flex_buffer().FlexEncoder;
    FlexEncoder.mixin(EncodeBuffer.prototype);
    function EncodeBuffer(options) {
      if (!(this instanceof EncodeBuffer))
        return new EncodeBuffer(options);
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec = this.codec = options.codec;
          if (codec.bufferish)
            this.bufferish = codec.bufferish;
        }
      }
    }
    EncodeBuffer.prototype.codec = preset;
    EncodeBuffer.prototype.write = function(input) {
      this.codec.encode(this, input);
    };
  }
});

// node_modules/msgpack-lite/lib/encode.js
var require_encode = __commonJS({
  "node_modules/msgpack-lite/lib/encode.js"(exports2) {
    exports2.encode = encode;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function encode(input, options) {
      var encoder = new EncodeBuffer(options);
      encoder.write(input);
      return encoder.read();
    }
  }
});

// node_modules/msgpack-lite/lib/ext-unpacker.js
var require_ext_unpacker = __commonJS({
  "node_modules/msgpack-lite/lib/ext-unpacker.js"(exports2) {
    exports2.setExtUnpackers = setExtUnpackers;
    var Bufferish = require_bufferish();
    var Buffer4 = Bufferish.global;
    var _decode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtUnpackers(codec) {
      codec.addExtUnpacker(14, [decode, unpackError(Error)]);
      codec.addExtUnpacker(1, [decode, unpackError(EvalError)]);
      codec.addExtUnpacker(2, [decode, unpackError(RangeError)]);
      codec.addExtUnpacker(3, [decode, unpackError(ReferenceError)]);
      codec.addExtUnpacker(4, [decode, unpackError(SyntaxError)]);
      codec.addExtUnpacker(5, [decode, unpackError(TypeError)]);
      codec.addExtUnpacker(6, [decode, unpackError(URIError)]);
      codec.addExtUnpacker(10, [decode, unpackRegExp]);
      codec.addExtUnpacker(11, [decode, unpackClass(Boolean)]);
      codec.addExtUnpacker(12, [decode, unpackClass(String)]);
      codec.addExtUnpacker(13, [decode, unpackClass(Date)]);
      codec.addExtUnpacker(15, [decode, unpackClass(Number)]);
      if (typeof Uint8Array !== "undefined") {
        codec.addExtUnpacker(17, unpackClass(Int8Array));
        codec.addExtUnpacker(18, unpackClass(Uint8Array));
        codec.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
        codec.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
        codec.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
        codec.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
        codec.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
        if (typeof Float64Array !== "undefined") {
          codec.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
        }
        if (typeof Uint8ClampedArray !== "undefined") {
          codec.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
        }
        codec.addExtUnpacker(26, unpackArrayBuffer);
        codec.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtUnpacker(27, unpackClass(Buffer4));
      }
    }
    function decode(input) {
      if (!_decode)
        _decode = require_decode().decode;
      return _decode(input);
    }
    function unpackRegExp(value) {
      return RegExp.apply(null, value);
    }
    function unpackError(Class) {
      return function(value) {
        var out = new Class();
        for (var key in ERROR_COLUMNS) {
          out[key] = value[key];
        }
        return out;
      };
    }
    function unpackClass(Class) {
      return function(value) {
        return new Class(value);
      };
    }
    function unpackArrayBuffer(value) {
      return new Uint8Array(value).buffer;
    }
  }
});

// node_modules/msgpack-lite/lib/read-format.js
var require_read_format = __commonJS({
  "node_modules/msgpack-lite/lib/read-format.js"(exports2) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    exports2.getReadFormat = getReadFormat;
    exports2.readUint8 = uint8;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var HAS_MAP = typeof Map !== "undefined";
    var NO_ASSERT = true;
    function getReadFormat(options) {
      var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
      var int64 = options && options.int64;
      var usemap = HAS_MAP && options && options.usemap;
      var readFormat = {
        map: usemap ? map_to_map : map_to_obj,
        array,
        str,
        bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
        ext,
        uint8,
        uint16,
        uint32,
        uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
        int8,
        int16,
        int32,
        int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
        float32: read(4, readFloatBE),
        float64: read(8, readDoubleBE)
      };
      return readFormat;
    }
    function map_to_obj(decoder, len) {
      var value = {};
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value[k[i]] = v[i];
      }
      return value;
    }
    function map_to_map(decoder, len) {
      var value = new Map();
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value.set(k[i], v[i]);
      }
      return value;
    }
    function array(decoder, len) {
      var value = new Array(len);
      var decode = decoder.codec.decode;
      for (var i = 0; i < len; i++) {
        value[i] = decode(decoder);
      }
      return value;
    }
    function str(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
    }
    function bin_buffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.from(buf);
    }
    function bin_arraybuffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.Uint8Array.from(buf).buffer;
    }
    function ext(decoder, len) {
      var start = decoder.reserve(len + 1);
      var type = decoder.buffer[start++];
      var end = start + len;
      var unpack = decoder.codec.getExtUnpacker(type);
      if (!unpack)
        throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return unpack(buf);
    }
    function uint8(decoder) {
      var start = decoder.reserve(1);
      return decoder.buffer[start];
    }
    function int8(decoder) {
      var start = decoder.reserve(1);
      var value = decoder.buffer[start];
      return value & 128 ? value - 256 : value;
    }
    function uint16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      return buffer[start++] << 8 | buffer[start];
    }
    function int16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      var value = buffer[start++] << 8 | buffer[start];
      return value & 32768 ? value - 65536 : value;
    }
    function uint32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] * 16777216 + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
    }
    function int32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] << 24 | buffer[start++] << 16 | buffer[start++] << 8 | buffer[start];
    }
    function read(len, method) {
      return function(decoder) {
        var start = decoder.reserve(len);
        return method.call(decoder.buffer, start, NO_ASSERT);
      };
    }
    function readUInt64BE(start) {
      return new Uint64BE(this, start).toNumber();
    }
    function readInt64BE(start) {
      return new Int64BE(this, start).toNumber();
    }
    function readUInt64BE_int64(start) {
      return new Uint64BE(this, start);
    }
    function readInt64BE_int64(start) {
      return new Int64BE(this, start);
    }
    function readFloatBE(start) {
      return ieee754.read(this, start, false, 23, 4);
    }
    function readDoubleBE(start) {
      return ieee754.read(this, start, false, 52, 8);
    }
  }
});

// node_modules/msgpack-lite/lib/read-token.js
var require_read_token = __commonJS({
  "node_modules/msgpack-lite/lib/read-token.js"(exports2) {
    var ReadFormat = require_read_format();
    exports2.getReadToken = getReadToken;
    function getReadToken(options) {
      var format2 = ReadFormat.getReadFormat(options);
      if (options && options.useraw) {
        return init_useraw(format2);
      } else {
        return init_token(format2);
      }
    }
    function init_token(format2) {
      var i;
      var token = new Array(256);
      for (i = 0; i <= 127; i++) {
        token[i] = constant(i);
      }
      for (i = 128; i <= 143; i++) {
        token[i] = fix(i - 128, format2.map);
      }
      for (i = 144; i <= 159; i++) {
        token[i] = fix(i - 144, format2.array);
      }
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format2.str);
      }
      token[192] = constant(null);
      token[193] = null;
      token[194] = constant(false);
      token[195] = constant(true);
      token[196] = flex(format2.uint8, format2.bin);
      token[197] = flex(format2.uint16, format2.bin);
      token[198] = flex(format2.uint32, format2.bin);
      token[199] = flex(format2.uint8, format2.ext);
      token[200] = flex(format2.uint16, format2.ext);
      token[201] = flex(format2.uint32, format2.ext);
      token[202] = format2.float32;
      token[203] = format2.float64;
      token[204] = format2.uint8;
      token[205] = format2.uint16;
      token[206] = format2.uint32;
      token[207] = format2.uint64;
      token[208] = format2.int8;
      token[209] = format2.int16;
      token[210] = format2.int32;
      token[211] = format2.int64;
      token[212] = fix(1, format2.ext);
      token[213] = fix(2, format2.ext);
      token[214] = fix(4, format2.ext);
      token[215] = fix(8, format2.ext);
      token[216] = fix(16, format2.ext);
      token[217] = flex(format2.uint8, format2.str);
      token[218] = flex(format2.uint16, format2.str);
      token[219] = flex(format2.uint32, format2.str);
      token[220] = flex(format2.uint16, format2.array);
      token[221] = flex(format2.uint32, format2.array);
      token[222] = flex(format2.uint16, format2.map);
      token[223] = flex(format2.uint32, format2.map);
      for (i = 224; i <= 255; i++) {
        token[i] = constant(i - 256);
      }
      return token;
    }
    function init_useraw(format2) {
      var i;
      var token = init_token(format2).slice();
      token[217] = token[196];
      token[218] = token[197];
      token[219] = token[198];
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format2.bin);
      }
      return token;
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function flex(lenFunc, decodeFunc) {
      return function(decoder) {
        var len = lenFunc(decoder);
        return decodeFunc(decoder, len);
      };
    }
    function fix(len, method) {
      return function(decoder) {
        return method(decoder, len);
      };
    }
  }
});

// node_modules/msgpack-lite/lib/read-core.js
var require_read_core = __commonJS({
  "node_modules/msgpack-lite/lib/read-core.js"(exports2) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtUnpacker = require_ext_unpacker();
    var readUint8 = require_read_format().readUint8;
    var ReadToken = require_read_token();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtUnpacker,
      getExtUnpacker,
      init
    });
    exports2.preset = init.call(CodecBase.preset);
    function getDecoder(options) {
      var readToken = ReadToken.getReadToken(options);
      return decode;
      function decode(decoder) {
        var type = readUint8(decoder);
        var func2 = readToken[type];
        if (!func2)
          throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
        return func2(decoder);
      }
    }
    function init() {
      var options = this.options;
      this.decode = getDecoder(options);
      if (options && options.preset) {
        ExtUnpacker.setExtUnpackers(this);
      }
      return this;
    }
    function addExtUnpacker(etype, unpacker) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      unpackers[etype] = CodecBase.filter(unpacker);
    }
    function getExtUnpacker(type) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      return unpackers[type] || extUnpacker;
      function extUnpacker(buffer) {
        return new ExtBuffer(buffer, type);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/decode-buffer.js
var require_decode_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/decode-buffer.js"(exports2) {
    exports2.DecodeBuffer = DecodeBuffer;
    var preset = require_read_core().preset;
    var FlexDecoder = require_flex_buffer().FlexDecoder;
    FlexDecoder.mixin(DecodeBuffer.prototype);
    function DecodeBuffer(options) {
      if (!(this instanceof DecodeBuffer))
        return new DecodeBuffer(options);
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec = this.codec = options.codec;
          if (codec.bufferish)
            this.bufferish = codec.bufferish;
        }
      }
    }
    DecodeBuffer.prototype.codec = preset;
    DecodeBuffer.prototype.fetch = function() {
      return this.codec.decode(this);
    };
  }
});

// node_modules/msgpack-lite/lib/decode.js
var require_decode = __commonJS({
  "node_modules/msgpack-lite/lib/decode.js"(exports2) {
    exports2.decode = decode;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function decode(input, options) {
      var decoder = new DecodeBuffer(options);
      decoder.write(input);
      return decoder.read();
    }
  }
});

// node_modules/event-lite/event-lite.js
var require_event_lite = __commonJS({
  "node_modules/event-lite/event-lite.js"(exports2, module2) {
    function EventLite() {
      if (!(this instanceof EventLite))
        return new EventLite();
    }
    (function(EventLite2) {
      if (typeof module2 !== "undefined")
        module2.exports = EventLite2;
      var LISTENERS = "listeners";
      var methods2 = {
        on,
        once,
        off,
        emit
      };
      mixin2(EventLite2.prototype);
      EventLite2.mixin = mixin2;
      function mixin2(target) {
        for (var key in methods2) {
          target[key] = methods2[key];
        }
        return target;
      }
      function on(type, func2) {
        getListeners(this, type).push(func2);
        return this;
      }
      function once(type, func2) {
        var that = this;
        wrap.originalListener = func2;
        getListeners(that, type).push(wrap);
        return that;
        function wrap() {
          off.call(that, type, wrap);
          func2.apply(this, arguments);
        }
      }
      function off(type, func2) {
        var that = this;
        var listners;
        if (!arguments.length) {
          delete that[LISTENERS];
        } else if (!func2) {
          listners = that[LISTENERS];
          if (listners) {
            delete listners[type];
            if (!Object.keys(listners).length)
              return off.call(that);
          }
        } else {
          listners = getListeners(that, type, true);
          if (listners) {
            listners = listners.filter(ne);
            if (!listners.length)
              return off.call(that, type);
            that[LISTENERS][type] = listners;
          }
        }
        return that;
        function ne(test) {
          return test !== func2 && test.originalListener !== func2;
        }
      }
      function emit(type, value) {
        var that = this;
        var listeners = getListeners(that, type, true);
        if (!listeners)
          return false;
        var arglen = arguments.length;
        if (arglen === 1) {
          listeners.forEach(zeroarg);
        } else if (arglen === 2) {
          listeners.forEach(onearg);
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          listeners.forEach(moreargs);
        }
        return !!listeners.length;
        function zeroarg(func2) {
          func2.call(that);
        }
        function onearg(func2) {
          func2.call(that, value);
        }
        function moreargs(func2) {
          func2.apply(that, args);
        }
      }
      function getListeners(that, type, readonly) {
        if (readonly && !that[LISTENERS])
          return;
        var listeners = that[LISTENERS] || (that[LISTENERS] = {});
        return listeners[type] || (listeners[type] = []);
      }
    })(EventLite);
  }
});

// node_modules/msgpack-lite/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/msgpack-lite/lib/encoder.js"(exports2) {
    exports2.Encoder = Encoder;
    var EventLite = require_event_lite();
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function Encoder(options) {
      if (!(this instanceof Encoder))
        return new Encoder(options);
      EncodeBuffer.call(this, options);
    }
    Encoder.prototype = new EncodeBuffer();
    EventLite.mixin(Encoder.prototype);
    Encoder.prototype.encode = function(chunk) {
      this.write(chunk);
      this.emit("data", this.read());
    };
    Encoder.prototype.end = function(chunk) {
      if (arguments.length)
        this.encode(chunk);
      this.flush();
      this.emit("end");
    };
  }
});

// node_modules/msgpack-lite/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/msgpack-lite/lib/decoder.js"(exports2) {
    exports2.Decoder = Decoder;
    var EventLite = require_event_lite();
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function Decoder(options) {
      if (!(this instanceof Decoder))
        return new Decoder(options);
      DecodeBuffer.call(this, options);
    }
    Decoder.prototype = new DecodeBuffer();
    EventLite.mixin(Decoder.prototype);
    Decoder.prototype.decode = function(chunk) {
      if (arguments.length)
        this.write(chunk);
      this.flush();
    };
    Decoder.prototype.push = function(chunk) {
      this.emit("data", chunk);
    };
    Decoder.prototype.end = function(chunk) {
      this.decode(chunk);
      this.emit("end");
    };
  }
});

// node_modules/msgpack-lite/lib/encode-stream.js
var require_encode_stream = __commonJS({
  "node_modules/msgpack-lite/lib/encode-stream.js"(exports2) {
    exports2.createEncodeStream = EncodeStream;
    var util4 = require("util");
    var Transform2 = require("stream").Transform;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    util4.inherits(EncodeStream, Transform2);
    var DEFAULT_OPTIONS = { objectMode: true };
    function EncodeStream(options) {
      if (!(this instanceof EncodeStream))
        return new EncodeStream(options);
      if (options) {
        options.objectMode = true;
      } else {
        options = DEFAULT_OPTIONS;
      }
      Transform2.call(this, options);
      var stream = this;
      var encoder = this.encoder = new EncodeBuffer(options);
      encoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    EncodeStream.prototype._transform = function(chunk, encoding, callback) {
      this.encoder.write(chunk);
      if (callback)
        callback();
    };
    EncodeStream.prototype._flush = function(callback) {
      this.encoder.flush();
      if (callback)
        callback();
    };
  }
});

// node_modules/msgpack-lite/lib/decode-stream.js
var require_decode_stream = __commonJS({
  "node_modules/msgpack-lite/lib/decode-stream.js"(exports2) {
    exports2.createDecodeStream = DecodeStream;
    var util4 = require("util");
    var Transform2 = require("stream").Transform;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    util4.inherits(DecodeStream, Transform2);
    var DEFAULT_OPTIONS = { objectMode: true };
    function DecodeStream(options) {
      if (!(this instanceof DecodeStream))
        return new DecodeStream(options);
      if (options) {
        options.objectMode = true;
      } else {
        options = DEFAULT_OPTIONS;
      }
      Transform2.call(this, options);
      var stream = this;
      var decoder = this.decoder = new DecodeBuffer(options);
      decoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    DecodeStream.prototype._transform = function(chunk, encoding, callback) {
      this.decoder.write(chunk);
      this.decoder.flush();
      if (callback)
        callback();
    };
  }
});

// node_modules/msgpack-lite/lib/ext.js
var require_ext = __commonJS({
  "node_modules/msgpack-lite/lib/ext.js"(exports2) {
    require_read_core();
    require_write_core();
    exports2.createCodec = require_codec_base().createCodec;
  }
});

// node_modules/msgpack-lite/lib/codec.js
var require_codec = __commonJS({
  "node_modules/msgpack-lite/lib/codec.js"(exports2) {
    require_read_core();
    require_write_core();
    exports2.codec = {
      preset: require_codec_base().preset
    };
  }
});

// node_modules/msgpack-lite/index.js
var require_msgpack_lite = __commonJS({
  "node_modules/msgpack-lite/index.js"(exports2) {
    exports2.encode = require_encode().encode;
    exports2.decode = require_decode().decode;
    exports2.Encoder = require_encoder().Encoder;
    exports2.Decoder = require_decoder().Decoder;
    exports2.createEncodeStream = require_encode_stream().createEncodeStream;
    exports2.createDecodeStream = require_decode_stream().createDecodeStream;
    exports2.createCodec = require_ext().createCodec;
    exports2.codec = require_codec().codec;
  }
});

// node_modules/@chemzqm/neovim/lib/utils/buffered.js
var require_buffered = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/buffered.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var Buffered = class extends stream_1.Transform {
      constructor() {
        super({
          readableHighWaterMark: 10 * 1024 * 1024,
          writableHighWaterMark: 10 * 1024 * 1024
        });
        this.chunks = null;
        this.timer = null;
      }
      sendData() {
        const { chunks } = this;
        if (chunks) {
          this.chunks = null;
          const buf = Buffer.concat(chunks);
          this.push(buf);
        }
      }
      _transform(chunk, _encoding, callback) {
        const { chunks, timer } = this;
        const MIN_SIZE = Buffer.poolSize;
        if (timer)
          clearTimeout(timer);
        if (chunk.length < MIN_SIZE) {
          if (!chunks)
            return callback(null, chunk);
          chunks.push(chunk);
          this.sendData();
          callback();
        } else {
          if (!chunks) {
            this.chunks = [chunk];
          } else {
            chunks.push(chunk);
          }
          this.timer = setTimeout(this.sendData.bind(this), 20);
          callback();
        }
      }
      _flush(callback) {
        const { chunks } = this;
        if (chunks) {
          this.chunks = null;
          const buf = Buffer.concat(chunks);
          callback(null, buf);
        } else {
          callback();
        }
      }
    };
    exports2.default = Buffered;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Base.js
var require_Base = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseApi = void 0;
    var events_1 = require("events");
    var isVim7 = process.env.VIM_NODE_RPC == "1";
    var BaseApi = class extends events_1.EventEmitter {
      constructor({ transport, data, client }) {
        super();
        this.setTransport(transport);
        this.data = data;
        this.client = client;
      }
      setTransport(transport) {
        this.transport = transport;
      }
      equals(other) {
        try {
          return String(this.data) === String(other.data);
        } catch (e) {
          return false;
        }
      }
      async request(name2, args = []) {
        let stack = Error().stack;
        return new Promise((resolve3, reject) => {
          this.transport.request(name2, this.getArgsByPrefix(args), (err, res) => {
            if (err) {
              let e = new Error(`request error ${name2} - ${err[1]}`);
              e.stack = stack;
              if (!name2.endsWith("get_var")) {
                this.client.logError(`request error on "${name2}"`, args, err[1], stack);
              }
              reject(e);
            } else {
              resolve3(res);
            }
          });
        });
      }
      getArgsByPrefix(args) {
        if (this.prefix !== "nvim_" && args[0] != this) {
          let id = isVim7 ? this.data : this;
          return [id, ...args];
        }
        return args;
      }
      getVar(name2) {
        return this.request(`${this.prefix}get_var`, [name2]).then((res) => res, (_err) => {
          return null;
        });
      }
      setVar(name2, value, isNotify = false) {
        if (isNotify) {
          this.notify(`${this.prefix}set_var`, [name2, value]);
          return;
        }
        return this.request(`${this.prefix}set_var`, [name2, value]);
      }
      deleteVar(name2) {
        this.notify(`${this.prefix}del_var`, [name2]);
      }
      getOption(name2) {
        return this.request(`${this.prefix}get_option`, [name2]);
      }
      setOption(name2, value, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}set_option`, [name2, value]);
          return;
        }
        return this.request(`${this.prefix}set_option`, [name2, value]);
      }
      notify(name2, args = []) {
        this.transport.notify(name2, this.getArgsByPrefix(args));
      }
    };
    exports2.BaseApi = BaseApi;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Buffer.js
var require_Buffer = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Buffer = void 0;
    var Base_1 = require_Base();
    var Buffer4 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_buf_";
      }
      async attach(sendBuffer = false, options = {}) {
        return await this.request(`${this.prefix}attach`, [sendBuffer, options]);
      }
      async detach() {
        return await this.request(`${this.prefix}detach`, []);
      }
      get id() {
        return this.data;
      }
      get length() {
        return this.request(`${this.prefix}line_count`, []);
      }
      get lines() {
        return this.getLines();
      }
      get changedtick() {
        return this.request(`${this.prefix}get_changedtick`, []);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [options]);
      }
      getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        return this.request(`${this.prefix}get_lines`, [
          start,
          end,
          indexing
        ]);
      }
      setLines(_lines, { start: _start, end: _end, strictIndexing } = {
        strictIndexing: true
      }, notify = false) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        const end = typeof _end !== "undefined" ? _end : _start + 1;
        const method = notify ? "notify" : "request";
        return this[method](`${this.prefix}set_lines`, [
          _start,
          end,
          indexing,
          lines
        ]);
      }
      setVirtualText(src_id, line, chunks, opts = {}) {
        this.notify(`${this.prefix}set_virtual_text`, [
          src_id,
          line,
          chunks,
          opts
        ]);
        return Promise.resolve(src_id);
      }
      insert(lines, start) {
        return this.setLines(lines, {
          start,
          end: start,
          strictIndexing: true
        });
      }
      replace(_lines, start) {
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        return this.setLines(lines, {
          start,
          end: start + lines.length,
          strictIndexing: false
        });
      }
      remove(start, end, strictIndexing = false) {
        return this.setLines([], { start, end, strictIndexing });
      }
      append(lines) {
        return this.setLines(lines, {
          start: -1,
          end: -1,
          strictIndexing: false
        });
      }
      get name() {
        return this.request(`${this.prefix}get_name`, []);
      }
      setName(value) {
        return this.request(`${this.prefix}set_name`, [value]);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      mark(name2) {
        return this.request(`${this.prefix}get_mark`, [name2]);
      }
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      setKeymap(mode, lhs, rhs, opts = {}) {
        this.client.call("coc#compat#buf_add_keymap", [this.id, mode, lhs, rhs, opts], true);
      }
      get loaded() {
        return this.request(`${this.prefix}is_loaded`, []);
      }
      getOffset(index) {
        return this.request(`${this.prefix}get_offset`, [index]);
      }
      addHighlight({ hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId }) {
        if (!hlGroup)
          throw new Error("hlGroup should not empty");
        const colEnd = typeof _end !== "undefined" ? _end : -1;
        const colStart = typeof _start !== "undefined" ? _start : -0;
        const srcId = typeof _srcId !== "undefined" ? _srcId : -1;
        const method = srcId == 0 ? "request" : "notify";
        let res = this[method](`${this.prefix}add_highlight`, [
          srcId,
          hlGroup,
          line,
          colStart,
          colEnd
        ]);
        return method === "request" ? res : Promise.resolve(null);
      }
      clearHighlight(args = {}) {
        const defaults2 = {
          srcId: -1,
          lineStart: 0,
          lineEnd: -1
        };
        const { srcId, lineStart, lineEnd } = Object.assign({}, defaults2, args);
        return this.notify(`${this.prefix}clear_highlight`, [
          srcId,
          lineStart,
          lineEnd
        ]);
      }
      highlightRanges(srcId, hlGroup, ranges) {
        this.client.call("coc#highlight#ranges", [this.id, srcId, hlGroup, ranges], true);
      }
      clearNamespace(key, lineStart = 0, lineEnd = -1) {
        this.client.call("coc#highlight#clear_highlight", [this.id, key, lineStart, lineEnd], true);
      }
      placeSign(sign) {
        let opts = { lnum: sign.lnum };
        if (typeof sign.priority === "number")
          opts.priority = sign.priority;
        this.client.call("sign_place", [sign.id || 0, sign.group || "", sign.name, this.id, opts], true);
      }
      unplaceSign(opts) {
        let details = { buffer: this.id };
        if (opts.id != null)
          details.id = opts.id;
        this.client.call("sign_unplace", [opts.group || "", details], true);
      }
      async getSigns(opts) {
        let res = await this.client.call("sign_getplaced", [this.id, opts || {}]);
        return res[0].signs;
      }
      async getHighlights(ns, start = 0, end = -1) {
        let res = [];
        let obj = await this.client.call("coc#highlight#get", [this.id, ns, start, end]);
        for (let arr of Object.values(obj)) {
          if (Array.isArray(arr)) {
            res.push(...arr);
          }
        }
        return res;
      }
      updateHighlights(ns, highlights, start = 0, end = -1) {
        this.client.call("coc#highlight#update_highlights", [this.id, ns, highlights, start, end], true);
      }
      listen(eventName, cb, disposables) {
        this.client.attachBufferEvent(this, eventName, cb);
        if (disposables) {
          disposables.push({
            dispose: () => {
              this.client.detachBufferEvent(this, eventName, cb);
            }
          });
        }
      }
    };
    exports2.Buffer = Buffer4;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Window.js
var require_Window = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Window.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Window = void 0;
    var Base_1 = require_Base();
    var timers_1 = require("timers");
    var Window3 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_win_";
      }
      get id() {
        return this.data;
      }
      get buffer() {
        return this.request(`${this.prefix}get_buf`, []);
      }
      get tabpage() {
        return this.request(`${this.prefix}get_tabpage`, []);
      }
      get cursor() {
        return this.request(`${this.prefix}get_cursor`, []);
      }
      setCursor(pos, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_cursor`, [pos]);
      }
      get height() {
        return this.request(`${this.prefix}get_height`, []);
      }
      setHeight(height, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_height`, [height]);
      }
      get width() {
        return this.request(`${this.prefix}get_width`, []);
      }
      setWidth(width, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_height`, [width]);
      }
      get position() {
        return this.request(`${this.prefix}get_position`, []);
      }
      get row() {
        return this.request(`${this.prefix}get_position`, []).then((position) => position[0]);
      }
      get col() {
        return this.request(`${this.prefix}get_position`, []).then((position) => position[1]);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      get number() {
        return this.request(`${this.prefix}get_number`, []);
      }
      setConfig(options, isNotify) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_config`, [options]);
      }
      getConfig() {
        return this.request(`${this.prefix}get_config`, []);
      }
      close(force, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}close`, [force]);
          let count = 0;
          let interval = setInterval(() => {
            if (count == 5)
              return timers_1.clearInterval(interval);
            this.request(`${this.prefix}is_valid`, []).then((valid) => {
              if (!valid) {
                timers_1.clearInterval(interval);
              } else {
                this.notify(`${this.prefix}close`, [force]);
              }
            }, () => {
              timers_1.clearInterval(interval);
            });
            count++;
          }, 50);
          return null;
        }
        return this.request(`${this.prefix}close`, [force]);
      }
      highlightRanges(hlGroup, ranges, priority = 10, isNotify) {
        if (isNotify) {
          this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority], true);
          return void 0;
        }
        return this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority]);
      }
      clearMatchGroup(hlGroup) {
        this.client.call("coc#highlight#clear_match_group", [this.id, hlGroup], true);
      }
      clearMatches(ids) {
        this.client.call("coc#highlight#clear_matches", [this.id, ids], true);
      }
    };
    exports2.Window = Window3;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Tabpage.js
var require_Tabpage = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Tabpage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tabpage = void 0;
    var Base_1 = require_Base();
    var Tabpage = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_tabpage_";
      }
      get windows() {
        return this.request(`${this.prefix}list_wins`, []);
      }
      get window() {
        return this.request(`${this.prefix}get_win`, []);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      get number() {
        return this.request(`${this.prefix}get_number`, []);
      }
      getOption() {
        throw new Error("Tabpage does not have `getOption`");
      }
      setOption() {
        throw new Error("Tabpage does not have `setOption`");
      }
    };
    exports2.Tabpage = Tabpage;
  }
});

// node_modules/@chemzqm/neovim/lib/api/types.js
var require_types = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = exports2.ExtType = void 0;
    var Buffer_1 = require_Buffer();
    var Window_1 = require_Window();
    var Tabpage_1 = require_Tabpage();
    var ExtType;
    (function(ExtType2) {
      ExtType2[ExtType2["Buffer"] = 0] = "Buffer";
      ExtType2[ExtType2["Window"] = 1] = "Window";
      ExtType2[ExtType2["Tabpage"] = 2] = "Tabpage";
    })(ExtType = exports2.ExtType || (exports2.ExtType = {}));
    exports2.Metadata = [
      {
        constructor: Buffer_1.Buffer,
        name: "Buffer",
        prefix: "nvim_buf_"
      },
      {
        constructor: Window_1.Window,
        name: "Window",
        prefix: "nvim_win_"
      },
      {
        constructor: Tabpage_1.Tabpage,
        name: "Tabpage",
        prefix: "nvim_tabpage_"
      }
    ];
  }
});

// node_modules/@chemzqm/neovim/lib/utils/logger.js
var require_logger3 = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/logger.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLogger = void 0;
    var fs_1 = __importDefault(require("fs"));
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    function getLogFile() {
      let file = process.env.NODE_CLIENT_LOG_FILE;
      if (file)
        return file;
      let dir = process.env.XDG_RUNTIME_DIR;
      if (dir)
        return path_1.default.join(dir, "node-client.log");
      return path_1.default.join(os_1.default.tmpdir(), `node-client-${process.pid}.log`);
    }
    var LOG_FILE_PATH = getLogFile();
    var level = process.env.NODE_CLIENT_LOG_LEVEL || "info";
    var invalid = process.getuid && process.getuid() == 0;
    if (!invalid) {
      try {
        fs_1.default.mkdirSync(path_1.default.dirname(LOG_FILE_PATH), { recursive: true });
        fs_1.default.writeFileSync(LOG_FILE_PATH, "", { encoding: "utf8", mode: 438 });
      } catch (_e) {
        invalid = true;
      }
    }
    function toObject(arg) {
      if (arg == null) {
        return arg;
      }
      if (Array.isArray(arg)) {
        return arg.map((o) => toObject(o));
      }
      if (typeof arg == "object" && typeof arg.prefix == "string" && typeof arg.data == "number") {
        return "[" + arg.prefix + arg.data + "]";
      }
      return arg;
    }
    function toString(arg) {
      if (arg == null)
        return String(arg);
      if (typeof arg == "object")
        return JSON.stringify(arg, null, 2);
      return String(arg);
    }
    function toTimeString(d) {
      return `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}.${d.getMilliseconds()}`;
    }
    var Logger2 = class {
      constructor(name2) {
        this.name = name2;
      }
      get stream() {
        if (invalid)
          return null;
        if (this._stream)
          return this._stream;
        this._stream = fs_1.default.createWriteStream(LOG_FILE_PATH, { encoding: "utf8" });
        return this._stream;
      }
      getText(level2, data, meta) {
        let more = "";
        if (meta.length) {
          let arr = toObject(meta);
          more = " " + arr.map((o) => toString(o));
        }
        return `${toTimeString(new Date())} ${level2.toUpperCase()} [${this.name}] - ${data}${more}
`;
      }
      debug(data, ...meta) {
        if (level != "debug" || this.stream == null)
          return;
        this.stream.write(this.getText("debug", data, meta));
      }
      info(data, ...meta) {
        if (this.stream == null)
          return;
        this.stream.write(this.getText("info", data, meta));
      }
      error(data, ...meta) {
        if (this.stream == null)
          return;
        this.stream.write(this.getText("error", data, meta));
      }
      trace(data, ...meta) {
        if (level != "trace" || this.stream == null)
          return;
        this.stream.write(this.getText("trace", data, meta));
      }
    };
    function createLogger3(name2) {
      return new Logger2(name2);
    }
    exports2.createLogger = createLogger3;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/base.js
var require_base = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var logger_1 = require_logger3();
    var debug = process.env.NODE_CLIENT_LOG_LEVEL == "debug";
    var logger113 = logger_1.createLogger("transport");
    var Transport3 = class extends events_1.EventEmitter {
      constructor(logger114) {
        super();
        this.logger = logger114;
        this.pauseLevel = 0;
        this.paused = new Map();
      }
      debug(key, ...meta) {
        if (!debug)
          return;
        logger113.debug(key, ...meta);
      }
      info(key, ...meta) {
        logger113.info(key, ...meta);
      }
      debugMessage(msg) {
        if (!debug)
          return;
        const msgType = msg[0];
        if (msgType == 0) {
          logger113.debug("receive request:", msg.slice(1));
        } else if (msgType == 1) {
        } else if (msgType == 2) {
          logger113.debug("receive notification:", msg.slice(1));
        } else {
          logger113.debug("unknown message:", msg);
        }
      }
      pauseNotification() {
        this.pauseLevel = this.pauseLevel + 1;
        this.paused.set(this.pauseLevel, []);
      }
      cancelNotification() {
        let { pauseLevel } = this;
        if (pauseLevel > 0) {
          this.paused.delete(pauseLevel);
          this.pauseLevel = pauseLevel - 1;
        }
      }
      resumeNotification(isNotify = false) {
        let { pauseLevel } = this;
        if (pauseLevel == 0)
          return isNotify ? null : Promise.resolve([null, null]);
        let stack = Error().stack;
        this.pauseLevel = pauseLevel - 1;
        let list2 = this.paused.get(pauseLevel);
        this.paused.delete(pauseLevel);
        if (list2 && list2.length) {
          return new Promise((resolve3, reject) => {
            if (!isNotify) {
              return this.request("nvim_call_atomic", [list2], (err, res) => {
                if (err) {
                  let e = new Error(`call_atomic error: ${err[1]}`);
                  e.stack = stack;
                  return reject(e);
                }
                if (Array.isArray(res) && res[1] != null) {
                  let [index, errType, message] = res[1];
                  let [fname, args] = list2[index];
                  this.logger.error(`request error ${errType} on "${fname}"`, args, message, stack);
                }
                resolve3(res);
              });
            }
            this.notify("nvim_call_atomic", [list2]);
            resolve3();
          });
        }
        return isNotify ? null : Promise.resolve([[], void 0]);
      }
    };
    exports2.default = Transport3;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/nvim.js
var require_nvim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/nvim.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NvimTransport = void 0;
    var msgpack = __importStar(require_msgpack_lite());
    var buffered_1 = __importDefault(require_buffered());
    var types_1 = require_types();
    var base_1 = __importDefault(require_base());
    var NvimTransport = class extends base_1.default {
      constructor(logger113) {
        super(logger113);
        this.pending = new Map();
        this.nextRequestId = 1;
        this.attached = false;
        const codec = this.setupCodec();
        this.encodeStream = msgpack.createEncodeStream({ codec });
        this.decodeStream = msgpack.createDecodeStream({ codec });
        this.decodeStream.on("data", (msg) => {
          this.parseMessage(msg);
        });
        this.decodeStream.on("end", () => {
          this.detach();
          this.emit("detach");
        });
      }
      parseMessage(msg) {
        const msgType = msg[0];
        this.debugMessage(msg);
        if (msgType === 0) {
          this.emit("request", msg[2].toString(), msg[3], this.createResponse(msg[1]));
        } else if (msgType === 1) {
          const id = msg[1];
          const handler = this.pending.get(id);
          if (handler) {
            this.pending.delete(id);
            let err = msg[2];
            if (err && err.length != 2) {
              err = [0, err instanceof Error ? err.message : err];
            }
            handler(err, msg[3]);
          }
        } else if (msgType === 2) {
          this.emit("notification", msg[1].toString(), msg[2]);
        } else {
          console.error(`Invalid message type ${msgType}`);
        }
      }
      setupCodec() {
        const codec = msgpack.createCodec();
        types_1.Metadata.forEach(({ constructor }, id) => {
          codec.addExtPacker(id, constructor, (obj) => msgpack.encode(obj.data));
          codec.addExtUnpacker(id, (data) => new constructor({
            transport: this,
            client: this.client,
            data: msgpack.decode(data)
          }));
        });
        this.codec = codec;
        return this.codec;
      }
      attach(writer, reader, client) {
        this.encodeStream = this.encodeStream.pipe(writer);
        const buffered = new buffered_1.default();
        reader.pipe(buffered).pipe(this.decodeStream);
        this.writer = writer;
        this.reader = reader;
        this.client = client;
        this.attached = true;
      }
      detach() {
        if (!this.attached)
          return;
        this.attached = false;
        this.encodeStream.unpipe(this.writer);
        this.reader.unpipe(this.decodeStream);
      }
      request(method, args, cb) {
        if (!this.attached)
          return;
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId + 1;
        let startTs = Date.now();
        this.debug("request to nvim:", id, method, args);
        this.encodeStream.write(msgpack.encode([0, id, method, args], {
          codec: this.codec
        }));
        let stack = Error().stack;
        let timer = setTimeout(() => {
          this.debug(`request to vim blocked more than 1s: ${method}`, args, stack);
        }, 1e3);
        this.pending.set(id, (err, res) => {
          clearTimeout(timer);
          this.debug("response of nvim:", id, `${Date.now() - startTs}ms`, res, err);
          cb(err, res);
        });
      }
      notify(method, args) {
        if (!this.attached)
          return;
        if (this.pauseLevel != 0) {
          let arr = this.paused.get(this.pauseLevel);
          if (arr) {
            arr.push([method, args]);
            return;
          }
        }
        this.debug("nvim notification:", method, args);
        this.encodeStream.write(msgpack.encode([2, method, args], {
          codec: this.codec
        }));
      }
      send(arr) {
        this.encodeStream.write(msgpack.encode(arr, {
          codec: this.codec
        }));
      }
      createResponse(requestId) {
        let { encodeStream } = this;
        let startTs = Date.now();
        let called = false;
        let timer = setTimeout(() => {
          this.debug(`request to client cost more than 1s`, requestId);
        }, 1e3);
        return {
          send: (resp, isError) => {
            clearTimeout(timer);
            if (called || !this.attached)
              return;
            this.debug("response of client:", requestId, `${Date.now() - startTs}ms`, resp, isError == true);
            called = true;
            encodeStream.write(msgpack.encode([
              1,
              requestId,
              isError ? resp : null,
              !isError ? resp : null
            ]));
          }
        };
      }
    };
    exports2.NvimTransport = NvimTransport;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/connection.js
var require_connection = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/connection.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = __importDefault(require("events"));
    var readline_1 = __importDefault(require("readline"));
    var logger_1 = require_logger3();
    var logger113 = logger_1.createLogger("connection");
    var Connection = class extends events_1.default {
      constructor(readable, writeable) {
        super();
        this.readable = readable;
        this.writeable = writeable;
        const rl = readline_1.default.createInterface(this.readable);
        rl.on("line", (line) => {
          this.parseData(line);
        });
        rl.on("close", () => {
          logger113.error("connection closed");
          process.exit(0);
        });
      }
      parseData(str) {
        if (str.length == 0)
          return;
        let arr;
        try {
          arr = JSON.parse(str);
        } catch (e) {
          console.error(`Invalid data from vim: ${str}`);
          return;
        }
        let [id, obj] = arr;
        if (id > 0) {
          logger113.debug("received request:", id, obj);
          this.emit("request", id, obj);
        } else if (id == 0) {
          logger113.debug("received notification:", obj);
          this.emit("notification", obj);
        } else {
          logger113.debug("received response:", id, obj);
          this.emit("response", id, obj);
        }
      }
      response(requestId, data) {
        this.send([requestId, data || null]);
      }
      notify(event, data) {
        this.send([0, [event, data || null]]);
      }
      send(arr) {
        logger113.debug("send to vim:", arr);
        try {
          this.writeable.write(JSON.stringify(arr) + "\n");
        } catch (e) {
          logger113.error("Send error:", arr);
        }
      }
      redraw(force = false) {
        this.send(["redraw", force ? "force" : ""]);
      }
      command(cmd) {
        this.send(["ex", cmd]);
      }
      expr(expr) {
        this.send(["expr", expr]);
      }
      call(func2, args, requestId) {
        if (!requestId) {
          this.send(["call", func2, args]);
          return;
        }
        this.send(["call", func2, args, requestId]);
      }
      dispose() {
        this.removeAllListeners();
      }
    };
    exports2.default = Connection;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/request.js
var require_request = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/request.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var logger_1 = require_logger3();
    var logger113 = logger_1.createLogger("request");
    var debug = process.env.NODE_CLIENT_LOG_LEVEL == "debug";
    var func2 = process.env.COC_NVIM == "1" ? "coc#api#call" : "nvim#api#call";
    var Request = class {
      constructor(connection, cb, id) {
        this.connection = connection;
        this.cb = cb;
        this.id = id;
      }
      request(method, args = []) {
        this.method = method;
        this.args = args;
        this.connection.call(func2, [method.slice(5), args], this.id);
      }
      callback(client, err, result) {
        let { method, cb } = this;
        if (debug && err) {
          logger113.debug(`request ${this.method} error:`, err, this.args);
        }
        if (err)
          return cb([0, err.toString()]);
        switch (method) {
          case "nvim_list_wins":
          case "nvim_tabpage_list_wins":
            return cb(null, result.map((o) => client.createWindow(o)));
          case "nvim_tabpage_get_win":
          case "nvim_get_current_win":
          case "nvim_open_win":
            return cb(null, client.createWindow(result));
          case "nvim_list_bufs":
            return cb(null, result.map((o) => client.createBuffer(o)));
          case "nvim_win_get_buf":
          case "nvim_create_buf":
          case "nvim_get_current_buf":
            return cb(null, client.createBuffer(result));
          case "nvim_list_tabpages":
            return cb(null, result.map((o) => client.createTabpage(o)));
          case "nvim_get_current_tabpage":
            return cb(null, client.createTabpage(result));
          default:
            return cb(null, result);
        }
      }
    };
    exports2.default = Request;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/vim.js
var require_vim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/vim.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VimTransport = void 0;
    var base_1 = __importDefault(require_base());
    var connection_1 = __importDefault(require_connection());
    var request_1 = __importDefault(require_request());
    var VimTransport = class extends base_1.default {
      constructor(logger113) {
        super(logger113);
        this.pending = new Map();
        this.nextRequestId = -1;
        this.attached = false;
        this.errText = "";
        this.outText = "";
        this.notifyMethod = process.env.COC_NVIM == "1" ? "coc#api#notify" : "nvim#api#notify";
      }
      attach(writer, reader, client) {
        let connection = this.connection = new connection_1.default(reader, writer);
        this.attached = true;
        this.client = client;
        connection.on("request", (id, obj) => {
          let [method, args] = obj;
          this.emit("request", method, args, this.createResponse(id));
        });
        connection.on("notification", (obj) => {
          let [event, args] = obj;
          this.emit("notification", event.toString(), args);
        });
        connection.on("response", (id, obj) => {
          let req = this.pending.get(id);
          if (req) {
            this.pending.delete(id);
            let err = null;
            let result = null;
            if (!Array.isArray(obj)) {
              err = obj;
            } else {
              err = obj[0];
              result = obj[1];
            }
            req.callback(this.client, err, result);
          }
        });
      }
      send(arr) {
        this.connection.send(arr);
      }
      detach() {
        if (!this.attached)
          return;
        this.attached = false;
        this.connection.dispose();
      }
      request(method, args, cb) {
        if (!this.attached)
          return cb([0, "transport disconnected"]);
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId - 1;
        let startTs = Date.now();
        this.debug("request to vim:", id, method, args);
        let timer = setTimeout(() => {
          this.debug(`request to vim cost more than 1s`, method, args);
        }, 1e3);
        let req = new request_1.default(this.connection, (err, res) => {
          clearTimeout(timer);
          this.debug(`response from vim cost:`, id, `${Date.now() - startTs}ms`);
          cb(err, res);
        }, id);
        this.pending.set(id, req);
        req.request(method, args);
      }
      notify(method, args) {
        if (!this.attached)
          return;
        if (this.pauseLevel != 0) {
          let arr = this.paused.get(this.pauseLevel);
          if (arr) {
            arr.push([method, args]);
            return;
          }
        }
        let fname = method.slice(5);
        if (fname == "err_write") {
          this.errText = this.errText + args[0].toString();
          return;
        }
        if (fname == "out_write") {
          let msg = args[0].toString() || "";
          if (!msg.includes("\n")) {
            this.outText = this.outText + msg;
          } else {
            let text = this.outText + args[0].toString();
            this.outText = "";
            this.connection.call(this.notifyMethod, [fname, [text]]);
          }
          return;
        }
        if (fname == "err_writeln") {
          let text = this.errText + args[0].toString();
          this.errText = "";
          this.connection.call(this.notifyMethod, [fname, [text]]);
          return;
        }
        this.connection.call(this.notifyMethod, [fname, args]);
      }
      createResponse(requestId) {
        let called = false;
        let { connection } = this;
        let startTs = Date.now();
        let timer = setTimeout(() => {
          this.debug(`request to client cost more than 1s`, requestId);
        }, 1e3);
        return {
          send: (resp, isError) => {
            clearTimeout(timer);
            if (called || !this.attached)
              return;
            called = true;
            let err = null;
            if (isError)
              err = typeof resp === "string" ? resp : resp.toString();
            this.debug("response of client cost:", requestId, `${Date.now() - startTs}ms`);
            connection.response(requestId, [err, isError ? null : resp]);
          }
        };
      }
    };
    exports2.VimTransport = VimTransport;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Neovim.js
var require_Neovim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Neovim.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Neovim = void 0;
    var Base_1 = require_Base();
    var Buffer_1 = require_Buffer();
    var Tabpage_1 = require_Tabpage();
    var Window_1 = require_Window();
    var isVim7 = process.env.VIM_NODE_RPC == "1";
    var Neovim2 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_";
        this.Buffer = Buffer_1.Buffer;
        this.Window = Window_1.Window;
        this.Tabpage = Tabpage_1.Tabpage;
      }
      getArgs(args) {
        if (!args)
          return [];
        if (Array.isArray(args))
          return args;
        return [args];
      }
      get apiInfo() {
        return this.request(`${this.prefix}get_api_info`);
      }
      get buffers() {
        return this.request(`${this.prefix}list_bufs`);
      }
      get buffer() {
        return this.request(`${this.prefix}get_current_buf`);
      }
      async setBuffer(buffer) {
        await this.request(`${this.prefix}set_current_buf`, [buffer]);
      }
      get chans() {
        return this.request(`${this.prefix}list_chans`);
      }
      getChanInfo(chan) {
        return this.request(`${this.prefix}get_chan_info`, [chan]);
      }
      createNamespace(name2 = "") {
        return this.request(`${this.prefix}create_namespace`, [name2]);
      }
      get namespaces() {
        return this.request(`${this.prefix}get_namespaces`, []);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [options]);
      }
      get tabpages() {
        return this.request(`${this.prefix}list_tabpages`);
      }
      get tabpage() {
        return this.request(`${this.prefix}get_current_tabpage`);
      }
      async setTabpage(tabpage) {
        await this.request(`${this.prefix}set_current_tabpage`, [tabpage]);
      }
      get windows() {
        return this.getWindows();
      }
      get window() {
        return this.request(`${this.prefix}get_current_win`);
      }
      getWindows() {
        return this.request(`${this.prefix}list_wins`);
      }
      async setWindow(win) {
        await this.request(`${this.prefix}set_current_win`, [win]);
      }
      get runtimePaths() {
        return this.request(`${this.prefix}list_runtime_paths`);
      }
      setDirectory(dir) {
        return this.request(`${this.prefix}set_current_dir`, [dir]);
      }
      get line() {
        return this.getLine();
      }
      createNewBuffer(listed = false, scratch = false) {
        return this.request(`${this.prefix}create_buf`, [listed, scratch]);
      }
      openFloatWindow(buffer, enter, options) {
        return this.request(`${this.prefix}open_win`, [buffer, enter, options]);
      }
      getLine() {
        return this.request(`${this.prefix}get_current_line`);
      }
      setLine(line) {
        return this.request(`${this.prefix}set_current_line`, [line]);
      }
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      get mode() {
        return this.request(`${this.prefix}get_mode`);
      }
      get colorMap() {
        return this.request(`${this.prefix}get_color_map`);
      }
      getColorByName(name2) {
        return this.request(`${this.prefix}get_color_by_name`, [name2]);
      }
      getHighlight(nameOrId, isRgb = true) {
        const functionName = typeof nameOrId === "string" ? "by_name" : "by_id";
        return this.request(`${this.prefix}get_hl_${functionName}`, [
          nameOrId,
          isRgb
        ]);
      }
      getHighlightByName(name2, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_name`, [name2, isRgb]);
      }
      getHighlightById(id, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_id`, [id, isRgb]);
      }
      deleteCurrentLine() {
        return this.request(`${this.prefix}del_current_line`);
      }
      eval(expr) {
        return this.request(`${this.prefix}eval`, [expr]);
      }
      lua(code, args = []) {
        const _args = this.getArgs(args);
        return this.request(`${this.prefix}execute_lua`, [code, _args]);
      }
      executeLua(code, args = []) {
        return this.lua(code, args);
      }
      callDictFunction(dict, fname, args = []) {
        const _args = this.getArgs(args);
        return this.request(`${this.prefix}call_dict_function`, [
          dict,
          fname,
          _args
        ]);
      }
      call(fname, args = [], isNotify) {
        const _args = this.getArgs(args);
        if (isNotify) {
          this.notify(`${this.prefix}call_function`, [fname, _args]);
          return null;
        }
        return this.request(`${this.prefix}call_function`, [fname, _args]);
      }
      callTimer(fname, args = [], isNotify) {
        const _args = this.getArgs(args);
        if (isNotify) {
          this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
          return null;
        }
        if (isVim7) {
          this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
          return new Promise((resolve3) => {
            setTimeout(() => {
              resolve3(null);
            }, 20);
          });
        }
        return this.request(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
      }
      callAsync(fname, args = []) {
        const _args = this.getArgs(args);
        return this.client.sendAsyncRequest(fname, _args);
      }
      callFunction(fname, args = []) {
        return this.call(fname, args);
      }
      callAtomic(calls) {
        return this.request(`${this.prefix}call_atomic`, [calls]);
      }
      command(arg, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}command`, [arg]);
          return null;
        }
        return this.request(`${this.prefix}command`, [arg]);
      }
      commandOutput(arg) {
        return this.request(`${this.prefix}command_output`, [arg]);
      }
      getVvar(name2) {
        return this.request(`${this.prefix}get_vvar`, [name2]);
      }
      feedKeys(keys, mode, escapeCsi) {
        return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);
      }
      input(keys) {
        return this.request(`${this.prefix}input`, [keys]);
      }
      parseExpression(expr, flags, highlight) {
        return this.request(`${this.prefix}parse_expression`, [
          expr,
          flags,
          highlight
        ]);
      }
      getProc(pid) {
        return this.request(`${this.prefix}get_proc`, [pid]);
      }
      getProcChildren(pid) {
        return this.request(`${this.prefix}get_proc_children`, [pid]);
      }
      replaceTermcodes(str, fromPart, doIt, special) {
        return this.request(`${this.prefix}replace_termcodes`, [
          str,
          fromPart,
          doIt,
          special
        ]);
      }
      strWidth(str) {
        return this.request(`${this.prefix}strwidth`, [str]);
      }
      outWrite(str) {
        this.notify(`${this.prefix}out_write`, [str]);
      }
      outWriteLine(str) {
        this.outWrite(`${str}
`);
      }
      errWrite(str) {
        this.notify(`${this.prefix}err_write`, [str]);
      }
      errWriteLine(str) {
        this.notify(`${this.prefix}err_writeln`, [str]);
      }
      get uis() {
        return this.request(`${this.prefix}list_uis`);
      }
      uiAttach(width, height, options) {
        return this.request(`${this.prefix}ui_attach`, [width, height, options]);
      }
      uiDetach() {
        return this.request(`${this.prefix}ui_detach`, []);
      }
      uiTryResize(width, height) {
        return this.request(`${this.prefix}ui_try_resize`, [width, height]);
      }
      uiSetOption(name2, value) {
        return this.request(`${this.prefix}ui_set_option`, [name2, value]);
      }
      subscribe(event) {
        return this.request(`${this.prefix}subscribe`, [event]);
      }
      unsubscribe(event) {
        return this.request(`${this.prefix}unsubscribe`, [event]);
      }
      setClientInfo(name2, version2, type, methods2, attributes) {
        this.notify(`${this.prefix}set_client_info`, [
          name2,
          version2,
          type,
          methods2,
          attributes
        ]);
      }
      async quit() {
        this.command("qa!", true);
        if (this.transport) {
          this.transport.detach();
        }
      }
    };
    exports2.Neovim = Neovim2;
  }
});

// node_modules/@chemzqm/neovim/lib/api/client.js
var require_client = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NeovimClient = exports2.AsyncResponse = void 0;
    var nvim_1 = require_nvim();
    var vim_1 = require_vim();
    var Neovim_1 = require_Neovim();
    var Buffer_1 = require_Buffer();
    var Window_1 = require_Window();
    var Tabpage_1 = require_Tabpage();
    var logger_1 = require_logger3();
    var logger113 = logger_1.createLogger("client");
    var isVim7 = process.env.VIM_NODE_RPC == "1";
    var AsyncResponse = class {
      constructor(requestId, cb) {
        this.requestId = requestId;
        this.cb = cb;
        this.finished = false;
      }
      finish(err, res) {
        if (this.finished)
          return;
        this.finished = true;
        if (err) {
          this.cb(new Error(err));
          return;
        }
        this.cb(null, res);
      }
    };
    exports2.AsyncResponse = AsyncResponse;
    var NeovimClient2 = class extends Neovim_1.Neovim {
      constructor(logger114) {
        super({});
        this.logger = logger114;
        this.requestId = 1;
        this.responses = new Map();
        this.attachedBuffers = new Map();
        Object.defineProperty(this, "client", {
          value: this
        });
        let transport = isVim7 ? new vim_1.VimTransport(logger114) : new nvim_1.NvimTransport(logger114);
        this.setTransport(transport);
        this.transportAttached = false;
        this.handleRequest = this.handleRequest.bind(this);
        this.handleNotification = this.handleNotification.bind(this);
      }
      echoError(msg) {
        let prefix = process.env.COC_NVIM == "1" ? "[coc.nvim] " : "";
        if (typeof msg === "string") {
          this.errWriteLine(prefix + msg);
          this.logError(msg, Error().stack);
        } else {
          this.errWriteLine(prefix + msg.message + " use :CocOpenLog for details");
          this.logError(msg.message || "Unknown error", msg.stack);
        }
      }
      logError(msg, ...args) {
        if (!this.logger)
          return;
        this.logger.error(msg, ...args);
      }
      createBuffer(id) {
        return new Buffer_1.Buffer({
          transport: this.transport,
          data: id,
          client: this
        });
      }
      createWindow(id) {
        return new Window_1.Window({
          transport: this.transport,
          data: id,
          client: this
        });
      }
      createTabpage(id) {
        return new Tabpage_1.Tabpage({
          transport: this.transport,
          data: id,
          client: this
        });
      }
      send(arr) {
        this.transport.send(arr);
      }
      redrawVim(force) {
        if (!isVim7)
          return;
        this.transport.send(["redraw", force ? "force" : ""]);
      }
      attach({ reader, writer }, requestApi = true) {
        this.transport.attach(writer, reader, this);
        this.transportAttached = true;
        this.setupTransport(requestApi);
      }
      detach() {
        this.transport.detach();
        this.transportAttached = false;
      }
      get isApiReady() {
        return this.transportAttached && typeof this._channelId !== "undefined";
      }
      get channelId() {
        return this._isReady.then(() => {
          return this._channelId;
        });
      }
      isAttached(bufnr) {
        return this.attachedBuffers.has(bufnr);
      }
      handleRequest(method, args, resp) {
        this.emit("request", method, args, resp);
      }
      sendAsyncRequest(method, args) {
        let id = this.requestId;
        this.requestId = id + 1;
        this.notify("nvim_call_function", ["coc#rpc#async_request", [id, method, args || []]]);
        return new Promise((resolve3, reject) => {
          let response = new AsyncResponse(id, (err, res) => {
            if (err)
              return reject(err);
            resolve3(res);
          });
          this.responses.set(id, response);
        });
      }
      emitNotification(method, args) {
        if (method.endsWith("_event")) {
          if (method.startsWith("nvim_buf_")) {
            const shortName = method.replace(/nvim_buf_(.*)_event/, "$1");
            const { id } = args[0];
            if (!this.attachedBuffers.has(id))
              return;
            const bufferMap = this.attachedBuffers.get(id);
            const cbs = bufferMap.get(shortName) || [];
            cbs.forEach((cb) => cb(...args));
            if (shortName === "detach") {
              this.attachedBuffers.delete(id);
            }
            return;
          }
          if (method.startsWith("nvim_async_request")) {
            const [id, method2, arr] = args;
            this.handleRequest(method2, arr, {
              send: (resp, isError) => {
                this.notify("nvim_call_function", ["coc#rpc#async_response", [id, resp, isError]]);
              }
            });
          }
          if (method.startsWith("nvim_async_response")) {
            const [id, err, res] = args;
            const response = this.responses.get(id);
            if (!response) {
              console.error(`Response not found for request ${id}`);
              return;
            }
            this.responses.delete(id);
            response.finish(err, res);
            return;
          }
        } else {
          this.emit("notification", method, args);
        }
      }
      handleNotification(method, args) {
        this.emitNotification(method, args);
      }
      setupTransport(requestApi = true) {
        if (!this.transportAttached) {
          throw new Error("Not attached to input/output");
        }
        this.transport.on("request", this.handleRequest);
        this.transport.on("notification", this.handleNotification);
        this.transport.on("detach", () => {
          this.emit("disconnect");
          this.transport.removeAllListeners("request");
          this.transport.removeAllListeners("notification");
          this.transport.removeAllListeners("detach");
        });
        if (requestApi) {
          this._isReady = this.generateApi();
        } else {
          this._channelId = 0;
          this._isReady = Promise.resolve(true);
        }
      }
      requestApi() {
        return new Promise((resolve3, reject) => {
          this.transport.request("nvim_get_api_info", [], (err, res) => {
            if (err) {
              reject(new Error(Array.isArray(err) ? err[1] : err.message || err.toString()));
            } else {
              resolve3(res);
            }
          });
        });
      }
      async generateApi() {
        let results;
        try {
          results = await this.requestApi();
        } catch (err) {
          console.error("Could not get vim api results");
          logger113.error(err);
        }
        if (results) {
          try {
            const [channelId, metadata] = results;
            this.functions = metadata.functions.map((f) => f.name);
            this._channelId = channelId;
            return true;
          } catch (err) {
            logger113.error(err.stack);
            return null;
          }
        }
        return null;
      }
      attachBufferEvent(buffer, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(buffer.id) || new Map();
        const cbs = bufferMap.get(eventName) || [];
        if (cbs.includes(cb))
          return;
        cbs.push(cb);
        bufferMap.set(eventName, cbs);
        this.attachedBuffers.set(buffer.id, bufferMap);
        return;
      }
      detachBufferEvent(buffer, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(buffer.id);
        if (!bufferMap || !bufferMap.has(eventName))
          return;
        const handlers = bufferMap.get(eventName).filter((handler) => handler !== cb);
        bufferMap.set(eventName, handlers);
      }
      pauseNotification() {
        this.transport.pauseNotification();
        let stack = Error().stack;
        process.nextTick(() => {
          if (this.transport.pauseLevel > 0) {
            this.logError(`resumeNotification not called within same tick:`, stack);
          }
        });
      }
      resumeNotification(cancel, notify) {
        if (cancel)
          return Promise.resolve(this.transport.cancelNotification());
        if (notify) {
          return Promise.resolve(this.transport.resumeNotification(true));
        }
        return Promise.resolve(this.transport.resumeNotification());
      }
      hasFunction(name2) {
        if (!this.functions)
          return true;
        return this.functions.indexOf(name2) !== -1;
      }
    };
    exports2.NeovimClient = NeovimClient2;
  }
});

// node_modules/@chemzqm/neovim/lib/attach/attach.js
var require_attach = __commonJS({
  "node_modules/@chemzqm/neovim/lib/attach/attach.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attach = void 0;
    var net_1 = require("net");
    var client_1 = require_client();
    function attach3({ reader: _reader, writer: _writer, proc, socket }, logger113 = null, requestApi = true) {
      let writer;
      let reader;
      let neovim;
      if (socket) {
        const client = net_1.createConnection(socket);
        writer = client;
        reader = client;
        client.once("close", () => {
          neovim.detach();
        });
      } else if (_reader && _writer) {
        writer = _writer;
        reader = _reader;
      } else if (proc) {
        writer = proc.stdin;
        reader = proc.stdout;
        proc.once("disconnect", () => {
          neovim.detach();
        });
      }
      writer.on("error", (err) => {
        if (err.code == "EPIPE") {
          neovim.detach();
        }
      });
      if (writer && reader) {
        neovim = new client_1.NeovimClient(logger113);
        neovim.attach({
          writer,
          reader
        }, requestApi);
        return neovim;
      }
      throw new Error("Invalid arguments, could not attach");
    }
    exports2.attach = attach3;
  }
});

// node_modules/@chemzqm/neovim/lib/api/index.js
var require_api = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tabpage = exports2.Window = exports2.Buffer = exports2.NeovimClient = exports2.Neovim = void 0;
    var client_1 = require_client();
    Object.defineProperty(exports2, "Neovim", { enumerable: true, get: function() {
      return client_1.NeovimClient;
    } });
    var client_2 = require_client();
    Object.defineProperty(exports2, "NeovimClient", { enumerable: true, get: function() {
      return client_2.NeovimClient;
    } });
    var Buffer_1 = require_Buffer();
    Object.defineProperty(exports2, "Buffer", { enumerable: true, get: function() {
      return Buffer_1.Buffer;
    } });
    var Window_1 = require_Window();
    Object.defineProperty(exports2, "Window", { enumerable: true, get: function() {
      return Window_1.Window;
    } });
    var Tabpage_1 = require_Tabpage();
    Object.defineProperty(exports2, "Tabpage", { enumerable: true, get: function() {
      return Tabpage_1.Tabpage;
    } });
  }
});

// node_modules/@chemzqm/neovim/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@chemzqm/neovim/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Window = exports2.Tabpage = exports2.Buffer = exports2.NeovimClient = exports2.Neovim = exports2.attach = void 0;
    var attach_1 = require_attach();
    Object.defineProperty(exports2, "attach", { enumerable: true, get: function() {
      return attach_1.attach;
    } });
    var index_1 = require_api();
    Object.defineProperty(exports2, "Neovim", { enumerable: true, get: function() {
      return index_1.Neovim;
    } });
    Object.defineProperty(exports2, "NeovimClient", { enumerable: true, get: function() {
      return index_1.NeovimClient;
    } });
    Object.defineProperty(exports2, "Buffer", { enumerable: true, get: function() {
      return index_1.Buffer;
    } });
    Object.defineProperty(exports2, "Tabpage", { enumerable: true, get: function() {
      return index_1.Tabpage;
    } });
    Object.defineProperty(exports2, "Window", { enumerable: true, get: function() {
      return index_1.Window;
    } });
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL2() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL3) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL3.install = install;
    })(RAL2 || (RAL2 = {}));
    exports2.default = RAL2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable80;
    (function(Disposable81) {
      function create(func2) {
        return {
          dispose: func2
        };
      }
      Disposable81.create = create;
    })(Disposable80 = exports2.Disposable || (exports2.Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders() {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ral_1 = require_ral();
    var util_1 = require("util");
    var disposable_1 = require_disposable();
    var messageBuffer_1 = require_messageBuffer();
    var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return disposable_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve3, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve3();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          return setTimeout(callback, ms, ...args);
        },
        clearTimeout(handle) {
          clearTimeout(handle);
        },
        setImmediate(callback, ...args) {
          return setImmediate(callback, ...args);
        },
        clearImmediate(handle) {
          clearImmediate(handle);
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        ral_1.default.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean2(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string2;
    function number2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number2;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func2(value) {
      return typeof value === "function";
    }
    exports2.func = func2;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isResponseMessage = exports2.isNotificationMessage = exports2.isRequestMessage = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = ErrorCodes2.jsonrpcReservedErrorRangeStart;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = ErrorCodes2.jsonrpcReservedErrorRangeEnd;
    })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
    var ResponseError2 = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError2.prototype);
      }
      toJson() {
        return {
          code: this.code,
          message: this.message,
          data: this.data
        };
      }
    };
    exports2.ResponseError = ResponseError2;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType03 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType03;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType3;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType22;
    var RequestType32 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType32;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType3;
    var NotificationType03 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType03;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType22;
    var NotificationType32 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType32;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    function isRequestMessage(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports2.isRequestMessage = isRequestMessage;
    function isNotificationMessage(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && message.id === void 0;
    }
    exports2.isNotificationMessage = isNotificationMessage;
    function isResponseMessage(message) {
      const candidate = message;
      return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    exports2.isResponseMessage = isResponseMessage;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event27;
    (function(Event28) {
      const _disposable = { dispose() {
      } };
      Event28.None = function() {
        return _disposable;
      };
    })(Event27 = exports2.Event || (exports2.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            ral_1.default().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter28 = class {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter28._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter28;
    Emitter28._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is7 = require_is();
    var events_1 = require_events();
    var CancellationToken53;
    (function(CancellationToken54) {
      CancellationToken54.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken54.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken54.None || candidate === CancellationToken54.Cancelled || Is7.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken54.is = is;
    })(CancellationToken53 = exports2.CancellationToken || (exports2.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        ral_1.default().timer.clearTimeout(handle);
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource26 = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken53.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken53.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource26;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is7 = require_is();
    var events_1 = require_events();
    var MessageReader2;
    (function(MessageReader3) {
      function is(value) {
        let candidate = value;
        return candidate && Is7.func(candidate.listen) && Is7.func(candidate.dispose) && Is7.func(candidate.onError) && Is7.func(candidate.onClose) && Is7.func(candidate.onPartialMessage);
      }
      MessageReader3.is = is;
    })(MessageReader2 = exports2.MessageReader || (exports2.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is7.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        var _a2;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options !== null && options !== void 0 ? options : "utf-8";
        } else {
          charset = (_a2 = options.charset) !== null && _a2 !== void 0 ? _a2 : "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = ral_1.default().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            const contentLength = headers.get("Content-Length");
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          let p;
          if (this.options.contentDecoder !== void 0) {
            p = this.options.contentDecoder.decode(body);
          } else {
            p = Promise.resolve(body);
          }
          p.then((value) => {
            this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
              this.callback(msg);
            }, (error) => {
              this.fireError(error);
            });
          }, (error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          ral_1.default().timer.clearTimeout(this.partialMessageTimer);
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve3, reject) => {
          this._waiting.push({ thunk, resolve: resolve3, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is7 = require_is();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter2;
    (function(MessageWriter3) {
      function is(value) {
        let candidate = value;
        return candidate && Is7.func(candidate.dispose) && Is7.func(candidate.onClose) && Is7.func(candidate.onError) && Is7.func(candidate.write);
      }
      MessageWriter3.is = is;
    })(MessageWriter2 = exports2.MessageWriter || (exports2.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is7.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        var _a2, _b;
        if (options === void 0 || typeof options === "string") {
          return { charset: options !== null && options !== void 0 ? options : "utf-8", contentTypeEncoder: ral_1.default().applicationJson.encoder };
        } else {
          return { charset: (_a2 = options.charset) !== null && _a2 !== void 0 ? _a2 : "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch = exports2.Touch || (exports2.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[Symbol.toStringTag] = "LinkedMap";
        this._map = new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a2;
        return (_a2 = this._head) === null || _a2 === void 0 ? void 0 : _a2.value;
      }
      get last() {
        var _a2;
        return (_a2 = this._tail) === null || _a2 === void 0 ? void 0 : _a2.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.NullLogger = exports2.ProgressType = void 0;
    var ral_1 = require_ral();
    var Is7 = require_is();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressNotification2;
    (function(ProgressNotification3) {
      ProgressNotification3.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification2 || (ProgressNotification2 = {}));
    var ProgressType4 = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType4;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is7.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace2;
    (function(Trace3) {
      Trace3[Trace3["Off"] = 0] = "Off";
      Trace3[Trace3["Messages"] = 1] = "Messages";
      Trace3[Trace3["Verbose"] = 2] = "Verbose";
    })(Trace2 = exports2.Trace || (exports2.Trace = {}));
    (function(Trace3) {
      function fromString(value) {
        if (!Is7.string(value)) {
          return Trace3.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace3.Off;
          case "messages":
            return Trace3.Messages;
          case "verbose":
            return Trace3.Verbose;
          default:
            return Trace3.Off;
        }
      }
      Trace3.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace3.Off:
            return "off";
          case Trace3.Messages:
            return "messages";
          case Trace3.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace3.toString = toString;
    })(Trace2 = exports2.Trace || (exports2.Trace = {}));
    var TraceFormat2;
    (function(TraceFormat3) {
      TraceFormat3["Text"] = "text";
      TraceFormat3["JSON"] = "json";
    })(TraceFormat2 = exports2.TraceFormat || (exports2.TraceFormat = {}));
    (function(TraceFormat3) {
      function fromString(value) {
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat3.JSON;
        } else {
          return TraceFormat3.Text;
        }
      }
      TraceFormat3.fromString = fromString;
    })(TraceFormat2 = exports2.TraceFormat || (exports2.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is7.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is7.func(candidate.createCancellationTokenSource);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is7.func(candidate.sendCancellation) && Is7.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
    var CancellationStrategy2;
    (function(CancellationStrategy3) {
      CancellationStrategy3.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy3.is = is;
    })(CancellationStrategy2 = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy2.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger113 = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSquenceNumber = 0;
      let unknownResponseSquenceNumber = 0;
      const version2 = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = Object.create(null);
      let starNotificationHandler = void 0;
      const notificationHandlers = Object.create(null);
      const progressHandlers = new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = Object.create(null);
      let requestTokens = Object.create(null);
      let trace = Trace2.Off;
      let traceFormat = TraceFormat2.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy2.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSquenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.isResponseMessage(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          if (messages_1.isRequestMessage(message)) {
            handleRequest(message);
          } else if (messages_1.isNotificationMessage(message)) {
            handleNotification(message);
          } else if (messages_1.isResponseMessage(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
            const key = createRequestQueueKey(message.params.id);
            const toCancel = messageQueue.get(key);
            if (messages_1.isRequestMessage(toCancel)) {
              const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response);
                return;
              }
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = String(requestMessage.id);
          const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
          requestTokens[tokenKey] = cancellationSource;
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but recevied none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              delete requestTokens[tokenKey];
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                delete requestTokens[tokenKey];
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is7.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              delete requestTokens[tokenKey];
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            delete requestTokens[tokenKey];
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is7.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger113.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger113.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = String(responseMessage.id);
          const responsePromise = responsePromises[key];
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise) {
            delete responsePromises[key];
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger113.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger113.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          notificationHandler = (params) => {
            const id = params.id;
            const source = requestTokens[String(id)];
            if (source) {
              source.cancel();
            }
          };
        } else {
          const element = notificationHandlers[message.method];
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger113.error(`Notification ${message.method} defines ${type.numberOfParams} params but recevied none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                if (type !== void 0) {
                  if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                    logger113.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                  }
                  if (type.numberOfParams !== message.params.length) {
                    logger113.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} argumennts`);
                  }
                }
                notificationHandler(...message.params);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger113.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger113.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger113.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger113.error("Received empty message.");
          return;
        }
        logger113.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is7.string(responseMessage.id) || Is7.number(responseMessage.id)) {
          const key = String(responseMessage.id);
          const responseHandler = responsePromises[key];
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace2.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace2.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
            break;
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Recevied parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is7.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version2,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is7.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is7.string(type)) {
              method = type;
              notificationHandlers[type] = { type: void 0, handler };
            } else {
              method = type.method;
              notificationHandlers[type.method] = { type, handler };
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                delete notificationHandlers[method];
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          connection.sendNotification(ProgressNotification2.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is7.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              cancellationStrategy.sender.sendCancellation(connection, id);
            });
          }
          const result = new Promise((resolve3, reject) => {
            const requestMessage = {
              jsonrpc: version2,
              id,
              method,
              params: messageParams
            };
            const resolveWithCleanup = (r) => {
              resolve3(r);
              cancellationStrategy.sender.cleanup(id);
              disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage);
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises[String(id)] = responsePromise;
            }
          });
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is7.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers[type] = { handler, type: void 0 };
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers[type.method] = { type, handler };
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                delete requestHandlers[method];
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat2.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is7.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat2.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace2.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            connection.sendNotification(SetTraceNotification.type, { value: Trace2.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new Error("Connection got disposed.");
          Object.keys(responsePromises).forEach((key) => {
            responsePromises[key].reject(error);
          });
          responsePromises = Object.create(null);
          requestTokens = Object.create(null);
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is7.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is7.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          ral_1.default().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        tracer.log(params.message, trace === Trace2.Verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification2.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.ProgressType = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.RAL = void 0;
    exports2.CancellationStrategy = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api2();
    var path36 = require("path");
    var os10 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    __exportStar(require_api2(), exports2);
    var IPCMessageReader2 = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader2;
    var IPCMessageWriter2 = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter2;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super(ril_1.default().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super(ril_1.default().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader2 = class extends api_1.ReadableStreamMessageReader {
      constructor(readble, encoding) {
        super(ril_1.default().stream.asReadableStream(readble), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader2;
    var StreamMessageWriter2 = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super(ril_1.default().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter2;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName2() {
      const randomSuffix = crypto_1.randomBytes(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path36.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path36.join(os10.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length >= limit) {
        ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName2;
    function createClientPipeTransport2(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        let server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport2;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = net_1.createConnection(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport2(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        const server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport2;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = net_1.createConnection(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger113, options) {
      if (!logger113) {
        logger113 = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader2(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter2(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return api_1.createMessageConnection(reader, writer, logger113, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  AnnotatedTextEdit: () => AnnotatedTextEdit,
  ChangeAnnotation: () => ChangeAnnotation,
  ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier,
  CodeAction: () => CodeAction,
  CodeActionContext: () => CodeActionContext,
  CodeActionKind: () => CodeActionKind,
  CodeDescription: () => CodeDescription,
  CodeLens: () => CodeLens,
  Color: () => Color,
  ColorInformation: () => ColorInformation,
  ColorPresentation: () => ColorPresentation,
  Command: () => Command,
  CompletionItem: () => CompletionItem,
  CompletionItemKind: () => CompletionItemKind,
  CompletionItemTag: () => CompletionItemTag,
  CompletionList: () => CompletionList,
  CreateFile: () => CreateFile,
  DeleteFile: () => DeleteFile,
  Diagnostic: () => Diagnostic,
  DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
  DiagnosticSeverity: () => DiagnosticSeverity,
  DiagnosticTag: () => DiagnosticTag,
  DocumentHighlight: () => DocumentHighlight,
  DocumentHighlightKind: () => DocumentHighlightKind,
  DocumentLink: () => DocumentLink,
  DocumentSymbol: () => DocumentSymbol,
  EOL: () => EOL,
  FoldingRange: () => FoldingRange,
  FoldingRangeKind: () => FoldingRangeKind,
  FormattingOptions: () => FormattingOptions,
  Hover: () => Hover,
  InsertReplaceEdit: () => InsertReplaceEdit,
  InsertTextFormat: () => InsertTextFormat,
  InsertTextMode: () => InsertTextMode,
  Location: () => Location,
  LocationLink: () => LocationLink,
  MarkedString: () => MarkedString,
  MarkupContent: () => MarkupContent,
  MarkupKind: () => MarkupKind,
  OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier,
  ParameterInformation: () => ParameterInformation,
  Position: () => Position,
  Range: () => Range,
  RenameFile: () => RenameFile,
  SelectionRange: () => SelectionRange,
  SignatureInformation: () => SignatureInformation,
  SymbolInformation: () => SymbolInformation,
  SymbolKind: () => SymbolKind,
  SymbolTag: () => SymbolTag,
  TextDocument: () => TextDocument,
  TextDocumentEdit: () => TextDocumentEdit,
  TextDocumentIdentifier: () => TextDocumentIdentifier,
  TextDocumentItem: () => TextDocumentItem,
  TextEdit: () => TextEdit,
  VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
  WorkspaceChange: () => WorkspaceChange,
  WorkspaceEdit: () => WorkspaceEdit,
  integer: () => integer,
  uinteger: () => uinteger
});
var integer, uinteger, Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, DocumentSymbol, CodeActionKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, EOL, TextDocument, FullTextDocument, Is;
var init_main = __esm({
  "node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    "use strict";
    (function(integer2) {
      integer2.MIN_VALUE = -2147483648;
      integer2.MAX_VALUE = 2147483647;
    })(integer || (integer = {}));
    (function(uinteger3) {
      uinteger3.MIN_VALUE = 0;
      uinteger3.MAX_VALUE = 2147483647;
    })(uinteger || (uinteger = {}));
    (function(Position45) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger.MAX_VALUE;
        }
        return { line, character };
      }
      Position45.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
      }
      Position45.is = is;
    })(Position || (Position = {}));
    (function(Range39) {
      function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
          return { start: Position.create(one, two), end: Position.create(three, four) };
        } else if (Position.is(one) && Position.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
      }
      Range39.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
      }
      Range39.is = is;
    })(Range || (Range = {}));
    (function(Location18) {
      function create(uri, range) {
        return { uri, range };
      }
      Location18.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location18.is = is;
    })(Location || (Location = {}));
    (function(LocationLink9) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink9.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink9.is = is;
    })(LocationLink || (LocationLink = {}));
    (function(Color4) {
      function create(red, green, blue2, alpha) {
        return {
          red,
          green,
          blue: blue2,
          alpha
        };
      }
      Color4.create = create;
      function is(value) {
        var candidate = value;
        return Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
      }
      Color4.is = is;
    })(Color || (Color = {}));
    (function(ColorInformation7) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation7.create = create;
      function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation7.is = is;
    })(ColorInformation || (ColorInformation = {}));
    (function(ColorPresentation5) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation5.create = create;
      function is(value) {
        var candidate = value;
        return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation5.is = is;
    })(ColorPresentation || (ColorPresentation = {}));
    (function(FoldingRangeKind2) {
      FoldingRangeKind2["Comment"] = "comment";
      FoldingRangeKind2["Imports"] = "imports";
      FoldingRangeKind2["Region"] = "region";
    })(FoldingRangeKind || (FoldingRangeKind = {}));
    (function(FoldingRange5) {
      function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        return result;
      }
      FoldingRange5.create = create;
      function is(value) {
        var candidate = value;
        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange5.is = is;
    })(FoldingRange || (FoldingRange = {}));
    (function(DiagnosticRelatedInformation2) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation2.is = is;
    })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
    (function(DiagnosticSeverity7) {
      DiagnosticSeverity7.Error = 1;
      DiagnosticSeverity7.Warning = 2;
      DiagnosticSeverity7.Information = 3;
      DiagnosticSeverity7.Hint = 4;
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function(DiagnosticTag6) {
      DiagnosticTag6.Unnecessary = 1;
      DiagnosticTag6.Deprecated = 2;
    })(DiagnosticTag || (DiagnosticTag = {}));
    (function(CodeDescription2) {
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Is.string(candidate.href);
      }
      CodeDescription2.is = is;
    })(CodeDescription || (CodeDescription = {}));
    (function(Diagnostic8) {
      function create(range, message, severity, code, source, relatedInformation) {
        var result = { range, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic8.create = create;
      function is(value) {
        var _a2;
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic8.is = is;
    })(Diagnostic || (Diagnostic = {}));
    (function(Command5) {
      function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command5.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command5.is = is;
    })(Command || (Command = {}));
    (function(TextEdit20) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit20.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit20.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit20.del = del;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
      }
      TextEdit20.is = is;
    })(TextEdit || (TextEdit = {}));
    (function(ChangeAnnotation2) {
      function create(label, needsConfirmation, description) {
        var result = { label };
        if (needsConfirmation !== void 0) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== void 0) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      ChangeAnnotation2.is = is;
    })(ChangeAnnotation || (ChangeAnnotation = {}));
    (function(ChangeAnnotationIdentifier2) {
      function is(value) {
        var candidate = value;
        return typeof candidate === "string";
      }
      ChangeAnnotationIdentifier2.is = is;
    })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
    (function(AnnotatedTextEdit2) {
      function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.insert = insert;
      function del(range, annotation) {
        return { range, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit2.del = del;
      function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      AnnotatedTextEdit2.is = is;
    })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
    (function(TextDocumentEdit6) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit6.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit6.is = is;
    })(TextDocumentEdit || (TextDocumentEdit = {}));
    (function(CreateFile3) {
      function create(uri, options, annotation) {
        var result = {
          kind: "create",
          uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      CreateFile3.is = is;
    })(CreateFile || (CreateFile = {}));
    (function(RenameFile3) {
      function create(oldUri, newUri, options, annotation) {
        var result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      RenameFile3.is = is;
    })(RenameFile || (RenameFile = {}));
    (function(DeleteFile3) {
      function create(uri, options, annotation) {
        var result = {
          kind: "delete",
          uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      DeleteFile3.is = is;
    })(DeleteFile || (DeleteFile = {}));
    (function(WorkspaceEdit10) {
      function is(value) {
        var candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit10.is = is;
    })(WorkspaceEdit || (WorkspaceEdit = {}));
    TextEditChangeImpl = function() {
      function TextEditChangeImpl2(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
        var edit2;
        var id;
        if (annotation === void 0) {
          edit2 = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit2 = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit2);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
        var edit2;
        var id;
        if (annotation === void 0) {
          edit2 = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit2 = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit2);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.delete = function(range, annotation) {
        var edit2;
        var id;
        if (annotation === void 0) {
          edit2 = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit2 = AnnotatedTextEdit.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit2);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.add = function(edit2) {
        this.edits.push(edit2);
      };
      TextEditChangeImpl2.prototype.all = function() {
        return this.edits;
      };
      TextEditChangeImpl2.prototype.clear = function() {
        this.edits.splice(0, this.edits.length);
      };
      TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
        if (value === void 0) {
          throw new Error("Text edit change is not configured to manage change annotations.");
        }
      };
      return TextEditChangeImpl2;
    }();
    ChangeAnnotations = function() {
      function ChangeAnnotations2(annotations) {
        this._annotations = annotations === void 0 ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      ChangeAnnotations2.prototype.all = function() {
        return this._annotations;
      };
      Object.defineProperty(ChangeAnnotations2.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== void 0) {
          throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === void 0) {
          throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      };
      ChangeAnnotations2.prototype.nextId = function() {
        this._counter++;
        return this._counter.toString();
      };
      return ChangeAnnotations2;
    }();
    WorkspaceChange = function() {
      function WorkspaceChange2(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach(function(change) {
              if (TextDocumentEdit.is(change)) {
                var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                _this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach(function(key) {
              var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              _this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      Object.defineProperty(WorkspaceChange2.prototype, "edit", {
        get: function() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
      });
      WorkspaceChange2.prototype.getTextEditChange = function(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var textDocument = { uri: key.uri, version: key.version };
          var result = this._textEditChanges[textDocument.uri];
          if (!result) {
            var edits = [];
            var textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          var result = this._textEditChanges[key];
          if (!result) {
            var edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      };
      WorkspaceChange2.prototype.initDocumentChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      };
      WorkspaceChange2.prototype.initChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = Object.create(null);
        }
      };
      WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = CreateFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = RenameFile.create(oldUri, newUri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = DeleteFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      return WorkspaceChange2;
    }();
    (function(TextDocumentIdentifier2) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier2.is = is;
    })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
    (function(VersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      VersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier2.is = is;
    })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
    (function(OptionalVersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      OptionalVersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier2.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
    (function(TextDocumentItem2) {
      function create(uri, languageId, version2, text) {
        return { uri, languageId, version: version2, text };
      }
      TextDocumentItem2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem2.is = is;
    })(TextDocumentItem || (TextDocumentItem = {}));
    (function(MarkupKind6) {
      MarkupKind6.PlainText = "plaintext";
      MarkupKind6.Markdown = "markdown";
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupKind6) {
      function is(value) {
        var candidate = value;
        return candidate === MarkupKind6.PlainText || candidate === MarkupKind6.Markdown;
      }
      MarkupKind6.is = is;
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupContent7) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent7.is = is;
    })(MarkupContent || (MarkupContent = {}));
    (function(CompletionItemKind6) {
      CompletionItemKind6.Text = 1;
      CompletionItemKind6.Method = 2;
      CompletionItemKind6.Function = 3;
      CompletionItemKind6.Constructor = 4;
      CompletionItemKind6.Field = 5;
      CompletionItemKind6.Variable = 6;
      CompletionItemKind6.Class = 7;
      CompletionItemKind6.Interface = 8;
      CompletionItemKind6.Module = 9;
      CompletionItemKind6.Property = 10;
      CompletionItemKind6.Unit = 11;
      CompletionItemKind6.Value = 12;
      CompletionItemKind6.Enum = 13;
      CompletionItemKind6.Keyword = 14;
      CompletionItemKind6.Snippet = 15;
      CompletionItemKind6.Color = 16;
      CompletionItemKind6.File = 17;
      CompletionItemKind6.Reference = 18;
      CompletionItemKind6.Folder = 19;
      CompletionItemKind6.EnumMember = 20;
      CompletionItemKind6.Constant = 21;
      CompletionItemKind6.Struct = 22;
      CompletionItemKind6.Event = 23;
      CompletionItemKind6.Operator = 24;
      CompletionItemKind6.TypeParameter = 25;
    })(CompletionItemKind || (CompletionItemKind = {}));
    (function(InsertTextFormat4) {
      InsertTextFormat4.PlainText = 1;
      InsertTextFormat4.Snippet = 2;
    })(InsertTextFormat || (InsertTextFormat = {}));
    (function(CompletionItemTag3) {
      CompletionItemTag3.Deprecated = 1;
    })(CompletionItemTag || (CompletionItemTag = {}));
    (function(InsertReplaceEdit3) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
      }
      InsertReplaceEdit3.is = is;
    })(InsertReplaceEdit || (InsertReplaceEdit = {}));
    (function(InsertTextMode4) {
      InsertTextMode4.asIs = 1;
      InsertTextMode4.adjustIndentation = 2;
    })(InsertTextMode || (InsertTextMode = {}));
    (function(CompletionItem4) {
      function create(label) {
        return { label };
      }
      CompletionItem4.create = create;
    })(CompletionItem || (CompletionItem = {}));
    (function(CompletionList4) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList4.create = create;
    })(CompletionList || (CompletionList = {}));
    (function(MarkedString3) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString3.fromPlainText = fromPlainText;
      function is(value) {
        var candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString3.is = is;
    })(MarkedString || (MarkedString = {}));
    (function(Hover6) {
      function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
      }
      Hover6.is = is;
    })(Hover || (Hover = {}));
    (function(ParameterInformation2) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation2.create = create;
    })(ParameterInformation || (ParameterInformation = {}));
    (function(SignatureInformation2) {
      function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          parameters[_i - 2] = arguments[_i];
        }
        var result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation2.create = create;
    })(SignatureInformation || (SignatureInformation = {}));
    (function(DocumentHighlightKind4) {
      DocumentHighlightKind4.Text = 1;
      DocumentHighlightKind4.Read = 2;
      DocumentHighlightKind4.Write = 3;
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    (function(DocumentHighlight6) {
      function create(range, kind) {
        var result = { range };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight6.create = create;
    })(DocumentHighlight || (DocumentHighlight = {}));
    (function(SymbolKind7) {
      SymbolKind7.File = 1;
      SymbolKind7.Module = 2;
      SymbolKind7.Namespace = 3;
      SymbolKind7.Package = 4;
      SymbolKind7.Class = 5;
      SymbolKind7.Method = 6;
      SymbolKind7.Property = 7;
      SymbolKind7.Field = 8;
      SymbolKind7.Constructor = 9;
      SymbolKind7.Enum = 10;
      SymbolKind7.Interface = 11;
      SymbolKind7.Function = 12;
      SymbolKind7.Variable = 13;
      SymbolKind7.Constant = 14;
      SymbolKind7.String = 15;
      SymbolKind7.Number = 16;
      SymbolKind7.Boolean = 17;
      SymbolKind7.Array = 18;
      SymbolKind7.Object = 19;
      SymbolKind7.Key = 20;
      SymbolKind7.Null = 21;
      SymbolKind7.EnumMember = 22;
      SymbolKind7.Struct = 23;
      SymbolKind7.Event = 24;
      SymbolKind7.Operator = 25;
      SymbolKind7.TypeParameter = 26;
    })(SymbolKind || (SymbolKind = {}));
    (function(SymbolTag6) {
      SymbolTag6.Deprecated = 1;
    })(SymbolTag || (SymbolTag = {}));
    (function(SymbolInformation8) {
      function create(name2, kind, range, uri, containerName) {
        var result = {
          name: name2,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation8.create = create;
    })(SymbolInformation || (SymbolInformation = {}));
    (function(DocumentSymbol8) {
      function create(name2, detail, kind, range, selectionRange, children) {
        var result = {
          name: name2,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol8.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
      }
      DocumentSymbol8.is = is;
    })(DocumentSymbol || (DocumentSymbol = {}));
    (function(CodeActionKind10) {
      CodeActionKind10.Empty = "";
      CodeActionKind10.QuickFix = "quickfix";
      CodeActionKind10.Refactor = "refactor";
      CodeActionKind10.RefactorExtract = "refactor.extract";
      CodeActionKind10.RefactorInline = "refactor.inline";
      CodeActionKind10.RefactorRewrite = "refactor.rewrite";
      CodeActionKind10.Source = "source";
      CodeActionKind10.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind10.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (CodeActionKind = {}));
    (function(CodeActionContext6) {
      function create(diagnostics, only) {
        var result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        return result;
      }
      CodeActionContext6.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
      }
      CodeActionContext6.is = is;
    })(CodeActionContext || (CodeActionContext = {}));
    (function(CodeAction9) {
      function create(title, kindOrCommandOrEdit, kind) {
        var result = { title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction9.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction9.is = is;
    })(CodeAction || (CodeAction = {}));
    (function(CodeLens6) {
      function create(range, data) {
        var result = { range };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens6.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens6.is = is;
    })(CodeLens || (CodeLens = {}));
    (function(FormattingOptions7) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions7.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions7.is = is;
    })(FormattingOptions || (FormattingOptions = {}));
    (function(DocumentLink7) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink7.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink7.is = is;
    })(DocumentLink || (DocumentLink = {}));
    (function(SelectionRange6) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange6.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange6.is(candidate.parent));
      }
      SelectionRange6.is = is;
    })(SelectionRange || (SelectionRange = {}));
    EOL = ["\n", "\r\n", "\r"];
    (function(TextDocument5) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument(uri, languageId, version2, content);
      }
      TextDocument5.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument5.is = is;
      function applyEdits2(document2, edits) {
        var text = document2.getText();
        var sortedEdits = mergeSort2(edits, function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
          var e = sortedEdits[i];
          var startOffset = document2.offsetAt(e.range.start);
          var endOffset = document2.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument5.applyEdits = applyEdits2;
      function mergeSort2(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort2(left, compare);
        mergeSort2(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (TextDocument = {}));
    FullTextDocument = function() {
      function FullTextDocument3(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument3.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument3.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument3.prototype.update = function(event, version2) {
        this._content = event.text;
        this._version = version2;
        this._lineOffsets = void 0;
      };
      FullTextDocument3.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          var lineOffsets = [];
          var text = this._content;
          var isLineStart = true;
          for (var i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            var ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      };
      FullTextDocument3.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position.create(0, offset);
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
      };
      FullTextDocument3.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      return FullTextDocument3;
    }();
    (function(Is7) {
      var toString = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is7.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is7.undefined = undefined2;
      function boolean2(value) {
        return value === true || value === false;
      }
      Is7.boolean = boolean2;
      function string2(value) {
        return toString.call(value) === "[object String]";
      }
      Is7.string = string2;
      function number2(value) {
        return toString.call(value) === "[object Number]";
      }
      Is7.number = number2;
      function numberRange(value, min, max) {
        return toString.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is7.numberRange = numberRange;
      function integer2(value) {
        return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is7.integer = integer2;
      function uinteger3(value) {
        return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is7.uinteger = uinteger3;
      function func2(value) {
        return toString.call(value) === "[object Function]";
      }
      Is7.func = func2;
      function objectLiteral2(value) {
        return value !== null && typeof value === "object";
      }
      Is7.objectLiteral = objectLiteral2;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is7.typedArray = typedArray;
    })(Is || (Is = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = void 0;
    var vscode_jsonrpc_1 = require_main();
    var RegistrationType4 = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType4;
    var ProtocolRequestType02 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType02;
    var ProtocolRequestType3 = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType3;
    var ProtocolNotificationType02 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType02;
    var ProtocolNotificationType4 = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType4;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean2(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string2;
    function number2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number2;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func2(value) {
      return typeof value === "function";
    }
    exports2.func = func2;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral2(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest3;
    (function(ImplementationRequest4) {
      ImplementationRequest4.method = "textDocument/implementation";
      ImplementationRequest4.type = new messages_1.ProtocolRequestType(ImplementationRequest4.method);
    })(ImplementationRequest3 = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest3;
    (function(TypeDefinitionRequest4) {
      TypeDefinitionRequest4.method = "textDocument/typeDefinition";
      TypeDefinitionRequest4.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest4.method);
    })(TypeDefinitionRequest3 = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest2;
    (function(WorkspaceFoldersRequest3) {
      WorkspaceFoldersRequest3.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
    })(WorkspaceFoldersRequest2 = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification2;
    (function(DidChangeWorkspaceFoldersNotification3) {
      DidChangeWorkspaceFoldersNotification3.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
    })(DidChangeWorkspaceFoldersNotification2 = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest2;
    (function(ConfigurationRequest3) {
      ConfigurationRequest3.type = new messages_1.ProtocolRequestType("workspace/configuration");
    })(ConfigurationRequest2 = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest3;
    (function(DocumentColorRequest4) {
      DocumentColorRequest4.method = "textDocument/documentColor";
      DocumentColorRequest4.type = new messages_1.ProtocolRequestType(DocumentColorRequest4.method);
    })(DocumentColorRequest3 = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
    var ColorPresentationRequest2;
    (function(ColorPresentationRequest3) {
      ColorPresentationRequest3.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
    })(ColorPresentationRequest2 = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRequest = exports2.FoldingRangeKind = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeKind2;
    (function(FoldingRangeKind3) {
      FoldingRangeKind3["Comment"] = "comment";
      FoldingRangeKind3["Imports"] = "imports";
      FoldingRangeKind3["Region"] = "region";
    })(FoldingRangeKind2 = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
    var FoldingRangeRequest3;
    (function(FoldingRangeRequest4) {
      FoldingRangeRequest4.method = "textDocument/foldingRange";
      FoldingRangeRequest4.type = new messages_1.ProtocolRequestType(FoldingRangeRequest4.method);
    })(FoldingRangeRequest3 = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest3;
    (function(DeclarationRequest4) {
      DeclarationRequest4.method = "textDocument/declaration";
      DeclarationRequest4.type = new messages_1.ProtocolRequestType(DeclarationRequest4.method);
    })(DeclarationRequest3 = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest3;
    (function(SelectionRangeRequest4) {
      SelectionRangeRequest4.method = "textDocument/selectionRange";
      SelectionRangeRequest4.type = new messages_1.ProtocolRequestType(SelectionRangeRequest4.method);
    })(SelectionRangeRequest3 = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress3;
    (function(WorkDoneProgress4) {
      WorkDoneProgress4.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress4.type;
      }
      WorkDoneProgress4.is = is;
    })(WorkDoneProgress3 = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest2;
    (function(WorkDoneProgressCreateRequest3) {
      WorkDoneProgressCreateRequest3.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
    })(WorkDoneProgressCreateRequest2 = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
    })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest3;
    (function(CallHierarchyPrepareRequest4) {
      CallHierarchyPrepareRequest4.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest4.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest4.method);
    })(CallHierarchyPrepareRequest3 = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest2;
    (function(CallHierarchyIncomingCallsRequest3) {
      CallHierarchyIncomingCallsRequest3.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest3.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest3.method);
    })(CallHierarchyIncomingCallsRequest2 = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest2;
    (function(CallHierarchyOutgoingCallsRequest3) {
      CallHierarchyOutgoingCallsRequest3.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest3.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest3.method);
    })(CallHierarchyOutgoingCallsRequest2 = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = void 0;
    var messages_1 = require_messages2();
    var SemanticTokenTypes2;
    (function(SemanticTokenTypes3) {
      SemanticTokenTypes3["namespace"] = "namespace";
      SemanticTokenTypes3["type"] = "type";
      SemanticTokenTypes3["class"] = "class";
      SemanticTokenTypes3["enum"] = "enum";
      SemanticTokenTypes3["interface"] = "interface";
      SemanticTokenTypes3["struct"] = "struct";
      SemanticTokenTypes3["typeParameter"] = "typeParameter";
      SemanticTokenTypes3["parameter"] = "parameter";
      SemanticTokenTypes3["variable"] = "variable";
      SemanticTokenTypes3["property"] = "property";
      SemanticTokenTypes3["enumMember"] = "enumMember";
      SemanticTokenTypes3["event"] = "event";
      SemanticTokenTypes3["function"] = "function";
      SemanticTokenTypes3["method"] = "method";
      SemanticTokenTypes3["macro"] = "macro";
      SemanticTokenTypes3["keyword"] = "keyword";
      SemanticTokenTypes3["modifier"] = "modifier";
      SemanticTokenTypes3["comment"] = "comment";
      SemanticTokenTypes3["string"] = "string";
      SemanticTokenTypes3["number"] = "number";
      SemanticTokenTypes3["regexp"] = "regexp";
      SemanticTokenTypes3["operator"] = "operator";
    })(SemanticTokenTypes2 = exports2.SemanticTokenTypes || (exports2.SemanticTokenTypes = {}));
    var SemanticTokenModifiers2;
    (function(SemanticTokenModifiers3) {
      SemanticTokenModifiers3["declaration"] = "declaration";
      SemanticTokenModifiers3["definition"] = "definition";
      SemanticTokenModifiers3["readonly"] = "readonly";
      SemanticTokenModifiers3["static"] = "static";
      SemanticTokenModifiers3["deprecated"] = "deprecated";
      SemanticTokenModifiers3["abstract"] = "abstract";
      SemanticTokenModifiers3["async"] = "async";
      SemanticTokenModifiers3["modification"] = "modification";
      SemanticTokenModifiers3["documentation"] = "documentation";
      SemanticTokenModifiers3["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers2 = exports2.SemanticTokenModifiers || (exports2.SemanticTokenModifiers = {}));
    var SemanticTokens6;
    (function(SemanticTokens7) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens7.is = is;
    })(SemanticTokens6 = exports2.SemanticTokens || (exports2.SemanticTokens = {}));
    var TokenFormat2;
    (function(TokenFormat3) {
      TokenFormat3.Relative = "relative";
    })(TokenFormat2 = exports2.TokenFormat || (exports2.TokenFormat = {}));
    var SemanticTokensRegistrationType3;
    (function(SemanticTokensRegistrationType4) {
      SemanticTokensRegistrationType4.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType4.type = new messages_1.RegistrationType(SemanticTokensRegistrationType4.method);
    })(SemanticTokensRegistrationType3 = exports2.SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest2;
    (function(SemanticTokensRequest3) {
      SemanticTokensRequest3.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest3.type = new messages_1.ProtocolRequestType(SemanticTokensRequest3.method);
    })(SemanticTokensRequest2 = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest2;
    (function(SemanticTokensDeltaRequest3) {
      SemanticTokensDeltaRequest3.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest3.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest3.method);
    })(SemanticTokensDeltaRequest2 = exports2.SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest2;
    (function(SemanticTokensRangeRequest3) {
      SemanticTokensRangeRequest3.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest3.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest3.method);
    })(SemanticTokensRangeRequest2 = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest2;
    (function(SemanticTokensRefreshRequest3) {
      SemanticTokensRefreshRequest3.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest3.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest3.method);
    })(SemanticTokensRefreshRequest2 = exports2.SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest2;
    (function(ShowDocumentRequest3) {
      ShowDocumentRequest3.method = "window/showDocument";
      ShowDocumentRequest3.type = new messages_1.ProtocolRequestType(ShowDocumentRequest3.method);
    })(ShowDocumentRequest2 = exports2.ShowDocumentRequest || (exports2.ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest3;
    (function(LinkedEditingRangeRequest4) {
      LinkedEditingRangeRequest4.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest4.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest4.method);
    })(LinkedEditingRangeRequest3 = exports2.LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind2;
    (function(FileOperationPatternKind3) {
      FileOperationPatternKind3.file = "file";
      FileOperationPatternKind3.folder = "folder";
    })(FileOperationPatternKind2 = exports2.FileOperationPatternKind || (exports2.FileOperationPatternKind = {}));
    var WillCreateFilesRequest3;
    (function(WillCreateFilesRequest4) {
      WillCreateFilesRequest4.method = "workspace/willCreateFiles";
      WillCreateFilesRequest4.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest4.method);
    })(WillCreateFilesRequest3 = exports2.WillCreateFilesRequest || (exports2.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification3;
    (function(DidCreateFilesNotification4) {
      DidCreateFilesNotification4.method = "workspace/didCreateFiles";
      DidCreateFilesNotification4.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification4.method);
    })(DidCreateFilesNotification3 = exports2.DidCreateFilesNotification || (exports2.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest3;
    (function(WillRenameFilesRequest4) {
      WillRenameFilesRequest4.method = "workspace/willRenameFiles";
      WillRenameFilesRequest4.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest4.method);
    })(WillRenameFilesRequest3 = exports2.WillRenameFilesRequest || (exports2.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification3;
    (function(DidRenameFilesNotification4) {
      DidRenameFilesNotification4.method = "workspace/didRenameFiles";
      DidRenameFilesNotification4.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification4.method);
    })(DidRenameFilesNotification3 = exports2.DidRenameFilesNotification || (exports2.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification3;
    (function(DidDeleteFilesNotification4) {
      DidDeleteFilesNotification4.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification4.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification4.method);
    })(DidDeleteFilesNotification3 = exports2.DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest3;
    (function(WillDeleteFilesRequest4) {
      WillDeleteFilesRequest4.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest4.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest4.method);
    })(WillDeleteFilesRequest3 = exports2.WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2["document"] = "document";
      UniquenessLevel2["project"] = "project";
      UniquenessLevel2["group"] = "group";
      UniquenessLevel2["scheme"] = "scheme";
      UniquenessLevel2["global"] = "global";
    })(UniquenessLevel = exports2.UniquenessLevel || (exports2.UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2["import"] = "import";
      MonikerKind2["export"] = "export";
      MonikerKind2["local"] = "local";
    })(MonikerKind = exports2.MonikerKind || (exports2.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports2.MonikerRequest || (exports2.MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeError = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.DocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = void 0;
    var Is7 = require_is2();
    var messages_1 = require_messages2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokenTypes", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokenTypes;
    } });
    Object.defineProperty(exports2, "SemanticTokenModifiers", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokenModifiers;
    } });
    Object.defineProperty(exports2, "SemanticTokens", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokens;
    } });
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var DocumentFilter;
    (function(DocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is7.string(candidate.language) || Is7.string(candidate.scheme) || Is7.string(candidate.pattern);
      }
      DocumentFilter2.is = is;
    })(DocumentFilter = exports2.DocumentFilter || (exports2.DocumentFilter = {}));
    var DocumentSelector40;
    (function(DocumentSelector41) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is7.string(elem) && !DocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector41.is = is;
    })(DocumentSelector40 = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
    var RegistrationRequest2;
    (function(RegistrationRequest3) {
      RegistrationRequest3.type = new messages_1.ProtocolRequestType("client/registerCapability");
    })(RegistrationRequest2 = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
    var UnregistrationRequest2;
    (function(UnregistrationRequest3) {
      UnregistrationRequest3.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
    })(UnregistrationRequest2 = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
    var ResourceOperationKind2;
    (function(ResourceOperationKind3) {
      ResourceOperationKind3.Create = "create";
      ResourceOperationKind3.Rename = "rename";
      ResourceOperationKind3.Delete = "delete";
    })(ResourceOperationKind2 = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
    var FailureHandlingKind2;
    (function(FailureHandlingKind3) {
      FailureHandlingKind3.Abort = "abort";
      FailureHandlingKind3.Transactional = "transactional";
      FailureHandlingKind3.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind3.Undo = "undo";
    })(FailureHandlingKind2 = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
    var StaticRegistrationOptions2;
    (function(StaticRegistrationOptions3) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is7.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions3.hasId = hasId;
    })(StaticRegistrationOptions2 = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions2;
    (function(TextDocumentRegistrationOptions3) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector40.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions3.is = is;
    })(TextDocumentRegistrationOptions2 = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions2;
    (function(WorkDoneProgressOptions3) {
      function is(value) {
        const candidate = value;
        return Is7.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is7.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions3.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is7.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions3.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions2 = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
    var InitializeRequest2;
    (function(InitializeRequest3) {
      InitializeRequest3.type = new messages_1.ProtocolRequestType("initialize");
    })(InitializeRequest2 = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
    var InitializeError2;
    (function(InitializeError3) {
      InitializeError3.unknownProtocolVersion = 1;
    })(InitializeError2 = exports2.InitializeError || (exports2.InitializeError = {}));
    var InitializedNotification2;
    (function(InitializedNotification3) {
      InitializedNotification3.type = new messages_1.ProtocolNotificationType("initialized");
    })(InitializedNotification2 = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
    var ShutdownRequest2;
    (function(ShutdownRequest3) {
      ShutdownRequest3.type = new messages_1.ProtocolRequestType0("shutdown");
    })(ShutdownRequest2 = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
    var ExitNotification2;
    (function(ExitNotification3) {
      ExitNotification3.type = new messages_1.ProtocolNotificationType0("exit");
    })(ExitNotification2 = exports2.ExitNotification || (exports2.ExitNotification = {}));
    var DidChangeConfigurationNotification2;
    (function(DidChangeConfigurationNotification3) {
      DidChangeConfigurationNotification3.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
    })(DidChangeConfigurationNotification2 = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
    var MessageType2;
    (function(MessageType3) {
      MessageType3.Error = 1;
      MessageType3.Warning = 2;
      MessageType3.Info = 3;
      MessageType3.Log = 4;
    })(MessageType2 = exports2.MessageType || (exports2.MessageType = {}));
    var ShowMessageNotification2;
    (function(ShowMessageNotification3) {
      ShowMessageNotification3.type = new messages_1.ProtocolNotificationType("window/showMessage");
    })(ShowMessageNotification2 = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
    var ShowMessageRequest2;
    (function(ShowMessageRequest3) {
      ShowMessageRequest3.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
    })(ShowMessageRequest2 = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
    var LogMessageNotification2;
    (function(LogMessageNotification3) {
      LogMessageNotification3.type = new messages_1.ProtocolNotificationType("window/logMessage");
    })(LogMessageNotification2 = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
    var TelemetryEventNotification2;
    (function(TelemetryEventNotification3) {
      TelemetryEventNotification3.type = new messages_1.ProtocolNotificationType("telemetry/event");
    })(TelemetryEventNotification2 = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
    var TextDocumentSyncKind2;
    (function(TextDocumentSyncKind3) {
      TextDocumentSyncKind3.None = 0;
      TextDocumentSyncKind3.Full = 1;
      TextDocumentSyncKind3.Incremental = 2;
    })(TextDocumentSyncKind2 = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification2;
    (function(DidOpenTextDocumentNotification3) {
      DidOpenTextDocumentNotification3.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification3.method);
    })(DidOpenTextDocumentNotification2 = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent2;
    (function(TextDocumentContentChangeEvent3) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent3.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent3.isFull = isFull;
    })(TextDocumentContentChangeEvent2 = exports2.TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification2;
    (function(DidChangeTextDocumentNotification3) {
      DidChangeTextDocumentNotification3.method = "textDocument/didChange";
      DidChangeTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification3.method);
    })(DidChangeTextDocumentNotification2 = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification2;
    (function(DidCloseTextDocumentNotification3) {
      DidCloseTextDocumentNotification3.method = "textDocument/didClose";
      DidCloseTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification3.method);
    })(DidCloseTextDocumentNotification2 = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification2;
    (function(DidSaveTextDocumentNotification3) {
      DidSaveTextDocumentNotification3.method = "textDocument/didSave";
      DidSaveTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification3.method);
    })(DidSaveTextDocumentNotification2 = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason2;
    (function(TextDocumentSaveReason3) {
      TextDocumentSaveReason3.Manual = 1;
      TextDocumentSaveReason3.AfterDelay = 2;
      TextDocumentSaveReason3.FocusOut = 3;
    })(TextDocumentSaveReason2 = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification2;
    (function(WillSaveTextDocumentNotification3) {
      WillSaveTextDocumentNotification3.method = "textDocument/willSave";
      WillSaveTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification3.method);
    })(WillSaveTextDocumentNotification2 = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest2;
    (function(WillSaveTextDocumentWaitUntilRequest3) {
      WillSaveTextDocumentWaitUntilRequest3.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest3.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest3.method);
    })(WillSaveTextDocumentWaitUntilRequest2 = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification2;
    (function(DidChangeWatchedFilesNotification3) {
      DidChangeWatchedFilesNotification3.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
    })(DidChangeWatchedFilesNotification2 = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
    var FileChangeType3;
    (function(FileChangeType4) {
      FileChangeType4.Created = 1;
      FileChangeType4.Changed = 2;
      FileChangeType4.Deleted = 3;
    })(FileChangeType3 = exports2.FileChangeType || (exports2.FileChangeType = {}));
    var WatchKind2;
    (function(WatchKind3) {
      WatchKind3.Create = 1;
      WatchKind3.Change = 2;
      WatchKind3.Delete = 4;
    })(WatchKind2 = exports2.WatchKind || (exports2.WatchKind = {}));
    var PublishDiagnosticsNotification2;
    (function(PublishDiagnosticsNotification3) {
      PublishDiagnosticsNotification3.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
    })(PublishDiagnosticsNotification2 = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind3;
    (function(CompletionTriggerKind4) {
      CompletionTriggerKind4.Invoked = 1;
      CompletionTriggerKind4.TriggerCharacter = 2;
      CompletionTriggerKind4.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind3 = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
    var CompletionRequest2;
    (function(CompletionRequest3) {
      CompletionRequest3.method = "textDocument/completion";
      CompletionRequest3.type = new messages_1.ProtocolRequestType(CompletionRequest3.method);
    })(CompletionRequest2 = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
    var CompletionResolveRequest2;
    (function(CompletionResolveRequest3) {
      CompletionResolveRequest3.method = "completionItem/resolve";
      CompletionResolveRequest3.type = new messages_1.ProtocolRequestType(CompletionResolveRequest3.method);
    })(CompletionResolveRequest2 = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
    var HoverRequest2;
    (function(HoverRequest3) {
      HoverRequest3.method = "textDocument/hover";
      HoverRequest3.type = new messages_1.ProtocolRequestType(HoverRequest3.method);
    })(HoverRequest2 = exports2.HoverRequest || (exports2.HoverRequest = {}));
    var SignatureHelpTriggerKind3;
    (function(SignatureHelpTriggerKind4) {
      SignatureHelpTriggerKind4.Invoked = 1;
      SignatureHelpTriggerKind4.TriggerCharacter = 2;
      SignatureHelpTriggerKind4.ContentChange = 3;
    })(SignatureHelpTriggerKind3 = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest2;
    (function(SignatureHelpRequest3) {
      SignatureHelpRequest3.method = "textDocument/signatureHelp";
      SignatureHelpRequest3.type = new messages_1.ProtocolRequestType(SignatureHelpRequest3.method);
    })(SignatureHelpRequest2 = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
    var DefinitionRequest2;
    (function(DefinitionRequest3) {
      DefinitionRequest3.method = "textDocument/definition";
      DefinitionRequest3.type = new messages_1.ProtocolRequestType(DefinitionRequest3.method);
    })(DefinitionRequest2 = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
    var ReferencesRequest2;
    (function(ReferencesRequest3) {
      ReferencesRequest3.method = "textDocument/references";
      ReferencesRequest3.type = new messages_1.ProtocolRequestType(ReferencesRequest3.method);
    })(ReferencesRequest2 = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
    var DocumentHighlightRequest2;
    (function(DocumentHighlightRequest3) {
      DocumentHighlightRequest3.method = "textDocument/documentHighlight";
      DocumentHighlightRequest3.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest3.method);
    })(DocumentHighlightRequest2 = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest2;
    (function(DocumentSymbolRequest3) {
      DocumentSymbolRequest3.method = "textDocument/documentSymbol";
      DocumentSymbolRequest3.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest3.method);
    })(DocumentSymbolRequest2 = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
    var CodeActionRequest2;
    (function(CodeActionRequest3) {
      CodeActionRequest3.method = "textDocument/codeAction";
      CodeActionRequest3.type = new messages_1.ProtocolRequestType(CodeActionRequest3.method);
    })(CodeActionRequest2 = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
    var CodeActionResolveRequest2;
    (function(CodeActionResolveRequest3) {
      CodeActionResolveRequest3.method = "codeAction/resolve";
      CodeActionResolveRequest3.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest3.method);
    })(CodeActionResolveRequest2 = exports2.CodeActionResolveRequest || (exports2.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest2;
    (function(WorkspaceSymbolRequest3) {
      WorkspaceSymbolRequest3.method = "workspace/symbol";
      WorkspaceSymbolRequest3.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest3.method);
    })(WorkspaceSymbolRequest2 = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
    var CodeLensRequest2;
    (function(CodeLensRequest3) {
      CodeLensRequest3.method = "textDocument/codeLens";
      CodeLensRequest3.type = new messages_1.ProtocolRequestType(CodeLensRequest3.method);
    })(CodeLensRequest2 = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
    var CodeLensResolveRequest2;
    (function(CodeLensResolveRequest3) {
      CodeLensResolveRequest3.method = "codeLens/resolve";
      CodeLensResolveRequest3.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest3.method);
    })(CodeLensResolveRequest2 = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest2;
    (function(CodeLensRefreshRequest3) {
      CodeLensRefreshRequest3.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest3.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest3.method);
    })(CodeLensRefreshRequest2 = exports2.CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest2;
    (function(DocumentLinkRequest3) {
      DocumentLinkRequest3.method = "textDocument/documentLink";
      DocumentLinkRequest3.type = new messages_1.ProtocolRequestType(DocumentLinkRequest3.method);
    })(DocumentLinkRequest2 = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest2;
    (function(DocumentLinkResolveRequest3) {
      DocumentLinkResolveRequest3.method = "documentLink/resolve";
      DocumentLinkResolveRequest3.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest3.method);
    })(DocumentLinkResolveRequest2 = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest2;
    (function(DocumentFormattingRequest3) {
      DocumentFormattingRequest3.method = "textDocument/formatting";
      DocumentFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest3.method);
    })(DocumentFormattingRequest2 = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest2;
    (function(DocumentRangeFormattingRequest3) {
      DocumentRangeFormattingRequest3.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest3.method);
    })(DocumentRangeFormattingRequest2 = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest2;
    (function(DocumentOnTypeFormattingRequest3) {
      DocumentOnTypeFormattingRequest3.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest3.method);
    })(DocumentOnTypeFormattingRequest2 = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior = exports2.PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = {}));
    var RenameRequest2;
    (function(RenameRequest3) {
      RenameRequest3.method = "textDocument/rename";
      RenameRequest3.type = new messages_1.ProtocolRequestType(RenameRequest3.method);
    })(RenameRequest2 = exports2.RenameRequest || (exports2.RenameRequest = {}));
    var PrepareRenameRequest2;
    (function(PrepareRenameRequest3) {
      PrepareRenameRequest3.method = "textDocument/prepareRename";
      PrepareRenameRequest3.type = new messages_1.ProtocolRequestType(PrepareRenameRequest3.method);
    })(PrepareRenameRequest2 = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
    var ExecuteCommandRequest2;
    (function(ExecuteCommandRequest3) {
      ExecuteCommandRequest3.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
    })(ExecuteCommandRequest2 = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest2;
    (function(ApplyWorkspaceEditRequest3) {
      ApplyWorkspaceEditRequest3.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest2 = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection2(input, output, logger113, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return vscode_jsonrpc_1.createMessageConnection(input, output, logger113, options);
    }
    exports2.createProtocolConnection = createProtocolConnection2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar((init_main(), main_exports), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection3();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes2;
    (function(LSPErrorCodes3) {
      LSPErrorCodes3.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes3.ContentModified = -32801;
      LSPErrorCodes3.RequestCancelled = -32800;
      LSPErrorCodes3.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes2 = exports2.LSPErrorCodes || (exports2.LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_1 = require_node2();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    function createProtocolConnection2(input, output, logger113, options) {
      return node_1.createMessageConnection(input, output, logger113, options);
    }
    exports2.createProtocolConnection = createProtocolConnection2;
  }
});

// node_modules/debounce/index.js
var require_debounce = __commonJS({
  "node_modules/debounce/index.js"(exports2, module2) {
    function debounce15(func2, wait2, immediate) {
      var timeout, args, context, timestamp, result;
      if (wait2 == null)
        wait2 = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait2 && last >= 0) {
          timeout = setTimeout(later, wait2 - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func2.apply(context, args);
            context = args = null;
          }
        }
      }
      ;
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait2);
        if (callNow) {
          result = func2.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      debounced.flush = function() {
        if (timeout) {
          result = func2.apply(context, args);
          context = args = null;
          clearTimeout(timeout);
          timeout = null;
        }
      };
      return debounced;
    }
    debounce15.debounce = debounce15;
    module2.exports = debounce15;
  }
});

// node_modules/rfc-3986/index.js
var require_rfc_3986 = __commonJS({
  "node_modules/rfc-3986/index.js"(exports2, module2) {
    "use strict";
    var internals = {
      rfc3986: {}
    };
    internals.generate = function() {
      var or = "|";
      var digit = "0-9";
      var digitOnly = "[" + digit + "]";
      var alpha = "a-zA-Z";
      var alphaOnly = "[" + alpha + "]";
      internals.rfc3986.cidr = digitOnly + or + "[1-2]" + digitOnly + or + "3[0-2]";
      var hexDigit = digit + "A-Fa-f";
      var hexDigitOnly = "[" + hexDigit + "]";
      var unreserved = alpha + digit + "-\\._~";
      var subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      var pctEncoded = "%" + hexDigit;
      var pchar = unreserved + pctEncoded + subDelims + ":@";
      var pcharOnly = "[" + pchar + "]";
      var zeroPad = "0?";
      var decOctect = "(?:" + zeroPad + zeroPad + digitOnly + or + zeroPad + "[1-9]" + digitOnly + or + "1" + digitOnly + digitOnly + or + "2[0-4]" + digitOnly + or + "25[0-5])";
      internals.rfc3986.IPv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
      var h16 = hexDigitOnly + "{1,4}";
      var ls32 = "(?:" + h16 + ":" + h16 + "|" + internals.rfc3986.IPv4address + ")";
      var IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      var IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      var IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      var IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      var IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      var IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      var IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      var IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      var IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      internals.rfc3986.IPv6address = "(?:" + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ")";
      internals.rfc3986.IPvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      internals.rfc3986.scheme = alphaOnly + "[" + alpha + digit + "+-\\.]*";
      var userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
      internals.rfc3986.IPLiteral = "\\[(?:" + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ")\\]";
      var regName = "[" + unreserved + pctEncoded + subDelims + "]{0,255}";
      var host = "(?:" + internals.rfc3986.IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ")";
      var port = digitOnly + "*";
      var authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
      var segment = pcharOnly + "*";
      var segmentNz = pcharOnly + "+";
      var pathAbEmpty = "(?:\\/" + segment + ")*";
      var pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
      var pathRootless = segmentNz + pathAbEmpty;
      internals.rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")" + or + pathAbsolute + or + pathRootless + ")";
      internals.rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
      internals.rfc3986.fragment = "[" + pchar + "\\/\\?]*";
      internals.rfc3986.uri = "^(?:" + internals.rfc3986.scheme + ":" + internals.rfc3986.hierPart + ")(?:\\?" + internals.rfc3986.query + ")?(?:#" + internals.rfc3986.fragment + ")?$";
    };
    internals.generate();
    module2.exports = internals.rfc3986;
  }
});

// node_modules/isuri/index.js
var require_isuri = __commonJS({
  "node_modules/isuri/index.js"(exports2, module2) {
    "use strict";
    var rfc3986 = require_rfc_3986();
    function escapeRegex(string2) {
      return string2.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    }
    var internals = {
      Uri: {
        createUriRegex: function(options) {
          options = options || {};
          if (typeof options !== "object" || Array.isArray(options)) {
            throw new Error("options must be an object");
          }
          var customScheme = "";
          if (options.scheme) {
            if (!Array.isArray(options.scheme)) {
              options.scheme = [options.scheme];
            }
            if (options.scheme.length <= 0) {
              throw new Error("scheme must have at least 1 scheme specified");
            }
            for (var i = 0; i < options.scheme.length; ++i) {
              var currentScheme = options.scheme[i];
              if (!(currentScheme instanceof RegExp || typeof currentScheme === "string")) {
                throw new Error("scheme must only contain Regular Expressions or Strings");
              }
              customScheme = customScheme + (customScheme ? "|" : "");
              if (currentScheme instanceof RegExp) {
                customScheme = customScheme + currentScheme.source;
              } else {
                if (!/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(currentScheme)) {
                  throw new Error("scheme at position " + i + " must be a valid scheme");
                }
                customScheme = customScheme + escapeRegex(currentScheme);
              }
            }
          }
          var scheme = "(?:" + (customScheme || rfc3986.scheme) + ")";
          return new RegExp("^(?:" + scheme + ":" + rfc3986.hierPart + ")(?:\\?" + rfc3986.query + ")?(?:#" + rfc3986.fragment + ")?$");
        },
        uriRegex: new RegExp(rfc3986.uri)
      }
    };
    internals.Uri.isValid = function(val) {
      return internals.Uri.uriRegex.test(val);
    };
    module2.exports = {
      createUriRegex: internals.Uri.createUriRegex,
      uriRegex: internals.Uri.uriRegex,
      isValid: internals.Uri.isValid
    };
  }
});

// node_modules/vscode-uri/lib/esm/index.js
function _validateUri(ret, _strict) {
  if (!ret.scheme && _strict) {
    throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "' + ret.authority + '", path: "' + ret.path + '", query: "' + ret.query + '", fragment: "' + ret.fragment + '"}');
  }
  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path36) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path36) {
        path36 = _slash;
      } else if (path36[0] !== _slash) {
        path36 = _slash + path36;
      }
      break;
  }
  return path36;
}
function encodeURIComponentFast(uriComponent, allowSlash) {
  var res = void 0;
  var nativeEncodePos = -1;
  for (var pos = 0; pos < uriComponent.length; pos++) {
    var code = uriComponent.charCodeAt(pos);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || allowSlash && code === 47) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      var escaped = encodeTable[code];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path36) {
  var res = void 0;
  for (var pos = 0; pos < path36.length; pos++) {
    var code = path36.charCodeAt(pos);
    if (code === 35 || code === 63) {
      if (res === void 0) {
        res = path36.substr(0, pos);
      }
      res += encodeTable[code];
    } else {
      if (res !== void 0) {
        res += path36[pos];
      }
    }
  }
  return res !== void 0 ? res : path36;
}
function uriToFsPath(uri, keepDriveLetterCasing) {
  var value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = "//" + uri.authority + uri.path;
  } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
    if (!keepDriveLetterCasing) {
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  var encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  var res = "";
  var scheme = uri.scheme, authority = uri.authority, path36 = uri.path, query = uri.query, fragment = uri.fragment;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    var idx = authority.indexOf("@");
    if (idx !== -1) {
      var userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.indexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.indexOf(":");
    if (idx === -1) {
      res += encoder(authority, false);
    } else {
      res += encoder(authority.substr(0, idx), false);
      res += authority.substr(idx);
    }
  }
  if (path36) {
    if (path36.length >= 3 && path36.charCodeAt(0) === 47 && path36.charCodeAt(2) === 58) {
      var code = path36.charCodeAt(1);
      if (code >= 65 && code <= 90) {
        path36 = "/" + String.fromCharCode(code + 32) + ":" + path36.substr(3);
      }
    } else if (path36.length >= 2 && path36.charCodeAt(1) === 58) {
      var code = path36.charCodeAt(0);
      if (code >= 65 && code <= 90) {
        path36 = String.fromCharCode(code + 32) + ":" + path36.substr(2);
      }
    }
    res += encoder(path36, true);
  }
  if (query) {
    res += "?";
    res += encoder(query, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
  }
  return res;
}
function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch (_a2) {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}
function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }
  return str.replace(_rEncodedAsHex, function(match) {
    return decodeURIComponentGraceful(match);
  });
}
var __extends, _a, isWindows, userAgent, _schemePattern, _singleSlashStart, _doubleSlashStart, _empty, _slash, _regexp, URI, _pathSepMarker, _URI, encodeTable, _rEncodedAsHex;
var init_esm2 = __esm({
  "node_modules/vscode-uri/lib/esm/index.js"() {
    "use strict";
    __extends = function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    if (typeof process === "object") {
      isWindows = process.platform === "win32";
    } else if (typeof navigator === "object") {
      userAgent = navigator.userAgent;
      isWindows = userAgent.indexOf("Windows") >= 0;
    }
    _schemePattern = /^\w[\w\d+.-]*$/;
    _singleSlashStart = /^\//;
    _doubleSlashStart = /^\/\//;
    _empty = "";
    _slash = "/";
    _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    URI = function() {
      function URI2(schemeOrData, authority, path36, query, fragment, _strict) {
        if (_strict === void 0) {
          _strict = false;
        }
        if (typeof schemeOrData === "object") {
          this.scheme = schemeOrData.scheme || _empty;
          this.authority = schemeOrData.authority || _empty;
          this.path = schemeOrData.path || _empty;
          this.query = schemeOrData.query || _empty;
          this.fragment = schemeOrData.fragment || _empty;
        } else {
          this.scheme = _schemeFix(schemeOrData, _strict);
          this.authority = authority || _empty;
          this.path = _referenceResolution(this.scheme, path36 || _empty);
          this.query = query || _empty;
          this.fragment = fragment || _empty;
          _validateUri(this, _strict);
        }
      }
      URI2.isUri = function(thing) {
        if (thing instanceof URI2) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "function" && typeof thing.with === "function" && typeof thing.toString === "function";
      };
      Object.defineProperty(URI2.prototype, "fsPath", {
        get: function() {
          return uriToFsPath(this, false);
        },
        enumerable: true,
        configurable: true
      });
      URI2.prototype.with = function(change) {
        if (!change) {
          return this;
        }
        var scheme = change.scheme, authority = change.authority, path36 = change.path, query = change.query, fragment = change.fragment;
        if (scheme === void 0) {
          scheme = this.scheme;
        } else if (scheme === null) {
          scheme = _empty;
        }
        if (authority === void 0) {
          authority = this.authority;
        } else if (authority === null) {
          authority = _empty;
        }
        if (path36 === void 0) {
          path36 = this.path;
        } else if (path36 === null) {
          path36 = _empty;
        }
        if (query === void 0) {
          query = this.query;
        } else if (query === null) {
          query = _empty;
        }
        if (fragment === void 0) {
          fragment = this.fragment;
        } else if (fragment === null) {
          fragment = _empty;
        }
        if (scheme === this.scheme && authority === this.authority && path36 === this.path && query === this.query && fragment === this.fragment) {
          return this;
        }
        return new _URI(scheme, authority, path36, query, fragment);
      };
      URI2.parse = function(value, _strict) {
        if (_strict === void 0) {
          _strict = false;
        }
        var match = _regexp.exec(value);
        if (!match) {
          return new _URI(_empty, _empty, _empty, _empty, _empty);
        }
        return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
      };
      URI2.file = function(path36) {
        var authority = _empty;
        if (isWindows) {
          path36 = path36.replace(/\\/g, _slash);
        }
        if (path36[0] === _slash && path36[1] === _slash) {
          var idx = path36.indexOf(_slash, 2);
          if (idx === -1) {
            authority = path36.substring(2);
            path36 = _slash;
          } else {
            authority = path36.substring(2, idx);
            path36 = path36.substring(idx) || _slash;
          }
        }
        return new _URI("file", authority, path36, _empty, _empty);
      };
      URI2.from = function(components) {
        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
      };
      URI2.prototype.toString = function(skipEncoding) {
        if (skipEncoding === void 0) {
          skipEncoding = false;
        }
        return _asFormatted(this, skipEncoding);
      };
      URI2.prototype.toJSON = function() {
        return this;
      };
      URI2.revive = function(data) {
        if (!data) {
          return data;
        } else if (data instanceof URI2) {
          return data;
        } else {
          var result = new _URI(data);
          result._formatted = data.external;
          result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
          return result;
        }
      };
      return URI2;
    }();
    _pathSepMarker = isWindows ? 1 : void 0;
    _URI = function(_super) {
      __extends(_URI2, _super);
      function _URI2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._formatted = null;
        _this._fsPath = null;
        return _this;
      }
      Object.defineProperty(_URI2.prototype, "fsPath", {
        get: function() {
          if (!this._fsPath) {
            this._fsPath = uriToFsPath(this, false);
          }
          return this._fsPath;
        },
        enumerable: true,
        configurable: true
      });
      _URI2.prototype.toString = function(skipEncoding) {
        if (skipEncoding === void 0) {
          skipEncoding = false;
        }
        if (!skipEncoding) {
          if (!this._formatted) {
            this._formatted = _asFormatted(this, false);
          }
          return this._formatted;
        } else {
          return _asFormatted(this, true);
        }
      };
      _URI2.prototype.toJSON = function() {
        var res = {
          $mid: 1
        };
        if (this._fsPath) {
          res.fsPath = this._fsPath;
          res._sep = _pathSepMarker;
        }
        if (this._formatted) {
          res.external = this._formatted;
        }
        if (this.path) {
          res.path = this.path;
        }
        if (this.scheme) {
          res.scheme = this.scheme;
        }
        if (this.authority) {
          res.authority = this.authority;
        }
        if (this.query) {
          res.query = this.query;
        }
        if (this.fragment) {
          res.fragment = this.fragment;
        }
        return res;
      };
      return _URI2;
    }(URI);
    encodeTable = (_a = {}, _a[58] = "%3A", _a[47] = "%2F", _a[63] = "%3F", _a[35] = "%23", _a[91] = "%5B", _a[93] = "%5D", _a[64] = "%40", _a[33] = "%21", _a[36] = "%24", _a[38] = "%26", _a[39] = "%27", _a[40] = "%28", _a[41] = "%29", _a[42] = "%2A", _a[43] = "%2B", _a[44] = "%2C", _a[59] = "%3B", _a[61] = "%3D", _a[32] = "%20", _a);
    _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs27 = require("fs");
    function checkPathExt(path36, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path36.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path36, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path36, options);
    }
    function isexe(path36, options, cb) {
      fs27.stat(path36, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path36, options));
      });
    }
    function sync(path36, options) {
      return checkStat(fs27.statSync(path36), path36, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs27 = require("fs");
    function isexe(path36, options, cb) {
      fs27.stat(path36, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path36, options) {
      return checkStat(fs27.statSync(path36), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports2, module2) {
    var fs27 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path36, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve3, reject) {
          isexe(path36, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve3(is);
            }
          });
        });
      }
      core(path36, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path36, options) {
      try {
        return core.sync(path36, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports2, module2) {
    var isWindows4 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path36 = require("path");
    var COLON = isWindows4 ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows4 && cmd.match(/\\/) ? [""] : [
        ...isWindows4 ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows4 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows4 ? pathExtExe.split(colon) : [""];
      if (isWindows4) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which5 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve3, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve3(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path36.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve3(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve3, reject) => {
        if (ii === pathExt.length)
          return resolve3(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve3(p + ext);
          }
          return resolve3(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path36.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which5;
    which5.sync = whichSync;
  }
});

// src/util/platform.ts
var platform_exports = {};
__export(platform_exports, {
  OS: () => OS,
  OperatingSystem: () => OperatingSystem,
  Platform: () => Platform,
  globals: () => globals,
  isLinux: () => isLinux,
  isMacintosh: () => isMacintosh,
  isNative: () => isNative,
  isWeb: () => isWeb,
  isWindows: () => isWindows2,
  language: () => language,
  platform: () => platform
});
var _isWindows, _isMacintosh, _isLinux, _isNative, _isWeb, language, Platform, _platform, isWindows2, isMacintosh, isLinux, isNative, isWeb, platform, _globals, globals, OperatingSystem, OS;
var init_platform = __esm({
  "src/util/platform.ts"() {
    _isWindows = false;
    _isMacintosh = false;
    _isLinux = false;
    _isNative = false;
    _isWeb = false;
    language = "en";
    if (typeof process === "object" && typeof process.nextTick === "function" && typeof process.platform === "string") {
      _isWindows = process.platform === "win32";
      _isMacintosh = process.platform === "darwin";
      _isLinux = process.platform === "linux";
      _isNative = true;
    }
    (function(Platform2) {
      Platform2[Platform2["Web"] = 0] = "Web";
      Platform2[Platform2["Mac"] = 1] = "Mac";
      Platform2[Platform2["Linux"] = 2] = "Linux";
      Platform2[Platform2["Windows"] = 3] = "Windows";
    })(Platform || (Platform = {}));
    _platform = 0;
    if (_isNative) {
      if (_isMacintosh) {
        _platform = 1;
      } else if (_isWindows) {
        _platform = 3;
      } else if (_isLinux) {
        _platform = 2;
      }
    }
    isWindows2 = _isWindows;
    isMacintosh = _isMacintosh;
    isLinux = _isLinux;
    isNative = _isNative;
    isWeb = _isWeb;
    platform = _platform;
    _globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
    globals = _globals;
    (function(OperatingSystem2) {
      OperatingSystem2[OperatingSystem2["Windows"] = 1] = "Windows";
      OperatingSystem2[OperatingSystem2["Macintosh"] = 2] = "Macintosh";
      OperatingSystem2[OperatingSystem2["Linux"] = 3] = "Linux";
    })(OperatingSystem || (OperatingSystem = {}));
    OS = _isMacintosh ? 2 : _isWindows ? 1 : 3;
  }
});

// src/util/index.ts
function isMarkdown(content) {
  if (import_vscode_languageserver_protocol.MarkupContent.is(content) && content.kind == import_vscode_languageserver_protocol.MarkupKind.Markdown) {
    return true;
  }
  return false;
}
function wait(ms) {
  return new Promise((resolve3) => {
    setTimeout(() => {
      resolve3(void 0);
    }, ms);
  });
}
function waitNextTick(fn) {
  return new Promise((resolve3) => {
    process.nextTick(() => {
      fn();
      resolve3(void 0);
    });
  });
}
function getUri(fullpath, id, buftype, isCygwin) {
  if (!fullpath)
    return `untitled:${id}`;
  if (isWindows2 && !isCygwin && !fullpath.startsWith("jdt://"))
    fullpath = import_path.default.win32.normalize(fullpath);
  if (import_path.default.isAbsolute(fullpath))
    return URI.file(fullpath).toString();
  if (import_isuri.default.isValid(fullpath))
    return URI.parse(fullpath).toString();
  if (buftype != "")
    return `${buftype}:${id}`;
  return `unknown:${id}`;
}
function disposeAll(disposables) {
  while (disposables.length) {
    const item = disposables.pop();
    if (item) {
      item.dispose();
    }
  }
}
function executable(command) {
  try {
    import_which.default.sync(command);
  } catch (e) {
    return false;
  }
  return true;
}
function runCommand(cmd, opts = {}, timeout) {
  if (!isWindows2) {
    opts.shell = opts.shell || process.env.SHELL;
  }
  opts.maxBuffer = 500 * 1024;
  return new Promise((resolve3, reject) => {
    let timer;
    if (timeout) {
      timer = setTimeout(() => {
        reject(new Error(`timeout after ${timeout}s`));
      }, timeout * 1e3);
    }
    (0, import_child_process.exec)(cmd, opts, (err, stdout, stderr) => {
      if (timer)
        clearTimeout(timer);
      if (err) {
        reject(new Error(`exited with ${err.code}
${err}
${stderr}`));
        return;
      }
      resolve3(stdout);
    });
  });
}
function watchFile(filepath, onChange) {
  let callback = (0, import_debounce.default)(onChange, 100);
  try {
    let watcher = import_fs.default.watch(filepath, {
      persistent: true,
      recursive: false,
      encoding: "utf8"
    }, () => {
      callback();
    });
    return import_vscode_languageserver_protocol.Disposable.create(() => {
      callback.clear();
      watcher.close();
    });
  } catch (e) {
    return import_vscode_languageserver_protocol.Disposable.create(() => {
      callback.clear();
    });
  }
}
function isRunning(pid) {
  try {
    let res = process.kill(pid, 0);
    return res == true;
  } catch (e) {
    return e.code === "EPERM";
  }
}
function getKeymapModifier(mode) {
  if (mode == "n" || mode == "o" || mode == "x" || mode == "v")
    return "<C-U>";
  if (mode == "i")
    return "<C-o>";
  if (mode == "s")
    return "<Esc>";
  return "";
}
function concurrent(arr, fn, limit = 3) {
  if (arr.length == 0)
    return Promise.resolve();
  let finished = 0;
  let total = arr.length;
  let remain = arr.slice();
  return new Promise((resolve3) => {
    let run = (val) => {
      let cb = () => {
        finished = finished + 1;
        if (finished == total) {
          resolve3();
        } else if (remain.length) {
          let next = remain.shift();
          run(next);
        }
      };
      fn(val).then(cb, cb);
    };
    for (let i = 0; i < Math.min(limit, remain.length); i++) {
      let val = remain.shift();
      run(val);
    }
  });
}
var import_child_process, import_debounce, import_fs, import_isuri, import_path, import_vscode_languageserver_protocol, import_which, logger, CONFIG_FILE_NAME;
var init_util = __esm({
  "src/util/index.ts"() {
    import_child_process = __toModule(require("child_process"));
    import_debounce = __toModule(require_debounce());
    import_fs = __toModule(require("fs"));
    import_isuri = __toModule(require_isuri());
    import_path = __toModule(require("path"));
    import_vscode_languageserver_protocol = __toModule(require_main2());
    init_esm2();
    import_which = __toModule(require_which());
    init_platform();
    logger = require_logger2()("util-index");
    CONFIG_FILE_NAME = "coc-settings.json";
  }
});

// src/util/is.ts
function vimCompleteItem(value) {
  return value && typeof value.word === "string";
}
function boolean(value) {
  return typeof value === "boolean";
}
function string(value) {
  return typeof value === "string";
}
function number(value) {
  return typeof value === "number";
}
function func(value) {
  return typeof value == "function";
}
function objectLiteral(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function emptyObject(obj) {
  if (!objectLiteral(obj)) {
    return false;
  }
  for (let key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
var hasOwnProperty;
var init_is = __esm({
  "src/util/is.ts"() {
    hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// src/util/object.ts
function isEmpty(obj) {
  if (!obj)
    return true;
  if (Array.isArray(obj))
    return obj.length == 0;
  return Object.keys(obj).length == 0;
}
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.keys(obj).forEach((key) => {
    if (obj[key] && typeof obj[key] === "object") {
      result[key] = deepClone(obj[key]);
    } else {
      result[key] = obj[key];
    }
  });
  return result;
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    let obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key in obj2) {
      if (_hasOwnProperty.call(obj2, key)) {
        let prop = obj2[key];
        if (typeof prop === "object" && !Object.isFrozen(prop)) {
          stack.push(prop);
        }
      }
    }
  }
  return obj;
}
function mixin(destination, source, overwrite = true) {
  if (!objectLiteral(destination)) {
    return source;
  }
  if (objectLiteral(source)) {
    Object.keys(source).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (objectLiteral(destination[key]) && objectLiteral(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }
  return destination;
}
function equals(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
var _hasOwnProperty;
var init_object = __esm({
  "src/util/object.ts"() {
    init_is();
    _hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// src/events.ts
var import_vscode_languageserver_protocol2, logger2, Events, events_default;
var init_events = __esm({
  "src/events.ts"() {
    import_vscode_languageserver_protocol2 = __toModule(require_main2());
    init_util();
    init_object();
    logger2 = require_logger2()("events");
    Events = class {
      constructor() {
        this.handlers = new Map();
        this._lastChange = 0;
        this._insertMode = false;
        this._pumAlignTop = false;
      }
      get cursor() {
        return this._cursor;
      }
      get pumAlignTop() {
        return this._pumAlignTop;
      }
      get insertMode() {
        return this._insertMode;
      }
      get lastChangeTs() {
        return this._lastChange;
      }
      async fire(event, args) {
        let cbs = this.handlers.get(event);
        if (event == "InsertEnter") {
          this._insertMode = true;
        } else if (event == "InsertLeave") {
          this._insertMode = false;
        } else if (!this._insertMode && (event == "CursorHoldI" || event == "CursorMovedI")) {
          this._insertMode = true;
          void this.fire("InsertEnter", [args[0]]);
        } else if (this._insertMode && (event == "CursorHold" || event == "CursorMoved")) {
          this._insertMode = false;
          this.fire("InsertLeave", [args[0]]).logError();
        }
        if (event == "MenuPopupChanged") {
          this._pumAlignTop = args[1] > args[0].row;
        }
        if (event == "InsertCharPre") {
          this._latestInsert = { bufnr: args[1], character: args[0], timestamp: Date.now() };
        }
        if (event == "TextChanged") {
          this._lastChange = Date.now();
        }
        if (event == "TextChangedI" || event == "TextChangedP") {
          this._lastChange = Date.now();
          if (this._latestInsert) {
            let insert = this._latestInsert;
            this._latestInsert = void 0;
            if (insert.bufnr == args[0] && Date.now() - insert.timestamp < 200 && args[1].pre.length) {
              let character = args[1].pre.slice(-1);
              process.nextTick(() => {
                void this.fire("TextInsert", [...args, character]);
              });
            }
          }
        }
        if (event == "CursorMoved" || event == "CursorMovedI") {
          let cursor = {
            bufnr: args[0],
            lnum: args[1][0],
            col: args[1][1],
            insert: event == "CursorMovedI"
          };
          if (this._cursor && equals(this._cursor, cursor))
            return;
          this._cursor = cursor;
        }
        if (cbs) {
          try {
            await Promise.all(cbs.map((fn) => fn(args)));
          } catch (e) {
            if (e.message && e.message.indexOf("transport disconnected") == -1)
              return;
            logger2.error(`Error on event: ${event}`, e.stack);
          }
        }
      }
      on(event, handler, thisArg, disposables) {
        if (Array.isArray(event)) {
          let arr = disposables || [];
          for (let ev of event) {
            this.on(ev, handler, thisArg, arr);
          }
          return import_vscode_languageserver_protocol2.Disposable.create(() => {
            disposeAll(arr);
          });
        } else {
          let arr = this.handlers.get(event) || [];
          let stack = Error().stack;
          let wrappedhandler = (args) => new Promise((resolve3, reject) => {
            let timer;
            try {
              Promise.resolve(handler.apply(thisArg || null, args)).then(() => {
                if (timer)
                  clearTimeout(timer);
                resolve3(void 0);
              }, (e) => {
                if (timer)
                  clearTimeout(timer);
                reject(e);
              });
              timer = setTimeout(() => {
                logger2.warn(`Handler of ${event} blocked more than 2s:`, stack);
              }, 2e3);
            } catch (e) {
              reject(e);
            }
          });
          arr.push(wrappedhandler);
          this.handlers.set(event, arr);
          let disposable = import_vscode_languageserver_protocol2.Disposable.create(() => {
            let idx = arr.indexOf(wrappedhandler);
            if (idx !== -1) {
              arr.splice(idx, 1);
            }
          });
          if (disposables) {
            disposables.push(disposable);
          }
          return disposable;
        }
      }
    };
    events_default = new Events();
  }
});

// node_modules/marked/src/defaults.js
var require_defaults = __commonJS({
  "node_modules/marked/src/defaults.js"(exports2, module2) {
    function getDefaults() {
      return {
        baseUrl: null,
        breaks: false,
        extensions: null,
        gfm: true,
        headerIds: true,
        headerPrefix: "",
        highlight: null,
        langPrefix: "language-",
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }
    function changeDefaults(newDefaults) {
      module2.exports.defaults = newDefaults;
    }
    module2.exports = {
      defaults: getDefaults(),
      getDefaults,
      changeDefaults
    };
  }
});

// node_modules/marked/src/helpers.js
var require_helpers = __commonJS({
  "node_modules/marked/src/helpers.js"(exports2, module2) {
    var escapeTest = /[&<>"']/;
    var escapeReplace = /[&<>"']/g;
    var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html;
    }
    var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape2(html) {
      return html.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === "colon")
          return ":";
        if (n.charAt(0) === "#") {
          return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return "";
      });
    }
    var caret = /(^|[^\[])\^/g;
    function edit2(regex, opt) {
      regex = regex.source || regex;
      opt = opt || "";
      const obj = {
        replace: (name2, val) => {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name2, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    var nonWordAndColonTest = /[^\w:]/g;
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        let prot;
        try {
          prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    var baseUrls = {};
    var justDomain = /^[^:]+:\/*[^/]*$/;
    var protocol = /^([^:]+:)[\s\S]*$/;
    var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      const relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    var noopTest = { exec: function noopTest2() {
    } };
    function merge(obj) {
      let i = 1, target, key;
      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }
      return obj;
    }
    function splitCells(tableRow, count) {
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
        let escaped = false, curr = offset;
        while (--curr >= 0 && str[curr] === "\\")
          escaped = !escaped;
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      let i = 0;
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count)
          cells.push("");
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
        return "";
      }
      let suffLen = 0;
      while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.substr(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      const l = str.length;
      let level = 0, i = 0;
      for (; i < l; i++) {
        if (str[i] === "\\") {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
    }
    function repeatString(pattern, count) {
      if (count < 1) {
        return "";
      }
      let result = "";
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }
    module2.exports = {
      escape,
      unescape: unescape2,
      edit: edit2,
      cleanUrl,
      resolveUrl,
      noopTest,
      merge,
      splitCells,
      rtrim,
      findClosingBracket,
      checkSanitizeDeprecation,
      repeatString
    };
  }
});

// node_modules/marked/src/Tokenizer.js
var require_Tokenizer = __commonJS({
  "node_modules/marked/src/Tokenizer.js"(exports2, module2) {
    var { defaults: defaults2 } = require_defaults();
    var {
      rtrim,
      splitCells,
      escape,
      findClosingBracket
    } = require_helpers();
    function outputLink(cap, link, raw) {
      const href = link.href;
      const title = link.title ? escape(link.title) : null;
      const text = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        return {
          type: "link",
          raw,
          href,
          title,
          text
        };
      } else {
        return {
          type: "image",
          raw,
          href,
          title,
          text: escape(text)
        };
      }
    }
    function indentCodeCompensation(raw, text) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      const indentToCode = matchIndentToCode[1];
      return text.split("\n").map((node) => {
        const matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    module2.exports = class Tokenizer {
      constructor(options) {
        this.options = options || defaults2;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap) {
          if (cap[0].length > 1) {
            return {
              type: "space",
              raw: cap[0]
            };
          }
          return { raw: "\n" };
        }
      }
      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text = cap[2].trim();
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text
          };
        }
      }
      nptable(src) {
        const cap = this.rules.block.nptable.exec(src);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, "")),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : [],
            raw: cap[0]
          };
          if (item.header.length === item.align.length) {
            let l = item.align.length;
            let i;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.cells.length;
            for (i = 0; i < l; i++) {
              item.cells[i] = splitCells(item.cells[i], item.header.length);
            }
            return item;
          }
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ *> ?/gm, "");
          return {
            type: "blockquote",
            raw: cap[0],
            text
          };
        }
      }
      list(src) {
        const cap = this.rules.block.list.exec(src);
        if (cap) {
          let raw = cap[0];
          const bull = cap[2];
          const isordered = bull.length > 1;
          const list2 = {
            type: "list",
            raw,
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          const itemMatch = cap[0].match(this.rules.block.item);
          let next = false, item, space, bcurr, bnext, addBack, loose, istask, ischecked, endMatch;
          let l = itemMatch.length;
          bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);
          for (let i = 0; i < l; i++) {
            item = itemMatch[i];
            raw = item;
            if (!this.options.pedantic) {
              endMatch = item.match(new RegExp("\\n\\s*\\n {0," + (bcurr[0].length - 1) + "}\\S"));
              if (endMatch) {
                addBack = item.length - endMatch.index + itemMatch.slice(i + 1).join("\n").length;
                list2.raw = list2.raw.substring(0, list2.raw.length - addBack);
                item = item.substring(0, endMatch.index);
                raw = item;
                l = i + 1;
              }
            }
            if (i !== l - 1) {
              bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);
              if (!this.options.pedantic ? bnext[1].length >= bcurr[0].length || bnext[1].length > 3 : bnext[1].length > bcurr[1].length) {
                itemMatch.splice(i, 2, itemMatch[i] + (!this.options.pedantic && bnext[1].length < bcurr[0].length && !itemMatch[i].match(/\n$/) ? "" : "\n") + itemMatch[i + 1]);
                i--;
                l--;
                continue;
              } else if (!this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {
                addBack = itemMatch.slice(i + 1).join("\n").length;
                list2.raw = list2.raw.substring(0, list2.raw.length - addBack);
                i = l - 1;
              }
              bcurr = bnext;
            }
            space = item.length;
            item = item.replace(/^ *([*+-]|\d+[.)]) ?/, "");
            if (~item.indexOf("\n ")) {
              space -= item.length;
              item = !this.options.pedantic ? item.replace(new RegExp("^ {1," + space + "}", "gm"), "") : item.replace(/^ {1,4}/gm, "");
            }
            item = rtrim(item, "\n");
            if (i !== l - 1) {
              raw = raw + "\n";
            }
            loose = next || /\n\n(?!\s*$)/.test(raw);
            if (i !== l - 1) {
              next = raw.slice(-2) === "\n\n";
              if (!loose)
                loose = next;
            }
            if (loose) {
              list2.loose = true;
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.test(item);
              ischecked = void 0;
              if (istask) {
                ischecked = item[1] !== " ";
                item = item.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: istask,
              checked: ischecked,
              loose,
              text: item
            });
          }
          return list2;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          return {
            type: this.options.sanitize ? "paragraph" : "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
          };
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3])
            cap[3] = cap[3].substring(1, cap[3].length - 1);
          const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          return {
            type: "def",
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, "")),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            let l = item.align.length;
            let i;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.cells.length;
            for (i = 0; i < l; i++) {
              item.cells[i] = splitCells(item.cells[i].replace(/^ *\| *| *\| *$/g, ""), item.header.length);
            }
            return item;
          }
        }
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1]
          };
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          return {
            type: "paragraph",
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1]
          };
        }
      }
      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0]
          };
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      }
      tag(src, inLink, inRawBlock) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!inLink && /^<a /i.test(cap[0])) {
            inLink = true;
          } else if (inLink && /^<\/a>/i.test(cap[0])) {
            inLink = false;
          }
          if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = true;
          } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink,
            inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf("!") === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link) {
              href = link[1];
              title = link[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0]);
        }
      }
      reflink(src, links2) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links2[link.toLowerCase()];
          if (!link || !link.href) {
            const text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0]);
        }
      }
      emStrong(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match)
          return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
          return;
        const nextChar = match[1] || match[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          const lLength = match[0].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim)
              continue;
            rLength = rDelim.length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            if (Math.min(lLength, rLength) % 2) {
              return {
                type: "em",
                raw: src.slice(0, lLength + match.index + rLength + 1),
                text: src.slice(1, lLength + match.index + rLength)
              };
            }
            return {
              type: "strong",
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: src.slice(2, lLength + match.index + rLength - 1)
            };
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2]
          };
        }
      }
      autolink(src, mangle) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      url(src, mangle) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + text;
            } else {
              href = text;
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      inlineText(src, inRawBlock, smartypants) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
          } else {
            text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      }
    };
  }
});

// node_modules/marked/src/rules.js
var require_rules = __commonJS({
  "node_modules/marked/src/rules.js"(exports2, module2) {
    var {
      noopTest,
      edit: edit2,
      merge
    } = require_helpers();
    var block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
      nptable: noopTest,
      table: noopTest,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit2(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
    block.item = edit2(block.item, "gm").replace(/bull/g, block.bullet).getRegex();
    block.listItemStart = edit2(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit2(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit2(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit2(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit2(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = merge({}, block);
    block.gfm = merge({}, block.normal, {
      nptable: "^ *([^|\\n ].*\\|.*)\\n {0,3}([-:]+ *\\|[-| :]*)(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
      table: "^ *\\|(.+)\\n {0,3}\\|?( *[-:]+[-| :]*)(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    });
    block.gfm.nptable = edit2(block.gfm.nptable).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.table = edit2(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = merge({}, block.normal, {
      html: edit2(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      paragraph: edit2(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    var inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
      nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        rDelimAst: /\_\_[^_*]*?\*[^_*]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /\*\*[^_*]*?\_[^_*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit2(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline.escapedEmSt = /\\\*|\\_/g;
    inline._comment = edit2(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit2(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit2(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit2(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit2(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit2(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit2(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit2(inline.reflink).replace("label", inline._label).getRegex();
    inline.reflinkSearch = edit2(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = merge({}, inline);
    inline.pedantic = merge({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit2(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit2(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = merge({}, inline.normal, {
      escape: edit2(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    inline.gfm.url = edit2(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = merge({}, inline.gfm, {
      br: edit2(inline.br).replace("{2,}", "*").getRegex(),
      text: edit2(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    module2.exports = {
      block,
      inline
    };
  }
});

// node_modules/marked/src/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/marked/src/Lexer.js"(exports2, module2) {
    var Tokenizer = require_Tokenizer();
    var { defaults: defaults2 } = require_defaults();
    var { block, inline } = require_rules();
    var { repeatString } = require_helpers();
    function smartypants(text) {
      return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
    }
    function mangle(text) {
      let out = "", i, ch;
      const l = text.length;
      for (i = 0; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    module2.exports = class Lexer {
      constructor(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || defaults2;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      static get rules() {
        return {
          block,
          inline
        };
      }
      static lex(src, options) {
        const lexer = new Lexer(options);
        return lexer.lex(src);
      }
      static lexInline(src, options) {
        const lexer = new Lexer(options);
        return lexer.inlineTokens(src);
      }
      lex(src) {
        src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
        this.blockTokens(src, this.tokens, true);
        this.inline(this.tokens);
        return this.tokens;
      }
      blockTokens(src, tokens = [], top = true) {
        if (this.options.pedantic) {
          src = src.replace(/^ +$/gm, "");
        }
        let token, i, l, lastToken, cutSrc, lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
            if (token = extTokenizer.call(this, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.type) {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.nptable(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.blockTokens(token.text, [], top);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            l = token.items.length;
            for (i = 0; i < l; i++) {
              token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
            }
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (top && (token = this.tokenizer.def(src))) {
            src = src.substring(token.raw.length);
            if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call(this, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
      inline(tokens) {
        let i, j, k, l2, row, token;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          switch (token.type) {
            case "paragraph":
            case "text":
            case "heading": {
              token.tokens = [];
              this.inlineTokens(token.text, token.tokens);
              break;
            }
            case "table": {
              token.tokens = {
                header: [],
                cells: []
              };
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                token.tokens.header[j] = [];
                this.inlineTokens(token.header[j], token.tokens.header[j]);
              }
              l2 = token.cells.length;
              for (j = 0; j < l2; j++) {
                row = token.cells[j];
                token.tokens.cells[j] = [];
                for (k = 0; k < row.length; k++) {
                  token.tokens.cells[j][k] = [];
                  this.inlineTokens(row[k], token.tokens.cells[j][k]);
                }
              }
              break;
            }
            case "blockquote": {
              this.inline(token.tokens);
              break;
            }
            case "list": {
              l2 = token.items.length;
              for (j = 0; j < l2; j++) {
                this.inline(token.items[j].tokens);
              }
              break;
            }
            default: {
            }
          }
        }
        return tokens;
      }
      inlineTokens(src, tokens = [], inLink = false, inRawBlock = false) {
        let token, lastToken, cutSrc;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links2 = Object.keys(this.tokens.links);
          if (links2.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links2.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
            if (token = extTokenizer.call(this, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
            src = src.substring(token.raw.length);
            inLink = token.inLink;
            inRawBlock = token.inRawBlock;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            if (token.type === "link") {
              token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
            }
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (token.type === "link") {
              token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
              tokens.push(token);
            } else if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call(this, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc, inRawBlock, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    };
  }
});

// node_modules/marked/src/Renderer.js
var require_Renderer = __commonJS({
  "node_modules/marked/src/Renderer.js"(exports2, module2) {
    var { defaults: defaults2 } = require_defaults();
    var {
      cleanUrl,
      escape
    } = require_helpers();
    module2.exports = class Renderer {
      constructor(options) {
        this.options = options || defaults2;
      }
      code(code, infostring, escaped) {
        const lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }
        code = code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      blockquote(quote) {
        return "<blockquote>\n" + quote + "</blockquote>\n";
      }
      html(html) {
        return html;
      }
      heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text + "</h" + level + ">\n";
      }
      hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }
      list(body, ordered, start) {
        const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }
      listitem(text) {
        return "<li>" + text + "</li>\n";
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }
      paragraph(text) {
        return "<p>" + text + "</p>\n";
      }
      table(header, body) {
        if (body)
          body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }
      tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
        return tag + content + "</" + type + ">\n";
      }
      strong(text) {
        return "<strong>" + text + "</strong>";
      }
      em(text) {
        return "<em>" + text + "</em>";
      }
      codespan(text) {
        return "<code>" + text + "</code>";
      }
      br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }
      del(text) {
        return "<del>" + text + "</del>";
      }
      link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<a href="' + escape(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      }
      image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      }
      text(text) {
        return text;
      }
    };
  }
});

// node_modules/marked/src/TextRenderer.js
var require_TextRenderer = __commonJS({
  "node_modules/marked/src/TextRenderer.js"(exports2, module2) {
    module2.exports = class TextRenderer {
      strong(text) {
        return text;
      }
      em(text) {
        return text;
      }
      codespan(text) {
        return text;
      }
      del(text) {
        return text;
      }
      html(text) {
        return text;
      }
      text(text) {
        return text;
      }
      link(href, title, text) {
        return "" + text;
      }
      image(href, title, text) {
        return "" + text;
      }
      br() {
        return "";
      }
    };
  }
});

// node_modules/marked/src/Slugger.js
var require_Slugger = __commonJS({
  "node_modules/marked/src/Slugger.js"(exports2, module2) {
    module2.exports = class Slugger {
      constructor() {
        this.seen = {};
      }
      serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }
      slug(value, options = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options.dryrun);
      }
    };
  }
});

// node_modules/marked/src/Parser.js
var require_Parser = __commonJS({
  "node_modules/marked/src/Parser.js"(exports2, module2) {
    var Renderer2 = require_Renderer();
    var TextRenderer = require_TextRenderer();
    var Slugger = require_Slugger();
    var { defaults: defaults2 } = require_defaults();
    var {
      unescape: unescape2
    } = require_helpers();
    module2.exports = class Parser {
      constructor(options) {
        this.options = options || defaults2;
        this.options.renderer = this.options.renderer || new Renderer2();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }
      static parse(tokens, options) {
        const parser2 = new Parser(options);
        return parser2.parse(tokens);
      }
      static parseInline(tokens, options) {
        const parser2 = new Parser(options);
        return parser2.parseInline(tokens);
      }
      parse(tokens, top = true) {
        let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call(this, token);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape2(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), { header: true, align: token.align[j] });
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token.cells.length;
              for (j = 0; j < l2; j++) {
                row = token.tokens.cells[j];
                cell = "";
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k]), { header: false, align: token.align[k] });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = "";
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "text") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === "text") {
                token = tokens[++i];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = "", i, token, ret;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call(this, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    };
  }
});

// node_modules/marked/src/marked.js
var require_marked = __commonJS({
  "node_modules/marked/src/marked.js"(exports2, module2) {
    var Lexer = require_Lexer();
    var Parser = require_Parser();
    var Tokenizer = require_Tokenizer();
    var Renderer2 = require_Renderer();
    var TextRenderer = require_TextRenderer();
    var Slugger = require_Slugger();
    var {
      merge,
      checkSanitizeDeprecation,
      escape
    } = require_helpers();
    var {
      getDefaults,
      changeDefaults,
      defaults: defaults2
    } = require_defaults();
    function marked2(src, opt, callback) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      opt = merge({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      if (callback) {
        const highlight = opt.highlight;
        let tokens;
        try {
          tokens = Lexer.lex(src, opt);
        } catch (e) {
          return callback(e);
        }
        const done = function(err) {
          let out;
          if (!err) {
            try {
              if (opt.walkTokens) {
                marked2.walkTokens(tokens, opt.walkTokens);
              }
              out = Parser.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
          }
          opt.highlight = highlight;
          return err ? callback(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length)
          return done();
        let pending = 0;
        marked2.walkTokens(tokens, function(token) {
          if (token.type === "code") {
            pending++;
            setTimeout(() => {
              highlight(token.text, token.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done();
        }
        return;
      }
      try {
        const tokens = Lexer.lex(src, opt);
        if (opt.walkTokens) {
          marked2.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parse(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    }
    marked2.options = marked2.setOptions = function(opt) {
      merge(marked2.defaults, opt);
      changeDefaults(marked2.defaults);
      return marked2;
    };
    marked2.getDefaults = getDefaults;
    marked2.defaults = defaults2;
    marked2.use = function(...args) {
      const opts = merge({}, ...args);
      const extensions = marked2.defaults.extensions || { renderers: {}, childTokens: {} };
      let hasExtensions;
      args.forEach((pack) => {
        if (pack.extensions) {
          hasExtensions = true;
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
        }
        if (pack.renderer) {
          const renderer = marked2.defaults.renderer || new Renderer2();
          for (const prop in pack.renderer) {
            const prevRenderer = renderer[prop];
            renderer[prop] = (...args2) => {
              let ret = pack.renderer[prop].apply(renderer, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args2);
              }
              return ret;
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = marked2.defaults.tokenizer || new Tokenizer();
          for (const prop in pack.tokenizer) {
            const prevTokenizer = tokenizer[prop];
            tokenizer[prop] = (...args2) => {
              let ret = pack.tokenizer[prop].apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.walkTokens) {
          const walkTokens = marked2.defaults.walkTokens;
          opts.walkTokens = (token) => {
            pack.walkTokens.call(this, token);
            if (walkTokens) {
              walkTokens(token);
            }
          };
        }
        if (hasExtensions) {
          opts.extensions = extensions;
        }
        marked2.setOptions(opts);
      });
    };
    marked2.walkTokens = function(tokens, callback) {
      for (const token of tokens) {
        callback(token);
        switch (token.type) {
          case "table": {
            for (const cell of token.tokens.header) {
              marked2.walkTokens(cell, callback);
            }
            for (const row of token.tokens.cells) {
              for (const cell of row) {
                marked2.walkTokens(cell, callback);
              }
            }
            break;
          }
          case "list": {
            marked2.walkTokens(token.items, callback);
            break;
          }
          default: {
            if (marked2.defaults.extensions && marked2.defaults.extensions.childTokens && marked2.defaults.extensions.childTokens[token.type]) {
              marked2.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                marked2.walkTokens(token[childTokens], callback);
              });
            } else if (token.tokens) {
              marked2.walkTokens(token.tokens, callback);
            }
          }
        }
      }
    };
    marked2.parseInline = function(src, opt) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      opt = merge({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      try {
        const tokens = Lexer.lexInline(src, opt);
        if (opt.walkTokens) {
          marked2.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parseInline(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    };
    marked2.Parser = Parser;
    marked2.parser = Parser.parse;
    marked2.Renderer = Renderer2;
    marked2.TextRenderer = TextRenderer;
    marked2.Lexer = Lexer;
    marked2.lexer = Lexer.lex;
    marked2.Tokenizer = Tokenizer;
    marked2.Slugger = Slugger;
    marked2.parse = marked2;
    module2.exports = marked2;
  }
});

// node_modules/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/colors/lib/styles.js"(exports2, module2) {
    var styles3 = {};
    module2["exports"] = styles3;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style2 = styles3[key] = [];
      style2.open = "[" + val[0] + "m";
      style2.close = "[" + val[1] + "m";
    });
  }
});

// node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/colors/lib/system/supports-colors.js"(exports2, module2) {
    var argv = process.argv;
    module2.exports = function() {
      if (argv.indexOf("--no-color") !== -1 || argv.indexOf("--color=false") !== -1) {
        return false;
      }
      if (argv.indexOf("--color") !== -1 || argv.indexOf("--color=true") !== -1 || argv.indexOf("--color=always") !== -1) {
        return true;
      }
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
      if (process.platform === "win32") {
        return true;
      }
      if ("COLORTERM" in process.env) {
        return true;
      }
      if (process.env.TERM === "dumb") {
        return false;
      }
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
      return false;
    }();
  }
});

// node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      }, all = [].concat(soul.up, soul.down, soul.mid), zalgo2 = {};
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function is_char(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "", counts, l;
        options2 = options2 || {};
        options2["up"] = options2["up"] || true;
        options2["mid"] = options2["mid"] || true;
        options2["down"] = options2["down"] || true;
        options2["size"] = options2["size"] || "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (is_char(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.min = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.min = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text);
    };
  }
});

// node_modules/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/colors/lib/maps/america.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    }();
  }
});

// node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/colors/lib/maps/zebra.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  }
});

// node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/colors/lib/maps/rainbow.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    }();
  }
});

// node_modules/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/colors/lib/maps/random.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      var available = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
      };
    }();
  }
});

// node_modules/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    colors.supportsColor = require_supports_colors();
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor;
    }
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style2) {
      return ansiStyles[style2].open + str + ansiStyles[style2].close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles3 = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles3);
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!colors.enabled || !str) {
        return str;
      }
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
      return str;
    }
    function applyTheme(theme) {
      for (var style2 in theme) {
        (function(style3) {
          colors[style3] = function(str) {
            return colors[theme[style3]](str);
          };
        })(style2);
      }
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        try {
          colors.themes[theme] = require(theme);
          applyTheme(colors.themes[theme]);
          return colors.themes[theme];
        } catch (err) {
          console.log(err);
          return err;
        }
      } else {
        applyTheme(theme);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles3).forEach(function(name2) {
        ret[name2] = {
          get: function() {
            return build([name2]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split(""), i = 0;
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america();
    colors.maps.zebra = require_zebra();
    colors.maps.rainbow = require_rainbow();
    colors.maps.random = require_random();
    for (var map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    defineProps(colors, init());
  }
});

// node_modules/colors/safe.js
var require_safe = __commonJS({
  "node_modules/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/cli-table/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/cli-table/lib/utils.js"(exports2) {
    exports2.repeat = function(str, times) {
      return Array(times + 1).join(str);
    };
    exports2.pad = function(str, len, pad2, dir) {
      if (len + 1 >= str.length)
        switch (dir) {
          case "left":
            str = Array(len + 1 - str.length).join(pad2) + str;
            break;
          case "both":
            var right = Math.ceil((padlen = len - str.length) / 2);
            var left = padlen - right;
            str = Array(left + 1).join(pad2) + str + Array(right + 1).join(pad2);
            break;
          default:
            str = str + Array(len + 1 - str.length).join(pad2);
        }
      ;
      return str;
    };
    exports2.truncate = function(str, length, chr) {
      chr = chr || "\u2026";
      return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
    };
    function options(defaults2, opts) {
      for (var p in opts) {
        if (p === "__proto__" || p === "constructor" || p === "prototype") {
          continue;
        }
        if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
          defaults2[p] = defaults2[p] || {};
          options(defaults2[p], opts[p]);
        } else {
          defaults2[p] = opts[p];
        }
      }
      return defaults2;
    }
    exports2.options = options;
    exports2.strlen = function(str) {
      var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
      var stripped = ("" + str).replace(code, "");
      var split = stripped.split("\n");
      return split.reduce(function(memo, s) {
        return s.length > memo ? s.length : memo;
      }, 0);
    };
  }
});

// node_modules/cli-table/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/cli-table/lib/index.js"(exports2, module2) {
    var colors = require_safe();
    var utils = require_utils2();
    var repeat2 = utils.repeat;
    var truncate = utils.truncate;
    var pad2 = utils.pad;
    function Table2(options) {
      this.options = utils.options({
        chars: {
          "top": "\u2500",
          "top-mid": "\u252C",
          "top-left": "\u250C",
          "top-right": "\u2510",
          "bottom": "\u2500",
          "bottom-mid": "\u2534",
          "bottom-left": "\u2514",
          "bottom-right": "\u2518",
          "left": "\u2502",
          "left-mid": "\u251C",
          "mid": "\u2500",
          "mid-mid": "\u253C",
          "right": "\u2502",
          "right-mid": "\u2524",
          "middle": "\u2502"
        },
        truncate: "\u2026",
        colWidths: [],
        colAligns: [],
        style: {
          "padding-left": 1,
          "padding-right": 1,
          head: ["red"],
          border: ["grey"],
          compact: false
        },
        head: []
      }, options);
    }
    Table2.prototype.__proto__ = Array.prototype;
    Table2.prototype.__defineGetter__("width", function() {
      var str = this.toString().split("\n");
      if (str.length)
        return str[0].length;
      return 0;
    });
    Table2.prototype.render;
    Table2.prototype.toString = function() {
      var ret = "", options = this.options, style2 = options.style, head = options.head, chars = options.chars, truncater = options.truncate, colWidths = options.colWidths || new Array(this.head.length), totalWidth = 0;
      if (!head.length && !this.length)
        return "";
      if (!colWidths.length) {
        var all_rows = this.slice(0);
        if (head.length) {
          all_rows = all_rows.concat([head]);
        }
        ;
        all_rows.forEach(function(cells) {
          if (typeof cells === "object" && cells.length) {
            extractColumnWidths(cells);
          } else {
            var header_cell = Object.keys(cells)[0], value_cell = cells[header_cell];
            colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
            if (typeof value_cell === "object" && value_cell.length) {
              extractColumnWidths(value_cell, 1);
            } else {
              colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
            }
          }
        });
      }
      ;
      totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(function(a, b) {
        return a + b;
      })) + colWidths.length + 1;
      function extractColumnWidths(arr, offset) {
        var offset = offset || 0;
        arr.forEach(function(cell, i) {
          colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
        });
      }
      ;
      function get_width(obj) {
        return typeof obj == "object" && obj.width != void 0 ? obj.width : (typeof obj == "object" ? utils.strlen(obj.text) : utils.strlen(obj)) + (style2["padding-left"] || 0) + (style2["padding-right"] || 0);
      }
      function line(line2, left, right, intersection) {
        var width = 0, line2 = left + repeat2(line2, totalWidth - 2) + right;
        colWidths.forEach(function(w, i) {
          if (i == colWidths.length - 1)
            return;
          width += w + 1;
          line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
        });
        return applyStyles(options.style.border, line2);
      }
      ;
      function lineTop() {
        var l2 = line(chars.top, chars["top-left"] || chars.top, chars["top-right"] || chars.top, chars["top-mid"]);
        if (l2)
          ret += l2 + "\n";
      }
      ;
      function generateRow(items, style3) {
        var cells = [], max_height = 0;
        if (!Array.isArray(items) && typeof items === "object") {
          var key = Object.keys(items)[0], value = items[key], first_cell_head = true;
          if (Array.isArray(value)) {
            items = value;
            items.unshift(key);
          } else {
            items = [key, value];
          }
        }
        items.forEach(function(item, i) {
          var contents = item.toString().split("\n").reduce(function(memo, l2) {
            memo.push(string2(l2, i));
            return memo;
          }, []);
          var height = contents.length;
          if (height > max_height) {
            max_height = height;
          }
          ;
          cells.push({ contents, height });
        });
        var lines = new Array(max_height);
        cells.forEach(function(cell, i) {
          cell.contents.forEach(function(line2, j2) {
            if (!lines[j2]) {
              lines[j2] = [];
            }
            ;
            if (style3 || first_cell_head && i === 0 && options.style.head) {
              line2 = applyStyles(options.style.head, line2);
            }
            lines[j2].push(line2);
          });
          for (var j = cell.height, l2 = max_height; j < l2; j++) {
            if (!lines[j]) {
              lines[j] = [];
            }
            ;
            lines[j].push(string2("", i));
          }
        });
        var ret2 = "";
        lines.forEach(function(line2, index) {
          if (ret2.length > 0) {
            ret2 += "\n" + applyStyles(options.style.border, chars.left);
          }
          ret2 += line2.join(applyStyles(options.style.border, chars.middle)) + applyStyles(options.style.border, chars.right);
        });
        return applyStyles(options.style.border, chars.left) + ret2;
      }
      ;
      function applyStyles(styles3, subject) {
        if (!subject)
          return "";
        styles3.forEach(function(style3) {
          subject = colors[style3](subject);
        });
        return subject;
      }
      ;
      function string2(str, index) {
        var str = String(typeof str == "object" && str.text ? str.text : str), length = utils.strlen(str), width = colWidths[index] - (style2["padding-left"] || 0) - (style2["padding-right"] || 0), align = options.colAligns[index] || "left";
        return repeat2(" ", style2["padding-left"] || 0) + (length == width ? str : length < width ? pad2(str, width + (str.length - length), " ", align == "left" ? "right" : align == "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat2(" ", style2["padding-right"] || 0);
      }
      ;
      if (head.length) {
        lineTop();
        ret += generateRow(head, style2.head) + "\n";
      }
      if (this.length)
        this.forEach(function(cells, i) {
          if (!head.length && i == 0)
            lineTop();
          else {
            if (!style2.compact || i < !!head.length ? 1 : cells.length == 0) {
              var l2 = line(chars.mid, chars["left-mid"], chars["right-mid"], chars["mid-mid"]);
              if (l2)
                ret += l2 + "\n";
            }
          }
          if (cells.hasOwnProperty("length") && !cells.length) {
            return;
          } else {
            ret += generateRow(cells) + "\n";
          }
          ;
        });
      var l = line(chars.bottom, chars["bottom-left"] || chars.bottom, chars["bottom-right"] || chars.bottom, chars["bottom-mid"]);
      if (l)
        ret += l;
      else
        ret = ret.slice(0, -1);
      return ret;
    };
    module2.exports = Table2;
    module2.exports.version = "0.0.1";
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue2) => `[${38 + offset};2;${red};${green};${blue2}m`;
    function assembleStyles() {
      const codes = new Map();
      const styles3 = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.gray = styles3.color.blackBright;
      styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright;
      styles3.color.grey = styles3.color.blackBright;
      styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
      for (const [groupName, group2] of Object.entries(styles3)) {
        for (const [styleName, style2] of Object.entries(group2)) {
          styles3[styleName] = {
            open: `[${style2[0]}m`,
            close: `[${style2[1]}m`
          };
          group2[styleName] = styles3[styleName];
          codes.set(style2[0], style2[1]);
        }
        Object.defineProperty(styles3, groupName, {
          value: group2,
          enumerable: false
        });
      }
      Object.defineProperty(styles3, "codes", {
        value: codes,
        enumerable: false
      });
      styles3.color.close = "[39m";
      styles3.bgColor.close = "[49m";
      styles3.color.ansi256 = wrapAnsi256();
      styles3.color.ansi16m = wrapAnsi16m();
      styles3.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles3.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles3, {
        rgbToAnsi256: {
          value: (red, green, blue2) => {
            if (red === green && green === blue2) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue2 / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer2 = Number.parseInt(colorString, 16);
            return [
              integer2 >> 16 & 255,
              integer2 >> 8 & 255,
              integer2 & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// src/markdown/styles.ts
function gray(str) {
  return `${import_ansi_styles.default.gray.open}${str}${import_ansi_styles.default.gray.close}`;
}
function magenta(str) {
  return `${import_ansi_styles.default.magenta.open}${str}${import_ansi_styles.default.magenta.close}`;
}
function bold(str) {
  return `${import_ansi_styles.default.bold.open}${str}${import_ansi_styles.default.bold.close}`;
}
function underline(str) {
  return `${import_ansi_styles.default.underline.open}${str}${import_ansi_styles.default.underline.close}`;
}
function strikethrough(str) {
  return `${import_ansi_styles.default.strikethrough.open}${str}${import_ansi_styles.default.strikethrough.close}`;
}
function italic(str) {
  return `${import_ansi_styles.default.italic.open}${str}${import_ansi_styles.default.italic.close}`;
}
function yellow(str) {
  return `${import_ansi_styles.default.yellow.open}${str}${import_ansi_styles.default.yellow.close}`;
}
function blue(str) {
  return `${import_ansi_styles.default.blue.open}${str}${import_ansi_styles.default.blue.close}`;
}
var import_ansi_styles;
var init_styles = __esm({
  "src/markdown/styles.ts"() {
    import_ansi_styles = __toModule(require_ansi_styles());
  }
});

// src/markdown/renderer.ts
function fixHardReturn(text, reflow) {
  return reflow ? text.replace(HARD_RETURN, /\n/g) : text;
}
function sanitizeTab(tab, fallbackTab) {
  if (typeof tab === "number") {
    return new Array(tab + 1).join(" ");
  } else if (typeof tab === "string" && isAllowedTabString(tab)) {
    return tab;
  } else {
    return new Array(fallbackTab + 1).join(" ");
  }
}
function isAllowedTabString(str) {
  return TAB_ALLOWED_CHARACTERS.some(function(char) {
    return str.match("^(" + char + ")+$");
  });
}
function indentLines(indent, text) {
  return text.replace(/(^|\n)(.+)/g, "$1" + indent + "$2");
}
function indentify(indent, text) {
  if (!text)
    return text;
  return indent + text.split("\n").join("\n" + indent);
}
function fixNestedLists(body, indent) {
  let regex = new RegExp("(\\S(?: |  )?)((?:" + indent + ")+)(" + POINT_REGEX + "(?:.*)+)$", "gm");
  return body.replace(regex, "$1\n" + indent + "$2$3");
}
function toSpaces(str) {
  return " ".repeat(str.length);
}
function bulletPointLine(indent, line) {
  return isPointedLine(line, indent) ? line : toSpaces(BULLET_POINT) + line;
}
function bulletPointLines(lines, indent) {
  let transform = bulletPointLine.bind(null, indent);
  return lines.split("\n").filter(identity).map(transform).join("\n");
}
function numberedLine(indent, line, num) {
  return isPointedLine(line, indent) ? {
    num: num + 1,
    line: line.replace(BULLET_POINT, numberedPoint(num + 1))
  } : {
    num,
    line: toSpaces(numberedPoint(num)) + line
  };
}
function numberedLines(lines, indent) {
  let transform = numberedLine.bind(null, indent);
  let num = 0;
  return lines.split("\n").filter(identity).map((line) => {
    const numbered = transform(line, num);
    num = numbered.num;
    return numbered.line;
  }).join("\n");
}
function list(body, ordered, indent) {
  body = body.trim();
  body = ordered ? numberedLines(body, indent) : bulletPointLines(body, indent);
  return body;
}
function section(text) {
  return text + "\n\n";
}
function undoColon(str) {
  return str.replace(COLON_REPLACER_REGEXP, ":");
}
function generateTableRow(text, escape = null) {
  if (!text)
    return [];
  escape = escape || identity;
  let lines = escape(text).split("\n");
  let data = [];
  lines.forEach(function(line) {
    if (!line)
      return;
    let parsed = line.replace(TABLE_ROW_WRAP_REGEXP, "").split(TABLE_CELL_SPLIT);
    data.push(parsed.splice(0, parsed.length - 1));
  });
  return data;
}
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function unescapeEntities(html) {
  return html.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
}
function identity(str) {
  return str;
}
var import_cli_table, logger3, TABLE_CELL_SPLIT, TABLE_ROW_WRAP, TABLE_ROW_WRAP_REGEXP, COLON_REPLACER, COLON_REPLACER_REGEXP, TAB_ALLOWED_CHARACTERS, HARD_RETURN, defaultOptions, BULLET_POINT_REGEX, NUMBERED_POINT_REGEX, POINT_REGEX, isPointedLine, BULLET_POINT, numberedPoint, links, Renderer, renderer_default;
var init_renderer = __esm({
  "src/markdown/renderer.ts"() {
    import_cli_table = __toModule(require_lib7());
    init_styles();
    logger3 = require_logger2()("markdown-renderer");
    TABLE_CELL_SPLIT = "^*||*^";
    TABLE_ROW_WRAP = "*|*|*|*";
    TABLE_ROW_WRAP_REGEXP = new RegExp(escapeRegExp(TABLE_ROW_WRAP), "g");
    COLON_REPLACER = "*#COLON|*";
    COLON_REPLACER_REGEXP = new RegExp(escapeRegExp(COLON_REPLACER), "g");
    TAB_ALLOWED_CHARACTERS = ["	"];
    HARD_RETURN = "\r";
    defaultOptions = {
      code: identity,
      blockquote: identity,
      html: gray,
      heading: magenta,
      firstHeading: magenta,
      hr: identity,
      listitem: identity,
      list,
      table: identity,
      paragraph: identity,
      strong: bold,
      em: italic,
      codespan: yellow,
      del: strikethrough,
      link: underline,
      href: underline,
      text: identity,
      unescape: true,
      emoji: false,
      width: 80,
      showSectionPrefix: true,
      tab: 2,
      tableOptions: {}
    };
    BULLET_POINT_REGEX = "\\*";
    NUMBERED_POINT_REGEX = "\\d+\\.";
    POINT_REGEX = "(?:" + [BULLET_POINT_REGEX, NUMBERED_POINT_REGEX].join("|") + ")";
    isPointedLine = function(line, indent) {
      return line.match("^(?:" + indent + ")*" + POINT_REGEX);
    };
    BULLET_POINT = "* ";
    numberedPoint = function(n) {
      return n + ". ";
    };
    links = new Map();
    Renderer = class {
      constructor(options = {}, highlightOptions = {}) {
        this.options = options;
        this.highlightOptions = highlightOptions;
        this.o = Object.assign({}, defaultOptions, options);
        this.tab = sanitizeTab(this.o.tab, defaultOptions.tab);
        this.tableSettings = this.o.tableOptions;
        this.unescape = this.o.unescape ? unescapeEntities : identity;
        this.highlightOptions = highlightOptions || {};
        this.transform = this.compose(undoColon, this.unescape);
      }
      textLength(str) {
        return str.replace(/\u001b\[(?:\d{1,3})(?:;\d{1,3})*m/g, "").length;
      }
      text(t) {
        return this.o.text(t);
      }
      code(code, lang, _escaped) {
        return "``` " + lang + "\n" + code + "\n```\n";
      }
      blockquote(quote) {
        return section(this.o.blockquote(indentify(this.tab, quote.trim())));
      }
      html(html) {
        return this.o.html(html);
      }
      heading(text, level, _raw) {
        text = this.transform(text);
        let prefix = this.o.showSectionPrefix ? new Array(level + 1).join("#") + " " : "";
        text = prefix + text;
        return section(level === 1 ? this.o.firstHeading(text) : this.o.heading(text));
      }
      hr() {
        return `\u2500\u2500\u2500
`;
      }
      list(body, ordered) {
        body = this.o.list(body, ordered, this.tab);
        return section(fixNestedLists(indentLines(this.tab, body), this.tab));
      }
      listitem(text) {
        let transform = this.compose(this.o.listitem, this.transform);
        let isNested = text.indexOf("\n") !== -1;
        if (isNested)
          text = text.trim();
        return "\n" + BULLET_POINT + transform(text);
      }
      checkbox(checked) {
        return "[" + (checked ? "X" : " ") + "] ";
      }
      paragraph(text) {
        let transform = this.compose(this.o.paragraph, this.transform);
        text = transform(text);
        return section(text);
      }
      table(header, body) {
        let table = new import_cli_table.default(Object.assign({}, {
          head: generateTableRow(header)[0]
        }, this.tableSettings));
        generateTableRow(body, this.transform).forEach(function(row) {
          table.push(row);
        });
        return section(this.o.table(table.toString()));
      }
      tablerow(content) {
        return TABLE_ROW_WRAP + content + TABLE_ROW_WRAP + "\n";
      }
      tablecell(content, _flags) {
        return content + TABLE_CELL_SPLIT;
      }
      strong(text) {
        return this.o.strong(text);
      }
      em(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.em(text);
      }
      codespan(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.codespan(text.replace(/:/g, COLON_REPLACER));
      }
      br() {
        return "\n";
      }
      del(text) {
        return this.o.del(text);
      }
      link(href, title, text) {
        let prot;
        if (this.options.sanitize) {
          try {
            prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, "").toLowerCase();
          } catch (e) {
            return "";
          }
          if (prot.startsWith("javascript:")) {
            return "";
          }
        }
        if (text && href && text != href) {
          links.set(text, href);
        }
        if (text && text != href)
          return blue(text);
        let out = this.o.href(href);
        return this.o.link(out);
      }
      image(href, title, text) {
        if (typeof this.o.image === "function") {
          return this.o.image(href, title, text);
        }
        let out = "![" + text;
        if (title)
          out += " \u2013 " + title;
        return out + "](" + href + ")\n";
      }
      compose(...funcs) {
        return (...args) => {
          for (let i = funcs.length; i-- > 0; ) {
            args = [funcs[i].apply(this, args)];
          }
          return args[0];
        };
      }
      static getLinks() {
        let res = [];
        for (let [text, href] of links.entries()) {
          res.push(`${blue(text)}: ${href}`);
        }
        links.clear();
        return res;
      }
    };
    renderer_default = Renderer;
  }
});

// src/util/string.ts
function rangeParts(text, range) {
  let { start, end } = range;
  let lines = text.split(/\r?\n/);
  let before = "";
  let after = "";
  let len = lines.length;
  for (let i = 0; i < len; i++) {
    let curr = lines[i];
    if (i < start.line) {
      before += curr + "\n";
      continue;
    }
    if (i > end.line) {
      after += curr + (i == len - 1 ? "" : "\n");
      continue;
    }
    if (i == start.line) {
      before += curr.slice(0, start.character);
    }
    if (i == end.line) {
      after += curr.slice(end.character) + (i == len - 1 ? "" : "\n");
    }
  }
  return [before, after];
}
function byteLength(str) {
  return Buffer.byteLength(str);
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function byteIndex(content, index) {
  let s = content.slice(0, index);
  return Buffer.byteLength(s);
}
function characterIndex(content, byteIndex2) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(0, byteIndex2).toString("utf8").length;
}
function byteSlice(content, start, end) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(start, end).toString("utf8");
}
function isWord(character) {
  let code = character.charCodeAt(0);
  if (code > 128)
    return false;
  if (code == 95)
    return true;
  if (code >= 48 && code <= 57)
    return true;
  if (code >= 65 && code <= 90)
    return true;
  if (code >= 97 && code <= 122)
    return true;
  return false;
}
var init_string = __esm({
  "src/util/string.ts"() {
  }
});

// src/util/ansiparse.ts
function parseAnsiHighlights(line, markdown = false) {
  let items = ansiparse(line);
  let highlights = [];
  let newLabel = "";
  for (let item of items) {
    if (!item.text)
      continue;
    let { foreground, background, bold: bold2, italic: italic2, underline: underline2 } = item;
    let len = byteLength(newLabel);
    if (foreground || background || bold2 || italic2 || underline2) {
      let span = [len, len + byteLength(item.text)];
      let hlGroup = "";
      if (foreground && background) {
        hlGroup = `CocList${upperFirst(foreground)}${upperFirst(background)}`;
      } else if (foreground) {
        if (markdown) {
          if (foreground == "yellow") {
            hlGroup = "CocMarkdownCode";
          } else if (foreground == "blue") {
            hlGroup = "CocMarkdownLink";
          } else if (foreground == "magenta") {
            hlGroup = "CocMarkdownHeader";
          } else {
            hlGroup = `CocListFg${upperFirst(foreground)}`;
          }
        } else {
          hlGroup = `CocListFg${upperFirst(foreground)}`;
        }
      } else if (background) {
        hlGroup = `CocListBg${upperFirst(background)}`;
      } else if (bold2) {
        hlGroup = "CocBold";
      } else if (italic2) {
        hlGroup = "CocItalic";
      } else if (underline2) {
        hlGroup = "CocUnderline";
      }
      highlights.push({ span, hlGroup });
    }
    newLabel = newLabel + item.text;
  }
  return { line: newLabel, highlights };
}
function ansiparse(str) {
  let matchingControl = null;
  let matchingData = null;
  let matchingText = "";
  let ansiState = [];
  let result = [];
  let state = {};
  let eraseChar;
  eraseChar = () => {
    let index;
    let text;
    if (matchingText.length) {
      matchingText = matchingText.substr(0, matchingText.length - 1);
    } else if (result.length) {
      index = result.length - 1;
      text = result[index].text;
      if (text.length === 1) {
        result.pop();
      } else {
        result[index].text = text.substr(0, text.length - 1);
      }
    }
  };
  for (let i = 0; i < str.length; i++) {
    if (matchingControl != null) {
      if (matchingControl == "" && str[i] == "[") {
        if (matchingText) {
          state.text = matchingText;
          result.push(state);
          state = {};
          matchingText = "";
        }
        if (matchingText == "" && (str[i + 1] == "m" || str[i + 1] == "K")) {
          if (state.foreground || state.background) {
            state.text = "";
            result.push(state);
          }
          state = {};
        }
        matchingControl = null;
        matchingData = "";
      } else {
        matchingText += matchingControl + str[i];
        matchingControl = null;
      }
      continue;
    } else if (matchingData != null) {
      if (str[i] == ";") {
        ansiState.push(matchingData);
        matchingData = "";
      } else if (str[i] == "m" || str[i] == "K") {
        ansiState.push(matchingData);
        matchingData = null;
        matchingText = "";
        ansiState.forEach((ansiCode) => {
          if (foregroundColors[ansiCode]) {
            state.foreground = foregroundColors[ansiCode];
          } else if (backgroundColors[ansiCode]) {
            state.background = backgroundColors[ansiCode];
          } else if (ansiCode == 39) {
            delete state.foreground;
          } else if (ansiCode == 49) {
            delete state.background;
          } else if (styles2[ansiCode]) {
            state[styles2[ansiCode]] = true;
          } else if (ansiCode == 22) {
            state.bold = false;
          } else if (ansiCode == 23) {
            state.italic = false;
          } else if (ansiCode == 24) {
            state.underline = false;
          }
        });
        ansiState = [];
      } else {
        matchingData += str[i];
      }
      continue;
    }
    if (str[i] == "") {
      matchingControl = str[i];
    } else if (str[i] == "\b") {
      eraseChar();
    } else {
      matchingText += str[i];
    }
  }
  if (matchingText) {
    state.text = matchingText + (matchingControl ? matchingControl : "");
    result.push(state);
  }
  return result;
}
var foregroundColors, backgroundColors, styles2;
var init_ansiparse = __esm({
  "src/util/ansiparse.ts"() {
    init_string();
    foregroundColors = {
      30: "black",
      31: "red",
      32: "green",
      33: "yellow",
      34: "blue",
      35: "magenta",
      36: "cyan",
      37: "white",
      90: "grey"
    };
    backgroundColors = {
      40: "black",
      41: "red",
      42: "green",
      43: "yellow",
      44: "blue",
      45: "magenta",
      46: "cyan",
      47: "white"
    };
    styles2 = {
      1: "bold",
      3: "italic",
      4: "underline"
    };
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
  }
});

// src/markdown/index.ts
function parseDocuments(docs, opts = {}) {
  let lines = [];
  let highlights = [];
  let codes = [];
  let idx = 0;
  for (let doc of docs) {
    let currline = lines.length;
    let { content, filetype } = doc;
    if (filetype == "markdown") {
      let info = parseMarkdown(content, opts);
      codes.push(...info.codes.map((o) => {
        o.startLine = o.startLine + currline;
        o.endLine = o.endLine + currline;
        return o;
      }));
      highlights.push(...info.highlights.map((o) => {
        o.lnum = o.lnum + currline;
        return o;
      }));
      lines.push(...info.lines);
    } else {
      let parts = content.trim().split(/\r?\n/);
      if (diagnosticFiletypes.includes(doc.filetype)) {
        codes.push({ hlGroup: `Coc${filetype}Float`, startLine: currline, endLine: currline + parts.length });
      } else {
        codes.push({ filetype: doc.filetype, startLine: currline, endLine: currline + parts.length });
      }
      lines.push(...parts);
    }
    if (doc.active) {
      let arr = getHighlightItems(content, currline, doc.active);
      if (arr.length)
        highlights.push(...arr);
    }
    if (idx != docs.length - 1) {
      lines.push("\u2500");
    }
    idx = idx + 1;
  }
  return { lines, highlights, codes };
}
function getHighlightItems(content, currline, active) {
  let res = [];
  let [start, end] = active;
  let lines = content.split(/\r?\n/);
  let used = 0;
  let inRange = false;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    if (!inRange) {
      if (used + line.length > start) {
        inRange = true;
        let colStart = byteLength(line.slice(0, start - used));
        if (used + line.length > end) {
          let colEnd = byteLength(line.slice(0, end - used));
          inRange = false;
          res.push({ colStart, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
          break;
        } else {
          let colEnd = byteLength(line);
          res.push({ colStart, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
        }
      }
    } else {
      if (used + line.length > end) {
        let colEnd = byteLength(line.slice(0, end - used));
        res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
        inRange = false;
        break;
      } else {
        let colEnd = byteLength(line);
        res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
      }
    }
    used = used + line.length + 1;
  }
  return res;
}
function parseMarkdown(content, opts) {
  import_marked.default.setOptions({
    renderer: new renderer_default(),
    gfm: true
  });
  let lines = [];
  let highlights = [];
  let codes = [];
  let currline = 0;
  let inCodeBlock = false;
  let filetype;
  let startLnum = 0;
  let parsed = (0, import_marked.default)(content);
  let links2 = renderer_default.getLinks();
  if (links2.length) {
    parsed = parsed + "\n\n" + links2.join("\n");
  }
  parsed = parsed.replace(/\s*$/, "");
  let parsedLines = parsed.split(/\n/);
  for (let i = 0; i < parsedLines.length; i++) {
    let line = parsedLines[i];
    if (!line.length) {
      let pre = lines[lines.length - 1];
      if (pre && pre.length) {
        lines.push(line);
        currline++;
      }
      continue;
    }
    if (opts.excludeImages && line.indexOf("![") !== -1) {
      line = line.replace(/\s*!\[.*?\]\(.*?\)/g, "");
      if (!(0, import_strip_ansi.default)(line).trim().length)
        continue;
    }
    if (/\s*```\s*([A-Za-z0-9_,]+)?$/.test(line)) {
      if (!inCodeBlock) {
        let pre = parsedLines[i - 1];
        if (pre && /^\s*```\s*/.test(pre)) {
          lines.push("");
          currline++;
        }
        inCodeBlock = true;
        filetype = line.replace(/^\s*```\s*/, "");
        if (filetype == "js")
          filetype = "javascript";
        if (filetype == "ts")
          filetype = "typescript";
        if (filetype == "bash")
          filetype = "sh";
        startLnum = currline;
      } else {
        inCodeBlock = false;
        codes.push({
          filetype,
          startLine: startLnum,
          endLine: currline
        });
      }
      continue;
    }
    if (inCodeBlock) {
      lines.push(line);
      currline++;
      continue;
    }
    let res = parseAnsiHighlights(line, true);
    if (res.highlights) {
      for (let hi of res.highlights) {
        let { hlGroup, span } = hi;
        highlights.push({
          hlGroup,
          lnum: currline,
          colStart: span[0],
          colEnd: span[1]
        });
      }
    }
    lines.push(res.line);
    currline++;
  }
  return { lines, highlights, codes };
}
var import_marked, import_strip_ansi, diagnosticFiletypes, logger4;
var init_markdown = __esm({
  "src/markdown/index.ts"() {
    import_marked = __toModule(require_marked());
    init_renderer();
    init_ansiparse();
    init_string();
    import_strip_ansi = __toModule(require_strip_ansi());
    diagnosticFiletypes = ["Error", "Warning", "Info", "Hint"];
    logger4 = require_logger2()("markdown-index");
  }
});

// src/util/mutex.ts
var Mutex;
var init_mutex = __esm({
  "src/util/mutex.ts"() {
    Mutex = class {
      constructor() {
        this.tasks = [];
        this.count = 1;
      }
      sched() {
        if (this.count > 0 && this.tasks.length > 0) {
          this.count--;
          let next = this.tasks.shift();
          next();
        }
      }
      get busy() {
        return this.count == 0;
      }
      acquire() {
        return new Promise((res) => {
          let task = () => {
            let released = false;
            res(() => {
              if (!released) {
                released = true;
                this.count++;
                this.sched();
              }
            });
          };
          this.tasks.push(task);
          process.nextTick(this.sched.bind(this));
        });
      }
      use(f) {
        return this.acquire().then((release) => f().then((res) => {
          release();
          return res;
        }).catch((err) => {
          release();
          throw err;
        }));
      }
    };
  }
});

// src/model/floatFactory.ts
var import_debounce2, import_vscode_languageserver_protocol3, isVim, logger5, FloatFactory;
var init_floatFactory = __esm({
  "src/model/floatFactory.ts"() {
    import_debounce2 = __toModule(require_debounce());
    import_vscode_languageserver_protocol3 = __toModule(require_main2());
    init_events();
    init_markdown();
    init_util();
    init_mutex();
    init_object();
    isVim = process.env.VIM_NODE_RPC == "1";
    logger5 = require_logger2()("model-float");
    FloatFactory = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.winid = 0;
        this._bufnr = 0;
        this.mutex = new Mutex();
        this.disposables = [];
        this.onCursorMoved = (0, import_debounce2.default)(this._onCursorMoved.bind(this), 100);
      }
      bindEvents(autoHide, alignTop) {
        let eventNames = ["InsertLeave", "InsertEnter", "BufEnter"];
        for (let ev of eventNames) {
          events_default.on(ev, (bufnr) => {
            if (bufnr == this._bufnr)
              return;
            this.close();
          }, null, this.disposables);
        }
        events_default.on("MenuPopupChanged", () => {
          if (events_default.pumAlignTop == alignTop) {
            this.close();
          }
        }, null, this.disposables);
        this.disposables.push(import_vscode_languageserver_protocol3.Disposable.create(() => {
          this.onCursorMoved.clear();
        }));
        events_default.on("CursorMoved", this.onCursorMoved.bind(this, autoHide), this, this.disposables);
        events_default.on("CursorMovedI", this.onCursorMoved.bind(this, autoHide), this, this.disposables);
      }
      unbind() {
        if (this.disposables.length) {
          disposeAll(this.disposables);
          this.disposables = [];
        }
      }
      _onCursorMoved(autoHide, bufnr, cursor) {
        if (bufnr == this._bufnr)
          return;
        if (bufnr == this.targetBufnr && equals(cursor, this.cursor)) {
          return;
        }
        if (autoHide || bufnr != this.targetBufnr || !events_default.insertMode) {
          this.close();
          return;
        }
      }
      async create(docs, _allowSelection = false, offsetX = 0) {
        await this.show(docs, {
          offsetX
        });
      }
      applyFloatConfig(conf, opts) {
        for (let key of Object.keys(opts)) {
          if (key == "border") {
            if (opts.border)
              conf.border = [1, 1, 1, 1];
            continue;
          }
          conf[key] = opts[key];
        }
        return conf;
      }
      async show(docs, config = {}) {
        if (docs.length == 0 || docs.every((doc) => doc.content.length == 0)) {
          this.close();
          return;
        }
        let curr = Date.now();
        let release = await this.mutex.acquire();
        try {
          await this.createPopup(docs, config, curr);
          release();
        } catch (e) {
          this.nvim.echoError(e);
          release();
        }
      }
      async createPopup(docs, opts, timestamp) {
        docs = docs.filter((o) => o.content.trim().length > 0);
        let { lines, codes, highlights } = parseDocuments(docs);
        let config = {
          pumAlignTop: events_default.pumAlignTop,
          preferTop: typeof opts.preferTop === "boolean" ? opts.preferTop : false,
          offsetX: opts.offsetX || 0,
          title: opts.title || "",
          close: opts.close ? 1 : 0,
          codes,
          highlights,
          modes: opts.modes || ["n", "i", "ic", "s"]
        };
        if (!isVim) {
          if (typeof opts.winblend === "number")
            config.winblend = opts.winblend;
          if (opts.focusable != null)
            config.focusable = opts.focusable ? 1 : 0;
          if (opts.shadow)
            config.shadow = 1;
        }
        if (opts.maxHeight)
          config.maxHeight = opts.maxHeight;
        if (opts.maxWidth)
          config.maxWidth = opts.maxWidth;
        if (opts.border && !opts.border.every((o) => o == 0)) {
          config.border = opts.border;
        }
        if (opts.title && !config.border)
          config.border = [1, 1, 1, 1];
        if (opts.highlight)
          config.highlight = opts.highlight;
        if (opts.borderhighlight)
          config.borderhighlight = [opts.borderhighlight];
        if (opts.cursorline)
          config.cursorline = 1;
        let autoHide = opts.autoHide == false ? false : true;
        if (autoHide)
          config.autohide = 1;
        this.unbind();
        let arr = await this.nvim.call("coc#float#create_cursor_float", [this.winid, this._bufnr, lines, config]);
        this.nvim.redrawVim();
        if (!arr || arr.length == 0 || this.closeTs > timestamp) {
          let winid2 = arr && arr.length > 0 ? arr[2] : this.winid;
          if (winid2) {
            this.winid = 0;
            this.nvim.call("coc#float#close", [winid2], true);
            this.nvim.redrawVim();
          }
          return;
        }
        let [targetBufnr, cursor, winid, bufnr, alignTop] = arr;
        this.winid = winid;
        this._bufnr = bufnr;
        this.targetBufnr = targetBufnr;
        this.cursor = cursor;
        this.bindEvents(autoHide, alignTop == 1);
      }
      close() {
        let { winid, nvim } = this;
        this.closeTs = Date.now();
        this.unbind();
        if (winid) {
          this.winid = 0;
          nvim.call("coc#float#close", [winid], true);
          nvim.redrawVim();
        }
      }
      checkRetrigger(bufnr) {
        if (this.winid && this.targetBufnr == bufnr)
          return true;
        return false;
      }
      get bufnr() {
        return this._bufnr;
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : null;
      }
      get window() {
        return this.winid ? this.nvim.createWindow(this.winid) : null;
      }
      async activated() {
        if (!this.winid)
          return false;
        return await this.nvim.call("coc#float#valid", [this.winid]) != 0;
      }
      dispose() {
        this.cursor = void 0;
        this.close();
      }
    };
  }
});

// src/util/position.ts
function rangeInRange(r, range) {
  return positionInRange(r.start, range) === 0 && positionInRange(r.end, range) === 0;
}
function rangeOverlap(r, range) {
  let { start, end } = r;
  if (comparePosition(end, range.start) <= 0) {
    return false;
  }
  if (comparePosition(start, range.end) >= 0) {
    return false;
  }
  return true;
}
function rangeIntersect(r, range) {
  if (positionInRange(r.start, range) == 0) {
    return true;
  }
  if (positionInRange(r.end, range) == 0) {
    return true;
  }
  if (rangeInRange(range, r)) {
    return true;
  }
  return false;
}
function lineInRange(line, range) {
  let { start, end } = range;
  return line >= start.line && line <= end.line;
}
function emptyRange(range) {
  let { start, end } = range;
  return start.line == end.line && start.character == end.character;
}
function positionInRange(position, range) {
  let { start, end } = range;
  if (comparePosition(position, start) < 0)
    return -1;
  if (comparePosition(position, end) > 0)
    return 1;
  return 0;
}
function comparePosition(position, other) {
  if (position.line > other.line)
    return 1;
  if (other.line == position.line && position.character > other.character)
    return 1;
  if (other.line == position.line && position.character == other.character)
    return 0;
  return -1;
}
function isSingleLine(range) {
  return range.start.line == range.end.line;
}
function getChangedPosition(start, edit2) {
  let { range, newText } = edit2;
  if (comparePosition(range.end, start) <= 0) {
    let lines = newText.split("\n");
    let lineCount = lines.length - (range.end.line - range.start.line) - 1;
    let characterCount = 0;
    if (range.end.line == start.line) {
      let single = isSingleLine(range) && lineCount == 0;
      let removed = single ? range.end.character - range.start.character : range.end.character;
      let added = single ? newText.length : lines[lines.length - 1].length;
      characterCount = added - removed;
    }
    return { line: lineCount, character: characterCount };
  }
  return { line: 0, character: 0 };
}
function adjustPosition(pos, edit2) {
  let { range, newText } = edit2;
  if (comparePosition(range.start, pos) > 1)
    return pos;
  let { start, end } = range;
  let newLines = newText.split("\n");
  let delta = end.line - start.line - newLines.length + 1;
  let lastLine = newLines[newLines.length - 1];
  let line = pos.line - delta;
  if (pos.line != end.line)
    return { line, character: pos.character };
  let pre = newLines.length == 1 && start.line != end.line ? start.character : 0;
  let removed = start.line == end.line && newLines.length == 1 ? end.character - start.character : end.character;
  let character = pre + pos.character + lastLine.length - removed;
  return {
    line,
    character
  };
}
function positionToOffset(lines, line, character) {
  let offset = 0;
  for (let i = 0; i <= line; i++) {
    if (i == line) {
      offset += character;
    } else {
      offset += lines[i].length + 1;
    }
  }
  return offset;
}
function editRange(range, text, edit2) {
  if (!rangeInRange(edit2.range, range))
    return text;
  let { start, end } = edit2.range;
  let lines = text.split("\n");
  let character = start.line == range.start.line ? start.character - range.start.character : start.character;
  let startOffset = positionToOffset(lines, start.line - range.start.line, character);
  character = end.line == range.start.line ? end.character - range.start.character : end.character;
  let endOffset = positionToOffset(lines, end.line - range.start.line, character);
  return `${text.slice(0, startOffset)}${edit2.newText}${text.slice(endOffset, text.length)}`;
}
function getChangedFromEdits(start, edits) {
  let changed = { line: 0, character: 0 };
  for (let edit2 of edits) {
    let d = getChangedPosition(start, edit2);
    changed = { line: changed.line + d.line, character: changed.character + d.character };
  }
  return changed.line == 0 && changed.character == 0 ? null : changed;
}
var init_position = __esm({
  "src/util/position.ts"() {
  }
});

// src/model/outputChannel.ts
var logger6, BufferChannel;
var init_outputChannel = __esm({
  "src/model/outputChannel.ts"() {
    init_util();
    logger6 = require_logger2()("outpubChannel");
    BufferChannel = class {
      constructor(name2, nvim, onDispose) {
        this.name = name2;
        this.nvim = nvim;
        this.onDispose = onDispose;
        this.lines = [""];
        this.disposables = [];
        this._disposed = false;
        this.created = false;
      }
      get content() {
        return this.lines.join("\n");
      }
      _append(value) {
        let { nvim } = this;
        let idx = this.lines.length - 1;
        let newlines = value.split(/\r?\n/);
        let lastline = this.lines[idx] + newlines[0];
        this.lines[idx] = lastline;
        let append = newlines.slice(1);
        this.lines = this.lines.concat(append);
        if (!this.created)
          return;
        nvim.pauseNotification();
        nvim.call("setbufline", [this.bufname, "$", lastline], true);
        if (append.length) {
          nvim.call("appendbufline", [this.bufname, "$", append], true);
        }
        nvim.resumeNotification(false, true);
      }
      append(value) {
        if (!this.validate())
          return;
        this._append(value);
      }
      appendLine(value) {
        if (!this.validate())
          return;
        this._append(value + "\n");
      }
      clear(keep) {
        if (!this.validate())
          return;
        let { nvim } = this;
        this.lines = keep ? this.lines.slice(-keep) : [];
        if (!this.created)
          return;
        nvim.pauseNotification();
        nvim.call("deletebufline", [this.bufname, 1, "$"], true);
        if (this.lines.length) {
          nvim.call("appendbufline", [this.bufname, "$", this.lines], true);
        }
        nvim.resumeNotification(false, true);
      }
      hide() {
        this.created = false;
        this.nvim.command(`exe 'silent! bd! '.fnameescape('${this.bufname}')`, true);
      }
      get bufname() {
        return `output:///${this.name}`;
      }
      show(preserveFocus) {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command(`exe 'vsplit '.fnameescape('${this.bufname}')`, true);
        if (preserveFocus) {
          nvim.command("wincmd p", true);
        }
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
        this.created = true;
      }
      validate() {
        return !this._disposed;
      }
      dispose() {
        if (this.onDispose)
          this.onDispose();
        this._disposed = true;
        this.hide();
        this.lines = [];
        disposeAll(this.disposables);
      }
    };
  }
});

// src/channels.ts
var logger7, Channels, channels_default;
var init_channels = __esm({
  "src/channels.ts"() {
    init_outputChannel();
    init_events();
    logger7 = require_logger2()("channels");
    Channels = class {
      constructor() {
        this.outputChannels = new Map();
        this.bufnrs = new Map();
        this.disposable = events_default.on("BufUnload", (bufnr) => {
          let name2 = this.bufnrs.get(bufnr);
          if (name2) {
            let channel = this.outputChannels.get(name2);
            if (channel)
              channel.created = false;
          }
        });
      }
      getProvider(nvim) {
        let provider = {
          onDidChange: null,
          provideTextDocumentContent: async (uri) => {
            let channel = this.get(uri.path.slice(1));
            if (!channel)
              return "";
            nvim.pauseNotification();
            nvim.call("bufnr", ["%"], true);
            nvim.command("setlocal nospell nofoldenable nowrap noswapfile", true);
            nvim.command("setlocal buftype=nofile bufhidden=hide", true);
            nvim.command("setfiletype log", true);
            let res = await nvim.resumeNotification();
            if (!res[1]) {
              this.bufnrs.set(res[0][0], channel.name);
              channel.created = true;
            }
            return channel.content;
          }
        };
        return provider;
      }
      get names() {
        return Array.from(this.outputChannels.keys());
      }
      get(channelName) {
        return this.outputChannels.get(channelName);
      }
      create(name2, nvim) {
        if (this.outputChannels.has(name2))
          return this.outputChannels.get(name2);
        if (!/^[\w\s-.]+$/.test(name2))
          throw new Error(`Invalid channel name "${name2}", only word characters and white space allowed.`);
        let channel = new BufferChannel(name2, nvim, () => {
          this.outputChannels.delete(name2);
        });
        this.outputChannels.set(name2, channel);
        return channel;
      }
      show(name2, preserveFocus) {
        let channel = this.outputChannels.get(name2);
        if (!channel)
          return;
        channel.show(preserveFocus);
      }
      dispose() {
        this.disposable.dispose();
        for (let channel of this.outputChannels.values()) {
          channel.dispose();
        }
        this.outputChannels.clear();
      }
    };
    channels_default = new Channels();
  }
});

// src/model/dialog.ts
var logger8, Dialog;
var init_dialog = __esm({
  "src/model/dialog.ts"() {
    init_events();
    init_util();
    logger8 = require_logger2()("model-dialog");
    Dialog = class {
      constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this.dispose();
            if (config.callback)
              config.callback(-1);
          }
        }, null, this.disposables);
        events_default.on("FloatBtnClick", (bufnr, idx) => {
          if (bufnr == this.bufnr) {
            this.dispose();
            let btns = config == null ? void 0 : config.buttons.filter((o) => o.disabled != true);
            if (config.callback)
              config.callback(btns[idx].index);
          }
        }, null, this.disposables);
      }
      get lines() {
        return [...this.config.content.split(/\r?\n/)];
      }
      async show(preferences) {
        let { nvim } = this;
        let { title, close, buttons } = this.config;
        let borderhighlight = this.config.borderhighlight || preferences.floatBorderHighlight;
        let highlight = this.config.highlight || preferences.floatHighlight;
        let opts = { maxwidth: preferences.maxWidth || 80 };
        if (title)
          opts.title = title;
        if (close || typeof close === "undefined")
          opts.close = 1;
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (highlight)
          opts.highlight = highlight;
        if (borderhighlight)
          opts.borderhighlight = [borderhighlight];
        if (buttons)
          opts.buttons = buttons.filter((o) => !o.disabled).map((o) => o.text);
        let res = await nvim.call("coc#float#create_dialog", [this.lines, opts]);
        if (!res[1])
          return;
        this.bufnr = res[1];
        nvim.command("redraw", true);
      }
      get winid() {
        if (!this.bufnr)
          return Promise.resolve(null);
        return this.nvim.call("bufwinid", [this.bufnr]);
      }
      dispose() {
        this.bufnr = void 0;
        disposeAll(this.disposables);
        this.disposables = [];
      }
    };
  }
});

// src/model/popup.ts
var isVim2, Popup;
var init_popup = __esm({
  "src/model/popup.ts"() {
    isVim2 = process.env.VIM_NODE_RPC == "1";
    Popup = class {
      constructor(nvim, winid, bufnr) {
        this.nvim = nvim;
        this.winid = winid;
        this.bufnr = bufnr;
      }
      get valid() {
        return this.nvim.call("coc#float#valid", [this.winid]).then((res) => {
          return !!res;
        });
      }
      close() {
        this.nvim.call("coc#float#close", [this.winid], true);
      }
      refreshScrollbar() {
        if (!isVim2)
          this.nvim.call("coc#float#nvim_scrollbar", [this.winid], true);
      }
      execute(cmd) {
        this.nvim.call("coc#compat#execute", [this.winid, cmd], true);
      }
      async scrollForward() {
        let { nvim, bufnr, winid } = this;
        let buf = nvim.createBuffer(bufnr);
        let total = await buf.length;
        let botline;
        if (!isVim2) {
          let infos = await nvim.call("getwininfo", [winid]);
          if (!infos || !infos.length)
            return;
          botline = infos[0].botline;
        } else {
          botline = await nvim.eval(`get(popup_getpos(${winid}), 'lastline', 0)`);
        }
        if (botline >= total || botline == 0)
          return;
        nvim.pauseNotification();
        this.setCursor(botline - 1);
        this.execute(`silent! noa setl scrolloff=0`);
        this.execute(`normal! ${botline}Gzt`);
        this.refreshScrollbar();
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      async scrollBackward() {
        let { nvim, winid } = this;
        let topline;
        if (!isVim2) {
          let infos = await nvim.call("getwininfo", [winid]);
          if (!infos || !infos.length)
            return;
          topline = infos[0].topline;
        } else {
          topline = await nvim.eval(`get(popup_getpos(${winid}), 'firstline', 0)`);
        }
        if (topline == 1)
          return;
        nvim.pauseNotification();
        this.setCursor(topline - 1);
        this.execute(`normal! ${topline}Gzb`);
        this.refreshScrollbar();
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      setCursor(index) {
        let { nvim, bufnr, winid } = this;
        if (isVim2) {
          nvim.call("win_execute", [winid, `exe ${index + 1}`], true);
        } else {
          let win = nvim.createWindow(winid);
          win.notify("nvim_win_set_cursor", [[index + 1, 0]]);
          nvim.command(`sign unplace 6 buffer=${bufnr}`, true);
          nvim.command(`sign place 6 line=${index + 1} name=CocCurrentLine buffer=${bufnr}`, true);
        }
      }
    };
  }
});

// src/model/menu.ts
var import_vscode_languageserver_protocol4, logger9, Menu;
var init_menu = __esm({
  "src/model/menu.ts"() {
    import_vscode_languageserver_protocol4 = __toModule(require_main2());
    init_events();
    init_util();
    init_popup();
    logger9 = require_logger2()("model-menu");
    Menu = class {
      constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.currIndex = 0;
        this.disposables = [];
        this.keyMappings = new Map();
        this._onDidClose = new import_vscode_languageserver_protocol4.Emitter();
        this.onDidClose = this._onDidClose.event;
        this.total = config.items.length;
        if (token) {
          token.onCancellationRequested(() => {
            var _a2;
            (_a2 = this.win) == null ? void 0 : _a2.close();
          });
        }
        this.disposables.push(this._onDidClose);
        this.addKeymappings();
      }
      attachEvents() {
        events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this._onDidClose.fire(-1);
            this.bufnr = void 0;
            this.win = void 0;
            this.dispose();
          }
        }, null, this.disposables);
      }
      addKeymappings() {
        let { nvim } = this;
        this.addKeys(["<esc>", "<C-c>"], () => {
          this._onDidClose.fire(-1);
          this.dispose();
        });
        this.addKeys(["\r", "<cr>"], () => {
          this._onDidClose.fire(this.currIndex);
          this.dispose();
        });
        let setCursorIndex = (idx) => {
          var _a2;
          if (!this.win)
            return;
          nvim.pauseNotification();
          this.setCursor(idx);
          (_a2 = this.win) == null ? void 0 : _a2.refreshScrollbar();
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        };
        this.addKeys("<C-f>", async () => {
          var _a2;
          await ((_a2 = this.win) == null ? void 0 : _a2.scrollForward());
        });
        this.addKeys("<C-b>", async () => {
          var _a2;
          await ((_a2 = this.win) == null ? void 0 : _a2.scrollBackward());
        });
        this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
          let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;
          setCursorIndex(idx);
        });
        this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
          let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;
          setCursorIndex(idx);
        });
        this.addKeys(["g"], () => {
          setCursorIndex(0);
        });
        this.addKeys(["G"], () => {
          setCursorIndex(this.total - 1);
        });
        let timer;
        let firstNumber;
        this.addKeys(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], (character) => {
          if (timer)
            clearTimeout(timer);
          let n = parseInt(character, 10);
          if (isNaN(n) || n > this.total)
            return;
          if (firstNumber == null && n == 0)
            return;
          if (firstNumber) {
            let count = firstNumber * 10 + n;
            firstNumber = void 0;
            this._onDidClose.fire(count - 1);
            this.dispose();
            return;
          }
          if (this.total < 10 || n * 10 > this.total) {
            this._onDidClose.fire(n - 1);
            this.dispose();
            return;
          }
          timer = setTimeout(async () => {
            this._onDidClose.fire(n - 1);
            this.dispose();
          }, 200);
          firstNumber = n;
        });
      }
      async show(preferences = {}) {
        let { nvim } = this;
        let { title, items } = this.config;
        let opts = {};
        if (title)
          opts.title = title;
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (preferences.floatHighlight)
          opts.highlight = preferences.floatHighlight;
        if (preferences.floatBorderHighlight)
          opts.borderhighlight = [preferences.floatBorderHighlight];
        let lines = items.map((v, i) => {
          if (i < 99)
            return `${i + 1}. ${v}`;
          return v;
        });
        if (preferences.confirmKey && preferences.confirmKey != "<cr>") {
          this.addKeys(preferences.confirmKey, () => {
            this._onDidClose.fire(this.currIndex);
            this.dispose();
          });
        }
        let res = await nvim.call("coc#float#create_menu", [lines, opts]);
        this.win = new Popup(nvim, res[0], res[1]);
        this.bufnr = res[1];
        this.attachEvents();
        nvim.call("coc#prompt#start_prompt", ["menu"], true);
        return res[0];
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      dispose() {
        var _a2;
        disposeAll(this.disposables);
        this.disposables = [];
        this.nvim.call("coc#prompt#stop_prompt", ["menu"], true);
        (_a2 = this.win) == null ? void 0 : _a2.close();
        this.win = void 0;
      }
      async onInputChar(session, character) {
        if (session != "menu" || !this.win)
          return;
        let fn = this.keyMappings.get(character);
        if (fn) {
          await Promise.resolve(fn(character));
        } else {
          logger9.warn(`Ignored key press: ${character}`);
        }
      }
      setCursor(index) {
        if (!this.win)
          return;
        this.currIndex = index;
        this.win.setCursor(index);
      }
      addKeys(keys, fn) {
        if (Array.isArray(keys)) {
          for (let key of keys) {
            this.keyMappings.set(key, fn);
          }
        } else {
          this.keyMappings.set(keys, fn);
        }
      }
    };
  }
});

// src/model/notification.ts
var isVim3, logger10, Notification;
var init_notification = __esm({
  "src/model/notification.ts"() {
    init_events();
    init_util();
    isVim3 = process.env.VIM_NODE_RPC == "1";
    logger10 = require_logger2()("model-notification");
    Notification = class {
      constructor(nvim, config, attachEvents = true) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        this._disposed = false;
        if (attachEvents) {
          events_default.on("BufWinLeave", (bufnr) => {
            if (bufnr == this.bufnr) {
              this.dispose();
              if (config.callback)
                config.callback(-1);
            }
          }, null, this.disposables);
          events_default.on("FloatBtnClick", (bufnr, idx) => {
            if (bufnr == this.bufnr) {
              this.dispose();
              let btns = config == null ? void 0 : config.buttons.filter((o) => o.disabled != true);
              if (config.callback)
                config.callback(btns[idx].index);
            }
          }, null, this.disposables);
        }
      }
      get lines() {
        return this.config.content.split(/\r?\n/);
      }
      async show(preferences) {
        let { nvim } = this;
        let { title, close, timeout, buttons, borderhighlight } = this.config;
        let opts = Object.assign({}, preferences);
        opts.close = close ? 1 : 0;
        if (title)
          opts.title = title;
        if (borderhighlight)
          opts.borderhighlight = borderhighlight;
        if (buttons)
          opts.buttons = buttons.filter((o) => !o.disabled).map((o) => o.text);
        if (timeout)
          opts.timeout = timeout;
        let res = await nvim.call("coc#float#create_notification", [this.lines, opts]);
        if (!res)
          return false;
        if (this._disposed) {
          this.nvim.call("coc#float#close", [res[0]], true);
          if (isVim3)
            this.nvim.command("redraw", true);
        } else {
          this._winid = res[0];
          this.bufnr = res[1];
        }
        return this._winid != void 0;
      }
      get winid() {
        return this._winid;
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        let { winid } = this;
        if (winid) {
          this.nvim.call("coc#float#close", [winid], true);
          if (isVim3)
            this.nvim.command("redraw", true);
        }
        this.bufnr = void 0;
        this._winid = void 0;
        disposeAll(this.disposables);
        this.disposables = [];
      }
    };
  }
});

// src/model/picker.ts
var import_vscode_languageserver_protocol5, logger11, isVim4, Picker;
var init_picker = __esm({
  "src/model/picker.ts"() {
    import_vscode_languageserver_protocol5 = __toModule(require_main2());
    init_events();
    init_util();
    init_string();
    init_popup();
    logger11 = require_logger2()("model-dialog");
    isVim4 = process.env.VIM_NODE_RPC == "1";
    Picker = class {
      constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.picked = new Set();
        this.currIndex = 0;
        this.disposables = [];
        this.keyMappings = new Map();
        this._onDidClose = new import_vscode_languageserver_protocol5.Emitter();
        this.onDidClose = this._onDidClose.event;
        for (let i = 0; i < config.items.length; i++) {
          let item = config.items[i];
          if (item.picked)
            this.picked.add(i);
        }
        this.total = config.items.length;
        if (token) {
          token.onCancellationRequested(() => {
            var _a2;
            (_a2 = this.win) == null ? void 0 : _a2.close();
          });
        }
        this.disposables.push(this._onDidClose);
        this.addKeymappings();
      }
      attachEvents() {
        events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this._onDidClose.fire(void 0);
            this.bufnr = void 0;
            this.win = void 0;
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("FloatBtnClick", (bufnr, idx) => {
          if (bufnr == this.bufnr) {
            if (idx == 0) {
              let selected = Array.from(this.picked);
              this._onDidClose.fire(selected.length ? selected : void 0);
            } else {
              this._onDidClose.fire(void 0);
            }
            this.dispose();
          }
        }, null, this.disposables);
      }
      addKeymappings() {
        let { nvim } = this;
        const toggleSelect = (idx) => {
          if (this.picked.has(idx)) {
            this.picked.delete(idx);
          } else {
            this.picked.add(idx);
          }
        };
        this.addKeys("<LeftRelease>", async () => {
          if (isVim4 || !this.win)
            return;
          let [winid, lnum, col] = await nvim.eval("[v:mouse_winid,v:mouse_lnum,v:mouse_col]");
          if (global.hasOwnProperty("__TEST__")) {
            let res = await nvim.getVar("mouse_position");
            winid = res[0];
            lnum = res[1];
            col = res[2];
          }
          nvim.pauseNotification();
          if (winid == this.win.winid) {
            if (col <= 3) {
              toggleSelect(lnum - 1);
              this.changeLine(lnum - 1);
            } else {
              this.setCursor(lnum - 1);
            }
          }
          nvim.call("win_gotoid", [winid], true);
          nvim.call("cursor", [lnum, col], true);
          nvim.call("coc#float#nvim_float_click", [], true);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
        });
        this.addKeys(["<esc>", "<C-c>"], () => {
          this._onDidClose.fire(void 0);
          this.dispose();
        });
        this.addKeys("<cr>", () => {
          if (this.picked.size == 0) {
            this._onDidClose.fire(void 0);
          } else {
            let selected = Array.from(this.picked);
            this._onDidClose.fire(selected);
          }
          this.dispose();
        });
        let setCursorIndex = (idx) => {
          nvim.pauseNotification();
          this.setCursor(idx);
          this.win.refreshScrollbar();
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        };
        this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
          let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;
          setCursorIndex(idx);
        });
        this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
          let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;
          setCursorIndex(idx);
        });
        this.addKeys(["g"], () => {
          setCursorIndex(0);
        });
        this.addKeys(["G"], () => {
          setCursorIndex(this.total - 1);
        });
        this.addKeys(" ", async () => {
          let idx = this.currIndex;
          toggleSelect(idx);
          nvim.pauseNotification();
          this.changeLine(idx);
          if (this.currIndex != this.total - 1) {
            this.setCursor(this.currIndex + 1);
          }
          nvim.command("redraw", true);
          await nvim.resumeNotification();
        });
        this.addKeys("<C-f>", async () => {
          var _a2;
          await ((_a2 = this.win) == null ? void 0 : _a2.scrollForward());
        });
        this.addKeys("<C-b>", async () => {
          var _a2;
          await ((_a2 = this.win) == null ? void 0 : _a2.scrollBackward());
        });
      }
      async show(preferences = {}) {
        let { nvim } = this;
        let { title, items } = this.config;
        let opts = { close: 1, cursorline: 1 };
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (title)
          opts.title = title;
        opts.close = 1;
        opts.cursorline = 1;
        if (preferences.floatHighlight) {
          opts.highlight = preferences.floatHighlight;
        }
        if (preferences.floatBorderHighlight) {
          opts.borderhighlight = [preferences.floatBorderHighlight];
        }
        if (preferences.pickerButtons) {
          let shortcut = preferences.pickerButtonShortcut;
          opts.buttons = ["Submit" + (shortcut ? " <cr>" : ""), "Cancel" + (shortcut ? " <esc>" : "")];
        }
        if (preferences.confirmKey && preferences.confirmKey != "<cr>") {
          this.addKeys(preferences.confirmKey, () => {
            this._onDidClose.fire(void 0);
            this.dispose();
          });
        }
        let lines = [];
        let positions2 = [];
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let line = `[${item.picked ? "x" : " "}] ${item.label}`;
          positions2.push([i, byteLength(line)]);
          if (item.description)
            line = line + ` ${item.description}`;
          lines.push(line);
        }
        let res = await nvim.call("coc#float#create_dialog", [lines, opts]);
        this.win = new Popup(nvim, res[0], res[1]);
        this.bufnr = res[1];
        this.attachEvents();
        let buf = nvim.createBuffer(this.bufnr);
        nvim.pauseNotification();
        for (let pos of positions2) {
          buf.addHighlight({ hlGroup: "Comment", line: pos[0], srcId: 1, colStart: pos[1], colEnd: -1 });
        }
        nvim.command("redraw", true);
        await nvim.resumeNotification();
        nvim.call("coc#prompt#start_prompt", ["picker"], true);
        return res[0];
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      dispose() {
        var _a2;
        this.picked.clear();
        this.keyMappings.clear();
        disposeAll(this.disposables);
        this.nvim.call("coc#prompt#stop_prompt", ["picker"], true);
        (_a2 = this.win) == null ? void 0 : _a2.close();
        this.win = void 0;
      }
      async onInputChar(session, character) {
        if (session != "picker" || !this.win)
          return;
        let fn = this.keyMappings.get(character);
        if (fn) {
          await Promise.resolve(fn(character));
        } else {
          logger11.warn(`Ignored key press: ${character}`);
        }
      }
      changeLine(index) {
        let { nvim } = this;
        let item = this.config.items[index];
        if (!item)
          return;
        let line = `[${this.picked.has(index) ? "x" : " "}] ${item.label}`;
        let col = byteLength(line);
        if (item.description)
          line = line + ` ${item.description}`;
        nvim.call("setbufline", [this.bufnr, index + 1, line], true);
        if (!isVim4) {
          let buf = nvim.createBuffer(this.bufnr);
          buf.addHighlight({ hlGroup: "Comment", line: index, srcId: 1, colStart: col, colEnd: -1 });
        }
      }
      setCursor(index) {
        if (!this.win)
          return;
        this.currIndex = index;
        this.win.setCursor(index);
      }
      addKeys(keys, fn) {
        if (Array.isArray(keys)) {
          for (let key of keys) {
            this.keyMappings.set(key, fn);
          }
        } else {
          this.keyMappings.set(keys, fn);
        }
      }
    };
  }
});

// src/model/progress.ts
var import_vscode_languageserver_protocol6, ProgressNotification;
var init_progress = __esm({
  "src/model/progress.ts"() {
    init_notification();
    import_vscode_languageserver_protocol6 = __toModule(require_main2());
    init_events();
    ProgressNotification = class extends Notification {
      constructor(nvim, option) {
        super(nvim, {
          content: "\n",
          close: option.cancellable == true,
          title: option.title
        }, false);
        this.option = option;
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            if (this.tokenSource) {
              this.tokenSource.cancel();
            }
            this.dispose();
          }
        }, null, this.disposables);
      }
      async show(preferences) {
        let { task } = this.option;
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol6.CancellationTokenSource();
        this.disposables.push(tokenSource);
        let total = 0;
        let res = await new Promise((resolve3, reject) => {
          tokenSource.token.onCancellationRequested(() => {
            resolve3(void 0);
          });
          super.show(Object.assign({ minWidth: preferences.minProgressWidth || 30, progress: 1 }, preferences)).then((shown) => {
            if (!shown)
              reject(new Error("Failed to create float window"));
          }).catch(reject);
          task({
            report: (p) => {
              if (!this.bufnr)
                return;
              let text = "";
              if (p.message)
                text += p.message.replace(/\r?\n/g, " ");
              if (p.increment) {
                total += p.increment;
                text = text + (text.length ? ` ${total}%` : `${total}%`);
              }
              this.nvim.call("setbufline", [this.bufnr, 2, text], true);
            }
          }, tokenSource.token).then((res2) => {
            if (this._disposed)
              return;
            setTimeout(() => {
              this.dispose();
            }, 100);
            resolve3(res2);
          }, (err) => {
            if (this._disposed)
              return;
            this.dispose();
            if (err instanceof Error) {
              reject(err);
            } else {
              resolve3(void 0);
            }
          });
        });
        return res;
      }
      dispose() {
        super.dispose();
        this.tokenSource = void 0;
      }
    };
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  return import_crypto.default.randomBytes(16);
}
var import_crypto;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toModule(require("crypto"));
  }
});

// node_modules/uuid/dist/esm-node/bytesToUuid.js
function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join("");
}
var byteToHex, bytesToUuid_default;
var init_bytesToUuid = __esm({
  "node_modules/uuid/dist/esm-node/bytesToUuid.js"() {
    byteToHex = [];
    for (var i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    bytesToUuid_default = bytesToUuid;
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf ? buf : bytesToUuid_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_bytesToUuid();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  var i = buf && offset || 0;
  if (typeof options == "string") {
    buf = options === "binary" ? new Array(16) : null;
    options = null;
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_bytesToUuid();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v4();
  }
});

// src/model/status.ts
var logger12, frames, StatusLine;
var init_status = __esm({
  "src/model/status.ts"() {
    init_esm_node();
    logger12 = require_logger2()("model-status");
    frames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
    StatusLine = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.items = new Map();
        this.shownIds = new Set();
        this._text = "";
        this.interval = setInterval(() => {
          this.setStatusText().logError();
        }, 100);
      }
      dispose() {
        clearInterval(this.interval);
      }
      createStatusBarItem(priority = 0, isProgress = false) {
        let uid = v1_default();
        let item = {
          text: "",
          priority,
          isProgress,
          show: () => {
            this.shownIds.add(uid);
          },
          hide: () => {
            this.shownIds.delete(uid);
          },
          dispose: () => {
            this.shownIds.delete(uid);
            this.items.delete(uid);
          }
        };
        this.items.set(uid, item);
        return item;
      }
      getText() {
        if (this.shownIds.size == 0)
          return "";
        let d = new Date();
        let idx = Math.floor(d.getMilliseconds() / 100);
        let text = "";
        let items = [];
        for (let [id, item] of this.items) {
          if (this.shownIds.has(id)) {
            items.push(item);
          }
        }
        items.sort((a, b) => a.priority - b.priority);
        for (let item of items) {
          if (!item.isProgress) {
            text = `${text} ${item.text}`;
          } else {
            text = `${text} ${frames[idx]} ${item.text}`;
          }
        }
        return text;
      }
      async setStatusText() {
        let text = this.getText();
        let { nvim } = this;
        if (text != this._text) {
          this._text = text;
          nvim.pauseNotification();
          this.nvim.setVar("coc_status", text, true);
          this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
          await nvim.resumeNotification(false, true);
        }
      }
    };
  }
});

// src/types.ts
var PatternType, SourceType, MessageLevel, ConfigurationTarget, ServiceStat, FileType;
var init_types = __esm({
  "src/types.ts"() {
    (function(PatternType2) {
      PatternType2[PatternType2["Buffer"] = 0] = "Buffer";
      PatternType2[PatternType2["LanguageServer"] = 1] = "LanguageServer";
      PatternType2[PatternType2["Global"] = 2] = "Global";
    })(PatternType || (PatternType = {}));
    (function(SourceType2) {
      SourceType2[SourceType2["Native"] = 0] = "Native";
      SourceType2[SourceType2["Remote"] = 1] = "Remote";
      SourceType2[SourceType2["Service"] = 2] = "Service";
    })(SourceType || (SourceType = {}));
    (function(MessageLevel2) {
      MessageLevel2[MessageLevel2["More"] = 0] = "More";
      MessageLevel2[MessageLevel2["Warning"] = 1] = "Warning";
      MessageLevel2[MessageLevel2["Error"] = 2] = "Error";
    })(MessageLevel || (MessageLevel = {}));
    (function(ConfigurationTarget3) {
      ConfigurationTarget3[ConfigurationTarget3["Global"] = 0] = "Global";
      ConfigurationTarget3[ConfigurationTarget3["User"] = 1] = "User";
      ConfigurationTarget3[ConfigurationTarget3["Workspace"] = 2] = "Workspace";
    })(ConfigurationTarget || (ConfigurationTarget = {}));
    (function(ServiceStat2) {
      ServiceStat2[ServiceStat2["Initial"] = 0] = "Initial";
      ServiceStat2[ServiceStat2["Starting"] = 1] = "Starting";
      ServiceStat2[ServiceStat2["StartFailed"] = 2] = "StartFailed";
      ServiceStat2[ServiceStat2["Running"] = 3] = "Running";
      ServiceStat2[ServiceStat2["Stopping"] = 4] = "Stopping";
      ServiceStat2[ServiceStat2["Stopped"] = 5] = "Stopped";
    })(ServiceStat || (ServiceStat = {}));
    (function(FileType2) {
      FileType2[FileType2["Unknown"] = 0] = "Unknown";
      FileType2[FileType2["File"] = 1] = "File";
      FileType2[FileType2["Directory"] = 2] = "Directory";
      FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
    })(FileType || (FileType = {}));
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes2;
    module2.exports.format = format2;
    module2.exports.parse = parse5;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options) {
      if (typeof value === "string") {
        return parse5(value);
      }
      if (typeof value === "number") {
        return format2(value, options);
      }
      return null;
    }
    function format2(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.replace(formatThousandsRegExp, thousandsSeparator);
      }
      return str + unitSeparator + unit;
    }
    function parse5(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// node_modules/fast-diff/diff.js
var require_diff = __commonJS({
  "node_modules/fast-diff/diff.js"(exports2, module2) {
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      return diffs;
    }
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v12 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v12[x] = -1;
        v2[x] = -1;
      }
      v12[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d || k1 !== d && v12[k1_offset - 1] < v12[k1_offset + 1]) {
            x1 = v12[k1_offset + 1];
          } else {
            x1 = v12[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v12[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v12[k1_offset] !== -1) {
              var x1 = v12[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(longtext2.substring(i), shorttext2.substring(j));
          var suffixLength = diff_commonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
      var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k = previous_equality - 1;
                  if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k][1] + text_insert;
                    k--;
                  }
                  if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k][1] + text_delete;
                    k--;
                  }
                  previous_equality = k;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              var n = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n, n);
                pointer = pointer - n;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                pointer = pointer - n + 1;
              } else {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    function starts_with_pair_end(str) {
      return is_surrogate_pair_end(str.charCodeAt(0));
    }
    function ends_with_pair_start(str) {
      return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
    }
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i = 0; i < tuples.length; i++) {
        if (tuples[i][1].length > 0) {
          ret.push(tuples[i]);
        }
      }
      return ret;
    }
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    function diff(text1, text2, cursor_pos) {
      return diff_main(text1, text2, cursor_pos, true);
    }
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module2.exports = diff;
  }
});

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  var p = data.length / 2 | 0;
  var left = data.slice(0, p);
  var right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  var leftIdx = 0;
  var rightIdx = 0;
  var i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    var ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset) {
  if (textOffset === void 0) {
    textOffset = 0;
  }
  var result = isAtLineStart ? [textOffset] : [];
  for (var i = 0; i < text.length; i++) {
    var ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function getWellformedRange(range) {
  var start = range.start;
  var end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  var range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}
var FullTextDocument2, TextDocument2;
var init_main2 = __esm({
  "node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
    "use strict";
    FullTextDocument2 = function() {
      function FullTextDocument3(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument3.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: true,
        configurable: true
      });
      FullTextDocument3.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument3.prototype.update = function(changes, version2) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
          var change = changes_1[_i];
          if (FullTextDocument3.isIncremental(change)) {
            var range = getWellformedRange(change.range);
            var startOffset = this.offsetAt(range.start);
            var endOffset = this.offsetAt(range.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            var startLine = Math.max(range.start.line, 0);
            var endLine = Math.max(range.end.line, 0);
            var lineOffsets = this._lineOffsets;
            var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            var diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (FullTextDocument3.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version2;
      };
      FullTextDocument3.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      };
      FullTextDocument3.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      };
      FullTextDocument3.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
      });
      FullTextDocument3.isIncremental = function(event) {
        var candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      };
      FullTextDocument3.isFull = function(event) {
        var candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      };
      return FullTextDocument3;
    }();
    (function(TextDocument5) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument2(uri, languageId, version2, content);
      }
      TextDocument5.create = create;
      function update(document2, changes, version2) {
        if (document2 instanceof FullTextDocument2) {
          document2.update(changes, version2);
          return document2;
        } else {
          throw new Error("TextDocument.update: document must be created by TextDocument.create");
        }
      }
      TextDocument5.update = update;
      function applyEdits2(document2, edits) {
        var text = document2.getText();
        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = 0;
        var spans = [];
        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
          var e = sortedEdits_1[_i];
          var startOffset = document2.offsetAt(e.range.start);
          if (startOffset < lastModifiedOffset) {
            throw new Error("Overlapping edit");
          } else if (startOffset > lastModifiedOffset) {
            spans.push(text.substring(lastModifiedOffset, startOffset));
          }
          if (e.newText.length) {
            spans.push(e.newText);
          }
          lastModifiedOffset = document2.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join("");
      }
      TextDocument5.applyEdits = applyEdits2;
    })(TextDocument2 || (TextDocument2 = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/scanner.js
function createScanner(text, ignoreTrivia) {
  if (ignoreTrivia === void 0) {
    ignoreTrivia = false;
  }
  var len = text.length;
  var pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    var digits = 0;
    var value2 = 0;
    while (digits < count || !exact) {
      var ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    var start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    var end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    var result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      var ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        var ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            var ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    var code = text.charCodeAt(pos);
    if (isWhiteSpace(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhiteSpace(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code) {
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      case 47:
        var start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          var safeLength = len - 1;
          var commentClosed = false;
          while (pos < safeLength) {
            var ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhiteSpace(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    var result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: function() {
      return pos;
    },
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: function() {
      return token;
    },
    getTokenValue: function() {
      return value;
    },
    getTokenOffset: function() {
      return tokenOffset;
    },
    getTokenLength: function() {
      return pos - tokenOffset;
    },
    getTokenStartLine: function() {
      return lineStartOffset;
    },
    getTokenStartCharacter: function() {
      return tokenOffset - prevTokenLineStartOffset;
    },
    getTokenError: function() {
      return scanError;
    }
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch >= 8192 && ch <= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var init_scanner = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/scanner.js"() {
    "use strict";
  }
});

// node_modules/jsonc-parser/lib/esm/impl/format.js
function format(documentText, range, options) {
  var initialIndentLevel;
  var formatText;
  var formatTextStart;
  var rangeStart;
  var rangeEnd;
  if (range) {
    rangeStart = range.offset;
    rangeEnd = rangeStart + range.length;
    formatTextStart = rangeStart;
    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
      formatTextStart--;
    }
    var endOffset = rangeEnd;
    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
      endOffset++;
    }
    formatText = documentText.substring(formatTextStart, endOffset);
    initialIndentLevel = computeIndentLevel(formatText, options);
  } else {
    formatText = documentText;
    initialIndentLevel = 0;
    formatTextStart = 0;
    rangeStart = 0;
    rangeEnd = documentText.length;
  }
  var eol = getEOL(options, documentText);
  var lineBreak = false;
  var indentLevel = 0;
  var indentValue;
  if (options.insertSpaces) {
    indentValue = repeat(" ", options.tabSize || 4);
  } else {
    indentValue = "	";
  }
  var scanner2 = createScanner(formatText, false);
  var hasError = false;
  function newLineAndIndent() {
    return eol + repeat(indentValue, initialIndentLevel + indentLevel);
  }
  function scanNext() {
    var token = scanner2.scan();
    lineBreak = false;
    while (token === 15 || token === 14) {
      lineBreak = lineBreak || token === 14;
      token = scanner2.scan();
    }
    hasError = token === 16 || scanner2.getTokenError() !== 0;
    return token;
  }
  var editOperations = [];
  function addEdit(text, startOffset, endOffset2) {
    if (!hasError && (!range || startOffset < rangeEnd && endOffset2 > rangeStart) && documentText.substring(startOffset, endOffset2) !== text) {
      editOperations.push({ offset: startOffset, length: endOffset2 - startOffset, content: text });
    }
  }
  var firstToken = scanNext();
  if (firstToken !== 17) {
    var firstTokenStart = scanner2.getTokenOffset() + formatTextStart;
    var initialIndent = repeat(indentValue, initialIndentLevel);
    addEdit(initialIndent, formatTextStart, firstTokenStart);
  }
  while (firstToken !== 17) {
    var firstTokenEnd = scanner2.getTokenOffset() + scanner2.getTokenLength() + formatTextStart;
    var secondToken = scanNext();
    var replaceContent = "";
    var needsLineBreak = false;
    while (!lineBreak && (secondToken === 12 || secondToken === 13)) {
      var commentTokenStart = scanner2.getTokenOffset() + formatTextStart;
      addEdit(" ", firstTokenEnd, commentTokenStart);
      firstTokenEnd = scanner2.getTokenOffset() + scanner2.getTokenLength() + formatTextStart;
      needsLineBreak = secondToken === 12;
      replaceContent = needsLineBreak ? newLineAndIndent() : "";
      secondToken = scanNext();
    }
    if (secondToken === 2) {
      if (firstToken !== 1) {
        indentLevel--;
        replaceContent = newLineAndIndent();
      }
    } else if (secondToken === 4) {
      if (firstToken !== 3) {
        indentLevel--;
        replaceContent = newLineAndIndent();
      }
    } else {
      switch (firstToken) {
        case 3:
        case 1:
          indentLevel++;
          replaceContent = newLineAndIndent();
          break;
        case 5:
        case 12:
          replaceContent = newLineAndIndent();
          break;
        case 13:
          if (lineBreak) {
            replaceContent = newLineAndIndent();
          } else if (!needsLineBreak) {
            replaceContent = " ";
          }
          break;
        case 6:
          if (!needsLineBreak) {
            replaceContent = " ";
          }
          break;
        case 10:
          if (secondToken === 6) {
            if (!needsLineBreak) {
              replaceContent = "";
            }
            break;
          }
        case 7:
        case 8:
        case 9:
        case 11:
        case 2:
        case 4:
          if (secondToken === 12 || secondToken === 13) {
            if (!needsLineBreak) {
              replaceContent = " ";
            }
          } else if (secondToken !== 5 && secondToken !== 17) {
            hasError = true;
          }
          break;
        case 16:
          hasError = true;
          break;
      }
      if (lineBreak && (secondToken === 12 || secondToken === 13)) {
        replaceContent = newLineAndIndent();
      }
    }
    if (secondToken === 17) {
      replaceContent = options.insertFinalNewline ? eol : "";
    }
    var secondTokenStart = scanner2.getTokenOffset() + formatTextStart;
    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
    firstToken = secondToken;
  }
  return editOperations;
}
function repeat(s, count) {
  var result = "";
  for (var i = 0; i < count; i++) {
    result += s;
  }
  return result;
}
function computeIndentLevel(content, options) {
  var i = 0;
  var nChars = 0;
  var tabSize = options.tabSize || 4;
  while (i < content.length) {
    var ch = content.charAt(i);
    if (ch === " ") {
      nChars++;
    } else if (ch === "	") {
      nChars += tabSize;
    } else {
      break;
    }
    i++;
  }
  return Math.floor(nChars / tabSize);
}
function getEOL(options, text) {
  for (var i = 0; i < text.length; i++) {
    var ch = text.charAt(i);
    if (ch === "\r") {
      if (i + 1 < text.length && text.charAt(i + 1) === "\n") {
        return "\r\n";
      }
      return "\r";
    } else if (ch === "\n") {
      return "\n";
    }
  }
  return options && options.eol || "\n";
}
function isEOL(text, offset) {
  return "\r\n".indexOf(text.charAt(offset)) !== -1;
}
var init_format = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/format.js"() {
    init_scanner();
    "use strict";
  }
});

// node_modules/jsonc-parser/lib/esm/impl/parser.js
function parse2(text, errors, options) {
  if (errors === void 0) {
    errors = [];
  }
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var currentProperty = null;
  var currentParent = [];
  var previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  var visitor = {
    onObjectBegin: function() {
      var object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: function(name2) {
      currentProperty = name2;
    },
    onObjectEnd: function() {
      currentParent = previousParents.pop();
    },
    onArrayBegin: function() {
      var array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: function() {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: function(error, offset, length) {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options);
  return currentParent[0];
}
function parseTree(text, errors, options) {
  if (errors === void 0) {
    errors = [];
  }
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var currentParent = { type: "array", offset: -1, length: -1, children: [], parent: void 0 };
  function ensurePropertyComplete(endOffset) {
    if (currentParent.type === "property") {
      currentParent.length = endOffset - currentParent.offset;
      currentParent = currentParent.parent;
    }
  }
  function onValue(valueNode) {
    currentParent.children.push(valueNode);
    return valueNode;
  }
  var visitor = {
    onObjectBegin: function(offset) {
      currentParent = onValue({ type: "object", offset, length: -1, parent: currentParent, children: [] });
    },
    onObjectProperty: function(name2, offset, length) {
      currentParent = onValue({ type: "property", offset, length: -1, parent: currentParent, children: [] });
      currentParent.children.push({ type: "string", value: name2, offset, length, parent: currentParent });
    },
    onObjectEnd: function(offset, length) {
      ensurePropertyComplete(offset + length);
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onArrayBegin: function(offset, length) {
      currentParent = onValue({ type: "array", offset, length: -1, parent: currentParent, children: [] });
    },
    onArrayEnd: function(offset, length) {
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onLiteralValue: function(value, offset, length) {
      onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });
      ensurePropertyComplete(offset + length);
    },
    onSeparator: function(sep, offset, length) {
      if (currentParent.type === "property") {
        if (sep === ":") {
          currentParent.colonOffset = offset;
        } else if (sep === ",") {
          ensurePropertyComplete(offset);
        }
      }
    },
    onError: function(error, offset, length) {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options);
  var result = currentParent.children[0];
  if (result) {
    delete result.parent;
  }
  return result;
}
function findNodeAtLocation(root, path36) {
  if (!root) {
    return void 0;
  }
  var node = root;
  for (var _i = 0, path_1 = path36; _i < path_1.length; _i++) {
    var segment = path_1[_i];
    if (typeof segment === "string") {
      if (node.type !== "object" || !Array.isArray(node.children)) {
        return void 0;
      }
      var found = false;
      for (var _a2 = 0, _b = node.children; _a2 < _b.length; _a2++) {
        var propertyNode = _b[_a2];
        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
          node = propertyNode.children[1];
          found = true;
          break;
        }
      }
      if (!found) {
        return void 0;
      }
    } else {
      var index = segment;
      if (node.type !== "array" || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
        return void 0;
      }
      node = node.children[index];
    }
  }
  return node;
}
function visit(text, visitor, options) {
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var _scanner = createScanner(text, false);
  function toNoArgVisit(visitFunction) {
    return visitFunction ? function() {
      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? function(arg) {
      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  var disallowComments = options && options.disallowComments;
  var allowTrailingComma = options && options.allowTrailingComma;
  function scanNext() {
    while (true) {
      var token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(14);
          break;
        case 5:
          handleError(15);
          break;
        case 3:
          handleError(13);
          break;
        case 1:
          if (!disallowComments) {
            handleError(11);
          }
          break;
        case 2:
          handleError(12);
          break;
        case 6:
          handleError(16);
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(10);
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter, skipUntil) {
    if (skipUntilAfter === void 0) {
      skipUntilAfter = [];
    }
    if (skipUntil === void 0) {
      skipUntil = [];
    }
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      var token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    var value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        var tokenValue = _scanner.getTokenValue();
        var value = Number(tokenValue);
        if (isNaN(value)) {
          handleError(2);
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [2, 5]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [2, 5]);
      }
    } else {
      handleError(5, [], [2, 5]);
    }
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [2, 5]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [2], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseValue()) {
        handleError(4, [], [4, 5]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (_scanner.getToken() !== 4) {
      handleError(8, [4], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}
function getNodeType(value) {
  switch (typeof value) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "object": {
      if (!value) {
        return "null";
      } else if (Array.isArray(value)) {
        return "array";
      }
      return "object";
    }
    default:
      return "null";
  }
}
var ParseOptions;
var init_parser = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/parser.js"() {
    init_scanner();
    "use strict";
    (function(ParseOptions2) {
      ParseOptions2.DEFAULT = {
        allowTrailingComma: false
      };
    })(ParseOptions || (ParseOptions = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/edit.js
function setProperty(text, originalPath, value, options) {
  var _a2;
  var path36 = originalPath.slice();
  var errors = [];
  var root = parseTree(text, errors);
  var parent = void 0;
  var lastSegment = void 0;
  while (path36.length > 0) {
    lastSegment = path36.pop();
    parent = findNodeAtLocation(root, path36);
    if (parent === void 0 && value !== void 0) {
      if (typeof lastSegment === "string") {
        value = (_a2 = {}, _a2[lastSegment] = value, _a2);
      } else {
        value = [value];
      }
    } else {
      break;
    }
  }
  if (!parent) {
    if (value === void 0) {
      throw new Error("Can not delete in empty document");
    }
    return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);
  } else if (parent.type === "object" && typeof lastSegment === "string" && Array.isArray(parent.children)) {
    var existing = findNodeAtLocation(parent, [lastSegment]);
    if (existing !== void 0) {
      if (value === void 0) {
        if (!existing.parent) {
          throw new Error("Malformed AST");
        }
        var propertyIndex = parent.children.indexOf(existing.parent);
        var removeBegin = void 0;
        var removeEnd = existing.parent.offset + existing.parent.length;
        if (propertyIndex > 0) {
          var previous = parent.children[propertyIndex - 1];
          removeBegin = previous.offset + previous.length;
        } else {
          removeBegin = parent.offset + 1;
          if (parent.children.length > 1) {
            var next = parent.children[1];
            removeEnd = next.offset;
          }
        }
        return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: "" }, options);
      } else {
        return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);
      }
    } else {
      if (value === void 0) {
        return [];
      }
      var newProperty = JSON.stringify(lastSegment) + ": " + JSON.stringify(value);
      var index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(function(p) {
        return p.children[0].value;
      })) : parent.children.length;
      var edit2 = void 0;
      if (index > 0) {
        var previous = parent.children[index - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      } else if (parent.children.length === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty + "," };
      }
      return withFormatting(text, edit2, options);
    }
  } else if (parent.type === "array" && typeof lastSegment === "number" && Array.isArray(parent.children)) {
    var insertIndex = lastSegment;
    if (insertIndex === -1) {
      var newProperty = "" + JSON.stringify(value);
      var edit2 = void 0;
      if (parent.children.length === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        var previous = parent.children[parent.children.length - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit2, options);
    } else if (value === void 0 && parent.children.length >= 0) {
      var removalIndex = lastSegment;
      var toRemove = parent.children[removalIndex];
      var edit2 = void 0;
      if (parent.children.length === 1) {
        edit2 = { offset: parent.offset + 1, length: parent.length - 2, content: "" };
      } else if (parent.children.length - 1 === removalIndex) {
        var previous = parent.children[removalIndex - 1];
        var offset = previous.offset + previous.length;
        var parentEndOffset = parent.offset + parent.length;
        edit2 = { offset, length: parentEndOffset - 2 - offset, content: "" };
      } else {
        edit2 = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: "" };
      }
      return withFormatting(text, edit2, options);
    } else if (value !== void 0) {
      var edit2 = void 0;
      var newProperty = "" + JSON.stringify(value);
      if (!options.isArrayInsertion && parent.children.length > lastSegment) {
        var toModify = parent.children[lastSegment];
        edit2 = { offset: toModify.offset, length: toModify.length, content: newProperty };
      } else if (parent.children.length === 0 || lastSegment === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + "," };
      } else {
        var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
        var previous = parent.children[index - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit2, options);
    } else {
      throw new Error("Can not " + (value === void 0 ? "remove" : options.isArrayInsertion ? "insert" : "modify") + " Array index " + insertIndex + " as length is not sufficient");
    }
  } else {
    throw new Error("Can not add " + (typeof lastSegment !== "number" ? "index" : "property") + " to parent of type " + parent.type);
  }
}
function withFormatting(text, edit2, options) {
  if (!options.formattingOptions) {
    return [edit2];
  }
  var newText = applyEdit(text, edit2);
  var begin = edit2.offset;
  var end = edit2.offset + edit2.content.length;
  if (edit2.length === 0 || edit2.content.length === 0) {
    while (begin > 0 && !isEOL(newText, begin - 1)) {
      begin--;
    }
    while (end < newText.length && !isEOL(newText, end)) {
      end++;
    }
  }
  var edits = format(newText, { offset: begin, length: end - begin }, options.formattingOptions);
  for (var i = edits.length - 1; i >= 0; i--) {
    var edit_1 = edits[i];
    newText = applyEdit(newText, edit_1);
    begin = Math.min(begin, edit_1.offset);
    end = Math.max(end, edit_1.offset + edit_1.length);
    end += edit_1.content.length - edit_1.length;
  }
  var editLength = text.length - (newText.length - end) - begin;
  return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function applyEdit(text, edit2) {
  return text.substring(0, edit2.offset) + edit2.content + text.substring(edit2.offset + edit2.length);
}
var init_edit = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/edit.js"() {
    init_format();
    init_parser();
    "use strict";
  }
});

// node_modules/jsonc-parser/lib/esm/main.js
function modify(text, path36, value, options) {
  return setProperty(text, path36, value, options);
}
function applyEdits(text, edits) {
  for (var i = edits.length - 1; i >= 0; i--) {
    text = applyEdit(text, edits[i]);
  }
  return text;
}
var parse3;
var init_main3 = __esm({
  "node_modules/jsonc-parser/lib/esm/main.js"() {
    init_format();
    init_edit();
    init_scanner();
    init_parser();
    "use strict";
    parse3 = parse2;
  }
});

// src/configuration/util.ts
function parseContentFromFile(filepath, onError) {
  if (!filepath || !import_fs2.default.existsSync(filepath))
    return { contents: {} };
  let content;
  let uri = URI.file(filepath).toString();
  try {
    content = import_fs2.default.readFileSync(filepath, "utf8");
  } catch (_e) {
    content = "";
  }
  let [errors, contents] = parseConfiguration(content);
  if (errors && errors.length) {
    onError(convertErrors(uri, content, errors));
  }
  return { contents };
}
function parseConfiguration(content) {
  if (content.length == 0)
    return [[], {}];
  let errors = [];
  let data = parse3(content, errors, { allowTrailingComma: true });
  function addProperty(current, key, remains, value) {
    if (remains.length == 0) {
      current[key] = convert(value);
    } else {
      if (!current[key])
        current[key] = {};
      let o = current[key];
      let first = remains.shift();
      addProperty(o, first, remains, value);
    }
  }
  function convert(obj, split = false) {
    if (!objectLiteral(obj))
      return obj;
    if (emptyObject(obj))
      return {};
    let dest = {};
    for (let key of Object.keys(obj)) {
      if (split && key.includes(".")) {
        let parts = key.split(".");
        let first = parts.shift();
        addProperty(dest, first, parts, obj[key]);
      } else {
        dest[key] = convert(obj[key]);
      }
    }
    return dest;
  }
  return [errors, convert(data, true)];
}
function convertErrors(uri, content, errors) {
  let items = [];
  let document2 = TextDocument2.create(uri, "json", 0, content);
  for (let err of errors) {
    let msg = "parse error";
    switch (err.error) {
      case 2:
        msg = "invalid number";
        break;
      case 8:
        msg = "close brace expected";
        break;
      case 5:
        msg = "colon expected";
        break;
      case 6:
        msg = "comma expected";
        break;
      case 9:
        msg = "end of file expected";
        break;
      case 16:
        msg = "invaliad character";
        break;
      case 10:
        msg = "invalid commment token";
        break;
      case 15:
        msg = "invalid escape character";
        break;
      case 1:
        msg = "invalid symbol";
        break;
      case 14:
        msg = "invalid unicode";
        break;
      case 3:
        msg = "property name expected";
        break;
      case 13:
        msg = "unexpected end of number";
        break;
      case 12:
        msg = "unexpected end of string";
        break;
      case 11:
        msg = "unexpected end of comment";
        break;
      case 4:
        msg = "value expected";
        break;
      default:
        msg = "Unknwn error";
        break;
    }
    let range = {
      start: document2.positionAt(err.offset),
      end: document2.positionAt(err.offset + err.length)
    };
    let loc = import_vscode_languageserver_protocol7.Location.create(uri, range);
    items.push({ location: loc, message: msg });
  }
  return items;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
  const segments = key.split(".");
  const last = segments.pop();
  let curr = settingsTreeRoot;
  for (let i = 0; i < segments.length; i++) {
    let s = segments[i];
    let obj = curr[s];
    switch (typeof obj) {
      case "function": {
        obj = curr[s] = {};
        break;
      }
      case "undefined": {
        obj = curr[s] = {};
        break;
      }
      case "object":
        break;
      default:
        conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is ${JSON.stringify(obj)}`);
        return;
    }
    curr = obj;
  }
  if (typeof curr === "object") {
    curr[last] = value;
  } else {
    conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
  }
}
function removeFromValueTree(valueTree, key) {
  const segments = key.split(".");
  doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
  const first = segments.shift();
  if (segments.length === 0) {
    delete valueTree[first];
    return;
  }
  if (Object.keys(valueTree).includes(first)) {
    const value = valueTree[first];
    if (typeof value === "object" && !Array.isArray(value)) {
      doRemoveFromValueTree(value, segments);
      if (Object.keys(value).length === 0) {
        delete valueTree[first];
      }
    }
  }
}
function getConfigurationValue(config, settingPath, defaultValue) {
  function accessSetting(config2, path37) {
    let current = config2;
    for (let i = 0; i < path37.length; i++) {
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[path37[i]];
    }
    return current;
  }
  const path36 = settingPath.split(".");
  const result = accessSetting(config, path36);
  return typeof result === "undefined" ? defaultValue : result;
}
function loadDefaultConfigurations() {
  let file = import_path2.default.join(pluginRoot, "data/schema.json");
  if (!import_fs2.default.existsSync(file)) {
    console.error("schema.json not found, reinstall coc.nvim to fix this!");
    return { contents: {} };
  }
  let content = import_fs2.default.readFileSync(file, "utf8");
  let { properties } = JSON.parse(content);
  let config = {};
  Object.keys(properties).forEach((key) => {
    let value = properties[key].default;
    if (value !== void 0) {
      addToValueTree(config, key, value, (message) => {
        logger13.error(message);
      });
    }
  });
  return { contents: config };
}
function getKeys(obj, curr) {
  let keys = [];
  for (let key of Object.keys(obj)) {
    let val = obj[key];
    let newKey = curr ? `${curr}.${key}` : key;
    keys.push(newKey);
    if (objectLiteral(val)) {
      keys.push(...getKeys(val, newKey));
    }
  }
  return keys;
}
function getChangedKeys(from, to) {
  let keys = [];
  let fromKeys = getKeys(from);
  let toKeys = getKeys(to);
  const added = toKeys.filter((key) => !fromKeys.includes(key));
  const removed = fromKeys.filter((key) => !toKeys.includes(key));
  keys.push(...added);
  keys.push(...removed);
  for (const key of fromKeys) {
    if (!toKeys.includes(key))
      continue;
    const value1 = getConfigurationValue(from, key);
    const value2 = getConfigurationValue(to, key);
    if (!equals(value1, value2)) {
      keys.push(key);
    }
  }
  return keys;
}
var import_vscode_languageserver_protocol7, import_fs2, import_path2, logger13, pluginRoot;
var init_util2 = __esm({
  "src/configuration/util.ts"() {
    import_vscode_languageserver_protocol7 = __toModule(require_main2());
    init_main2();
    init_main3();
    init_is();
    init_object();
    import_fs2 = __toModule(require("fs"));
    init_esm2();
    import_path2 = __toModule(require("path"));
    logger13 = require_logger2()("configuration-util");
    pluginRoot = false ? resolve(__dirname, "../..") : (0, import_path2.dirname)(__dirname);
  }
});

// src/configuration/model.ts
var ConfigurationModel;
var init_model = __esm({
  "src/configuration/model.ts"() {
    init_is();
    init_object();
    init_util2();
    ConfigurationModel = class {
      constructor(_contents = {}) {
        this._contents = _contents;
      }
      get contents() {
        return this._contents;
      }
      clone() {
        return new ConfigurationModel(deepClone(this._contents));
      }
      getValue(section2) {
        let res = section2 ? getConfigurationValue(this.contents, section2) : this.contents;
        return res;
      }
      merge(...others) {
        const contents = deepClone(this.contents);
        for (const other of others) {
          this.mergeContents(contents, other.contents);
        }
        return new ConfigurationModel(contents);
      }
      freeze() {
        if (!Object.isFrozen(this._contents)) {
          Object.freeze(this._contents);
        }
        return this;
      }
      mergeContents(source, target) {
        for (const key of Object.keys(target)) {
          if (key in source) {
            if (objectLiteral(source[key]) && objectLiteral(target[key])) {
              this.mergeContents(source[key], target[key]);
              continue;
            }
          }
          source[key] = deepClone(target[key]);
        }
      }
      setValue(key, value) {
        addToValueTree(this.contents, key, value, (message) => {
          console.error(message);
        });
      }
      removeValue(key) {
        removeFromValueTree(this.contents, key);
      }
    };
  }
});

// src/configuration/configuration.ts
var Configuration;
var init_configuration = __esm({
  "src/configuration/configuration.ts"() {
    init_model();
    Configuration = class {
      constructor(_defaultConfiguration, _userConfiguration, _workspaceConfiguration, _memoryConfiguration = new ConfigurationModel()) {
        this._defaultConfiguration = _defaultConfiguration;
        this._userConfiguration = _userConfiguration;
        this._workspaceConfiguration = _workspaceConfiguration;
        this._memoryConfiguration = _memoryConfiguration;
      }
      getConsolidateConfiguration() {
        if (!this._consolidateConfiguration) {
          this._consolidateConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
          this._consolidateConfiguration = this._consolidateConfiguration.freeze();
        }
        return this._consolidateConfiguration;
      }
      getValue(section2) {
        let configuration = this.getConsolidateConfiguration();
        return configuration.getValue(section2);
      }
      inspect(key) {
        const consolidateConfigurationModel = this.getConsolidateConfiguration();
        const { _workspaceConfiguration, _memoryConfiguration } = this;
        return {
          default: this._defaultConfiguration.freeze().getValue(key),
          user: this._userConfiguration.freeze().getValue(key),
          workspace: _workspaceConfiguration.freeze().getValue(key),
          memory: _memoryConfiguration.freeze().getValue(key),
          value: consolidateConfigurationModel.getValue(key)
        };
      }
      get defaults() {
        return this._defaultConfiguration;
      }
      get user() {
        return this._userConfiguration;
      }
      get workspace() {
        return this._workspaceConfiguration;
      }
      toData() {
        return {
          defaults: {
            contents: this._defaultConfiguration.contents
          },
          user: {
            contents: this._userConfiguration.contents
          },
          workspace: {
            contents: this._workspaceConfiguration.contents
          }
        };
      }
    };
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad2 = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad2) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch8;
    minimatch8.Minimatch = Minimatch2;
    var path36 = { sep: "/" };
    try {
      path36 = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch8.GLOBSTAR = Minimatch2.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch8.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list2) {
        return minimatch8(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch8.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch8;
      var orig = minimatch8;
      var m = function minimatch9(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch3(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch2.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch2;
      return minimatch8.defaults(def).Minimatch;
    };
    function minimatch8(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch2(pattern, options).match(p);
    }
    function Minimatch2(pattern, options) {
      if (!(this instanceof Minimatch2)) {
        return new Minimatch2(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path36.sep !== "/") {
        pattern = pattern.split(path36.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch2.prototype.debug = function() {
    };
    Minimatch2.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch2.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch8.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch2.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch2) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch2.prototype.parse = parse5;
    var SUBPARSE = {};
    function parse5(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch8.makeRe = function(pattern, options) {
      return new Minimatch2(pattern, options || {}).makeRe();
    };
    Minimatch2.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch8.match = function(list2, pattern, options) {
      options = options || {};
      var mm = new Minimatch2(pattern, options);
      list2 = list2.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern);
      }
      return list2;
    };
    Minimatch2.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path36.sep !== "/") {
        f = f.split(path36.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch2.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// src/util/fs.ts
async function statAsync(filepath) {
  let stat = null;
  try {
    stat = await import_fs_extra.default.stat(filepath);
  } catch (e) {
  }
  return stat;
}
function renameAsync(oldPath, newPath) {
  return new Promise((resolve3, reject) => {
    import_fs_extra.default.rename(oldPath, newPath, (err) => {
      if (err)
        return reject(err);
      resolve3();
    });
  });
}
function resolveRoot(folder, subs, cwd, bottomup = false, checkCwd = true) {
  let home = import_os.default.homedir();
  let dir = fixDriver(folder);
  if (isParentFolder(dir, home, true))
    return null;
  if (checkCwd && cwd && isParentFolder(cwd, dir, true) && inDirectory(cwd, subs))
    return cwd;
  let parts = dir.split(import_path3.default.sep);
  if (bottomup) {
    while (parts.length > 0) {
      let dir2 = parts.join(import_path3.default.sep);
      if (dir2 == home) {
        break;
      }
      if (dir2 != home && inDirectory(dir2, subs)) {
        return dir2;
      }
      parts.pop();
    }
    return null;
  } else {
    let curr = [parts.shift()];
    for (let part of parts) {
      curr.push(part);
      let dir2 = curr.join(import_path3.default.sep);
      if (dir2 != home && inDirectory(dir2, subs)) {
        return dir2;
      }
    }
    return null;
  }
}
function inDirectory(dir, subs) {
  try {
    let files = import_fs_extra.default.readdirSync(dir);
    for (let pattern of subs) {
      let is_wildcard = pattern.includes("*");
      let res = is_wildcard ? import_minimatch.default.match(files, pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }).length !== 0 : files.includes(pattern);
      if (res)
        return true;
    }
  } catch (e) {
  }
  return false;
}
function findUp(name2, cwd) {
  let root = import_path3.default.parse(cwd).root;
  let subs = Array.isArray(name2) ? name2 : [name2];
  while (cwd && cwd !== root) {
    let find = inDirectory(cwd, subs);
    if (find) {
      for (let sub of subs) {
        let filepath = import_path3.default.join(cwd, sub);
        if (import_fs_extra.default.existsSync(filepath)) {
          return filepath;
        }
      }
    }
    cwd = import_path3.default.dirname(cwd);
  }
  return null;
}
function readFile(fullpath, encoding) {
  return new Promise((resolve3, reject) => {
    import_fs_extra.default.readFile(fullpath, encoding, (err, content) => {
      if (err)
        reject(err);
      resolve3(content);
    });
  });
}
function getFileLineCount(filepath) {
  let i;
  let count = 0;
  return new Promise((resolve3, reject) => {
    import_fs_extra.default.createReadStream(filepath).on("error", (e) => reject(e)).on("data", (chunk) => {
      for (i = 0; i < chunk.length; ++i)
        if (chunk[i] == 10)
          count++;
    }).on("end", () => resolve3(count));
  });
}
function readFileLines(fullpath, start, end) {
  if (!import_fs_extra.default.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  let res = [];
  const rl = import_readline.default.createInterface({
    input: import_fs_extra.default.createReadStream(fullpath, { encoding: "utf8" }),
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve3, reject) => {
    rl.on("line", (line) => {
      if (n == 0 && line.startsWith("\uFEFF")) {
        line = line.slice(1);
      }
      if (n >= start && n <= end) {
        res.push(line);
      }
      if (n == end) {
        rl.close();
      }
      n = n + 1;
    });
    rl.on("close", () => {
      resolve3(res);
    });
    rl.on("error", reject);
  });
}
function readFileLine(fullpath, count) {
  if (!import_fs_extra.default.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  const rl = import_readline.default.createInterface({
    input: import_fs_extra.default.createReadStream(fullpath, { encoding: "utf8" }),
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve3, reject) => {
    rl.on("line", (line) => {
      if (n == count) {
        if (n == 0 && line.startsWith("\uFEFF")) {
          line = line.slice(1);
        }
        rl.close();
        resolve3(line);
        return;
      }
      n = n + 1;
    });
    rl.on("error", reject);
  });
}
async function writeFile(fullpath, content) {
  await import_fs_extra.default.writeFile(fullpath, content, { encoding: "utf8" });
}
function isFile(uri) {
  return uri.startsWith("file:");
}
function isParentFolder(folder, filepath, checkEqual = false) {
  let pdir = fixDriver(import_path3.default.resolve(import_path3.default.normalize(folder)));
  let dir = fixDriver(import_path3.default.resolve(import_path3.default.normalize(filepath)));
  if (pdir == "//")
    pdir = "/";
  if (pdir == dir)
    return checkEqual ? true : false;
  if (pdir.endsWith(import_path3.default.sep))
    return dir.startsWith(pdir);
  return dir.startsWith(pdir) && dir[pdir.length] == import_path3.default.sep;
}
function fixDriver(filepath) {
  if (import_os.default.platform() != "win32" || filepath[1] != ":")
    return filepath;
  return filepath[0].toUpperCase() + filepath.slice(1);
}
var import_child_process2, import_fs_extra, import_net, import_os, import_path3, import_readline, import_util9, import_minimatch, logger14;
var init_fs = __esm({
  "src/util/fs.ts"() {
    import_child_process2 = __toModule(require("child_process"));
    import_fs_extra = __toModule(require_lib5());
    import_net = __toModule(require("net"));
    import_os = __toModule(require("os"));
    import_path3 = __toModule(require("path"));
    import_readline = __toModule(require("readline"));
    import_util9 = __toModule(require("util"));
    import_minimatch = __toModule(require_minimatch());
    logger14 = require_logger2()("util-fs");
  }
});

// src/configuration/index.ts
function lookUp(tree, key) {
  if (key) {
    if (tree && tree.hasOwnProperty(key))
      return tree[key];
    const parts = key.split(".");
    let node = tree;
    for (let i = 0; node && i < parts.length; i++) {
      node = node[parts[i]];
    }
    return node;
  }
  return tree;
}
var import_os2, import_fs3, import_path4, import_vscode_languageserver_protocol8, logger15, Configurations;
var init_configuration2 = __esm({
  "src/configuration/index.ts"() {
    import_os2 = __toModule(require("os"));
    import_fs3 = __toModule(require("fs"));
    import_path4 = __toModule(require("path"));
    import_vscode_languageserver_protocol8 = __toModule(require_main2());
    init_esm2();
    init_types();
    init_object();
    init_util();
    init_configuration();
    init_model();
    init_util2();
    init_is();
    init_fs();
    logger15 = require_logger2()("configurations");
    Configurations = class {
      constructor(userConfigFile, _proxy) {
        this.userConfigFile = userConfigFile;
        this._proxy = _proxy;
        this._errorItems = [];
        this._folderConfigurations = new Map();
        this._onError = new import_vscode_languageserver_protocol8.Emitter();
        this._onChange = new import_vscode_languageserver_protocol8.Emitter();
        this.disposables = [];
        this.onError = this._onError.event;
        this.onDidChange = this._onChange.event;
        let user = this.parseContentFromFile(userConfigFile);
        let data = {
          defaults: loadDefaultConfigurations(),
          user,
          workspace: { contents: {} }
        };
        this._configuration = Configurations.parse(data);
        this.watchFile(userConfigFile, ConfigurationTarget.User);
        let folderConfigFile = import_path4.default.join(process.cwd(), `.vim/${CONFIG_FILE_NAME}`);
        if (folderConfigFile != userConfigFile && import_fs3.default.existsSync(folderConfigFile)) {
          this.addFolderFile(folderConfigFile);
        }
      }
      parseContentFromFile(filepath) {
        if (!filepath)
          return { contents: {} };
        let uri = URI.file(filepath).toString();
        this._errorItems = this._errorItems.filter((o) => o.location.uri != uri);
        let res = parseContentFromFile(filepath, (errors) => {
          this._errorItems.push(...errors);
        });
        this._onError.fire(this._errorItems);
        return res;
      }
      get errorItems() {
        return this._errorItems;
      }
      get foldConfigurations() {
        return this._folderConfigurations;
      }
      extendsDefaults(props) {
        let { defaults: defaults2 } = this._configuration;
        let { contents } = defaults2;
        contents = deepClone(contents);
        Object.keys(props).forEach((key) => {
          addToValueTree(contents, key, props[key], (msg) => {
            logger15.error(msg);
          });
        });
        let data = {
          defaults: { contents },
          user: this._configuration.user,
          workspace: this._configuration.workspace
        };
        this._configuration = Configurations.parse(data);
      }
      updateUserConfig(props) {
        if (!props || Object.keys(props).length == 0)
          return;
        let { user } = this._configuration;
        let model = user.clone();
        Object.keys(props).forEach((key) => {
          let val = props[key];
          if (val === void 0) {
            model.removeValue(key);
          } else if (objectLiteral(val)) {
            for (let k of Object.keys(val)) {
              model.setValue(`${key}.${k}`, val[k]);
            }
          } else {
            model.setValue(key, val);
          }
        });
        this.changeConfiguration(ConfigurationTarget.User, model);
      }
      get defaults() {
        return this._configuration.defaults;
      }
      get user() {
        return this._configuration.user;
      }
      get workspace() {
        return this._configuration.workspace;
      }
      addFolderFile(filepath) {
        let { _folderConfigurations } = this;
        if (_folderConfigurations.has(filepath))
          return;
        if (import_path4.default.resolve(filepath, "../..") == import_os2.default.homedir())
          return;
        let model = this.parseContentFromFile(filepath);
        this.watchFile(filepath, ConfigurationTarget.Workspace);
        this.changeConfiguration(ConfigurationTarget.Workspace, model, filepath);
      }
      watchFile(filepath, target) {
        if (!import_fs3.default.existsSync(filepath) || global.hasOwnProperty("__TEST__"))
          return;
        let disposable = watchFile(filepath, () => {
          let model = this.parseContentFromFile(filepath);
          this.changeConfiguration(target, model, filepath);
        });
        this.disposables.push(disposable);
      }
      changeConfiguration(target, model, configFile) {
        let { defaults: defaults2, user, workspace } = this._configuration;
        let { workspaceConfigFile } = this;
        let data = {
          defaults: target == ConfigurationTarget.Global ? model : defaults2,
          user: target == ConfigurationTarget.User ? model : user,
          workspace: target == ConfigurationTarget.Workspace ? model : workspace
        };
        let configuration = Configurations.parse(data);
        let changed = getChangedKeys(this._configuration.getValue(), configuration.getValue());
        if (target == ConfigurationTarget.Workspace && configFile) {
          this._folderConfigurations.set(configFile, new ConfigurationModel(model.contents));
          this.workspaceConfigFile = configFile;
        }
        if (changed.length == 0)
          return;
        this._configuration = configuration;
        this._onChange.fire({
          affectsConfiguration: (section2, resource) => {
            if (!resource || target != ConfigurationTarget.Workspace)
              return changed.includes(section2);
            let u = URI.parse(resource);
            if (u.scheme !== "file")
              return changed.includes(section2);
            let filepath = u.fsPath;
            let preRoot = workspaceConfigFile ? import_path4.default.resolve(workspaceConfigFile, "../..") : "";
            if (configFile && !isParentFolder(preRoot, filepath, true) && !isParentFolder(import_path4.default.resolve(configFile, "../.."), filepath)) {
              return false;
            }
            return changed.includes(section2);
          }
        });
      }
      setFolderConfiguration(uri) {
        let u = URI.parse(uri);
        if (u.scheme != "file")
          return;
        let filepath = u.fsPath;
        for (let [configFile, model] of this.foldConfigurations) {
          let root = import_path4.default.resolve(configFile, "../..");
          if (isParentFolder(root, filepath, true) && this.workspaceConfigFile != configFile) {
            this.changeConfiguration(ConfigurationTarget.Workspace, model, configFile);
            break;
          }
        }
      }
      hasFolderConfiguration(filepath) {
        let { folders } = this;
        return folders.findIndex((f) => isParentFolder(f, filepath, true)) !== -1;
      }
      getConfigFile(target) {
        if (target == ConfigurationTarget.Global)
          return null;
        if (target == ConfigurationTarget.User)
          return this.userConfigFile;
        return this.workspaceConfigFile;
      }
      get folders() {
        let res = [];
        let { _folderConfigurations } = this;
        for (let folder of _folderConfigurations.keys()) {
          res.push(import_path4.default.resolve(folder, "../.."));
        }
        return res;
      }
      get configuration() {
        return this._configuration;
      }
      getConfiguration(section2, resource) {
        let configuration;
        if (resource) {
          let { defaults: defaults2, user } = this._configuration;
          configuration = new Configuration(defaults2, user, this.getFolderConfiguration(resource));
        } else {
          configuration = this._configuration;
        }
        const config = Object.freeze(lookUp(configuration.getValue(null), section2));
        const result = {
          has(key) {
            return typeof lookUp(config, key) !== "undefined";
          },
          get: (key, defaultValue) => {
            let result2 = lookUp(config, key);
            if (result2 == null)
              return defaultValue;
            return result2;
          },
          update: (key, value, isUser = false) => {
            let s = section2 ? `${section2}.${key}` : key;
            let target = isUser ? ConfigurationTarget.User : ConfigurationTarget.Workspace;
            let model = target == ConfigurationTarget.User ? this.user.clone() : this.workspace.clone();
            if (value == void 0) {
              model.removeValue(s);
            } else {
              model.setValue(s, value);
            }
            if (target == ConfigurationTarget.Workspace && !this.workspaceConfigFile && this._proxy) {
              let file = this.workspaceConfigFile = this._proxy.workspaceConfigFile;
              if (!import_fs3.default.existsSync(file)) {
                let folder = import_path4.default.dirname(file);
                if (!import_fs3.default.existsSync(folder))
                  import_fs3.default.mkdirSync(folder);
                import_fs3.default.writeFileSync(file, "{}", { encoding: "utf8" });
              }
            }
            this.changeConfiguration(target, model, target == ConfigurationTarget.Workspace ? this.workspaceConfigFile : this.userConfigFile);
            if (this._proxy && !global.hasOwnProperty("__TEST__")) {
              if (value == void 0) {
                this._proxy.$removeConfigurationOption(target, s);
              } else {
                this._proxy.$updateConfigurationOption(target, s, value);
              }
            }
          },
          inspect: (key) => {
            key = section2 ? `${section2}.${key}` : key;
            const config2 = this._configuration.inspect(key);
            if (config2) {
              return {
                key,
                defaultValue: config2.default,
                globalValue: config2.user,
                workspaceValue: config2.workspace
              };
            }
            return void 0;
          }
        };
        Object.defineProperty(result, "has", {
          enumerable: false
        });
        Object.defineProperty(result, "get", {
          enumerable: false
        });
        Object.defineProperty(result, "update", {
          enumerable: false
        });
        Object.defineProperty(result, "inspect", {
          enumerable: false
        });
        if (typeof config === "object") {
          mixin(result, config, false);
        }
        return deepFreeze(result);
      }
      getFolderConfiguration(uri) {
        let u = URI.parse(uri);
        if (u.scheme != "file")
          return new ConfigurationModel();
        let filepath = u.fsPath;
        for (let [configFile, model] of this.foldConfigurations) {
          let root = import_path4.default.resolve(configFile, "../..");
          if (isParentFolder(root, filepath, true))
            return model;
        }
        return new ConfigurationModel();
      }
      checkFolderConfiguration(uri) {
        let u = URI.parse(uri);
        if (u.scheme != "file")
          return;
        let rootPath = import_path4.default.dirname(u.fsPath);
        if (!this.hasFolderConfiguration(rootPath)) {
          let folder = findUp(".vim", rootPath);
          if (folder && folder != import_os2.default.homedir()) {
            let file = import_path4.default.join(folder, CONFIG_FILE_NAME);
            if (import_fs3.default.existsSync(file)) {
              this.addFolderFile(file);
            }
          }
        } else {
          this.setFolderConfiguration(uri);
        }
      }
      static parse(data) {
        const defaultConfiguration = new ConfigurationModel(data.defaults.contents);
        const userConfiguration = new ConfigurationModel(data.user.contents);
        const workspaceConfiguration = new ConfigurationModel(data.workspace.contents);
        return new Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, new ConfigurationModel());
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/configuration/shape.ts
var import_fs5, import_path5, logger16, ConfigurationProxy;
var init_shape = __esm({
  "src/configuration/shape.ts"() {
    import_fs5 = __toModule(require("fs"));
    init_main3();
    import_path5 = __toModule(require("path"));
    init_esm2();
    init_util();
    logger16 = require_logger2()("configuration-shape");
    ConfigurationProxy = class {
      constructor(workspace) {
        this.workspace = workspace;
      }
      get nvim() {
        return this.workspace.nvim;
      }
      async modifyConfiguration(target, key, value) {
        let { nvim, workspace } = this;
        let file = workspace.getConfigFile(target);
        if (!file)
          return;
        let formattingOptions = { tabSize: 2, insertSpaces: true };
        let content = import_fs5.default.readFileSync(file, "utf8");
        value = value == null ? void 0 : value;
        let edits = modify(content, [key], value, { formattingOptions });
        content = applyEdits(content, edits);
        import_fs5.default.writeFileSync(file, content, "utf8");
        let doc = workspace.getDocument(URI.file(file).toString());
        if (doc)
          nvim.command("checktime", true);
        return;
      }
      get workspaceConfigFile() {
        let folder = import_path5.default.join(this.workspace.root, ".vim");
        return import_path5.default.join(folder, CONFIG_FILE_NAME);
      }
      $updateConfigurationOption(target, key, value) {
        this.modifyConfiguration(target, key, value).logError();
      }
      $removeConfigurationOption(target, key) {
        this.modifyConfiguration(target, key).logError();
      }
    };
  }
});

// src/model/db.ts
var import_fs_extra2, import_path6, DB;
var init_db = __esm({
  "src/model/db.ts"() {
    import_fs_extra2 = __toModule(require_lib5());
    import_path6 = __toModule(require("path"));
    DB = class {
      constructor(filepath) {
        this.filepath = filepath;
      }
      fetch(key) {
        let obj = this.load();
        if (!key)
          return obj;
        let parts = key.split(".");
        for (let part of parts) {
          if (typeof obj[part] == "undefined") {
            return void 0;
          }
          obj = obj[part];
        }
        return obj;
      }
      exists(key) {
        let obj = this.load();
        let parts = key.split(".");
        for (let part of parts) {
          if (typeof obj[part] == "undefined") {
            return false;
          }
          obj = obj[part];
        }
        return true;
      }
      delete(key) {
        let obj = this.load();
        let origin = obj;
        let parts = key.split(".");
        let len = parts.length;
        for (let i = 0; i < len; i++) {
          if (typeof obj[parts[i]] == "undefined") {
            break;
          }
          if (i == len - 1) {
            delete obj[parts[i]];
            import_fs_extra2.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2), "utf8");
            break;
          }
          obj = obj[parts[i]];
        }
      }
      push(key, data) {
        let origin = this.load() || {};
        let obj = origin;
        let parts = key.split(".");
        let len = parts.length;
        if (obj == null) {
          let dir = import_path6.default.dirname(this.filepath);
          import_fs_extra2.default.mkdirpSync(dir);
          obj = origin;
        }
        for (let i = 0; i < len; i++) {
          let key2 = parts[i];
          if (i == len - 1) {
            obj[key2] = data;
            import_fs_extra2.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2));
            break;
          }
          if (typeof obj[key2] == "undefined") {
            obj[key2] = {};
            obj = obj[key2];
          } else {
            obj = obj[key2];
          }
        }
      }
      load() {
        let dir = import_path6.default.dirname(this.filepath);
        let stat = import_fs_extra2.default.statSync(dir);
        if (!stat || !stat.isDirectory()) {
          import_fs_extra2.default.mkdirpSync(dir);
          import_fs_extra2.default.writeFileSync(this.filepath, "{}", "utf8");
          return {};
        }
        try {
          let content = import_fs_extra2.default.readFileSync(this.filepath, "utf8");
          return JSON.parse(content.trim());
        } catch (e) {
          import_fs_extra2.default.writeFileSync(this.filepath, "{}", "utf8");
          return {};
        }
      }
      clear() {
        let stat = import_fs_extra2.default.statSync(this.filepath);
        if (!stat || !stat.isFile())
          return;
        import_fs_extra2.default.writeFileSync(this.filepath, "{}", "utf8");
      }
      destroy() {
        if (import_fs_extra2.default.existsSync(this.filepath)) {
          import_fs_extra2.default.unlinkSync(this.filepath);
        }
      }
    };
  }
});

// src/util/diff.ts
function diffLines(oldLines, newLines, startLine) {
  let endOffset = 0;
  let startOffset = 0;
  let parts = oldLines.slice(startLine + 1);
  for (let i = 0; i < Math.min(parts.length, newLines.length); i++) {
    if (parts[parts.length - 1 - i] == newLines[newLines.length - 1 - i]) {
      endOffset = endOffset + 1;
    } else {
      break;
    }
  }
  for (let i = 0; i <= Math.min(startLine, newLines.length - 1 - endOffset); i++) {
    if (oldLines[i] == newLines[i]) {
      startOffset = startOffset + 1;
    } else {
      break;
    }
  }
  let replacement = newLines.slice(startOffset, newLines.length - endOffset);
  let end = oldLines.length - endOffset;
  if (end > startOffset && replacement.length) {
    let offset = 0;
    for (let i = 0; i < Math.min(replacement.length, end - startOffset); i++) {
      if (replacement[i] == oldLines[startOffset + i]) {
        offset = offset + 1;
      } else {
        break;
      }
    }
    if (offset) {
      return {
        start: startOffset + offset,
        end,
        replacement: replacement.slice(offset)
      };
    }
  }
  return {
    start: startOffset,
    end,
    replacement
  };
}
function getChange(oldStr, newStr, cursorEnd) {
  let ol = oldStr.length;
  let nl = newStr.length;
  let max = Math.min(ol, nl);
  let newText = "";
  let startOffset = 0;
  let endOffset = -1;
  let shouldLimit = false;
  for (let i = 0; i <= max; i++) {
    if (cursorEnd != null && i == cursorEnd) {
      endOffset = i;
      shouldLimit = true;
      break;
    }
    if (oldStr[ol - i - 1] != newStr[nl - i - 1]) {
      endOffset = i;
      break;
    }
  }
  if (endOffset == -1)
    return null;
  let remain = max - endOffset;
  if (remain == 0) {
    startOffset = 0;
  } else {
    for (let i = 0; i <= remain; i++) {
      if (oldStr[i] != newStr[i] || i == remain) {
        startOffset = i;
        break;
      }
    }
  }
  remain = remain - startOffset;
  if (shouldLimit && remain > 0) {
    let end2 = endOffset;
    for (let i = 0; i < remain; i++) {
      let oc = oldStr[ol - end2 - 1 - i];
      let nc = newStr[nl - end2 - 1 - i];
      if (oc == nc) {
        endOffset = endOffset + 1;
      } else {
        break;
      }
    }
  }
  let end = ol - endOffset;
  if (ol == nl && startOffset == end)
    return null;
  newText = newStr.slice(startOffset, nl - endOffset);
  if (startOffset == end) {
    let pre = startOffset == 0 ? "" : newStr[startOffset - 1];
    if (pre && pre != "\n" && oldStr[startOffset] == "\n" && newText.startsWith("\n")) {
      return { start: startOffset + 1, end: end + 1, newText: newText.slice(1) + "\n" };
    }
  }
  return { start: startOffset, end, newText };
}
function patchLine(from, to, fill = " ") {
  if (from == to)
    return to;
  let idx = to.indexOf(from);
  if (idx !== -1)
    return fill.repeat(idx) + from;
  let result = (0, import_fast_diff.default)(from, to);
  let str = "";
  for (let item of result) {
    if (item[0] == import_fast_diff.default.DELETE) {
      return to;
    } else if (item[0] == import_fast_diff.default.INSERT) {
      str = str + fill.repeat(byteLength(item[1]));
    } else {
      str = str + item[1];
    }
  }
  return str;
}
var import_fast_diff, logger17;
var init_diff = __esm({
  "src/util/diff.ts"() {
    import_fast_diff = __toModule(require_diff());
    init_string();
    logger17 = require_logger2()("util-diff");
  }
});

// src/model/chars.ts
var logger18, Range3, Chars;
var init_chars = __esm({
  "src/model/chars.ts"() {
    logger18 = require_logger2()("model-chars");
    Range3 = class {
      constructor(start, end) {
        this.start = start;
        this.end = end ? end : start;
      }
      static fromKeywordOption(keywordOption) {
        let parts = keywordOption.split(",");
        let ranges = [];
        for (let part of parts) {
          if (part == "@") {
            ranges.push(new Range3(65, 90));
            ranges.push(new Range3(97, 122));
          } else if (part == "@-@") {
            ranges.push(new Range3(64));
          } else if (/^([A-Za-z])-([A-Za-z])$/.test(part)) {
            let ms = part.match(/^([A-Za-z])-([A-Za-z])$/);
            ranges.push(new Range3(ms[1].charCodeAt(0), ms[2].charCodeAt(0)));
          } else if (/^\d+-\d+$/.test(part)) {
            let ms = part.match(/^(\d+)-(\d+)$/);
            ranges.push(new Range3(Number(ms[1]), Number(ms[2])));
          } else if (/^\d+$/.test(part)) {
            ranges.push(new Range3(Number(part)));
          } else {
            let c = part.charCodeAt(0);
            if (!ranges.some((o) => o.contains(c))) {
              ranges.push(new Range3(c));
            }
          }
        }
        return ranges;
      }
      contains(c) {
        return c >= this.start && c <= this.end;
      }
    };
    Chars = class {
      constructor(keywordOption) {
        this.ranges = [];
        if (keywordOption)
          this.ranges = Range3.fromKeywordOption(keywordOption);
      }
      addKeyword(ch) {
        let c = ch.charCodeAt(0);
        let { ranges } = this;
        if (!ranges.some((o) => o.contains(c))) {
          ranges.push(new Range3(c));
        }
      }
      clone() {
        let chars = new Chars();
        chars.ranges = this.ranges.slice();
        return chars;
      }
      setKeywordOption(keywordOption) {
        this.ranges = Range3.fromKeywordOption(keywordOption);
      }
      matchKeywords(content, min = 3) {
        let length = content.length;
        if (length == 0)
          return [];
        let res = new Set();
        let str = "";
        let len = 0;
        for (let i = 0; i < length; i++) {
          let ch = content[i];
          let code = ch.codePointAt(0);
          if (len == 0 && code == 45)
            continue;
          let isKeyword = this.isKeywordCode(code);
          if (isKeyword) {
            if (len == 48)
              continue;
            str = str + ch;
            len = len + 1;
          } else {
            if (len >= min && len < 48)
              res.add(str);
            str = "";
            len = 0;
          }
        }
        if (len != 0)
          res.add(str);
        return Array.from(res);
      }
      isKeywordCode(code) {
        if (code > 255)
          return true;
        if (code < 33)
          return false;
        return this.ranges.some((r) => r.contains(code));
      }
      isKeywordChar(ch) {
        let { ranges } = this;
        let c = ch.charCodeAt(0);
        if (c > 255)
          return true;
        if (c < 33)
          return false;
        return ranges.some((r) => r.contains(c));
      }
      isKeyword(word) {
        let { ranges } = this;
        for (let i = 0, l = word.length; i < l; i++) {
          let ch = word.charCodeAt(i);
          if (ch > 255)
            return false;
          if (ranges.some((r) => r.contains(ch)))
            continue;
          return false;
        }
        return true;
      }
    };
  }
});

// src/model/textdocument.ts
function computeLineOffsets2(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    let ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
var LinesTextDocument;
var init_textdocument = __esm({
  "src/model/textdocument.ts"() {
    LinesTextDocument = class {
      constructor(uri, languageId, version2, lines, eol) {
        this.uri = uri;
        this.languageId = languageId;
        this.version = version2;
        this.lines = lines;
        this.eol = eol;
      }
      get _content() {
        return this.lines.join("\n") + (this.eol ? "\n" : "");
      }
      get lineCount() {
        return this.lines.length + (this.eol ? 1 : 0);
      }
      getText(range) {
        if (range) {
          const start = this.offsetAt(range.start);
          const end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0;
        let high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets2(this._content, true);
        }
        return this._lineOffsets;
      }
    };
  }
});

// src/model/document.ts
var import_debounce3, import_vscode_languageserver_protocol9, logger19, Document;
var init_document = __esm({
  "src/model/document.ts"() {
    import_debounce3 = __toModule(require_debounce());
    import_vscode_languageserver_protocol9 = __toModule(require_main2());
    init_main2();
    init_esm2();
    init_events();
    init_diff();
    init_util();
    init_object();
    init_position();
    init_string();
    init_chars();
    init_textdocument();
    logger19 = require_logger2()("model-document");
    Document = class {
      constructor(buffer, env, maxFileSize) {
        this.buffer = buffer;
        this.env = env;
        this.maxFileSize = maxFileSize;
        this.isIgnored = false;
        this.size = 0;
        this.eol = true;
        this.lines = [];
        this._attached = false;
        this._previewwindow = false;
        this._winid = -1;
        this._words = [];
        this._onDocumentChange = new import_vscode_languageserver_protocol9.Emitter();
        this._onDocumentDetach = new import_vscode_languageserver_protocol9.Emitter();
        this.disposables = [];
        this.onDocumentChange = this._onDocumentChange.event;
        this.onDocumentDetach = this._onDocumentDetach.event;
        this.fireContentChanges = (0, import_debounce3.default)(() => {
          this._fireContentChanges();
        }, 300);
        this.fetchContent = (0, import_debounce3.default)(() => {
          void this._fetchContent();
        }, 100);
      }
      get content() {
        return this.syncLines.join("\n") + (this.eol ? "\n" : "");
      }
      get attached() {
        return this._attached;
      }
      get bufnr() {
        return this.buffer.id;
      }
      get filetype() {
        return this._filetype;
      }
      get uri() {
        return this._uri;
      }
      get shouldAttach() {
        let { buftype, maxFileSize } = this;
        if (!this.getVar("enabled", true))
          return false;
        if (this.uri.endsWith("%5BCommand%20Line%5D"))
          return true;
        if (this.size == -2)
          return false;
        if (maxFileSize && this.size > maxFileSize)
          return false;
        return buftype == "" || buftype == "acwrite";
      }
      get isCommandLine() {
        return this.uri && this.uri.endsWith("%5BCommand%20Line%5D");
      }
      get enabled() {
        return this.getVar("enabled", true);
      }
      get words() {
        return this._words;
      }
      convertFiletype(filetype) {
        switch (filetype) {
          case "javascript.jsx":
            return "javascriptreact";
          case "typescript.jsx":
          case "typescript.tsx":
            return "typescriptreact";
          case "tex":
            return "latex";
          default: {
            let map = this.env.filetypeMap;
            return map[filetype] || filetype;
          }
        }
      }
      get changedtick() {
        return this._changedtick;
      }
      get schema() {
        return URI.parse(this.uri).scheme;
      }
      get lineCount() {
        return this.lines.length;
      }
      get winid() {
        return this._winid;
      }
      get previewwindow() {
        return this._previewwindow;
      }
      async init(nvim, token) {
        this.nvim = nvim;
        let opts = await nvim.call("coc#util#get_bufoptions", [this.bufnr, this.maxFileSize]);
        if (opts == null)
          return false;
        let buftype = this.buftype = opts.buftype;
        this._previewwindow = opts.previewwindow;
        this._winid = opts.winid;
        this.size = typeof opts.size == "number" ? opts.size : 0;
        this.variables = opts.variables || {};
        this._changedtick = opts.changedtick;
        this.eol = opts.eol == 1;
        this._uri = getUri(opts.fullpath, this.bufnr, buftype, this.env.isCygwin);
        if (token.isCancellationRequested)
          return false;
        if (this.shouldAttach) {
          this.lines = opts.lines;
          let res = await this.attach();
          if (!res)
            return false;
          this._attached = true;
        }
        this._filetype = this.convertFiletype(opts.filetype);
        this.setIskeyword(opts.iskeyword);
        this.createTextDocument(1, this.lines);
        if (token.isCancellationRequested) {
          this.detach();
          return false;
        }
        return true;
      }
      async attach() {
        let attached = await this.buffer.attach(true);
        if (!attached)
          return false;
        let lines = this.lines;
        this.buffer.listen("lines", (buf, tick, firstline, lastline, linedata) => {
          if (buf.id !== this.bufnr || !this._attached || tick == null)
            return;
          if (tick > this._changedtick) {
            this._changedtick = tick;
            lines = [...lines.slice(0, firstline), ...linedata, ...lines.slice(lastline)];
            this.lines = lines;
            this.fireContentChanges();
          }
        }, this.disposables);
        this.buffer.listen("detach", async (buf) => {
          lines = [];
          this._onDocumentDetach.fire(buf.id);
        }, this.disposables);
        return true;
      }
      get dirty() {
        if (this.lines === this.syncLines)
          return false;
        return !equals(this.lines, this.syncLines);
      }
      _fireContentChanges() {
        let { cursor } = events_default;
        if (!this.dirty)
          return;
        let textDocument = this._textDocument;
        let endOffset = null;
        if (cursor && cursor.bufnr == this.bufnr) {
          endOffset = this.getEndOffset(cursor.lnum, cursor.col, cursor.insert);
        }
        let content = this.getDocumentContent();
        let change = getChange(textDocument.getText(), content, endOffset);
        if (change == null)
          return;
        let start = textDocument.positionAt(change.start);
        let end = textDocument.positionAt(change.end);
        let original = textDocument.getText(import_vscode_languageserver_protocol9.Range.create(start, end));
        this.createTextDocument(this.version + 1, this.lines);
        let changes = [{
          range: { start, end },
          rangeLength: change.end - change.start,
          text: change.newText
        }];
        this._onDocumentChange.fire({
          bufnr: this.bufnr,
          original,
          originalLines: textDocument.lines,
          textDocument: { version: this.version, uri: this.uri },
          contentChanges: changes
        });
        this._words = this.chars.matchKeywords(content);
      }
      async applyEdits(edits) {
        if (!Array.isArray(arguments[0]) && Array.isArray(arguments[1])) {
          edits = arguments[1];
        }
        if (edits.length == 0)
          return;
        let textDocument = TextDocument2.create(this.uri, this.filetype, 1, this.getDocumentContent());
        let applied = TextDocument2.applyEdits(textDocument, edits);
        let content;
        if (this.eol) {
          if (applied.endsWith("\r\n")) {
            content = applied.slice(0, -2);
          } else {
            content = applied.endsWith("\n") ? applied.slice(0, -1) : applied;
          }
        } else {
          content = applied;
        }
        let lines = this.lines;
        let newLines = content.split(/\r?\n/);
        if (!equals(lines, newLines)) {
          let lnums = edits.map((o) => o.range.start.line);
          let d = diffLines(lines, newLines, Math.min.apply(null, lnums));
          let original = lines.slice(d.start, d.end);
          this.nvim.call("coc#util#set_lines", [this.bufnr, this._changedtick, original, d.replacement, d.start, d.end], true);
          if (this.env.isVim)
            this.nvim.command("redraw", true);
          await waitNextTick(() => {
            this.lines = newLines;
            this._forceSync();
          });
        }
      }
      async changeLines(lines) {
        let filtered = [];
        let newLines = this.lines.slice();
        for (let [lnum, text] of lines) {
          if (newLines[lnum] != text) {
            filtered.push([lnum, text]);
            newLines[lnum] = text;
          }
        }
        if (!filtered.length)
          return;
        this.nvim.call("coc#util#change_lines", [this.bufnr, filtered], true);
        if (this.env.isVim)
          this.nvim.command("redraw", true);
        this.lines = newLines;
        this._forceSync();
      }
      _forceSync() {
        this.fireContentChanges.clear();
        this._fireContentChanges();
      }
      forceSync() {
        if (global.hasOwnProperty("__TEST__")) {
          this._forceSync();
        }
      }
      getOffset(lnum, col) {
        return this.textDocument.offsetAt({
          line: lnum - 1,
          character: col
        });
      }
      isWord(word) {
        return this.chars.isKeyword(word);
      }
      getMoreWords() {
        let res = [];
        let { words, chars } = this;
        if (!chars.isKeywordChar("-"))
          return res;
        for (let word of words) {
          word = word.replace(/^-+/, "");
          if (word.includes("-")) {
            let parts = word.split("-");
            for (let part of parts) {
              if (part.length > 2 && !res.includes(part) && !words.includes(part)) {
                res.push(part);
              }
            }
          }
        }
        return res;
      }
      getWordRangeAtPosition(position, extraChars, current = true) {
        let chars = this.chars.clone();
        if (extraChars && extraChars.length) {
          for (let ch of extraChars) {
            chars.addKeyword(ch);
          }
        }
        let line = this.getline(position.line, current);
        if (line.length == 0 || position.character >= line.length)
          return null;
        if (!chars.isKeywordChar(line[position.character]))
          return null;
        let start = position.character;
        let end = position.character + 1;
        if (!chars.isKeywordChar(line[start])) {
          return import_vscode_languageserver_protocol9.Range.create(position, { line: position.line, character: position.character + 1 });
        }
        while (start >= 0) {
          let ch = line[start - 1];
          if (!ch || !chars.isKeyword(ch))
            break;
          start = start - 1;
        }
        while (end <= line.length) {
          let ch = line[end];
          if (!ch || !chars.isKeywordChar(ch))
            break;
          end = end + 1;
        }
        return import_vscode_languageserver_protocol9.Range.create(position.line, start, position.line, end);
      }
      get textDocument() {
        return this._textDocument;
      }
      get syncLines() {
        return this._textDocument.lines;
      }
      get version() {
        return this._textDocument.version;
      }
      createTextDocument(version2, lines) {
        let { uri, filetype, eol } = this;
        this._textDocument = new LinesTextDocument(uri, filetype, version2, lines, eol);
      }
      async _fetchContent(sync) {
        if (!this.env.isVim || !this._attached)
          return;
        let { nvim, bufnr, changedtick } = this;
        let o = await nvim.call("coc#util#get_buf_lines", [bufnr, changedtick]);
        if (o) {
          this._changedtick = o.changedtick;
          this.lines = o.lines;
          if (sync) {
            this._forceSync();
          } else {
            this.fireContentChanges();
          }
        }
      }
      async patchChange(currentLine) {
        if (!this._attached)
          return;
        if (this.env.isVim) {
          if (currentLine) {
            let change = await this.nvim.call("coc#util#get_changeinfo", []);
            if (change.changedtick < this._changedtick)
              return;
            let { lnum, line, changedtick } = change;
            let newLines = this.lines.slice();
            this._changedtick = changedtick;
            if (newLines[lnum - 1] == line)
              return;
            newLines[lnum - 1] = line;
            this.lines = newLines;
            this._forceSync();
          } else {
            this.fetchContent.clear();
            await this._fetchContent(true);
          }
        } else {
          this._changedtick = await this.buffer.getVar("changedtick");
          this._forceSync();
        }
      }
      getSymbolRanges(word) {
        let { version: version2, filetype, uri } = this;
        let textDocument = new LinesTextDocument(uri, filetype, version2, this.lines, this.eol);
        let res = [];
        let content = textDocument.getText();
        let str = "";
        for (let i = 0, l = content.length; i < l; i++) {
          let ch = content[i];
          if (ch == "-" && str.length == 0) {
            continue;
          }
          let isKeyword = this.chars.isKeywordChar(ch);
          if (isKeyword) {
            str = str + ch;
          }
          if (str.length > 0 && !isKeyword && str == word) {
            res.push(import_vscode_languageserver_protocol9.Range.create(textDocument.positionAt(i - str.length), textDocument.positionAt(i)));
          }
          if (!isKeyword) {
            str = "";
          }
        }
        return res;
      }
      fixStartcol(position, valids) {
        let line = this.getline(position.line);
        if (!line)
          return null;
        let { character } = position;
        let start = line.slice(0, character);
        let col = byteLength(start);
        let { chars } = this;
        for (let i = start.length - 1; i >= 0; i--) {
          let c = start[i];
          if (c == " ")
            break;
          if (!chars.isKeywordChar(c) && !valids.includes(c)) {
            break;
          }
          col = col - byteLength(c);
        }
        return col;
      }
      addHighlights(items, hlGroup, range) {
        let { start, end } = range;
        if (emptyRange(range))
          return;
        for (let line = start.line; line <= end.line; line++) {
          const text = this.getline(line, false);
          let colStart = line == start.line ? byteIndex(text, start.character) : 0;
          let colEnd = line == end.line ? byteIndex(text, end.character) : global.Buffer.byteLength(text);
          if (colStart >= colEnd)
            continue;
          items.push({ hlGroup, lnum: line, colStart, colEnd });
        }
      }
      getline(line, current = true) {
        if (current)
          return this.lines[line] || "";
        return this.syncLines[line] || "";
      }
      getLines(start, end) {
        return this.lines.slice(start, end);
      }
      getDocumentContent() {
        let content = this.lines.join("\n");
        return this.eol ? content + "\n" : content;
      }
      getVar(key, defaultValue) {
        let val = this.variables[`coc_${key}`];
        return val === void 0 ? defaultValue : val;
      }
      getPosition(lnum, col) {
        let line = this.getline(lnum - 1);
        if (!line || col == 0)
          return { line: lnum - 1, character: 0 };
        let pre = byteSlice(line, 0, col - 1);
        return { line: lnum - 1, character: pre.length };
      }
      getEndOffset(lnum, col, insert) {
        let total = 0;
        let len = this.lines.length;
        for (let i = lnum - 1; i < len; i++) {
          let line = this.lines[i];
          let l = line.length;
          if (i == lnum - 1 && l != 0) {
            let buf = global.Buffer.from(line, "utf8");
            let isEnd = buf.byteLength <= col - 1;
            if (!isEnd) {
              total = total + buf.slice(col - 1, buf.length).toString("utf8").length;
              if (!insert)
                total = total - 1;
            }
          } else {
            total = total + l;
          }
          if (!this.eol && i == len - 1)
            break;
          total = total + 1;
        }
        return total;
      }
      setFiletype(filetype) {
        this._filetype = this.convertFiletype(filetype);
        let lines = this._textDocument.lines;
        this._textDocument = new LinesTextDocument(this.uri, this.filetype, 1, lines, this.eol);
      }
      setIskeyword(iskeyword) {
        let chars = this.chars = new Chars(iskeyword);
        let additional = this.getVar("additional_keywords", []);
        if (additional && Array.isArray(additional)) {
          for (let ch of additional) {
            chars.addKeyword(ch);
          }
        }
        let lines = this.lines.length > 3e4 ? this.lines.slice(0, 3e4) : this.lines;
        this._words = this.chars.matchKeywords(lines.join("\n"));
      }
      detach() {
        this._attached = false;
        disposeAll(this.disposables);
        this.disposables = [];
        this.fetchContent.clear();
        this.fireContentChanges.clear();
        this._onDocumentChange.dispose();
        this._onDocumentDetach.dispose();
      }
      async synchronize() {
        let { changedtick } = this;
        await this.patchChange();
        if (changedtick != this.changedtick) {
          await wait(50);
        }
      }
      getLocalifyBonus(sp, ep) {
        let res = new Map();
        let { chars } = this;
        let startLine = Math.max(0, sp.line - 100);
        let endLine = Math.min(this.lineCount, sp.line + 100);
        let content = this.lines.slice(startLine, endLine).join("\n");
        sp = import_vscode_languageserver_protocol9.Position.create(sp.line - startLine, sp.character);
        ep = import_vscode_languageserver_protocol9.Position.create(ep.line - startLine, ep.character);
        let doc = TextDocument2.create(this.uri, this.filetype, 1, content);
        let headCount = doc.offsetAt(sp);
        let len = content.length;
        let tailCount = len - doc.offsetAt(ep);
        let start = 0;
        let preKeyword = false;
        for (let i = 0; i < headCount; i++) {
          let iskeyword = chars.isKeyword(content[i]);
          if (!preKeyword && iskeyword) {
            start = i;
          } else if (preKeyword && (!iskeyword || i == headCount - 1)) {
            if (i - start > 1) {
              let str = content.slice(start, i);
              res.set(str, i / headCount);
            }
          }
          preKeyword = iskeyword;
        }
        start = len - tailCount;
        preKeyword = false;
        for (let i = start; i < content.length; i++) {
          let iskeyword = chars.isKeyword(content[i]);
          if (!preKeyword && iskeyword) {
            start = i;
          } else if (preKeyword && (!iskeyword || i == len - 1)) {
            if (i - start > 1) {
              let end = i == len - 1 ? i + 1 : i;
              let str = content.slice(start, end);
              let score5 = res.get(str) || 0;
              res.set(str, Math.max(score5, (len - i + (end - start)) / tailCount));
            }
          }
          preKeyword = iskeyword;
        }
        return res;
      }
    };
  }
});

// src/util/array.ts
function splitArray(array, fn) {
  let res = [[], []];
  for (let item of array) {
    if (fn(item)) {
      res[0].push(item);
    } else {
      res[1].push(item);
    }
  }
  return res;
}
function group(array, size) {
  let len = array.length;
  let res = [];
  for (let i = 0; i < Math.ceil(len / size); i++) {
    res.push(array.slice(i * size, (i + 1) * size));
  }
  return res;
}
function distinct(array, keyFn) {
  if (!keyFn) {
    return array.filter((element, position) => array.indexOf(element) === position);
  }
  const seen = Object.create(null);
  return array.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}
var init_array = __esm({
  "src/util/array.ts"() {
  }
});

// src/model/fileSystemWatcher.ts
var import_vscode_languageserver_protocol10, import_minimatch2, import_path7, logger20, FileSystemWatcher;
var init_fileSystemWatcher = __esm({
  "src/model/fileSystemWatcher.ts"() {
    import_vscode_languageserver_protocol10 = __toModule(require_main2());
    init_esm2();
    import_minimatch2 = __toModule(require_minimatch());
    import_path7 = __toModule(require("path"));
    init_util();
    init_array();
    logger20 = require_logger2()("filesystem-watcher");
    FileSystemWatcher = class {
      constructor(clientPromise, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        this.globPattern = globPattern;
        this.ignoreCreateEvents = ignoreCreateEvents;
        this.ignoreChangeEvents = ignoreChangeEvents;
        this.ignoreDeleteEvents = ignoreDeleteEvents;
        this._onDidCreate = new import_vscode_languageserver_protocol10.Emitter();
        this._onDidChange = new import_vscode_languageserver_protocol10.Emitter();
        this._onDidDelete = new import_vscode_languageserver_protocol10.Emitter();
        this._onDidRename = new import_vscode_languageserver_protocol10.Emitter();
        this.onDidCreate = this._onDidCreate.event;
        this.onDidChange = this._onDidChange.event;
        this.onDidDelete = this._onDidDelete.event;
        this.onDidRename = this._onDidRename.event;
        this.disposables = [];
        if (!clientPromise)
          return;
        clientPromise.then((client) => {
          if (client)
            return this.listen(client);
        }).catch((error) => {
          logger20.error("watchman initialize failed");
          logger20.error(error.stack);
        });
      }
      async listen(client) {
        let {
          globPattern,
          ignoreCreateEvents,
          ignoreChangeEvents,
          ignoreDeleteEvents
        } = this;
        let disposable = await client.subscribe(globPattern, (change) => {
          let { root, files } = change;
          files = files.filter((f) => f.type == "f" && (0, import_minimatch2.default)(f.name, globPattern, { dot: true }));
          for (let file of files) {
            let uri = URI.file(import_path7.default.join(root, file.name));
            if (!file.exists) {
              if (!ignoreDeleteEvents)
                this._onDidDelete.fire(uri);
            } else {
              if (file.new === true) {
                if (!ignoreCreateEvents)
                  this._onDidCreate.fire(uri);
              } else {
                if (!ignoreChangeEvents)
                  this._onDidChange.fire(uri);
              }
            }
          }
          if (files.length == 2 && !files[0].exists && files[1].exists) {
            let oldFile = files[0];
            let newFile = files[1];
            if (oldFile.size == newFile.size) {
              this._onDidRename.fire({
                oldUri: URI.file(import_path7.default.join(root, oldFile.name)),
                newUri: URI.file(import_path7.default.join(root, newFile.name))
              });
            }
          }
          if (files.length >= 2) {
            let [oldFiles, newFiles] = splitArray(files, (o) => o.exists === false);
            if (oldFiles.length == newFiles.length) {
              for (let oldFile of oldFiles) {
                let newFile = newFiles.find((o) => o.size == oldFile.size && o.mtime_ms == oldFile.mtime_ms);
                if (newFile) {
                  this._onDidRename.fire({
                    oldUri: URI.file(import_path7.default.join(root, oldFile.name)),
                    newUri: URI.file(import_path7.default.join(root, newFile.name))
                  });
                }
              }
            }
          }
        });
        this.disposables.push(disposable);
        return disposable;
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/mru.ts
var import_path8, import_fs_extra3, Mru;
var init_mru = __esm({
  "src/model/mru.ts"() {
    import_path8 = __toModule(require("path"));
    import_fs_extra3 = __toModule(require_lib5());
    Mru = class {
      constructor(name2, base) {
        this.name = name2;
        this.file = import_path8.default.join(base || process.env.COC_DATA_HOME, name2);
      }
      async load() {
        let dir = import_path8.default.dirname(this.file);
        try {
          import_fs_extra3.default.mkdirpSync(dir);
          if (!import_fs_extra3.default.existsSync(this.file)) {
            import_fs_extra3.default.writeFileSync(this.file, "", "utf8");
          }
          let content = await import_fs_extra3.default.readFile(this.file, "utf8");
          content = content.trim();
          return content.length ? content.trim().split("\n") : [];
        } catch (e) {
          return [];
        }
      }
      async add(item) {
        let items = await this.load();
        let idx = items.indexOf(item);
        if (idx !== -1)
          items.splice(idx, 1);
        items.unshift(item);
        import_fs_extra3.default.writeFileSync(this.file, items.join("\n"), "utf8");
      }
      async remove(item) {
        let items = await this.load();
        let idx = items.indexOf(item);
        if (idx !== -1) {
          items.splice(idx, 1);
          import_fs_extra3.default.writeFileSync(this.file, items.join("\n"), "utf8");
        }
      }
      async clean() {
        try {
          await import_fs_extra3.default.unlink(this.file);
        } catch (e) {
        }
      }
    };
  }
});

// src/util/decorator.ts
function memorize(_target, key, descriptor) {
  let fn = descriptor.value;
  if (typeof fn !== "function")
    return;
  let memoKey = "$" + key;
  descriptor.value = function(...args) {
    if (this.hasOwnProperty(memoKey))
      return Promise.resolve(this[memoKey]);
    return new Promise((resolve3, reject) => {
      Promise.resolve(fn.apply(this, args)).then((res) => {
        this[memoKey] = res;
        resolve3(res);
      }, (e) => {
        reject(e);
      });
    });
  };
}
var logger21;
var init_decorator = __esm({
  "src/util/decorator.ts"() {
    logger21 = require_logger2()("util-decorator");
  }
});

// src/model/resolver.ts
var import_path9, import_fs6, import_strip_ansi2, logger22, Resolver;
var init_resolver = __esm({
  "src/model/resolver.ts"() {
    import_path9 = __toModule(require("path"));
    import_fs6 = __toModule(require("fs"));
    init_util();
    init_fs();
    init_decorator();
    import_strip_ansi2 = __toModule(require_strip_ansi());
    logger22 = require_logger2()("model-resolver");
    Resolver = class {
      get nodeFolder() {
        if (!executable("npm"))
          return Promise.resolve("");
        return runCommand("npm --loglevel silent root -g", {}, 3e3).then((root) => {
          return (0, import_strip_ansi2.default)(root).trim();
        });
      }
      get yarnFolder() {
        if (!executable("yarnpkg"))
          return Promise.resolve("");
        return runCommand("yarnpkg global dir", {}, 3e3).then((root) => {
          let folder = import_path9.default.join((0, import_strip_ansi2.default)(root).trim(), "node_modules");
          let exists = import_fs6.default.existsSync(folder);
          return exists ? folder : "";
        });
      }
      async resolveModule(mod) {
        let nodeFolder = await this.nodeFolder;
        let yarnFolder = await this.yarnFolder;
        if (yarnFolder) {
          let s = await statAsync(import_path9.default.join(yarnFolder, mod, "package.json"));
          if (s && s.isFile())
            return import_path9.default.join(yarnFolder, mod);
        }
        if (nodeFolder) {
          let s = await statAsync(import_path9.default.join(nodeFolder, mod, "package.json"));
          if (s && s.isFile())
            return import_path9.default.join(nodeFolder, mod);
        }
        return null;
      }
    };
    __decorateClass([
      memorize
    ], Resolver.prototype, "nodeFolder", 1);
    __decorateClass([
      memorize
    ], Resolver.prototype, "yarnFolder", 1);
  }
});

// src/model/task.ts
var import_vscode_languageserver_protocol11, Task;
var init_task = __esm({
  "src/model/task.ts"() {
    init_events();
    import_vscode_languageserver_protocol11 = __toModule(require_main2());
    init_util();
    Task = class {
      constructor(nvim, id) {
        this.nvim = nvim;
        this.id = id;
        this.disposables = [];
        this._onExit = new import_vscode_languageserver_protocol11.Emitter();
        this._onStderr = new import_vscode_languageserver_protocol11.Emitter();
        this._onStdout = new import_vscode_languageserver_protocol11.Emitter();
        this.onExit = this._onExit.event;
        this.onStdout = this._onStdout.event;
        this.onStderr = this._onStderr.event;
        events_default.on("TaskExit", (id2, code) => {
          if (id2 == this.id) {
            this._onExit.fire(code);
          }
        }, null, this.disposables);
        events_default.on("TaskStderr", (id2, lines) => {
          if (id2 == this.id) {
            this._onStderr.fire(lines);
          }
        }, null, this.disposables);
        let stdout = [];
        let timer;
        events_default.on("TaskStdout", (id2, lines) => {
          if (id2 == this.id) {
            if (timer)
              clearTimeout(timer);
            stdout.push(...lines);
            timer = setTimeout(() => {
              this._onStdout.fire(stdout);
              stdout = [];
            }, 100);
          }
        }, null, this.disposables);
      }
      async start(opts) {
        let { nvim } = this;
        return await nvim.call("coc#task#start", [this.id, opts]);
      }
      async stop() {
        let { nvim } = this;
        await nvim.call("coc#task#stop", [this.id]);
      }
      get running() {
        let { nvim } = this;
        return nvim.call("coc#task#running", [this.id]);
      }
      dispose() {
        let { nvim } = this;
        nvim.call("coc#task#stop", [this.id], true);
        this._onStdout.dispose();
        this._onStderr.dispose();
        this._onExit.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/terminal.ts
var logger23, TerminalModel;
var init_terminal = __esm({
  "src/model/terminal.ts"() {
    logger23 = require_logger2()("model-terminal");
    TerminalModel = class {
      constructor(cmd, args, nvim, _name) {
        this.cmd = cmd;
        this.args = args;
        this.nvim = nvim;
        this._name = _name;
        this.pid = 0;
      }
      async start(cwd, env) {
        let { nvim } = this;
        let cmd = [this.cmd, ...this.args];
        let [bufnr, pid] = await nvim.call("coc#terminal#start", [cmd, cwd, env || {}]);
        this.bufnr = bufnr;
        this.pid = pid;
      }
      get name() {
        return this._name || this.cmd;
      }
      get processId() {
        return Promise.resolve(this.pid);
      }
      sendText(text, addNewLine = true) {
        if (!this.bufnr)
          return;
        this.nvim.call("coc#terminal#send", [this.bufnr, text, addNewLine], true);
      }
      async show(preserveFocus) {
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        let [loaded, winid, curr] = await nvim.eval(`[bufloaded(${bufnr}),bufwinid(${bufnr}),win_getid()]`);
        if (!loaded)
          return false;
        if (curr == winid)
          return true;
        nvim.pauseNotification();
        if (winid == -1) {
          nvim.command(`below ${bufnr}sb`, true);
          nvim.command("resize 8", true);
          nvim.call("coc#util#do_autocmd", ["CocTerminalOpen"], true);
        } else {
          nvim.call("win_gotoid", [winid], true);
        }
        nvim.command("normal! G", true);
        if (preserveFocus) {
          nvim.command("wincmd p", true);
        }
        await nvim.resumeNotification();
        return true;
      }
      async hide() {
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        let winnr = await nvim.call("bufwinnr", bufnr);
        if (winnr == -1)
          return;
        await nvim.command(`${winnr}close!`);
      }
      dispose() {
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        nvim.call("coc#terminal#close", [bufnr], true);
      }
    };
  }
});

// src/model/bufferSync.ts
var BufferSync;
var init_bufferSync = __esm({
  "src/model/bufferSync.ts"() {
    init_util();
    BufferSync = class {
      constructor(_create, workspace) {
        this._create = _create;
        this.workspace = workspace;
        this.disposables = [];
        this.itemsMap = new Map();
        let { disposables } = this;
        for (let doc of workspace.documents) {
          this.create(doc);
        }
        workspace.onDidOpenTextDocument((e) => {
          let doc = workspace.getDocument(e.bufnr);
          if (doc)
            this.create(doc);
        }, null, disposables);
        workspace.onDidChangeTextDocument((e) => {
          this.onChange(e);
        }, null, disposables);
        workspace.onDidCloseTextDocument((e) => {
          this.delete(e.bufnr);
        }, null, disposables);
      }
      get items() {
        return Array.from(this.itemsMap.values()).map((x) => x.item);
      }
      getItem(bufnr) {
        var _a2;
        if (typeof bufnr === "number") {
          return (_a2 = this.itemsMap.get(bufnr)) == null ? void 0 : _a2.item;
        }
        let o = Array.from(this.itemsMap.values()).find((v) => {
          return v.uri == bufnr;
        });
        return o ? o.item : void 0;
      }
      create(doc) {
        if (!doc || doc.isCommandLine || !doc.attached)
          return;
        let o = this.itemsMap.get(doc.bufnr);
        if (o)
          o.item.dispose();
        let item = this._create(doc);
        if (item)
          this.itemsMap.set(doc.bufnr, { uri: doc.uri, item });
      }
      onChange(e) {
        let o = this.itemsMap.get(e.bufnr);
        if (o && typeof o.item.onChange == "function") {
          o.item.onChange(e);
        }
      }
      delete(bufnr) {
        let o = this.itemsMap.get(bufnr);
        if (o) {
          this.itemsMap.delete(bufnr);
          o.item.dispose();
        }
      }
      reset() {
        for (let o of this.itemsMap.values()) {
          o.item.dispose();
        }
        this.itemsMap.clear();
      }
      dispose() {
        disposeAll(this.disposables);
        for (let o of this.itemsMap.values()) {
          o.item.dispose();
        }
        this.itemsMap.clear();
      }
    };
  }
});

// src/util/match.ts
function score(selector, uri, languageId) {
  if (Array.isArray(selector)) {
    let ret = 0;
    for (const filter of selector) {
      const value = score(filter, uri, languageId);
      if (value === 10) {
        return value;
      }
      if (value > ret) {
        ret = value;
      }
    }
    return ret;
  } else if (typeof selector === "string") {
    if (selector === "*") {
      return 5;
    } else if (selector === languageId) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector) {
    let u = URI.parse(uri);
    const { language: language2, pattern, scheme } = selector;
    let ret = 0;
    if (scheme) {
      if (scheme === u.scheme) {
        ret = 5;
      } else if (scheme === "*") {
        ret = 3;
      } else {
        return 0;
      }
    }
    if (language2) {
      if (language2 === languageId) {
        ret = 10;
      } else if (language2 === "*") {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (pattern) {
      let caseInsensitive = isWindows2 || isMacintosh;
      let p = caseInsensitive ? pattern.toLowerCase() : pattern;
      let f = caseInsensitive ? u.fsPath.toLowerCase() : u.fsPath;
      if (p === f || (0, import_minimatch3.default)(f, p, { dot: true })) {
        ret = 5;
      } else {
        return 0;
      }
    }
    return ret;
  } else {
    return 0;
  }
}
var import_minimatch3;
var init_match = __esm({
  "src/util/match.ts"() {
    import_minimatch3 = __toModule(require_minimatch());
    init_esm2();
    init_platform();
  }
});

// node_modules/node-int64/Int64.js
var require_Int64 = __commonJS({
  "node_modules/node-int64/Int64.js"(exports2, module2) {
    var VAL32 = 4294967296;
    var _HEX = [];
    for (var i = 0; i < 256; i++) {
      _HEX[i] = (i > 15 ? "" : "0") + i.toString(16);
    }
    var Int64 = module2.exports = function(a1, a2) {
      if (a1 instanceof Buffer) {
        this.buffer = a1;
        this.offset = a2 || 0;
      } else if (Object.prototype.toString.call(a1) == "[object Uint8Array]") {
        this.buffer = new Buffer(a1);
        this.offset = a2 || 0;
      } else {
        this.buffer = this.buffer || new Buffer(8);
        this.offset = 0;
        this.setValue.apply(this, arguments);
      }
    };
    Int64.MAX_INT = Math.pow(2, 53);
    Int64.MIN_INT = -Math.pow(2, 53);
    Int64.prototype = {
      constructor: Int64,
      _2scomp: function() {
        var b = this.buffer, o = this.offset, carry = 1;
        for (var i2 = o + 7; i2 >= o; i2--) {
          var v = (b[i2] ^ 255) + carry;
          b[i2] = v & 255;
          carry = v >> 8;
        }
      },
      setValue: function(hi, lo) {
        var negate = false;
        if (arguments.length == 1) {
          if (typeof hi == "number") {
            negate = hi < 0;
            hi = Math.abs(hi);
            lo = hi % VAL32;
            hi = hi / VAL32;
            if (hi > VAL32)
              throw new RangeError(hi + " is outside Int64 range");
            hi = hi | 0;
          } else if (typeof hi == "string") {
            hi = (hi + "").replace(/^0x/, "");
            lo = hi.substr(-8);
            hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : "";
            hi = parseInt(hi, 16);
            lo = parseInt(lo, 16);
          } else {
            throw new Error(hi + " must be a Number or String");
          }
        }
        var b = this.buffer, o = this.offset;
        for (var i2 = 7; i2 >= 0; i2--) {
          b[o + i2] = lo & 255;
          lo = i2 == 4 ? hi : lo >>> 8;
        }
        if (negate)
          this._2scomp();
      },
      toNumber: function(allowImprecise) {
        var b = this.buffer, o = this.offset;
        var negate = b[o] & 128, x = 0, carry = 1;
        for (var i2 = 7, m = 1; i2 >= 0; i2--, m *= 256) {
          var v = b[o + i2];
          if (negate) {
            v = (v ^ 255) + carry;
            carry = v >> 8;
            v = v & 255;
          }
          x += v * m;
        }
        if (!allowImprecise && x >= Int64.MAX_INT) {
          return negate ? -Infinity : Infinity;
        }
        return negate ? -x : x;
      },
      valueOf: function() {
        return this.toNumber(false);
      },
      toString: function(radix) {
        return this.valueOf().toString(radix || 10);
      },
      toOctetString: function(sep) {
        var out = new Array(8);
        var b = this.buffer, o = this.offset;
        for (var i2 = 0; i2 < 8; i2++) {
          out[i2] = _HEX[b[o + i2]];
        }
        return out.join(sep || "");
      },
      toBuffer: function(rawBuffer) {
        if (rawBuffer && this.offset === 0)
          return this.buffer;
        var out = new Buffer(8);
        this.buffer.copy(out, 0, this.offset, this.offset + 8);
        return out;
      },
      copy: function(targetBuffer, targetOffset) {
        this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
      },
      compare: function(other) {
        if ((this.buffer[this.offset] & 128) != (other.buffer[other.offset] & 128)) {
          return other.buffer[other.offset] - this.buffer[this.offset];
        }
        for (var i2 = 0; i2 < 8; i2++) {
          if (this.buffer[this.offset + i2] !== other.buffer[other.offset + i2]) {
            return this.buffer[this.offset + i2] - other.buffer[other.offset + i2];
          }
        }
        return 0;
      },
      equals: function(other) {
        return this.compare(other) === 0;
      },
      inspect: function() {
        return "[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]";
      }
    };
  }
});

// node_modules/bser/index.js
var require_bser = __commonJS({
  "node_modules/bser/index.js"(exports2) {
    var EE = require("events").EventEmitter;
    var util4 = require("util");
    var os10 = require("os");
    var assert = require("assert");
    var Int64 = require_Int64();
    var isBigEndian = os10.endianness() == "BE";
    function nextPow2(size) {
      return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));
    }
    function Accumulator(initsize) {
      this.buf = Buffer.alloc(nextPow2(initsize || 8192));
      this.readOffset = 0;
      this.writeOffset = 0;
    }
    exports2.Accumulator = Accumulator;
    Accumulator.prototype.writeAvail = function() {
      return this.buf.length - this.writeOffset;
    };
    Accumulator.prototype.readAvail = function() {
      return this.writeOffset - this.readOffset;
    };
    Accumulator.prototype.reserve = function(size) {
      if (size < this.writeAvail()) {
        return;
      }
      if (this.readOffset > 0) {
        this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);
        this.writeOffset -= this.readOffset;
        this.readOffset = 0;
      }
      if (size < this.writeAvail()) {
        return;
      }
      var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));
      this.buf.copy(buf);
      this.buf = buf;
    };
    Accumulator.prototype.append = function(buf) {
      if (Buffer.isBuffer(buf)) {
        this.reserve(buf.length);
        buf.copy(this.buf, this.writeOffset, 0, buf.length);
        this.writeOffset += buf.length;
      } else {
        var size = Buffer.byteLength(buf);
        this.reserve(size);
        this.buf.write(buf, this.writeOffset);
        this.writeOffset += size;
      }
    };
    Accumulator.prototype.assertReadableSize = function(size) {
      if (this.readAvail() < size) {
        throw new Error("wanted to read " + size + " bytes but only have " + this.readAvail());
      }
    };
    Accumulator.prototype.peekString = function(size) {
      this.assertReadableSize(size);
      return this.buf.toString("utf-8", this.readOffset, this.readOffset + size);
    };
    Accumulator.prototype.readString = function(size) {
      var str = this.peekString(size);
      this.readOffset += size;
      return str;
    };
    Accumulator.prototype.peekInt = function(size) {
      this.assertReadableSize(size);
      switch (size) {
        case 1:
          return this.buf.readInt8(this.readOffset, size);
        case 2:
          return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);
        case 4:
          return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);
        case 8:
          var big = this.buf.slice(this.readOffset, this.readOffset + 8);
          if (isBigEndian) {
            return new Int64(big);
          }
          return new Int64(byteswap64(big));
        default:
          throw new Error("invalid integer size " + size);
      }
    };
    Accumulator.prototype.readInt = function(bytes2) {
      var ival = this.peekInt(bytes2);
      if (ival instanceof Int64 && isFinite(ival.valueOf())) {
        ival = ival.valueOf();
      }
      this.readOffset += bytes2;
      return ival;
    };
    Accumulator.prototype.peekDouble = function() {
      this.assertReadableSize(8);
      return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);
    };
    Accumulator.prototype.readDouble = function() {
      var dval = this.peekDouble();
      this.readOffset += 8;
      return dval;
    };
    Accumulator.prototype.readAdvance = function(size) {
      if (size > 0) {
        this.assertReadableSize(size);
      } else if (size < 0 && this.readOffset + size < 0) {
        throw new Error("advance with negative offset " + size + " would seek off the start of the buffer");
      }
      this.readOffset += size;
    };
    Accumulator.prototype.writeByte = function(value) {
      this.reserve(1);
      this.buf.writeInt8(value, this.writeOffset);
      ++this.writeOffset;
    };
    Accumulator.prototype.writeInt = function(value, size) {
      this.reserve(size);
      switch (size) {
        case 1:
          this.buf.writeInt8(value, this.writeOffset);
          break;
        case 2:
          if (isBigEndian) {
            this.buf.writeInt16BE(value, this.writeOffset);
          } else {
            this.buf.writeInt16LE(value, this.writeOffset);
          }
          break;
        case 4:
          if (isBigEndian) {
            this.buf.writeInt32BE(value, this.writeOffset);
          } else {
            this.buf.writeInt32LE(value, this.writeOffset);
          }
          break;
        default:
          throw new Error("unsupported integer size " + size);
      }
      this.writeOffset += size;
    };
    Accumulator.prototype.writeDouble = function(value) {
      this.reserve(8);
      if (isBigEndian) {
        this.buf.writeDoubleBE(value, this.writeOffset);
      } else {
        this.buf.writeDoubleLE(value, this.writeOffset);
      }
      this.writeOffset += 8;
    };
    var BSER_ARRAY = 0;
    var BSER_OBJECT = 1;
    var BSER_STRING = 2;
    var BSER_INT8 = 3;
    var BSER_INT16 = 4;
    var BSER_INT32 = 5;
    var BSER_INT64 = 6;
    var BSER_REAL = 7;
    var BSER_TRUE = 8;
    var BSER_FALSE = 9;
    var BSER_NULL = 10;
    var BSER_TEMPLATE = 11;
    var BSER_SKIP = 12;
    var ST_NEED_PDU = 0;
    var ST_FILL_PDU = 1;
    var MAX_INT8 = 127;
    var MAX_INT16 = 32767;
    var MAX_INT32 = 2147483647;
    function BunserBuf() {
      EE.call(this);
      this.buf = new Accumulator();
      this.state = ST_NEED_PDU;
    }
    util4.inherits(BunserBuf, EE);
    exports2.BunserBuf = BunserBuf;
    BunserBuf.prototype.append = function(buf, synchronous) {
      if (synchronous) {
        this.buf.append(buf);
        return this.process(synchronous);
      }
      try {
        this.buf.append(buf);
      } catch (err) {
        this.emit("error", err);
        return;
      }
      this.processLater();
    };
    BunserBuf.prototype.processLater = function() {
      var self2 = this;
      process.nextTick(function() {
        try {
          self2.process(false);
        } catch (err) {
          self2.emit("error", err);
        }
      });
    };
    BunserBuf.prototype.process = function(synchronous) {
      if (this.state == ST_NEED_PDU) {
        if (this.buf.readAvail() < 2) {
          return;
        }
        this.expectCode(0);
        this.expectCode(1);
        this.pduLen = this.decodeInt(true);
        if (this.pduLen === false) {
          this.buf.readAdvance(-2);
          return;
        }
        this.buf.reserve(this.pduLen);
        this.state = ST_FILL_PDU;
      }
      if (this.state == ST_FILL_PDU) {
        if (this.buf.readAvail() < this.pduLen) {
          return;
        }
        var val = this.decodeAny();
        if (synchronous) {
          return val;
        }
        this.emit("value", val);
        this.state = ST_NEED_PDU;
      }
      if (!synchronous && this.buf.readAvail() > 0) {
        this.processLater();
      }
    };
    BunserBuf.prototype.raise = function(reason) {
      throw new Error(reason + ", in Buffer of length " + this.buf.buf.length + " (" + this.buf.readAvail() + " readable) at offset " + this.buf.readOffset + " buffer: " + JSON.stringify(this.buf.buf.slice(this.buf.readOffset, this.buf.readOffset + 32).toJSON()));
    };
    BunserBuf.prototype.expectCode = function(expected) {
      var code = this.buf.readInt(1);
      if (code != expected) {
        this.raise("expected bser opcode " + expected + " but got " + code);
      }
    };
    BunserBuf.prototype.decodeAny = function() {
      var code = this.buf.peekInt(1);
      switch (code) {
        case BSER_INT8:
        case BSER_INT16:
        case BSER_INT32:
        case BSER_INT64:
          return this.decodeInt();
        case BSER_REAL:
          this.buf.readAdvance(1);
          return this.buf.readDouble();
        case BSER_TRUE:
          this.buf.readAdvance(1);
          return true;
        case BSER_FALSE:
          this.buf.readAdvance(1);
          return false;
        case BSER_NULL:
          this.buf.readAdvance(1);
          return null;
        case BSER_STRING:
          return this.decodeString();
        case BSER_ARRAY:
          return this.decodeArray();
        case BSER_OBJECT:
          return this.decodeObject();
        case BSER_TEMPLATE:
          return this.decodeTemplate();
        default:
          this.raise("unhandled bser opcode " + code);
      }
    };
    BunserBuf.prototype.decodeArray = function() {
      this.expectCode(BSER_ARRAY);
      var nitems = this.decodeInt();
      var arr = [];
      for (var i = 0; i < nitems; ++i) {
        arr.push(this.decodeAny());
      }
      return arr;
    };
    BunserBuf.prototype.decodeObject = function() {
      this.expectCode(BSER_OBJECT);
      var nitems = this.decodeInt();
      var res = {};
      for (var i = 0; i < nitems; ++i) {
        var key = this.decodeString();
        var val = this.decodeAny();
        res[key] = val;
      }
      return res;
    };
    BunserBuf.prototype.decodeTemplate = function() {
      this.expectCode(BSER_TEMPLATE);
      var keys = this.decodeArray();
      var nitems = this.decodeInt();
      var arr = [];
      for (var i = 0; i < nitems; ++i) {
        var obj = {};
        for (var keyidx = 0; keyidx < keys.length; ++keyidx) {
          if (this.buf.peekInt(1) == BSER_SKIP) {
            this.buf.readAdvance(1);
            continue;
          }
          var val = this.decodeAny();
          obj[keys[keyidx]] = val;
        }
        arr.push(obj);
      }
      return arr;
    };
    BunserBuf.prototype.decodeString = function() {
      this.expectCode(BSER_STRING);
      var len = this.decodeInt();
      return this.buf.readString(len);
    };
    BunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {
      if (relaxSizeAsserts && this.buf.readAvail() < 1) {
        return false;
      } else {
        this.buf.assertReadableSize(1);
      }
      var code = this.buf.peekInt(1);
      var size = 0;
      switch (code) {
        case BSER_INT8:
          size = 1;
          break;
        case BSER_INT16:
          size = 2;
          break;
        case BSER_INT32:
          size = 4;
          break;
        case BSER_INT64:
          size = 8;
          break;
        default:
          this.raise("invalid bser int encoding " + code);
      }
      if (relaxSizeAsserts && this.buf.readAvail() < 1 + size) {
        return false;
      }
      this.buf.readAdvance(1);
      return this.buf.readInt(size);
    };
    function loadFromBuffer(input) {
      var buf = new BunserBuf();
      var result = buf.append(input, true);
      if (buf.buf.readAvail()) {
        throw Error("excess data found after input buffer, use BunserBuf instead");
      }
      if (typeof result === "undefined") {
        throw Error("no bser found in string and no error raised!?");
      }
      return result;
    }
    exports2.loadFromBuffer = loadFromBuffer;
    function byteswap64(buf) {
      var swap = Buffer.alloc(buf.length);
      for (var i = 0; i < buf.length; i++) {
        swap[i] = buf[buf.length - 1 - i];
      }
      return swap;
    }
    function dump_int64(buf, val) {
      var be = val.toBuffer();
      if (isBigEndian) {
        buf.writeByte(BSER_INT64);
        buf.append(be);
        return;
      }
      var le = byteswap64(be);
      buf.writeByte(BSER_INT64);
      buf.append(le);
    }
    function dump_int(buf, val) {
      var abs = Math.abs(val);
      if (abs <= MAX_INT8) {
        buf.writeByte(BSER_INT8);
        buf.writeInt(val, 1);
      } else if (abs <= MAX_INT16) {
        buf.writeByte(BSER_INT16);
        buf.writeInt(val, 2);
      } else if (abs <= MAX_INT32) {
        buf.writeByte(BSER_INT32);
        buf.writeInt(val, 4);
      } else {
        dump_int64(buf, new Int64(val));
      }
    }
    function dump_any(buf, val) {
      switch (typeof val) {
        case "number":
          if (isFinite(val) && Math.floor(val) === val) {
            dump_int(buf, val);
          } else {
            buf.writeByte(BSER_REAL);
            buf.writeDouble(val);
          }
          return;
        case "string":
          buf.writeByte(BSER_STRING);
          dump_int(buf, Buffer.byteLength(val));
          buf.append(val);
          return;
        case "boolean":
          buf.writeByte(val ? BSER_TRUE : BSER_FALSE);
          return;
        case "object":
          if (val === null) {
            buf.writeByte(BSER_NULL);
            return;
          }
          if (val instanceof Int64) {
            dump_int64(buf, val);
            return;
          }
          if (Array.isArray(val)) {
            buf.writeByte(BSER_ARRAY);
            dump_int(buf, val.length);
            for (var i = 0; i < val.length; ++i) {
              dump_any(buf, val[i]);
            }
            return;
          }
          buf.writeByte(BSER_OBJECT);
          var keys = Object.keys(val);
          var num_keys = keys.length;
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var v = val[key];
            if (typeof v == "undefined") {
              num_keys--;
            }
          }
          dump_int(buf, num_keys);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var v = val[key];
            if (typeof v == "undefined") {
              continue;
            }
            dump_any(buf, key);
            try {
              dump_any(buf, v);
            } catch (e) {
              throw new Error(e.message + " (while serializing object property with name `" + key + "')");
            }
          }
          return;
        default:
          throw new Error("cannot serialize type " + typeof val + " to BSER");
      }
    }
    function dumpToBuffer(val) {
      var buf = new Accumulator();
      buf.writeByte(0);
      buf.writeByte(1);
      buf.writeByte(BSER_INT32);
      buf.writeInt(0, 4);
      dump_any(buf, val);
      var off = buf.writeOffset;
      var len = off - 7;
      buf.writeOffset = 3;
      buf.writeInt(len, 4);
      buf.writeOffset = off;
      return buf.buf.slice(0, off);
    }
    exports2.dumpToBuffer = dumpToBuffer;
  }
});

// node_modules/fb-watchman/index.js
var require_fb_watchman = __commonJS({
  "node_modules/fb-watchman/index.js"(exports2, module2) {
    "use strict";
    var net3 = require("net");
    var EE = require("events").EventEmitter;
    var util4 = require("util");
    var childProcess = require("child_process");
    var bser = require_bser();
    var unilateralTags = ["subscription", "log"];
    function Client2(options) {
      var self2 = this;
      EE.call(this);
      this.watchmanBinaryPath = "watchman";
      if (options && options.watchmanBinaryPath) {
        this.watchmanBinaryPath = options.watchmanBinaryPath.trim();
      }
      ;
      this.commands = [];
    }
    util4.inherits(Client2, EE);
    module2.exports.Client = Client2;
    Client2.prototype.sendNextCommand = function() {
      if (this.currentCommand) {
        return;
      }
      this.currentCommand = this.commands.shift();
      if (!this.currentCommand) {
        return;
      }
      this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));
    };
    Client2.prototype.cancelCommands = function(why) {
      var error = new Error(why);
      var cmds = this.commands;
      this.commands = [];
      if (this.currentCommand) {
        cmds.unshift(this.currentCommand);
        this.currentCommand = null;
      }
      cmds.forEach(function(cmd) {
        cmd.cb(error);
      });
    };
    Client2.prototype.connect = function() {
      var self2 = this;
      function makeSock(sockname) {
        self2.bunser = new bser.BunserBuf();
        self2.bunser.on("value", function(obj) {
          var unilateral = false;
          for (var i = 0; i < unilateralTags.length; i++) {
            var tag = unilateralTags[i];
            if (tag in obj) {
              unilateral = tag;
            }
          }
          if (unilateral) {
            self2.emit(unilateral, obj);
          } else if (self2.currentCommand) {
            var cmd = self2.currentCommand;
            self2.currentCommand = null;
            if ("error" in obj) {
              var error = new Error(obj.error);
              error.watchmanResponse = obj;
              cmd.cb(error);
            } else {
              cmd.cb(null, obj);
            }
          }
          self2.sendNextCommand();
        });
        self2.bunser.on("error", function(err) {
          self2.emit("error", err);
        });
        self2.socket = net3.createConnection(sockname);
        self2.socket.on("connect", function() {
          self2.connecting = false;
          self2.emit("connect");
          self2.sendNextCommand();
        });
        self2.socket.on("error", function(err) {
          self2.connecting = false;
          self2.emit("error", err);
        });
        self2.socket.on("data", function(buf) {
          if (self2.bunser) {
            self2.bunser.append(buf);
          }
        });
        self2.socket.on("end", function() {
          self2.socket = null;
          self2.bunser = null;
          self2.cancelCommands("The watchman connection was closed");
          self2.emit("end");
        });
      }
      if (process.env.WATCHMAN_SOCK) {
        makeSock(process.env.WATCHMAN_SOCK);
        return;
      }
      var args = ["--no-pretty", "get-sockname"];
      var proc = null;
      var spawnFailed = false;
      function spawnError(error) {
        if (spawnFailed) {
          return;
        }
        spawnFailed = true;
        if (error.errno === "EACCES") {
          error.message = "The Watchman CLI is installed but cannot be spawned because of a permission problem";
        } else if (error.errno === "ENOENT") {
          error.message = "Watchman was not found in PATH.  See https://facebook.github.io/watchman/docs/install.html for installation instructions";
        }
        console.error("Watchman: ", error.message);
        self2.emit("error", error);
      }
      try {
        proc = childProcess.spawn(this.watchmanBinaryPath, args, {
          stdio: ["ignore", "pipe", "pipe"]
        });
      } catch (error) {
        spawnError(error);
        return;
      }
      var stdout = [];
      var stderr = [];
      proc.stdout.on("data", function(data) {
        stdout.push(data);
      });
      proc.stderr.on("data", function(data) {
        data = data.toString("utf8");
        stderr.push(data);
        console.error(data);
      });
      proc.on("error", function(error) {
        spawnError(error);
      });
      proc.on("close", function(code, signal) {
        if (code !== 0) {
          spawnError(new Error(self2.watchmanBinaryPath + " " + args.join(" ") + " returned with exit code=" + code + ", signal=" + signal + ", stderr= " + stderr.join("")));
          return;
        }
        try {
          var obj = JSON.parse(stdout.join(""));
          if ("error" in obj) {
            var error = new Error(obj.error);
            error.watchmanResponse = obj;
            self2.emit("error", error);
            return;
          }
          makeSock(obj.sockname);
        } catch (e) {
          self2.emit("error", e);
        }
      });
    };
    Client2.prototype.command = function(args, done) {
      done = done || function() {
      };
      this.commands.push({ cmd: args, cb: done });
      if (!this.socket) {
        if (!this.connecting) {
          this.connecting = true;
          this.connect();
          return;
        }
        return;
      }
      this.sendNextCommand();
    };
    var cap_versions = {
      "cmd-watch-del-all": "3.1.1",
      "cmd-watch-project": "3.1",
      "relative_root": "3.3",
      "term-dirname": "3.1",
      "term-idirname": "3.1",
      "wildmatch": "3.7"
    };
    function vers_compare(a, b) {
      a = a.split(".");
      b = b.split(".");
      for (var i = 0; i < 3; i++) {
        var d = parseInt(a[i] || "0") - parseInt(b[i] || "0");
        if (d != 0) {
          return d;
        }
      }
      return 0;
    }
    function have_cap(vers, name2) {
      if (name2 in cap_versions) {
        return vers_compare(vers, cap_versions[name2]) >= 0;
      }
      return false;
    }
    Client2.prototype._synthesizeCapabilityCheck = function(resp, optional, required) {
      resp.capabilities = {};
      var version2 = resp.version;
      optional.forEach(function(name2) {
        resp.capabilities[name2] = have_cap(version2, name2);
      });
      required.forEach(function(name2) {
        var have = have_cap(version2, name2);
        resp.capabilities[name2] = have;
        if (!have) {
          resp.error = "client required capability `" + name2 + "` is not supported by this server";
        }
      });
      return resp;
    };
    Client2.prototype.capabilityCheck = function(caps, done) {
      var optional = caps.optional || [];
      var required = caps.required || [];
      var self2 = this;
      this.command(["version", {
        optional,
        required
      }], function(error, resp) {
        if (error) {
          done(error);
          return;
        }
        if (!("capabilities" in resp)) {
          resp = self2._synthesizeCapabilityCheck(resp, optional, required);
          if (resp.error) {
            error = new Error(resp.error);
            error.watchmanResponse = resp;
            done(error);
            return;
          }
        }
        done(null, resp);
      });
    };
    Client2.prototype.end = function() {
      this.cancelCommands("The client was ended");
      if (this.socket) {
        this.socket.end();
        this.socket = null;
      }
      this.bunser = null;
    };
  }
});

// src/watchman.ts
function isValidWatchRoot(root) {
  if (root == "/" || root == "/tmp" || root == "/private/tmp")
    return false;
  if (root.toLowerCase() === import_os3.default.homedir().toLowerCase())
    return false;
  if (import_path10.default.parse(root).base == root)
    return false;
  if (root.startsWith("/tmp/") || root.startsWith("/private/tmp/"))
    return false;
  if (isParentFolder(import_os3.default.tmpdir(), root, true))
    return false;
  return true;
}
var import_fb_watchman, import_os3, import_path10, import_vscode_languageserver_protocol12, import_minimatch4, logger24, requiredCapabilities, clientsMap, Watchman;
var init_watchman = __esm({
  "src/watchman.ts"() {
    import_fb_watchman = __toModule(require_fb_watchman());
    import_os3 = __toModule(require("os"));
    import_path10 = __toModule(require("path"));
    init_esm_node();
    import_vscode_languageserver_protocol12 = __toModule(require_main2());
    import_minimatch4 = __toModule(require_minimatch());
    init_fs();
    logger24 = require_logger2()("watchman");
    requiredCapabilities = ["relative_root", "cmd-watch-project", "wildmatch", "field-new"];
    clientsMap = new Map();
    Watchman = class {
      constructor(binaryPath, channel) {
        this.channel = channel;
        this._disposed = false;
        this.client = new import_fb_watchman.default.Client({
          watchmanBinaryPath: binaryPath
        });
        this.client.setMaxListeners(300);
      }
      checkCapability() {
        let { client } = this;
        return new Promise((resolve3, reject) => {
          client.capabilityCheck({
            optional: [],
            required: requiredCapabilities
          }, (error, resp) => {
            if (error)
              return reject(error);
            let { capabilities } = resp;
            for (let key of Object.keys(capabilities)) {
              if (!capabilities[key])
                return resolve3(false);
            }
            resolve3(true);
          });
        });
      }
      async watchProject(root) {
        try {
          let resp = await this.command(["watch-project", root]);
          let { watch, warning, relative_path } = resp;
          if (warning)
            logger24.warn(warning);
          this.watch = watch;
          this.relative_path = relative_path;
          logger24.info(`watchman watching project: ${root}`);
          this.appendOutput(`watchman watching project: ${root}`);
        } catch (e) {
          logger24.error(e);
          return false;
        }
        return true;
      }
      command(args) {
        return new Promise((resolve3, reject) => {
          this.client.command(args, (error, resp) => {
            if (error)
              return reject(error);
            resolve3(resp);
          });
        });
      }
      async subscribe(globPattern, cb) {
        let { watch, relative_path } = this;
        if (!watch) {
          this.appendOutput(`watchman not watching: ${watch}`, "Error");
          return null;
        }
        let { clock } = await this.command(["clock", watch]);
        let uid = v1_default();
        let sub = {
          expression: ["allof", ["match", "**/*", "wholename"]],
          fields: ["name", "size", "new", "exists", "type", "mtime_ms", "ctime_ms"],
          since: clock
        };
        let root = watch;
        if (relative_path) {
          sub.relative_root = relative_path;
          root = import_path10.default.join(watch, relative_path);
        }
        let { subscribe } = await this.command(["subscribe", watch, uid, sub]);
        if (global.hasOwnProperty("__TEST__"))
          global.subscribe = subscribe;
        this.appendOutput(`subscribing "${globPattern}" in ${root}`);
        this.client.on("subscription", (resp) => {
          if (!resp || resp.subscription != uid)
            return;
          let { files } = resp;
          if (!files)
            return;
          files = files.filter((f) => f.type == "f" && (0, import_minimatch4.default)(f.name, globPattern, { dot: true }));
          if (!files.length)
            return;
          let ev = Object.assign({}, resp);
          if (this.relative_path)
            ev.root = import_path10.default.resolve(resp.root, this.relative_path);
          this.appendOutput(`file change detected: ${JSON.stringify(ev, null, 2)}`);
          cb(ev);
        });
        return import_vscode_languageserver_protocol12.Disposable.create(() => this.unsubscribe(subscribe));
      }
      unsubscribe(subscription) {
        if (this._disposed)
          return Promise.resolve();
        let { watch } = this;
        if (!watch)
          return;
        this.appendOutput(`unsubscribe "${subscription}" in: ${watch}`);
        return this.command(["unsubscribe", watch, subscription]).catch((e) => {
          logger24.error(e);
        });
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        this.client.removeAllListeners();
        this.client.end();
      }
      appendOutput(message, type = "Info") {
        if (this.channel) {
          this.channel.appendLine(`[${type}  - ${new Date().toLocaleTimeString()}] ${message}`);
        }
      }
      static dispose() {
        for (let promise of clientsMap.values()) {
          promise.then((client) => {
            client.dispose();
          }, (_e) => {
          });
        }
      }
      static createClient(binaryPath, root, channel) {
        if (!isValidWatchRoot(root))
          return null;
        let client = clientsMap.get(root);
        if (client)
          return client;
        let promise = new Promise(async (resolve3, reject) => {
          try {
            let watchman2 = new Watchman(binaryPath, channel);
            let valid = await watchman2.checkCapability();
            if (!valid)
              return resolve3(null);
            let watching = await watchman2.watchProject(root);
            if (!watching)
              return resolve3(null);
            resolve3(watchman2);
          } catch (e) {
            reject(e);
          }
        });
        clientsMap.set(root, promise);
        return promise;
      }
    };
  }
});

// package.json
var version;
var init_package = __esm({
  "package.json"() {
    version = "0.0.80";
  }
});

// src/workspace.ts
var import_bytes, import_fast_diff2, import_fs_extra4, import_os4, import_path11, import_vscode_languageserver_protocol13, import_which2, APIVERSION, logger25, NAME_SPACE, methods, Workspace, workspace_default;
var init_workspace = __esm({
  "src/workspace.ts"() {
    import_bytes = __toModule(require_bytes());
    import_fast_diff2 = __toModule(require_diff());
    import_fs_extra4 = __toModule(require_lib5());
    import_os4 = __toModule(require("os"));
    import_path11 = __toModule(require("path"));
    init_esm_node();
    import_vscode_languageserver_protocol13 = __toModule(require_main2());
    init_esm2();
    import_which2 = __toModule(require_which());
    init_channels();
    init_configuration2();
    init_shape();
    init_events();
    init_db();
    init_document();
    init_fileSystemWatcher();
    init_mru();
    init_resolver();
    init_task();
    init_terminal();
    init_bufferSync();
    init_types();
    init_array();
    init_fs();
    init_util();
    init_match();
    init_position();
    init_string();
    init_watchman();
    init_window();
    init_package();
    APIVERSION = 10;
    logger25 = require_logger2()("workspace");
    NAME_SPACE = 2e3;
    methods = [
      "showMessage",
      "runTerminalCommand",
      "openTerminal",
      "showQuickpick",
      "menuPick",
      "openLocalConfig",
      "showPrompt",
      "createStatusBarItem",
      "createOutputChannel",
      "showOutputChannel",
      "requestInput",
      "echoLines",
      "getCursorPosition",
      "moveTo",
      "getOffset"
    ];
    Workspace = class {
      constructor() {
        this.keymaps = new Map();
        this.resolver = new Resolver();
        this.rootPatterns = new Map();
        this._workspaceFolders = [];
        this._insertMode = false;
        this._cwd = process.cwd();
        this._initialized = false;
        this._attached = false;
        this.buffers = new Map();
        this.autocmdMaxId = 0;
        this.autocmds = new Map();
        this.terminals = new Map();
        this.creatingSources = new Map();
        this.schemeProviderMap = new Map();
        this.namespaceMap = new Map();
        this.disposables = [];
        this.watchedOptions = new Set();
        this._dynAutocmd = false;
        this._disposed = false;
        this._onDidOpenDocument = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidCloseDocument = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidChangeDocument = new import_vscode_languageserver_protocol13.Emitter();
        this._onWillSaveDocument = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidSaveDocument = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidChangeWorkspaceFolders = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidChangeConfiguration = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidWorkspaceInitialized = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidOpenTerminal = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidCloseTerminal = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidRuntimePathChange = new import_vscode_languageserver_protocol13.Emitter();
        this.onDidCloseTerminal = this._onDidCloseTerminal.event;
        this.onDidOpenTerminal = this._onDidOpenTerminal.event;
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        this.onDidOpenTextDocument = this._onDidOpenDocument.event;
        this.onDidCloseTextDocument = this._onDidCloseDocument.event;
        this.onDidChangeTextDocument = this._onDidChangeDocument.event;
        this.onWillSaveTextDocument = this._onWillSaveDocument.event;
        this.onDidSaveTextDocument = this._onDidSaveDocument.event;
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this.onDidWorkspaceInitialized = this._onDidWorkspaceInitialized.event;
        this.onDidRuntimePathChange = this._onDidRuntimePathChange.event;
        this._onDidCreateFiles = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidRenameFiles = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidDeleteFiles = new import_vscode_languageserver_protocol13.Emitter();
        this._onWillCreateFiles = new import_vscode_languageserver_protocol13.Emitter();
        this._onWillRenameFiles = new import_vscode_languageserver_protocol13.Emitter();
        this._onWillDeleteFiles = new import_vscode_languageserver_protocol13.Emitter();
        this.onDidCreateFiles = this._onDidCreateFiles.event;
        this.onDidRenameFiles = this._onDidRenameFiles.event;
        this.onDidDeleteFiles = this._onDidDeleteFiles.event;
        this.onWillCreateFiles = this._onWillCreateFiles.event;
        this.onWillRenameFiles = this._onWillRenameFiles.event;
        this.onWillDeleteFiles = this._onWillDeleteFiles.event;
        this.version = version;
        this.configurations = this.createConfigurations();
        let cwd = process.cwd();
        if (cwd != import_os4.default.homedir() && inDirectory(cwd, [".vim"])) {
          this._workspaceFolders.push({
            uri: URI.file(cwd).toString(),
            name: import_path11.default.basename(cwd)
          });
        }
      }
      async init() {
        let { nvim } = this;
        for (let method of methods) {
          Object.defineProperty(this, method, {
            get: () => {
              return (...args) => {
                return window_default[method].apply(window_default, args);
              };
            }
          });
        }
        this._env = await nvim.call("coc#util#vim_info");
        if (this._env.apiversion != APIVERSION) {
          console.error(`API version ${this._env.apiversion} is not ${APIVERSION}, please build coc.nvim by 'yarn install' after pull source code.`);
          process.exit();
        }
        this._insertMode = this._env.mode.startsWith("insert");
        if (this._env.workspaceFolders && Array.isArray(this._env.workspaceFolders)) {
          this._workspaceFolders = this._env.workspaceFolders.map((f) => ({
            uri: URI.file(f).toString(),
            name: import_path11.default.dirname(f)
          }));
        }
        this.configurations.updateUserConfig(this._env.config);
        let preferences = this.getConfiguration("coc.preferences");
        let maxFileSize = preferences.get("maxFileSize", "10MB");
        this.maxFileSize = import_bytes.default.parse(maxFileSize);
        events_default.on(["InsertEnter", "CursorMovedI"], () => {
          this._insertMode = true;
        }, null, this.disposables);
        events_default.on(["InsertLeave", "CursorMoved"], () => {
          this._insertMode = false;
        }, null, this.disposables);
        events_default.on("BufEnter", this.onBufEnter, this, this.disposables);
        events_default.on("CursorMoved", this.checkCurrentBuffer, this, this.disposables);
        events_default.on("CursorMovedI", this.checkCurrentBuffer, this, this.disposables);
        events_default.on("DirChanged", this.onDirChanged, this, this.disposables);
        events_default.on("BufCreate", this.onBufCreate, this, this.disposables);
        events_default.on("BufUnload", this.onBufUnload, this, this.disposables);
        events_default.on("TermOpen", this.onBufCreate, this, this.disposables);
        events_default.on("TermClose", this.onBufUnload, this, this.disposables);
        events_default.on("BufWritePost", this.onBufWritePost, this, this.disposables);
        events_default.on("BufWritePre", this.onBufWritePre, this, this.disposables);
        events_default.on("FileType", this.onFileTypeChange, this, this.disposables);
        events_default.on("CursorHold", this.checkCurrentBuffer, this, this.disposables);
        events_default.on("TextChanged", this.checkBuffer, this, this.disposables);
        events_default.on("BufReadCmd", this.onBufReadCmd, this, this.disposables);
        events_default.on("VimResized", (columns, lines) => {
          Object.assign(this._env, { columns, lines });
        }, null, this.disposables);
        await this.attach();
        this.attachChangedEvents();
        this.configurations.onDidChange((e) => {
          this._onDidChangeConfiguration.fire(e);
        }, null, this.disposables);
        this.watchOption("runtimepath", (oldValue, newValue) => {
          let result = (0, import_fast_diff2.default)(oldValue, newValue);
          for (let [changeType, value] of result) {
            if (changeType == 1) {
              let paths = value.replace(/,$/, "").split(",");
              this._onDidRuntimePathChange.fire(paths);
            }
          }
          this._env.runtimepath = newValue;
        }, this.disposables);
        this.watchGlobal("coc_sources_disable_map", async (_, newValue) => {
          this.env.disabledSources = newValue;
        });
        this.disposables.push(this.registerTextDocumentContentProvider("output", channels_default.getProvider(nvim)));
      }
      getConfigFile(target) {
        return this.configurations.getConfigFile(target);
      }
      registerAutocmd(autocmd) {
        this.autocmdMaxId += 1;
        let id = this.autocmdMaxId;
        this.autocmds.set(id, autocmd);
        this.setupDynamicAutocmd();
        return import_vscode_languageserver_protocol13.Disposable.create(() => {
          this.autocmds.delete(id);
          this.setupDynamicAutocmd();
        });
      }
      watchOption(key, callback, disposables) {
        let watching = this.watchedOptions.has(key);
        if (!watching) {
          this.watchedOptions.add(key);
          this.setupDynamicAutocmd();
        }
        let disposable = events_default.on("OptionSet", async (changed, oldValue, newValue) => {
          if (changed == key && callback) {
            await Promise.resolve(callback(oldValue, newValue));
          }
        });
        if (disposables) {
          disposables.push(import_vscode_languageserver_protocol13.Disposable.create(() => {
            disposable.dispose();
            if (watching)
              return;
            this.watchedOptions.delete(key);
            this.setupDynamicAutocmd();
          }));
        }
      }
      watchGlobal(key, callback, disposables) {
        let { nvim } = this;
        nvim.call("coc#_watch", key, true);
        let disposable = events_default.on("GlobalChange", async (changed, oldValue, newValue) => {
          if (changed == key && callback) {
            await Promise.resolve(callback(oldValue, newValue));
          }
        });
        if (disposables) {
          disposables.push(import_vscode_languageserver_protocol13.Disposable.create(() => {
            disposable.dispose();
            nvim.call("coc#_unwatch", key, true);
          }));
        }
      }
      get cwd() {
        return this._cwd;
      }
      get env() {
        return this._env;
      }
      get root() {
        return this._root || this.cwd;
      }
      get rootPath() {
        return this.root;
      }
      get workspaceFolders() {
        return this._workspaceFolders;
      }
      get uri() {
        let { bufnr } = this;
        if (bufnr) {
          let document2 = this.getDocument(bufnr);
          if (document2 && document2.schema == "file") {
            return document2.uri;
          }
        }
        return null;
      }
      get workspaceFolder() {
        let { rootPath } = this;
        if (rootPath == import_os4.default.homedir())
          return null;
        return {
          uri: URI.file(rootPath).toString(),
          name: import_path11.default.basename(rootPath)
        };
      }
      get textDocuments() {
        let docs = [];
        for (let b of this.buffers.values()) {
          docs.push(b.textDocument);
        }
        return docs;
      }
      get documents() {
        return Array.from(this.buffers.values());
      }
      createNameSpace(name2 = "") {
        if (this.namespaceMap.has(name2))
          return this.namespaceMap.get(name2);
        NAME_SPACE = NAME_SPACE + 1;
        this.namespaceMap.set(name2, NAME_SPACE);
        return NAME_SPACE;
      }
      get channelNames() {
        return channels_default.names;
      }
      get pluginRoot() {
        return import_path11.default.dirname(__dirname);
      }
      get isVim() {
        return this._env.isVim;
      }
      get isNvim() {
        return !this._env.isVim;
      }
      get completeOpt() {
        return this._env.completeOpt;
      }
      get initialized() {
        return this._initialized;
      }
      get ready() {
        if (this._initialized)
          return Promise.resolve();
        return new Promise((resolve3) => {
          let disposable = this.onDidWorkspaceInitialized(() => {
            disposable.dispose();
            resolve3();
          });
        });
      }
      get filetypes() {
        let res = new Set();
        for (let doc of this.documents) {
          res.add(doc.filetype);
        }
        return res;
      }
      match(selector, document2) {
        return score(selector, document2.uri, document2.languageId);
      }
      async findUp(filename) {
        let { cwd } = this;
        let filepath = await this.nvim.call("expand", "%:p");
        filepath = import_path11.default.normalize(filepath);
        let isFile2 = filepath && import_path11.default.isAbsolute(filepath);
        if (isFile2 && !isParentFolder(cwd, filepath, true)) {
          return findUp(filename, import_path11.default.dirname(filepath));
        }
        let res = findUp(filename, cwd);
        if (res && res != import_os4.default.homedir())
          return res;
        if (isFile2)
          return findUp(filename, import_path11.default.dirname(filepath));
        return null;
      }
      async resolveRootFolder(uri, patterns) {
        let { cwd } = this;
        if (uri.scheme != "file")
          return cwd;
        let filepath = import_path11.default.normalize(uri.fsPath);
        let dir = import_path11.default.dirname(filepath);
        return resolveRoot(dir, patterns) || dir;
      }
      createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete) {
        let watchmanPath = global.hasOwnProperty("__TEST__") ? null : this.getWatchmanPath();
        let channel = watchmanPath ? window_default.createOutputChannel("watchman") : null;
        let promise = watchmanPath ? Watchman.createClient(watchmanPath, this.root, channel) : Promise.resolve(null);
        let watcher = new FileSystemWatcher(promise, globPattern, !!ignoreCreate, !!ignoreChange, !!ignoreDelete);
        return watcher;
      }
      getWatchmanPath() {
        const preferences = this.getConfiguration("coc.preferences");
        let watchmanPath = preferences.get("watchmanPath", "watchman");
        try {
          return import_which2.default.sync(watchmanPath);
        } catch (e) {
          return null;
        }
      }
      getConfiguration(section2, resource) {
        return this.configurations.getConfiguration(section2, resource);
      }
      getDocument(uri) {
        if (typeof uri === "number") {
          return this.buffers.get(uri);
        }
        const caseInsensitive = platform_exports.isWindows || platform_exports.isMacintosh;
        uri = URI.parse(uri).toString();
        for (let doc of this.buffers.values()) {
          if (!doc)
            continue;
          if (doc.uri === uri)
            return doc;
          if (import_path11.default.resolve(doc.uri) === import_path11.default.resolve(uri))
            return doc;
          if (caseInsensitive && doc.uri.toLowerCase() === uri.toLowerCase())
            return doc;
        }
        return null;
      }
      async applyEdit(edit2) {
        let { nvim } = this;
        let { documentChanges, changes } = edit2;
        let [bufnr, cursor] = await nvim.eval('[bufnr("%"),coc#cursor#position()]');
        let document2 = this.getDocument(bufnr);
        let uri = document2 ? document2.uri : null;
        let currEdits = null;
        let locations = [];
        let changeCount = 0;
        const preferences = this.getConfiguration("coc.preferences");
        let promptUser = !global.hasOwnProperty("__TEST__") && preferences.get("promptWorkspaceEdit", true);
        let listTarget = preferences.get("listOfWorkspaceEdit", "quickfix");
        try {
          if (documentChanges && documentChanges.length) {
            let changedUris = this.getChangedUris(documentChanges);
            changeCount = changedUris.length;
            if (promptUser) {
              let diskCount = changedUris.reduce((p, c) => {
                return p + (this.getDocument(c) == null ? 1 : 0);
              }, 0);
              if (diskCount) {
                let res = await window_default.showPrompt(`${diskCount} documents on disk would be loaded for change, confirm?`);
                if (!res)
                  return;
              }
            }
            let changedMap = new Map();
            for (const change of documentChanges) {
              if (import_vscode_languageserver_protocol13.TextDocumentEdit.is(change)) {
                let { textDocument, edits } = change;
                let doc = await this.loadFile(textDocument.uri);
                if (textDocument.uri == uri)
                  currEdits = edits;
                await doc.applyEdits(edits);
                for (let edit3 of edits) {
                  locations.push({ uri: doc.uri, range: edit3.range });
                }
              } else if (import_vscode_languageserver_protocol13.CreateFile.is(change)) {
                let file = URI.parse(change.uri).fsPath;
                await this.createFile(file, change.options);
              } else if (import_vscode_languageserver_protocol13.RenameFile.is(change)) {
                changedMap.set(change.oldUri, change.newUri);
                await this.renameFile(URI.parse(change.oldUri).fsPath, URI.parse(change.newUri).fsPath, change.options);
              } else if (import_vscode_languageserver_protocol13.DeleteFile.is(change)) {
                await this.deleteFile(URI.parse(change.uri).fsPath, change.options);
              }
            }
            if (changedMap.size) {
              locations.forEach((location) => {
                let newUri = changedMap.get(location.uri);
                if (newUri)
                  location.uri = newUri;
              });
            }
          } else if (changes) {
            let uris = Object.keys(changes);
            let unloaded = uris.filter((uri2) => this.getDocument(uri2) == null);
            if (unloaded.length) {
              if (promptUser) {
                let res = await window_default.showPrompt(`${unloaded.length} documents on disk would be loaded for change, confirm?`);
                if (!res)
                  return;
              }
              await this.loadFiles(unloaded);
            }
            for (let uri2 of Object.keys(changes)) {
              let document3 = this.getDocument(uri2);
              if (URI.parse(uri2).toString() == uri2)
                currEdits = changes[uri2];
              let edits = changes[uri2];
              for (let edit3 of edits) {
                locations.push({ uri: document3.uri, range: edit3.range });
              }
              await document3.applyEdits(edits);
            }
            changeCount = uris.length;
          }
          if (currEdits) {
            let changed = getChangedFromEdits({ line: cursor[0], character: cursor[1] }, currEdits);
            if (changed)
              await window_default.moveTo({
                line: cursor[0] + changed.line,
                character: cursor[1] + changed.character
              });
          }
          if (locations.length) {
            let items = await Promise.all(locations.map((loc) => this.getQuickfixItem(loc)));
            let silent = locations.every((l) => l.uri == uri);
            if (listTarget == "quickfix") {
              await this.nvim.call("setqflist", [items]);
              if (!silent)
                window_default.showMessage(`changed ${changeCount} buffers, use :wa to save changes to disk and :copen to open quickfix list`, "more");
            } else if (listTarget == "location") {
              await nvim.setVar("coc_jump_locations", items);
              if (!silent)
                window_default.showMessage(`changed ${changeCount} buffers, use :wa to save changes to disk and :CocList location to manage changed locations`, "more");
            }
          }
        } catch (e) {
          logger25.error("Error on applyEdits:", edit2, e);
          window_default.showMessage(`Error on applyEdits: ${e.message}`, "error");
          return false;
        }
        await wait(50);
        return true;
      }
      async getQuickfixItem(loc, text, type = "", module2) {
        if (import_vscode_languageserver_protocol13.LocationLink.is(loc)) {
          loc = import_vscode_languageserver_protocol13.Location.create(loc.targetUri, loc.targetRange);
        }
        let doc = this.getDocument(loc.uri);
        let { uri, range } = loc;
        let { line, character } = range.start;
        let sl = range.start.line;
        let sc = range.start.character;
        let el = range.end.line;
        let ec = range.end.character;
        let u = URI.parse(uri);
        let bufnr = doc ? doc.bufnr : -1;
        if (!text && u.scheme == "file") {
          text = await this.getLine(uri, line);
          character = byteIndex(text, character);
        }
        let item = {
          uri,
          filename: u.scheme == "file" ? u.fsPath : uri,
          lnum: sl + 1,
          end_lnum: el + 1,
          col: sc + 1,
          end_col: ec + 1,
          text: text || "",
          range
        };
        if (module2)
          item.module = module2;
        if (type)
          item.type = type;
        if (bufnr != -1)
          item.bufnr = bufnr;
        return item;
      }
      createMru(name2) {
        return new Mru(name2);
      }
      async getSelectedRange(mode, document2) {
        let { nvim } = this;
        if (mode === "line") {
          let line = await nvim.call("line", ["."]);
          let content = document2.getline(line - 1);
          if (!content.length)
            return null;
          return import_vscode_languageserver_protocol13.Range.create(line - 1, 0, line, 0);
        }
        if (mode === "cursor") {
          let [line, character] = await nvim.eval("coc#cursor#position()");
          return import_vscode_languageserver_protocol13.Range.create(line, character, line, character);
        }
        if (!["v", "V", "char", "line", ""].includes(mode)) {
          throw new Error(`Mode '${mode}' not supported`);
        }
        let isVisual = ["v", "V", ""].includes(mode);
        let [, sl, sc] = await nvim.call("getpos", isVisual ? `'<` : `'[`);
        let [, el, ec] = await nvim.call("getpos", isVisual ? `'>` : `']`);
        let range = import_vscode_languageserver_protocol13.Range.create(document2.getPosition(sl, sc), document2.getPosition(el, ec));
        if (mode == "v" || mode == "") {
          range.end.character = range.end.character + 1;
        }
        return range;
      }
      async selectRange(range) {
        let { nvim } = this;
        let { start, end } = range;
        let [bufnr, ve, selection] = await nvim.eval(`[bufnr('%'), &virtualedit, &selection]`);
        let doc = this.getDocument(bufnr);
        if (!doc || !doc.attached)
          return;
        let line = doc.getline(start.line);
        let col = line ? byteLength(line.slice(0, start.character)) : 0;
        let endLine = doc.getline(end.line);
        let endCol = endLine ? byteLength(endLine.slice(0, end.character)) : 0;
        let move_cmd = "";
        let resetVirtualEdit = false;
        move_cmd += "v";
        endCol = await nvim.eval(`virtcol([${end.line + 1}, ${endCol}])`);
        if (selection == "inclusive") {
          if (end.character == 0) {
            move_cmd += `${end.line}G`;
          } else {
            move_cmd += `${end.line + 1}G${endCol}|`;
          }
        } else if (selection == "old") {
          move_cmd += `${end.line + 1}G${endCol}|`;
        } else {
          move_cmd += `${end.line + 1}G${endCol + 1}|`;
        }
        col = await nvim.eval(`virtcol([${start.line + 1}, ${col}])`);
        move_cmd += `o${start.line + 1}G${col + 1}|o`;
        nvim.pauseNotification();
        if (ve != "onemore") {
          resetVirtualEdit = true;
          nvim.setOption("virtualedit", "onemore", true);
        }
        nvim.command(`noa call cursor(${start.line + 1},${col + (move_cmd == "a" ? 0 : 1)})`, true);
        nvim.command(`normal! ${move_cmd}`, true);
        if (resetVirtualEdit)
          nvim.setOption("virtualedit", ve, true);
        if (this.isVim)
          nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      async showLocations(locations) {
        let items = await Promise.all(locations.map((loc) => this.getQuickfixItem(loc)));
        let { nvim } = this;
        const preferences = this.getConfiguration("coc.preferences");
        if (preferences.get("useQuickfixForLocations", false)) {
          let openCommand = await nvim.getVar("coc_quickfix_open_command");
          if (typeof openCommand != "string") {
            openCommand = items.length < 10 ? `copen ${items.length}` : "copen";
          }
          nvim.pauseNotification();
          nvim.call("setqflist", [items], true);
          nvim.command(openCommand, true);
          nvim.resumeNotification(false, true);
        } else {
          await nvim.setVar("coc_jump_locations", items);
          if (this.env.locationlist) {
            nvim.command("CocList --normal --auto-preview location", true);
          } else {
            nvim.call("coc#util#do_autocmd", ["CocLocationsChange"], true);
          }
        }
      }
      async getLine(uri, line) {
        let document2 = this.getDocument(uri);
        if (document2)
          return document2.getline(line) || "";
        if (!uri.startsWith("file:"))
          return "";
        let fsPath = URI.parse(uri).fsPath;
        if (!import_fs_extra4.default.existsSync(fsPath))
          return "";
        return await readFileLine(fsPath, line);
      }
      getWorkspaceFolder(uri) {
        this.workspaceFolders.sort((a, b) => b.uri.length - a.uri.length);
        let filepath = URI.parse(uri).fsPath;
        return this.workspaceFolders.find((folder) => isParentFolder(URI.parse(folder.uri).fsPath, filepath, true));
      }
      async readFile(uri) {
        let document2 = this.getDocument(uri);
        if (document2) {
          await document2.patchChange();
          return document2.content;
        }
        let u = URI.parse(uri);
        if (u.scheme != "file")
          return "";
        let lines = await this.nvim.call("readfile", [u.fsPath]);
        return lines.join("\n") + "\n";
      }
      get document() {
        return new Promise((resolve3, reject) => {
          this.nvim.buffer.then((buf) => {
            let bufnr = buf.id;
            this.bufnr = bufnr;
            if (this.buffers.has(bufnr)) {
              resolve3(this.buffers.get(bufnr));
              return;
            }
            this.onBufCreate(bufnr).catch(reject);
            let disposable = this.onDidOpenTextDocument((doc) => {
              disposable.dispose();
              resolve3(this.getDocument(doc.uri));
            });
          }, reject);
        });
      }
      async getCurrentState() {
        let document2 = await this.document;
        let position = await window_default.getCursorPosition();
        return {
          document: document2.textDocument,
          position
        };
      }
      async getFormatOptions(uri) {
        let doc;
        if (uri)
          doc = this.getDocument(uri);
        let bufnr = doc ? doc.bufnr : 0;
        let [tabSize, insertSpaces] = await this.nvim.call("coc#util#get_format_opts", [bufnr]);
        return {
          tabSize,
          insertSpaces: insertSpaces == 1
        };
      }
      async jumpTo(uri, position, openCommand) {
        const preferences = this.getConfiguration("coc.preferences");
        let jumpCommand = openCommand || preferences.get("jumpCommand", "edit");
        let { nvim } = this;
        let doc = this.getDocument(uri);
        let bufnr = doc ? doc.bufnr : -1;
        if (bufnr != -1 && jumpCommand == "edit") {
          nvim.pauseNotification();
          nvim.command(`silent! normal! m'`, true);
          nvim.command(`buffer ${bufnr}`, true);
          if (position) {
            let line = doc.getline(position.line);
            let col = byteLength(line.slice(0, position.character)) + 1;
            nvim.call("cursor", [position.line + 1, col], true);
          }
          if (this.isVim)
            nvim.command("redraw", true);
          await nvim.resumeNotification();
        } else {
          let { fsPath, scheme } = URI.parse(uri);
          let pos = position == null ? null : [position.line, position.character];
          if (scheme == "file") {
            let bufname = fixDriver(import_path11.default.normalize(fsPath));
            await this.nvim.call("coc#util#jump", [jumpCommand, bufname, pos]);
          } else {
            if (import_os4.default.platform() == "win32") {
              uri = uri.replace(/\/?/, "?");
            }
            await this.nvim.call("coc#util#jump", [jumpCommand, uri, pos]);
          }
        }
      }
      async createFile(filepath, opts = {}) {
        let stat = await statAsync(filepath);
        if (stat && !opts.overwrite && !opts.ignoreIfExists) {
          window_default.showMessage(`${filepath} already exists!`, "error");
          return;
        }
        if (!stat || opts.overwrite) {
          if (filepath.endsWith("/")) {
            try {
              filepath = this.expand(filepath);
              await import_fs_extra4.default.mkdirp(filepath);
            } catch (e) {
              window_default.showMessage(`Can't create ${filepath}: ${e.message}`, "error");
            }
          } else {
            let uri = URI.file(filepath).toString();
            let doc = this.getDocument(uri);
            if (doc)
              return;
            if (!import_fs_extra4.default.existsSync(import_path11.default.dirname(filepath))) {
              import_fs_extra4.default.mkdirpSync(import_path11.default.dirname(filepath));
            }
            import_fs_extra4.default.writeFileSync(filepath, "", "utf8");
            await this.loadFile(uri);
          }
        }
      }
      async loadFile(uri) {
        let doc = this.getDocument(uri);
        if (doc)
          return doc;
        let { nvim } = this;
        let filepath = uri.startsWith("file") ? URI.parse(uri).fsPath : uri;
        nvim.call("coc#util#open_files", [[filepath]], true);
        return await new Promise((resolve3, reject) => {
          let disposable = this.onDidOpenTextDocument((textDocument) => {
            let fsPath = URI.parse(textDocument.uri).fsPath;
            if (textDocument.uri == uri || fsPath == filepath) {
              clearTimeout(timer);
              disposable.dispose();
              resolve3(this.getDocument(uri));
            }
          });
          let timer = setTimeout(() => {
            disposable.dispose();
            reject(new Error(`Create document ${uri} timeout after 1s.`));
          }, 1e3);
        });
      }
      async loadFiles(uris) {
        uris = uris.filter((uri) => this.getDocument(uri) == null);
        if (!uris.length)
          return;
        let bufnrs = await this.nvim.call("coc#util#open_files", [uris.map((u) => URI.parse(u).fsPath)]);
        let create = bufnrs.filter((bufnr) => this.getDocument(bufnr) == null);
        if (!create.length)
          return;
        return new Promise((resolve3, reject) => {
          let timer = setTimeout(() => {
            disposable.dispose();
            reject(new Error(`Create document timeout after 2s.`));
          }, 2e3);
          let disposable = this.onDidOpenTextDocument(() => {
            if (uris.every((uri) => this.getDocument(uri) != null)) {
              clearTimeout(timer);
              disposable.dispose();
              resolve3();
            }
          });
        });
      }
      async renameFile(oldPath, newPath, opts = {}) {
        let { overwrite, ignoreIfExists } = opts;
        let { nvim } = this;
        try {
          let stat = await statAsync(newPath);
          if (stat && !overwrite && !ignoreIfExists) {
            throw new Error(`${newPath} already exists`);
          }
          if (!stat || overwrite) {
            let uri = URI.file(oldPath).toString();
            let newUri = URI.file(newPath).toString();
            let doc = this.getDocument(uri);
            if (doc != null) {
              let isCurrent = doc.bufnr == this.bufnr;
              let newDoc = this.getDocument(newUri);
              if (newDoc)
                await this.nvim.command(`silent ${newDoc.bufnr}bwipeout!`);
              let content = doc.getDocumentContent();
              await import_fs_extra4.default.writeFile(newPath, content, "utf8");
              if (!isCurrent) {
                await nvim.call("coc#util#open_files", [[newPath]]);
                await nvim.command(`silent ${doc.bufnr}bwipeout!`);
              } else {
                let view = await nvim.call("winsaveview");
                nvim.pauseNotification();
                nvim.call("coc#util#open_file", ["keepalt edit", newPath], true);
                nvim.command(`silent ${doc.bufnr}bwipeout!`, true);
                nvim.call("winrestview", [view], true);
                await nvim.resumeNotification();
              }
              await import_fs_extra4.default.unlink(oldPath);
            } else {
              await renameAsync(oldPath, newPath);
            }
          }
        } catch (e) {
          window_default.showMessage(`Rename error: ${e.message}`, "error");
        }
      }
      async deleteFile(filepath, opts = {}) {
        let { ignoreIfNotExists, recursive } = opts;
        let stat = await statAsync(filepath.replace(/\/$/, ""));
        let isDir = stat && stat.isDirectory();
        if (filepath.endsWith("/") && !isDir) {
          window_default.showMessage(`${filepath} is not directory`, "error");
          return;
        }
        if (!stat && !ignoreIfNotExists) {
          window_default.showMessage(`${filepath} not exists`, "error");
          return;
        }
        if (stat == null)
          return;
        if (isDir && !recursive) {
          window_default.showMessage(`Can't remove directory, recursive not set`, "error");
          return;
        }
        try {
          if (isDir && recursive) {
            await import_fs_extra4.default.remove(filepath);
          } else if (isDir) {
            await import_fs_extra4.default.rmdir(filepath);
          } else {
            await import_fs_extra4.default.unlink(filepath);
          }
          if (!isDir) {
            let uri = URI.file(filepath).toString();
            let doc = this.getDocument(uri);
            if (doc)
              await this.nvim.command(`silent! bwipeout! ${doc.bufnr}`);
          }
        } catch (e) {
          window_default.showMessage(`Error on delete ${filepath}: ${e.message}`, "error");
        }
      }
      async openResource(uri) {
        let { nvim } = this;
        if (uri.startsWith("http")) {
          await nvim.call("coc#util#open_url", uri);
          return;
        }
        let wildignore = await nvim.getOption("wildignore");
        await nvim.setOption("wildignore", "");
        await this.jumpTo(uri);
        await nvim.setOption("wildignore", wildignore);
      }
      async resolveModule(name2) {
        return await this.resolver.resolveModule(name2);
      }
      async runCommand(cmd, cwd, timeout) {
        cwd = cwd || this.cwd;
        return runCommand(cmd, { cwd }, timeout);
      }
      expand(filepath) {
        if (!filepath)
          return filepath;
        if (filepath.startsWith("~")) {
          filepath = import_os4.default.homedir() + filepath.slice(1);
        }
        if (filepath.includes("$")) {
          let doc = this.getDocument(this.bufnr);
          let fsPath = doc ? URI.parse(doc.uri).fsPath : "";
          filepath = filepath.replace(/\$\{(.*?)\}/g, (match, name2) => {
            if (name2.startsWith("env:")) {
              let key = name2.split(":")[1];
              let val = key ? process.env[key] : "";
              return val;
            }
            switch (name2) {
              case "workspace":
              case "workspaceRoot":
              case "workspaceFolder":
                return this.root;
              case "workspaceFolderBasename":
                return import_path11.default.dirname(this.root);
              case "cwd":
                return this.cwd;
              case "file":
                return fsPath;
              case "fileDirname":
                return fsPath ? import_path11.default.dirname(fsPath) : "";
              case "fileExtname":
                return fsPath ? import_path11.default.extname(fsPath) : "";
              case "fileBasename":
                return fsPath ? import_path11.default.basename(fsPath) : "";
              case "fileBasenameNoExtension": {
                let basename = fsPath ? import_path11.default.basename(fsPath) : "";
                return basename ? basename.slice(0, basename.length - import_path11.default.extname(basename).length) : "";
              }
              default:
                return match;
            }
          });
          filepath = filepath.replace(/\$[\w]+/g, (match) => {
            if (match == "$HOME")
              return import_os4.default.homedir();
            return process.env[match.slice(1)] || match;
          });
        }
        return filepath;
      }
      async createTerminal(opts) {
        let cmd = opts.shellPath;
        let args = opts.shellArgs;
        if (!cmd)
          cmd = await this.nvim.getOption("shell");
        let terminal = new TerminalModel(cmd, args || [], this.nvim, opts.name);
        await terminal.start(opts.cwd || this.cwd, opts.env);
        this.terminals.set(terminal.bufnr, terminal);
        this._onDidOpenTerminal.fire(terminal);
        return terminal;
      }
      async callAsync(method, args) {
        if (this.isNvim)
          return await this.nvim.call(method, args);
        return await this.nvim.callAsync("coc#util#with_callback", [method, args]);
      }
      registerTextDocumentContentProvider(scheme, provider) {
        this.schemeProviderMap.set(scheme, provider);
        this.setupDynamicAutocmd();
        let disposables = [];
        if (provider.onDidChange) {
          provider.onDidChange(async (uri) => {
            let doc = this.getDocument(uri.toString());
            if (doc) {
              let { buffer } = doc;
              let tokenSource = new import_vscode_languageserver_protocol13.CancellationTokenSource();
              let content = await Promise.resolve(provider.provideTextDocumentContent(uri, tokenSource.token));
              await buffer.setLines(content.split(/\r?\n/), {
                start: 0,
                end: -1,
                strictIndexing: false
              });
            }
          }, null, disposables);
        }
        return import_vscode_languageserver_protocol13.Disposable.create(() => {
          this.schemeProviderMap.delete(scheme);
          disposeAll(disposables);
          this.setupDynamicAutocmd();
        });
      }
      registerKeymap(modes, key, fn, opts = {}) {
        if (!key)
          throw new Error(`Invalid key ${key} of registerKeymap`);
        if (this.keymaps.has(key))
          throw new Error(`${key} already exists.`);
        opts = Object.assign({ sync: true, cancel: true, silent: true, repeat: false }, opts);
        let { nvim } = this;
        this.keymaps.set(key, [fn, !!opts.repeat]);
        let method = opts.sync ? "request" : "notify";
        let silent = opts.silent ? "<silent>" : "";
        for (let m of modes) {
          if (m == "i") {
            nvim.command(`inoremap ${silent}<expr> <Plug>(coc-${key}) coc#_insert_key('${method}', '${key}', ${opts.cancel ? 1 : 0})`, true);
          } else {
            let modify2 = getKeymapModifier(m);
            nvim.command(`${m}noremap ${silent} <Plug>(coc-${key}) :${modify2}call coc#rpc#${method}('doKeymap', ['${key}'])<cr>`, true);
          }
        }
        return import_vscode_languageserver_protocol13.Disposable.create(() => {
          this.keymaps.delete(key);
          for (let m of modes) {
            nvim.command(`${m}unmap <Plug>(coc-${key})`, true);
          }
        });
      }
      registerExprKeymap(mode, key, fn, buffer = false) {
        if (!key)
          return;
        let id = `${mode}${global.Buffer.from(key).toString("base64")}${buffer ? "1" : "0"}`;
        let { nvim } = this;
        this.keymaps.set(id, [fn, false]);
        if (mode == "i") {
          nvim.command(`inoremap <silent><expr>${buffer ? "<nowait><buffer>" : ""} ${key} coc#_insert_key('request', '${id}')`, true);
        } else {
          nvim.command(`${mode}noremap <silent><expr>${buffer ? "<nowait><buffer>" : ""} ${key} coc#rpc#request('doKeymap', ['${id}'])`, true);
        }
        return import_vscode_languageserver_protocol13.Disposable.create(() => {
          this.keymaps.delete(id);
          nvim.command(`${mode}unmap ${buffer ? "<buffer>" : ""} ${key}`, true);
        });
      }
      registerLocalKeymap(mode, key, fn, notify = false) {
        let id = v1_default();
        let { nvim, bufnr } = this;
        this.keymaps.set(id, [fn, false]);
        let method = notify ? "notify" : "request";
        let modify2 = getKeymapModifier(mode);
        let escaped = key.startsWith("<") && key.endsWith(">") ? `{${key.slice(1, -1)}}` : key;
        if (this.isNvim && !global.hasOwnProperty("__TEST__")) {
          nvim.call("nvim_buf_set_keymap", [0, mode, key, `:${modify2}call coc#rpc#${method}('doKeymap', ['${id}', '', '${escaped}'])<CR>`, {
            silent: true,
            nowait: true
          }], true);
        } else {
          let cmd = `${mode}noremap <silent><nowait><buffer> ${key} :${modify2}call coc#rpc#${method}('doKeymap', ['${id}', '', '${escaped}'])<CR>`;
          nvim.command(cmd, true);
        }
        return import_vscode_languageserver_protocol13.Disposable.create(() => {
          this.keymaps.delete(id);
          nvim.call("coc#compat#buf_del_keymap", [bufnr, mode, key], true);
        });
      }
      createDatabase(name2) {
        let root;
        if (global.hasOwnProperty("__TEST__")) {
          root = import_path11.default.join(import_os4.default.tmpdir(), `coc-${process.pid}`);
          import_fs_extra4.default.mkdirpSync(root);
        } else {
          root = import_path11.default.dirname(this.env.extensionRoot);
        }
        let filepath = import_path11.default.join(root, name2 + ".json");
        return new DB(filepath);
      }
      createTask(id) {
        return new Task(this.nvim, id);
      }
      registerBufferSync(create) {
        return new BufferSync(create, this);
      }
      setupDynamicAutocmd(initialize = false) {
        if (!initialize && !this._dynAutocmd)
          return;
        this._dynAutocmd = true;
        let schemes = this.schemeProviderMap.keys();
        let cmds = [];
        for (let scheme of schemes) {
          cmds.push(`autocmd BufReadCmd,FileReadCmd,SourceCmd ${scheme}:/* call coc#rpc#request('CocAutocmd', ['BufReadCmd','${scheme}', expand('<amatch>')])`);
        }
        for (let [id, autocmd] of this.autocmds.entries()) {
          let args = autocmd.arglist && autocmd.arglist.length ? ", " + autocmd.arglist.join(", ") : "";
          let event = Array.isArray(autocmd.event) ? autocmd.event.join(",") : autocmd.event;
          let pattern = autocmd.pattern != null ? autocmd.pattern : "*";
          if (/\buser\b/i.test(event)) {
            pattern = "";
          }
          cmds.push(`autocmd ${event} ${pattern} call coc#rpc#${autocmd.request ? "request" : "notify"}('doAutocmd', [${id}${args}])`);
        }
        for (let key of this.watchedOptions) {
          cmds.push(`autocmd OptionSet ${key} call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])`);
        }
        let content = `
augroup coc_dynamic_autocmd
  autocmd!
  ${cmds.join("\n  ")}
augroup end`;
        try {
          let dir = import_path11.default.join(process.env.TMPDIR || import_os4.default.tmpdir(), `coc.nvim-${process.pid}`);
          if (!import_fs_extra4.default.existsSync(dir))
            import_fs_extra4.default.mkdirpSync(dir);
          let filepath = import_path11.default.join(dir, `coc-${process.pid}.vim`);
          import_fs_extra4.default.writeFileSync(filepath, content, "utf8");
          let cmd = `source ${filepath}`;
          if (this.env.isCygwin && platform_exports.isWindows) {
            cmd = `execute "source" . substitute(system('cygpath ${filepath.replace(/\\/g, "/")}'), '\\n', '', 'g')`;
          }
          this.nvim.command(cmd).logError();
        } catch (e) {
          window_default.showMessage(`Can't create tmp file: ${e.message}`, "error");
        }
      }
      async onBufReadCmd(scheme, uri) {
        let provider = this.schemeProviderMap.get(scheme);
        if (!provider) {
          window_default.showMessage(`Provider for ${scheme} not found`, "error");
          return;
        }
        let tokenSource = new import_vscode_languageserver_protocol13.CancellationTokenSource();
        let content = await Promise.resolve(provider.provideTextDocumentContent(URI.parse(uri), tokenSource.token));
        let buf = await this.nvim.buffer;
        await buf.setLines(content.split(/\r?\n/), {
          start: 0,
          end: -1,
          strictIndexing: false
        });
        setTimeout(async () => {
          await events_default.fire("BufCreate", [buf.id]);
        }, 30);
      }
      async attach() {
        if (this._attached)
          return;
        this._attached = true;
        let [bufs, bufnr, winid] = await this.nvim.eval(`[map(getbufinfo({'bufloaded': 1}),'v:val["bufnr"]'),bufnr('%'),win_getid()]`);
        this.bufnr = bufnr;
        await Promise.all(bufs.map((buf) => this.onBufCreate(buf)));
        if (!this._initialized) {
          this._onDidWorkspaceInitialized.fire(void 0);
          this._initialized = true;
        }
        await events_default.fire("BufEnter", [bufnr]);
        await events_default.fire("BufWinEnter", [bufnr, winid]);
      }
      getChangedUris(documentChanges) {
        let uris = new Set();
        let createUris = new Set();
        for (let change of documentChanges) {
          if (import_vscode_languageserver_protocol13.TextDocumentEdit.is(change)) {
            let { textDocument } = change;
            let { uri, version: version2 } = textDocument;
            uris.add(uri);
            if (version2 != null && version2 > 0) {
              let doc = this.getDocument(uri);
              if (!doc) {
                throw new Error(`${uri} not loaded`);
              }
              if (doc.version != version2) {
                throw new Error(`${uri} changed before apply edit`);
              }
            }
          } else if (import_vscode_languageserver_protocol13.CreateFile.is(change) || import_vscode_languageserver_protocol13.DeleteFile.is(change)) {
            if (!isFile(change.uri)) {
              throw new Error(`change of scheme ${change.uri} not supported`);
            }
            createUris.add(change.uri);
            uris.add(change.uri);
          } else if (import_vscode_languageserver_protocol13.RenameFile.is(change)) {
            if (!isFile(change.oldUri) || !isFile(change.newUri)) {
              throw new Error(`change of scheme ${change.oldUri} not supported`);
            }
            let newFile = URI.parse(change.newUri).fsPath;
            if (import_fs_extra4.default.existsSync(newFile)) {
              throw new Error(`file "${newFile}" already exists for rename`);
            }
            uris.add(change.oldUri);
          } else {
            throw new Error(`Invalid document change: ${JSON.stringify(change, null, 2)}`);
          }
        }
        return Array.from(uris);
      }
      createConfigurations() {
        let home = import_path11.default.normalize(process.env.COC_VIMCONFIG) || import_path11.default.join(import_os4.default.homedir(), ".vim");
        let userConfigFile = import_path11.default.join(home, CONFIG_FILE_NAME);
        return new Configurations(userConfigFile, new ConfigurationProxy(this));
      }
      attachChangedEvents() {
        if (this.isVim) {
          const onChange = (bufnr) => {
            let doc = this.getDocument(bufnr);
            if (doc && doc.attached)
              doc.fetchContent();
          };
          events_default.on("TextChangedP", onChange, null, this.disposables);
          events_default.on("TextChangedI", onChange, null, this.disposables);
          events_default.on("TextChanged", onChange, null, this.disposables);
        }
      }
      async onBufCreate(buf) {
        let buffer = typeof buf === "number" ? this.nvim.createBuffer(buf) : buf;
        let bufnr = buffer.id;
        if (this.creatingSources.has(bufnr))
          return;
        let document2 = this.getDocument(bufnr);
        let source = new import_vscode_languageserver_protocol13.CancellationTokenSource();
        try {
          if (document2)
            this.onBufUnload(bufnr, true);
          document2 = new Document(buffer, this._env, this.maxFileSize);
          let token = source.token;
          this.creatingSources.set(bufnr, source);
          let created = await document2.init(this.nvim, token);
          if (!created)
            document2 = null;
        } catch (e) {
          logger25.error("Error on create buffer:", e);
          document2 = null;
        }
        if (this.creatingSources.get(bufnr) == source) {
          source.dispose();
          this.creatingSources.delete(bufnr);
        }
        if (!document2 || !document2.textDocument)
          return;
        this.buffers.set(bufnr, document2);
        if (document2.attached) {
          document2.onDocumentDetach((bufnr2) => {
            let doc = this.getDocument(bufnr2);
            if (doc)
              this.onBufUnload(doc.bufnr);
          });
        }
        if (document2.buftype == "" && document2.schema == "file") {
          this.configurations.checkFolderConfiguration(document2.uri);
          let config = this.getConfiguration("workspace");
          let filetypes = config.get("ignoredFiletypes", []);
          if (!filetypes.includes(document2.filetype)) {
            let root = this.resolveRoot(document2);
            if (root) {
              this.addWorkspaceFolder(root);
              if (this.bufnr == buffer.id) {
                this._root = root;
              }
            }
          }
        }
        if (document2.enabled) {
          let textDocument = Object.assign(document2.textDocument, { bufnr });
          this._onDidOpenDocument.fire(textDocument);
          document2.onDocumentChange((e) => this._onDidChangeDocument.fire(e));
        }
        logger25.debug("buffer created", buffer.id);
      }
      onBufEnter(bufnr) {
        this.bufnr = bufnr;
        let doc = this.getDocument(bufnr);
        if (doc) {
          this.configurations.setFolderConfiguration(doc.uri);
          let workspaceFolder = this.getWorkspaceFolder(doc.uri);
          if (workspaceFolder)
            this._root = URI.parse(workspaceFolder.uri).fsPath;
        }
      }
      async checkCurrentBuffer(bufnr) {
        this.bufnr = bufnr;
        await this.checkBuffer(bufnr);
      }
      onBufWritePost(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (!doc)
          return;
        this._onDidSaveDocument.fire(doc.textDocument);
      }
      onBufUnload(bufnr, recreate = false) {
        logger25.debug("buffer unload", bufnr);
        if (!recreate) {
          let source = this.creatingSources.get(bufnr);
          if (source) {
            source.cancel();
            this.creatingSources.delete(bufnr);
          }
        }
        if (this.terminals.has(bufnr)) {
          let terminal = this.terminals.get(bufnr);
          this._onDidCloseTerminal.fire(terminal);
          this.terminals.delete(bufnr);
        }
        let doc = this.buffers.get(bufnr);
        if (doc) {
          let textDocument = Object.assign(doc.textDocument, { bufnr });
          this._onDidCloseDocument.fire(textDocument);
          this.buffers.delete(bufnr);
          doc.detach();
        }
      }
      async onBufWritePre(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (!doc || !doc.attached)
          return;
        await doc.synchronize();
        let firing = true;
        let thenables = [];
        let event = {
          document: doc.textDocument,
          reason: import_vscode_languageserver_protocol13.TextDocumentSaveReason.Manual,
          waitUntil: (thenable) => {
            if (!firing) {
              logger25.error(`Can't call waitUntil in async manner:`, Error().stack);
              window_default.showMessage(`waitUntil can't be used in async manner, check log for details`, "error");
            } else {
              thenables.push(thenable);
            }
          }
        };
        this._onWillSaveDocument.fire(event);
        firing = false;
        let total = thenables.length;
        if (total) {
          let promise = new Promise((resolve3) => {
            const preferences = this.getConfiguration("coc.preferences");
            const willSaveHandlerTimeout = preferences.get("willSaveHandlerTimeout", 500);
            let timer = setTimeout(() => {
              window_default.showMessage(`Will save handler timeout after ${willSaveHandlerTimeout}ms`, "warning");
              resolve3(void 0);
            }, willSaveHandlerTimeout);
            let i = 0;
            let called = false;
            for (let p of thenables) {
              let cb = (res) => {
                if (called)
                  return;
                called = true;
                clearTimeout(timer);
                resolve3(res);
              };
              p.then((res) => {
                if (Array.isArray(res) && res.length && import_vscode_languageserver_protocol13.TextEdit.is(res[0])) {
                  return cb(res);
                }
                i = i + 1;
                if (i == total)
                  cb(void 0);
              }, () => {
                i = i + 1;
                if (i == total)
                  cb(void 0);
              });
            }
          });
          let edits = await promise;
          if (edits)
            await doc.applyEdits(edits);
        }
      }
      onDirChanged(cwd) {
        if (cwd == this._cwd)
          return;
        this._cwd = cwd;
      }
      onFileTypeChange(filetype, bufnr) {
        let doc = this.getDocument(bufnr);
        if (!doc)
          return;
        let converted = doc.convertFiletype(filetype);
        if (converted == doc.filetype)
          return;
        let textDocument = Object.assign(doc.textDocument, { bufnr });
        this._onDidCloseDocument.fire(textDocument);
        doc.setFiletype(filetype);
        this._onDidOpenDocument.fire(Object.assign(doc.textDocument, { bufnr }));
      }
      async checkBuffer(bufnr) {
        if (this._disposed || !bufnr)
          return;
        let doc = this.getDocument(bufnr);
        if (!doc && !this.creatingSources.has(bufnr))
          await this.onBufCreate(bufnr);
      }
      resolveRoot(document2) {
        let types = [PatternType.Buffer, PatternType.LanguageServer, PatternType.Global];
        let u = URI.parse(document2.uri);
        let dir = import_path11.default.dirname(u.fsPath);
        let { cwd } = this;
        let config = this.getConfiguration("workspace");
        let bottomUpFileTypes = config.get("bottomUpFiletypes", []);
        let checkCwd = config.get("workspaceFolderCheckCwd", true);
        for (let patternType of types) {
          let patterns = this.getRootPatterns(document2, patternType);
          if (patterns && patterns.length) {
            let isBottomUp = bottomUpFileTypes.includes(document2.filetype);
            let root = resolveRoot(dir, patterns, cwd, isBottomUp, checkCwd);
            if (root)
              return root;
          }
        }
        if (this.cwd != import_os4.default.homedir() && isParentFolder(this.cwd, dir, true))
          return this.cwd;
        return null;
      }
      getRootPatterns(document2, patternType) {
        let { uri } = document2;
        if (patternType == PatternType.Buffer)
          return document2.getVar("root_patterns", []) || [];
        if (patternType == PatternType.LanguageServer)
          return this.getServerRootPatterns(document2.filetype);
        const preferences = this.getConfiguration("coc.preferences", uri);
        return preferences.get("rootPatterns", [".git", ".hg", ".projections.json"]).slice();
      }
      async renameCurrent() {
        let { nvim } = this;
        let bufnr = await nvim.call("bufnr", "%");
        let cwd = await nvim.call("getcwd");
        let doc = this.getDocument(bufnr);
        if (!doc || doc.buftype != "" || doc.schema != "file") {
          nvim.errWriteLine("current buffer is not file.");
          return;
        }
        let oldPath = URI.parse(doc.uri).fsPath;
        let newPath = await nvim.callAsync("coc#util#with_callback", ["input", ["New path: ", oldPath, "file"]]);
        newPath = newPath ? newPath.trim() : null;
        if (newPath == oldPath || !newPath)
          return;
        let lines = await doc.buffer.lines;
        let exists = import_fs_extra4.default.existsSync(oldPath);
        if (exists) {
          let modified = await nvim.eval("&modified");
          if (modified)
            await nvim.command("noa w");
          if (oldPath.toLowerCase() != newPath.toLowerCase() && import_fs_extra4.default.existsSync(newPath)) {
            let overwrite = await window_default.showPrompt(`${newPath} exists, overwrite?`);
            if (!overwrite)
              return;
            import_fs_extra4.default.unlinkSync(newPath);
          }
          import_fs_extra4.default.renameSync(oldPath, newPath);
        }
        this._onWillRenameFiles.fire({
          files: [{ newUri: URI.parse(newPath), oldUri: URI.parse(oldPath) }],
          waitUntil: async (thenable) => {
            const edit2 = await Promise.resolve(thenable);
            if (edit2 && import_vscode_languageserver_protocol13.WorkspaceEdit.is(edit2)) {
              await this.applyEdit(edit2);
            }
          }
        });
        this._onDidRenameFiles.fire({
          files: [{ newUri: URI.parse(newPath), oldUri: URI.parse(oldPath) }]
        });
        let filepath = isParentFolder(cwd, newPath) ? import_path11.default.relative(cwd, newPath) : newPath;
        let view = await nvim.call("winsaveview");
        nvim.pauseNotification();
        if (oldPath.toLowerCase() == newPath.toLowerCase()) {
          nvim.command(`keepalt ${bufnr}bwipeout!`, true);
          nvim.call("coc#util#open_file", ["keepalt edit", filepath], true);
        } else {
          nvim.call("coc#util#open_file", ["keepalt edit", filepath], true);
          nvim.command(`${bufnr}bwipeout!`, true);
        }
        if (!exists && lines.join("\n") != "\n") {
          nvim.call("append", [0, lines], true);
          nvim.command("normal! Gdd", true);
        }
        nvim.call("winrestview", [view], true);
        await nvim.resumeNotification();
      }
      get folderPaths() {
        return this.workspaceFolders.map((f) => URI.parse(f.uri).fsPath);
      }
      get floatSupported() {
        let { env } = this;
        return env.floating || env.textprop;
      }
      removeWorkspaceFolder(fsPath) {
        let idx = this._workspaceFolders.findIndex((f) => URI.parse(f.uri).fsPath == fsPath);
        if (idx != -1) {
          let folder = this._workspaceFolders[idx];
          this._workspaceFolders.splice(idx, 1);
          this._onDidChangeWorkspaceFolders.fire({
            removed: [folder],
            added: []
          });
        }
      }
      renameWorkspaceFolder(oldPath, newPath) {
        let idx = this._workspaceFolders.findIndex((f) => URI.parse(f.uri).fsPath == oldPath);
        if (idx == -1)
          return;
        let removed = this._workspaceFolders[idx];
        let added = {
          uri: URI.file(newPath).toString(),
          name: import_path11.default.dirname(newPath)
        };
        this._workspaceFolders.splice(idx, 1);
        this._workspaceFolders.push(added);
        this._onDidChangeWorkspaceFolders.fire({
          removed: [removed],
          added: [added]
        });
      }
      addRootPattern(filetype, rootPatterns) {
        let patterns = this.rootPatterns.get(filetype) || [];
        for (let p of rootPatterns) {
          if (!patterns.includes(p)) {
            patterns.push(p);
          }
        }
        this.rootPatterns.set(filetype, patterns);
      }
      get insertMode() {
        return this._insertMode;
      }
      async detach() {
        if (!this._attached)
          return;
        this._attached = false;
        channels_default.dispose();
        for (let bufnr of this.buffers.keys()) {
          await events_default.fire("BufUnload", [bufnr]);
        }
      }
      dispose() {
        this._disposed = true;
        for (let doc of this.documents) {
          doc.detach();
        }
        disposeAll(this.disposables);
        Watchman.dispose();
        this.configurations.dispose();
        this.buffers.clear();
      }
      addWorkspaceFolder(rootPath) {
        if (rootPath == import_os4.default.homedir())
          return;
        let { _workspaceFolders } = this;
        let uri = URI.file(rootPath).toString();
        let workspaceFolder = { uri, name: import_path11.default.basename(rootPath) };
        if (_workspaceFolders.findIndex((o) => o.uri == uri) == -1) {
          _workspaceFolders.push(workspaceFolder);
          if (this._initialized) {
            this._onDidChangeWorkspaceFolders.fire({
              added: [workspaceFolder],
              removed: []
            });
          }
        }
        return workspaceFolder;
      }
      getServerRootPatterns(filetype) {
        let lspConfig = this.getConfiguration().get("languageserver", {});
        let patterns = [];
        for (let key of Object.keys(lspConfig)) {
          let config = lspConfig[key];
          let { filetypes, rootPatterns } = config;
          if (Array.isArray(filetypes) && rootPatterns && filetypes.includes(filetype)) {
            patterns.push(...rootPatterns);
          }
        }
        patterns = patterns.concat(this.rootPatterns.get(filetype) || []);
        return patterns.length ? distinct(patterns) : null;
      }
    };
    workspace_default = new Workspace();
  }
});

// src/util/fzy.ts
function islower(s) {
  return s.toLowerCase() === s;
}
function isupper(s) {
  return s.toUpperCase() === s;
}
function precompute_bonus(haystack) {
  let m = haystack.length;
  let match_bonus = new Array(m);
  let last_ch = "/";
  for (let i = 0; i < m; i++) {
    let ch = haystack[i];
    if (last_ch === "/") {
      match_bonus[i] = SCORE_MATCH_SLASH;
    } else if (last_ch === "-" || last_ch === "_" || last_ch === " ") {
      match_bonus[i] = SCORE_MATCH_WORD;
    } else if (last_ch === ".") {
      match_bonus[i] = SCORE_MATCH_DOT;
    } else if (islower(last_ch) && isupper(ch)) {
      match_bonus[i] = SCORE_MATCH_CAPITAL;
    } else {
      match_bonus[i] = 0;
    }
    last_ch = ch;
  }
  return match_bonus;
}
function compute(needle, haystack, D, M) {
  let n = needle.length;
  let m = haystack.length;
  let lower_needle = needle.toLowerCase();
  let lower_haystack = haystack.toLowerCase();
  let match_bonus = precompute_bonus(haystack);
  for (let i = 0; i < n; i++) {
    D[i] = new Array(m);
    M[i] = new Array(m);
    let prev_score = SCORE_MIN;
    let gap_score = i === n - 1 ? SCORE_GAP_TRAILING : SCORE_GAP_INNER;
    for (let j = 0; j < m; j++) {
      if (lower_needle[i] === lower_haystack[j]) {
        let score5 = SCORE_MIN;
        if (!i) {
          score5 = j * SCORE_GAP_LEADING + match_bonus[j];
        } else if (j) {
          score5 = Math.max(M[i - 1][j - 1] + match_bonus[j], D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE);
        }
        D[i][j] = score5;
        M[i][j] = prev_score = Math.max(score5, prev_score + gap_score);
      } else {
        D[i][j] = SCORE_MIN;
        M[i][j] = prev_score = prev_score + gap_score;
      }
    }
  }
}
function score2(needle, haystack) {
  let n = needle.length;
  let m = haystack.length;
  if (!n || !m)
    return SCORE_MIN;
  if (n === m) {
    return SCORE_MAX;
  }
  if (m > 1024) {
    return SCORE_MIN;
  }
  let D = new Array(n);
  let M = new Array(n);
  compute(needle, haystack, D, M);
  return M[n - 1][m - 1];
}
function groupPositions(arr) {
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    let last = res.length ? res[res.length - 1] : void 0;
    let curr = arr[i];
    if (last && curr == last[1]) {
      last[1] = curr + 1;
    } else {
      res.push([curr, curr + 1]);
    }
  }
  return res;
}
function positions(needle, haystack) {
  let n = needle.length;
  let m = haystack.length;
  let positions2 = new Array(n);
  if (!n || !m)
    return positions2;
  if (n === m) {
    for (let i = 0; i < n; i++)
      positions2[i] = i;
    return positions2;
  }
  if (m > 1024) {
    return positions2;
  }
  let D = new Array(n);
  let M = new Array(n);
  compute(needle, haystack, D, M);
  let match_required = false;
  for (let i = n - 1, j = m - 1; i >= 0; i--) {
    for (; j >= 0; j--) {
      if (D[i][j] !== SCORE_MIN && (match_required || D[i][j] === M[i][j])) {
        match_required = i && j && M[i][j] === D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE;
        positions2[i] = j--;
        break;
      }
    }
  }
  return positions2;
}
function hasMatch(needle, haystack) {
  needle = needle.toLowerCase();
  haystack = haystack.toLowerCase();
  let l = needle.length;
  for (let i = 0, j = 0; i < l; i += 1) {
    j = haystack.indexOf(needle[i], j) + 1;
    if (j === 0)
      return false;
  }
  return true;
}
var SCORE_MIN, SCORE_MAX, SCORE_GAP_LEADING, SCORE_GAP_TRAILING, SCORE_GAP_INNER, SCORE_MATCH_CONSECUTIVE, SCORE_MATCH_SLASH, SCORE_MATCH_WORD, SCORE_MATCH_CAPITAL, SCORE_MATCH_DOT;
var init_fzy = __esm({
  "src/util/fzy.ts"() {
    SCORE_MIN = -Infinity;
    SCORE_MAX = Infinity;
    SCORE_GAP_LEADING = -5e-3;
    SCORE_GAP_TRAILING = -5e-3;
    SCORE_GAP_INNER = -0.01;
    SCORE_MATCH_CONSECUTIVE = 1;
    SCORE_MATCH_SLASH = 0.9;
    SCORE_MATCH_WORD = 0.8;
    SCORE_MATCH_CAPITAL = 0.7;
    SCORE_MATCH_DOT = 0.6;
  }
});

// src/tree/filter.ts
var import_vscode_languageserver_protocol14, sessionKey, Filter;
var init_filter = __esm({
  "src/tree/filter.ts"() {
    init_events();
    import_vscode_languageserver_protocol14 = __toModule(require_main2());
    init_util();
    sessionKey = "filter";
    Filter = class {
      constructor(nvim, keys) {
        this.nvim = nvim;
        this._activated = false;
        this.history = [];
        this.disposables = [];
        this._onDidUpdate = new import_vscode_languageserver_protocol14.Emitter();
        this._onDidExit = new import_vscode_languageserver_protocol14.Emitter();
        this._onDidKeyPress = new import_vscode_languageserver_protocol14.Emitter();
        this.onDidKeyPress = this._onDidKeyPress.event;
        this.onDidUpdate = this._onDidUpdate.event;
        this.onDidExit = this._onDidExit.event;
        this.text = "";
        events_default.on("InputChar", (session, character) => {
          if (session !== sessionKey || !this._activated)
            return;
          if (!keys.includes(character)) {
            if (character.length == 1) {
              this.text = this.text + character;
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<bs>") {
              this.text = this.text.slice(0, -1);
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<C-u>") {
              this.text = "";
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<C-n>") {
              let idx = this.history.indexOf(this.text);
              let text = this.history[idx + 1] || this.history[0];
              if (text) {
                this.text = text;
                this._onDidUpdate.fire(this.text);
              }
              return;
            }
            if (character == "<C-p>") {
              let idx = this.history.indexOf(this.text);
              let text = this.history[idx - 1] || this.history[this.history.length - 1];
              if (text) {
                this.text = text;
                this._onDidUpdate.fire(this.text);
              }
            }
            if (character == "<esc>" || character == "<C-o>") {
              this.deactivate();
              return;
            }
          }
          this._onDidKeyPress.fire(character);
        }, null, this.disposables);
      }
      active() {
        if (this._activated)
          return;
        this._activated = true;
        this.text = "";
        this.nvim.call("coc#prompt#start_prompt", [sessionKey], true);
      }
      deactivate(node) {
        if (!this._activated)
          return;
        this.nvim.call("coc#prompt#stop_prompt", [sessionKey], true);
        this._activated = false;
        let { text } = this;
        this.text = "";
        this._onDidExit.fire(node);
        if (text && !this.history.includes(text)) {
          this.history.push(text);
        }
      }
      get activated() {
        return this._activated;
      }
      dispose() {
        this.deactivate();
        this.history = [];
        this._onDidKeyPress.dispose();
        this._onDidUpdate.dispose();
        this._onDidExit.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/tree/TreeItem.ts
var import_path12, TreeItemLabel, TreeItemCollapsibleState, TreeItem;
var init_TreeItem = __esm({
  "src/tree/TreeItem.ts"() {
    init_esm2();
    import_path12 = __toModule(require("path"));
    (function(TreeItemLabel3) {
      function is(obj) {
        return typeof obj.label == "string";
      }
      TreeItemLabel3.is = is;
    })(TreeItemLabel || (TreeItemLabel = {}));
    (function(TreeItemCollapsibleState2) {
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["None"] = 0] = "None";
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["Collapsed"] = 1] = "Collapsed";
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["Expanded"] = 2] = "Expanded";
    })(TreeItemCollapsibleState || (TreeItemCollapsibleState = {}));
    TreeItem = class {
      constructor(label, collapsibleState = 0) {
        this.collapsibleState = collapsibleState;
        if (URI.isUri(label)) {
          this.resourceUri = label;
          this.label = import_path12.default.basename(label.path);
          this.id = label.toString();
        } else {
          this.label = label;
        }
      }
    };
  }
});

// src/tree/TreeView.ts
var TreeView_exports = {};
__export(TreeView_exports, {
  default: () => BasicTreeView
});
var import_vscode_languageserver_protocol15, logger26, highlightNamespace, signOffset, globalId, BasicTreeView;
var init_TreeView = __esm({
  "src/tree/TreeView.ts"() {
    import_vscode_languageserver_protocol15 = __toModule(require_main2());
    init_commands2();
    init_events();
    init_floatFactory();
    init_util();
    init_mutex();
    init_object();
    init_string();
    init_fzy();
    init_workspace();
    init_window();
    init_filter();
    init_TreeItem();
    logger26 = require_logger2()("BasicTreeView");
    highlightNamespace = "tree";
    signOffset = 3e3;
    globalId = 1;
    BasicTreeView = class {
      constructor(viewId, opts) {
        this.viewId = viewId;
        this._selection = [];
        this._onDidExpandElement = new import_vscode_languageserver_protocol15.Emitter();
        this._onDidCollapseElement = new import_vscode_languageserver_protocol15.Emitter();
        this._onDidChangeSelection = new import_vscode_languageserver_protocol15.Emitter();
        this._onDidChangeVisibility = new import_vscode_languageserver_protocol15.Emitter();
        this.onDidExpandElement = this._onDidExpandElement.event;
        this.onDidCollapseElement = this._onDidCollapseElement.event;
        this.onDidChangeSelection = this._onDidChangeSelection.event;
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this.retryTimers = 0;
        this.renderedItems = [];
        this.nodesMap = new Map();
        this.mutex = new Mutex();
        this.disposables = [];
        this.lineState = { titleCount: 0, messageCount: 0 };
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        if (opts.enableFilter) {
          this.filter = new Filter(this.nvim, [this.keys.selectNext, this.keys.selectPrevious, this.keys.invoke]);
        }
        this.tooltipFactory = new FloatFactory(workspace_default.nvim);
        this.canSelectMany = !!opts.canSelectMany;
        this.provider = opts.treeDataProvider;
        this.leafIndent = opts.disableLeafIndent !== true;
        this.winfixwidth = opts.winfixwidth !== false;
        let message;
        Object.defineProperty(this, "message", {
          set: (msg) => {
            message = msg ? msg.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return message;
          }
        });
        let title = viewId.replace(/\r?\n/g, " ");
        Object.defineProperty(this, "title", {
          set: (newTitle) => {
            title = newTitle ? newTitle.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return title;
          }
        });
        let description;
        Object.defineProperty(this, "description", {
          set: (desc) => {
            description = desc ? desc.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return description;
          }
        });
        let filterText;
        Object.defineProperty(this, "filterText", {
          set: (text) => {
            let { titleCount, messageCount } = this.lineState;
            let start = titleCount + messageCount;
            if (text != null) {
              let highlights = [{
                lnum: start,
                colStart: byteLength(text),
                colEnd: byteLength(text) + 1,
                hlGroup: "Cursor"
              }];
              this.renderedItems = [];
              this.updateUI([text + " "], highlights, start, -1, true);
              void this.doFilter(text);
            } else if (filterText != null) {
              this.updateUI([], [], start, start + 1);
            }
            filterText = text;
          },
          get: () => {
            return filterText;
          }
        });
        if (this.provider.onDidChangeTreeData) {
          this.provider.onDidChangeTreeData(this.onDataChange, this, this.disposables);
        }
        events_default.on("BufUnload", (bufnr) => {
          if (bufnr != this.bufnr)
            return;
          this.winid = void 0;
          this.bufnr = void 0;
          this._onDidChangeVisibility.fire({ visible: false });
          this.dispose();
        }, null, this.disposables);
        events_default.on("CursorHold", async (bufnr) => {
          if (bufnr != this.bufnr)
            return;
          await this.onHover();
        }, null, this.disposables);
        events_default.on(["CursorMoved", "BufEnter"], () => {
          this.cancelResolve();
        }, null, this.disposables);
        events_default.on("WinEnter", (winid) => {
          var _a2;
          if (winid != this.windowId || !((_a2 = this.filter) == null ? void 0 : _a2.activated))
            return;
          let buf = this.nvim.createBuffer(this.bufnr);
          let line = this.startLnum - 1;
          let len = this.filterText ? this.filterText.length : 0;
          let range = import_vscode_languageserver_protocol15.Range.create(line, len, line, len + 1);
          buf.highlightRanges(highlightNamespace, "Cursor", [range]);
          this.nvim.call("coc#prompt#start_prompt", [sessionKey], true);
          this.redraw();
        }, null, this.disposables);
        events_default.on("WinLeave", (winid) => {
          var _a2;
          if (winid != this.windowId || !((_a2 = this.filter) == null ? void 0 : _a2.activated))
            return;
          let buf = this.nvim.createBuffer(this.bufnr);
          this.nvim.call("coc#prompt#stop_prompt", [sessionKey], true);
          buf.clearNamespace(highlightNamespace, this.startLnum - 1, this.startLnum);
        }, null, this.disposables);
        this.disposables.push(this._onDidChangeVisibility, this._onDidChangeSelection, this._onDidCollapseElement, this._onDidExpandElement);
        if (this.filter) {
          this.filter.onDidExit((node) => {
            this.nodesMap.clear();
            this.filterText = void 0;
            this.itemsToFilter = void 0;
            if (node && typeof this.provider.getParent === "function") {
              this.renderedItems = [];
              void this.reveal(node, { focus: true });
            } else {
              this.clearSelection();
              void this.render();
            }
          });
          this.filter.onDidUpdate((text) => {
            this.filterText = text;
          });
          this.filter.onDidKeyPress(async (character) => {
            var _a2, _b;
            let items = this.renderedItems;
            if (!(items == null ? void 0 : items.length))
              return;
            let curr = this.selection[0];
            if (character == "<up>" || character == this.keys.selectPrevious) {
              let idx = items.findIndex((o) => o.node == curr);
              let index = idx == -1 || idx == 0 ? items.length - 1 : idx - 1;
              let node = (_a2 = items[index]) == null ? void 0 : _a2.node;
              if (node)
                this.selectItem(node, true);
            }
            if (character == "<down>" || character == this.keys.selectNext) {
              let idx = items.findIndex((o) => o.node == curr);
              let index = idx == -1 || idx == items.length - 1 ? 0 : idx + 1;
              let node = (_b = items[index]) == null ? void 0 : _b.node;
              if (node)
                this.selectItem(node, true);
            }
            if (character == "<cr>" || character == this.keys.invoke) {
              if (!curr)
                return;
              await this.invokeCommand(curr);
              this.filter.deactivate(curr);
            }
          });
        }
      }
      get windowId() {
        return this.winid;
      }
      get startLnum() {
        let filterCount = this.filterText == null ? 0 : 1;
        return this.lineState.messageCount + this.lineState.titleCount + filterCount;
      }
      get nvim() {
        return workspace_default.nvim;
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("tree")) {
          let config = workspace_default.getConfiguration("tree");
          this.config = {
            openedIcon: config.get("openedIcon", " "),
            closedIcon: config.get("closedIcon", " ")
          };
          this.keys = {
            close: config.get("key.close"),
            invoke: config.get("key.invoke"),
            toggle: config.get("key.toggle"),
            actions: config.get("key.actions"),
            collapseAll: config.get("key.collapseAll"),
            toggleSelection: config.get("key.toggleSelection"),
            activeFilter: config.get("key.activeFilter"),
            selectNext: config.get("key.selectNext"),
            selectPrevious: config.get("key.selectPrevious")
          };
          if (e) {
            void this.render();
          }
        }
      }
      async doFilter(text) {
        let items = [];
        let index = 0;
        let release = await this.mutex.acquire();
        try {
          if (!this.itemsToFilter) {
            let itemsToFilter = [];
            const addNodes = async (nodes2) => {
              for (let n of nodes2) {
                itemsToFilter.push(n);
                let arr = await Promise.resolve(this.provider.getChildren(n));
                if (arr == null ? void 0 : arr.length)
                  await addNodes(arr);
              }
            };
            let nodes = await Promise.resolve(this.provider.getChildren());
            await addNodes(nodes);
            this.itemsToFilter = itemsToFilter;
          }
          for (let n of this.itemsToFilter) {
            let item = await this.getTreeItem(n);
            let label = TreeItemLabel.is(item.label) ? item.label.label : item.label;
            if (!text || hasMatch(text, label)) {
              let idxs = text ? positions(text, label) : [];
              item.collapsibleState = TreeItemCollapsibleState.None;
              item.label = { label, highlights: text ? groupPositions(idxs) : [] };
              let { line, highlights: highlights2 } = this.getRenderedLine(item, index, 0);
              items.push({
                level: 0,
                node: n,
                line,
                index,
                score: text ? score2(text, label) : 0,
                highlights: highlights2
              });
              index += 1;
            }
          }
          items.sort((a, b) => {
            if (a.score != b.score)
              return b.score - a.score;
            return a.index - b.index;
          });
          let lnum = this.startLnum;
          let highlights = [];
          let renderedItems = this.renderedItems = items.map((o, idx) => {
            highlights.push(...o.highlights.map((h) => {
              h.lnum = lnum + idx;
              return h;
            }));
            delete o.index;
            delete o.score;
            delete o.highlights;
            return o;
          });
          this.updateUI(renderedItems.map((o) => o.line), highlights, lnum, -1, true);
          if (renderedItems.length) {
            this.selectItem(renderedItems[0].node, true);
          } else {
            this.clearSelection();
          }
          this.redraw();
          release();
        } catch (e) {
          release();
          logger26.error(`Error on tree filter: ${e.message}`, e);
        }
      }
      async onHover() {
        let { nvim } = this;
        let lnum = await nvim.call("line", ["."]);
        let element = this.getElementByLnum(lnum - 1);
        if (!element)
          return;
        let obj = this.nodesMap.get(element);
        if (!obj)
          return;
        let item = obj.item;
        if (!obj.resolved) {
          item = await this.resolveItem(element, item);
          if (!item)
            return;
        }
        if (!item.tooltip || !this.bufnr)
          return;
        let isMarkdown2 = import_vscode_languageserver_protocol15.MarkupContent.is(item.tooltip) && item.tooltip.kind == import_vscode_languageserver_protocol15.MarkupKind.Markdown;
        let doc = {
          filetype: isMarkdown2 ? "markdown" : "txt",
          content: import_vscode_languageserver_protocol15.MarkupContent.is(item.tooltip) ? item.tooltip.value : item.tooltip
        };
        await this.tooltipFactory.show([doc], { modes: ["n"] });
      }
      async onClick(element) {
        let { nvim } = this;
        let [line, col] = await nvim.eval(`[getline('.'),col('.')]`);
        let pre = byteSlice(line, 0, col - 1);
        let character = line[pre.length];
        if (!character)
          return;
        let { openedIcon, closedIcon } = this.config;
        if (/^\s*$/.test(pre) && [openedIcon, closedIcon].includes(character)) {
          await this.toggleExpand(element);
        } else {
          await this.invokeCommand(element);
        }
      }
      async invokeCommand(element) {
        let obj = this.nodesMap.get(element);
        if (!obj)
          return;
        this.selectItem(element);
        let item = obj.item;
        if (!item.command) {
          item = await this.resolveItem(element, item);
          if (!item)
            return;
        }
        if (!item.command)
          throw new Error(`Failed to resolve command from TreeItem.`);
        await commands_default.execute(item.command);
      }
      async invokeActions(element) {
        this.selectItem(element);
        if (typeof this.provider.resolveActions !== "function") {
          await window_default.showWarningMessage("No actions");
          return;
        }
        let obj = this.nodesMap.get(element);
        let actions = await Promise.resolve(this.provider.resolveActions(obj.item, element));
        if (!actions || actions.length == 0) {
          await window_default.showWarningMessage("No actions available");
          return;
        }
        let keys = actions.map((o) => o.title);
        let res = await window_default.showMenuPicker(keys, "Choose action");
        if (res == -1)
          return;
        await Promise.resolve(actions[res].handler(element));
      }
      async onDataChange(node) {
        var _a2;
        if ((_a2 = this.filter) == null ? void 0 : _a2.activated) {
          this.itemsToFilter = void 0;
          await this.doFilter(this.filterText);
          return;
        }
        this.clearSelection();
        if (!node) {
          await this.render();
          return;
        }
        let release = await this.mutex.acquire();
        try {
          let items = this.renderedItems;
          let idx = items.findIndex((o) => o.node === node);
          if (idx != -1 && this.bufnr) {
            let obj = items[idx];
            let level = obj.level;
            let removeCount = 0;
            for (let i = idx; i < items.length; i++) {
              let o = items[i];
              if (i == idx || o && o.level > level) {
                removeCount += 1;
              }
            }
            let appendItems = [];
            let highlights = [];
            let start = idx + this.startLnum;
            await this.appendTreeNode(node, level, start, appendItems, highlights);
            items.splice(idx, removeCount, ...appendItems);
            this.updateUI(appendItems.map((o) => o.line), highlights, start, start + removeCount);
          }
          release();
        } catch (e) {
          let errMsg = `Error on tree refresh: ${e.message}`;
          logger26.error(errMsg, e);
          this.nvim.errWriteLine("[coc.nvim] " + errMsg);
          release();
        }
      }
      async resolveItem(element, item) {
        if (typeof this.provider.resolveTreeItem === "function") {
          let tokenSource = this.resolveTokenSource = new import_vscode_languageserver_protocol15.CancellationTokenSource();
          let token = tokenSource.token;
          item = await Promise.resolve(this.provider.resolveTreeItem(item, element, token));
          tokenSource.dispose();
          this.resolveTokenSource = void 0;
          if (token.isCancellationRequested)
            return void 0;
        }
        this.nodesMap.set(element, { item, resolved: true });
        return item;
      }
      get visible() {
        return this.winid != null;
      }
      get selection() {
        return this._selection.slice();
      }
      async checkLines() {
        if (!this.bufnr)
          return;
        let buf = this.nvim.createBuffer(this.bufnr);
        let curr = await buf.lines;
        let { titleCount, messageCount } = this.lineState;
        curr = curr.slice(titleCount + messageCount);
        let lines = this.renderedItems.map((o) => o.line);
        return equals(curr, lines);
      }
      async toggleExpand(element) {
        let o = this.nodesMap.get(element);
        if (!o)
          return;
        let treeItem = o.item;
        let lnum = this.getItemLnum(element);
        let nodeIdx = lnum - this.startLnum;
        let obj = this.renderedItems[nodeIdx];
        if (!obj || treeItem.collapsibleState == TreeItemCollapsibleState.None) {
          if (typeof this.provider.getParent === "function") {
            let node = await Promise.resolve(this.provider.getParent(element));
            if (node) {
              await this.toggleExpand(node);
              this.focusItem(node);
            }
          }
          return;
        }
        let removeCount = 0;
        if (treeItem.collapsibleState == TreeItemCollapsibleState.Expanded) {
          let level = obj.level;
          for (let i = nodeIdx + 1; i < this.renderedItems.length; i++) {
            let o2 = this.renderedItems[i];
            if (!o2 || o2.level <= level)
              break;
            removeCount += 1;
          }
          treeItem.collapsibleState = TreeItemCollapsibleState.Collapsed;
        } else if (treeItem.collapsibleState == TreeItemCollapsibleState.Collapsed) {
          treeItem.collapsibleState = TreeItemCollapsibleState.Expanded;
        }
        let newItems = [];
        let newHighlights = [];
        await this.appendTreeNode(obj.node, obj.level, lnum, newItems, newHighlights);
        this.renderedItems.splice(nodeIdx, removeCount + 1, ...newItems);
        this.updateUI(newItems.map((o2) => o2.line), newHighlights, lnum, lnum + removeCount + 1);
        this.refreshSigns();
        if (treeItem.collapsibleState == TreeItemCollapsibleState.Collapsed) {
          this._onDidCollapseElement.fire({ element });
        } else {
          this._onDidExpandElement.fire({ element });
        }
      }
      toggleSelection(element) {
        let idx = this._selection.findIndex((o) => o === element);
        if (idx !== -1) {
          this.unselectItem(idx);
        } else {
          this.selectItem(element);
        }
      }
      clearSelection() {
        if (!this.bufnr)
          return;
        this._selection = [];
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.unplaceSign({ group: "CocTree" });
        this._onDidChangeSelection.fire({ selection: [] });
      }
      selectItem(item, forceSingle, noRedraw) {
        let { nvim } = this;
        if (!this.bufnr || !workspace_default.env.sign)
          return;
        let row = this.getItemLnum(item);
        if (row == null)
          return;
        let buf = nvim.createBuffer(this.bufnr);
        let exists = this._selection.includes(item);
        if (!this.canSelectMany || forceSingle) {
          this._selection = [item];
        } else if (!exists) {
          this._selection.push(item);
        }
        nvim.pauseNotification();
        if (!this.canSelectMany || forceSingle) {
          buf.unplaceSign({ group: "CocTree" });
        }
        nvim.call("coc#compat#execute", [this.winid, `exe ${row + 1}`], true);
        buf.placeSign({ id: signOffset + row, lnum: row + 1, name: "CocTreeSelected", group: "CocTree" });
        if (!noRedraw)
          this.redraw();
        void nvim.resumeNotification(false, true);
        if (!exists)
          this._onDidChangeSelection.fire({ selection: this._selection });
      }
      unselectItem(idx) {
        let item = this._selection[idx];
        let row = this.getItemLnum(item);
        if (row == null || !this.bufnr || !workspace_default.env.sign)
          return;
        this._selection.splice(idx, 1);
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.unplaceSign({ group: "CocTree", id: signOffset + row });
        this._onDidChangeSelection.fire({ selection: this._selection });
      }
      focusItem(element) {
        if (!this.winid)
          return;
        let lnum = this.getItemLnum(element);
        if (lnum == null)
          return;
        this.nvim.call("coc#compat#execute", [this.winid, `exe ${lnum + 1}`], true);
      }
      getElementByLnum(lnum) {
        let item = this.renderedItems[lnum - this.startLnum];
        return item ? item.node : void 0;
      }
      getItemLnum(item) {
        let idx = this.renderedItems.findIndex((o) => o.node === item);
        if (idx == -1)
          return void 0;
        return this.startLnum + idx;
      }
      async getTreeItem(element) {
        let exists;
        let resolved = false;
        let obj = this.nodesMap.get(element);
        if (obj != null) {
          exists = obj.item;
          resolved = obj.resolved;
        }
        let item = await Promise.resolve(this.provider.getTreeItem(element));
        if (item.id && !exists) {
          for (let obj2 of this.nodesMap.values()) {
            if (obj2.item.id === item.id) {
              resolved = obj2.resolved;
              exists = obj2.item;
              break;
            }
          }
        }
        if (exists && exists.collapsibleState != TreeItemCollapsibleState.None && item.collapsibleState != TreeItemCollapsibleState.None) {
          item.collapsibleState = exists.collapsibleState;
        }
        this.nodesMap.set(element, { item, resolved });
        return item;
      }
      getRenderedLine(treeItem, lnum, level) {
        let { openedIcon, closedIcon } = this.config;
        const highlights = [];
        const { label, deprecated, description } = treeItem;
        let prefix = "  ".repeat(level);
        const addHighlight = (text, hlGroup) => {
          let colStart = byteLength(prefix);
          highlights.push({
            lnum,
            hlGroup,
            colStart,
            colEnd: colStart + byteLength(text)
          });
        };
        switch (treeItem.collapsibleState) {
          case TreeItemCollapsibleState.Expanded: {
            addHighlight(openedIcon, "CocTreeOpenClose");
            prefix += openedIcon + " ";
            break;
          }
          case TreeItemCollapsibleState.Collapsed: {
            addHighlight(closedIcon, "CocTreeOpenClose");
            prefix += closedIcon + " ";
            break;
          }
          default:
            prefix += this.leafIndent ? "  " : "";
        }
        if (treeItem.icon) {
          let { text, hlGroup } = treeItem.icon;
          addHighlight(text, hlGroup);
          prefix += text + " ";
        }
        if (TreeItemLabel.is(label) && Array.isArray(label.highlights)) {
          let colStart = byteLength(prefix);
          for (let o of label.highlights) {
            highlights.push({
              lnum,
              hlGroup: "Search",
              colStart: colStart + o[0],
              colEnd: colStart + o[1]
            });
          }
        }
        let labelText = typeof label === "string" ? label : label.label;
        if (deprecated) {
          addHighlight(labelText, "CocDeprecatedHighlight");
        }
        prefix += labelText;
        if (description && description.indexOf("\n") == -1) {
          prefix += " ";
          addHighlight(description, "CocTreeDescription");
          prefix += description;
        }
        return { line: prefix, highlights };
      }
      async appendTreeNode(element, level, lnum, items, highlights) {
        let takes = 1;
        let treeItem = await this.getTreeItem(element);
        let res = this.getRenderedLine(treeItem, lnum, level);
        highlights.push(...res.highlights);
        items.push({ level, line: res.line, node: element });
        if (treeItem.collapsibleState == TreeItemCollapsibleState.Expanded) {
          let l = level + 1;
          let children = await Promise.resolve(this.provider.getChildren(element)) || [];
          for (let el of children) {
            let n = await this.appendTreeNode(el, l, lnum + takes, items, highlights);
            takes = takes + n;
          }
        }
        return takes;
      }
      updateUI(lines, highlights, start = 0, end = -1, noRedraw = false) {
        if (!this.bufnr)
          return;
        let { nvim } = this;
        let buf = nvim.createBuffer(this.bufnr);
        nvim.pauseNotification();
        buf.setOption("modifiable", true, true);
        void buf.setLines(lines, { start, end, strictIndexing: false }, true);
        if (highlights.length) {
          let highlightEnd = end == -1 ? -1 : start + lines.length;
          nvim.call("coc#highlight#update_highlights", [this.bufnr, highlightNamespace, highlights, start, highlightEnd], true);
        }
        buf.setOption("modifiable", false, true);
        if (!noRedraw)
          this.redraw();
        void nvim.resumeNotification(false, true);
      }
      async reveal(element, options = {}) {
        var _a2;
        if ((_a2 = this.filter) == null ? void 0 : _a2.activated)
          return;
        let isShown = this.getItemLnum(element) != null;
        let { select, focus, expand } = options;
        let curr = element;
        if (typeof this.provider.getParent !== "function") {
          throw new Error("missing getParent function from provider for reveal.");
        }
        if (!isShown) {
          while (curr) {
            let parentNode = await Promise.resolve(this.provider.getParent(curr));
            if (parentNode) {
              let item = await this.getTreeItem(parentNode);
              item.collapsibleState = TreeItemCollapsibleState.Expanded;
              curr = parentNode;
            } else {
              break;
            }
          }
        }
        if (expand) {
          let item = await this.getTreeItem(element);
          if (item.collapsibleState == TreeItemCollapsibleState.None)
            return;
          item.collapsibleState = TreeItemCollapsibleState.Expanded;
          if (typeof expand === "number" && expand > 1) {
            let curr2 = Math.min(expand, 2);
            let nodes = await Promise.resolve(this.provider.getChildren(element));
            while ((nodes == null ? void 0 : nodes.length) > 0) {
              let arr = [];
              for (let n of nodes) {
                let item2 = await this.getTreeItem(n);
                if (item2.collapsibleState == TreeItemCollapsibleState.None)
                  continue;
                item2.collapsibleState = TreeItemCollapsibleState.Expanded;
                if (curr2 > 1) {
                  let res = await Promise.resolve(this.provider.getChildren(n));
                  arr.push(...res);
                }
              }
              nodes = arr;
              curr2 = curr2 - 1;
            }
          }
        }
        if (!isShown || expand) {
          await this.render();
        }
        if (select !== false)
          this.selectItem(element);
        if (focus)
          this.focusItem(element);
      }
      updateHeadLines(initialize = false) {
        let { titleCount, messageCount } = this.lineState;
        let end = initialize ? -1 : titleCount + messageCount;
        let lines = [];
        let highlights = [];
        try {
          if (this.message) {
            highlights.push({ hlGroup: "MoreMsg", colStart: 0, colEnd: byteLength(this.message), lnum: 0 });
            lines.push(this.message);
            lines.push("");
          }
          if (this.title) {
            highlights.push({ hlGroup: "CocTreeTitle", colStart: 0, colEnd: byteLength(this.title), lnum: lines.length });
            if (this.description) {
              let colStart = byteLength(this.title) + 1;
              highlights.push({ hlGroup: "Comment", colStart, colEnd: colStart + byteLength(this.description), lnum: lines.length });
            }
            lines.push(this.title + (this.description ? " " + this.description : ""));
          }
          this.lineState.messageCount = this.message ? 2 : 0;
          this.lineState.titleCount = this.title ? 1 : 0;
          this.updateUI(lines, highlights, 0, end);
          if (!initialize) {
            this.refreshSigns();
          }
        } catch (e) {
          this.nvim.errWriteLine("[coc.nvim] Error on update head lines:" + e.message);
          logger26.error("Error on update head lines:", e);
        }
      }
      refreshSigns() {
        let { selection, nvim, bufnr } = this;
        if (!selection.length || !bufnr || !workspace_default.env.sign)
          return;
        let buf = nvim.createBuffer(bufnr);
        nvim.pauseNotification();
        buf.unplaceSign({ group: "CocTree" });
        for (let n of selection) {
          let row = this.getItemLnum(n);
          if (row == null)
            continue;
          buf.placeSign({ id: signOffset + row, lnum: row + 1, name: "CocTreeSelected", group: "CocTree" });
        }
        void nvim.resumeNotification(false, true);
      }
      async render() {
        if (!this.bufnr)
          return;
        let release = await this.mutex.acquire();
        try {
          let lines = [];
          let highlights = [];
          let { startLnum } = this;
          let nodes = await Promise.resolve(this.provider.getChildren());
          let level = 0;
          let lnum = startLnum;
          let renderedItems = [];
          if (!(nodes == null ? void 0 : nodes.length)) {
            this.message = "No results";
          } else {
            for (let node of nodes) {
              let n = await this.appendTreeNode(node, level, lnum, renderedItems, highlights);
              lnum += n;
            }
          }
          lines.push(...renderedItems.map((o) => o.line));
          this.renderedItems = renderedItems;
          let delta = this.startLnum - startLnum;
          if (delta)
            highlights.forEach((o) => o.lnum = o.lnum + delta);
          this.updateUI(lines, highlights, this.startLnum, -1);
          this.retryTimers = 0;
          release();
        } catch (e) {
          this.renderedItems = [];
          this.nodesMap.clear();
          this.lineState = { titleCount: 0, messageCount: 1 };
          release();
          let errMsg = `${e.message}`.replace(/\r?\n/g, " ");
          this.updateUI([errMsg], [{ hlGroup: "WarningMsg", colStart: 0, colEnd: byteLength(errMsg), lnum: 0 }]);
          if (this.retryTimers == 5)
            return;
          this.timer = setTimeout(() => {
            this.retryTimers = this.retryTimers + 1;
            void this.render();
          }, 500);
        }
      }
      async show(splitCommand = "belowright 30vs") {
        if (this.bufnr || this._creating)
          return;
        this._creating = true;
        let { nvim } = this;
        this.originalWin = await nvim.call("win_getid");
        let winid = await nvim.call("coc#window#find", ["cocViewId", this.viewId]);
        let id = globalId;
        globalId = globalId + 1;
        nvim.pauseNotification();
        if (winid != -1) {
          nvim.call("win_gotoid", [winid], true);
          nvim.command(`silent edit +setl\\ buftype=nofile CocTree${id}`, true);
        } else {
          nvim.command(`silent keepalt ${splitCommand} +setl\\ buftype=nofile CocTree${id}`, true);
        }
        nvim.command("setl bufhidden=wipe nolist nonumber norelativenumber foldcolumn=0", true);
        nvim.command(`setl signcolumn=${this.canSelectMany ? "yes" : "no"}${this.winfixwidth ? " winfixwidth" : ""}`, true);
        nvim.command("setl nocursorline nobuflisted wrap undolevels=-1 filetype=coctree nomodifiable noswapfile", true);
        nvim.command(`let w:cocViewId = "${this.viewId.replace(/"/g, '\\"')}"`, true);
        nvim.call("bufnr", ["%"], true);
        nvim.call("win_getid", [], true);
        let res = await nvim.resumeNotification();
        if (res[1])
          throw new Error(`Error on buffer create:` + JSON.stringify(res[1]));
        this._onDidChangeVisibility.fire({ visible: true });
        this.registerKeymaps();
        let arr = res[0];
        this.bufnr = arr[arr.length - 2];
        this.winid = arr[arr.length - 1];
        this._creating = false;
        this.updateHeadLines(true);
        void this.render();
      }
      registerKeymaps() {
        let { toggleSelection, actions, close, invoke, toggle, collapseAll, activeFilter } = this.keys;
        let { nvim } = this;
        const regist4 = (mode, key, fn, notify = false) => {
          this.disposables.push(workspace_default.registerLocalKeymap(mode, key, async () => {
            let lnum = await nvim.call("line", ["."]);
            let element = this.getElementByLnum(lnum - 1);
            if (element && !this.nodesMap.has(element))
              return;
            await Promise.resolve(fn(element));
          }, notify));
        };
        this.disposables.push(workspace_default.registerLocalKeymap("n", "<C-o>", () => {
          nvim.call("win_gotoid", [this.originalWin], true);
        }, true));
        regist4("n", "<LeftRelease>", async (element) => {
          if (element)
            await this.onClick(element);
        });
        this.filter && activeFilter && regist4("n", activeFilter, async () => {
          this.nvim.command(`exe ${this.startLnum}`, true);
          this.filter.active();
          this.filterText = "";
        }, true);
        toggleSelection && regist4("n", toggleSelection, async (element) => {
          if (element)
            this.toggleSelection(element);
        });
        invoke && regist4("n", invoke, async (element) => {
          if (element)
            await this.invokeCommand(element);
        }, true);
        actions && regist4("n", actions, async (element) => {
          if (element)
            await this.invokeActions(element);
        }, true);
        toggle && regist4("n", toggle, async (element) => {
          if (element)
            await this.toggleExpand(element);
        }, true);
        collapseAll && regist4("n", collapseAll, async () => {
          for (let obj of this.nodesMap.values()) {
            let item = obj.item;
            if (item.collapsibleState == TreeItemCollapsibleState.Expanded) {
              item.collapsibleState = TreeItemCollapsibleState.Collapsed;
            }
          }
          await this.render();
        });
        close && regist4("n", close, async () => {
          this.hide();
        }, true);
      }
      hide() {
        if (!this.bufnr)
          return;
        this.nvim.command(`bd! ${this.bufnr}`, true);
        this.redraw();
        this._onDidChangeVisibility.fire({ visible: false });
        this.bufnr = void 0;
        this.winid = void 0;
      }
      redraw() {
        var _a2;
        if (workspace_default.isVim || ((_a2 = this.filter) == null ? void 0 : _a2.activated)) {
          this.nvim.command("redraw", true);
        }
      }
      cancelResolve() {
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
          this.resolveTokenSource = void 0;
        }
      }
      dispose() {
        var _a2;
        if (!this.provider)
          return;
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = void 0;
        }
        (_a2 = this.filter) == null ? void 0 : _a2.dispose();
        this._selection = [];
        this.hide();
        this.itemsToFilter = [];
        this.cancelResolve();
        this.tooltipFactory.dispose();
        this.renderedItems = [];
        this.nodesMap.clear();
        this.provider = void 0;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/window.ts
var import_fs10, import_os5, import_path13, import_vscode_languageserver_protocol16, logger27, Window, window_default;
var init_window = __esm({
  "src/window.ts"() {
    import_fs10 = __toModule(require("fs"));
    import_os5 = __toModule(require("os"));
    import_path13 = __toModule(require("path"));
    import_vscode_languageserver_protocol16 = __toModule(require_main2());
    init_esm2();
    init_channels();
    init_events();
    init_dialog();
    init_menu();
    init_notification();
    init_picker();
    init_progress();
    init_status();
    init_types();
    init_util();
    init_mutex();
    init_platform();
    init_workspace();
    logger27 = require_logger2()("window");
    Window = class {
      constructor() {
        this.mutex = new Mutex();
      }
      get nvim() {
        return workspace_default.nvim;
      }
      dispose() {
        var _a2;
        (_a2 = this.statusLine) == null ? void 0 : _a2.dispose();
      }
      showMessage(msg, messageType = "more") {
        if (this.mutex.busy || !this.nvim)
          return;
        let { messageLevel } = this;
        let method = process.env.VIM_NODE_RPC == "1" ? "callTimer" : "call";
        if (global.hasOwnProperty("__TEST__"))
          logger27.info(msg);
        let hl = "Error";
        let level = MessageLevel.Error;
        switch (messageType) {
          case "more":
            level = MessageLevel.More;
            hl = "MoreMsg";
            break;
          case "warning":
            level = MessageLevel.Warning;
            hl = "WarningMsg";
            break;
        }
        if (level >= messageLevel) {
          this.nvim[method]("coc#util#echo_messages", [hl, ("[coc.nvim] " + msg).split("\n")], true);
        }
      }
      async runTerminalCommand(cmd, cwd, keepfocus = false) {
        cwd = cwd || workspace_default.cwd;
        return await this.nvim.callAsync("coc#util#run_terminal", { cmd, cwd, keepfocus: keepfocus ? 1 : 0 });
      }
      async openTerminal(cmd, opts = {}) {
        let bufnr = await this.nvim.call("coc#util#open_terminal", __spreadValues({ cmd }, opts));
        return bufnr;
      }
      async showQuickpick(items, placeholder = "Choose by number") {
        let release = await this.mutex.acquire();
        try {
          let title = placeholder + ":";
          items = items.map((s, idx) => `${idx + 1}. ${s}`);
          let res = await this.nvim.callAsync("coc#util#quickpick", [title, items.map((s) => s.trim())]);
          release();
          let n = parseInt(res, 10);
          if (isNaN(n) || n <= 0 || n > items.length)
            return -1;
          return n - 1;
        } catch (e) {
          release();
          return -1;
        }
      }
      async showMenuPicker(items, title, token) {
        if (workspace_default.env.dialog) {
          let release = await this.mutex.acquire();
          if (token && token.isCancellationRequested) {
            release();
            return -1;
          }
          try {
            let menu = new Menu(this.nvim, { items: items.map((s) => s.trim()), title }, token);
            let promise = new Promise((resolve3) => {
              menu.onDidClose((selected) => {
                resolve3(selected);
              });
            });
            await menu.show(this.dialogPreference);
            let res = await promise;
            release();
            return res;
          } catch (e) {
            logger27.error(`Error on showMenuPicker:`, e);
            release();
          }
        }
        return await this.showQuickpick(items);
      }
      async openLocalConfig() {
        let { root } = workspace_default;
        if (root == import_os5.default.homedir()) {
          this.showMessage(`Can't create local config in home directory`, "warning");
          return;
        }
        let dir = import_path13.default.join(root, ".vim");
        if (!import_fs10.default.existsSync(dir)) {
          let res = await this.showPrompt(`Would you like to create folder'${root}/.vim'?`);
          if (!res)
            return;
          import_fs10.default.mkdirSync(dir);
        }
        await workspace_default.jumpTo(URI.file(import_path13.default.join(dir, CONFIG_FILE_NAME)).toString());
      }
      async showPrompt(title) {
        let release = await this.mutex.acquire();
        try {
          let res = await this.nvim.callAsync("coc#float#prompt_confirm", [title]);
          release();
          return res == 1;
        } catch (e) {
          release();
          return false;
        }
      }
      async showDialog(config) {
        if (!this.checkDialog())
          return null;
        let dialog = new Dialog(this.nvim, config);
        await dialog.show(this.dialogPreference);
        return dialog;
      }
      async requestInput(title, defaultValue) {
        let { nvim } = this;
        const preferences = workspace_default.getConfiguration("coc.preferences");
        if (workspace_default.env.dialog && preferences.get("promptInput", true) && !isWindows2) {
          let release = await this.mutex.acquire();
          let preferences2 = this.dialogPreference;
          try {
            let opts = {};
            if (preferences2.floatHighlight)
              opts.highlight = preferences2.floatHighlight;
            if (preferences2.floatBorderHighlight)
              opts.borderhighlight = preferences2.floatBorderHighlight;
            let arr = await nvim.call("coc#float#create_prompt_win", [title, defaultValue || "", opts]);
            let [bufnr, winid] = arr;
            let res = await new Promise((resolve3) => {
              let disposables = [];
              events_default.on("BufWinLeave", (nr) => {
                if (nr == bufnr) {
                  disposeAll(disposables);
                  resolve3(null);
                }
              }, null, disposables);
              events_default.on("PromptInsert", async (value) => {
                disposeAll(disposables);
                await nvim.call("coc#float#close", [winid]);
                if (!value) {
                  this.showMessage("Empty word, canceled", "warning");
                  resolve3(null);
                } else {
                  resolve3(value);
                }
              }, null, disposables);
            });
            release();
            return res;
          } catch (e) {
            logger27.error("Error on requestInput:", e);
            release();
          }
        } else {
          let res = await workspace_default.callAsync("input", [title + ": ", defaultValue || ""]);
          nvim.command("normal! :<C-u>", true);
          if (!res) {
            this.showMessage("Empty word, canceled", "warning");
            return null;
          }
          return res;
        }
      }
      createStatusBarItem(priority = 0, option = {}) {
        if (!workspace_default.env) {
          let fn = () => {
          };
          return { text: "", show: fn, dispose: fn, hide: fn, priority: 0, isProgress: false };
        }
        if (!this.statusLine) {
          this.statusLine = new StatusLine(this.nvim);
        }
        return this.statusLine.createStatusBarItem(priority, option.progress || false);
      }
      createOutputChannel(name2) {
        return channels_default.create(name2, this.nvim);
      }
      showOutputChannel(name2, preserveFocus) {
        channels_default.show(name2, preserveFocus);
      }
      async echoLines(lines, truncate = false) {
        let { nvim } = this;
        let cmdHeight = workspace_default.env.cmdheight;
        if (lines.length > cmdHeight && truncate) {
          lines = lines.slice(0, cmdHeight);
        }
        let maxLen = workspace_default.env.columns - 12;
        lines = lines.map((line) => {
          line = line.replace(/\n/g, " ");
          if (truncate)
            line = line.slice(0, maxLen);
          return line;
        });
        if (truncate && lines.length == cmdHeight) {
          let last = lines[lines.length - 1];
          lines[cmdHeight - 1] = `${last.length == maxLen ? last.slice(0, -4) : last} ...`;
        }
        await nvim.call("coc#util#echo_lines", [lines]);
      }
      async getCursorPosition() {
        let [line, content] = await this.nvim.eval(`[line('.')-1, strpart(getline('.'), 0, col('.') - 1)]`);
        return import_vscode_languageserver_protocol16.Position.create(line, content.length);
      }
      async moveTo(position) {
        await this.nvim.call("coc#cursor#move_to", [position.line, position.character]);
        if (workspace_default.env.isVim)
          this.nvim.command("redraw", true);
      }
      async getOffset() {
        return await this.nvim.call("coc#cursor#char_offset");
      }
      async getCursorScreenPosition() {
        let [row, col] = await this.nvim.call("coc#cursor#screen_pos");
        return { row, col };
      }
      async showPickerDialog(items, title, token) {
        if (!this.checkDialog())
          return void 0;
        let release = await this.mutex.acquire();
        if (token && token.isCancellationRequested) {
          release();
          return void 0;
        }
        try {
          let useString = typeof items[0] === "string";
          let picker = new Picker(this.nvim, {
            title,
            items: useString ? items.map((s) => {
              return { label: s };
            }) : items
          }, token);
          let promise = new Promise((resolve3) => {
            picker.onDidClose((selected) => {
              resolve3(selected);
            });
          });
          await picker.show(this.dialogPreference);
          let picked = await promise;
          let res = picked == void 0 ? void 0 : items.filter((_, i) => picked.includes(i));
          release();
          return res;
        } catch (e) {
          logger27.error(`Error on showPickerDialog:`, e);
          release();
        }
      }
      async showInformationMessage(message, ...items) {
        if (!this.enableMessageDialog)
          return await this.showConfirm(message, items, "Info");
        let texts = typeof items[0] === "string" ? items : items.map((s) => s.title);
        let idx = await this.createNotification("CocInfoFloat", message, texts);
        return idx == -1 ? void 0 : items[idx];
      }
      async showWarningMessage(message, ...items) {
        if (!this.enableMessageDialog)
          return await this.showConfirm(message, items, "Warning");
        let texts = typeof items[0] === "string" ? items : items.map((s) => s.title);
        let idx = await this.createNotification("CocWarningFloat", message, texts);
        return idx == -1 ? void 0 : items[idx];
      }
      async showErrorMessage(message, ...items) {
        if (!this.enableMessageDialog)
          return await this.showConfirm(message, items, "Error");
        let texts = typeof items[0] === "string" ? items : items.map((s) => s.title);
        let idx = await this.createNotification("CocErrorFloat", message, texts);
        return idx == -1 ? void 0 : items[idx];
      }
      async showNotification(config) {
        if (!this.checkDialog())
          return false;
        let notification = new Notification(this.nvim, config);
        return await notification.show(this.notificationPreference);
      }
      async showConfirm(message, items, kind) {
        if (!items || items.length == 0) {
          let msgType = kind == "Info" ? "more" : kind == "Error" ? "error" : "warning";
          this.showMessage(message, msgType);
          return void 0;
        }
        let titles = typeof items[0] === "string" ? items.slice() : items.map((o) => o.title);
        let choices = titles.map((s, i) => `${i + 1}${s}`);
        let res = await this.nvim.callAsync("coc#util#with_callback", ["confirm", [message, choices.join("\n"), 0, kind]]);
        return items[res - 1];
      }
      async withProgress(options, task) {
        if (!this.checkDialog())
          return void 0;
        let progress = new ProgressNotification(this.nvim, {
          task,
          title: options.title,
          cancellable: options.cancellable
        });
        return await progress.show(this.notificationPreference);
      }
      createTreeView(viewId, options) {
        const BasicTreeView2 = (init_TreeView(), TreeView_exports).default;
        return new BasicTreeView2(viewId, options);
      }
      createNotification(borderhighlight, message, items) {
        return new Promise((resolve3) => {
          let config = {
            content: message,
            borderhighlight,
            close: true,
            buttons: items.map((s, index) => {
              return { text: s, index };
            }),
            callback: (idx) => {
              resolve3(idx);
            }
          };
          let notification = new Notification(this.nvim, config);
          notification.show(this.notificationPreference).then((shown) => {
            if (!shown) {
              logger27.error("Unable to open notification window");
              resolve3(-1);
            }
            if (!items.length)
              resolve3(-1);
          }, (e) => {
            logger27.error("Unable to open notification window", e);
            resolve3(-1);
          });
        });
      }
      get dialogPreference() {
        let config = workspace_default.getConfiguration("dialog");
        return {
          maxWidth: config.get("maxWidth"),
          maxHeight: config.get("maxHeight"),
          floatHighlight: config.get("floatHighlight"),
          floatBorderHighlight: config.get("floatBorderHighlight"),
          pickerButtons: config.get("pickerButtons"),
          pickerButtonShortcut: config.get("pickerButtonShortcut"),
          confirmKey: config.get("confirmKey")
        };
      }
      get notificationPreference() {
        let config = workspace_default.getConfiguration("notification");
        return {
          top: config.get("marginTop"),
          right: config.get("marginRight"),
          maxWidth: config.get("maxWidth"),
          maxHeight: config.get("maxHeight"),
          highlight: config.get("highlightGroup"),
          minProgressWidth: config.get("minProgressWidth")
        };
      }
      checkDialog() {
        if (workspace_default.env.dialog)
          return true;
        this.showMessage("Dialog requires vim >= 8.2.0750 or neovim >= 0.4.0, please upgrade your vim", "warning");
        return false;
      }
      get enableMessageDialog() {
        if (!workspace_default.env.dialog)
          return false;
        let config = workspace_default.getConfiguration("coc.preferences");
        return config.get("enableMessageDialog", false);
      }
      get messageLevel() {
        let config = workspace_default.getConfiguration("coc.preferences");
        let level = config.get("messageLevel", "more");
        switch (level) {
          case "error":
            return MessageLevel.Error;
          case "warning":
            return MessageLevel.Warning;
          default:
            return MessageLevel.More;
        }
      }
    };
    window_default = new Window();
  }
});

// src/diagnostic/util.ts
function getSeverityName(severity) {
  switch (severity) {
    case import_vscode_languageserver_protocol17.DiagnosticSeverity.Warning:
      return "Warning";
    case import_vscode_languageserver_protocol17.DiagnosticSeverity.Information:
      return "Information";
    case import_vscode_languageserver_protocol17.DiagnosticSeverity.Hint:
      return "Hint";
    default:
      return "Error";
  }
}
function getSeverityType(severity) {
  switch (severity) {
    case import_vscode_languageserver_protocol17.DiagnosticSeverity.Warning:
      return "W";
    case import_vscode_languageserver_protocol17.DiagnosticSeverity.Information:
      return "I";
    case import_vscode_languageserver_protocol17.DiagnosticSeverity.Hint:
      return "I";
    default:
      return "E";
  }
}
function severityLevel(level) {
  switch (level) {
    case "hint":
      return import_vscode_languageserver_protocol17.DiagnosticSeverity.Hint;
    case "information":
      return import_vscode_languageserver_protocol17.DiagnosticSeverity.Information;
    case "warning":
      return import_vscode_languageserver_protocol17.DiagnosticSeverity.Warning;
    case "error":
      return import_vscode_languageserver_protocol17.DiagnosticSeverity.Error;
    default:
      return import_vscode_languageserver_protocol17.DiagnosticSeverity.Hint;
  }
}
function getNameFromSeverity(severity) {
  switch (severity) {
    case import_vscode_languageserver_protocol17.DiagnosticSeverity.Error:
      return "CocError";
    case import_vscode_languageserver_protocol17.DiagnosticSeverity.Warning:
      return "CocWarning";
    case import_vscode_languageserver_protocol17.DiagnosticSeverity.Information:
      return "CocInfo";
    case import_vscode_languageserver_protocol17.DiagnosticSeverity.Hint:
      return "CocHint";
    default:
      return "CocError";
  }
}
function getLocationListItem(bufnr, diagnostic) {
  let { start, end } = diagnostic.range;
  let owner = diagnostic.source || "coc.nvim";
  let msg = diagnostic.message.split("\n")[0];
  let type = getSeverityName(diagnostic.severity).slice(0, 1).toUpperCase();
  return {
    bufnr,
    lnum: start.line + 1,
    end_lnum: end.line + 1,
    col: start.character + 1,
    end_col: end.character + 1,
    text: `[${owner}${diagnostic.code ? " " + diagnostic.code : ""}] ${msg} [${type}]`,
    type
  };
}
var import_vscode_languageserver_protocol17;
var init_util3 = __esm({
  "src/diagnostic/util.ts"() {
    import_vscode_languageserver_protocol17 = __toModule(require_main2());
  }
});

// src/diagnostic/buffer.ts
function sortDiagnostics(a, b) {
  if ((a.severity || 1) != (b.severity || 1)) {
    return (a.severity || 1) - (b.severity || 1);
  }
  let d = comparePosition(a.range.start, b.range.start);
  if (d != 0)
    return d;
  return a.source > b.source ? 1 : -1;
}
function getHighlightGroup(diagnostic) {
  let tags = diagnostic.tags || [];
  if (tags.includes(import_vscode_languageserver_protocol18.DiagnosticTag.Deprecated)) {
    return DiagnosticHighlight.Deprecated;
  }
  if (tags.includes(import_vscode_languageserver_protocol18.DiagnosticTag.Unnecessary)) {
    return DiagnosticHighlight.Unused;
  }
  switch (diagnostic.severity) {
    case import_vscode_languageserver_protocol18.DiagnosticSeverity.Warning:
      return DiagnosticHighlight.Warning;
    case import_vscode_languageserver_protocol18.DiagnosticSeverity.Information:
      return DiagnosticHighlight.Information;
    case import_vscode_languageserver_protocol18.DiagnosticSeverity.Hint:
      return DiagnosticHighlight.Hint;
    default:
      return DiagnosticHighlight.Error;
  }
}
var import_vscode_languageserver_protocol18, isVim5, logger28, signGroup, highlightNamespace2, hlGroups, DiagnosticHighlight, DiagnosticBuffer;
var init_buffer = __esm({
  "src/diagnostic/buffer.ts"() {
    init_mutex();
    import_vscode_languageserver_protocol18 = __toModule(require_main2());
    init_object();
    init_position();
    init_workspace();
    init_events();
    init_util3();
    isVim5 = process.env.VIM_NODE_RPC == "1";
    logger28 = require_logger2()("diagnostic-buffer");
    signGroup = "CocDiagnostic";
    highlightNamespace2 = "diagnostic";
    hlGroups = ["CocErrorHighlight", "CocWarningHighlight", "CocInfoHighlight", "CocHintHighlight", "CocDeprecatedHighlight", "CocUnusedHighlight"];
    (function(DiagnosticHighlight2) {
      DiagnosticHighlight2["Error"] = "CocErrorHighlight";
      DiagnosticHighlight2["Warning"] = "CocWarningHighlight";
      DiagnosticHighlight2["Information"] = "CocInfoHighlight";
      DiagnosticHighlight2["Hint"] = "CocHintHighlight";
      DiagnosticHighlight2["Deprecated"] = "CocDeprecatedHighlight";
      DiagnosticHighlight2["Unused"] = "CocUnusedHighlight";
    })(DiagnosticHighlight || (DiagnosticHighlight = {}));
    DiagnosticBuffer = class {
      constructor(nvim, bufnr, uri, config, onRefresh) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this.uri = uri;
        this.config = config;
        this.onRefresh = onRefresh;
        this.diagnosticsMap = new Map();
        this.mutex = new Mutex();
        this._disposed = false;
      }
      get displayByAle() {
        return this.config.displayByAle;
      }
      clearHighlight(collection) {
        this.buffer.clearNamespace(highlightNamespace2 + collection);
      }
      clearSigns(collection) {
        this.buffer.unplaceSign({ group: signGroup + collection });
      }
      get diagnostics() {
        let res = [];
        for (let diags of this.diagnosticsMap.values()) {
          res.push(...diags);
        }
        return res;
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      refreshAle(collection, diagnostics) {
        let aleItems = diagnostics.map((o) => {
          let range = o.range;
          return {
            text: o.message,
            code: o.code,
            lnum: range.start.line + 1,
            col: range.start.character + 1,
            end_lnum: range.end.line + 1,
            end_col: range.end.character,
            type: getSeverityType(o.severity)
          };
        });
        let method = global.hasOwnProperty("__TEST__") ? "MockAleResults" : "ale#other_source#ShowResults";
        this.nvim.call(method, [this.bufnr, "coc" + collection, aleItems], true);
      }
      async refresh(diagnosticsMap, force) {
        let release = await this.mutex.acquire();
        try {
          await this._refresh(diagnosticsMap, force === true);
          release();
        } catch (e) {
          release();
          this.nvim.echoError(e);
        }
      }
      async _refresh(diagnosticsMap, force) {
        let { refreshOnInsertMode } = this.config;
        let { nvim } = this;
        let checkInsert = !this.displayByAle && !refreshOnInsertMode;
        if (events_default.insertMode && checkInsert)
          return;
        let info = await nvim.call("coc#util#diagnostic_info", [this.bufnr, checkInsert]);
        if (!info || this._disposed)
          return;
        if (this.displayByAle) {
          nvim.pauseNotification();
          for (let [collection, diagnostics] of Object.entries(diagnosticsMap)) {
            this.diagnosticsMap.set(collection, []);
            this.refreshAle(collection, diagnostics);
          }
          await nvim.resumeNotification();
        } else {
          let changed = false;
          let redraw = false;
          nvim.pauseNotification();
          for (let [collection, diagnostics] of Object.entries(diagnosticsMap)) {
            let prev = this.diagnosticsMap.get(collection) || [];
            this.diagnosticsMap.set(collection, diagnostics);
            if (!equals(prev, diagnostics)) {
              changed = true;
              redraw = true;
              this.addSigns(collection, diagnostics);
              this.updateHighlights(collection, diagnostics);
            } else if (prev.length && force) {
              redraw = true;
              this.updateHighlights(collection, diagnostics);
            }
          }
          if (changed) {
            this.showVirtualText(info.lnum, info.bufnr);
            this.updateLocationList(info.winid, info.locationlist);
            this.setDiagnosticInfo();
          }
          if (isVim5 && redraw)
            this.nvim.command("redraw", true);
          await this.nvim.resumeNotification();
        }
        this.onRefresh(this.diagnostics);
      }
      updateLocationList(winid, title) {
        if (!this.config.locationlistUpdate || winid == -1 || title !== "Diagnostics of coc")
          return;
        let items = [];
        let { diagnostics } = this;
        diagnostics.sort(sortDiagnostics);
        for (let diagnostic of diagnostics) {
          let item = getLocationListItem(this.bufnr, diagnostic);
          items.push(item);
        }
        this.nvim.call("setloclist", [winid, [], "r", { title: "Diagnostics of coc", items }], true);
      }
      addSigns(collection, diagnostics) {
        if (!this.config.enableSign)
          return;
        let group2 = signGroup + collection;
        this.buffer.unplaceSign({ group: group2 });
        let signsMap = new Map();
        for (let diagnostic of diagnostics) {
          let { range, severity } = diagnostic;
          let line = range.start.line;
          let exists = signsMap.get(line) || [];
          if (exists.includes(severity)) {
            continue;
          }
          exists.push(severity);
          signsMap.set(line, exists);
          let priority = this.config.signPriority + 4 - severity;
          let name2 = getNameFromSeverity(severity);
          this.buffer.placeSign({ name: name2, lnum: line + 1, group: group2, priority });
        }
      }
      setDiagnosticInfo() {
        let lnums = [0, 0, 0, 0];
        let info = { error: 0, warning: 0, information: 0, hint: 0, lnums };
        for (let diagnostics of this.diagnosticsMap.values()) {
          for (let diagnostic of diagnostics) {
            let lnum = diagnostic.range.start.line + 1;
            switch (diagnostic.severity) {
              case import_vscode_languageserver_protocol18.DiagnosticSeverity.Warning:
                info.warning = info.warning + 1;
                lnums[1] = lnums[1] ? Math.min(lnums[1], lnum) : lnum;
                break;
              case import_vscode_languageserver_protocol18.DiagnosticSeverity.Information:
                info.information = info.information + 1;
                lnums[2] = lnums[2] ? Math.min(lnums[2], lnum) : lnum;
                break;
              case import_vscode_languageserver_protocol18.DiagnosticSeverity.Hint:
                info.hint = info.hint + 1;
                lnums[3] = lnums[3] ? Math.min(lnums[3], lnum) : lnum;
                break;
              default:
                lnums[0] = lnums[0] ? Math.min(lnums[0], lnum) : lnum;
                info.error = info.error + 1;
            }
          }
        }
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.setVar("coc_diagnostic_info", info, true);
        this.nvim.call("coc#util#do_autocmd", ["CocDiagnosticChange"], true);
      }
      showVirtualText(lnum, bufnr) {
        if (!this.config.virtualText)
          return;
        let { virtualTextSrcId, virtualTextPrefix, virtualTextCurrentLineOnly } = this.config;
        let { diagnostics, buffer } = this;
        if (virtualTextCurrentLineOnly) {
          if (bufnr && this.bufnr != bufnr)
            return;
          diagnostics = diagnostics.filter((d) => {
            let { start, end } = d.range;
            return start.line <= lnum - 1 && end.line >= lnum - 1;
          });
        }
        diagnostics.sort(sortDiagnostics);
        buffer.clearNamespace(virtualTextSrcId);
        for (let i = diagnostics.length - 1; i >= 0; i--) {
          let diagnostic = diagnostics[i];
          let { line } = diagnostic.range.start;
          let highlight = getNameFromSeverity(diagnostic.severity) + "VirtualText";
          let msg = diagnostic.message.split(/\n/).map((l) => l.trim()).filter((l) => l.length > 0).slice(0, this.config.virtualTextLines).join(this.config.virtualTextLineSeparator);
          void buffer.setVirtualText(virtualTextSrcId, line, [[virtualTextPrefix + msg, highlight]], {});
        }
      }
      updateHighlights(collection, diagnostics) {
        if (!diagnostics.length) {
          this.clearHighlight(collection);
        } else {
          let items = this.getHighlightItems(diagnostics);
          this.buffer.updateHighlights(highlightNamespace2 + collection, items);
        }
      }
      getHighlightItems(diagnostics) {
        let doc = workspace_default.getDocument(this.bufnr);
        if (!doc)
          return [];
        let res = [];
        for (let diagnostic of diagnostics.slice(0, this.config.highlighLimit)) {
          let hlGroup = getHighlightGroup(diagnostic);
          doc.addHighlights(res, hlGroup, diagnostic.range);
        }
        res.sort((a, b) => {
          if (a.lnum != b.lnum)
            return a.lnum - b.lnum;
          if (a.colStart != b.colStart)
            return a.colStart - b.colStart;
          return hlGroups.indexOf(b.hlGroup) - hlGroups.indexOf(a.hlGroup);
        });
        return res;
      }
      clear() {
        let { nvim } = this;
        let collections = Array.from(this.diagnosticsMap.keys());
        this.diagnosticsMap.clear();
        if (this.displayByAle) {
          for (let collection of collections) {
            let method = global.hasOwnProperty("__TEST__") ? "MockAleResults" : "ale#other_source#ShowResults";
            this.nvim.call(method, [this.bufnr, collection, []], true);
          }
        } else {
          nvim.pauseNotification();
          for (let collection of collections) {
            this.clearHighlight(collection);
            this.clearSigns(collection);
          }
          if (this.config.virtualText) {
            this.buffer.clearNamespace(this.config.virtualTextSrcId);
          }
          this.buffer.deleteVar("coc_diagnostic_info");
          void nvim.resumeNotification(false, true);
        }
      }
      getDiagnosticsAt(pos, checkCurrentLine) {
        let diagnostics = [];
        for (let diags of this.diagnosticsMap.values()) {
          if (checkCurrentLine) {
            diagnostics.push(...diags.filter((o) => lineInRange(pos.line, o.range)));
          } else {
            diagnostics.push(...diags.filter((o) => positionInRange(pos, o.range) == 0));
          }
        }
        diagnostics.sort(sortDiagnostics);
        return diagnostics;
      }
      async isEnabled() {
        if (this._disposed)
          return false;
        let buf = this.nvim.createBuffer(this.bufnr);
        let res = await buf.getVar("coc_diagnostic_disable");
        return res != 1;
      }
      dispose() {
        this._disposed = true;
        this.clear();
      }
    };
  }
});

// src/diagnostic/collection.ts
var import_vscode_languageserver_protocol19, logger29, DiagnosticCollection;
var init_collection = __esm({
  "src/diagnostic/collection.ts"() {
    import_vscode_languageserver_protocol19 = __toModule(require_main2());
    init_esm2();
    init_workspace();
    logger29 = require_logger2()("diagnostic-collection");
    DiagnosticCollection = class {
      constructor(name2, onDispose) {
        this.name = name2;
        this.onDispose = onDispose;
        this.diagnosticsMap = new Map();
        this._onDidDiagnosticsChange = new import_vscode_languageserver_protocol19.Emitter();
        this.onDidDiagnosticsChange = this._onDidDiagnosticsChange.event;
      }
      set(entries, diagnostics) {
        let diagnosticsPerFile = new Map();
        if (!Array.isArray(entries)) {
          let doc = workspace_default.getDocument(entries);
          let uri = doc ? doc.uri : entries;
          diagnosticsPerFile.set(uri, diagnostics || []);
        } else {
          for (let item of entries) {
            let [uri, diagnostics2] = item;
            let doc = workspace_default.getDocument(uri);
            uri = doc ? doc.uri : uri;
            if (diagnostics2 == null) {
              diagnostics2 = [];
            } else {
              diagnostics2 = (diagnosticsPerFile.get(uri) || []).concat(diagnostics2);
            }
            diagnosticsPerFile.set(uri, diagnostics2);
          }
        }
        for (let item of diagnosticsPerFile) {
          let [uri, diagnostics2] = item;
          uri = URI.parse(uri).toString();
          diagnostics2.forEach((o) => {
            o.range = o.range || import_vscode_languageserver_protocol19.Range.create(0, 0, 0, 0);
            o.message = o.message || "";
            o.source = o.source || this.name;
          });
          this.diagnosticsMap.set(uri, diagnostics2);
          this._onDidDiagnosticsChange.fire(uri);
        }
      }
      delete(uri) {
        this.diagnosticsMap.delete(uri);
        this._onDidDiagnosticsChange.fire(uri);
      }
      clear() {
        let uris = this.diagnosticsMap.keys();
        this.diagnosticsMap.clear();
        for (let uri of uris) {
          this._onDidDiagnosticsChange.fire(uri);
        }
      }
      forEach(callback, thisArg) {
        for (let uri of this.diagnosticsMap.keys()) {
          let diagnostics = this.diagnosticsMap.get(uri);
          callback.call(thisArg, uri, diagnostics, this);
        }
      }
      get(uri) {
        let arr = this.diagnosticsMap.get(uri);
        return arr == null ? [] : arr;
      }
      has(uri) {
        return this.diagnosticsMap.has(uri);
      }
      dispose() {
        this.clear();
        if (this.onDispose)
          this.onDispose();
        this._onDidDiagnosticsChange.dispose();
      }
    };
  }
});

// src/diagnostic/manager.ts
var import_debounce4, import_vscode_languageserver_protocol20, logger30, DiagnosticManager, manager_default;
var init_manager = __esm({
  "src/diagnostic/manager.ts"() {
    import_debounce4 = __toModule(require_debounce());
    import_vscode_languageserver_protocol20 = __toModule(require_main2());
    init_esm2();
    init_events();
    init_floatFactory();
    init_util();
    init_position();
    init_window();
    init_workspace();
    init_buffer();
    init_collection();
    init_util3();
    logger30 = require_logger2()("diagnostic-manager");
    DiagnosticManager = class {
      constructor() {
        this.enabled = true;
        this._onDidRefresh = new import_vscode_languageserver_protocol20.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.collections = [];
        this.disposables = [];
      }
      init() {
        this.setConfiguration();
        workspace_default.onDidChangeConfiguration((e) => {
          this.setConfiguration(e);
        }, null, this.disposables);
        this.floatFactory = new FloatFactory(this.nvim);
        this.buffers = workspace_default.registerBufferSync((doc) => {
          if (doc.buftype !== "")
            return void 0;
          let buf = new DiagnosticBuffer(this.nvim, doc.bufnr, doc.uri, this.config, (diagnostics) => {
            this._onDidRefresh.fire({ diagnostics, uri: buf.uri, bufnr: buf.bufnr });
            if (["never", "jump"].includes(this.config.enableMessage))
              return;
            if (events_default.insertMode)
              return;
            this.echoMessage(true).logError();
          });
          let collections = this.getCollections(doc.uri);
          if (this.enabled && collections.length) {
            let diagnostics = this.getDiagnostics(doc.uri);
            void buf.refresh(diagnostics);
          }
          return buf;
        });
        workspace_default.onDidCloseTextDocument((e) => {
          for (let collection of this.collections) {
            collection.delete(e.uri);
          }
        }, null, this.disposables);
        events_default.on("CursorMoved", (bufnr) => {
          if (this.config.enableMessage != "always")
            return;
          if (!this.buffers.getItem(bufnr))
            return;
          if (this.timer)
            clearTimeout(this.timer);
          this.timer = setTimeout(async () => {
            await this.echoMessage(true);
          }, this.config.messageDelay);
        }, null, this.disposables);
        let fn = (0, import_debounce4.default)((bufnr, cursor) => {
          if (!this.config.virtualTextCurrentLineOnly)
            return;
          let buf = this.buffers.getItem(bufnr);
          if (buf)
            buf.showVirtualText(cursor[0]);
        }, 100);
        events_default.on("CursorMoved", fn, null, this.disposables);
        this.disposables.push(import_vscode_languageserver_protocol20.Disposable.create(() => {
          fn.clear();
        }));
        let timer;
        events_default.on("InsertLeave", async (bufnr) => {
          if (this.config.refreshOnInsertMode || !this.autoRefresh)
            return;
          let doc = workspace_default.getDocument(bufnr);
          if (!(doc == null ? void 0 : doc.attached))
            return;
          doc._forceSync();
          timer = setTimeout(() => {
            if (events_default.insertMode)
              return;
            for (let buf of this.buffers.items) {
              void buf.refresh(this.getDiagnostics(buf.uri), false);
            }
          }, Math.max(0, 500 - Date.now() + events_default.lastChangeTs));
        }, null, this.disposables);
        let clear = () => {
          if (timer)
            clearTimeout(timer);
        };
        this.disposables.push({ dispose: clear });
        events_default.on("InsertEnter", clear, null, this.disposables);
        events_default.on("BufEnter", async () => {
          if (this.timer)
            clearTimeout(this.timer);
        }, null, this.disposables);
        let errorItems = workspace_default.configurations.errorItems;
        this.setConfigurationErrors(errorItems);
        workspace_default.configurations.onError((items) => {
          this.setConfigurationErrors(items);
        }, null, this.disposables);
      }
      defineSigns() {
        let { nvim } = this;
        let { enableHighlightLineNumber, enableSign } = this.config;
        if (!enableSign)
          return;
        nvim.pauseNotification();
        for (let kind of ["Error", "Warning", "Info", "Hint"]) {
          let signText = this.config[kind.toLowerCase() + "Sign"];
          let cmd = `sign define Coc${kind} linehl=Coc${kind}Line`;
          if (signText)
            cmd += ` texthl=Coc${kind}Sign text=${signText}`;
          if (enableHighlightLineNumber)
            cmd += ` numhl=Coc${kind}Sign`;
          nvim.command(cmd, true);
        }
        void nvim.resumeNotification(false, true);
      }
      async setLocationlist(bufnr) {
        let buf = this.buffers.getItem(bufnr);
        let diagnosticsMap = buf ? this.getDiagnostics(buf.uri) : {};
        let items = [];
        for (let diagnostics of Object.values(diagnosticsMap)) {
          for (let diagnostic of diagnostics) {
            let item = getLocationListItem(bufnr, diagnostic);
            items.push(item);
          }
        }
        let curr = await this.nvim.call("getloclist", [0, { title: 1 }]);
        let action = curr.title && curr.title.indexOf("Diagnostics of coc") != -1 ? "r" : " ";
        await this.nvim.call("setloclist", [0, [], action, { title: "Diagnostics of coc", items }]);
      }
      setConfigurationErrors(errorItems) {
        let collection = this.create("config");
        if (errorItems == null ? void 0 : errorItems.length) {
          let entries = new Map();
          for (let item of errorItems) {
            let { uri } = item.location;
            let diagnostics = entries.get(uri) || [];
            diagnostics.push(import_vscode_languageserver_protocol20.Diagnostic.create(item.location.range, item.message, import_vscode_languageserver_protocol20.DiagnosticSeverity.Error));
            entries.set(uri, diagnostics);
          }
          collection.set(Array.from(entries));
        } else {
          collection.clear();
        }
      }
      create(name2) {
        let collection = this.getCollectionByName(name2);
        if (collection)
          return collection;
        collection = new DiagnosticCollection(name2, () => {
          let idx = this.collections.findIndex((o) => o == collection);
          if (idx !== -1)
            this.collections.splice(idx, 1);
        });
        this.collections.push(collection);
        collection.onDidDiagnosticsChange((uri) => {
          let buf = this.buffers.getItem(uri);
          if (!this.autoRefresh || !buf)
            return;
          if (events_default.insertMode && !this.config.refreshOnInsertMode)
            return;
          void buf.refresh(this.getDiagnostics(uri, name2), true);
        });
        return collection;
      }
      getSortedRanges(uri, severity) {
        let collections = this.getCollections(uri);
        let res = [];
        let level = severity ? severityLevel(severity) : 0;
        for (let collection of collections) {
          let diagnostics = collection.get(uri);
          if (level) {
            diagnostics = diagnostics.filter((o) => o.severity == level);
          } else {
            let minLevel = this.config.level;
            if (minLevel && minLevel < import_vscode_languageserver_protocol20.DiagnosticSeverity.Hint) {
              diagnostics = diagnostics.filter((o) => {
                if (o.severity && o.severity > minLevel) {
                  return false;
                }
                return true;
              });
            }
          }
          let ranges = diagnostics.map((o) => o.range);
          res.push(...ranges);
        }
        res.sort((a, b) => {
          if (a.start.line != b.start.line) {
            return a.start.line - b.start.line;
          }
          return a.start.character - b.start.character;
        });
        return res;
      }
      getDiagnostics(uri, collection) {
        let res = {};
        let collections = collection ? [this.getCollectionByName(collection)] : this.getCollections(uri);
        let { level, showUnused, showDeprecated } = this.config;
        for (let collection2 of collections) {
          if (!collection2)
            continue;
          let items = collection2.get(uri) || [];
          if (items.length) {
            items = items.filter((d) => {
              var _a2, _b;
              if (level && d.severity && d.severity > level) {
                return false;
              }
              if (!showUnused && ((_a2 = d.tags) == null ? void 0 : _a2.includes(import_vscode_languageserver_protocol20.DiagnosticTag.Unnecessary))) {
                return false;
              }
              if (!showDeprecated && ((_b = d.tags) == null ? void 0 : _b.includes(import_vscode_languageserver_protocol20.DiagnosticTag.Deprecated))) {
                return false;
              }
              return true;
            });
            items.sort((a, b) => {
              return comparePosition(a.range.start, b.range.start);
            });
          }
          res[collection2.name] = items;
        }
        return res;
      }
      getDiagnosticsInRange(document2, range) {
        let collections = this.getCollections(document2.uri);
        let res = [];
        for (let collection of collections) {
          let items = collection.get(document2.uri);
          if (!items)
            continue;
          for (let item of items) {
            if (rangeIntersect(item.range, range)) {
              res.push(item);
            }
          }
        }
        return res;
      }
      async preview() {
        let diagnostics = await this.getCurrentDiagnostics();
        if (diagnostics.length == 0) {
          this.nvim.command("pclose", true);
          return;
        }
        let lines = [];
        for (let diagnostic of diagnostics) {
          let { source, code, severity, message } = diagnostic;
          let s = getSeverityName(severity)[0];
          lines.push(`[${source}${code ? " " + code : ""}] [${s}]`);
          lines.push(...message.split(/\r?\n/));
          lines.push("");
        }
        this.nvim.call("coc#util#preview_info", [lines, "txt"], true);
      }
      async jumpPrevious(severity) {
        let buffer = await this.nvim.buffer;
        let document2 = workspace_default.getDocument(buffer.id);
        if (!document2)
          return;
        let curpos = await window_default.getCursorPosition();
        let ranges = this.getSortedRanges(document2.uri, severity);
        let pos;
        for (let i = ranges.length - 1; i >= 0; i--) {
          let end = ranges[i].end;
          if (comparePosition(end, curpos) < 0) {
            pos = ranges[i].start;
            break;
          } else if (i == 0) {
            let wrapscan = await this.nvim.getOption("wrapscan");
            if (wrapscan)
              pos = ranges[ranges.length - 1].start;
          }
        }
        if (pos) {
          await window_default.moveTo(pos);
          if (this.config.enableMessage == "never")
            return;
          await this.echoMessage(false);
        }
      }
      async jumpNext(severity) {
        let buffer = await this.nvim.buffer;
        let document2 = workspace_default.getDocument(buffer.id);
        let curpos = await window_default.getCursorPosition();
        let ranges = this.getSortedRanges(document2.uri, severity);
        let pos;
        for (let i = 0; i <= ranges.length - 1; i++) {
          let start = ranges[i].start;
          if (comparePosition(start, curpos) > 0) {
            pos = ranges[i].start;
            break;
          } else if (i == ranges.length - 1) {
            let wrapscan = await this.nvim.getOption("wrapscan");
            if (wrapscan)
              pos = ranges[0].start;
          }
        }
        if (pos) {
          await window_default.moveTo(pos);
          if (this.config.enableMessage == "never")
            return;
          await this.echoMessage(false);
        }
      }
      getDiagnosticList() {
        let res = [];
        const { level, showUnused, showDeprecated } = this.config;
        for (let collection of this.collections) {
          collection.forEach((uri, diagnostics) => {
            var _a2, _b;
            let file = URI.parse(uri).fsPath;
            for (let diagnostic of diagnostics) {
              if (diagnostic.severity && diagnostic.severity > level) {
                continue;
              }
              if (!showUnused && ((_a2 = diagnostic.tags) == null ? void 0 : _a2.includes(import_vscode_languageserver_protocol20.DiagnosticTag.Unnecessary))) {
                continue;
              }
              if (!showDeprecated && ((_b = diagnostic.tags) == null ? void 0 : _b.includes(import_vscode_languageserver_protocol20.DiagnosticTag.Deprecated))) {
                continue;
              }
              let { start, end } = diagnostic.range;
              let o = {
                file,
                lnum: start.line + 1,
                end_lnum: end.line + 1,
                col: start.character + 1,
                end_col: end.character + 1,
                code: diagnostic.code,
                source: diagnostic.source || collection.name,
                message: diagnostic.message,
                severity: getSeverityName(diagnostic.severity),
                level: diagnostic.severity || 0,
                location: import_vscode_languageserver_protocol20.Location.create(uri, diagnostic.range)
              };
              res.push(o);
            }
          });
        }
        res.sort((a, b) => {
          if (a.level !== b.level) {
            return a.level - b.level;
          }
          if (a.file !== b.file) {
            return a.file > b.file ? 1 : -1;
          } else {
            if (a.lnum != b.lnum) {
              return a.lnum - b.lnum;
            }
            return a.col - b.col;
          }
        });
        return res;
      }
      getDiagnosticsAt(bufnr, cursor, atEnd = false, lastline = false) {
        let buffer = this.buffers.getItem(bufnr);
        if (!buffer)
          return [];
        let pos = import_vscode_languageserver_protocol20.Position.create(cursor[0], cursor[1]);
        let res = buffer.getDiagnosticsAt(pos, this.config.checkCurrentLine);
        if (this.config.checkCurrentLine || res.length)
          return res;
        if (atEnd) {
          pos = import_vscode_languageserver_protocol20.Position.create(cursor[0], cursor[1] + 1);
          res = buffer.getDiagnosticsAt(pos, false);
          if (res.length)
            return res;
        }
        if (lastline && cursor[1] == 0) {
          pos = import_vscode_languageserver_protocol20.Position.create(cursor[0] + 1, 0);
          res = buffer.getDiagnosticsAt(pos, false);
        }
        return res;
      }
      async getCurrentDiagnostics() {
        let [bufnr, cursor, eol, lastline] = await this.nvim.eval(`[bufnr("%"),coc#cursor#position(),col('.')==col('$')-1,line('.')==line('$')]`);
        return this.getDiagnosticsAt(bufnr, cursor, eol == 1, lastline == 1);
      }
      async echoMessage(truncate = false) {
        const config = this.config;
        if (!this.enabled || config.displayByAle)
          return;
        if (this.timer)
          clearTimeout(this.timer);
        let useFloat = config.messageTarget == "float";
        let [filetype, mode] = await this.nvim.eval(`[&filetype,mode()]`);
        if (mode != "n")
          return;
        let diagnostics = await this.getCurrentDiagnostics();
        if (diagnostics.length == 0) {
          if (useFloat)
            this.floatFactory.close();
          return;
        }
        if (truncate && workspace_default.insertMode)
          return;
        let docs = [];
        let ft = "";
        if (Object.keys(config.filetypeMap).length > 0) {
          const defaultFiletype = config.filetypeMap["default"] || "";
          ft = config.filetypeMap[filetype] || (defaultFiletype == "bufferType" ? filetype : defaultFiletype);
        }
        diagnostics.forEach((diagnostic) => {
          let { source, code, severity, message } = diagnostic;
          let s = getSeverityName(severity)[0];
          const codeStr = code ? " " + code : "";
          const str = config.format.replace("%source", source).replace("%code", codeStr).replace("%severity", s).replace("%message", message);
          let filetype2 = "Error";
          if (ft === "") {
            switch (severity) {
              case import_vscode_languageserver_protocol20.DiagnosticSeverity.Hint:
                filetype2 = "Hint";
                break;
              case import_vscode_languageserver_protocol20.DiagnosticSeverity.Warning:
                filetype2 = "Warning";
                break;
              case import_vscode_languageserver_protocol20.DiagnosticSeverity.Information:
                filetype2 = "Info";
                break;
            }
          } else {
            filetype2 = ft;
          }
          docs.push({ filetype: filetype2, content: str });
        });
        if (useFloat) {
          let config2 = this.floatFactory.applyFloatConfig({ modes: ["n"], maxWidth: 80 }, this.config.floatConfig);
          await this.floatFactory.show(docs, config2);
        } else {
          let lines = docs.map((d) => d.content).join("\n").split(/\r?\n/);
          if (lines.length) {
            await this.nvim.command('echo ""');
            await window_default.echoLines(lines, truncate);
          }
        }
      }
      async jumpRelated() {
        let diagnostics = await this.getCurrentDiagnostics();
        if (!diagnostics)
          return;
        let diagnostic = diagnostics.find((o) => o.relatedInformation != null);
        if (!diagnostic)
          return;
        let locations = diagnostic.relatedInformation.map((o) => o.location);
        if (locations.length == 1) {
          await workspace_default.jumpTo(locations[0].uri, locations[0].range.start);
        } else if (locations.length > 1) {
          await workspace_default.showLocations(locations);
        }
      }
      reset() {
        if (this.timer) {
          clearTimeout(this.timer);
        }
        this.buffers.reset();
        for (let collection of this.collections) {
          collection.dispose();
        }
        this.collections = [];
      }
      dispose() {
        var _a2;
        this.buffers.dispose();
        if (this.timer) {
          clearTimeout(this.timer);
        }
        for (let collection of this.collections) {
          collection.dispose();
        }
        (_a2 = this.floatFactory) == null ? void 0 : _a2.close();
        this.collections = [];
        disposeAll(this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      setConfiguration(event) {
        if (event && !event.affectsConfiguration("diagnostic"))
          return;
        let config = workspace_default.getConfiguration("diagnostic");
        let messageTarget = config.get("messageTarget", "float");
        if (messageTarget == "float" && !workspace_default.env.floating && !workspace_default.env.textprop) {
          messageTarget = "echo";
        }
        let enableHighlightLineNumber = config.get("enableHighlightLineNumber", true);
        if (!workspace_default.isNvim)
          enableHighlightLineNumber = false;
        this.config = {
          floatConfig: config.get("floatConfig", {}),
          messageTarget,
          enableHighlightLineNumber,
          highlighLimit: config.get("highlighLimit", 1e3),
          autoRefresh: config.get("autoRefresh", true),
          virtualTextSrcId: workspace_default.createNameSpace("diagnostic-virtualText"),
          checkCurrentLine: config.get("checkCurrentLine", false),
          enableSign: workspace_default.env.sign && config.get("enableSign", true),
          locationlistUpdate: config.get("locationlistUpdate", true),
          enableMessage: config.get("enableMessage", "always"),
          messageDelay: config.get("messageDelay", 200),
          virtualText: config.get("virtualText", false) && this.nvim.hasFunction("nvim_buf_set_virtual_text"),
          virtualTextCurrentLineOnly: config.get("virtualTextCurrentLineOnly", true),
          virtualTextPrefix: config.get("virtualTextPrefix", " "),
          virtualTextLineSeparator: config.get("virtualTextLineSeparator", " \\ "),
          virtualTextLines: config.get("virtualTextLines", 3),
          displayByAle: config.get("displayByAle", false),
          level: severityLevel(config.get("level", "hint")),
          signPriority: config.get("signPriority", 10),
          errorSign: config.get("errorSign", ">>"),
          warningSign: config.get("warningSign", ">>"),
          infoSign: config.get("infoSign", ">>"),
          hintSign: config.get("hintSign", ">>"),
          refreshOnInsertMode: config.get("refreshOnInsertMode", false),
          filetypeMap: config.get("filetypeMap", {}),
          showUnused: config.get("showUnused", true),
          showDeprecated: config.get("showDeprecated", true),
          format: config.get("format", "[%source%code] [%severity] %message")
        };
        this.enabled = config.get("enable", true);
        this.defineSigns();
      }
      getCollectionByName(name2) {
        return this.collections.find((o) => o.name == name2);
      }
      getCollections(uri) {
        return this.collections.filter((c) => c.has(uri));
      }
      toggleDiagnostic() {
        let { enabled } = this;
        this.enabled = !enabled;
        for (let buf of this.buffers.items) {
          if (this.enabled) {
            void this.refreshBuffer(buf.uri, true);
          } else {
            buf.clear();
          }
        }
      }
      async toggleDiagnosticBuffer(bufnr) {
        if (!this.enabled)
          return;
        let buf = this.buffers.getItem(bufnr);
        if (buf) {
          let isEnabled = await buf.isEnabled();
          await this.nvim.call("setbufvar", [bufnr, "coc_diagnostic_disable", isEnabled ? 1 : 0]);
          if (isEnabled) {
            buf.clear();
          } else {
            void this.refreshBuffer(bufnr, true);
          }
        }
      }
      get autoRefresh() {
        return this.enabled && this.config.autoRefresh;
      }
      async refreshBuffer(uri, force = false) {
        let buf = this.buffers.getItem(uri);
        if (!buf)
          return false;
        await buf.refresh(this.getDiagnostics(buf.uri), force);
        return true;
      }
      refresh(bufnr) {
        if (!bufnr) {
          for (let item of this.buffers.items) {
            void this.refreshBuffer(item.uri, true);
          }
        } else {
          let item = this.buffers.getItem(bufnr);
          if (item) {
            void this.refreshBuffer(item.uri, true);
          }
        }
      }
    };
    manager_default = new DiagnosticManager();
  }
});

// src/util/charCode.ts
var CharCode;
var init_charCode = __esm({
  "src/util/charCode.ts"() {
    (function(CharCode2) {
      CharCode2[CharCode2["Null"] = 0] = "Null";
      CharCode2[CharCode2["Backspace"] = 8] = "Backspace";
      CharCode2[CharCode2["Tab"] = 9] = "Tab";
      CharCode2[CharCode2["LineFeed"] = 10] = "LineFeed";
      CharCode2[CharCode2["CarriageReturn"] = 13] = "CarriageReturn";
      CharCode2[CharCode2["Space"] = 32] = "Space";
      CharCode2[CharCode2["ExclamationMark"] = 33] = "ExclamationMark";
      CharCode2[CharCode2["DoubleQuote"] = 34] = "DoubleQuote";
      CharCode2[CharCode2["Hash"] = 35] = "Hash";
      CharCode2[CharCode2["DollarSign"] = 36] = "DollarSign";
      CharCode2[CharCode2["PercentSign"] = 37] = "PercentSign";
      CharCode2[CharCode2["Ampersand"] = 38] = "Ampersand";
      CharCode2[CharCode2["SingleQuote"] = 39] = "SingleQuote";
      CharCode2[CharCode2["OpenParen"] = 40] = "OpenParen";
      CharCode2[CharCode2["CloseParen"] = 41] = "CloseParen";
      CharCode2[CharCode2["Asterisk"] = 42] = "Asterisk";
      CharCode2[CharCode2["Plus"] = 43] = "Plus";
      CharCode2[CharCode2["Comma"] = 44] = "Comma";
      CharCode2[CharCode2["Dash"] = 45] = "Dash";
      CharCode2[CharCode2["Period"] = 46] = "Period";
      CharCode2[CharCode2["Slash"] = 47] = "Slash";
      CharCode2[CharCode2["Digit0"] = 48] = "Digit0";
      CharCode2[CharCode2["Digit1"] = 49] = "Digit1";
      CharCode2[CharCode2["Digit2"] = 50] = "Digit2";
      CharCode2[CharCode2["Digit3"] = 51] = "Digit3";
      CharCode2[CharCode2["Digit4"] = 52] = "Digit4";
      CharCode2[CharCode2["Digit5"] = 53] = "Digit5";
      CharCode2[CharCode2["Digit6"] = 54] = "Digit6";
      CharCode2[CharCode2["Digit7"] = 55] = "Digit7";
      CharCode2[CharCode2["Digit8"] = 56] = "Digit8";
      CharCode2[CharCode2["Digit9"] = 57] = "Digit9";
      CharCode2[CharCode2["Colon"] = 58] = "Colon";
      CharCode2[CharCode2["Semicolon"] = 59] = "Semicolon";
      CharCode2[CharCode2["LessThan"] = 60] = "LessThan";
      CharCode2[CharCode2["Equals"] = 61] = "Equals";
      CharCode2[CharCode2["GreaterThan"] = 62] = "GreaterThan";
      CharCode2[CharCode2["QuestionMark"] = 63] = "QuestionMark";
      CharCode2[CharCode2["AtSign"] = 64] = "AtSign";
      CharCode2[CharCode2["A"] = 65] = "A";
      CharCode2[CharCode2["B"] = 66] = "B";
      CharCode2[CharCode2["C"] = 67] = "C";
      CharCode2[CharCode2["D"] = 68] = "D";
      CharCode2[CharCode2["E"] = 69] = "E";
      CharCode2[CharCode2["F"] = 70] = "F";
      CharCode2[CharCode2["G"] = 71] = "G";
      CharCode2[CharCode2["H"] = 72] = "H";
      CharCode2[CharCode2["I"] = 73] = "I";
      CharCode2[CharCode2["J"] = 74] = "J";
      CharCode2[CharCode2["K"] = 75] = "K";
      CharCode2[CharCode2["L"] = 76] = "L";
      CharCode2[CharCode2["M"] = 77] = "M";
      CharCode2[CharCode2["N"] = 78] = "N";
      CharCode2[CharCode2["O"] = 79] = "O";
      CharCode2[CharCode2["P"] = 80] = "P";
      CharCode2[CharCode2["Q"] = 81] = "Q";
      CharCode2[CharCode2["R"] = 82] = "R";
      CharCode2[CharCode2["S"] = 83] = "S";
      CharCode2[CharCode2["T"] = 84] = "T";
      CharCode2[CharCode2["U"] = 85] = "U";
      CharCode2[CharCode2["V"] = 86] = "V";
      CharCode2[CharCode2["W"] = 87] = "W";
      CharCode2[CharCode2["X"] = 88] = "X";
      CharCode2[CharCode2["Y"] = 89] = "Y";
      CharCode2[CharCode2["Z"] = 90] = "Z";
      CharCode2[CharCode2["OpenSquareBracket"] = 91] = "OpenSquareBracket";
      CharCode2[CharCode2["Backslash"] = 92] = "Backslash";
      CharCode2[CharCode2["CloseSquareBracket"] = 93] = "CloseSquareBracket";
      CharCode2[CharCode2["Caret"] = 94] = "Caret";
      CharCode2[CharCode2["Underline"] = 95] = "Underline";
      CharCode2[CharCode2["BackTick"] = 96] = "BackTick";
      CharCode2[CharCode2["a"] = 97] = "a";
      CharCode2[CharCode2["b"] = 98] = "b";
      CharCode2[CharCode2["c"] = 99] = "c";
      CharCode2[CharCode2["d"] = 100] = "d";
      CharCode2[CharCode2["e"] = 101] = "e";
      CharCode2[CharCode2["f"] = 102] = "f";
      CharCode2[CharCode2["g"] = 103] = "g";
      CharCode2[CharCode2["h"] = 104] = "h";
      CharCode2[CharCode2["i"] = 105] = "i";
      CharCode2[CharCode2["j"] = 106] = "j";
      CharCode2[CharCode2["k"] = 107] = "k";
      CharCode2[CharCode2["l"] = 108] = "l";
      CharCode2[CharCode2["m"] = 109] = "m";
      CharCode2[CharCode2["n"] = 110] = "n";
      CharCode2[CharCode2["o"] = 111] = "o";
      CharCode2[CharCode2["p"] = 112] = "p";
      CharCode2[CharCode2["q"] = 113] = "q";
      CharCode2[CharCode2["r"] = 114] = "r";
      CharCode2[CharCode2["s"] = 115] = "s";
      CharCode2[CharCode2["t"] = 116] = "t";
      CharCode2[CharCode2["u"] = 117] = "u";
      CharCode2[CharCode2["v"] = 118] = "v";
      CharCode2[CharCode2["w"] = 119] = "w";
      CharCode2[CharCode2["x"] = 120] = "x";
      CharCode2[CharCode2["y"] = 121] = "y";
      CharCode2[CharCode2["z"] = 122] = "z";
      CharCode2[CharCode2["OpenCurlyBrace"] = 123] = "OpenCurlyBrace";
      CharCode2[CharCode2["Pipe"] = 124] = "Pipe";
      CharCode2[CharCode2["CloseCurlyBrace"] = 125] = "CloseCurlyBrace";
      CharCode2[CharCode2["Tilde"] = 126] = "Tilde";
      CharCode2[CharCode2["U_Combining_Grave_Accent"] = 768] = "U_Combining_Grave_Accent";
      CharCode2[CharCode2["U_Combining_Acute_Accent"] = 769] = "U_Combining_Acute_Accent";
      CharCode2[CharCode2["U_Combining_Circumflex_Accent"] = 770] = "U_Combining_Circumflex_Accent";
      CharCode2[CharCode2["U_Combining_Tilde"] = 771] = "U_Combining_Tilde";
      CharCode2[CharCode2["U_Combining_Macron"] = 772] = "U_Combining_Macron";
      CharCode2[CharCode2["U_Combining_Overline"] = 773] = "U_Combining_Overline";
      CharCode2[CharCode2["U_Combining_Breve"] = 774] = "U_Combining_Breve";
      CharCode2[CharCode2["U_Combining_Dot_Above"] = 775] = "U_Combining_Dot_Above";
      CharCode2[CharCode2["U_Combining_Diaeresis"] = 776] = "U_Combining_Diaeresis";
      CharCode2[CharCode2["U_Combining_Hook_Above"] = 777] = "U_Combining_Hook_Above";
      CharCode2[CharCode2["U_Combining_Ring_Above"] = 778] = "U_Combining_Ring_Above";
      CharCode2[CharCode2["U_Combining_Double_Acute_Accent"] = 779] = "U_Combining_Double_Acute_Accent";
      CharCode2[CharCode2["U_Combining_Caron"] = 780] = "U_Combining_Caron";
      CharCode2[CharCode2["U_Combining_Vertical_Line_Above"] = 781] = "U_Combining_Vertical_Line_Above";
      CharCode2[CharCode2["U_Combining_Double_Vertical_Line_Above"] = 782] = "U_Combining_Double_Vertical_Line_Above";
      CharCode2[CharCode2["U_Combining_Double_Grave_Accent"] = 783] = "U_Combining_Double_Grave_Accent";
      CharCode2[CharCode2["U_Combining_Candrabindu"] = 784] = "U_Combining_Candrabindu";
      CharCode2[CharCode2["U_Combining_Inverted_Breve"] = 785] = "U_Combining_Inverted_Breve";
      CharCode2[CharCode2["U_Combining_Turned_Comma_Above"] = 786] = "U_Combining_Turned_Comma_Above";
      CharCode2[CharCode2["U_Combining_Comma_Above"] = 787] = "U_Combining_Comma_Above";
      CharCode2[CharCode2["U_Combining_Reversed_Comma_Above"] = 788] = "U_Combining_Reversed_Comma_Above";
      CharCode2[CharCode2["U_Combining_Comma_Above_Right"] = 789] = "U_Combining_Comma_Above_Right";
      CharCode2[CharCode2["U_Combining_Grave_Accent_Below"] = 790] = "U_Combining_Grave_Accent_Below";
      CharCode2[CharCode2["U_Combining_Acute_Accent_Below"] = 791] = "U_Combining_Acute_Accent_Below";
      CharCode2[CharCode2["U_Combining_Left_Tack_Below"] = 792] = "U_Combining_Left_Tack_Below";
      CharCode2[CharCode2["U_Combining_Right_Tack_Below"] = 793] = "U_Combining_Right_Tack_Below";
      CharCode2[CharCode2["U_Combining_Left_Angle_Above"] = 794] = "U_Combining_Left_Angle_Above";
      CharCode2[CharCode2["U_Combining_Horn"] = 795] = "U_Combining_Horn";
      CharCode2[CharCode2["U_Combining_Left_Half_Ring_Below"] = 796] = "U_Combining_Left_Half_Ring_Below";
      CharCode2[CharCode2["U_Combining_Up_Tack_Below"] = 797] = "U_Combining_Up_Tack_Below";
      CharCode2[CharCode2["U_Combining_Down_Tack_Below"] = 798] = "U_Combining_Down_Tack_Below";
      CharCode2[CharCode2["U_Combining_Plus_Sign_Below"] = 799] = "U_Combining_Plus_Sign_Below";
      CharCode2[CharCode2["U_Combining_Minus_Sign_Below"] = 800] = "U_Combining_Minus_Sign_Below";
      CharCode2[CharCode2["U_Combining_Palatalized_Hook_Below"] = 801] = "U_Combining_Palatalized_Hook_Below";
      CharCode2[CharCode2["U_Combining_Retroflex_Hook_Below"] = 802] = "U_Combining_Retroflex_Hook_Below";
      CharCode2[CharCode2["U_Combining_Dot_Below"] = 803] = "U_Combining_Dot_Below";
      CharCode2[CharCode2["U_Combining_Diaeresis_Below"] = 804] = "U_Combining_Diaeresis_Below";
      CharCode2[CharCode2["U_Combining_Ring_Below"] = 805] = "U_Combining_Ring_Below";
      CharCode2[CharCode2["U_Combining_Comma_Below"] = 806] = "U_Combining_Comma_Below";
      CharCode2[CharCode2["U_Combining_Cedilla"] = 807] = "U_Combining_Cedilla";
      CharCode2[CharCode2["U_Combining_Ogonek"] = 808] = "U_Combining_Ogonek";
      CharCode2[CharCode2["U_Combining_Vertical_Line_Below"] = 809] = "U_Combining_Vertical_Line_Below";
      CharCode2[CharCode2["U_Combining_Bridge_Below"] = 810] = "U_Combining_Bridge_Below";
      CharCode2[CharCode2["U_Combining_Inverted_Double_Arch_Below"] = 811] = "U_Combining_Inverted_Double_Arch_Below";
      CharCode2[CharCode2["U_Combining_Caron_Below"] = 812] = "U_Combining_Caron_Below";
      CharCode2[CharCode2["U_Combining_Circumflex_Accent_Below"] = 813] = "U_Combining_Circumflex_Accent_Below";
      CharCode2[CharCode2["U_Combining_Breve_Below"] = 814] = "U_Combining_Breve_Below";
      CharCode2[CharCode2["U_Combining_Inverted_Breve_Below"] = 815] = "U_Combining_Inverted_Breve_Below";
      CharCode2[CharCode2["U_Combining_Tilde_Below"] = 816] = "U_Combining_Tilde_Below";
      CharCode2[CharCode2["U_Combining_Macron_Below"] = 817] = "U_Combining_Macron_Below";
      CharCode2[CharCode2["U_Combining_Low_Line"] = 818] = "U_Combining_Low_Line";
      CharCode2[CharCode2["U_Combining_Double_Low_Line"] = 819] = "U_Combining_Double_Low_Line";
      CharCode2[CharCode2["U_Combining_Tilde_Overlay"] = 820] = "U_Combining_Tilde_Overlay";
      CharCode2[CharCode2["U_Combining_Short_Stroke_Overlay"] = 821] = "U_Combining_Short_Stroke_Overlay";
      CharCode2[CharCode2["U_Combining_Long_Stroke_Overlay"] = 822] = "U_Combining_Long_Stroke_Overlay";
      CharCode2[CharCode2["U_Combining_Short_Solidus_Overlay"] = 823] = "U_Combining_Short_Solidus_Overlay";
      CharCode2[CharCode2["U_Combining_Long_Solidus_Overlay"] = 824] = "U_Combining_Long_Solidus_Overlay";
      CharCode2[CharCode2["U_Combining_Right_Half_Ring_Below"] = 825] = "U_Combining_Right_Half_Ring_Below";
      CharCode2[CharCode2["U_Combining_Inverted_Bridge_Below"] = 826] = "U_Combining_Inverted_Bridge_Below";
      CharCode2[CharCode2["U_Combining_Square_Below"] = 827] = "U_Combining_Square_Below";
      CharCode2[CharCode2["U_Combining_Seagull_Below"] = 828] = "U_Combining_Seagull_Below";
      CharCode2[CharCode2["U_Combining_X_Above"] = 829] = "U_Combining_X_Above";
      CharCode2[CharCode2["U_Combining_Vertical_Tilde"] = 830] = "U_Combining_Vertical_Tilde";
      CharCode2[CharCode2["U_Combining_Double_Overline"] = 831] = "U_Combining_Double_Overline";
      CharCode2[CharCode2["U_Combining_Grave_Tone_Mark"] = 832] = "U_Combining_Grave_Tone_Mark";
      CharCode2[CharCode2["U_Combining_Acute_Tone_Mark"] = 833] = "U_Combining_Acute_Tone_Mark";
      CharCode2[CharCode2["U_Combining_Greek_Perispomeni"] = 834] = "U_Combining_Greek_Perispomeni";
      CharCode2[CharCode2["U_Combining_Greek_Koronis"] = 835] = "U_Combining_Greek_Koronis";
      CharCode2[CharCode2["U_Combining_Greek_Dialytika_Tonos"] = 836] = "U_Combining_Greek_Dialytika_Tonos";
      CharCode2[CharCode2["U_Combining_Greek_Ypogegrammeni"] = 837] = "U_Combining_Greek_Ypogegrammeni";
      CharCode2[CharCode2["U_Combining_Bridge_Above"] = 838] = "U_Combining_Bridge_Above";
      CharCode2[CharCode2["U_Combining_Equals_Sign_Below"] = 839] = "U_Combining_Equals_Sign_Below";
      CharCode2[CharCode2["U_Combining_Double_Vertical_Line_Below"] = 840] = "U_Combining_Double_Vertical_Line_Below";
      CharCode2[CharCode2["U_Combining_Left_Angle_Below"] = 841] = "U_Combining_Left_Angle_Below";
      CharCode2[CharCode2["U_Combining_Not_Tilde_Above"] = 842] = "U_Combining_Not_Tilde_Above";
      CharCode2[CharCode2["U_Combining_Homothetic_Above"] = 843] = "U_Combining_Homothetic_Above";
      CharCode2[CharCode2["U_Combining_Almost_Equal_To_Above"] = 844] = "U_Combining_Almost_Equal_To_Above";
      CharCode2[CharCode2["U_Combining_Left_Right_Arrow_Below"] = 845] = "U_Combining_Left_Right_Arrow_Below";
      CharCode2[CharCode2["U_Combining_Upwards_Arrow_Below"] = 846] = "U_Combining_Upwards_Arrow_Below";
      CharCode2[CharCode2["U_Combining_Grapheme_Joiner"] = 847] = "U_Combining_Grapheme_Joiner";
      CharCode2[CharCode2["U_Combining_Right_Arrowhead_Above"] = 848] = "U_Combining_Right_Arrowhead_Above";
      CharCode2[CharCode2["U_Combining_Left_Half_Ring_Above"] = 849] = "U_Combining_Left_Half_Ring_Above";
      CharCode2[CharCode2["U_Combining_Fermata"] = 850] = "U_Combining_Fermata";
      CharCode2[CharCode2["U_Combining_X_Below"] = 851] = "U_Combining_X_Below";
      CharCode2[CharCode2["U_Combining_Left_Arrowhead_Below"] = 852] = "U_Combining_Left_Arrowhead_Below";
      CharCode2[CharCode2["U_Combining_Right_Arrowhead_Below"] = 853] = "U_Combining_Right_Arrowhead_Below";
      CharCode2[CharCode2["U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below"] = 854] = "U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below";
      CharCode2[CharCode2["U_Combining_Right_Half_Ring_Above"] = 855] = "U_Combining_Right_Half_Ring_Above";
      CharCode2[CharCode2["U_Combining_Dot_Above_Right"] = 856] = "U_Combining_Dot_Above_Right";
      CharCode2[CharCode2["U_Combining_Asterisk_Below"] = 857] = "U_Combining_Asterisk_Below";
      CharCode2[CharCode2["U_Combining_Double_Ring_Below"] = 858] = "U_Combining_Double_Ring_Below";
      CharCode2[CharCode2["U_Combining_Zigzag_Above"] = 859] = "U_Combining_Zigzag_Above";
      CharCode2[CharCode2["U_Combining_Double_Breve_Below"] = 860] = "U_Combining_Double_Breve_Below";
      CharCode2[CharCode2["U_Combining_Double_Breve"] = 861] = "U_Combining_Double_Breve";
      CharCode2[CharCode2["U_Combining_Double_Macron"] = 862] = "U_Combining_Double_Macron";
      CharCode2[CharCode2["U_Combining_Double_Macron_Below"] = 863] = "U_Combining_Double_Macron_Below";
      CharCode2[CharCode2["U_Combining_Double_Tilde"] = 864] = "U_Combining_Double_Tilde";
      CharCode2[CharCode2["U_Combining_Double_Inverted_Breve"] = 865] = "U_Combining_Double_Inverted_Breve";
      CharCode2[CharCode2["U_Combining_Double_Rightwards_Arrow_Below"] = 866] = "U_Combining_Double_Rightwards_Arrow_Below";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_A"] = 867] = "U_Combining_Latin_Small_Letter_A";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_E"] = 868] = "U_Combining_Latin_Small_Letter_E";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_I"] = 869] = "U_Combining_Latin_Small_Letter_I";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_O"] = 870] = "U_Combining_Latin_Small_Letter_O";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_U"] = 871] = "U_Combining_Latin_Small_Letter_U";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_C"] = 872] = "U_Combining_Latin_Small_Letter_C";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_D"] = 873] = "U_Combining_Latin_Small_Letter_D";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_H"] = 874] = "U_Combining_Latin_Small_Letter_H";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_M"] = 875] = "U_Combining_Latin_Small_Letter_M";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_R"] = 876] = "U_Combining_Latin_Small_Letter_R";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_T"] = 877] = "U_Combining_Latin_Small_Letter_T";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_V"] = 878] = "U_Combining_Latin_Small_Letter_V";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_X"] = 879] = "U_Combining_Latin_Small_Letter_X";
      CharCode2[CharCode2["LINE_SEPARATOR_2028"] = 8232] = "LINE_SEPARATOR_2028";
      CharCode2[CharCode2["U_CIRCUMFLEX"] = 94] = "U_CIRCUMFLEX";
      CharCode2[CharCode2["U_GRAVE_ACCENT"] = 96] = "U_GRAVE_ACCENT";
      CharCode2[CharCode2["U_DIAERESIS"] = 168] = "U_DIAERESIS";
      CharCode2[CharCode2["U_MACRON"] = 175] = "U_MACRON";
      CharCode2[CharCode2["U_ACUTE_ACCENT"] = 180] = "U_ACUTE_ACCENT";
      CharCode2[CharCode2["U_CEDILLA"] = 184] = "U_CEDILLA";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LEFT_ARROWHEAD"] = 706] = "U_MODIFIER_LETTER_LEFT_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_RIGHT_ARROWHEAD"] = 707] = "U_MODIFIER_LETTER_RIGHT_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_UP_ARROWHEAD"] = 708] = "U_MODIFIER_LETTER_UP_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_DOWN_ARROWHEAD"] = 709] = "U_MODIFIER_LETTER_DOWN_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING"] = 722] = "U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING";
      CharCode2[CharCode2["U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING"] = 723] = "U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING";
      CharCode2[CharCode2["U_MODIFIER_LETTER_UP_TACK"] = 724] = "U_MODIFIER_LETTER_UP_TACK";
      CharCode2[CharCode2["U_MODIFIER_LETTER_DOWN_TACK"] = 725] = "U_MODIFIER_LETTER_DOWN_TACK";
      CharCode2[CharCode2["U_MODIFIER_LETTER_PLUS_SIGN"] = 726] = "U_MODIFIER_LETTER_PLUS_SIGN";
      CharCode2[CharCode2["U_MODIFIER_LETTER_MINUS_SIGN"] = 727] = "U_MODIFIER_LETTER_MINUS_SIGN";
      CharCode2[CharCode2["U_BREVE"] = 728] = "U_BREVE";
      CharCode2[CharCode2["U_DOT_ABOVE"] = 729] = "U_DOT_ABOVE";
      CharCode2[CharCode2["U_RING_ABOVE"] = 730] = "U_RING_ABOVE";
      CharCode2[CharCode2["U_OGONEK"] = 731] = "U_OGONEK";
      CharCode2[CharCode2["U_SMALL_TILDE"] = 732] = "U_SMALL_TILDE";
      CharCode2[CharCode2["U_DOUBLE_ACUTE_ACCENT"] = 733] = "U_DOUBLE_ACUTE_ACCENT";
      CharCode2[CharCode2["U_MODIFIER_LETTER_RHOTIC_HOOK"] = 734] = "U_MODIFIER_LETTER_RHOTIC_HOOK";
      CharCode2[CharCode2["U_MODIFIER_LETTER_CROSS_ACCENT"] = 735] = "U_MODIFIER_LETTER_CROSS_ACCENT";
      CharCode2[CharCode2["U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR"] = 741] = "U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR";
      CharCode2[CharCode2["U_MODIFIER_LETTER_HIGH_TONE_BAR"] = 742] = "U_MODIFIER_LETTER_HIGH_TONE_BAR";
      CharCode2[CharCode2["U_MODIFIER_LETTER_MID_TONE_BAR"] = 743] = "U_MODIFIER_LETTER_MID_TONE_BAR";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_TONE_BAR"] = 744] = "U_MODIFIER_LETTER_LOW_TONE_BAR";
      CharCode2[CharCode2["U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR"] = 745] = "U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR";
      CharCode2[CharCode2["U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK"] = 746] = "U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK";
      CharCode2[CharCode2["U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK"] = 747] = "U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK";
      CharCode2[CharCode2["U_MODIFIER_LETTER_UNASPIRATED"] = 749] = "U_MODIFIER_LETTER_UNASPIRATED";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD"] = 751] = "U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_UP_ARROWHEAD"] = 752] = "U_MODIFIER_LETTER_LOW_UP_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD"] = 753] = "U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD"] = 754] = "U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_RING"] = 755] = "U_MODIFIER_LETTER_LOW_RING";
      CharCode2[CharCode2["U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT"] = 756] = "U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT";
      CharCode2[CharCode2["U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT"] = 757] = "U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT";
      CharCode2[CharCode2["U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT"] = 758] = "U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_TILDE"] = 759] = "U_MODIFIER_LETTER_LOW_TILDE";
      CharCode2[CharCode2["U_MODIFIER_LETTER_RAISED_COLON"] = 760] = "U_MODIFIER_LETTER_RAISED_COLON";
      CharCode2[CharCode2["U_MODIFIER_LETTER_BEGIN_HIGH_TONE"] = 761] = "U_MODIFIER_LETTER_BEGIN_HIGH_TONE";
      CharCode2[CharCode2["U_MODIFIER_LETTER_END_HIGH_TONE"] = 762] = "U_MODIFIER_LETTER_END_HIGH_TONE";
      CharCode2[CharCode2["U_MODIFIER_LETTER_BEGIN_LOW_TONE"] = 763] = "U_MODIFIER_LETTER_BEGIN_LOW_TONE";
      CharCode2[CharCode2["U_MODIFIER_LETTER_END_LOW_TONE"] = 764] = "U_MODIFIER_LETTER_END_LOW_TONE";
      CharCode2[CharCode2["U_MODIFIER_LETTER_SHELF"] = 765] = "U_MODIFIER_LETTER_SHELF";
      CharCode2[CharCode2["U_MODIFIER_LETTER_OPEN_SHELF"] = 766] = "U_MODIFIER_LETTER_OPEN_SHELF";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_LEFT_ARROW"] = 767] = "U_MODIFIER_LETTER_LOW_LEFT_ARROW";
      CharCode2[CharCode2["U_GREEK_LOWER_NUMERAL_SIGN"] = 885] = "U_GREEK_LOWER_NUMERAL_SIGN";
      CharCode2[CharCode2["U_GREEK_TONOS"] = 900] = "U_GREEK_TONOS";
      CharCode2[CharCode2["U_GREEK_DIALYTIKA_TONOS"] = 901] = "U_GREEK_DIALYTIKA_TONOS";
      CharCode2[CharCode2["U_GREEK_KORONIS"] = 8125] = "U_GREEK_KORONIS";
      CharCode2[CharCode2["U_GREEK_PSILI"] = 8127] = "U_GREEK_PSILI";
      CharCode2[CharCode2["U_GREEK_PERISPOMENI"] = 8128] = "U_GREEK_PERISPOMENI";
      CharCode2[CharCode2["U_GREEK_DIALYTIKA_AND_PERISPOMENI"] = 8129] = "U_GREEK_DIALYTIKA_AND_PERISPOMENI";
      CharCode2[CharCode2["U_GREEK_PSILI_AND_VARIA"] = 8141] = "U_GREEK_PSILI_AND_VARIA";
      CharCode2[CharCode2["U_GREEK_PSILI_AND_OXIA"] = 8142] = "U_GREEK_PSILI_AND_OXIA";
      CharCode2[CharCode2["U_GREEK_PSILI_AND_PERISPOMENI"] = 8143] = "U_GREEK_PSILI_AND_PERISPOMENI";
      CharCode2[CharCode2["U_GREEK_DASIA_AND_VARIA"] = 8157] = "U_GREEK_DASIA_AND_VARIA";
      CharCode2[CharCode2["U_GREEK_DASIA_AND_OXIA"] = 8158] = "U_GREEK_DASIA_AND_OXIA";
      CharCode2[CharCode2["U_GREEK_DASIA_AND_PERISPOMENI"] = 8159] = "U_GREEK_DASIA_AND_PERISPOMENI";
      CharCode2[CharCode2["U_GREEK_DIALYTIKA_AND_VARIA"] = 8173] = "U_GREEK_DIALYTIKA_AND_VARIA";
      CharCode2[CharCode2["U_GREEK_DIALYTIKA_AND_OXIA"] = 8174] = "U_GREEK_DIALYTIKA_AND_OXIA";
      CharCode2[CharCode2["U_GREEK_VARIA"] = 8175] = "U_GREEK_VARIA";
      CharCode2[CharCode2["U_GREEK_OXIA"] = 8189] = "U_GREEK_OXIA";
      CharCode2[CharCode2["U_GREEK_DASIA"] = 8190] = "U_GREEK_DASIA";
      CharCode2[CharCode2["U_OVERLINE"] = 8254] = "U_OVERLINE";
      CharCode2[CharCode2["UTF8_BOM"] = 65279] = "UTF8_BOM";
    })(CharCode || (CharCode = {}));
  }
});

// src/snippets/parser.ts
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
var logger31, TokenType, _Scanner, Scanner, Marker, Text, TransformableMarker, Placeholder, Choice, Transform, FormatString, Variable, TextmateSnippet, SnippetParser;
var init_parser2 = __esm({
  "src/snippets/parser.ts"() {
    init_charCode();
    init_string();
    logger31 = require_logger2()("snippets-parser");
    (function(TokenType2) {
      TokenType2[TokenType2["Dollar"] = 0] = "Dollar";
      TokenType2[TokenType2["Colon"] = 1] = "Colon";
      TokenType2[TokenType2["Comma"] = 2] = "Comma";
      TokenType2[TokenType2["CurlyOpen"] = 3] = "CurlyOpen";
      TokenType2[TokenType2["CurlyClose"] = 4] = "CurlyClose";
      TokenType2[TokenType2["Backslash"] = 5] = "Backslash";
      TokenType2[TokenType2["Forwardslash"] = 6] = "Forwardslash";
      TokenType2[TokenType2["Pipe"] = 7] = "Pipe";
      TokenType2[TokenType2["Int"] = 8] = "Int";
      TokenType2[TokenType2["VariableName"] = 9] = "VariableName";
      TokenType2[TokenType2["Format"] = 10] = "Format";
      TokenType2[TokenType2["Plus"] = 11] = "Plus";
      TokenType2[TokenType2["Dash"] = 12] = "Dash";
      TokenType2[TokenType2["QuestionMark"] = 13] = "QuestionMark";
      TokenType2[TokenType2["EOF"] = 14] = "EOF";
    })(TokenType || (TokenType = {}));
    _Scanner = class {
      static isDigitCharacter(ch) {
        return ch >= CharCode.Digit0 && ch <= CharCode.Digit9;
      }
      static isVariableCharacter(ch) {
        return ch === CharCode.Underline || ch >= CharCode.a && ch <= CharCode.z || ch >= CharCode.A && ch <= CharCode.Z;
      }
      constructor() {
        this.text("");
      }
      text(value) {
        this.value = value;
        this.pos = 0;
      }
      tokenText(token) {
        return this.value.substr(token.pos, token.len);
      }
      next() {
        if (this.pos >= this.value.length) {
          return { type: 14, pos: this.pos, len: 0 };
        }
        let pos = this.pos;
        let len = 0;
        let ch = this.value.charCodeAt(pos);
        let type;
        type = _Scanner._table[ch];
        if (typeof type === "number") {
          this.pos += 1;
          return { type, pos, len: 1 };
        }
        if (_Scanner.isDigitCharacter(ch)) {
          type = 8;
          do {
            len += 1;
            ch = this.value.charCodeAt(pos + len);
          } while (_Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        if (_Scanner.isVariableCharacter(ch)) {
          type = 9;
          do {
            ch = this.value.charCodeAt(pos + ++len);
          } while (_Scanner.isVariableCharacter(ch) || _Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        type = 10;
        do {
          len += 1;
          ch = this.value.charCodeAt(pos + len);
        } while (!isNaN(ch) && typeof _Scanner._table[ch] === "undefined" && !_Scanner.isDigitCharacter(ch) && !_Scanner.isVariableCharacter(ch));
        this.pos += len;
        return { type, pos, len };
      }
    };
    Scanner = _Scanner;
    Scanner._table = {
      [CharCode.DollarSign]: 0,
      [CharCode.Colon]: 1,
      [CharCode.Comma]: 2,
      [CharCode.OpenCurlyBrace]: 3,
      [CharCode.CloseCurlyBrace]: 4,
      [CharCode.Backslash]: 5,
      [CharCode.Slash]: 6,
      [CharCode.Pipe]: 7,
      [CharCode.Plus]: 11,
      [CharCode.Dash]: 12,
      [CharCode.QuestionMark]: 13
    };
    Marker = class {
      constructor() {
        this._children = [];
      }
      appendChild(child) {
        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
          this._children[this._children.length - 1].value += child.value;
        } else {
          child.parent = this;
          this._children.push(child);
        }
        return this;
      }
      setOnlyChild(child) {
        child.parent = this;
        this._children = [child];
      }
      replace(child, others) {
        const { parent } = child;
        const idx = parent.children.indexOf(child);
        const newChildren = parent.children.slice(0);
        newChildren.splice(idx, 1, ...others);
        parent._children = newChildren;
        (function _fixParent(children, parent2) {
          for (const child2 of children) {
            child2.parent = parent2;
            _fixParent(child2.children, child2);
          }
        })(others, parent);
      }
      get children() {
        return this._children;
      }
      get snippet() {
        let candidate = this;
        while (true) {
          if (!candidate) {
            return void 0;
          }
          if (candidate instanceof TextmateSnippet) {
            return candidate;
          }
          candidate = candidate.parent;
        }
      }
      toString() {
        return this.children.reduce((prev, cur) => prev + cur.toString(), "");
      }
      len() {
        return 0;
      }
      get next() {
        let { parent } = this;
        let { children } = parent;
        let idx = children.indexOf(this);
        return children[idx + 1];
      }
    };
    Text = class extends Marker {
      constructor(value) {
        super();
        this.value = value;
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      toString() {
        return this.value;
      }
      toTextmateString() {
        return Text.escape(this.value);
      }
      len() {
        return this.value.length;
      }
      clone() {
        return new Text(this.value);
      }
    };
    TransformableMarker = class extends Marker {
    };
    Placeholder = class extends TransformableMarker {
      constructor(index) {
        super();
        this.index = index;
      }
      static compareByIndex(a, b) {
        if (a.index === b.index) {
          return 0;
        } else if (a.isFinalTabstop) {
          return 1;
        } else if (b.isFinalTabstop) {
          return -1;
        } else if (a.index < b.index) {
          return -1;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return 0;
        }
      }
      get isFinalTabstop() {
        return this.index === 0;
      }
      get choice() {
        return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
      }
      toTextmateString() {
        let transformString = "";
        if (this.transform) {
          transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0 && !this.transform) {
          return `$${this.index}`;
        } else if (this.children.length === 0) {
          return `\${${this.index}${transformString}}`;
        } else if (this.choice) {
          return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
        } else {
          return `\${${this.index}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
        }
      }
      clone() {
        let ret = new Placeholder(this.index);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    Choice = class extends Marker {
      constructor() {
        super(...arguments);
        this.options = [];
      }
      appendChild(marker) {
        if (marker instanceof Text) {
          marker.parent = this;
          this.options.push(marker);
        }
        return this;
      }
      toString() {
        return this.options[0].value;
      }
      toTextmateString() {
        return this.options.map((option) => option.value.replace(/\||,/g, "\\$&")).join(",");
      }
      len() {
        return this.options[0].len();
      }
      clone() {
        let ret = new Choice();
        for (let opt of this.options) {
          ret.appendChild(opt);
        }
        return ret;
      }
    };
    Transform = class extends Marker {
      resolve(value) {
        let didMatch = false;
        let ret = value.replace(this.regexp, (...args) => {
          didMatch = true;
          return this._replace(args.slice(0, -2));
        });
        if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
          ret = this._replace([]);
        }
        return ret;
      }
      _replace(groups) {
        let ret = "";
        for (const marker of this._children) {
          if (marker instanceof FormatString) {
            let value = groups[marker.index] || "";
            value = marker.resolve(value);
            ret += value;
          } else {
            ret += marker.toString();
          }
        }
        return ret;
      }
      toString() {
        return "";
      }
      toTextmateString() {
        return `/${this.regexp.source}/${this.children.map((c) => c.toTextmateString())}/${(this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")}`;
      }
      clone() {
        let ret = new Transform();
        ret.regexp = new RegExp(this.regexp.source, "" + (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    FormatString = class extends Marker {
      constructor(index, shorthandName, ifValue, elseValue) {
        super();
        this.index = index;
        this.shorthandName = shorthandName;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
      }
      resolve(value) {
        if (this.shorthandName === "upcase") {
          return !value ? "" : value.toLocaleUpperCase();
        } else if (this.shorthandName === "downcase") {
          return !value ? "" : value.toLocaleLowerCase();
        } else if (this.shorthandName === "capitalize") {
          return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
        } else if (this.shorthandName === "pascalcase") {
          return !value ? "" : this._toPascalCase(value);
        } else if (Boolean(value) && typeof this.ifValue === "string") {
          return this.ifValue;
        } else if (!value && typeof this.elseValue === "string") {
          return this.elseValue;
        } else {
          return value || "";
        }
      }
      _toPascalCase(value) {
        const match = value.match(/[a-z]+/gi);
        if (!match) {
          return value;
        }
        return match.map((word) => word.charAt(0).toUpperCase() + word.substr(1).toLowerCase()).join("");
      }
      toTextmateString() {
        let value = "${";
        value += this.index;
        if (this.shorthandName) {
          value += `:/${this.shorthandName}`;
        } else if (this.ifValue && this.elseValue) {
          value += `:?${this.ifValue}:${this.elseValue}`;
        } else if (this.ifValue) {
          value += `:+${this.ifValue}`;
        } else if (this.elseValue) {
          value += `:-${this.elseValue}`;
        }
        value += "}";
        return value;
      }
      clone() {
        let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
        return ret;
      }
    };
    Variable = class extends TransformableMarker {
      constructor(name2) {
        super();
        this.name = name2;
      }
      async resolve(resolver) {
        let value = await resolver.resolve(this);
        if (value && value.includes("\n")) {
          let indent = "";
          this.snippet.walk((m) => {
            if (m == this) {
              return false;
            }
            if (m instanceof Text) {
              let lines2 = m.toString().split(/\r?\n/);
              indent = lines2[lines2.length - 1].match(/^\s*/)[0];
            }
            return true;
          });
          let lines = value.split("\n");
          let indents = lines.filter((s) => s.length > 0).map((s) => s.match(/^\s*/)[0]);
          let minIndent = indents.length == 0 ? "" : indents.reduce((p, c) => p.length < c.length ? p : c);
          let newLines = lines.map((s, i) => i == 0 || s.length == 0 || !s.startsWith(minIndent) ? s : indent + s.slice(minIndent.length));
          value = newLines.join("\n");
        }
        if (this.transform) {
          value = this.transform.resolve(value || "");
        }
        if (value !== void 0) {
          this._children = [new Text(value)];
          return true;
        }
        return false;
      }
      toTextmateString() {
        let transformString = "";
        if (this.transform) {
          transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0) {
          return `\${${this.name}${transformString}}`;
        } else {
          return `\${${this.name}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
        }
      }
      clone() {
        const ret = new Variable(this.name);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    TextmateSnippet = class extends Marker {
      get placeholderInfo() {
        if (!this._placeholders) {
          this._variables = [];
          let all = [];
          let last;
          this.walk((candidate) => {
            if (candidate instanceof Placeholder) {
              all.push(candidate);
              last = !last || last.index < candidate.index ? candidate : last;
            } else if (candidate instanceof Variable) {
              let first = candidate.name.charCodeAt(0);
              if (first < 65 || first > 90) {
                this._variables.push(candidate);
              }
            }
            return true;
          });
          this._placeholders = { all, last };
        }
        return this._placeholders;
      }
      get variables() {
        return this._variables;
      }
      get placeholders() {
        const { all } = this.placeholderInfo;
        return all;
      }
      get maxIndexNumber() {
        let { placeholders } = this;
        return placeholders.reduce((curr, p) => Math.max(curr, p.index), 0);
      }
      get minIndexNumber() {
        let { placeholders } = this;
        let nums = placeholders.map((p) => p.index);
        nums.sort((a, b) => a - b);
        if (nums.length > 1 && nums[0] == 0)
          return nums[1];
        return nums[0] || 0;
      }
      insertSnippet(snippet, id, range) {
        let placeholder = this.placeholders[id];
        if (!placeholder)
          return;
        let { index } = placeholder;
        let [before, after] = rangeParts(placeholder.toString(), range);
        let nested = new SnippetParser().parse(snippet, true);
        let maxIndexAdded = nested.maxIndexNumber + 1;
        let indexes = [];
        for (let p of nested.placeholders) {
          if (p.isFinalTabstop) {
            p.index = maxIndexAdded + index;
          } else {
            p.index = p.index + index;
          }
          indexes.push(p.index);
        }
        this.walk((m) => {
          if (m instanceof Placeholder && m.index > index) {
            m.index = m.index + maxIndexAdded;
          }
          return true;
        });
        let children = nested.children;
        if (before)
          children.unshift(new Text(before));
        if (after)
          children.push(new Text(after));
        this.replace(placeholder, children);
        return Math.min.apply(null, indexes);
      }
      updatePlaceholder(id, val) {
        const placeholder = this.placeholders[id];
        for (let p of this.placeholders) {
          if (p.index == placeholder.index) {
            let child = p.children[0];
            let newText = p.transform ? p.transform.resolve(val) : val;
            if (child) {
              p.setOnlyChild(new Text(newText));
            } else {
              p.appendChild(new Text(newText));
            }
          }
        }
        this._placeholders = void 0;
      }
      updateVariable(id, val) {
        const find = this.variables[id - this.maxIndexNumber - 1];
        if (find) {
          let variables = this.variables.filter((o) => o.name == find.name);
          for (let variable of variables) {
            let newText = variable.transform ? variable.transform.resolve(val) : val;
            variable.setOnlyChild(new Text(newText));
          }
        }
      }
      getPlaceholderText(id, value) {
        const placeholder = this.placeholders[id];
        if (!placeholder)
          return value;
        return placeholder.transform ? placeholder.transform.resolve(value) : value;
      }
      offset(marker) {
        let pos = 0;
        let found = false;
        this.walk((candidate) => {
          if (candidate === marker) {
            found = true;
            return false;
          }
          pos += candidate.len();
          return true;
        });
        if (!found) {
          return -1;
        }
        return pos;
      }
      fullLen(marker) {
        let ret = 0;
        walk([marker], (marker2) => {
          ret += marker2.len();
          return true;
        });
        return ret;
      }
      enclosingPlaceholders(placeholder) {
        let ret = [];
        let { parent } = placeholder;
        while (parent) {
          if (parent instanceof Placeholder) {
            ret.push(parent);
          }
          parent = parent.parent;
        }
        return ret;
      }
      async resolveVariables(resolver) {
        let items = [];
        this.walk((candidate) => {
          if (candidate instanceof Variable) {
            items.push(candidate);
          }
          return true;
        });
        await Promise.all(items.map((o) => o.resolve(resolver)));
      }
      appendChild(child) {
        this._placeholders = void 0;
        return super.appendChild(child);
      }
      replace(child, others) {
        this._placeholders = void 0;
        return super.replace(child, others);
      }
      toTextmateString() {
        return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), "");
      }
      clone() {
        let ret = new TextmateSnippet();
        this._children = this.children.map((child) => child.clone());
        return ret;
      }
      walk(visitor) {
        walk(this.children, visitor);
      }
    };
    SnippetParser = class {
      constructor() {
        this._scanner = new Scanner();
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      text(value) {
        return this.parse(value).toString();
      }
      parse(value, insertFinalTabstop) {
        this._scanner.text(value);
        this._token = this._scanner.next();
        const snippet = new TextmateSnippet();
        while (this._parse(snippet)) {
        }
        const placeholderDefaultValues = new Map();
        const incompletePlaceholders = [];
        snippet.walk((marker) => {
          if (marker instanceof Placeholder) {
            if (marker.isFinalTabstop) {
              placeholderDefaultValues.set(0, void 0);
            } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
              placeholderDefaultValues.set(marker.index, marker.children);
            } else {
              incompletePlaceholders.push(marker);
            }
          }
          return true;
        });
        for (const placeholder of incompletePlaceholders) {
          if (placeholderDefaultValues.has(placeholder.index)) {
            const clone = new Placeholder(placeholder.index);
            clone.transform = placeholder.transform;
            for (const child of placeholderDefaultValues.get(placeholder.index)) {
              let marker = child.clone();
              if (clone.transform) {
                if (marker instanceof Text) {
                  marker = new Text(clone.transform.resolve(marker.value));
                } else {
                  for (let child2 of marker.children) {
                    if (child2 instanceof Text) {
                      marker.replace(child2, [new Text(clone.transform.resolve(child2.value))]);
                      break;
                    }
                  }
                }
              }
              clone.appendChild(marker);
            }
            snippet.replace(placeholder, [clone]);
          }
        }
        if (!placeholderDefaultValues.has(0) && insertFinalTabstop) {
          snippet.appendChild(new Placeholder(0));
        }
        return snippet;
      }
      _accept(type, value) {
        if (type === void 0 || this._token.type === type) {
          let ret = !value ? true : this._scanner.tokenText(this._token);
          this._token = this._scanner.next();
          return ret;
        }
        return false;
      }
      _backTo(token) {
        this._scanner.pos = token.pos + token.len;
        this._token = token;
        return false;
      }
      _until(type) {
        if (this._token.type === 14) {
          return false;
        }
        let start = this._token;
        while (this._token.type !== type) {
          this._token = this._scanner.next();
          if (this._token.type === 14) {
            return false;
          }
        }
        let value = this._scanner.value.substring(start.pos, this._token.pos);
        this._token = this._scanner.next();
        return value;
      }
      _parse(marker) {
        return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
      }
      _parseEscaped(marker) {
        let value;
        if (value = this._accept(5, true)) {
          value = this._accept(0, true) || this._accept(4, true) || this._accept(5, true) || value;
          marker.appendChild(new Text(value));
          return true;
        }
        return false;
      }
      _parseTabstopOrVariableName(parent) {
        let value;
        const token = this._token;
        const match = this._accept(0) && (value = this._accept(9, true) || this._accept(8, true));
        if (!match) {
          return this._backTo(token);
        }
        parent.appendChild(/^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));
        return true;
      }
      _parseComplexPlaceholder(parent) {
        let index;
        const token = this._token;
        const match = this._accept(0) && this._accept(3) && (index = this._accept(8, true));
        if (!match) {
          return this._backTo(token);
        }
        const placeholder = new Placeholder(Number(index));
        if (this._accept(1)) {
          while (true) {
            if (this._accept(4)) {
              parent.appendChild(placeholder);
              return true;
            }
            if (this._parse(placeholder)) {
              continue;
            }
            parent.appendChild(new Text("${" + index + ":"));
            placeholder.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (placeholder.index > 0 && this._accept(7)) {
          const choice = new Choice();
          while (true) {
            if (this._parseChoiceElement(choice)) {
              if (this._accept(2)) {
                continue;
              }
              if (this._accept(7)) {
                placeholder.appendChild(choice);
                if (this._accept(4)) {
                  parent.appendChild(placeholder);
                  return true;
                }
              }
            }
            this._backTo(token);
            return false;
          }
        } else if (this._accept(6)) {
          if (this._parseTransform(placeholder)) {
            parent.appendChild(placeholder);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(4)) {
          parent.appendChild(placeholder);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseChoiceElement(parent) {
        const token = this._token;
        const values = [];
        while (true) {
          if (this._token.type === 2 || this._token.type === 7) {
            break;
          }
          let value;
          if (value = this._accept(5, true)) {
            value = this._accept(2, true) || this._accept(7, true) || this._accept(5, true) || value;
          } else {
            value = this._accept(void 0, true);
          }
          if (!value) {
            this._backTo(token);
            return false;
          }
          values.push(value);
        }
        if (values.length === 0) {
          this._backTo(token);
          return false;
        }
        parent.appendChild(new Text(values.join("")));
        return true;
      }
      _parseComplexVariable(parent) {
        let name2;
        const token = this._token;
        const match = this._accept(0) && this._accept(3) && (name2 = this._accept(9, true));
        if (!match) {
          return this._backTo(token);
        }
        const variable = new Variable(name2);
        if (this._accept(1)) {
          while (true) {
            if (this._accept(4)) {
              parent.appendChild(variable);
              return true;
            }
            if (this._parse(variable)) {
              continue;
            }
            parent.appendChild(new Text("${" + name2 + ":"));
            variable.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (this._accept(6)) {
          if (this._parseTransform(variable)) {
            parent.appendChild(variable);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(4)) {
          parent.appendChild(variable);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseTransform(parent) {
        let transform = new Transform();
        let regexValue = "";
        let regexOptions = "";
        while (true) {
          if (this._accept(6)) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5, true)) {
            escaped = this._accept(6, true) || escaped;
            regexValue += escaped;
            continue;
          }
          if (this._token.type !== 14) {
            regexValue += this._accept(void 0, true);
            continue;
          }
          return false;
        }
        while (true) {
          if (this._accept(6)) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5, true)) {
            escaped = this._accept(6, true) || escaped;
            transform.appendChild(new Text(escaped));
            continue;
          }
          if (this._parseFormatString(transform) || this._parseAnything(transform)) {
            let text = transform.children[0];
            if (text && text.value && text.value.includes("\\n")) {
              text.value = text.value.replace(/\\n/g, "\n");
            }
            continue;
          }
          return false;
        }
        while (true) {
          if (this._accept(4)) {
            break;
          }
          if (this._token.type !== 14) {
            regexOptions += this._accept(void 0, true);
            continue;
          }
          return false;
        }
        try {
          transform.regexp = new RegExp(regexValue, regexOptions);
        } catch (e) {
          return false;
        }
        parent.transform = transform;
        return true;
      }
      _parseFormatString(parent) {
        const token = this._token;
        if (!this._accept(0)) {
          return false;
        }
        let complex = false;
        if (this._accept(3)) {
          complex = true;
        }
        let index = this._accept(8, true);
        if (!index) {
          this._backTo(token);
          return false;
        } else if (!complex) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (this._accept(4)) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (!this._accept(1)) {
          this._backTo(token);
          return false;
        }
        if (this._accept(6)) {
          let shorthand = this._accept(9, true);
          if (!shorthand || !this._accept(4)) {
            this._backTo(token);
            return false;
          } else {
            parent.appendChild(new FormatString(Number(index), shorthand));
            return true;
          }
        } else if (this._accept(11)) {
          let ifValue = this._until(4);
          if (ifValue) {
            parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
            return true;
          }
        } else if (this._accept(12)) {
          let elseValue = this._until(4);
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        } else if (this._accept(13)) {
          let ifValue = this._until(1);
          if (ifValue) {
            let elseValue = this._until(4);
            if (elseValue) {
              parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
              return true;
            }
          }
        } else {
          let elseValue = this._until(4);
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        }
        this._backTo(token);
        return false;
      }
      _parseAnything(marker) {
        if (this._token.type !== 14) {
          let text = this._scanner.tokenText(this._token);
          marker.appendChild(new Text(text));
          this._accept(void 0);
          return true;
        }
        return false;
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name2, value, isGlobal) => {
      const index = R++;
      debug(index, value);
      t[name2] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
      options2[k] = true;
      return options2;
    }, {});
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    var { MAX_LENGTH } = require_constants();
    var { re, t } = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse5 = (version2, options) => {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse5;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse5 = require_parse();
    var valid = (version2, options) => {
      const v = parse5(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse5 = require_parse();
    var clean = (version2, options) => {
      const s = parse5(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version2, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/diff.js
var require_diff2 = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse5 = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v12 = parse5(version1);
        const v2 = parse5(version2);
        const hasPre = v12.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v12) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v12[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse5 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse5(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list2, loose) => list2.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list2, loose) => list2.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse5 = require_parse();
    var { re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null)
        return null;
      return parse5(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list2) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list2 && typeof list2.forEach === "function") {
        list2.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list2) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list2);
      }
      this.list = list2;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    var Range39 = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range39) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range39(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached;
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range, re[t.COMPARATORTRIM]);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
        const l = rangeList.length;
        const rangeMap = new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp];
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(""))
          rangeMap.delete("");
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range39)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range39;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range39(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range39(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range39 = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range39 = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range39(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range39 = require_range();
    var toComparators = (range, options) => new Range39(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range39 = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range39(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range39 = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range39(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range39 = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range39(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin)))
          minver = setMin;
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range39 = require_range();
    var validRange = (range, options) => {
      try {
        return new Range39(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range39 = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range39(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range39 = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range39(r1, options);
      r2 = new Range39(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!min)
            min = version2;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range39 = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom)
        return true;
      sub = new Range39(sub, options);
      dom = new Range39(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom)
        return true;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true;
        else if (options.includePrerelease)
          sub = [new Comparator(">=0.0.0-0")];
        else
          sub = [new Comparator(">=0.0.0")];
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease)
          return true;
        else
          dom = [new Comparator(">=0.0.0")];
      }
      const eqSet = new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null;
        if (lt && !satisfies(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      if (needDomGTPre || needDomLTPre)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff2(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// src/model/installBuffer.ts
var import_events16, logger32, State, InstallBuffer;
var init_installBuffer = __esm({
  "src/model/installBuffer.ts"() {
    import_events16 = __toModule(require("events"));
    init_status();
    logger32 = require_logger2()("model-installBuffer");
    (function(State3) {
      State3[State3["Waiting"] = 0] = "Waiting";
      State3[State3["Faild"] = 1] = "Faild";
      State3[State3["Progressing"] = 2] = "Progressing";
      State3[State3["Success"] = 3] = "Success";
    })(State || (State = {}));
    InstallBuffer = class extends import_events16.EventEmitter {
      constructor(isUpdate = false, isSync = false, channel = void 0) {
        super();
        this.isUpdate = isUpdate;
        this.isSync = isSync;
        this.channel = channel;
        this.statMap = new Map();
        this.messagesMap = new Map();
        this.names = [];
      }
      setExtensions(names) {
        this.statMap.clear();
        this.names = names;
        for (let name2 of names) {
          this.statMap.set(name2, 0);
        }
      }
      addMessage(name2, msg, isProgress = false) {
        if (isProgress && this.channel)
          return;
        let lines = this.messagesMap.get(name2) || [];
        this.messagesMap.set(name2, lines.concat(msg.trim().split(/\r?\n/)));
        if (this.channel)
          this.channel.appendLine(`[${name2}] ${msg}`);
      }
      startProgress(names) {
        for (let name2 of names) {
          this.statMap.set(name2, 2);
        }
      }
      finishProgress(name2, succeed = true) {
        if (this.channel) {
          if (succeed) {
            this.channel.appendLine(`[${name2}] install succeed!`);
          } else {
            this.channel.appendLine(`[${name2}] install failed!`);
          }
        }
        this.statMap.set(name2, succeed ? 3 : 1);
      }
      get remains() {
        let count = 0;
        for (let name2 of this.names) {
          let stat = this.statMap.get(name2);
          if (![3, 1].includes(stat)) {
            count = count + 1;
          }
        }
        return count;
      }
      getLines() {
        let lines = [];
        for (let name2 of this.names) {
          let state = this.statMap.get(name2);
          let processText = "*";
          switch (state) {
            case 2: {
              let d = new Date();
              let idx = Math.floor(d.getMilliseconds() / 100);
              processText = frames[idx];
              break;
            }
            case 1:
              processText = "\u2717";
              break;
            case 3:
              processText = "\u2713";
              break;
          }
          let msgs = this.messagesMap.get(name2) || [];
          lines.push(`- ${processText} ${name2} ${msgs.length ? msgs[msgs.length - 1] : ""}`);
        }
        return lines;
      }
      getMessages(line) {
        if (line <= 1)
          return [];
        let name2 = this.names[line - 2];
        if (!name2)
          return [];
        return this.messagesMap.get(name2);
      }
      draw(nvim, buffer) {
        let { remains } = this;
        let first = remains == 0 ? `${this.isUpdate ? "Update" : "Install"} finished` : `Installing, ${remains} remains...`;
        let lines = [first, "", ...this.getLines()];
        buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false }, true);
        if (remains == 0 && this.interval) {
          clearInterval(this.interval);
          this.interval = null;
        }
        if (process.env.VIM_NODE_RPC) {
          nvim.command("redraw", true);
        }
      }
      highlight(nvim) {
        nvim.call("matchadd", ["CocListFgCyan", "^\\-\\s\\zs\\*"], true);
        nvim.call("matchadd", ["CocListFgGreen", "^\\-\\s\\zs\u2713"], true);
        nvim.call("matchadd", ["CocListFgRed", "^\\-\\s\\zs\u2717"], true);
        nvim.call("matchadd", ["CocListFgYellow", "^-.\\{3\\}\\zs\\S\\+"], true);
      }
      async show(nvim) {
        let { isSync } = this;
        if (this.channel)
          return;
        nvim.pauseNotification();
        nvim.command(isSync ? "enew" : "vs +enew", true);
        nvim.call("bufnr", ["%"], true);
        nvim.command("setl buftype=nofile bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1", true);
        if (!isSync) {
          nvim.command("nnoremap <silent><nowait><buffer> q :q<CR>", true);
        }
        this.highlight(nvim);
        let res = await nvim.resumeNotification();
        let bufnr = res && res[1] == null ? res[0][1] : null;
        if (!bufnr)
          return;
        this.bufnr = bufnr;
        let buffer = nvim.createBuffer(bufnr);
        this.interval = setInterval(() => {
          this.draw(nvim, buffer);
        }, 100);
      }
      dispose() {
        if (this.interval) {
          clearInterval(this.interval);
        }
      }
    };
  }
});

// node_modules/ini/ini.js
var require_ini = __commonJS({
  "node_modules/ini/ini.js"(exports2) {
    exports2.parse = exports2.decode = decode;
    exports2.stringify = exports2.encode = encode;
    exports2.safe = safe;
    exports2.unsafe = unsafe;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    function encode(obj, opt) {
      var children = [];
      var out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? " = " : "=";
      Object.keys(obj).forEach(function(k, _, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
          val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object")
          children.push(k);
        else
          out += safe(k) + separator + safe(val) + eol;
      });
      if (opt.section && out.length)
        out = "[" + safe(opt.section) + "]" + eol + out;
      children.forEach(function(k, _, __) {
        var nk = dotSplit(k).join("\\.");
        var section2 = (opt.section ? opt.section + "." : "") + nk;
        var child = encode(obj[k], {
          section: section2,
          whitespace: opt.whitespace
        });
        if (out.length && child.length)
          out += eol;
        out += child;
      });
      return out;
    }
    function dotSplit(str) {
      return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode(str) {
      var out = {};
      var p = out;
      var section2 = null;
      var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      var lines = str.split(/[\r\n]+/g);
      lines.forEach(function(line, _, __) {
        if (!line || line.match(/^\s*[;#]/))
          return;
        var match = line.match(re);
        if (!match)
          return;
        if (match[1] !== void 0) {
          section2 = unsafe(match[1]);
          if (section2 === "__proto__") {
            p = {};
            return;
          }
          p = out[section2] = out[section2] || {};
          return;
        }
        var key = unsafe(match[2]);
        if (key === "__proto__")
          return;
        var value = match[3] ? unsafe(match[4]) : true;
        switch (value) {
          case "true":
          case "false":
          case "null":
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === "[]") {
          key = key.substring(0, key.length - 2);
          if (key === "__proto__")
            return;
          if (!p[key])
            p[key] = [];
          else if (!Array.isArray(p[key]))
            p[key] = [p[key]];
        }
        if (Array.isArray(p[key]))
          p[key].push(value);
        else
          p[key] = value;
      });
      Object.keys(out).filter(function(k, _, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
          return false;
        var parts = dotSplit(k);
        var p2 = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, ".");
        parts.forEach(function(part, _2, __2) {
          if (part === "__proto__")
            return;
          if (!p2[part] || typeof p2[part] !== "object")
            p2[part] = {};
          p2 = p2[part];
        });
        if (p2 === out && nl === l)
          return false;
        p2[nl] = out[k];
        return true;
      }).forEach(function(del, _, __) {
        delete out[del];
      });
      return out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'")
          val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_) {
        }
      } else {
        var esc = false;
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1)
            break;
          else if (c === "\\")
            esc = true;
          else
            unesc += c;
        }
        if (esc)
          unesc += "\\";
        return unesc.trim();
      }
      return val;
    }
  }
});

// node_modules/rc/node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  "node_modules/rc/node_modules/strip-json-comments/index.js"(exports2, module2) {
    "use strict";
    var singleComment = 1;
    var multiComment = 2;
    function stripWithoutWhitespace() {
      return "";
    }
    function stripWithWhitespace(str, start, end) {
      return str.slice(start, end).replace(/\S/g, " ");
    }
    module2.exports = function(str, opts) {
      opts = opts || {};
      var currentChar;
      var nextChar;
      var insideString = false;
      var insideComment = false;
      var offset = 0;
      var ret = "";
      var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
      for (var i = 0; i < str.length; i++) {
        currentChar = str[i];
        nextChar = str[i + 1];
        if (!insideComment && currentChar === '"') {
          var escaped = str[i - 1] === "\\" && str[i - 2] !== "\\";
          if (!escaped) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          continue;
        }
        if (!insideComment && currentChar + nextChar === "//") {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = singleComment;
          i++;
        } else if (insideComment === singleComment && currentChar + nextChar === "\r\n") {
          i++;
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
          continue;
        } else if (insideComment === singleComment && currentChar === "\n") {
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
        } else if (!insideComment && currentChar + nextChar === "/*") {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = multiComment;
          i++;
          continue;
        } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
          i++;
          insideComment = false;
          ret += strip(str, offset, i + 1);
          offset = i + 1;
          continue;
        }
      }
      return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
    };
  }
});

// node_modules/rc/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/rc/lib/utils.js"(exports2) {
    "use strict";
    var fs27 = require("fs");
    var ini = require_ini();
    var path36 = require("path");
    var stripJsonComments = require_strip_json_comments();
    var parse5 = exports2.parse = function(content) {
      if (/^\s*{/.test(content))
        return JSON.parse(stripJsonComments(content));
      return ini.parse(content);
    };
    var file = exports2.file = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      });
      for (var i in args)
        if (typeof args[i] !== "string")
          return;
      var file2 = path36.join.apply(null, args);
      var content;
      try {
        return fs27.readFileSync(file2, "utf-8");
      } catch (err) {
        return;
      }
    };
    var json = exports2.json = function() {
      var content = file.apply(null, arguments);
      return content ? parse5(content) : null;
    };
    var env = exports2.env = function(prefix, env2) {
      env2 = env2 || process.env;
      var obj = {};
      var l = prefix.length;
      for (var k in env2) {
        if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
          var keypath = k.substring(l).split("__");
          var _emptyStringIndex;
          while ((_emptyStringIndex = keypath.indexOf("")) > -1) {
            keypath.splice(_emptyStringIndex, 1);
          }
          var cursor = obj;
          keypath.forEach(function _buildSubObj(_subkey, i) {
            if (!_subkey || typeof cursor !== "object")
              return;
            if (i === keypath.length - 1)
              cursor[_subkey] = env2[k];
            if (cursor[_subkey] === void 0)
              cursor[_subkey] = {};
            cursor = cursor[_subkey];
          });
        }
      }
      return obj;
    };
    var find = exports2.find = function() {
      var rel = path36.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file2 = path36.join(start, rel2);
        try {
          fs27.statSync(file2);
          return file2;
        } catch (err) {
          if (path36.dirname(start) !== start)
            return find2(path36.dirname(start), rel2);
        }
      }
      return find2(process.cwd(), rel);
    };
  }
});

// node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS({
  "node_modules/deep-extend/lib/deep-extend.js"(exports2, module2) {
    "use strict";
    function isSpecificValue(val) {
      return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
    }
    function cloneSpecificValue(val) {
      if (val instanceof Buffer) {
        var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        val.copy(x);
        return x;
      } else if (val instanceof Date) {
        return new Date(val.getTime());
      } else if (val instanceof RegExp) {
        return new RegExp(val);
      } else {
        throw new Error("Unexpected situation");
      }
    }
    function deepCloneArray(arr) {
      var clone = [];
      arr.forEach(function(item, index) {
        if (typeof item === "object" && item !== null) {
          if (Array.isArray(item)) {
            clone[index] = deepCloneArray(item);
          } else if (isSpecificValue(item)) {
            clone[index] = cloneSpecificValue(item);
          } else {
            clone[index] = deepExtend({}, item);
          }
        } else {
          clone[index] = item;
        }
      });
      return clone;
    }
    function safeGetProperty(object, property) {
      return property === "__proto__" ? void 0 : object[property];
    }
    var deepExtend = module2.exports = function() {
      if (arguments.length < 1 || typeof arguments[0] !== "object") {
        return false;
      }
      if (arguments.length < 2) {
        return arguments[0];
      }
      var target = arguments[0];
      var args = Array.prototype.slice.call(arguments, 1);
      var val, src, clone;
      args.forEach(function(obj) {
        if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
          return;
        }
        Object.keys(obj).forEach(function(key) {
          src = safeGetProperty(target, key);
          val = safeGetProperty(obj, key);
          if (val === target) {
            return;
          } else if (typeof val !== "object" || val === null) {
            target[key] = val;
            return;
          } else if (Array.isArray(val)) {
            target[key] = deepCloneArray(val);
            return;
          } else if (isSpecificValue(val)) {
            target[key] = cloneSpecificValue(val);
            return;
          } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
            target[key] = deepExtend({}, val);
            return;
          } else {
            target[key] = deepExtend(src, val);
            return;
          }
        });
      });
      return target;
    };
  }
});

// node_modules/minimist/index.js
var require_minimist = __commonJS({
  "node_modules/minimist/index.js"(exports2, module2) {
    module2.exports = function(args, opts) {
      if (!opts)
        opts = {};
      var flags = { bools: {}, strings: {}, unknownFn: null };
      if (typeof opts["unknown"] === "function") {
        flags.unknownFn = opts["unknown"];
      }
      if (typeof opts["boolean"] === "boolean" && opts["boolean"]) {
        flags.allBools = true;
      } else {
        [].concat(opts["boolean"]).filter(Boolean).forEach(function(key2) {
          flags.bools[key2] = true;
        });
      }
      var aliases = {};
      Object.keys(opts.alias || {}).forEach(function(key2) {
        aliases[key2] = [].concat(opts.alias[key2]);
        aliases[key2].forEach(function(x) {
          aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
            return x !== y;
          }));
        });
      });
      [].concat(opts.string).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = true;
        if (aliases[key2]) {
          flags.strings[aliases[key2]] = true;
        }
      });
      var defaults2 = opts["default"] || {};
      var argv = { _: [] };
      Object.keys(flags.bools).forEach(function(key2) {
        setArg(key2, defaults2[key2] === void 0 ? false : defaults2[key2]);
      });
      var notFlags = [];
      if (args.indexOf("--") !== -1) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
      }
      function argDefined(key2, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
      }
      function setArg(key2, val, arg2) {
        if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
          if (flags.unknownFn(arg2) === false)
            return;
        }
        var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
        setKey(argv, key2.split("."), value2);
        (aliases[key2] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
      function setKey(obj, keys, value2) {
        var o = obj;
        for (var i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (key2 === "__proto__")
            return;
          if (o[key2] === void 0)
            o[key2] = {};
          if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype)
            o[key2] = {};
          if (o[key2] === Array.prototype)
            o[key2] = [];
          o = o[key2];
        }
        var key2 = keys[keys.length - 1];
        if (key2 === "__proto__")
          return;
        if (o === Object.prototype || o === Number.prototype || o === String.prototype)
          o = {};
        if (o === Array.prototype)
          o = [];
        if (o[key2] === void 0 || flags.bools[key2] || typeof o[key2] === "boolean") {
          o[key2] = value2;
        } else if (Array.isArray(o[key2])) {
          o[key2].push(value2);
        } else {
          o[key2] = [o[key2], value2];
        }
      }
      function aliasIsBoolean(key2) {
        return aliases[key2].some(function(x) {
          return flags.bools[x];
        });
      }
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          var key = m[1];
          var value = m[2];
          if (flags.bools[key]) {
            value = value !== "false";
          }
          setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg)) {
          var key = arg.match(/^--no-(.+)/)[1];
          setArg(key, false, arg);
        } else if (/^--.+/.test(arg)) {
          var key = arg.match(/^--(.+)/)[1];
          var next = args[i + 1];
          if (next !== void 0 && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, next, arg);
            i++;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next === "true", arg);
            i++;
          } else {
            setArg(key, flags.strings[key] ? "" : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          var letters = arg.slice(1, -1).split("");
          var broken = false;
          for (var j = 0; j < letters.length; j++) {
            var next = arg.slice(j + 2);
            if (next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
              setArg(letters[j], next.split("=")[1], arg);
              broken = true;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg);
              broken = true;
              break;
            } else {
              setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
            }
          }
          var key = arg.slice(-1)[0];
          if (!broken && key !== "-") {
            if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
              setArg(key, args[i + 1], arg);
              i++;
            } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
              setArg(key, args[i + 1] === "true", arg);
              i++;
            } else {
              setArg(key, flags.strings[key] ? "" : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv._.push(flags.strings["_"] || !isNumber(arg) ? arg : Number(arg));
          }
          if (opts.stopEarly) {
            argv._.push.apply(argv._, args.slice(i + 1));
            break;
          }
        }
      }
      Object.keys(defaults2).forEach(function(key2) {
        if (!hasKey(argv, key2.split("."))) {
          setKey(argv, key2.split("."), defaults2[key2]);
          (aliases[key2] || []).forEach(function(x) {
            setKey(argv, x.split("."), defaults2[key2]);
          });
        }
      });
      if (opts["--"]) {
        argv["--"] = new Array();
        notFlags.forEach(function(key2) {
          argv["--"].push(key2);
        });
      } else {
        notFlags.forEach(function(key2) {
          argv._.push(key2);
        });
      }
      return argv;
    };
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      if (typeof x === "number")
        return true;
      if (/^0x[0-9a-f]+$/i.test(x))
        return true;
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
  }
});

// node_modules/rc/index.js
var require_rc = __commonJS({
  "node_modules/rc/index.js"(exports2, module2) {
    var cc = require_utils3();
    var join2 = require("path").join;
    var deepExtend = require_deep_extend();
    var etc = "/etc";
    var win = process.platform === "win32";
    var home = win ? process.env.USERPROFILE : process.env.HOME;
    module2.exports = function(name2, defaults2, argv, parse5) {
      if (typeof name2 !== "string")
        throw new Error("rc(name): name *must* be string");
      if (!argv)
        argv = require_minimist()(process.argv.slice(2));
      defaults2 = (typeof defaults2 === "string" ? cc.json(defaults2) : defaults2) || {};
      parse5 = parse5 || cc.parse;
      var env = cc.env(name2 + "_");
      var configs = [defaults2];
      var configFiles = [];
      function addConfigFile(file) {
        if (configFiles.indexOf(file) >= 0)
          return;
        var fileConfig = cc.file(file);
        if (fileConfig) {
          configs.push(parse5(fileConfig));
          configFiles.push(file);
        }
      }
      if (!win)
        [
          join2(etc, name2, "config"),
          join2(etc, name2 + "rc")
        ].forEach(addConfigFile);
      if (home)
        [
          join2(home, ".config", name2, "config"),
          join2(home, ".config", name2),
          join2(home, "." + name2, "config"),
          join2(home, "." + name2 + "rc")
        ].forEach(addConfigFile);
      addConfigFile(cc.find("." + name2 + "rc"));
      if (env.config)
        addConfigFile(env.config);
      if (argv.config)
        addConfigFile(argv.config);
      return deepExtend.apply(null, configs.concat([
        env,
        argv,
        configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0
      ]));
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer4(arg, encodingOrOffset, length);
    }
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    module2.exports = contentDisposition2;
    module2.exports.parse = parse5;
    var basename = require("path").basename;
    var Buffer4 = require_safe_buffer().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition2(filename, options) {
      var opts = options || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format2(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name2 = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name2);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name2) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name2;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name2)) {
        params["filename*"] = name2;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name2;
      }
      return params;
    }
    function format2(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string2 = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string2 += "; " + param + "=" + val;
        }
      }
      return string2;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer4.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse5(string2) {
      if (!string2 || typeof string2 !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string2);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
      while (match = PARAM_REGEXP.exec(string2)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string2.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL = url.URL;
    var http3 = require("http");
    var https3 = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug2();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (typeof data === "function") {
        callback = data;
        data = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name2, value) {
      this._options.headers[name2] = value;
      this._currentRequest.setHeader(name2, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name2) {
      delete this._options.headers[name2];
      this._currentRequest.removeHeader(name2);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      if (callback) {
        this.on("timeout", callback);
      }
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        clearTimeout(this._timeout);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!this.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.once("response", clearTimer);
      this.once("error", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.substr(0, protocol.length - 1);
        this._options.agent = this._options.agents[scheme];
      }
      var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url.format(this._options);
      request2._redirectable = this;
      for (var e = 0; e < events.length; e++) {
        request2.on(events[e], eventHandlers[events[e]]);
      }
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request2 === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request2.finished) {
                request2.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request2.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
        abortRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) || url.parse(this._currentUrl).hostname;
        var redirectUrl = url.resolve(this._currentUrl, location);
        debug("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);
        if (redirectUrlParts.hostname !== previousHostName) {
          removeMatchingHeaders(/^authorization$/i, this._options.headers);
        }
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          } catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }
        try {
          this._performRequest();
        } catch (cause) {
          var error = new RedirectionError("Redirected request failed: " + cause.message);
          error.cause = cause;
          this.emit("error", error);
        }
      } else {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request2(input, options, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL(urlStr));
            } catch (err) {
              input = url.parse(urlStr);
            }
          } else if (URL && input instanceof URL) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (typeof options === "function") {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request2, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue;
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(message) {
        Error.captureStackTrace(this, this.constructor);
        this.message = message || defaultMessage;
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    function abortRequest(request2) {
      for (var e = 0; e < events.length; e++) {
        request2.removeListener(events[e], eventHandlers[events[e]]);
      }
      request2.on("error", noop);
      request2.abort();
    }
    module2.exports = wrap({ http: http3, https: https3 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS({
  "node_modules/tar/lib/high-level-opt.js"(exports2, module2) {
    "use strict";
    var argmap = new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
      argmap.has(k) ? argmap.get(k) : k,
      opt[k]
    ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {};
  }
});

// node_modules/minipass/index.js
var require_minipass = __commonJS({
  "node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var EE = require("events");
    var Stream = require("stream");
    var Yallist = require_yallist();
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = new Yallist();
        this.buffer = new Yallist();
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (!this.objectMode && !chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            cb();
          return this.flowing;
        }
        if (typeof chunk === "string" && !this[OBJECTMODE] && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing) {
          if (this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          this.emit("data", chunk);
        } else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          cb();
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        try {
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
            return null;
          if (this[OBJECTMODE])
            n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding)
              this.buffer = new Yallist([
                Array.from(this.buffer).join("")
              ]);
            else
              this.buffer = new Yallist([
                Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])
              ]);
          }
          return this[READ](n || null, this.buffer.head.value);
        } finally {
          this[MAYBE_EMIT_END]();
        }
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer.head.value = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        return this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer.head.value.length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === process.stdout || dest === process.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        const p = { dest, opts, ondrain: (_) => this[RESUME]() };
        this.pipes.push(p);
        dest.on("drain", p.ondrain);
        this[RESUME]();
        if (ended && p.opts.end)
          p.dest.end();
        return dest;
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        try {
          return super.on(ev, fn);
        } finally {
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          }
        }
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          if (!data)
            return;
          if (this.pipes.length)
            this.pipes.forEach((p) => p.dest.write(data) === false && this.pause());
        } else if (ev === "end") {
          if (this[EMITTED_END] === true)
            return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[DECODER]) {
            data = this[DECODER].end();
            if (data) {
              this.pipes.forEach((p) => p.dest.write(data));
              super.emit("data", data);
            }
          }
          this.pipes.forEach((p) => {
            p.dest.removeListener("drain", p.ondrain);
            if (p.opts.end)
              p.dest.end();
          });
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
        }
        const args = new Array(arguments.length);
        args[0] = ev;
        args[1] = data;
        if (arguments.length > 2) {
          for (let i = 2; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
        }
        try {
          return super.emit.apply(this, args);
        } finally {
          if (!isEndish(ev))
            this[MAYBE_EMIT_END]();
          else
            this.removeAllListeners(ev);
        }
      }
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      promise() {
        return new Promise((resolve3, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("end", () => resolve3());
          this.on("error", (er) => reject(er));
        });
      }
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve3 = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve3({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve3({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve3 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer = new Yallist();
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minizlib/constants.js
var require_constants2 = __commonJS({
  "node_modules/minizlib/constants.js"(exports2, module2) {
    var realZlibConstants = require("zlib").constants || { ZLIB_VERNUM: 4736 };
    module2.exports = Object.freeze(Object.assign(Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// node_modules/minizlib/index.js
var require_minizlib = __commonJS({
  "node_modules/minizlib/index.js"(exports2) {
    "use strict";
    var assert = require("assert");
    var Buffer4 = require("buffer").Buffer;
    var realZlib = require("zlib");
    var constants = exports2.constants = require_constants2();
    var Minipass = require_minipass();
    var OriginalBufferConcat = Buffer4.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer4.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding, cb) {
        if (chunk)
          this.write(chunk, encoding);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer4.from(chunk, encoding);
        if (this[_sawError])
          return;
        assert(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer4.concat = (args) => args;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer4.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer4.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer4.from(result[0]));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer4.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data) {
        return super.write(data);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants.Z_SYNC_FLUSH);
          assert(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data);
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports2.Deflate = Deflate;
    exports2.Inflate = Inflate;
    exports2.Gzip = Gzip;
    exports2.Gunzip = Gunzip;
    exports2.DeflateRaw = DeflateRaw;
    exports2.InflateRaw = InflateRaw;
    exports2.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports2.BrotliCompress = BrotliCompress;
      exports2.BrotliDecompress = BrotliDecompress;
    } else {
      exports2.BrotliCompress = exports2.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  }
});

// node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS({
  "node_modules/tar/lib/normalize-windows-path.js"(exports2, module2) {
    var platform3 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    module2.exports = platform3 !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
  }
});

// node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS({
  "node_modules/tar/lib/read-entry.js"(exports2, module2) {
    "use strict";
    var MiniPass = require_minipass();
    var normPath = require_normalize_windows_path();
    var SLURP = Symbol("slurp");
    module2.exports = class ReadEntry extends MiniPass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          default:
            this.ignore = true;
        }
        this.path = normPath(header.path);
        this.mode = header.mode;
        if (this.mode)
          this.mode = this.mode & 4095;
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = normPath(header.linkpath);
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex)
          this[SLURP](ex);
        if (gex)
          this[SLURP](gex, true);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain)
          throw new Error("writing more to entry than is appropriate");
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore)
          return true;
        if (r >= writeLen)
          return super.write(data);
        return super.write(data.slice(0, r));
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
            this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
        }
      }
    };
  }
});

// node_modules/tar/lib/types.js
var require_types2 = __commonJS({
  "node_modules/tar/lib/types.js"(exports2) {
    "use strict";
    exports2.name = new Map([
      ["0", "File"],
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      ["7", "ContiguousFile"],
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      ["A", "SolarisACL"],
      ["D", "GNUDumpDir"],
      ["I", "Inode"],
      ["K", "NextFileHasLongLinkpath"],
      ["L", "NextFileHasLongPath"],
      ["M", "ContinuationFile"],
      ["N", "OldGnuLongPath"],
      ["S", "SparseFile"],
      ["V", "TapeVolumeHeader"],
      ["X", "OldExtendedHeader"]
    ]);
    exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
  }
});

// node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS({
  "node_modules/tar/lib/large-numbers.js"(exports2, module2) {
    "use strict";
    var encode = (num, buf) => {
      if (!Number.isSafeInteger(num))
        throw Error("cannot encode number outside of javascript safe integer range");
      else if (num < 0)
        encodeNegative(num, buf);
      else
        encodePositive(num, buf);
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i = buf.length; i > 1; i--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped)
          buf[i - 1] = onesComp(byte);
        else if (byte === 0)
          buf[i - 1] = 0;
        else {
          flipped = true;
          buf[i - 1] = twosComp(byte);
        }
      }
    };
    var parse5 = (buf) => {
      const pre = buf[0];
      const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
      if (value === null)
        throw Error("invalid base256 encoding");
      if (!Number.isSafeInteger(value))
        throw Error("parsed number outside of javascript safe integer range");
      return value;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum = 0;
      var flipped = false;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        var f;
        if (flipped)
          f = onesComp(byte);
        else if (byte === 0)
          f = byte;
        else {
          flipped = true;
          f = twosComp(byte);
        }
        if (f !== 0)
          sum -= f * Math.pow(256, len - i - 1);
      }
      return sum;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum = 0;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        if (byte !== 0)
          sum += byte * Math.pow(256, len - i - 1);
      }
      return sum;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
    module2.exports = {
      encode,
      parse: parse5
    };
  }
});

// node_modules/tar/lib/header.js
var require_header = __commonJS({
  "node_modules/tar/lib/header.js"(exports2, module2) {
    "use strict";
    var types = require_types2();
    var pathModule = require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data))
          this.decode(data, off || 0, ex, gex);
        else if (data)
          this.set(data);
      }
      decode(buf, off, ex, gex) {
        if (!off)
          off = 0;
        if (!buf || !(buf.length >= off + 512))
          throw new Error("need 512 bytes for header");
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "")
          this[TYPE] = "0";
        if (this[TYPE] === "0" && this.path.substr(-1) === "/")
          this[TYPE] = "5";
        if (this[TYPE] === "5")
          this.size = 0;
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix = decString(buf, off + 345, 155);
            this.path = prefix + "/" + this.path;
          } else {
            const prefix = decString(buf, off + 345, 130);
            if (prefix)
              this.path = prefix + "/" + this.path;
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++)
          sum += buf[i];
        for (let i = off + 156; i < off + 512; i++)
          sum += buf[i];
        this.cksumValid = sum === this.cksum;
        if (this.cksum === null && sum === 8 * 32)
          this.nullBlock = true;
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
            this[k] = ex[k];
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off)
          off = 0;
        if (!(buf.length >= off + 512))
          throw new Error("need 512 bytes for header");
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split = splitPrefix(this.path || "", prefixSize);
        const path36 = split[0];
        const prefix = split[1];
        this.needPax = split[2];
        this.needPax = encString(buf, off, 100, path36) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0)
          this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
        else {
          this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++)
          sum += buf[i];
        for (let i = off + 156; i < off + 512; i++)
          sum += buf[i];
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data) {
        for (const i in data) {
          if (data[i] !== null && data[i] !== void 0)
            this[i] = data[i];
        }
      }
      get type() {
        return types.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types.code.has(type))
          this[TYPE] = types.code.get(type);
        else
          this[TYPE] = type;
      }
    };
    var splitPrefix = (p, prefixSize) => {
      const pathSize = 100;
      let pp = p;
      let prefix = "";
      let ret;
      const root = pathModule.parse(p).root || ".";
      if (Buffer.byteLength(pp) < pathSize)
        ret = [pp, prefix, false];
      else {
        prefix = pathModule.dirname(pp);
        pp = pathModule.basename(pp);
        do {
          if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize)
            ret = [pp, prefix, false];
          else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize)
            ret = [pp.substr(0, pathSize - 1), prefix, true];
          else {
            pp = pathModule.join(pathModule.basename(prefix), pp);
            prefix = pathModule.dirname(prefix);
          }
        } while (prefix !== root && !ret);
        if (!ret)
          ret = [p.substr(0, pathSize - 1), "", true];
      }
      return ret;
    };
    var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
    var nanNull = (value) => isNaN(value) ? null : value;
    var decSmallNumber = (buf, off, size) => nanNull(parseInt(buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size, number2) => number2 === null ? false : number2 > MAXNUM[size] || number2 < 0 ? (large.encode(number2, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number2), false);
    var encSmallNumber = (buf, off, size, number2) => buf.write(octalString(number2, size), off, size, "ascii");
    var octalString = (number2, size) => padOctal(Math.floor(number2).toString(8), size);
    var padOctal = (string2, size) => (string2.length === size - 1 ? string2 : new Array(size - string2.length - 1).join("0") + string2 + " ") + "\0";
    var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size, string2) => string2 === null ? false : (buf.write(string2 + NULLS, off, size, "utf8"), string2.length !== Buffer.byteLength(string2) || string2.length > size);
    module2.exports = Header;
  }
});

// node_modules/tar/lib/pax.js
var require_pax = __commonJS({
  "node_modules/tar/lib/pax.js"(exports2, module2) {
    "use strict";
    var Header = require_header();
    var path36 = require("path");
    var Pax = class {
      constructor(obj, global2) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global2 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "")
          return null;
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i = 0; i < 512; i++)
          buf[i] = 0;
        new Header({
          path: ("PaxHeader/" + path36.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i = bodyLen + 512; i < buf.length; i++)
          buf[i] = 0;
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0)
          return "";
        const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
        const byteLen = Buffer.byteLength(s);
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits))
          digits += 1;
        const len = digits + byteLen;
        return len + s;
      }
    };
    Pax.parse = (string2, ex, g) => new Pax(merge(parseKV(string2), ex), g);
    var merge = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
    var parseKV = (string2) => string2.replace(/\n$/, "").split("\n").reduce(parseKVLine, Object.create(null));
    var parseKVLine = (set, line) => {
      const n = parseInt(line, 10);
      if (n !== Buffer.byteLength(line) + 1)
        return set;
      line = line.substr((n + " ").length);
      const kv = line.split("=");
      const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k)
        return set;
      const v = kv.join("=");
      set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
      return set;
    };
    module2.exports = Pax;
  }
});

// node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS({
  "node_modules/tar/lib/strip-trailing-slashes.js"(exports2, module2) {
    module2.exports = (str) => {
      let i = str.length - 1;
      let slashesStart = -1;
      while (i > -1 && str.charAt(i) === "/") {
        slashesStart = i;
        i--;
      }
      return slashesStart === -1 ? str : str.slice(0, slashesStart);
    };
  }
});

// node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS({
  "node_modules/tar/lib/warn-mixin.js"(exports2, module2) {
    "use strict";
    module2.exports = (Base) => class extends Base {
      warn(code, message, data = {}) {
        if (this.file)
          data.file = this.file;
        if (this.cwd)
          data.cwd = this.cwd;
        data.code = message instanceof Error && message.code || code;
        data.tarCode = code;
        if (!this.strict && data.recoverable !== false) {
          if (message instanceof Error) {
            data = Object.assign(message, data);
            message = message.message;
          }
          this.emit("warn", data.tarCode, message, data);
        } else if (message instanceof Error)
          this.emit("error", Object.assign(message, data));
        else
          this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
      }
    };
  }
});

// node_modules/tar/lib/winchars.js
var require_winchars = __commonJS({
  "node_modules/tar/lib/winchars.js"(exports2, module2) {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
    var toWin = new Map(raw.map((char, i) => [char, win[i]]));
    var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
    module2.exports = {
      encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
      decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
    };
  }
});

// node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS({
  "node_modules/tar/lib/strip-absolute-path.js"(exports2, module2) {
    var { isAbsolute, parse: parse5 } = require("path").win32;
    module2.exports = (path36) => {
      let r = "";
      let parsed = parse5(path36);
      while (isAbsolute(path36) || parsed.root) {
        const root = path36.charAt(0) === "/" && path36.slice(0, 4) !== "//?/" ? "/" : parsed.root;
        path36 = path36.substr(root.length);
        r += root;
        parsed = parse5(path36);
      }
      return [r, path36];
    };
  }
});

// node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS({
  "node_modules/tar/lib/mode-fix.js"(exports2, module2) {
    "use strict";
    module2.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable)
        mode = (mode | 384) & ~18;
      if (isDir) {
        if (mode & 256)
          mode |= 64;
        if (mode & 32)
          mode |= 8;
        if (mode & 4)
          mode |= 1;
      }
      return mode;
    };
  }
});

// node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS({
  "node_modules/tar/lib/write-entry.js"(exports2, module2) {
    "use strict";
    var MiniPass = require_minipass();
    var Pax = require_pax();
    var Header = require_header();
    var fs27 = require("fs");
    var path36 = require("path");
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var prefixPath = (path37, prefix) => {
      if (!prefix)
        return normPath(path37);
      path37 = normPath(path37).replace(/^\.(\/|$)/, "");
      return stripSlash(prefix) + "/" + path37;
    };
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var AWAITDRAIN = Symbol("awaitDrain");
    var ONDRAIN = Symbol("ondrain");
    var PREFIX = Symbol("prefix");
    var HAD_ERROR = Symbol("hadError");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var stripAbsolutePath = require_strip_absolute_path();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends MiniPass {
      constructor(p, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p !== "string")
          throw new TypeError("path is required");
        this.path = normPath(p);
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid() || 0;
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || new Map();
        this.statCache = opt.statCache || new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = normPath(opt.cwd || process.cwd());
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.prefix = opt.prefix ? normPath(opt.prefix) : null;
        this.fd = null;
        this.blockLen = null;
        this.blockRemain = null;
        this.buf = null;
        this.offset = null;
        this.length = null;
        this.pos = null;
        this.remain = null;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p = p.replace(/\\/g, "/");
        }
        this.absolute = normPath(opt.absolute || path36.resolve(this.cwd, p));
        if (this.path === "")
          this.path = "./";
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute))
          this[ONLSTAT](this.statCache.get(this.absolute));
        else
          this[LSTAT]();
      }
      emit(ev, ...data) {
        if (ev === "error")
          this[HAD_ERROR] = true;
        return super.emit(ev, ...data);
      }
      [LSTAT]() {
        fs27.lstat(this.absolute, (er, stat) => {
          if (er)
            return this.emit("error", er);
          this[ONLSTAT](stat);
        });
      }
      [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile())
          stat.size = 0;
        this.type = getType(stat);
        this.emit("stat", stat);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [PREFIX](path37) {
        return prefixPath(path37, this.prefix);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable)
          this.noMtime = true;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        }
        super.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.substr(-1) !== "/")
          this.path += "/";
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs27.readlink(this.absolute, (er, linkpath) => {
          if (er)
            return this.emit("error", er);
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = normPath(linkpath);
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = normPath(path36.relative(this.cwd, linkpath));
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0)
              return this[HARDLINK](linkpath);
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0)
          return this.end();
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs27.open(this.absolute, "r", (er, fd) => {
          if (er)
            return this.emit("error", er);
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        this.fd = fd;
        if (this[HAD_ERROR])
          return this[CLOSE]();
        this.blockLen = 512 * Math.ceil(this.stat.size / 512);
        this.blockRemain = this.blockLen;
        const bufLen = Math.min(this.blockLen, this.maxReadSize);
        this.buf = Buffer.allocUnsafe(bufLen);
        this.offset = 0;
        this.pos = 0;
        this.remain = this.stat.size;
        this.length = this.buf.length;
        this[READ]();
      }
      [READ]() {
        const { fd, buf, offset, length, pos } = this;
        fs27.read(fd, buf, offset, length, pos, (er, bytesRead) => {
          if (er) {
            return this[CLOSE](() => this.emit("error", er));
          }
          this[ONREAD](bytesRead);
        });
      }
      [CLOSE](cb) {
        fs27.close(this.fd, cb);
      }
      [ONREAD](bytesRead) {
        if (bytesRead <= 0 && this.remain > 0) {
          const er = new Error("encountered unexpected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead > this.remain) {
          const er = new Error("did not encounter expected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead === this.remain) {
          for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
            this.buf[i + this.offset] = 0;
            bytesRead++;
            this.remain++;
          }
        }
        const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
        const flushed = this.write(writeBuf);
        if (!flushed)
          this[AWAITDRAIN](() => this[ONDRAIN]());
        else
          this[ONDRAIN]();
      }
      [AWAITDRAIN](cb) {
        this.once("drain", cb);
      }
      write(writeBuf) {
        if (this.blockRemain < writeBuf.length) {
          const er = new Error("writing more data than expected");
          er.path = this.absolute;
          return this.emit("error", er);
        }
        this.remain -= writeBuf.length;
        this.blockRemain -= writeBuf.length;
        this.pos += writeBuf.length;
        this.offset += writeBuf.length;
        return super.write(writeBuf);
      }
      [ONDRAIN]() {
        if (!this.remain) {
          if (this.blockRemain)
            super.write(Buffer.alloc(this.blockRemain));
          return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
        }
        if (this.offset >= this.length) {
          this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
          this.offset = 0;
        }
        this.length = this.buf.length - this.offset;
        this[READ]();
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      [LSTAT]() {
        this[ONLSTAT](fs27.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs27.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs27.openSync(this.absolute, "r"));
      }
      [READ]() {
        let threw = true;
        try {
          const { fd, buf, offset, length, pos } = this;
          const bytesRead = fs27.readSync(fd, buf, offset, length, pos);
          this[ONREAD](bytesRead);
          threw = false;
        } finally {
          if (threw) {
            try {
              this[CLOSE](() => {
              });
            } catch (er) {
            }
          }
        }
      }
      [AWAITDRAIN](cb) {
        cb();
      }
      [CLOSE](cb) {
        fs27.closeSync(this.fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable)
          this.noMtime = true;
        this.prefix = opt.prefix || null;
        this.path = normPath(readEntry.path);
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = normPath(readEntry.linkpath);
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        }
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [PREFIX](path37) {
        return prefixPath(path37, this.prefix);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain)
          throw new Error("writing more to entry than is appropriate");
        this.blockRemain -= writeLen;
        return super.write(data);
      }
      end() {
        if (this.blockRemain)
          super.write(Buffer.alloc(this.blockRemain));
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module2.exports = WriteEntry;
  }
});

// node_modules/tar/lib/pack.js
var require_pack = __commonJS({
  "node_modules/tar/lib/pack.js"(exports2, module2) {
    "use strict";
    var PackJob = class {
      constructor(path37, absolute) {
        this.path = path37 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var MiniPass = require_minipass();
    var zlib = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs27 = require("fs");
    var path36 = require("path");
    var warner = require_warn_mixin();
    var normPath = require_normalize_windows_path();
    var Pack = warner(class Pack extends MiniPass {
      constructor(opt) {
        super(opt);
        opt = opt || Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = normPath(opt.prefix || "");
        this.linkCache = opt.linkCache || new Map();
        this.statCache = opt.statCache || new Map();
        this.readdirCache = opt.readdirCache || new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip) {
          if (typeof opt.gzip !== "object")
            opt.gzip = {};
          if (this.portable)
            opt.gzip.portable = true;
          this.zip = new zlib.Gzip(opt.gzip);
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_) => super.end());
          this.zip.on("drain", (_) => this[ONDRAIN]());
          this.on("resume", (_) => this.zip.resume());
        } else
          this.on("drain", this[ONDRAIN]);
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path37) {
        this.write(path37);
        return this;
      }
      end(path37) {
        if (path37)
          this.write(path37);
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path37) {
        if (this[ENDED])
          throw new Error("write after end");
        if (path37 instanceof ReadEntry)
          this[ADDTARENTRY](path37);
        else
          this[ADDFSENTRY](path37);
        return this.flowing;
      }
      [ADDTARENTRY](p) {
        const absolute = normPath(path36.resolve(this.cwd, p.path));
        if (!this.filter(p.path, p))
          p.resume();
        else {
          const job = new PackJob(p.path, absolute, false);
          job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
          job.entry.on("end", (_) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p) {
        const absolute = normPath(path36.resolve(this.cwd, p));
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? "stat" : "lstat";
        fs27[stat](job.absolute, (er, stat2) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er)
            this.emit("error", er);
          else
            this[ONSTAT](job, stat2);
        });
      }
      [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        if (!this.filter(job.path, stat))
          job.ignore = true;
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs27.readdir(job.absolute, (er, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er)
            return this.emit("error", er);
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING])
          return;
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
          this[PROCESSJOB](w.value);
          if (w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w);
            w.next = p;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip)
            this.zip.end(EOF);
          else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending)
          return;
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped)
            this[PIPE](job);
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute))
            this[ONSTAT](job, this.statCache.get(job.absolute));
          else
            this[STAT](job);
        }
        if (!job.stat)
          return;
        if (job.ignore)
          return;
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute))
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          else
            this[READDIR](job);
          if (!job.readdir)
            return;
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped)
          this[PIPE](job);
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data) => this.warn(code, msg, data),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime,
          prefix: this.prefix
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
        } catch (er) {
          this.emit("error", er);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry)
          this[CURRENT].entry.resume();
      }
      [PIPE](job) {
        job.piped = true;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        const source = job.entry;
        const zip = this.zip;
        if (zip) {
          source.on("data", (chunk) => {
            if (!zip.write(chunk))
              source.pause();
          });
        } else {
          source.on("data", (chunk) => {
            if (!super.write(chunk))
              source.pause();
          });
        }
      }
      pause() {
        if (this.zip)
          this.zip.pause();
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs27[stat](job.absolute));
      }
      [READDIR](job, stat) {
        this[ONREADDIR](job, fs27.readdirSync(job.absolute));
      }
      [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        if (zip) {
          source.on("data", (chunk) => {
            zip.write(chunk);
          });
        } else {
          source.on("data", (chunk) => {
            super[WRITE](chunk);
          });
        }
      }
    };
    Pack.Sync = PackSync;
    module2.exports = Pack;
  }
});

// node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS({
  "node_modules/fs-minipass/index.js"(exports2) {
    "use strict";
    var MiniPass = require_minipass();
    var EE = require("events").EventEmitter;
    var fs27 = require("fs");
    var writev = fs27.writev;
    if (!writev) {
      const binding = process.binding("fs");
      const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
      writev = (fd, iovec, pos, cb) => {
        const done = (er, bw) => cb(er, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
      };
    }
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends MiniPass {
      constructor(path36, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path36 !== "string")
          throw new TypeError("path must be a string");
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path36;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs27.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs27.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er)
          this[_onerror](er);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs27.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          case "error":
            if (this[_errored])
              return;
            this[_errored] = true;
            return super.emit(ev, data);
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs27.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs27.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs27.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path36, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path36;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      emit(ev, data) {
        if (ev === "error") {
          if (this[_errored])
            return;
          this[_errored] = true;
        }
        return super.emit(ev, data);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs27.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = Buffer.from(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs27.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er)
          this[_onerror](er);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs27.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs27.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if (er.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else
              throw er;
          }
        } else
          fd = fs27.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs27.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](null, fs27.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
          threw = false;
        } finally {
          if (threw)
            try {
              this[_close]();
            } catch (_) {
            }
        }
      }
    };
    exports2.ReadStream = ReadStream;
    exports2.ReadStreamSync = ReadStreamSync;
    exports2.WriteStream = WriteStream;
    exports2.WriteStreamSync = WriteStreamSync;
  }
});

// node_modules/tar/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/tar/lib/parse.js"(exports2, module2) {
    "use strict";
    var warner = require_warn_mixin();
    var Header = require_header();
    var EE = require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib = require_minizlib();
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var noop = (_) => true;
    module2.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone)
          this.on(DONE, opt.ondone);
        else {
          this.on(DONE, (_) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
            this.emit("close");
          });
        }
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        if (typeof opt.onentry === "function")
          this.on("entry", opt.onentry);
      }
      [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === null)
          this[SAW_VALID_ENTRY] = false;
        let header;
        try {
          header = new Header(chunk, position, this[EX], this[GEX]);
        } catch (er) {
          return this.warn("TAR_ENTRY_INVALID", er);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin")
              this[STATE] = "header";
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid)
            this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
          else if (!header.path)
            this.warn("TAR_ENTRY_INVALID", "path is required", { header });
          else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
              this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
            else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
            else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid)
                      this[SAW_VALID_ENTRY] = true;
                  };
                  entry.on("end", onend);
                } else
                  this[SAW_VALID_ENTRY] = true;
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c) => this[META] += c);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain)
                    this[STATE] = "body";
                  else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else
                    this[QUEUE].push(entry);
                }
              }
            }
          }
        }
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry))
          this.emit.apply(this, entry);
        else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re = this[READENTRY];
          const drainNow = !re || re.flowing || re.size === re.remain;
          if (drainNow) {
            if (!this[WRITING])
              this.emit("drain");
          } else
            re.once("drain", (_) => this.emit("drain"));
        }
      }
      [CONSUMEBODY](chunk, position) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
        entry.write(c);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c.length;
      }
      [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        if (!this[WRITEENTRY])
          this[EMITMETA](entry);
        return ret;
      }
      [EMIT](ev, data, extra) {
        if (!this[QUEUE].length && !this[READENTRY])
          this.emit(ev, data, extra);
        else
          this[QUEUE].push([ev, data, extra]);
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error) {
        this[ABORTED] = true;
        this.emit("abort", error);
        this.warn("TAR_ABORT", error, { recoverable: false });
      }
      write(chunk) {
        if (this[ABORTED])
          return;
        if (this[UNZIP] === null && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
            if (chunk[i] !== gzipHeader[i])
              this[UNZIP] = false;
          }
          if (this[UNZIP] === null) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = new zlib.Unzip();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er) => this.abort(er));
            this[UNZIP].on("end", (_) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP])
          this[UNZIP].write(chunk);
        else
          this[CONSUMECHUNK](chunk);
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length)
          this[READENTRY].once("drain", (_) => this.emit("drain"));
        return ret;
      }
      [BUFFERCONCAT](c) {
        if (c && !this[ABORTED])
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
            if (this[BUFFER])
              entry.write(this[BUFFER]);
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING])
          this[BUFFERCONCAT](chunk);
        else if (!chunk && !this[BUFFER])
          this[MAYBEEND]();
        else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          } else
            this[CONSUMECHUNKSUB](chunk);
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED])
          this[MAYBEEND]();
      }
      [CONSUMECHUNKSUB](chunk) {
        let position = 0;
        const length = chunk.length;
        while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position);
              position += 512;
              break;
            case "ignore":
            case "body":
              position += this[CONSUMEBODY](chunk, position);
              break;
            case "meta":
              position += this[CONSUMEMETA](chunk, position);
              break;
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position < length) {
          if (this[BUFFER])
            this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
          else
            this[BUFFER] = chunk.slice(position);
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP])
            this[UNZIP].end(chunk);
          else {
            this[ENDED] = true;
            this.write(chunk);
          }
        }
      }
    });
  }
});

// node_modules/tar/lib/list.js
var require_list = __commonJS({
  "node_modules/tar/lib/list.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser = require_parse2();
    var fs27 = require("fs");
    var fsm = require_fs_minipass();
    var path36 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function")
        cb = opt_, files = null, opt_ = {};
      else if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (typeof files === "function")
        cb = files, files = null;
      if (!files)
        files = [];
      else
        files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      if (files.length)
        filesFilter(opt, files);
      if (!opt.noResume)
        onentryFunction(opt);
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list2(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e) => {
        onentry(e);
        e.resume();
      } : (e) => e.resume();
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path36.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path36.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var listFileSync = (opt) => {
      const p = list2(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat = fs27.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize)
          p.end(fs27.readFileSync(file));
        else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs27.openSync(file, "r");
          while (pos < stat.size) {
            const bytesRead = fs27.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p.write(buf.slice(0, bytesRead));
          }
          p.end();
        }
        threw = false;
      } finally {
        if (threw && fd) {
          try {
            fs27.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var listFile = (opt, cb) => {
      const parse5 = new Parser(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve3, reject) => {
        parse5.on("error", reject);
        parse5.on("end", resolve3);
        fs27.stat(file, (er, stat) => {
          if (er)
            reject(er);
          else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(parse5);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var list2 = (opt) => new Parser(opt);
  }
});

// node_modules/tar/lib/create.js
var require_create = __commonJS({
  "node_modules/tar/lib/create.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fsm = require_fs_minipass();
    var t = require_list();
    var path36 = require("path");
    module2.exports = (opt_, files, cb) => {
      if (typeof files === "function")
        cb = files;
      if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      const stream = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var createFile = (opt, files, cb) => {
      const p = new Pack(opt);
      const stream = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      const promise = new Promise((res, rej) => {
        stream.on("error", rej);
        stream.on("close", res);
        p.on("error", rej);
      });
      addFilesAsync(p, files);
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path36.resolve(p.cwd, file.substr(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else
          p.add(file);
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path36.resolve(p.cwd, file.substr(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else
          p.add(file);
      }
      p.end();
    };
    var createSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      addFilesSync(p, files);
      return p;
    };
    var create = (opt, files) => {
      const p = new Pack(opt);
      addFilesAsync(p, files);
      return p;
    };
  }
});

// node_modules/tar/lib/replace.js
var require_replace = __commonJS({
  "node_modules/tar/lib/replace.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs27 = require("fs");
    var fsm = require_fs_minipass();
    var t = require_list();
    var path36 = require("path");
    var Header = require_header();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file)
        throw new TypeError("file is required");
      if (opt.gzip)
        throw new TypeError("cannot append to compressed archives");
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position;
      try {
        try {
          fd = fs27.openSync(opt.file, "r+");
        } catch (er) {
          if (er.code === "ENOENT")
            fd = fs27.openSync(opt.file, "w+");
          else
            throw er;
        }
        const st = fs27.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION:
          for (position = 0; position < st.size; position += 512) {
            for (let bufPos = 0, bytes2 = 0; bufPos < 512; bufPos += bytes2) {
              bytes2 = fs27.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);
              if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
                throw new Error("cannot append to compressed archives");
              if (!bytes2)
                break POSITION;
            }
            const h = new Header(headBuf);
            if (!h.cksumValid)
              break;
            const entryBlockSize = 512 * Math.ceil(h.size / 512);
            if (position + entryBlockSize + 512 > st.size)
              break;
            position += entryBlockSize;
            if (opt.mtimeCache)
              opt.mtimeCache.set(h.path, h.mtime);
          }
        threw = false;
        streamSync(opt, p, position, fd, files);
      } finally {
        if (threw) {
          try {
            fs27.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var streamSync = (opt, p, position, fd, files) => {
      const stream = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var replace = (opt, files, cb) => {
      files = Array.from(files);
      const p = new Pack(opt);
      const getPos = (fd, size, cb_) => {
        const cb2 = (er, pos) => {
          if (er)
            fs27.close(fd, (_) => cb_(er));
          else
            cb_(null, pos);
        };
        let position = 0;
        if (size === 0)
          return cb2(null, 0);
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes2) => {
          if (er)
            return cb2(er);
          bufPos += bytes2;
          if (bufPos < 512 && bytes2) {
            return fs27.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
          }
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
            return cb2(new Error("cannot append to compressed archives"));
          if (bufPos < 512)
            return cb2(null, position);
          const h = new Header(headBuf);
          if (!h.cksumValid)
            return cb2(null, position);
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > size)
            return cb2(null, position);
          position += entryBlockSize + 512;
          if (position >= size)
            return cb2(null, position);
          if (opt.mtimeCache)
            opt.mtimeCache.set(h.path, h.mtime);
          bufPos = 0;
          fs27.read(fd, headBuf, 0, 512, position, onread);
        };
        fs27.read(fd, headBuf, 0, 512, position, onread);
      };
      const promise = new Promise((resolve3, reject) => {
        p.on("error", reject);
        let flag = "r+";
        const onopen = (er, fd) => {
          if (er && er.code === "ENOENT" && flag === "r+") {
            flag = "w+";
            return fs27.open(opt.file, flag, onopen);
          }
          if (er)
            return reject(er);
          fs27.fstat(fd, (er2, st) => {
            if (er2)
              return fs27.close(fd, () => reject(er2));
            getPos(fd, st.size, (er3, position) => {
              if (er3)
                return reject(er3);
              const stream = new fsm.WriteStream(opt.file, {
                fd,
                start: position
              });
              p.pipe(stream);
              stream.on("error", reject);
              stream.on("close", resolve3);
              addFilesAsync(p, files);
            });
          });
        };
        fs27.open(opt.file, flag, onopen);
      });
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path36.resolve(p.cwd, file.substr(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else
          p.add(file);
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path36.resolve(p.cwd, file.substr(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else
          p.add(file);
      }
      p.end();
    };
  }
});

// node_modules/tar/lib/update.js
var require_update = __commonJS({
  "node_modules/tar/lib/update.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var r = require_replace();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file)
        throw new TypeError("file is required");
      if (opt.gzip)
        throw new TypeError("cannot append to compressed archives");
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      mtimeFilter(opt);
      return r(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter = opt.filter;
      if (!opt.mtimeCache)
        opt.mtimeCache = new Map();
      opt.filter = filter ? (path36, stat) => filter(path36, stat) && !(opt.mtimeCache.get(path36) > stat.mtime) : (path36, stat) => !(opt.mtimeCache.get(path36) > stat.mtime);
    };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/opts-arg.js"(exports2, module2) {
    var { promisify } = require("util");
    var fs27 = require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = { mode: 511, fs: fs27 };
      else if (typeof opts === "object")
        opts = __spreadValues({ mode: 511, fs: fs27 }, opts);
      else if (typeof opts === "number")
        opts = { mode: opts, fs: fs27 };
      else if (typeof opts === "string")
        opts = { mode: parseInt(opts, 8), fs: fs27 };
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs27.mkdir;
      opts.mkdirAsync = promisify(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs27.stat;
      opts.statAsync = promisify(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs27.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs27.mkdirSync;
      return opts;
    };
    module2.exports = optsArg;
  }
});

// node_modules/tar/node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/path-arg.js"(exports2, module2) {
    var platform3 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var { resolve: resolve3, parse: parse5 } = require("path");
    var pathArg = (path36) => {
      if (/\0/.test(path36)) {
        throw Object.assign(new TypeError("path must be a string without null bytes"), {
          path: path36,
          code: "ERR_INVALID_ARG_VALUE"
        });
      }
      path36 = resolve3(path36);
      if (platform3 === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const { root } = parse5(path36);
        if (badWinChars.test(path36.substr(root.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path: path36,
            code: "EINVAL"
          });
        }
      }
      return path36;
    };
    module2.exports = pathArg;
  }
});

// node_modules/tar/node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/find-made.js"(exports2, module2) {
    var { dirname: dirname3 } = require("path");
    var findMade = (opts, parent, path36 = void 0) => {
      if (path36 === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then((st) => st.isDirectory() ? path36 : void 0, (er) => er.code === "ENOENT" ? findMade(opts, dirname3(parent), parent) : void 0);
    };
    var findMadeSync = (opts, parent, path36 = void 0) => {
      if (path36 === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path36 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname3(parent), parent) : void 0;
      }
    };
    module2.exports = { findMade, findMadeSync };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/mkdirp-manual.js"(exports2, module2) {
    var { dirname: dirname3 } = require("path");
    var mkdirpManual = (path36, opts, made) => {
      opts.recursive = false;
      const parent = dirname3(path36);
      if (parent === path36) {
        return opts.mkdirAsync(path36, opts).catch((er) => {
          if (er.code !== "EISDIR")
            throw er;
        });
      }
      return opts.mkdirAsync(path36, opts).then(() => made || path36, (er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path36, opts, made2));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        return opts.statAsync(path36).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er;
        }, () => {
          throw er;
        });
      });
    };
    var mkdirpManualSync = (path36, opts, made) => {
      const parent = dirname3(path36);
      opts.recursive = false;
      if (parent === path36) {
        try {
          return opts.mkdirSync(path36, opts);
        } catch (er) {
          if (er.code !== "EISDIR")
            throw er;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path36, opts);
        return made || path36;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path36, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        try {
          if (!opts.statSync(path36).isDirectory())
            throw er;
        } catch (_) {
          throw er;
        }
      }
    };
    module2.exports = { mkdirpManual, mkdirpManualSync };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/mkdirp-native.js"(exports2, module2) {
    var { dirname: dirname3 } = require("path");
    var { findMade, findMadeSync } = require_find_made();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var mkdirpNative = (path36, opts) => {
      opts.recursive = true;
      const parent = dirname3(path36);
      if (parent === path36)
        return opts.mkdirAsync(path36, opts);
      return findMade(opts, path36).then((made) => opts.mkdirAsync(path36, opts).then(() => made).catch((er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(path36, opts);
        else
          throw er;
      }));
    };
    var mkdirpNativeSync = (path36, opts) => {
      opts.recursive = true;
      const parent = dirname3(path36);
      if (parent === path36)
        return opts.mkdirSync(path36, opts);
      const made = findMadeSync(opts, path36);
      try {
        opts.mkdirSync(path36, opts);
        return made;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path36, opts);
        else
          throw er;
      }
    };
    module2.exports = { mkdirpNative, mkdirpNativeSync };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/use-native.js"(exports2, module2) {
    var fs27 = require("fs");
    var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version2.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs27.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs27.mkdirSync;
    module2.exports = { useNative, useNativeSync };
  }
});

// node_modules/tar/node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/tar/node_modules/mkdirp/index.js"(exports2, module2) {
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var { useNative, useNativeSync } = require_use_native();
    var mkdirp = (path36, opts) => {
      path36 = pathArg(path36);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path36, opts) : mkdirpManual(path36, opts);
    };
    var mkdirpSync = (path36, opts) => {
      path36 = pathArg(path36);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path36, opts) : mkdirpManualSync(path36, opts);
    };
    mkdirp.sync = mkdirpSync;
    mkdirp.native = (path36, opts) => mkdirpNative(pathArg(path36), optsArg(opts));
    mkdirp.manual = (path36, opts) => mkdirpManual(pathArg(path36), optsArg(opts));
    mkdirp.nativeSync = (path36, opts) => mkdirpNativeSync(pathArg(path36), optsArg(opts));
    mkdirp.manualSync = (path36, opts) => mkdirpManualSync(pathArg(path36), optsArg(opts));
    module2.exports = mkdirp;
  }
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/chownr/chownr.js"(exports2, module2) {
    "use strict";
    var fs27 = require("fs");
    var path36 = require("path");
    var LCHOWN = fs27.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs27.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs27.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path37, uid, gid) => {
      try {
        return fs27[LCHOWNSYNC](path37, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync = (path37, uid, gid) => {
      try {
        return fs27.chownSync(path37, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path37, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs27.chown(path37, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path37, uid, gid) => {
      try {
        return lchownSync(path37, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync(path37, uid, gid);
      }
    } : (path37, uid, gid) => lchownSync(path37, uid, gid);
    var nodeVersion = process.version;
    var readdir = (path37, options, cb) => fs27.readdir(path37, options, cb);
    var readdirSync = (path37, options) => fs27.readdirSync(path37, options);
    if (/^v4\./.test(nodeVersion))
      readdir = (path37, options, cb) => fs27.readdir(path37, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs27[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs27.lstat(path36.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path36.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path36.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path36.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir(p, { withFileTypes: true }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs27.lstatSync(path36.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path36.resolve(p, child.name), uid, gid);
      handleEISDirSync(path36.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync(p, { withFileTypes: true });
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS({
  "node_modules/tar/lib/mkdir.js"(exports2, module2) {
    "use strict";
    var mkdirp = require_mkdirp();
    var fs27 = require("fs");
    var path36 = require("path");
    var chownr = require_chownr();
    var normPath = require_normalize_windows_path();
    var SymlinkError = class extends Error {
      constructor(symlink, path37) {
        super("Cannot extract through symbolic link");
        this.path = path37;
        this.symlink = symlink;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path37, code) {
        super(code + ": Cannot cd into '" + path37 + "'");
        this.path = path37;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var cGet = (cache, key) => cache.get(normPath(key));
    var cSet = (cache, key, val) => cache.set(normPath(key), val);
    var checkCwd = (dir, cb) => {
      fs27.stat(dir, (er, st) => {
        if (er || !st.isDirectory())
          er = new CwdError(dir, er && er.code || "ENOTDIR");
        cb(er);
      });
    };
    module2.exports = (dir, opt, cb) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd = normPath(opt.cwd);
      const done = (er, created) => {
        if (er)
          cb(er);
        else {
          cSet(cache, dir, true);
          if (created && doChown)
            chownr(created, uid, gid, (er2) => done(er2));
          else if (needChmod)
            fs27.chmod(dir, mode, cb);
          else
            cb();
        }
      };
      if (cache && cGet(cache, dir) === true)
        return done();
      if (dir === cwd)
        return checkCwd(dir, done);
      if (preserve)
        return mkdirp(dir, { mode }).then((made) => done(null, made), done);
      const sub = normPath(path36.relative(cwd, dir));
      const parts = sub.split("/");
      mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);
    };
    var mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
      if (!parts.length)
        return cb(null, created);
      const p = parts.shift();
      const part = normPath(path36.resolve(base + "/" + p));
      if (cGet(cache, part))
        return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      fs27.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
    };
    var onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
      if (er) {
        fs27.lstat(part, (statEr, st) => {
          if (statEr) {
            statEr.path = statEr.path && normPath(statEr.path);
            cb(statEr);
          } else if (st.isDirectory())
            mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
          else if (unlink) {
            fs27.unlink(part, (er2) => {
              if (er2)
                return cb(er2);
              fs27.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
            });
          } else if (st.isSymbolicLink())
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          else
            cb(er);
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      }
    };
    var checkCwdSync = (dir) => {
      let ok = false;
      let code = "ENOTDIR";
      try {
        ok = fs27.statSync(dir).isDirectory();
      } catch (er) {
        code = er.code;
      } finally {
        if (!ok)
          throw new CwdError(dir, code);
      }
    };
    module2.exports.sync = (dir, opt) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd = normPath(opt.cwd);
      const done = (created2) => {
        cSet(cache, dir, true);
        if (created2 && doChown)
          chownr.sync(created2, uid, gid);
        if (needChmod)
          fs27.chmodSync(dir, mode);
      };
      if (cache && cGet(cache, dir) === true)
        return done();
      if (dir === cwd) {
        checkCwdSync(cwd);
        return done();
      }
      if (preserve)
        return done(mkdirp.sync(dir, mode));
      const sub = normPath(path36.relative(cwd, dir));
      const parts = sub.split("/");
      let created = null;
      for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift()) {
        part = normPath(path36.resolve(part));
        if (cGet(cache, part))
          continue;
        try {
          fs27.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
        } catch (er) {
          const st = fs27.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache, part, true);
            continue;
          } else if (unlink) {
            fs27.unlinkSync(part);
            fs27.mkdirSync(part, mode);
            created = created || part;
            cSet(cache, part, true);
            continue;
          } else if (st.isSymbolicLink())
            return new SymlinkError(part, part + "/" + parts.join("/"));
        }
      }
      return done(created);
    };
  }
});

// node_modules/tar/lib/normalize-unicode.js
var require_normalize_unicode = __commonJS({
  "node_modules/tar/lib/normalize-unicode.js"(exports2, module2) {
    var normalizeCache = Object.create(null);
    var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
    module2.exports = (s) => {
      if (!hasOwnProperty3.call(normalizeCache, s))
        normalizeCache[s] = s.normalize("NFKD");
      return normalizeCache[s];
    };
  }
});

// node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS({
  "node_modules/tar/lib/path-reservations.js"(exports2, module2) {
    var assert = require("assert");
    var normalize = require_normalize_unicode();
    var stripSlashes = require_strip_trailing_slashes();
    var { join: join2 } = require("path");
    var platform3 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows4 = platform3 === "win32";
    module2.exports = () => {
      const queues = new Map();
      const reservations = new Map();
      const getDirs = (path36) => {
        const dirs = path36.split("/").slice(0, -1).reduce((set, path37) => {
          if (set.length)
            path37 = join2(set[set.length - 1], path37);
          set.push(path37 || "/");
          return set;
        }, []);
        return dirs;
      };
      const running = new Set();
      const getQueues = (fn) => {
        const res = reservations.get(fn);
        if (!res)
          throw new Error("function does not have any path reservations");
        return {
          paths: res.paths.map((path36) => queues.get(path36)),
          dirs: [...res.dirs].map((path36) => queues.get(path36))
        };
      };
      const check = (fn) => {
        const { paths, dirs } = getQueues(fn);
        return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
      };
      const run = (fn) => {
        if (running.has(fn) || !check(fn))
          return false;
        running.add(fn);
        fn(() => clear(fn));
        return true;
      };
      const clear = (fn) => {
        if (!running.has(fn))
          return false;
        const { paths, dirs } = reservations.get(fn);
        const next = new Set();
        paths.forEach((path36) => {
          const q = queues.get(path36);
          assert.equal(q[0], fn);
          if (q.length === 1)
            queues.delete(path36);
          else {
            q.shift();
            if (typeof q[0] === "function")
              next.add(q[0]);
            else
              q[0].forEach((fn2) => next.add(fn2));
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          assert(q[0] instanceof Set);
          if (q[0].size === 1 && q.length === 1)
            queues.delete(dir);
          else if (q[0].size === 1) {
            q.shift();
            next.add(q[0]);
          } else
            q[0].delete(fn);
        });
        running.delete(fn);
        next.forEach((fn2) => run(fn2));
        return true;
      };
      const reserve = (paths, fn) => {
        paths = isWindows4 ? ["win32 parallelization disabled"] : paths.map((p) => {
          return normalize(stripSlashes(join2(p))).toLowerCase();
        });
        const dirs = new Set(paths.map((path36) => getDirs(path36)).reduce((a, b) => a.concat(b)));
        reservations.set(fn, { dirs, paths });
        paths.forEach((path36) => {
          const q = queues.get(path36);
          if (!q)
            queues.set(path36, [fn]);
          else
            q.push(fn);
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          if (!q)
            queues.set(dir, [new Set([fn])]);
          else if (q[q.length - 1] instanceof Set)
            q[q.length - 1].add(fn);
          else
            q.push(new Set([fn]));
        });
        return run(fn);
      };
      return { check, reserve };
    };
  }
});

// node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS({
  "node_modules/tar/lib/get-write-flag.js"(exports2, module2) {
    var platform3 = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows4 = platform3 === "win32";
    var fs27 = global.__FAKE_TESTING_FS__ || require("fs");
    var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs27.constants;
    var fMapEnabled = isWindows4 && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
  }
});

// node_modules/tar/lib/unpack.js
var require_unpack = __commonJS({
  "node_modules/tar/lib/unpack.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var Parser = require_parse2();
    var fs27 = require("fs");
    var fsm = require_fs_minipass();
    var path36 = require("path");
    var mkdir = require_mkdir();
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var stripAbsolutePath = require_strip_absolute_path();
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var normalize = require_normalize_unicode();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var PRUNECACHE = Symbol("pruneCache");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var CHECKED_CWD = Symbol("checkedCwd");
    var crypto2 = require("crypto");
    var getFlag = require_get_write_flag();
    var platform3 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows4 = platform3 === "win32";
    var unlinkFile = (path37, cb) => {
      if (!isWindows4)
        return fs27.unlink(path37, cb);
      const name2 = path37 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
      fs27.rename(path37, name2, (er) => {
        if (er)
          return cb(er);
        fs27.unlink(name2, cb);
      });
    };
    var unlinkFileSync = (path37) => {
      if (!isWindows4)
        return fs27.unlinkSync(path37);
      const name2 = path37 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
      fs27.renameSync(path37, name2);
      fs27.unlinkSync(name2);
    };
    var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
    var cacheKeyNormalize = (path37) => normalize(stripSlash(normPath(path37))).toLowerCase();
    var pruneCache = (cache, abs) => {
      abs = cacheKeyNormalize(abs);
      for (const path37 of cache.keys()) {
        const pnorm = cacheKeyNormalize(path37);
        if (pnorm === abs || pnorm.indexOf(abs + "/") === 0)
          cache.delete(path37);
      }
    };
    var dropCache = (cache) => {
      for (const key of cache.keys())
        cache.delete(key);
    };
    var Unpack = class extends Parser {
      constructor(opt) {
        if (!opt)
          opt = {};
        opt.ondone = (_) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this[CHECKED_CWD] = false;
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number")
            throw new TypeError("cannot set owner without number uid and gid");
          if (opt.preserveOwner) {
            throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
          }
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number")
          this.preserveOwner = process.getuid && process.getuid() === 0;
        else
          this.preserveOwner = !!opt.preserveOwner;
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || isWindows4;
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = normPath(path36.resolve(opt.cwd || process.cwd()));
        this.strip = +opt.strip || 0;
        this.processUmask = opt.noChmod ? 0 : process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      warn(code, msg, data = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT")
          data.recoverable = false;
        return super.warn(code, msg, data);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
          this.emit("close");
        }
      }
      [CHECKPATH](entry) {
        if (this.strip) {
          const parts = normPath(entry.path).split("/");
          if (parts.length < this.strip)
            return false;
          entry.path = parts.slice(this.strip).join("/");
          if (entry.type === "Link") {
            const linkparts = normPath(entry.linkpath).split("/");
            if (linkparts.length >= this.strip)
              entry.linkpath = linkparts.slice(this.strip).join("/");
            else
              return false;
          }
        }
        if (!this.preservePaths) {
          const p = normPath(entry.path);
          const parts = p.split("/");
          if (parts.includes("..") || isWindows4 && /^[a-z]:\.\.$/i.test(parts[0])) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p
            });
            return false;
          }
          const [root, stripped] = stripAbsolutePath(p);
          if (root) {
            entry.path = stripped;
            this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
              entry,
              path: p
            });
          }
        }
        if (path36.isAbsolute(entry.path))
          entry.absolute = normPath(path36.resolve(entry.path));
        else
          entry.absolute = normPath(path36.resolve(this.cwd, entry.path));
        if (!this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
          this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
            entry,
            path: normPath(entry.path),
            resolvedPath: entry.absolute,
            cwd: this.cwd
          });
          return false;
        }
        if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir")
          return false;
        if (this.win32) {
          const { root: aRoot } = path36.win32.parse(entry.absolute);
          entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length));
          const { root: pRoot } = path36.win32.parse(entry.path);
          entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length));
        }
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry))
          return entry.resume();
        assert.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode)
              entry.mode = entry.mode | 448;
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
          default:
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er, entry) {
        if (er.name === "CwdError")
          this.emit("error", er);
        else {
          this.warn("TAR_ENTRY_ERROR", er, { entry });
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode,
          noChmod: this.noChmod
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream.on("error", (er) => {
          if (stream.fd)
            fs27.close(stream.fd, () => {
            });
          stream.write = () => true;
          this[ONERROR](er, entry);
          fullyDone();
        });
        let actions = 1;
        const done = (er) => {
          if (er) {
            if (stream.fd)
              fs27.close(stream.fd, () => {
              });
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          if (--actions === 0) {
            fs27.close(stream.fd, (er2) => {
              if (er2)
                this[ONERROR](er2, entry);
              else
                this[UNPEND]();
              fullyDone();
            });
          }
        };
        stream.on("finish", (_) => {
          const abs = entry.absolute;
          const fd = stream.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            fs27.futimes(fd, atime, mtime, (er) => er ? fs27.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs27.fchown(fd, uid, gid, (er) => er ? fs27.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => {
            this[ONERROR](er, entry);
            fullyDone();
          });
          entry.pipe(tx);
        }
        tx.pipe(stream);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          let actions = 1;
          const done = (_) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs27.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs27.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, { entry });
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        const linkpath = normPath(path36.resolve(this.cwd, entry.linkpath));
        this[LINK](entry, linkpath, "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows4;
      }
      [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath)
          paths.push(entry.linkpath);
        this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
      }
      [PRUNECACHE](entry) {
        if (entry.type === "SymbolicLink")
          dropCache(this.dirCache);
        else if (entry.type !== "Directory")
          pruneCache(this.dirCache, entry.absolute);
      }
      [CHECKFS2](entry, fullyDone) {
        this[PRUNECACHE](entry);
        const done = (er) => {
          this[PRUNECACHE](entry);
          fullyDone(er);
        };
        const checkCwd = () => {
          this[MKDIR](this.cwd, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            this[CHECKED_CWD] = true;
            start();
          });
        };
        const start = () => {
          if (entry.absolute !== this.cwd) {
            const parent = normPath(path36.dirname(entry.absolute));
            if (parent !== this.cwd) {
              return this[MKDIR](parent, this.dmode, (er) => {
                if (er) {
                  this[ONERROR](er, entry);
                  done();
                  return;
                }
                afterMakeParent();
              });
            }
          }
          afterMakeParent();
        };
        const afterMakeParent = () => {
          fs27.lstat(entry.absolute, (lstatEr, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
              return;
            }
            if (lstatEr || this[ISREUSABLE](entry, st))
              return this[MAKEFS](null, entry, done);
            if (st.isDirectory()) {
              if (entry.type === "Directory") {
                const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
                const afterChmod = (er) => this[MAKEFS](er, entry, done);
                if (!needChmod)
                  return afterChmod();
                return fs27.chmod(entry.absolute, entry.mode, afterChmod);
              }
              if (entry.absolute !== this.cwd) {
                return fs27.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
              }
            }
            if (entry.absolute === this.cwd)
              return this[MAKEFS](null, entry, done);
            unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
          });
        };
        if (this[CHECKED_CWD])
          start();
        else
          checkCwd();
      }
      [MAKEFS](er, entry, done) {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link, done) {
        fs27[link](linkpath, entry.absolute, (er) => {
          if (er)
            this[ONERROR](er, entry);
          else {
            this[UNPEND]();
            entry.resume();
          }
          done();
        });
      }
    };
    var callSync = (fn) => {
      try {
        return [null, fn()];
      } catch (er) {
        return [er, null];
      }
    };
    var UnpackSync = class extends Unpack {
      [MAKEFS](er, entry) {
        return super[MAKEFS](er, entry, () => {
        });
      }
      [CHECKFS](entry) {
        this[PRUNECACHE](entry);
        if (!this[CHECKED_CWD]) {
          const er2 = this[MKDIR](this.cwd, this.dmode);
          if (er2)
            return this[ONERROR](er2, entry);
          this[CHECKED_CWD] = true;
        }
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path36.dirname(entry.absolute));
          if (parent !== this.cwd) {
            const mkParent = this[MKDIR](parent, this.dmode);
            if (mkParent)
              return this[ONERROR](mkParent, entry);
          }
        }
        const [lstatEr, st] = callSync(() => fs27.lstatSync(entry.absolute));
        if (st && (this.keep || this.newer && st.mtime > entry.mtime))
          return this[SKIP](entry);
        if (lstatEr || this[ISREUSABLE](entry, st))
          return this[MAKEFS](null, entry);
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const [er3] = needChmod ? callSync(() => {
              fs27.chmodSync(entry.absolute, entry.mode);
            }) : [];
            return this[MAKEFS](er3, entry);
          }
          const [er2] = callSync(() => fs27.rmdirSync(entry.absolute));
          this[MAKEFS](er2, entry);
        }
        const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
        this[MAKEFS](er, entry);
      }
      [FILE](entry, done) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er) => {
          let closeError;
          try {
            fs27.closeSync(fd);
          } catch (e) {
            closeError = e;
          }
          if (er || closeError)
            this[ONERROR](er || closeError, entry);
          done();
        };
        let fd;
        try {
          fd = fs27.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er) {
          return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs27.writeSync(fd, chunk, 0, chunk.length);
          } catch (er) {
            oner(er);
          }
        });
        tx.on("end", (_) => {
          let er = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            try {
              fs27.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs27.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs27.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs27.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er = er || fchowner;
              }
            }
          }
          oner(er);
        });
      }
      [DIRECTORY](entry, done) {
        const mode = entry.mode & 4095 || this.dmode;
        const er = this[MKDIR](entry.absolute, mode);
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        if (entry.mtime && !this.noMtime) {
          try {
            fs27.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
          } catch (er2) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs27.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er2) {
          }
        }
        done();
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir.sync(normPath(dir), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er) {
          return er;
        }
      }
      [LINK](entry, linkpath, link, done) {
        try {
          fs27[link + "Sync"](linkpath, entry.absolute);
          done();
          entry.resume();
        } catch (er) {
          return this[ONERROR](er, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module2.exports = Unpack;
  }
});

// node_modules/tar/lib/extract.js
var require_extract = __commonJS({
  "node_modules/tar/lib/extract.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs27 = require("fs");
    var fsm = require_fs_minipass();
    var path36 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function")
        cb = opt_, files = null, opt_ = {};
      else if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (typeof files === "function")
        cb = files, files = null;
      if (!files)
        files = [];
      else
        files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      if (files.length)
        filesFilter(opt, files);
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path36.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path36.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var extractFileSync = (opt) => {
      const u = new Unpack.Sync(opt);
      const file = opt.file;
      const stat = fs27.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat.size
      });
      stream.pipe(u);
    };
    var extractFile = (opt, cb) => {
      const u = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve3, reject) => {
        u.on("error", reject);
        u.on("close", resolve3);
        fs27.stat(file, (er, stat) => {
          if (er)
            reject(er);
          else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(u);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var extractSync = (opt) => new Unpack.Sync(opt);
    var extract = (opt) => new Unpack(opt);
  }
});

// node_modules/tar/index.js
var require_tar = __commonJS({
  "node_modules/tar/index.js"(exports2) {
    "use strict";
    exports2.c = exports2.create = require_create();
    exports2.r = exports2.replace = require_replace();
    exports2.t = exports2.list = require_list();
    exports2.u = exports2.update = require_update();
    exports2.x = exports2.extract = require_extract();
    exports2.Pack = require_pack();
    exports2.Unpack = require_unpack();
    exports2.Parse = require_parse2();
    exports2.ReadEntry = require_read_entry();
    exports2.WriteEntry = require_write_entry();
    exports2.Header = require_header();
    exports2.Pax = require_pax();
    exports2.types = require_types2();
  }
});

// node_modules/traverse/index.js
var require_traverse = __commonJS({
  "node_modules/traverse/index.js"(exports2, module2) {
    module2.exports = Traverse;
    function Traverse(obj) {
      if (!(this instanceof Traverse))
        return new Traverse(obj);
      this.value = obj;
    }
    Traverse.prototype.get = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
          node = void 0;
          break;
        }
        node = node[key];
      }
      return node;
    };
    Traverse.prototype.set = function(ps, value) {
      var node = this.value;
      for (var i = 0; i < ps.length - 1; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key))
          node[key] = {};
        node = node[key];
      }
      node[ps[i]] = value;
      return value;
    };
    Traverse.prototype.map = function(cb) {
      return walk2(this.value, cb, true);
    };
    Traverse.prototype.forEach = function(cb) {
      this.value = walk2(this.value, cb, false);
      return this.value;
    };
    Traverse.prototype.reduce = function(cb, init) {
      var skip = arguments.length === 1;
      var acc = skip ? this.value : init;
      this.forEach(function(x) {
        if (!this.isRoot || !skip) {
          acc = cb.call(this, acc, x);
        }
      });
      return acc;
    };
    Traverse.prototype.deepEqual = function(obj) {
      if (arguments.length !== 1) {
        throw new Error("deepEqual requires exactly one object to compare against");
      }
      var equal = true;
      var node = obj;
      this.forEach(function(y) {
        var notEqual = function() {
          equal = false;
          return void 0;
        }.bind(this);
        if (!this.isRoot) {
          if (typeof node !== "object")
            return notEqual();
          node = node[this.key];
        }
        var x = node;
        this.post(function() {
          node = x;
        });
        var toS = function(o) {
          return Object.prototype.toString.call(o);
        };
        if (this.circular) {
          if (Traverse(obj).get(this.circular.path) !== x)
            notEqual();
        } else if (typeof x !== typeof y) {
          notEqual();
        } else if (x === null || y === null || x === void 0 || y === void 0) {
          if (x !== y)
            notEqual();
        } else if (x.__proto__ !== y.__proto__) {
          notEqual();
        } else if (x === y) {
        } else if (typeof x === "function") {
          if (x instanceof RegExp) {
            if (x.toString() != y.toString())
              notEqual();
          } else if (x !== y)
            notEqual();
        } else if (typeof x === "object") {
          if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
            if (toS(x) !== toS(y)) {
              notEqual();
            }
          } else if (x instanceof Date || y instanceof Date) {
            if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
              notEqual();
            }
          } else {
            var kx = Object.keys(x);
            var ky = Object.keys(y);
            if (kx.length !== ky.length)
              return notEqual();
            for (var i = 0; i < kx.length; i++) {
              var k = kx[i];
              if (!Object.hasOwnProperty.call(y, k)) {
                notEqual();
              }
            }
          }
        }
      });
      return equal;
    };
    Traverse.prototype.paths = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.path);
      });
      return acc;
    };
    Traverse.prototype.nodes = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.node);
      });
      return acc;
    };
    Traverse.prototype.clone = function() {
      var parents = [], nodes = [];
      return function clone(src) {
        for (var i = 0; i < parents.length; i++) {
          if (parents[i] === src) {
            return nodes[i];
          }
        }
        if (typeof src === "object" && src !== null) {
          var dst = copy(src);
          parents.push(src);
          nodes.push(dst);
          Object.keys(src).forEach(function(key) {
            dst[key] = clone(src[key]);
          });
          parents.pop();
          nodes.pop();
          return dst;
        } else {
          return src;
        }
      }(this.value);
    };
    function walk2(root, cb, immutable) {
      var path36 = [];
      var parents = [];
      var alive = true;
      return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var state = {
          node,
          node_,
          path: [].concat(path36),
          parent: parents.slice(-1)[0],
          key: path36.slice(-1)[0],
          isRoot: path36.length === 0,
          level: path36.length,
          circular: null,
          update: function(x) {
            if (!state.isRoot) {
              state.parent.node[state.key] = x;
            }
            state.node = x;
          },
          "delete": function() {
            delete state.parent.node[state.key];
          },
          remove: function() {
            if (Array.isArray(state.parent.node)) {
              state.parent.node.splice(state.key, 1);
            } else {
              delete state.parent.node[state.key];
            }
          },
          before: function(f) {
            modifiers.before = f;
          },
          after: function(f) {
            modifiers.after = f;
          },
          pre: function(f) {
            modifiers.pre = f;
          },
          post: function(f) {
            modifiers.post = f;
          },
          stop: function() {
            alive = false;
          }
        };
        if (!alive)
          return state;
        if (typeof node === "object" && node !== null) {
          state.isLeaf = Object.keys(node).length == 0;
          for (var i = 0; i < parents.length; i++) {
            if (parents[i].node_ === node_) {
              state.circular = parents[i];
              break;
            }
          }
        } else {
          state.isLeaf = true;
        }
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        var ret = cb.call(state, state.node);
        if (ret !== void 0 && state.update)
          state.update(ret);
        if (modifiers.before)
          modifiers.before.call(state, state.node);
        if (typeof state.node == "object" && state.node !== null && !state.circular) {
          parents.push(state);
          var keys = Object.keys(state.node);
          keys.forEach(function(key, i2) {
            path36.push(key);
            if (modifiers.pre)
              modifiers.pre.call(state, state.node[key], key);
            var child = walker(state.node[key]);
            if (immutable && Object.hasOwnProperty.call(state.node, key)) {
              state.node[key] = child.node;
            }
            child.isLast = i2 == keys.length - 1;
            child.isFirst = i2 == 0;
            if (modifiers.post)
              modifiers.post.call(state, child);
            path36.pop();
          });
          parents.pop();
        }
        if (modifiers.after)
          modifiers.after.call(state, state.node);
        return state;
      }(root).node;
    }
    Object.keys(Traverse.prototype).forEach(function(key) {
      Traverse[key] = function(obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
      };
    });
    function copy(src) {
      if (typeof src === "object" && src !== null) {
        var dst;
        if (Array.isArray(src)) {
          dst = [];
        } else if (src instanceof Date) {
          dst = new Date(src);
        } else if (src instanceof Boolean) {
          dst = new Boolean(src);
        } else if (src instanceof Number) {
          dst = new Number(src);
        } else if (src instanceof String) {
          dst = new String(src);
        } else {
          dst = Object.create(Object.getPrototypeOf(src));
        }
        Object.keys(src).forEach(function(key) {
          dst[key] = src[key];
        });
        return dst;
      } else
        return src;
    }
  }
});

// node_modules/chainsaw/index.js
var require_chainsaw = __commonJS({
  "node_modules/chainsaw/index.js"(exports2, module2) {
    var Traverse = require_traverse();
    var EventEmitter8 = require("events").EventEmitter;
    module2.exports = Chainsaw;
    function Chainsaw(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0)
        saw.handlers = r;
      saw.record();
      return saw.chain();
    }
    Chainsaw.light = function ChainsawLight(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0)
        saw.handlers = r;
      return saw.chain();
    };
    Chainsaw.saw = function(builder, handlers) {
      var saw = new EventEmitter8();
      saw.handlers = handlers;
      saw.actions = [];
      saw.chain = function() {
        var ch = Traverse(saw.handlers).map(function(node) {
          if (this.isRoot)
            return node;
          var ps = this.path;
          if (typeof node === "function") {
            this.update(function() {
              saw.actions.push({
                path: ps,
                args: [].slice.call(arguments)
              });
              return ch;
            });
          }
        });
        process.nextTick(function() {
          saw.emit("begin");
          saw.next();
        });
        return ch;
      };
      saw.pop = function() {
        return saw.actions.shift();
      };
      saw.next = function() {
        var action = saw.pop();
        if (!action) {
          saw.emit("end");
        } else if (!action.trap) {
          var node = saw.handlers;
          action.path.forEach(function(key) {
            node = node[key];
          });
          node.apply(saw.handlers, action.args);
        }
      };
      saw.nest = function(cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;
        if (typeof cb === "boolean") {
          var autonext = cb;
          cb = args.shift();
        }
        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);
        if (r !== void 0)
          s.handlers = r;
        if (typeof saw.step !== "undefined") {
          s.record();
        }
        cb.apply(s.chain(), args);
        if (autonext !== false)
          s.on("end", saw.next);
      };
      saw.record = function() {
        upgradeChainsaw(saw);
      };
      ["trap", "down", "jump"].forEach(function(method) {
        saw[method] = function() {
          throw new Error("To use the trap, down and jump features, please call record() first to start recording actions.");
        };
      });
      return saw;
    };
    function upgradeChainsaw(saw) {
      saw.step = 0;
      saw.pop = function() {
        return saw.actions[saw.step++];
      };
      saw.trap = function(name2, cb) {
        var ps = Array.isArray(name2) ? name2 : [name2];
        saw.actions.push({
          path: ps,
          step: saw.step,
          cb,
          trap: true
        });
      };
      saw.down = function(name2) {
        var ps = (Array.isArray(name2) ? name2 : [name2]).join("/");
        var i = saw.actions.slice(saw.step).map(function(x) {
          if (x.trap && x.step <= saw.step)
            return false;
          return x.path.join("/") == ps;
        }).indexOf(true);
        if (i >= 0)
          saw.step += i;
        else
          saw.step = saw.actions.length;
        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
          saw.step = act.step;
          act.cb();
        } else
          saw.next();
      };
      saw.jump = function(step) {
        saw.step = step;
        saw.next();
      };
    }
  }
});

// node_modules/buffers/index.js
var require_buffers = __commonJS({
  "node_modules/buffers/index.js"(exports2, module2) {
    module2.exports = Buffers;
    function Buffers(bufs) {
      if (!(this instanceof Buffers))
        return new Buffers(bufs);
      this.buffers = bufs || [];
      this.length = this.buffers.reduce(function(size, buf) {
        return size + buf.length;
      }, 0);
    }
    Buffers.prototype.push = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to push a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.push(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.unshift = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to unshift a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.unshift(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.copy = function(dst, dStart, start, end) {
      return this.slice(start, end).copy(dst, dStart, 0, end - start);
    };
    Buffers.prototype.splice = function(i, howMany) {
      var buffers = this.buffers;
      var index = i >= 0 ? i : this.length - i;
      var reps = [].slice.call(arguments, 2);
      if (howMany === void 0) {
        howMany = this.length - index;
      } else if (howMany > this.length - index) {
        howMany = this.length - index;
      }
      for (var i = 0; i < reps.length; i++) {
        this.length += reps[i].length;
      }
      var removed = new Buffers();
      var bytes2 = 0;
      var startBytes = 0;
      for (var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
        startBytes += buffers[ii].length;
      }
      if (index - startBytes > 0) {
        var start = index - startBytes;
        if (start + howMany < buffers[ii].length) {
          removed.push(buffers[ii].slice(start, start + howMany));
          var orig = buffers[ii];
          var buf0 = new Buffer(start);
          for (var i = 0; i < start; i++) {
            buf0[i] = orig[i];
          }
          var buf1 = new Buffer(orig.length - start - howMany);
          for (var i = start + howMany; i < orig.length; i++) {
            buf1[i - howMany - start] = orig[i];
          }
          if (reps.length > 0) {
            var reps_ = reps.slice();
            reps_.unshift(buf0);
            reps_.push(buf1);
            buffers.splice.apply(buffers, [ii, 1].concat(reps_));
            ii += reps_.length;
            reps = [];
          } else {
            buffers.splice(ii, 1, buf0, buf1);
            ii += 2;
          }
        } else {
          removed.push(buffers[ii].slice(start));
          buffers[ii] = buffers[ii].slice(0, start);
          ii++;
        }
      }
      if (reps.length > 0) {
        buffers.splice.apply(buffers, [ii, 0].concat(reps));
        ii += reps.length;
      }
      while (removed.length < howMany) {
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);
        if (take === len) {
          removed.push(buf);
          buffers.splice(ii, 1);
        } else {
          removed.push(buf.slice(0, take));
          buffers[ii] = buffers[ii].slice(take);
        }
      }
      this.length -= removed.length;
      return removed;
    };
    Buffers.prototype.slice = function(i, j) {
      var buffers = this.buffers;
      if (j === void 0)
        j = this.length;
      if (i === void 0)
        i = 0;
      if (j > this.length)
        j = this.length;
      var startBytes = 0;
      for (var si = 0; si < buffers.length && startBytes + buffers[si].length <= i; si++) {
        startBytes += buffers[si].length;
      }
      var target = new Buffer(j - i);
      var ti = 0;
      for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
        var len = buffers[ii].length;
        var start = ti === 0 ? i - startBytes : 0;
        var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
        buffers[ii].copy(target, ti, start, end);
        ti += end - start;
      }
      return target;
    };
    Buffers.prototype.pos = function(i) {
      if (i < 0 || i >= this.length)
        throw new Error("oob");
      var l = i, bi = 0, bu = null;
      for (; ; ) {
        bu = this.buffers[bi];
        if (l < bu.length) {
          return { buf: bi, offset: l };
        } else {
          l -= bu.length;
        }
        bi++;
      }
    };
    Buffers.prototype.get = function get(i) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].get(pos.offset);
    };
    Buffers.prototype.set = function set(i, b) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].set(pos.offset, b);
    };
    Buffers.prototype.indexOf = function(needle, offset) {
      if (typeof needle === "string") {
        needle = new Buffer(needle);
      } else if (needle instanceof Buffer) {
      } else {
        throw new Error("Invalid type for a search string");
      }
      if (!needle.length) {
        return 0;
      }
      if (!this.length) {
        return -1;
      }
      var i = 0, j = 0, match = 0, mstart, pos = 0;
      if (offset) {
        var p = this.pos(offset);
        i = p.buf;
        j = p.offset;
        pos = offset;
      }
      for (; ; ) {
        while (j >= this.buffers[i].length) {
          j = 0;
          i++;
          if (i >= this.buffers.length) {
            return -1;
          }
        }
        var char = this.buffers[i][j];
        if (char == needle[match]) {
          if (match == 0) {
            mstart = {
              i,
              j,
              pos
            };
          }
          match++;
          if (match == needle.length) {
            return mstart.pos;
          }
        } else if (match != 0) {
          i = mstart.i;
          j = mstart.j;
          pos = mstart.pos;
          match = 0;
        }
        j++;
        pos++;
      }
    };
    Buffers.prototype.toBuffer = function() {
      return this.slice();
    };
    Buffers.prototype.toString = function(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
  }
});

// node_modules/binary/lib/vars.js
var require_vars = __commonJS({
  "node_modules/binary/lib/vars.js"(exports2, module2) {
    module2.exports = function(store) {
      function getset(name2, value) {
        var node = vars.store;
        var keys = name2.split(".");
        keys.slice(0, -1).forEach(function(k) {
          if (node[k] === void 0)
            node[k] = {};
          node = node[k];
        });
        var key = keys[keys.length - 1];
        if (arguments.length == 1) {
          return node[key];
        } else {
          return node[key] = value;
        }
      }
      var vars = {
        get: function(name2) {
          return getset(name2);
        },
        set: function(name2, value) {
          return getset(name2, value);
        },
        store: store || {}
      };
      return vars;
    };
  }
});

// node_modules/binary/index.js
var require_binary = __commonJS({
  "node_modules/binary/index.js"(exports2, module2) {
    var Chainsaw = require_chainsaw();
    var EventEmitter8 = require("events").EventEmitter;
    var Buffers = require_buffers();
    var Vars = require_vars();
    var Stream = require("stream").Stream;
    exports2 = module2.exports = function(bufOrEm, eventName) {
      if (Buffer.isBuffer(bufOrEm)) {
        return exports2.parse(bufOrEm);
      }
      var s = exports2.stream();
      if (bufOrEm && bufOrEm.pipe) {
        bufOrEm.pipe(s);
      } else if (bufOrEm) {
        bufOrEm.on(eventName || "data", function(buf) {
          s.write(buf);
        });
        bufOrEm.on("end", function() {
          s.end();
        });
      }
      return s;
    };
    exports2.stream = function(input) {
      if (input)
        return exports2.apply(null, arguments);
      var pending = null;
      function getBytes(bytes2, cb, skip) {
        pending = {
          bytes: bytes2,
          skip,
          cb: function(buf) {
            pending = null;
            cb(buf);
          }
        };
        dispatch();
      }
      var offset = null;
      function dispatch() {
        if (!pending) {
          if (caughtEnd)
            done = true;
          return;
        }
        if (typeof pending === "function") {
          pending();
        } else {
          var bytes2 = offset + pending.bytes;
          if (buffers.length >= bytes2) {
            var buf;
            if (offset == null) {
              buf = buffers.splice(0, bytes2);
              if (!pending.skip) {
                buf = buf.slice();
              }
            } else {
              if (!pending.skip) {
                buf = buffers.slice(offset, bytes2);
              }
              offset = bytes2;
            }
            if (pending.skip) {
              pending.cb();
            } else {
              pending.cb(buf);
            }
          }
        }
      }
      function builder(saw) {
        function next() {
          if (!done)
            saw.next();
        }
        var self2 = words(function(bytes2, cb) {
          return function(name2) {
            getBytes(bytes2, function(buf) {
              vars.set(name2, cb(buf));
              next();
            });
          };
        });
        self2.tap = function(cb) {
          saw.nest(cb, vars.store);
        };
        self2.into = function(key, cb) {
          if (!vars.get(key))
            vars.set(key, {});
          var parent = vars;
          vars = Vars(parent.get(key));
          saw.nest(function() {
            cb.apply(this, arguments);
            this.tap(function() {
              vars = parent;
            });
          }, vars.store);
        };
        self2.flush = function() {
          vars.store = {};
          next();
        };
        self2.loop = function(cb) {
          var end = false;
          saw.nest(false, function loop() {
            this.vars = vars.store;
            cb.call(this, function() {
              end = true;
              next();
            }, vars.store);
            this.tap(function() {
              if (end)
                saw.next();
              else
                loop.call(this);
            }.bind(this));
          }, vars.store);
        };
        self2.buffer = function(name2, bytes2) {
          if (typeof bytes2 === "string") {
            bytes2 = vars.get(bytes2);
          }
          getBytes(bytes2, function(buf) {
            vars.set(name2, buf);
            next();
          });
        };
        self2.skip = function(bytes2) {
          if (typeof bytes2 === "string") {
            bytes2 = vars.get(bytes2);
          }
          getBytes(bytes2, function() {
            next();
          });
        };
        self2.scan = function find(name2, search) {
          if (typeof search === "string") {
            search = new Buffer(search);
          } else if (!Buffer.isBuffer(search)) {
            throw new Error("search must be a Buffer or a string");
          }
          var taken = 0;
          pending = function() {
            var pos = buffers.indexOf(search, offset + taken);
            var i = pos - offset - taken;
            if (pos !== -1) {
              pending = null;
              if (offset != null) {
                vars.set(name2, buffers.slice(offset, offset + taken + i));
                offset += taken + i + search.length;
              } else {
                vars.set(name2, buffers.slice(0, taken + i));
                buffers.splice(0, taken + i + search.length);
              }
              next();
              dispatch();
            } else {
              i = Math.max(buffers.length - search.length - offset - taken, 0);
            }
            taken += i;
          };
          dispatch();
        };
        self2.peek = function(cb) {
          offset = 0;
          saw.nest(function() {
            cb.call(this, vars.store);
            this.tap(function() {
              offset = null;
            });
          });
        };
        return self2;
      }
      ;
      var stream = Chainsaw.light(builder);
      stream.writable = true;
      var buffers = Buffers();
      stream.write = function(buf) {
        buffers.push(buf);
        dispatch();
      };
      var vars = Vars();
      var done = false, caughtEnd = false;
      stream.end = function() {
        caughtEnd = true;
      };
      stream.pipe = Stream.prototype.pipe;
      Object.getOwnPropertyNames(EventEmitter8.prototype).forEach(function(name2) {
        stream[name2] = EventEmitter8.prototype[name2];
      });
      return stream;
    };
    exports2.parse = function parse5(buffer) {
      var self2 = words(function(bytes2, cb) {
        return function(name2) {
          if (offset + bytes2 <= buffer.length) {
            var buf = buffer.slice(offset, offset + bytes2);
            offset += bytes2;
            vars.set(name2, cb(buf));
          } else {
            vars.set(name2, null);
          }
          return self2;
        };
      });
      var offset = 0;
      var vars = Vars();
      self2.vars = vars.store;
      self2.tap = function(cb) {
        cb.call(self2, vars.store);
        return self2;
      };
      self2.into = function(key, cb) {
        if (!vars.get(key)) {
          vars.set(key, {});
        }
        var parent = vars;
        vars = Vars(parent.get(key));
        cb.call(self2, vars.store);
        vars = parent;
        return self2;
      };
      self2.loop = function(cb) {
        var end = false;
        var ender = function() {
          end = true;
        };
        while (end === false) {
          cb.call(self2, ender, vars.store);
        }
        return self2;
      };
      self2.buffer = function(name2, size) {
        if (typeof size === "string") {
          size = vars.get(size);
        }
        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
        offset += size;
        vars.set(name2, buf);
        return self2;
      };
      self2.skip = function(bytes2) {
        if (typeof bytes2 === "string") {
          bytes2 = vars.get(bytes2);
        }
        offset += bytes2;
        return self2;
      };
      self2.scan = function(name2, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        vars.set(name2, null);
        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
          for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++)
            ;
          if (j === search.length)
            break;
        }
        vars.set(name2, buffer.slice(offset, offset + i));
        offset += i + search.length;
        return self2;
      };
      self2.peek = function(cb) {
        var was = offset;
        cb.call(self2, vars.store);
        offset = was;
        return self2;
      };
      self2.flush = function() {
        vars.store = {};
        return self2;
      };
      self2.eof = function() {
        return offset >= buffer.length;
      };
      return self2;
    };
    function decodeLEu(bytes2) {
      var acc = 0;
      for (var i = 0; i < bytes2.length; i++) {
        acc += Math.pow(256, i) * bytes2[i];
      }
      return acc;
    }
    function decodeBEu(bytes2) {
      var acc = 0;
      for (var i = 0; i < bytes2.length; i++) {
        acc += Math.pow(256, bytes2.length - i - 1) * bytes2[i];
      }
      return acc;
    }
    function decodeBEs(bytes2) {
      var val = decodeBEu(bytes2);
      if ((bytes2[0] & 128) == 128) {
        val -= Math.pow(256, bytes2.length);
      }
      return val;
    }
    function decodeLEs(bytes2) {
      var val = decodeLEu(bytes2);
      if ((bytes2[bytes2.length - 1] & 128) == 128) {
        val -= Math.pow(256, bytes2.length);
      }
      return val;
    }
    function words(decode) {
      var self2 = {};
      [1, 2, 4, 8].forEach(function(bytes2) {
        var bits = bytes2 * 8;
        self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes2, decodeLEu);
        self2["word" + bits + "ls"] = decode(bytes2, decodeLEs);
        self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes2, decodeBEu);
        self2["word" + bits + "bs"] = decode(bytes2, decodeBEs);
      });
      self2.word8 = self2.word8u = self2.word8be;
      self2.word8s = self2.word8bs;
      return self2;
    }
  }
});

// node_modules/unzip-stream/lib/matcher-stream.js
var require_matcher_stream = __commonJS({
  "node_modules/unzip-stream/lib/matcher-stream.js"(exports2, module2) {
    var Transform2 = require("stream").Transform;
    var util4 = require("util");
    function MatcherStream(patternDesc, matchFn) {
      if (!(this instanceof MatcherStream)) {
        return new MatcherStream();
      }
      Transform2.call(this);
      var p = typeof patternDesc === "object" ? patternDesc.pattern : patternDesc;
      this.pattern = Buffer.isBuffer(p) ? p : Buffer.from(p);
      this.requiredLength = this.pattern.length;
      if (patternDesc.requiredExtraSize)
        this.requiredLength += patternDesc.requiredExtraSize;
      this.data = new Buffer("");
      this.bytesSoFar = 0;
      this.matchFn = matchFn;
    }
    util4.inherits(MatcherStream, Transform2);
    MatcherStream.prototype.checkDataChunk = function(ignoreMatchZero) {
      var enoughData = this.data.length >= this.requiredLength;
      if (!enoughData) {
        return;
      }
      var matchIndex = this.data.indexOf(this.pattern, ignoreMatchZero ? 1 : 0);
      if (matchIndex >= 0 && matchIndex + this.requiredLength > this.data.length) {
        if (matchIndex > 0) {
          var packet = this.data.slice(0, matchIndex);
          this.push(packet);
          this.bytesSoFar += matchIndex;
          this.data = this.data.slice(matchIndex);
        }
        return;
      }
      if (matchIndex === -1) {
        var packetLen = this.data.length - this.requiredLength + 1;
        var packet = this.data.slice(0, packetLen);
        this.push(packet);
        this.bytesSoFar += packetLen;
        this.data = this.data.slice(packetLen);
        return;
      }
      if (matchIndex > 0) {
        var packet = this.data.slice(0, matchIndex);
        this.data = this.data.slice(matchIndex);
        this.push(packet);
        this.bytesSoFar += matchIndex;
      }
      var finished = this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : true;
      if (finished) {
        this.data = new Buffer("");
        return;
      }
      return true;
    };
    MatcherStream.prototype._transform = function(chunk, encoding, cb) {
      this.data = Buffer.concat([this.data, chunk]);
      var firstIteration = true;
      while (this.checkDataChunk(!firstIteration)) {
        firstIteration = false;
      }
      cb();
    };
    MatcherStream.prototype._flush = function(cb) {
      if (this.data.length > 0) {
        var firstIteration = true;
        while (this.checkDataChunk(!firstIteration)) {
          firstIteration = false;
        }
      }
      if (this.data.length > 0) {
        this.push(this.data);
        this.data = null;
      }
      cb();
    };
    module2.exports = MatcherStream;
  }
});

// node_modules/unzip-stream/lib/entry.js
var require_entry = __commonJS({
  "node_modules/unzip-stream/lib/entry.js"(exports2, module2) {
    "use strict";
    var stream = require("stream");
    var inherits = require("util").inherits;
    function Entry() {
      if (!(this instanceof Entry)) {
        return new Entry();
      }
      stream.PassThrough.call(this);
      this.path = null;
      this.type = null;
      this.isDirectory = false;
    }
    inherits(Entry, stream.PassThrough);
    Entry.prototype.autodrain = function() {
      return this.pipe(new stream.Transform({ transform: function(d, e, cb) {
        cb();
      } }));
    };
    module2.exports = Entry;
  }
});

// node_modules/unzip-stream/lib/unzip-stream.js
var require_unzip_stream = __commonJS({
  "node_modules/unzip-stream/lib/unzip-stream.js"(exports2, module2) {
    "use strict";
    var binary = require_binary();
    var stream = require("stream");
    var util4 = require("util");
    var zlib = require("zlib");
    var MatcherStream = require_matcher_stream();
    var Entry = require_entry();
    var states = {
      STREAM_START: 0,
      START: 1,
      LOCAL_FILE_HEADER: 2,
      LOCAL_FILE_HEADER_SUFFIX: 3,
      FILE_DATA: 4,
      FILE_DATA_END: 5,
      DATA_DESCRIPTOR: 6,
      CENTRAL_DIRECTORY_FILE_HEADER: 7,
      CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
      CDIR64_END: 9,
      CDIR64_END_DATA_SECTOR: 10,
      CDIR64_LOCATOR: 11,
      CENTRAL_DIRECTORY_END: 12,
      CENTRAL_DIRECTORY_END_COMMENT: 13,
      TRAILING_JUNK: 14,
      ERROR: 99
    };
    var FOUR_GIGS = 4294967296;
    var SIG_LOCAL_FILE_HEADER = 67324752;
    var SIG_DATA_DESCRIPTOR = 134695760;
    var SIG_CDIR_RECORD = 33639248;
    var SIG_CDIR64_RECORD_END = 101075792;
    var SIG_CDIR64_LOCATOR_END = 117853008;
    var SIG_CDIR_RECORD_END = 101010256;
    function UnzipStream(options) {
      if (!(this instanceof UnzipStream)) {
        return new UnzipStream(options);
      }
      stream.Transform.call(this);
      this.options = options || {};
      this.data = new Buffer("");
      this.state = states.STREAM_START;
      this.skippedBytes = 0;
      this.parsedEntity = null;
      this.outStreamInfo = {};
    }
    util4.inherits(UnzipStream, stream.Transform);
    UnzipStream.prototype.processDataChunk = function(chunk) {
      var requiredLength;
      switch (this.state) {
        case states.STREAM_START:
        case states.START:
          requiredLength = 4;
          break;
        case states.LOCAL_FILE_HEADER:
          requiredLength = 26;
          break;
        case states.LOCAL_FILE_HEADER_SUFFIX:
          requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength;
          break;
        case states.DATA_DESCRIPTOR:
          requiredLength = 12;
          break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
          requiredLength = 42;
          break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
          requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength + this.parsedEntity.fileCommentLength;
          break;
        case states.CDIR64_END:
          requiredLength = 52;
          break;
        case states.CDIR64_END_DATA_SECTOR:
          requiredLength = this.parsedEntity.centralDirectoryRecordSize - 44;
          break;
        case states.CDIR64_LOCATOR:
          requiredLength = 16;
          break;
        case states.CENTRAL_DIRECTORY_END:
          requiredLength = 18;
          break;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
          requiredLength = this.parsedEntity.commentLength;
          break;
        case states.FILE_DATA:
          return 0;
        case states.FILE_DATA_END:
          return 0;
        case states.TRAILING_JUNK:
          if (this.options.debug)
            console.log("found", chunk.length, "bytes of TRAILING_JUNK");
          return chunk.length;
        default:
          return chunk.length;
      }
      var chunkLength = chunk.length;
      if (chunkLength < requiredLength) {
        return 0;
      }
      switch (this.state) {
        case states.STREAM_START:
        case states.START:
          var signature = chunk.readUInt32LE(0);
          switch (signature) {
            case SIG_LOCAL_FILE_HEADER:
              this.state = states.LOCAL_FILE_HEADER;
              break;
            case SIG_CDIR_RECORD:
              this.state = states.CENTRAL_DIRECTORY_FILE_HEADER;
              break;
            case SIG_CDIR64_RECORD_END:
              this.state = states.CDIR64_END;
              break;
            case SIG_CDIR64_LOCATOR_END:
              this.state = states.CDIR64_LOCATOR;
              break;
            case SIG_CDIR_RECORD_END:
              this.state = states.CENTRAL_DIRECTORY_END;
              break;
            default:
              var isStreamStart = this.state === states.STREAM_START;
              if (!isStreamStart && (signature & 65535) !== 19280 && this.skippedBytes < 26) {
                var remaining = signature;
                var toSkip = 4;
                for (var i = 1; i < 4 && remaining !== 0; i++) {
                  remaining = remaining >>> 8;
                  if ((remaining & 255) === 80) {
                    toSkip = i;
                    break;
                  }
                }
                this.skippedBytes += toSkip;
                if (this.options.debug)
                  console.log("Skipped", this.skippedBytes, "bytes");
                return toSkip;
              }
              this.state = states.ERROR;
              var errMsg = isStreamStart ? "Not a valid zip file" : "Invalid signature in zip file";
              if (this.options.debug) {
                var sig = chunk.readUInt32LE(0);
                var asString;
                try {
                  asString = chunk.slice(0, 4).toString();
                } catch (e) {
                }
                console.log("Unexpected signature in zip file: 0x" + sig.toString(16), '"' + asString + '", skipped', this.skippedBytes, "bytes");
              }
              this.emit("error", new Error(errMsg));
              return chunk.length;
          }
          this.skippedBytes = 0;
          return requiredLength;
        case states.LOCAL_FILE_HEADER:
          this.parsedEntity = this._readFile(chunk);
          this.state = states.LOCAL_FILE_HEADER_SUFFIX;
          return requiredLength;
        case states.LOCAL_FILE_HEADER_SUFFIX:
          var entry = new Entry();
          var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
          entry.path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
          var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
          var extra = this._readExtraFields(extraDataBuffer);
          if (extra && extra.parsed) {
            if (extra.parsed.path && !isUtf8) {
              entry.path = extra.parsed.path;
            }
            if (Number.isFinite(extra.parsed.uncompressedSize) && this.parsedEntity.uncompressedSize === FOUR_GIGS - 1) {
              this.parsedEntity.uncompressedSize = extra.parsed.uncompressedSize;
            }
            if (Number.isFinite(extra.parsed.compressedSize) && this.parsedEntity.compressedSize === FOUR_GIGS - 1) {
              this.parsedEntity.compressedSize = extra.parsed.compressedSize;
            }
          }
          this.parsedEntity.extra = extra.parsed || {};
          if (this.options.debug) {
            const debugObj = Object.assign({}, this.parsedEntity, {
              path: entry.path,
              flags: "0x" + this.parsedEntity.flags.toString(16),
              extraFields: extra && extra.debug
            });
            console.log("decoded LOCAL_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
          }
          this._prepareOutStream(this.parsedEntity, entry);
          this.emit("entry", entry);
          this.state = states.FILE_DATA;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
          this.parsedEntity = this._readCentralDirectoryEntry(chunk);
          this.state = states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
          var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
          var path36 = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
          var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
          var extra = this._readExtraFields(extraDataBuffer);
          if (extra && extra.parsed && extra.parsed.path && !isUtf8) {
            path36 = extra.parsed.path;
          }
          this.parsedEntity.extra = extra.parsed;
          var isUnix = (this.parsedEntity.versionMadeBy & 65280) >> 8 === 3;
          var unixAttrs, isSymlink;
          if (isUnix) {
            unixAttrs = this.parsedEntity.externalFileAttributes >>> 16;
            var fileType = unixAttrs >>> 12;
            isSymlink = (fileType & 10) === 10;
          }
          if (this.options.debug) {
            const debugObj = Object.assign({}, this.parsedEntity, {
              path: path36,
              flags: "0x" + this.parsedEntity.flags.toString(16),
              unixAttrs: unixAttrs && "0" + unixAttrs.toString(8),
              isSymlink,
              extraFields: extra.debug
            });
            console.log("decoded CENTRAL_DIRECTORY_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
          }
          this.state = states.START;
          return requiredLength;
        case states.CDIR64_END:
          this.parsedEntity = this._readEndOfCentralDirectory64(chunk);
          if (this.options.debug) {
            console.log("decoded CDIR64_END_RECORD:", this.parsedEntity);
          }
          this.state = states.CDIR64_END_DATA_SECTOR;
          return requiredLength;
        case states.CDIR64_END_DATA_SECTOR:
          this.state = states.START;
          return requiredLength;
        case states.CDIR64_LOCATOR:
          this.state = states.START;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_END:
          this.parsedEntity = this._readEndOfCentralDirectory(chunk);
          if (this.options.debug) {
            console.log("decoded CENTRAL_DIRECTORY_END:", this.parsedEntity);
          }
          this.state = states.CENTRAL_DIRECTORY_END_COMMENT;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
          if (this.options.debug) {
            console.log("decoded CENTRAL_DIRECTORY_END_COMMENT:", chunk.slice(0, requiredLength).toString());
          }
          this.state = states.TRAILING_JUNK;
          return requiredLength;
        case states.ERROR:
          return chunk.length;
        default:
          console.log("didn't handle state #", this.state, "discarding");
          return chunk.length;
      }
    };
    UnzipStream.prototype._prepareOutStream = function(vars, entry) {
      var self2 = this;
      var isDirectory = vars.uncompressedSize === 0 && /[\/\\]$/.test(entry.path);
      entry.path = entry.path.replace(/^([/\\]*[.]+[/\\]+)*[/\\]*/, "");
      entry.type = isDirectory ? "Directory" : "File";
      entry.isDirectory = isDirectory;
      var fileSizeKnown = !(vars.flags & 8);
      if (fileSizeKnown) {
        entry.size = vars.uncompressedSize;
      }
      var isVersionSupported = vars.versionsNeededToExtract <= 45;
      this.outStreamInfo = {
        stream: null,
        limit: fileSizeKnown ? vars.compressedSize : -1,
        written: 0
      };
      if (!fileSizeKnown) {
        var pattern = new Buffer(4);
        pattern.writeUInt32LE(SIG_DATA_DESCRIPTOR, 0);
        var zip64Mode = vars.extra.zip64Mode;
        var extraSize = zip64Mode ? 20 : 12;
        var searchPattern = {
          pattern,
          requiredExtraSize: extraSize
        };
        var matcherStream = new MatcherStream(searchPattern, function(matchedChunk, sizeSoFar) {
          var vars2 = self2._readDataDescriptor(matchedChunk, zip64Mode);
          var compressedSizeMatches = vars2.compressedSize === sizeSoFar;
          if (!zip64Mode && !compressedSizeMatches && sizeSoFar >= FOUR_GIGS) {
            var overflown = sizeSoFar - FOUR_GIGS;
            while (overflown >= 0) {
              compressedSizeMatches = vars2.compressedSize === overflown;
              if (compressedSizeMatches)
                break;
              overflown -= FOUR_GIGS;
            }
          }
          if (!compressedSizeMatches) {
            return;
          }
          self2.state = states.FILE_DATA_END;
          var sliceOffset = zip64Mode ? 24 : 16;
          if (self2.data.length > 0) {
            self2.data = Buffer.concat([matchedChunk.slice(sliceOffset), self2.data]);
          } else {
            self2.data = matchedChunk.slice(sliceOffset);
          }
          return true;
        });
        this.outStreamInfo.stream = matcherStream;
      } else {
        this.outStreamInfo.stream = new stream.PassThrough();
      }
      var isEncrypted = vars.flags & 1 || vars.flags & 64;
      if (isEncrypted || !isVersionSupported) {
        var message = isEncrypted ? "Encrypted files are not supported!" : "Zip version " + Math.floor(vars.versionsNeededToExtract / 10) + "." + vars.versionsNeededToExtract % 10 + " is not supported";
        entry.skip = true;
        setImmediate(() => {
          entry.emit("error", new Error(message));
        });
        this.outStreamInfo.stream.pipe(new Entry().autodrain());
        return;
      }
      var isCompressed = vars.compressionMethod > 0;
      if (isCompressed) {
        var inflater = zlib.createInflateRaw();
        inflater.on("error", function(err) {
          self2.state = states.ERROR;
          self2.emit("error", err);
        });
        this.outStreamInfo.stream.pipe(inflater).pipe(entry);
      } else {
        this.outStreamInfo.stream.pipe(entry);
      }
      if (this._drainAllEntries) {
        entry.autodrain();
      }
    };
    UnzipStream.prototype._readFile = function(data) {
      var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      return vars;
    };
    UnzipStream.prototype._readExtraFields = function(data) {
      var extra = {};
      var result = { parsed: extra };
      if (this.options.debug) {
        result.debug = [];
      }
      var index = 0;
      while (index < data.length) {
        var vars = binary.parse(data).skip(index).word16lu("extraId").word16lu("extraSize").vars;
        index += 4;
        var fieldType = void 0;
        switch (vars.extraId) {
          case 1:
            fieldType = "Zip64 extended information extra field";
            var z64vars = binary.parse(data.slice(index, index + vars.extraSize)).word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offsetToLocalHeader").word32lu("diskStartNumber").vars;
            if (z64vars.uncompressedSize !== null) {
              extra.uncompressedSize = z64vars.uncompressedSize;
            }
            if (z64vars.compressedSize !== null) {
              extra.compressedSize = z64vars.compressedSize;
            }
            extra.zip64Mode = true;
            break;
          case 10:
            fieldType = "NTFS extra field";
            break;
          case 21589:
            fieldType = "extended timestamp";
            var timestampFields = data.readUInt8(index);
            var offset = 1;
            if (vars.extraSize >= offset + 4 && timestampFields & 1) {
              extra.mtime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
            }
            if (vars.extraSize >= offset + 4 && timestampFields & 2) {
              extra.atime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
            }
            if (vars.extraSize >= offset + 4 && timestampFields & 4) {
              extra.ctime = new Date(data.readUInt32LE(index + offset) * 1e3);
            }
            break;
          case 28789:
            fieldType = "Info-ZIP Unicode Path Extra Field";
            var fieldVer = data.readUInt8(index);
            if (fieldVer === 1) {
              var offset = 1;
              var nameCrc32 = data.readUInt32LE(index + offset);
              offset += 4;
              var pathBuffer = data.slice(index + offset);
              extra.path = pathBuffer.toString();
            }
            break;
          case 13:
          case 22613:
            fieldType = vars.extraId === 13 ? "PKWARE Unix" : "Info-ZIP UNIX (type 1)";
            var offset = 0;
            if (vars.extraSize >= 8) {
              var atime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
              var mtime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
              extra.atime = atime;
              extra.mtime = mtime;
              if (vars.extraSize >= 12) {
                var uid = data.readUInt16LE(index + offset);
                offset += 2;
                var gid = data.readUInt16LE(index + offset);
                offset += 2;
                extra.uid = uid;
                extra.gid = gid;
              }
            }
            break;
          case 30805:
            fieldType = "Info-ZIP UNIX (type 2)";
            var offset = 0;
            if (vars.extraSize >= 4) {
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.uid = uid;
              extra.gid = gid;
            }
            break;
          case 30837:
            fieldType = "Info-ZIP New Unix";
            var offset = 0;
            var extraVer = data.readUInt8(index);
            offset += 1;
            if (extraVer === 1) {
              var uidSize = data.readUInt8(index + offset);
              offset += 1;
              if (uidSize <= 6) {
                extra.uid = data.readUIntLE(index + offset, uidSize);
              }
              offset += uidSize;
              var gidSize = data.readUInt8(index + offset);
              offset += 1;
              if (gidSize <= 6) {
                extra.gid = data.readUIntLE(index + offset, gidSize);
              }
            }
            break;
          case 30062:
            fieldType = "ASi Unix";
            var offset = 0;
            if (vars.extraSize >= 14) {
              var crc = data.readUInt32LE(index + offset);
              offset += 4;
              var mode = data.readUInt16LE(index + offset);
              offset += 2;
              var sizdev = data.readUInt32LE(index + offset);
              offset += 4;
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.mode = mode;
              extra.uid = uid;
              extra.gid = gid;
              if (vars.extraSize > 14) {
                var start = index + offset;
                var end = index + vars.extraSize - 14;
                var symlinkName = this._decodeString(data.slice(start, end));
                extra.symlink = symlinkName;
              }
            }
            break;
        }
        if (this.options.debug) {
          result.debug.push({
            extraId: "0x" + vars.extraId.toString(16),
            description: fieldType,
            data: data.slice(index, index + vars.extraSize).inspect()
          });
        }
        index += vars.extraSize;
      }
      return result;
    };
    UnzipStream.prototype._readDataDescriptor = function(data, zip64Mode) {
      if (zip64Mode) {
        var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word64lu("compressedSize").word64lu("uncompressedSize").vars;
        return vars;
      }
      var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
      return vars;
    };
    UnzipStream.prototype._readCentralDirectoryEntry = function(data) {
      var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
      return vars;
    };
    UnzipStream.prototype._readEndOfCentralDirectory64 = function(data) {
      var vars = binary.parse(data).word64lu("centralDirectoryRecordSize").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskNumberWithCentralDirectoryStart").word64lu("centralDirectoryEntries").word64lu("totalCentralDirectoryEntries").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
      return vars;
    };
    UnzipStream.prototype._readEndOfCentralDirectory = function(data) {
      var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("centralDirectoryEntries").word16lu("totalCentralDirectoryEntries").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      return vars;
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 ";
    UnzipStream.prototype._decodeString = function(buffer, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8");
      }
      if (this.options.decodeString) {
        return this.options.decodeString(buffer);
      }
      let result = "";
      for (var i = 0; i < buffer.length; i++) {
        result += cp437[buffer[i]];
      }
      return result;
    };
    UnzipStream.prototype._parseOrOutput = function(encoding, cb) {
      var consume;
      while ((consume = this.processDataChunk(this.data)) > 0) {
        this.data = this.data.slice(consume);
        if (this.data.length === 0)
          break;
      }
      if (this.state === states.FILE_DATA) {
        if (this.outStreamInfo.limit >= 0) {
          var remaining = this.outStreamInfo.limit - this.outStreamInfo.written;
          var packet;
          if (remaining < this.data.length) {
            packet = this.data.slice(0, remaining);
            this.data = this.data.slice(remaining);
          } else {
            packet = this.data;
            this.data = new Buffer("");
          }
          this.outStreamInfo.written += packet.length;
          if (this.outStreamInfo.limit === this.outStreamInfo.written) {
            this.state = states.START;
            this.outStreamInfo.stream.end(packet, encoding, cb);
          } else {
            this.outStreamInfo.stream.write(packet, encoding, cb);
          }
        } else {
          var packet = this.data;
          this.data = new Buffer("");
          this.outStreamInfo.written += packet.length;
          var outputStream = this.outStreamInfo.stream;
          outputStream.write(packet, encoding, () => {
            if (this.state === states.FILE_DATA_END) {
              this.state = states.START;
              return outputStream.end(cb);
            }
            cb();
          });
        }
        return;
      }
      cb();
    };
    UnzipStream.prototype.drainAll = function() {
      this._drainAllEntries = true;
    };
    UnzipStream.prototype._transform = function(chunk, encoding, cb) {
      var self2 = this;
      if (self2.data.length > 0) {
        self2.data = Buffer.concat([self2.data, chunk]);
      } else {
        self2.data = chunk;
      }
      var startDataLength = self2.data.length;
      var done = function() {
        if (self2.data.length > 0 && self2.data.length < startDataLength) {
          startDataLength = self2.data.length;
          self2._parseOrOutput(encoding, done);
          return;
        }
        cb();
      };
      self2._parseOrOutput(encoding, done);
    };
    UnzipStream.prototype._flush = function(cb) {
      var self2 = this;
      if (self2.data.length > 0) {
        self2._parseOrOutput("buffer", function() {
          if (self2.data.length > 0)
            return setImmediate(function() {
              self2._flush(cb);
            });
          cb();
        });
        return;
      }
      if (self2.state === states.FILE_DATA) {
        return cb(new Error("Stream finished in an invalid state, uncompression failed"));
      }
      setImmediate(cb);
    };
    module2.exports = UnzipStream;
  }
});

// node_modules/unzip-stream/lib/parser-stream.js
var require_parser_stream = __commonJS({
  "node_modules/unzip-stream/lib/parser-stream.js"(exports2, module2) {
    var Transform2 = require("stream").Transform;
    var util4 = require("util");
    var UnzipStream = require_unzip_stream();
    function ParserStream(opts) {
      if (!(this instanceof ParserStream)) {
        return new ParserStream(opts);
      }
      var transformOpts = opts || {};
      Transform2.call(this, { readableObjectMode: true });
      this.opts = opts || {};
      this.unzipStream = new UnzipStream(this.opts);
      var self2 = this;
      this.unzipStream.on("entry", function(entry) {
        self2.push(entry);
      });
      this.unzipStream.on("error", function(error) {
        self2.emit("error", error);
      });
    }
    util4.inherits(ParserStream, Transform2);
    ParserStream.prototype._transform = function(chunk, encoding, cb) {
      this.unzipStream.write(chunk, encoding, cb);
    };
    ParserStream.prototype._flush = function(cb) {
      var self2 = this;
      this.unzipStream.end(function() {
        process.nextTick(function() {
          self2.emit("close");
        });
        cb();
      });
    };
    ParserStream.prototype.on = function(eventName, fn) {
      if (eventName === "entry") {
        return Transform2.prototype.on.call(this, "data", fn);
      }
      return Transform2.prototype.on.call(this, eventName, fn);
    };
    ParserStream.prototype.drainAll = function() {
      this.unzipStream.drainAll();
      return this.pipe(new Transform2({ objectMode: true, transform: function(d, e, cb) {
        cb();
      } }));
    };
    module2.exports = ParserStream;
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp2 = __commonJS({
  "node_modules/mkdirp/index.js"(exports2, module2) {
    var path36 = require("path");
    var fs27 = require("fs");
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs27;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      var cb = f || function() {
      };
      p = path36.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path36.dirname(p) === p)
              return cb(er);
            mkdirP(path36.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb(er2, made2);
              else
                mkdirP(p, opts, cb, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb(er, made);
              else
                cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs27;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      p = path36.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path36.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/unzip-stream/lib/extract.js
var require_extract2 = __commonJS({
  "node_modules/unzip-stream/lib/extract.js"(exports2, module2) {
    var fs27 = require("fs");
    var path36 = require("path");
    var util4 = require("util");
    var mkdirp = require_mkdirp2();
    var Transform2 = require("stream").Transform;
    var UnzipStream = require_unzip_stream();
    function Extract(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Transform2.call(this);
      this.opts = opts || {};
      this.unzipStream = new UnzipStream(this.opts);
      this.unfinishedEntries = 0;
      this.afterFlushWait = false;
      this.createdDirectories = {};
      var self2 = this;
      this.unzipStream.on("entry", this._processEntry.bind(this));
      this.unzipStream.on("error", function(error) {
        self2.emit("error", error);
      });
    }
    util4.inherits(Extract, Transform2);
    Extract.prototype._transform = function(chunk, encoding, cb) {
      this.unzipStream.write(chunk, encoding, cb);
    };
    Extract.prototype._flush = function(cb) {
      var self2 = this;
      var allDone = function() {
        process.nextTick(function() {
          self2.emit("close");
        });
        cb();
      };
      this.unzipStream.end(function() {
        if (self2.unfinishedEntries > 0) {
          self2.afterFlushWait = true;
          return self2.on("await-finished", allDone);
        }
        allDone();
      });
    };
    Extract.prototype._processEntry = function(entry) {
      var self2 = this;
      var destPath = path36.join(this.opts.path, entry.path);
      var directory = entry.isDirectory ? destPath : path36.dirname(destPath);
      this.unfinishedEntries++;
      var writeFileFn = function() {
        var pipedStream = fs27.createWriteStream(destPath);
        pipedStream.on("close", function() {
          self2.unfinishedEntries--;
          self2._notifyAwaiter();
        });
        pipedStream.on("error", function(error) {
          self2.emit("error", error);
        });
        entry.pipe(pipedStream);
      };
      if (this.createdDirectories[directory] || directory === ".") {
        return writeFileFn();
      }
      mkdirp(directory, function(err) {
        if (err)
          return self2.emit("error", err);
        self2.createdDirectories[directory] = true;
        if (entry.isDirectory) {
          self2.unfinishedEntries--;
          self2._notifyAwaiter();
          return;
        }
        writeFileFn();
      });
    };
    Extract.prototype._notifyAwaiter = function() {
      if (this.afterFlushWait && this.unfinishedEntries === 0) {
        this.emit("await-finished");
        this.afterFlushWait = false;
      }
    };
    module2.exports = Extract;
  }
});

// node_modules/unzip-stream/unzip.js
var require_unzip = __commonJS({
  "node_modules/unzip-stream/unzip.js"(exports2) {
    "use strict";
    exports2.Parse = require_parser_stream();
    exports2.Extract = require_extract2();
  }
});

// node_modules/@tootallnate/once/dist/index.js
var require_dist = __commonJS({
  "node_modules/@tootallnate/once/dist/index.js"(exports2, module2) {
    "use strict";
    function noop() {
    }
    function once(emitter, name2) {
      const o = once.spread(emitter, name2);
      const r = o.then((args) => args[0]);
      r.cancel = o.cancel;
      return r;
    }
    (function(once2) {
      function spread(emitter, name2) {
        let c = null;
        const p = new Promise((resolve3, reject) => {
          function cancel() {
            emitter.removeListener(name2, onEvent);
            emitter.removeListener("error", onError);
            p.cancel = noop;
          }
          function onEvent(...args) {
            cancel();
            resolve3(args);
          }
          function onError(err) {
            cancel();
            reject(err);
          }
          c = cancel;
          emitter.on(name2, onEvent);
          emitter.on("error", onError);
        });
        if (!c) {
          throw new TypeError("Could not get `cancel()` function");
        }
        p.cancel = c;
        return p;
      }
      once2.spread = spread;
    })(once || (once = {}));
    module2.exports = once;
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve3, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve3(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/http-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/http-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve3) {
          resolve3(value);
        });
      }
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var debug_1 = __importDefault(require_src());
    var once_1 = __importDefault(require_dist());
    var agent_base_1 = require_src2();
    var debug = debug_1.default("http-proxy-agent");
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    var HttpProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("Creating new HttpProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          const parsed = url_1.default.parse(req.path);
          if (!parsed.protocol) {
            parsed.protocol = "http:";
          }
          if (!parsed.hostname) {
            parsed.hostname = opts.hostname || opts.host || null;
          }
          if (parsed.port == null && typeof opts.port) {
            parsed.port = String(opts.port);
          }
          if (parsed.port === "80") {
            delete parsed.port;
          }
          req.path = url_1.default.format(parsed);
          if (proxy.auth) {
            req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
          }
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          if (req._header) {
            let first;
            let endOfHeaders;
            debug("Regenerating stored HTTP header string for request");
            req._header = null;
            req._implicitHeader();
            if (req.output && req.output.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.output[0];
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.output[0] = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.output);
            } else if (req.outputData && req.outputData.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.outputData[0].data;
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.outputData[0].data = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.outputData[0].data);
            }
          }
          yield once_1.default(socket, "connect");
          return socket;
        });
      }
    };
    exports2.default = HttpProxyAgent2;
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/http-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpProxyAgent2(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpProxyAgent3) {
      createHttpProxyAgent3.HttpProxyAgent = agent_1.default;
      createHttpProxyAgent3.prototype = agent_1.default.prototype;
    })(createHttpProxyAgent2 || (createHttpProxyAgent2 = {}));
    module2.exports = createHttpProxyAgent2;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve3, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve3({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent2 = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve3) {
          resolve3(value);
        });
      }
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name2 of Object.keys(headers)) {
            payload += `${name2}: ${headers[name2]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              const servername = opts.servername || opts.host;
              if (!servername) {
                throw new Error('Could not determine "servername"');
              }
              debug("Upgrading socket connection to TLS");
              return tls_1.default.connect(Object.assign(Object.assign({}, omit2(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket();
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent2;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit2(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent2());
    function createHttpsProxyAgent2(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent3) {
      createHttpsProxyAgent3.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent3.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent2 || (createHttpsProxyAgent2 = {}));
    module2.exports = createHttpsProxyAgent2;
  }
});

// node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProperties = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module2.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value = fromStream[property];
            const isFunction = typeof value === "function";
            return isFunction ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  }
});

// node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "node_modules/decompress-response/index.js"(exports2, module2) {
    "use strict";
    var { Transform: Transform2, PassThrough } = require("stream");
    var zlib = require("zlib");
    var mimicResponse = require_mimic_response();
    module2.exports = (response) => {
      const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
      }
      let isEmpty2 = true;
      const checker = new Transform2({
        transform(data, _encoding, callback) {
          isEmpty2 = false;
          callback(null, data);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough({
        autoDestroy: false,
        destroy(error, callback) {
          response.destroy();
          callback(error);
        }
      });
      const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
      decompressStream.once("error", (error) => {
        if (isEmpty2 && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error);
      });
      mimicResponse(response, finalStream);
      response.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  }
});

// src/model/fetch.ts
function getSystemProxyURI(endpoint) {
  let env;
  if (endpoint.protocol === "http:") {
    env = process.env.HTTP_PROXY || process.env.http_proxy || null;
  } else if (endpoint.protocol === "https:") {
    env = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
  }
  let noProxy = process.env.NO_PROXY || process.env.no_proxy;
  if (noProxy === "*") {
    env = null;
  } else if (noProxy) {
    const hostname = endpoint.hostname.replace(/^\.*/, ".").toLowerCase();
    const port = endpoint.port || endpoint.protocol.startsWith("https") ? "443" : "80";
    const noProxyList = noProxy.split(",");
    for (let i = 0, len = noProxyList.length; i < len; i++) {
      let noProxyItem = noProxyList[i].trim().toLowerCase();
      if (noProxyItem.includes(":")) {
        let noProxyItemParts = noProxyItem.split(":", 2);
        let noProxyHost = noProxyItemParts[0].replace(/^\.*/, ".");
        let noProxyPort = noProxyItemParts[1];
        if (port === noProxyPort && hostname.endsWith(noProxyHost)) {
          env = null;
          break;
        }
      } else {
        noProxyItem = noProxyItem.replace(/^\.*/, ".");
        if (hostname.endsWith(noProxyItem)) {
          env = null;
          break;
        }
      }
    }
  }
  return env;
}
function getAgent(endpoint, options) {
  let proxy = options.proxyUrl || getSystemProxyURI(endpoint);
  if (proxy) {
    const proxyEndpoint = (0, import_url.parse)(proxy);
    if (!/^https?:$/.test(proxyEndpoint.protocol)) {
      return null;
    }
    let opts = {
      host: proxyEndpoint.hostname,
      port: proxyEndpoint.port ? Number(proxyEndpoint.port) : proxyEndpoint.protocol === "https" ? "443" : "80",
      auth: proxyEndpoint.auth,
      rejectUnauthorized: typeof options.strictSSL === "boolean" ? options.strictSSL : true
    };
    logger33.info(`Using proxy ${proxy} from ${options.proxyUrl ? "configuration" : "system environment"} for ${endpoint.hostname}:`);
    return endpoint.protocol === "http:" ? (0, import_http_proxy_agent.default)(opts) : (0, import_https_proxy_agent.default)(opts);
  }
  return null;
}
function resolveRequestOptions(url, options = {}) {
  let config = workspace_default.getConfiguration("http");
  let { data } = options;
  let dataType = getDataType(data);
  let proxyOptions = {
    proxyUrl: config.get("proxy", ""),
    strictSSL: config.get("proxyStrictSSL", true),
    proxyAuthorization: config.get("proxyAuthorization", null),
    proxyCA: config.get("proxyCA", null)
  };
  if (options.query && !url.includes("?")) {
    url = `${url}?${(0, import_querystring.stringify)(options.query)}`;
  }
  let headers = Object.assign(options.headers || {}, { "Proxy-Authorization": proxyOptions.proxyAuthorization });
  let endpoint = (0, import_url.parse)(url);
  let agent = getAgent(endpoint, proxyOptions);
  let opts = {
    method: options.method || "GET",
    hostname: endpoint.hostname,
    port: endpoint.port ? parseInt(endpoint.port, 10) : endpoint.protocol === "https:" ? 443 : 80,
    path: endpoint.path,
    agent,
    rejectUnauthorized: proxyOptions.strictSSL,
    maxRedirects: 3,
    headers: Object.assign({
      "User-Agent": "Mozilla/5.0 (X11; Linux x86_64)",
      "Accept-Encoding": "gzip, deflate"
    }, headers)
  };
  if (proxyOptions.proxyCA) {
    opts.ca = import_fs11.default.readFileSync(proxyOptions.proxyCA);
  }
  if (dataType == "object") {
    opts.headers["Content-Type"] = "application/json";
  } else if (dataType == "string") {
    opts.headers["Content-Type"] = "text/plain";
  }
  if (options.user && options.password) {
    opts.auth = options.user + ":" + options.password;
  }
  if (options.timeout) {
    opts.timeout = options.timeout;
  }
  if (options.buffer)
    opts.buffer = true;
  return opts;
}
function request(url, data, opts, token) {
  let mod = url.startsWith("https:") ? import_follow_redirects.https : import_follow_redirects.http;
  return new Promise((resolve3, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new Error("request aborted"));
      });
    }
    const req = mod.request(opts, (res) => {
      let readable = res;
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers || {};
        let chunks = [];
        let contentType = headers["content-type"] || "";
        readable = (0, import_decompress_response.default)(res);
        readable.on("data", (chunk) => {
          chunks.push(chunk);
        });
        readable.on("end", () => {
          let buf = Buffer.concat(chunks);
          if (!opts.buffer && (contentType.startsWith("application/json") || contentType.startsWith("text/"))) {
            let ms = contentType.match(/charset=(\S+)/);
            let encoding = ms ? ms[1] : "utf8";
            let rawData = buf.toString(encoding);
            if (!contentType.includes("application/json")) {
              resolve3(rawData);
            } else {
              try {
                const parsedData = JSON.parse(rawData);
                resolve3(parsedData);
              } catch (e) {
                reject(new Error(`Parse response error: ${e}`));
              }
            }
          } else {
            resolve3(buf);
          }
        });
        readable.on("error", (err) => {
          reject(new Error(`Unable to connect ${url}: ${err.message}`));
        });
      } else {
        reject(new Error(`Bad response from ${url}: ${res.statusCode}`));
      }
    });
    req.on("error", reject);
    req.on("timeout", () => {
      req.destroy(new Error(`Request timeout after ${opts.timeout}ms`));
    });
    if (data) {
      if (typeof data === "string" || Buffer.isBuffer(data)) {
        req.write(data);
      } else {
        req.write(JSON.stringify(data));
      }
    }
    if (opts.timeout) {
      req.setTimeout(opts.timeout);
    }
    req.end();
  });
}
function getDataType(data) {
  if (data === null)
    return "null";
  if (data === void 0)
    return "undefined";
  if (typeof data == "string")
    return "string";
  if (Buffer.isBuffer(data))
    return "buffer";
  if (Array.isArray(data) || objectLiteral(data))
    return "object";
  return "unknown";
}
function fetch(url, options = {}, token) {
  let opts = resolveRequestOptions(url, options);
  return request(url, options.data, opts, token).catch((err) => {
    logger33.error(`Fetch error for ${url}:`, opts, err);
    if (opts.agent && opts.agent.proxy) {
      let { proxy } = opts.agent;
      throw new Error(`Request failed using proxy ${proxy.host}: ${err.message}`);
    } else {
      throw err;
    }
  });
}
var import_follow_redirects, import_url, import_fs11, import_querystring, import_http_proxy_agent, import_https_proxy_agent, import_decompress_response, logger33;
var init_fetch = __esm({
  "src/model/fetch.ts"() {
    import_follow_redirects = __toModule(require_follow_redirects());
    import_url = __toModule(require("url"));
    import_fs11 = __toModule(require("fs"));
    init_is();
    init_workspace();
    import_querystring = __toModule(require("querystring"));
    import_http_proxy_agent = __toModule(require_dist2());
    import_https_proxy_agent = __toModule(require_dist3());
    import_decompress_response = __toModule(require_decompress_response());
    logger33 = require_logger2()("model-fetch");
  }
});

// src/model/download.ts
function download(url, options, token) {
  let { dest, onProgress, extract } = options;
  if (!dest || !import_path14.default.isAbsolute(dest)) {
    throw new Error(`Expect absolute file path for dest option.`);
  }
  let stat;
  try {
    stat = import_fs_extra5.default.statSync(dest);
  } catch (_e) {
    import_fs_extra5.default.mkdirpSync(dest);
  }
  if (stat && !stat.isDirectory()) {
    throw new Error(`${dest} exists, but not directory!`);
  }
  let mod = url.startsWith("https") ? import_follow_redirects2.https : import_follow_redirects2.http;
  let opts = resolveRequestOptions(url, options);
  let extname = import_path14.default.extname(url);
  return new Promise((resolve3, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new Error("request aborted"));
      });
    }
    const req = mod.request(opts, (res) => {
      var _a2, _b;
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers || {};
        let dispositionHeader = headers["content-disposition"];
        if (!extname && dispositionHeader) {
          let disposition = import_content_disposition.default.parse(dispositionHeader);
          if ((_a2 = disposition.parameters) == null ? void 0 : _a2.filename) {
            extname = import_path14.default.extname(disposition.parameters.filename);
          }
        }
        if (extract === true) {
          if (extname === ".zip" || headers["content-type"] == "application/zip") {
            extract = "unzip";
          } else if (extname == ".tgz") {
            extract = "untar";
          } else {
            reject(new Error(`Unable to extract for ${url}`));
            return;
          }
        }
        let total = Number(headers["content-length"]);
        let cur = 0;
        if (!isNaN(total)) {
          res.on("data", (chunk) => {
            cur += chunk.length;
            let percent = (cur / total * 100).toFixed(1);
            if (onProgress) {
              onProgress(percent);
            } else {
              logger34.info(`Download ${url} progress ${percent}%`);
            }
          });
        }
        res.on("error", (err) => {
          reject(new Error(`Unable to connect ${url}: ${err.message}`));
        });
        res.on("end", () => {
          logger34.info("Download completed:", url);
        });
        let stream;
        if (extract === "untar") {
          stream = res.pipe(import_tar.default.x({ strip: (_b = options.strip) != null ? _b : 1, C: dest }));
        } else if (extract === "unzip") {
          stream = res.pipe(import_unzip_stream.default.Extract({ path: dest }));
        } else {
          dest = import_path14.default.join(dest, `${v1_default()}${extname}`);
          stream = res.pipe(import_fs_extra5.default.createWriteStream(dest));
        }
        stream.on("finish", () => {
          logger34.info(`Downloaded ${url} => ${dest}`);
          setTimeout(() => {
            resolve3(dest);
          }, 100);
        });
        stream.on("error", reject);
      } else {
        reject(new Error(`Invalid response from ${url}: ${res.statusCode}`));
      }
    });
    req.on("error", reject);
    req.on("timeout", () => {
      req.destroy(new Error(`request timeout after ${options.timeout}ms`));
    });
    if (options.timeout) {
      req.setTimeout(options.timeout);
    }
    req.end();
  });
}
var import_content_disposition, import_follow_redirects2, import_fs_extra5, import_path14, import_tar, import_unzip_stream, logger34;
var init_download = __esm({
  "src/model/download.ts"() {
    import_content_disposition = __toModule(require_content_disposition());
    import_follow_redirects2 = __toModule(require_follow_redirects());
    import_fs_extra5 = __toModule(require_lib5());
    import_path14 = __toModule(require("path"));
    import_tar = __toModule(require_tar());
    import_unzip_stream = __toModule(require_unzip());
    init_esm_node();
    init_fetch();
    logger34 = require_logger2()("model-download");
  }
});

// src/model/installer.ts
function registryUrl(scope = "coc.nvim") {
  const result = (0, import_rc.default)("npm", { registry: "https://registry.npmjs.org/" });
  const registry = result[`${scope}:registry`] || result.config_registry || result.registry;
  return registry.endsWith("/") ? registry : registry + "/";
}
function createInstallerFactory(npm, root) {
  return (def) => new Installer(root, npm, def);
}
var import_events17, import_child_process3, import_readline2, import_fs_extra6, import_os6, import_path15, import_rc, import_semver, logger35, Installer;
var init_installer = __esm({
  "src/model/installer.ts"() {
    import_events17 = __toModule(require("events"));
    import_child_process3 = __toModule(require("child_process"));
    init_main3();
    import_readline2 = __toModule(require("readline"));
    import_fs_extra6 = __toModule(require_lib5());
    import_os6 = __toModule(require("os"));
    import_path15 = __toModule(require("path"));
    import_rc = __toModule(require_rc());
    import_semver = __toModule(require_semver2());
    init_workspace();
    init_download();
    init_fetch();
    init_fs();
    logger35 = require_logger2()("model-installer");
    Installer = class extends import_events17.EventEmitter {
      constructor(root, npm, def) {
        super();
        this.root = root;
        this.npm = npm;
        this.def = def;
        if (!import_fs_extra6.default.existsSync(root))
          import_fs_extra6.default.mkdirpSync(root);
        if (/^https?:/.test(def)) {
          this.url = def;
        } else {
          if (def.startsWith("@")) {
            const idx = def.indexOf("@", 1);
            if (idx > 1) {
              this.name = def.substring(0, idx);
              this.version = def.substring(idx + 1);
            } else {
              this.name = def;
            }
          } else {
            if (def.includes("@")) {
              let [name2, version2] = def.split("@", 2);
              this.name = name2;
              this.version = version2;
            } else {
              this.name = def;
            }
          }
        }
      }
      get info() {
        return { name: this.name, version: this.version };
      }
      async install() {
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        logger35.info(`Fetched info of ${this.def}`, info);
        let { name: name2 } = info;
        let required = info["engines.coc"] ? info["engines.coc"].replace(/^\^/, ">=") : "";
        if (required && !import_semver.default.satisfies(workspace_default.version, required)) {
          throw new Error(`${name2} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);
        }
        await this.doInstall(info);
        return name2;
      }
      async update(url) {
        this.url = url;
        let folder = import_path15.default.join(this.root, this.name);
        let stat = await import_fs_extra6.default.lstat(folder);
        if (stat.isSymbolicLink()) {
          this.log(`Skipped update for symbol link`);
          return;
        }
        let version2;
        if (import_fs_extra6.default.existsSync(import_path15.default.join(folder, "package.json"))) {
          let content = await import_fs_extra6.default.readFile(import_path15.default.join(folder, "package.json"), "utf8");
          version2 = JSON.parse(content).version;
        }
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        if (version2 && info.version && import_semver.default.gte(version2, info.version)) {
          this.log(`Current version ${version2} is up to date.`);
          return;
        }
        let required = info["engines.coc"] ? info["engines.coc"].replace(/^\^/, ">=") : "";
        if (required && !import_semver.default.satisfies(workspace_default.version, required)) {
          throw new Error(`${info.version} requires coc.nvim ${required}, please update coc.nvim.`);
        }
        await this.doInstall(info);
        let jsonFile = import_path15.default.join(this.root, info.name, "package.json");
        if (import_fs_extra6.default.existsSync(jsonFile)) {
          this.log(`Updated to v${info.version}`);
          return import_path15.default.dirname(jsonFile);
        } else {
          throw new Error(`Package.json not found: ${jsonFile}`);
        }
      }
      async doInstall(info) {
        let folder = import_path15.default.join(this.root, info.name);
        if (import_fs_extra6.default.existsSync(folder)) {
          let stat2 = import_fs_extra6.default.statSync(folder);
          if (!stat2.isDirectory()) {
            this.log(`${folder} is not directory skipped install`);
            return;
          }
        }
        let tmpFolder = await import_fs_extra6.default.mkdtemp(import_path15.default.join(import_os6.default.tmpdir(), `${info.name.replace("/", "-")}-`));
        let url = info["dist.tarball"];
        this.log(`Downloading from ${url}`);
        await download(url, { dest: tmpFolder, onProgress: (p) => this.log(`Download progress ${p}%`, true), extract: "untar" });
        this.log(`Extension download at ${tmpFolder}`);
        let content = await import_fs_extra6.default.readFile(import_path15.default.join(tmpFolder, "package.json"), "utf8");
        let { dependencies } = JSON.parse(content);
        if (dependencies && Object.keys(dependencies).length) {
          let p = new Promise((resolve3, reject) => {
            let args = ["install", "--ignore-scripts", "--no-lockfile", "--production", "--no-global"];
            if (url.startsWith("https://github.com")) {
              args = ["install"];
            }
            if ((this.npm.endsWith("npm") || this.npm.endsWith("npm.CMD")) && !this.npm.endsWith("pnpm")) {
              args.push("--legacy-peer-deps");
            }
            if (this.npm.endsWith("yarn")) {
              args.push("--ignore-engines");
            }
            this.log(`Installing dependencies by: ${this.npm} ${args.join(" ")}.`);
            const child = (0, import_child_process3.spawn)(this.npm, args, {
              cwd: tmpFolder
            });
            const rl = import_readline2.default.createInterface({
              input: child.stdout
            });
            rl.on("line", (line) => {
              this.log(`[npm] ${line}`, true);
            });
            child.stderr.setEncoding("utf8");
            child.stdout.setEncoding("utf8");
            child.on("error", reject);
            let err = "";
            child.stderr.on("data", (data) => {
              err += data;
            });
            child.on("exit", (code) => {
              if (code) {
                if (err)
                  this.log(err);
                reject(new Error(`${this.npm} install exited with ${code}`));
                return;
              }
              resolve3();
            });
          });
          await p;
        }
        let jsonFile = import_path15.default.resolve(this.root, global.hasOwnProperty("__TEST__") ? "" : "..", "package.json");
        let errors = [];
        let obj = parse3(import_fs_extra6.default.readFileSync(jsonFile, "utf8"), errors, { allowTrailingComma: true });
        if (errors && errors.length > 0) {
          throw new Error(`Error on load ${jsonFile}`);
        }
        obj.dependencies = obj.dependencies || {};
        if (this.url) {
          obj.dependencies[info.name] = this.url;
        } else {
          obj.dependencies[info.name] = ">=" + info.version;
        }
        const sortedObj = { dependencies: {} };
        Object.keys(obj.dependencies).sort().forEach((k) => {
          sortedObj.dependencies[k] = obj.dependencies[k];
        });
        let stat = await statAsync(folder);
        if (stat) {
          if (stat.isDirectory()) {
            import_fs_extra6.default.removeSync(folder);
          } else {
            import_fs_extra6.default.unlinkSync(folder);
          }
        }
        await import_fs_extra6.default.move(tmpFolder, folder, { overwrite: true });
        await import_fs_extra6.default.writeFile(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: "utf8" });
        this.log(`Update package.json at ${jsonFile}`);
        this.log(`Installed extension ${this.name}@${info.version} at ${folder}`);
      }
      async getInfo() {
        if (this.url)
          return await this.getInfoFromUri();
        let registry = registryUrl();
        this.log(`Get info from ${registry}`);
        let buffer = await fetch(registry + this.name, { timeout: 1e4, buffer: true });
        let res = JSON.parse(buffer.toString());
        if (!this.version)
          this.version = res["dist-tags"]["latest"];
        let obj = res["versions"][this.version];
        if (!obj)
          throw new Error(`${this.def} doesn't exists in ${registry}.`);
        let requiredVersion = obj["engines"] && obj["engines"]["coc"];
        if (!requiredVersion) {
          throw new Error(`${this.def} is not valid coc extension, "engines" field with coc property required.`);
        }
        return {
          "dist.tarball": obj["dist"]["tarball"],
          "engines.coc": requiredVersion,
          version: obj["version"],
          name: res.name
        };
      }
      async getInfoFromUri() {
        let { url } = this;
        if (!url.includes("github.com")) {
          throw new Error(`"${url}" is not supported, coc.nvim support github.com only`);
        }
        url = url.replace(/\/$/, "");
        let branch = "master";
        if (url.includes("@")) {
          let idx = url.indexOf("@");
          branch = url.substr(idx + 1);
          url = url.substring(0, idx);
        }
        let fileUrl = url.replace("github.com", "raw.githubusercontent.com") + `/${branch}/package.json`;
        this.log(`Get info from ${fileUrl}`);
        let content = await fetch(fileUrl, { timeout: 1e4 });
        let obj = typeof content == "string" ? JSON.parse(content) : content;
        this.name = obj.name;
        return {
          "dist.tarball": `${url}/archive/${branch}.tar.gz`,
          "engines.coc": obj["engines"] ? obj["engines"]["coc"] : null,
          name: obj.name,
          version: obj.version
        };
      }
      log(msg, isProgress = false) {
        logger35.info(msg);
        this.emit("message", msg, isProgress);
      }
    };
  }
});

// src/model/memos.ts
var import_fs13, logger36, Memos;
var init_memos = __esm({
  "src/model/memos.ts"() {
    import_fs13 = __toModule(require("fs"));
    init_object();
    logger36 = require_logger2()("model-memos");
    Memos = class {
      constructor(filepath) {
        this.filepath = filepath;
        if (!import_fs13.default.existsSync(filepath)) {
          import_fs13.default.writeFileSync(filepath, "{}", "utf8");
        }
      }
      fetchContent(id, key) {
        try {
          let content = import_fs13.default.readFileSync(this.filepath, "utf8");
          let res = JSON.parse(content);
          let obj = res[id];
          if (!obj)
            return void 0;
          return obj[key];
        } catch (e) {
          return void 0;
        }
      }
      async update(id, key, value) {
        let { filepath } = this;
        try {
          let content = import_fs13.default.readFileSync(filepath, "utf8");
          let current = content ? JSON.parse(content) : {};
          current[id] = current[id] || {};
          if (value !== void 0) {
            current[id][key] = deepClone(value);
          } else {
            delete current[id][key];
          }
          content = JSON.stringify(current, null, 2);
          import_fs13.default.writeFileSync(filepath, content, "utf8");
        } catch (e) {
          logger36.error(`Error on update memos:`, e);
        }
      }
      createMemento(id) {
        return {
          get: (key, defaultValue) => {
            let res = this.fetchContent(id, key);
            return res === void 0 ? defaultValue : res;
          },
          update: async (key, value) => {
            await this.update(id, key, value);
          }
        };
      }
    };
  }
});

// src/util/lodash.ts
function defaults(obj, ...sources) {
  obj = Object(obj);
  sources.forEach((source) => {
    if (source != null) {
      source = Object(source);
      for (const key in source) {
        const value = obj[key];
        if (value === void 0 || value === objectProto[key] && !hasOwnProperty2.call(obj, key)) {
          obj[key] = source[key];
        }
      }
    }
  });
  return obj;
}
function omit(obj, properties) {
  let o = {};
  for (let key of Object.keys(obj)) {
    if (!properties.includes(key)) {
      o[key] = obj[key];
    }
  }
  return o;
}
var objectProto, hasOwnProperty2;
var init_lodash = __esm({
  "src/util/lodash.ts"() {
    objectProto = Object.prototype;
    hasOwnProperty2 = objectProto.hasOwnProperty;
  }
});

// src/provider/manager.ts
function addLocation(arr, location) {
  let { range, uri } = location;
  if (arr.find((o) => o.uri == uri && equals(o.range, range)) != null)
    return;
  arr.push(location);
}
var import_vscode_languageserver_protocol21, logger37, Manager;
var init_manager2 = __esm({
  "src/provider/manager.ts"() {
    import_vscode_languageserver_protocol21 = __toModule(require_main2());
    init_workspace();
    init_object();
    logger37 = require_logger2()("provider-manager");
    Manager = class {
      constructor() {
        this.providers = new Set();
      }
      hasProvider(document2) {
        return this.getProvider(document2) != null;
      }
      getProvider(document2) {
        let currScore = 0;
        let providerItem;
        for (let item of this.providers) {
          let { selector, priority } = item;
          let score5 = workspace_default.match(selector, document2);
          if (score5 == 0)
            continue;
          if (typeof priority == "number") {
            score5 = priority;
          }
          if (score5 < currScore)
            continue;
          currScore = score5;
          providerItem = item;
        }
        return providerItem;
      }
      getProviderById(id) {
        let item = Array.from(this.providers).find((o) => o.id == id);
        return item ? item.provider : null;
      }
      getProviders(document2) {
        let items = Array.from(this.providers);
        items = items.filter((item) => workspace_default.match(item.selector, document2) > 0);
        return items.sort((a, b) => workspace_default.match(b.selector, document2) - workspace_default.match(a.selector, document2));
      }
      toLocations(arr) {
        let res = [];
        for (let def of arr) {
          if (!def)
            continue;
          if (import_vscode_languageserver_protocol21.Location.is(def)) {
            addLocation(res, def);
          } else if (Array.isArray(def)) {
            for (let d of def) {
              if (import_vscode_languageserver_protocol21.Location.is(d)) {
                addLocation(res, d);
              } else if (import_vscode_languageserver_protocol21.LocationLink.is(d)) {
                let { targetUri, targetSelectionRange, targetRange } = d;
                addLocation(res, import_vscode_languageserver_protocol21.Location.create(targetUri, targetSelectionRange || targetRange));
              }
            }
          } else {
            logger37.error(`Bad definition`, def);
          }
        }
        return res;
      }
    };
  }
});

// src/provider/callHierarchyManager.ts
var import_vscode_languageserver_protocol22, CallHierarchyManager;
var init_callHierarchyManager = __esm({
  "src/provider/callHierarchyManager.ts"() {
    import_vscode_languageserver_protocol22 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    CallHierarchyManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol22.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async prepareCallHierarchy(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        if (provider.prepareCallHierarchy === null)
          return null;
        return await Promise.resolve(provider.prepareCallHierarchy(document2, position, token));
      }
      async provideCallHierarchyOutgoingCalls(document2, item, token) {
        let providerItem = this.getProvider(document2);
        if (!providerItem)
          return null;
        let { provider } = providerItem;
        if (provider.provideCallHierarchyOutgoingCalls === null)
          return null;
        return await Promise.resolve(provider.provideCallHierarchyOutgoingCalls(item, token));
      }
      async provideCallHierarchyIncomingCalls(document2, item, token) {
        let providerItem = this.getProvider(document2);
        if (!providerItem)
          return null;
        let { provider } = providerItem;
        if (provider.provideCallHierarchyIncomingCalls(item, token) === null)
          return null;
        return await Promise.resolve(provider.provideCallHierarchyIncomingCalls(item, token));
      }
    };
  }
});

// src/provider/codeActionManager.ts
var import_vscode_languageserver_protocol23, logger38, CodeActionManager;
var init_codeActionManager = __esm({
  "src/provider/codeActionManager.ts"() {
    import_vscode_languageserver_protocol23 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    logger38 = require_logger2()("codeActionManager");
    CodeActionManager = class extends Manager {
      constructor() {
        super(...arguments);
        this.providerMap = new WeakMap();
      }
      register(selector, provider, clientId, codeActionKinds) {
        let item = {
          id: v4_default(),
          selector,
          provider,
          kinds: codeActionKinds,
          clientId
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol23.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideCodeActions(document2, range, context, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        if (context.only) {
          let { only } = context;
          providers = providers.filter((p) => {
            if (p.kinds && !p.kinds.some((kind) => only.includes(kind))) {
              return false;
            }
            return true;
          });
        }
        let res = [];
        await Promise.all(providers.map((item) => {
          let { provider, id } = item;
          return Promise.resolve(provider.provideCodeActions(document2, range, context, token)).then((actions) => {
            if (!actions || actions.length == 0)
              return;
            for (let action of actions) {
              if (import_vscode_languageserver_protocol23.Command.is(action)) {
                let codeAction = {
                  title: action.title,
                  command: action
                };
                res.push(codeAction);
                this.providerMap.set(codeAction, id);
              } else {
                if (context.only) {
                  if (!action.kind)
                    continue;
                  let found = false;
                  for (let only of context.only) {
                    if (action.kind.startsWith(only)) {
                      found = true;
                      break;
                    }
                  }
                  if (!found)
                    continue;
                }
                let idx = res.findIndex((o) => o.title == action.title);
                if (idx == -1) {
                  this.providerMap.set(action, id);
                  res.push(action);
                }
              }
            }
          });
        }));
        return res;
      }
      async resolveCodeAction(codeAction, token) {
        if (codeAction.edit != null)
          return codeAction;
        let id = this.providerMap.get(codeAction);
        if (!id)
          throw new Error(`provider id not found from codeAction`);
        let provider = this.getProviderById(id);
        if (!provider || typeof provider.resolveCodeAction !== "function") {
          return codeAction;
        }
        let resolved = await Promise.resolve(provider.resolveCodeAction(codeAction, token));
        if (resolved)
          this.providerMap.set(resolved, id);
        return resolved || codeAction;
      }
    };
  }
});

// src/provider/codeLensManager.ts
var import_vscode_languageserver_protocol24, CodeLensManager;
var init_codeLensManager = __esm({
  "src/provider/codeLensManager.ts"() {
    import_vscode_languageserver_protocol24 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    init_lodash();
    CodeLensManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol24.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideCodeLenses(document2, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        let arr = await Promise.all(providers.map((item) => {
          let { provider, id } = item;
          return Promise.resolve(provider.provideCodeLenses(document2, token)).then((res) => {
            if (Array.isArray(res)) {
              for (let item2 of res) {
                item2.source = id;
              }
            }
            return res;
          });
        }));
        return [].concat(...arr);
      }
      async resolveCodeLens(codeLens, token) {
        if (codeLens.command)
          return codeLens;
        let { source } = codeLens;
        let provider = this.getProviderById(source);
        if (!provider || typeof provider.resolveCodeLens != "function") {
          return codeLens;
        }
        let res = await Promise.resolve(provider.resolveCodeLens(omit(codeLens, ["source"]), token));
        Object.assign(codeLens, res);
        return codeLens;
      }
    };
  }
});

// src/provider/declarationManager.ts
var import_vscode_languageserver_protocol25, logger39, DeclarationManager;
var init_declarationManager = __esm({
  "src/provider/declarationManager.ts"() {
    import_vscode_languageserver_protocol25 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    logger39 = require_logger2()("definitionManager");
    DeclarationManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol25.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDeclaration(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDeclaration(document2, position, token));
      }
    };
  }
});

// src/provider/definitionManager.ts
var import_vscode_languageserver_protocol26, logger40, DefinitionManager;
var init_definitionManager = __esm({
  "src/provider/definitionManager.ts"() {
    import_vscode_languageserver_protocol26 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    init_object();
    logger40 = require_logger2()("definitionManager");
    DefinitionManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol26.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async getDefinitions(document2, position, token) {
        const providers = this.getProviders(document2);
        if (!providers.length)
          return [];
        const arr = await Promise.all(providers.map((item) => {
          const { provider } = item;
          return Promise.resolve(provider.provideDefinition(document2, position, token));
        }));
        return arr;
      }
      async provideDefinition(document2, position, token) {
        const arr = await this.getDefinitions(document2, position, token);
        return this.toLocations(arr);
      }
      async provideDefinitionLinks(document2, position, token) {
        const arr = await this.getDefinitions(document2, position, token);
        const defs = [];
        for (const def of arr) {
          if (!Array.isArray(def))
            continue;
          for (const val of def) {
            if (import_vscode_languageserver_protocol26.LocationLink.is(val)) {
              let idx = defs.findIndex((o) => o.targetUri == val.targetUri && equals(o.targetRange, val.targetRange));
              if (idx == -1)
                defs.push(val);
            }
          }
        }
        return defs;
      }
    };
  }
});

// src/provider/documentColorManager.ts
var import_vscode_languageserver_protocol27, DocumentColorManager;
var init_documentColorManager = __esm({
  "src/provider/documentColorManager.ts"() {
    import_vscode_languageserver_protocol27 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    DocumentColorManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol27.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDocumentColors(document2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        let res = await Promise.resolve(provider.provideDocumentColors(document2, token));
        return res;
      }
      async provideColorPresentations(colorInformation, document2, token) {
        let { range, color } = colorInformation;
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        let res = await Promise.resolve(provider.provideColorPresentations(color, { document: document2, range }, token));
        return res;
      }
    };
  }
});

// src/provider/documentHighlightManager.ts
var import_vscode_languageserver_protocol28, DocumentHighlightManager;
var init_documentHighlightManager = __esm({
  "src/provider/documentHighlightManager.ts"() {
    import_vscode_languageserver_protocol28 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    DocumentHighlightManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol28.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDocumentHighlights(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentHighlights(document2, position, token));
      }
    };
  }
});

// src/provider/documentLinkManager.ts
var import_vscode_languageserver_protocol29, DocumentLinkManager;
var init_documentLinkManager = __esm({
  "src/provider/documentLinkManager.ts"() {
    import_vscode_languageserver_protocol29 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    DocumentLinkManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol29.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async _provideDocumentLinks(item, document2, token) {
        let { provider, id } = item;
        let items = await Promise.resolve(provider.provideDocumentLinks(document2, token));
        if (!items || !items.length)
          return [];
        items.forEach((item2) => {
          item2.data = item2.data || {};
          item2.data.source = id;
        });
        return items;
      }
      async provideDocumentLinks(document2, token) {
        let items = this.getProviders(document2);
        if (items.length == 0)
          return [];
        const arr = await Promise.all(items.map((item) => this._provideDocumentLinks(item, document2, token)));
        return [].concat(...arr);
      }
      async resolveDocumentLink(link, token) {
        let { data } = link;
        if (!data || !data.source)
          return null;
        for (let item of this.providers) {
          if (item.id == data.source) {
            let { provider } = item;
            link = await Promise.resolve(provider.resolveDocumentLink(link, token));
            return link;
          }
        }
        return null;
      }
    };
  }
});

// src/provider/documentSymbolManager.ts
var import_vscode_languageserver_protocol30, DocumentSymbolManager;
var init_documentSymbolManager = __esm({
  "src/provider/documentSymbolManager.ts"() {
    import_vscode_languageserver_protocol30 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    DocumentSymbolManager = class extends Manager {
      register(selector, provider, displayName) {
        let item = {
          id: v4_default(),
          displayName,
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol30.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDocumentSymbols(document2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentSymbols(document2, token)) || [];
      }
    };
  }
});

// src/provider/foldingRangeManager.ts
var import_vscode_languageserver_protocol31, FoldingRangeManager;
var init_foldingRangeManager = __esm({
  "src/provider/foldingRangeManager.ts"() {
    import_vscode_languageserver_protocol31 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    FoldingRangeManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol31.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideFoldingRanges(document2, context, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideFoldingRanges(document2, context, token)) || [];
      }
    };
  }
});

// src/provider/formatManager.ts
var import_vscode_languageserver_protocol32, FormatManager;
var init_formatManager = __esm({
  "src/provider/formatManager.ts"() {
    import_vscode_languageserver_protocol32 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    FormatManager = class extends Manager {
      register(selector, provider, priority = 0) {
        let item = {
          id: v4_default(),
          selector,
          priority,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol32.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      handles(doc) {
        return this.getProvider(doc) != null;
      }
      async provideDocumentFormattingEdits(document2, options, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentFormattingEdits(document2, options, token));
      }
    };
  }
});

// src/provider/formatRangeManager.ts
var import_vscode_languageserver_protocol33, FormatRangeManager;
var init_formatRangeManager = __esm({
  "src/provider/formatRangeManager.ts"() {
    import_vscode_languageserver_protocol33 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    FormatRangeManager = class extends Manager {
      register(selector, provider, priority = 0) {
        let item = {
          id: v4_default(),
          selector,
          provider,
          priority
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol33.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDocumentRangeFormattingEdits(document2, range, options, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentRangeFormattingEdits(document2, range, options, token));
      }
    };
  }
});

// src/provider/hoverManager.ts
var import_vscode_languageserver_protocol34, HoverManager;
var init_hoverManager = __esm({
  "src/provider/hoverManager.ts"() {
    import_vscode_languageserver_protocol34 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    HoverManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol34.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideHover(document2, position, token) {
        let items = this.getProviders(document2);
        if (items.length === 0)
          return null;
        let res = [];
        for (let i = 0, len = items.length; i < len; i += 1) {
          const item = items[i];
          let hover = await Promise.resolve(item.provider.provideHover(document2, position, token));
          if (hover && hover.contents != "")
            res.push(hover);
        }
        return res;
      }
    };
  }
});

// src/provider/implementationManager.ts
var import_vscode_languageserver_protocol35, ImplementationManager;
var init_implementationManager = __esm({
  "src/provider/implementationManager.ts"() {
    import_vscode_languageserver_protocol35 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    ImplementationManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol35.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideReferences(document2, position, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        let arr = await Promise.all(providers.map((item) => {
          let { provider } = item;
          return Promise.resolve(provider.provideImplementation(document2, position, token));
        }));
        return this.toLocations(arr);
      }
    };
  }
});

// src/provider/linkedEditingRangeManager.ts
var import_vscode_languageserver_protocol36, logger41, LinkedEditingRangeManager;
var init_linkedEditingRangeManager = __esm({
  "src/provider/linkedEditingRangeManager.ts"() {
    init_esm_node();
    import_vscode_languageserver_protocol36 = __toModule(require_main2());
    init_manager2();
    logger41 = require_logger2()("linkedEditingManager");
    LinkedEditingRangeManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol36.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideLinkedEditingRanges(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        if (!provider.provideLinkedEditingRanges)
          return null;
        return await Promise.resolve(provider.provideLinkedEditingRanges(document2, position, token));
      }
    };
  }
});

// src/provider/onTypeFormatManager.ts
var import_vscode_languageserver_protocol37, logger42, OnTypeFormatManager;
var init_onTypeFormatManager = __esm({
  "src/provider/onTypeFormatManager.ts"() {
    import_vscode_languageserver_protocol37 = __toModule(require_main2());
    init_workspace();
    logger42 = require_logger2()("onTypeFormatManager");
    OnTypeFormatManager = class {
      constructor() {
        this.providers = new Set();
      }
      register(selector, provider, triggerCharacters) {
        let item = {
          triggerCharacters,
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol37.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      hasProvider(document2) {
        for (let o of this.providers) {
          let { selector } = o;
          if (workspace_default.match(selector, document2) > 0) {
            return true;
          }
        }
        return false;
      }
      getProvider(document2, triggerCharacter) {
        for (let o of this.providers) {
          let { triggerCharacters, selector } = o;
          if (workspace_default.match(selector, document2) > 0 && triggerCharacters.includes(triggerCharacter)) {
            return o.provider;
          }
        }
        return null;
      }
      async onCharacterType(character, document2, position, token) {
        let provider = this.getProvider(document2, character);
        if (!provider)
          return;
        let formatOpts = await workspace_default.getFormatOptions(document2.uri);
        return await Promise.resolve(provider.provideOnTypeFormattingEdits(document2, position, character, formatOpts, token));
      }
    };
  }
});

// src/provider/referenceManager.ts
var import_vscode_languageserver_protocol38, ReferenceManager;
var init_referenceManager = __esm({
  "src/provider/referenceManager.ts"() {
    import_vscode_languageserver_protocol38 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    ReferenceManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol38.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideReferences(document2, position, context, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        let arr = await Promise.all(providers.map((item) => {
          let { provider } = item;
          return Promise.resolve(provider.provideReferences(document2, position, context, token));
        }));
        return this.toLocations(arr);
      }
    };
  }
});

// src/provider/renameManager.ts
var import_vscode_languageserver_protocol39, RenameManager;
var init_renameManager = __esm({
  "src/provider/renameManager.ts"() {
    import_vscode_languageserver_protocol39 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    RenameManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol39.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideRenameEdits(document2, position, newName, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideRenameEdits(document2, position, newName, token));
      }
      async prepareRename(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        if (provider.prepareRename == null)
          return null;
        let res = await Promise.resolve(provider.prepareRename(document2, position, token));
        if (res == null)
          return false;
        return res;
      }
    };
  }
});

// src/provider/selectionRangeManager.ts
var import_vscode_languageserver_protocol40, SelectionRangeManager;
var init_selectionRangeManager = __esm({
  "src/provider/selectionRangeManager.ts"() {
    import_vscode_languageserver_protocol40 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    SelectionRangeManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol40.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideSelectionRanges(document2, positions2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        let ranges = await Promise.resolve(provider.provideSelectionRanges(document2, positions2, token));
        if (!ranges || ranges.length == 0)
          return [];
        for (let i = 0; i < ranges.length - 1; i++) {
          let r = ranges[i];
          if (!r.parent)
            r.parent = ranges[i + 1];
        }
        return ranges;
      }
    };
  }
});

// src/provider/semanticTokensManager.ts
var import_vscode_languageserver_protocol41, logger43, SemanticTokensManager;
var init_semanticTokensManager = __esm({
  "src/provider/semanticTokensManager.ts"() {
    init_esm_node();
    import_vscode_languageserver_protocol41 = __toModule(require_main2());
    init_manager2();
    logger43 = require_logger2()("semanticTokensManager");
    SemanticTokensManager = class extends Manager {
      constructor() {
        super(...arguments);
        this.resolvedProvider = new Map();
      }
      register(selector, provider, legend, onChange) {
        let id = v4_default();
        let item = {
          id,
          selector,
          legend,
          provider
        };
        this.providers.add(item);
        let disposable;
        if (typeof provider.onDidChangeSemanticTokens === "function") {
          disposable = provider.onDidChangeSemanticTokens(() => {
            onChange();
          });
        }
        return import_vscode_languageserver_protocol41.Disposable.create(() => {
          disposable == null ? void 0 : disposable.dispose();
          for (let [uri, providerId] of this.resolvedProvider.entries()) {
            if (providerId == id) {
              this.resolvedProvider.delete(uri);
            }
          }
          this.providers.delete(item);
        });
      }
      getLegend(document2) {
        const item = this.getProvider(document2);
        if (!item)
          return;
        this.resolvedProvider.set(document2.uri, item.id);
        return item.legend;
      }
      resolveProvider(document2) {
        var _a2;
        let id = this.resolvedProvider.get(document2.uri);
        if (id)
          return this.getProviderById(id);
        return (_a2 = this.getProvider(document2)) == null ? void 0 : _a2.provider;
      }
      hasSemanticTokensEdits(document2) {
        let provider = this.resolveProvider(document2);
        if (!provider)
          return false;
        return typeof provider.provideDocumentSemanticTokensEdits === "function";
      }
      async provideDocumentSemanticTokens(document2, token) {
        let provider = this.resolveProvider(document2);
        if (!provider || typeof provider.provideDocumentSemanticTokens !== "function")
          return null;
        return await Promise.resolve(provider.provideDocumentSemanticTokens(document2, token));
      }
      async provideDocumentSemanticTokensEdits(document2, previousResultId, token) {
        let provider = this.resolveProvider(document2);
        if (!provider || typeof provider.provideDocumentSemanticTokensEdits !== "function")
          return null;
        return await Promise.resolve(provider.provideDocumentSemanticTokensEdits(document2, previousResultId, token));
      }
    };
  }
});

// src/provider/semanticTokensRangeManager.ts
var import_vscode_languageserver_protocol42, logger44, SemanticTokensRangeManager;
var init_semanticTokensRangeManager = __esm({
  "src/provider/semanticTokensRangeManager.ts"() {
    init_esm_node();
    import_vscode_languageserver_protocol42 = __toModule(require_main2());
    init_manager2();
    logger44 = require_logger2()("semanticTokensRangeManager");
    SemanticTokensRangeManager = class extends Manager {
      register(selector, provider, legend) {
        let item = {
          id: v4_default(),
          selector,
          legend,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol42.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      getLegend(document2) {
        const item = this.getProvider(document2);
        if (!item)
          return;
        return item.legend;
      }
      async provideDocumentRangeSemanticTokens(document2, range, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        if (provider.provideDocumentRangeSemanticTokens === null)
          return null;
        return await Promise.resolve(provider.provideDocumentRangeSemanticTokens(document2, range, token));
      }
    };
  }
});

// src/provider/signatureManager.ts
var import_vscode_languageserver_protocol43, SignatureManager;
var init_signatureManager = __esm({
  "src/provider/signatureManager.ts"() {
    import_vscode_languageserver_protocol43 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    SignatureManager = class extends Manager {
      register(selector, provider, triggerCharacters) {
        let characters = triggerCharacters.reduce((p, c) => p.concat(c.length == 1 ? [c] : c.split(/\s*/g)), []);
        let item = {
          id: v4_default(),
          selector,
          provider,
          triggerCharacters: characters
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol43.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      shouldTrigger(document2, triggerCharacter) {
        let item = this.getProvider(document2);
        if (!item)
          return false;
        let { triggerCharacters } = item;
        return triggerCharacters && triggerCharacters.indexOf(triggerCharacter) != -1;
      }
      async provideSignatureHelp(document2, position, token, context) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let res = await Promise.resolve(item.provider.provideSignatureHelp(document2, position, token, context));
        if (res && res.signatures && res.signatures.length)
          return res;
        return null;
      }
    };
  }
});

// src/provider/typeDefinitionManager.ts
var import_vscode_languageserver_protocol44, TypeDefinitionManager;
var init_typeDefinitionManager = __esm({
  "src/provider/typeDefinitionManager.ts"() {
    import_vscode_languageserver_protocol44 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    TypeDefinitionManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol44.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideTypeDefinition(document2, position, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        let arr = await Promise.all(providers.map((item) => {
          let { provider } = item;
          return Promise.resolve(provider.provideTypeDefinition(document2, position, token));
        }));
        return this.toLocations(arr);
      }
    };
  }
});

// src/provider/workspaceSymbolsManager.ts
var import_vscode_languageserver_protocol45, WorkspaceSymbolManager;
var init_workspaceSymbolsManager = __esm({
  "src/provider/workspaceSymbolsManager.ts"() {
    init_esm_node();
    import_vscode_languageserver_protocol45 = __toModule(require_main2());
    WorkspaceSymbolManager = class {
      constructor() {
        this.providers = new Map();
      }
      register(provider) {
        let id = v4_default();
        this.providers.set(id, provider);
        return import_vscode_languageserver_protocol45.Disposable.create(() => {
          this.providers.delete(id);
        });
      }
      async provideWorkspaceSymbols(query, token) {
        let entries = Array.from(this.providers.entries());
        if (!entries.length)
          return [];
        let res = [];
        await Promise.all(entries.map((o) => {
          let [id, p] = o;
          return Promise.resolve(p.provideWorkspaceSymbols(query, token)).then((list2) => {
            if (list2)
              res.push(...list2.map((item) => Object.assign({ source: id }, item)));
          });
        }));
        return res;
      }
      async resolveWorkspaceSymbol(symbolInfo, token) {
        let provider = this.providers.get(symbolInfo.source);
        if (!provider)
          return;
        if (typeof provider.resolveWorkspaceSymbol != "function") {
          return Promise.resolve(symbolInfo);
        }
        return await Promise.resolve(provider.resolveWorkspaceSymbol(symbolInfo, token));
      }
      hasProvider() {
        return this.providers.size > 0;
      }
    };
  }
});

// src/languages.ts
var import_vscode_languageserver_protocol46, logger45, Languages, languages_default;
var init_languages = __esm({
  "src/languages.ts"() {
    import_vscode_languageserver_protocol46 = __toModule(require_main2());
    init_manager();
    init_callHierarchyManager();
    init_codeActionManager();
    init_codeLensManager();
    init_declarationManager();
    init_definitionManager();
    init_documentColorManager();
    init_documentHighlightManager();
    init_documentLinkManager();
    init_documentSymbolManager();
    init_foldingRangeManager();
    init_formatManager();
    init_formatRangeManager();
    init_hoverManager();
    init_implementationManager();
    init_linkedEditingRangeManager();
    init_onTypeFormatManager();
    init_referenceManager();
    init_renameManager();
    init_selectionRangeManager();
    init_semanticTokensManager();
    init_semanticTokensRangeManager();
    init_signatureManager();
    init_typeDefinitionManager();
    init_workspaceSymbolsManager();
    logger45 = require_logger2()("languages");
    Languages = class {
      constructor() {
        this._onDidSemanticTokensRefresh = new import_vscode_languageserver_protocol46.Emitter();
        this.onDidSemanticTokensRefresh = this._onDidSemanticTokensRefresh.event;
        this.onTypeFormatManager = new OnTypeFormatManager();
        this.documentLinkManager = new DocumentLinkManager();
        this.documentColorManager = new DocumentColorManager();
        this.foldingRangeManager = new FoldingRangeManager();
        this.renameManager = new RenameManager();
        this.formatManager = new FormatManager();
        this.codeActionManager = new CodeActionManager();
        this.workspaceSymbolsManager = new WorkspaceSymbolManager();
        this.formatRangeManager = new FormatRangeManager();
        this.hoverManager = new HoverManager();
        this.signatureManager = new SignatureManager();
        this.documentSymbolManager = new DocumentSymbolManager();
        this.documentHighlightManager = new DocumentHighlightManager();
        this.definitionManager = new DefinitionManager();
        this.declarationManager = new DeclarationManager();
        this.typeDefinitionManager = new TypeDefinitionManager();
        this.referenceManager = new ReferenceManager();
        this.implementationManager = new ImplementationManager();
        this.codeLensManager = new CodeLensManager();
        this.selectionRangeManager = new SelectionRangeManager();
        this.callHierarchyManager = new CallHierarchyManager();
        this.semanticTokensManager = new SemanticTokensManager();
        this.semanticTokensRangeManager = new SemanticTokensRangeManager();
        this.linkedEditingManager = new LinkedEditingRangeManager();
        this.cancelTokenSource = new import_vscode_languageserver_protocol46.CancellationTokenSource();
      }
      hasFormatProvider(doc) {
        if (this.formatManager.hasProvider(doc)) {
          return true;
        }
        if (this.formatRangeManager.hasProvider(doc)) {
          return true;
        }
        return false;
      }
      registerOnTypeFormattingEditProvider(selector, provider, triggerCharacters) {
        return this.onTypeFormatManager.register(selector, provider, triggerCharacters);
      }
      registerCompletionItemProvider(name2, shortcut, selector, provider, triggerCharacters = [], priority, allCommitCharacters) {
        selector = typeof selector == "string" ? [{ language: selector }] : selector;
        let sources = (init_sources2(), sources_exports).default;
        return sources.createLanguageSource(name2, shortcut, selector, provider, triggerCharacters, priority, allCommitCharacters);
      }
      registerCodeActionProvider(selector, provider, clientId, codeActionKinds) {
        return this.codeActionManager.register(selector, provider, clientId, codeActionKinds);
      }
      registerHoverProvider(selector, provider) {
        return this.hoverManager.register(selector, provider);
      }
      registerSelectionRangeProvider(selector, provider) {
        return this.selectionRangeManager.register(selector, provider);
      }
      registerSignatureHelpProvider(selector, provider, triggerCharacters) {
        return this.signatureManager.register(selector, provider, triggerCharacters);
      }
      registerDocumentSymbolProvider(selector, provider, metadata) {
        return this.documentSymbolManager.register(selector, provider, metadata == null ? void 0 : metadata.label);
      }
      registerFoldingRangeProvider(selector, provider) {
        return this.foldingRangeManager.register(selector, provider);
      }
      registerDocumentHighlightProvider(selector, provider) {
        return this.documentHighlightManager.register(selector, provider);
      }
      registerCodeLensProvider(selector, provider) {
        return this.codeLensManager.register(selector, provider);
      }
      registerDocumentLinkProvider(selector, provider) {
        return this.documentLinkManager.register(selector, provider);
      }
      registerDocumentColorProvider(selector, provider) {
        return this.documentColorManager.register(selector, provider);
      }
      registerDefinitionProvider(selector, provider) {
        return this.definitionManager.register(selector, provider);
      }
      registerDeclarationProvider(selector, provider) {
        return this.declarationManager.register(selector, provider);
      }
      registerTypeDefinitionProvider(selector, provider) {
        return this.typeDefinitionManager.register(selector, provider);
      }
      registerImplementationProvider(selector, provider) {
        return this.implementationManager.register(selector, provider);
      }
      registerReferencesProvider(selector, provider) {
        return this.referenceManager.register(selector, provider);
      }
      registerRenameProvider(selector, provider) {
        return this.renameManager.register(selector, provider);
      }
      registerWorkspaceSymbolProvider(provider) {
        if (arguments.length > 1 && typeof arguments[1].provideWorkspaceSymbols === "function") {
          provider = arguments[1];
        }
        return this.workspaceSymbolsManager.register(provider);
      }
      registerDocumentFormatProvider(selector, provider, priority = 0) {
        return this.formatManager.register(selector, provider, priority);
      }
      registerDocumentRangeFormatProvider(selector, provider, priority = 0) {
        return this.formatRangeManager.register(selector, provider, priority);
      }
      registerCallHierarchyProvider(selector, provider) {
        return this.callHierarchyManager.register(selector, provider);
      }
      registerDocumentSemanticTokensProvider(selector, provider, legend) {
        this._onDidSemanticTokensRefresh.fire(selector);
        return this.semanticTokensManager.register(selector, provider, legend, () => {
          this._onDidSemanticTokensRefresh.fire(selector);
        });
      }
      registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
        this._onDidSemanticTokensRefresh.fire(selector);
        return this.semanticTokensRangeManager.register(selector, provider, legend);
      }
      registerLinkedEditingRangeProvider(selector, provider) {
        return this.linkedEditingManager.register(selector, provider);
      }
      shouldTriggerSignatureHelp(document2, triggerCharacter) {
        return this.signatureManager.shouldTrigger(document2, triggerCharacter);
      }
      async getHover(document2, position, token) {
        return await this.hoverManager.provideHover(document2, position, token);
      }
      async getSignatureHelp(document2, position, token, context) {
        return await this.signatureManager.provideSignatureHelp(document2, position, token, context);
      }
      async getDefinition(document2, position, token) {
        if (!this.definitionManager.hasProvider(document2))
          return null;
        return await this.definitionManager.provideDefinition(document2, position, token);
      }
      async getDefinitionLinks(document2, position, token) {
        if (!this.definitionManager.hasProvider(document2))
          return null;
        return await this.definitionManager.provideDefinitionLinks(document2, position, token);
      }
      async getDeclaration(document2, position, token) {
        if (!this.declarationManager.hasProvider(document2))
          return null;
        return await this.declarationManager.provideDeclaration(document2, position, token);
      }
      async getTypeDefinition(document2, position, token) {
        if (!this.typeDefinitionManager.hasProvider(document2))
          return null;
        return await this.typeDefinitionManager.provideTypeDefinition(document2, position, token);
      }
      async getImplementation(document2, position, token) {
        if (!this.implementationManager.hasProvider(document2))
          return null;
        return await this.implementationManager.provideReferences(document2, position, token);
      }
      async getReferences(document2, context, position, token) {
        if (!this.referenceManager.hasProvider(document2))
          return null;
        return await this.referenceManager.provideReferences(document2, position, context, token);
      }
      async getDocumentSymbol(document2, token) {
        return await this.documentSymbolManager.provideDocumentSymbols(document2, token);
      }
      async getSelectionRanges(document2, positions2, token) {
        return await this.selectionRangeManager.provideSelectionRanges(document2, positions2, token);
      }
      async getWorkspaceSymbols(query, token) {
        query = query || "";
        return await this.workspaceSymbolsManager.provideWorkspaceSymbols(query, token);
      }
      async resolveWorkspaceSymbol(symbol, token) {
        return await this.workspaceSymbolsManager.resolveWorkspaceSymbol(symbol, token);
      }
      async prepareRename(document2, position, token) {
        return await this.renameManager.prepareRename(document2, position, token);
      }
      async provideRenameEdits(document2, position, newName, token) {
        return await this.renameManager.provideRenameEdits(document2, position, newName, token);
      }
      async provideDocumentFormattingEdits(document2, options, token) {
        if (!this.formatManager.hasProvider(document2)) {
          let hasRangeFormater = this.formatRangeManager.hasProvider(document2);
          if (!hasRangeFormater)
            return null;
          let end = document2.positionAt(document2.getText().length);
          let range = import_vscode_languageserver_protocol46.Range.create(import_vscode_languageserver_protocol46.Position.create(0, 0), end);
          return await this.provideDocumentRangeFormattingEdits(document2, range, options, token);
        }
        return await this.formatManager.provideDocumentFormattingEdits(document2, options, token);
      }
      async provideDocumentRangeFormattingEdits(document2, range, options, token) {
        if (!this.formatRangeManager.hasProvider(document2))
          return null;
        return await this.formatRangeManager.provideDocumentRangeFormattingEdits(document2, range, options, token);
      }
      async getCodeActions(document2, range, context, token) {
        return await this.codeActionManager.provideCodeActions(document2, range, context, token);
      }
      async getDocumentHighLight(document2, position, token) {
        return await this.documentHighlightManager.provideDocumentHighlights(document2, position, token);
      }
      async getDocumentLinks(document2, token) {
        if (!this.documentLinkManager.hasProvider(document2)) {
          return null;
        }
        return await this.documentLinkManager.provideDocumentLinks(document2, token) || [];
      }
      async resolveDocumentLink(link) {
        return await this.documentLinkManager.resolveDocumentLink(link, this.token);
      }
      async provideDocumentColors(document2, token) {
        return await this.documentColorManager.provideDocumentColors(document2, token);
      }
      async provideFoldingRanges(document2, context, token) {
        if (!this.foldingRangeManager.hasProvider(document2)) {
          return null;
        }
        return await this.foldingRangeManager.provideFoldingRanges(document2, context, token);
      }
      async provideColorPresentations(color, document2, token) {
        return await this.documentColorManager.provideColorPresentations(color, document2, token);
      }
      async getCodeLens(document2, token) {
        return await this.codeLensManager.provideCodeLenses(document2, token);
      }
      async resolveCodeLens(codeLens, token) {
        if (codeLens.command != null)
          return codeLens;
        return await this.codeLensManager.resolveCodeLens(codeLens, token);
      }
      async resolveCodeAction(codeAction, token) {
        return await this.codeActionManager.resolveCodeAction(codeAction, token);
      }
      async provideDocumentOnTypeEdits(character, document2, position, token) {
        return this.onTypeFormatManager.onCharacterType(character, document2, position, token);
      }
      canFormatOnType(character, document2) {
        return this.onTypeFormatManager.getProvider(document2, character) != null;
      }
      async prepareCallHierarchy(document2, position, token) {
        return this.callHierarchyManager.prepareCallHierarchy(document2, position, token);
      }
      async provideIncomingCalls(document2, item, token) {
        return this.callHierarchyManager.provideCallHierarchyIncomingCalls(document2, item, token);
      }
      async provideOutgoingCalls(document2, item, token) {
        return this.callHierarchyManager.provideCallHierarchyOutgoingCalls(document2, item, token);
      }
      getLegend(document2, range) {
        if (range)
          return this.semanticTokensRangeManager.getLegend(document2);
        return this.semanticTokensManager.getLegend(document2);
      }
      hasSemanticTokensEdits(document2) {
        return this.semanticTokensManager.hasSemanticTokensEdits(document2);
      }
      async provideDocumentSemanticTokens(document2, token) {
        return this.semanticTokensManager.provideDocumentSemanticTokens(document2, token);
      }
      async provideDocumentSemanticTokensEdits(document2, previousResultId, token) {
        return this.semanticTokensManager.provideDocumentSemanticTokensEdits(document2, previousResultId, token);
      }
      async provideDocumentRangeSemanticTokens(document2, range, token) {
        return this.semanticTokensRangeManager.provideDocumentRangeSemanticTokens(document2, range, token);
      }
      hasLinkedEditing(document2) {
        return this.linkedEditingManager.hasProvider(document2);
      }
      async provideLinkedEdits(document2, position, token) {
        return this.linkedEditingManager.provideLinkedEditingRanges(document2, position, token);
      }
      hasProvider(id, document2) {
        switch (id) {
          case "formatOnType":
            return this.onTypeFormatManager.hasProvider(document2);
          case "rename":
            return this.renameManager.hasProvider(document2);
          case "onTypeEdit":
            return this.onTypeFormatManager.hasProvider(document2);
          case "documentLink":
            return this.documentLinkManager.hasProvider(document2);
          case "documentColor":
            return this.documentColorManager.hasProvider(document2);
          case "foldingRange":
            return this.foldingRangeManager.hasProvider(document2);
          case "format":
            return this.formatManager.hasProvider(document2) || this.formatRangeManager.hasProvider(document2);
          case "codeAction":
            return this.codeActionManager.hasProvider(document2);
          case "workspaceSymbols":
            return this.workspaceSymbolsManager.hasProvider();
          case "formatRange":
            return this.formatRangeManager.hasProvider(document2);
          case "hover":
            return this.hoverManager.hasProvider(document2);
          case "signature":
            return this.signatureManager.hasProvider(document2);
          case "documentSymbol":
            return this.documentSymbolManager.hasProvider(document2);
          case "documentHighlight":
            return this.documentHighlightManager.hasProvider(document2);
          case "definition":
            return this.definitionManager.hasProvider(document2);
          case "declaration":
            return this.declarationManager.hasProvider(document2);
          case "typeDefinition":
            return this.typeDefinitionManager.hasProvider(document2);
          case "reference":
            return this.referenceManager.hasProvider(document2);
          case "implementation":
            return this.implementationManager.hasProvider(document2);
          case "codeLens":
            return this.codeLensManager.hasProvider(document2);
          case "selectionRange":
            return this.selectionRangeManager.hasProvider(document2);
          case "callHierarchy":
            return this.callHierarchyManager.hasProvider(document2);
          case "semanticTokens":
            return this.semanticTokensManager.hasProvider(document2);
          case "linkedEditing":
            return this.linkedEditingManager.hasProvider(document2);
          default:
            throw new Error(`Invalid provider name: ${id}`);
        }
      }
      createDiagnosticCollection(owner) {
        return manager_default.create(owner);
      }
      get token() {
        this.cancelTokenSource = new import_vscode_languageserver_protocol46.CancellationTokenSource();
        return this.cancelTokenSource.token;
      }
    };
    languages_default = new Languages();
  }
});

// src/model/highligher.ts
var Highlighter;
var init_highligher = __esm({
  "src/model/highligher.ts"() {
    init_ansiparse();
    init_string();
    Highlighter = class {
      constructor() {
        this.lines = [];
        this.highlights = [];
      }
      addLine(line, hlGroup) {
        if (line.includes("\n")) {
          for (let content of line.split(/\r?\n/)) {
            this.addLine(content, hlGroup);
          }
          return;
        }
        if (hlGroup) {
          this.highlights.push({
            lnum: this.lines.length,
            colStart: line.match(/^\s*/)[0].length,
            colEnd: byteLength(line),
            hlGroup
          });
        }
        if (line.includes("")) {
          let res = parseAnsiHighlights(line);
          for (let hl of res.highlights) {
            let { span, hlGroup: hlGroup2 } = hl;
            if (span[0] != span[1]) {
              this.highlights.push({
                lnum: this.lines.length,
                colStart: span[0],
                colEnd: span[1],
                hlGroup: hlGroup2
              });
            }
          }
          this.lines.push(res.line);
        } else {
          this.lines.push(line);
        }
      }
      addLines(lines) {
        this.lines.push(...lines);
      }
      addTexts(items) {
        this.addLines("");
        for (let item of items) {
          this.addText(item.text, item.hlGroup);
        }
      }
      addText(text, hlGroup) {
        let { lines } = this;
        let pre = lines[lines.length - 1] || "";
        if (hlGroup) {
          let colStart = byteLength(pre);
          this.highlights.push({
            lnum: lines.length ? lines.length - 1 : 0,
            colStart,
            colEnd: colStart + byteLength(text),
            hlGroup
          });
        }
        if (lines.length) {
          lines[lines.length - 1] = `${pre}${text}`;
        } else {
          lines.push(text);
        }
      }
      get length() {
        return this.lines.length;
      }
      getline(line) {
        return this.lines[line] || "";
      }
      render(buffer, start = 0, end = -1) {
        buffer.setLines(this.lines, { start, end, strictIndexing: false }, true);
        for (let item of this.highlights) {
          buffer.addHighlight({
            hlGroup: item.hlGroup,
            colStart: item.colStart,
            colEnd: item.colEnd == null ? -1 : item.colEnd,
            line: start + item.lnum,
            srcId: -1
          });
        }
      }
    };
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main2();
  }
});

// src/util/processes.ts
function terminate(process2, cwd) {
  if (process2.killed)
    return;
  if (isWindows3) {
    try {
      let options = {
        stdio: ["pipe", "pipe", "ignore"]
      };
      if (cwd) {
        options.cwd = cwd;
      }
      cp.execFileSync("taskkill", ["/T", "/F", "/PID", process2.pid.toString()], options);
      return true;
    } catch (err) {
      return false;
    }
  } else if (isLinux2 || isMacintosh2) {
    try {
      let filepath = (0, import_path16.join)(pluginRoot2, "bin/terminateProcess.sh");
      if (!import_fs14.default.existsSync(filepath)) {
        console.error(`"${filepath}" not found`);
        return false;
      }
      let result = cp.spawnSync(filepath, [process2.pid.toString()]);
      return result.error ? false : true;
    } catch (err) {
      return false;
    }
  } else {
    process2.kill("SIGKILL");
    return true;
  }
}
var cp, import_path16, import_fs14, isWindows3, isMacintosh2, isLinux2, pluginRoot2;
var init_processes = __esm({
  "src/util/processes.ts"() {
    cp = __toModule(require("child_process"));
    import_path16 = __toModule(require("path"));
    import_fs14 = __toModule(require("fs"));
    isWindows3 = process.platform === "win32";
    isMacintosh2 = process.platform === "darwin";
    isLinux2 = process.platform === "linux";
    pluginRoot2 = false ? resolve2(__dirname, "../..") : (0, import_path16.dirname)(__dirname);
  }
});

// src/language-client/progressPart.ts
var import_vscode_languageserver_protocol47, logger46, ProgressPart;
var init_progressPart = __esm({
  "src/language-client/progressPart.ts"() {
    import_vscode_languageserver_protocol47 = __toModule(require_main2());
    init_util();
    init_window();
    "use strict";
    logger46 = require_logger2()("language-client-progressPart");
    ProgressPart = class {
      constructor(client, token, done) {
        this.client = client;
        this.token = token;
        this.disposables = [];
        this._cancelled = false;
        this.statusBarItem = window_default.createStatusBarItem(99, { progress: true });
        this.disposables.push(client.onProgress(import_vscode_languageserver_protocol47.WorkDoneProgress.type, this.token, (value) => {
          switch (value.kind) {
            case "begin":
              this.begin(value);
              break;
            case "report":
              this.report(value);
              break;
            case "end":
              this.done(value.message);
              done && done(this);
              break;
          }
        }));
      }
      begin(params) {
        if (typeof this.title === "string")
          return;
        this.title = params.title;
        this.report(params);
      }
      report(params) {
        let statusBarItem = this.statusBarItem;
        let parts = [];
        if (this.title)
          parts.push(this.title);
        if (typeof params.percentage == "number")
          parts.push(params.percentage.toFixed(0) + "%");
        if (params.message)
          parts.push(params.message);
        statusBarItem.text = parts.join(" ");
        statusBarItem.show();
      }
      cancel() {
        if (this._cancelled)
          return;
        this._cancelled = true;
        disposeAll(this.disposables);
      }
      done(message) {
        if (this._cancelled)
          return;
        const statusBarItem = this.statusBarItem;
        statusBarItem.text = `${this.title} ${message || "finished"}`;
        setTimeout(() => {
          statusBarItem.dispose();
        }, 300);
        this.cancel();
      }
    };
  }
});

// src/language-client/utils/async.ts
var import_vscode_languageserver_protocol48, Delayer;
var init_async = __esm({
  "src/language-client/utils/async.ts"() {
    import_vscode_languageserver_protocol48 = __toModule(require_main2());
    Delayer = class {
      constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = void 0;
        this.completionPromise = void 0;
        this.onSuccess = void 0;
        this.task = void 0;
      }
      trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
          this.cancelTimeout();
        }
        if (!this.completionPromise) {
          this.completionPromise = new Promise((resolve3) => {
            this.onSuccess = resolve3;
          }).then(() => {
            this.completionPromise = void 0;
            this.onSuccess = void 0;
            let result = this.task();
            this.task = void 0;
            return result;
          });
        }
        if (delay >= 0 || this.timeout === void 0) {
          this.timeout = (0, import_vscode_languageserver_protocol48.RAL)().timer.setTimeout(() => {
            this.timeout = void 0;
            this.onSuccess(void 0);
          }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
      }
      forceDelivery() {
        if (!this.completionPromise) {
          return void 0;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = void 0;
        this.onSuccess = void 0;
        this.task = void 0;
        return result;
      }
      isTriggered() {
        return this.timeout !== void 0;
      }
      cancel() {
        this.cancelTimeout();
        this.completionPromise = void 0;
      }
      dispose() {
        this.cancelTimeout();
      }
      cancelTimeout() {
        if (this.timeout !== void 0) {
          (0, import_vscode_languageserver_protocol48.RAL)().timer.clearTimeout(this.timeout);
          this.timeout = void 0;
        }
      }
    };
  }
});

// src/language-client/utils/converter.ts
function convertToTextDocumentItem(document2) {
  return {
    uri: document2.uri,
    languageId: document2.languageId,
    version: document2.version,
    text: document2.getText()
  };
}
function asCloseTextDocumentParams(document2) {
  return {
    textDocument: {
      uri: document2.uri
    }
  };
}
function asChangeTextDocumentParams(document2) {
  let result = {
    textDocument: {
      uri: document2.uri,
      version: document2.version
    },
    contentChanges: [{ text: document2.getText() }]
  };
  return result;
}
function asWillSaveTextDocumentParams(event) {
  return {
    textDocument: asVersionedTextDocumentIdentifier(event.document),
    reason: event.reason
  };
}
function asVersionedTextDocumentIdentifier(textDocument) {
  return {
    uri: textDocument.uri,
    version: textDocument.version
  };
}
function asSaveTextDocumentParams(document2, includeText) {
  let result = {
    textDocument: asVersionedTextDocumentIdentifier(document2)
  };
  if (includeText) {
    result.text = document2.getText();
  }
  return result;
}
function asUri(resource) {
  return resource.toString();
}
function asCompletionParams(textDocument, position, context) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position,
    context: omit(context, ["option"])
  };
}
function asTextDocumentPositionParams(textDocument, position) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position
  };
}
function asSignatureHelpParams(textDocument, position, context) {
  return {
    textDocument: asTextDocumentIdentifier(textDocument),
    position,
    context
  };
}
function asTextDocumentIdentifier(textDocument) {
  return {
    uri: textDocument.uri
  };
}
function asReferenceParams(textDocument, position, options) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position,
    context: { includeDeclaration: options.includeDeclaration }
  };
}
function asDocumentSymbolParams(textDocument) {
  return {
    textDocument: {
      uri: textDocument.uri
    }
  };
}
function asCodeLensParams(textDocument) {
  return {
    textDocument: {
      uri: textDocument.uri
    }
  };
}
var init_converter = __esm({
  "src/language-client/utils/converter.ts"() {
    init_lodash();
  }
});

// src/language-client/utils/uuid.ts
function generateUuid() {
  return v4_default();
}
var init_uuid = __esm({
  "src/language-client/utils/uuid.ts"() {
    init_esm_node();
  }
});

// src/language-client/client.ts
function createConnection(input, output, errorHandler, closeHandler, options) {
  let logger113 = new ConsoleLogger();
  let connection = (0, import_vscode_languageserver_protocol49.createProtocolConnection)(input, output, logger113, options);
  connection.onError((data) => {
    errorHandler(data[0], data[1], data[2]);
  });
  connection.onClose(closeHandler);
  let result = {
    listen: () => connection.listen(),
    sendRequest: (type, ...params) => connection.sendRequest(string(type) ? type : type.method, ...params),
    onRequest: (type, handler) => connection.onRequest(string(type) ? type : type.method, handler),
    sendNotification: (type, params) => connection.sendNotification(string(type) ? type : type.method, params),
    onNotification: (type, handler) => connection.onNotification(string(type) ? type : type.method, handler),
    onProgress: connection.onProgress,
    sendProgress: connection.sendProgress,
    trace: (value, tracer, sendNotificationOrTraceOptions) => {
      const defaultTraceOptions = {
        sendNotification: false,
        traceFormat: import_vscode_languageserver_protocol49.TraceFormat.Text
      };
      if (sendNotificationOrTraceOptions === void 0) {
        connection.trace(value, tracer, defaultTraceOptions);
      } else if (boolean(sendNotificationOrTraceOptions)) {
        connection.trace(value, tracer, sendNotificationOrTraceOptions);
      } else {
        connection.trace(value, tracer, sendNotificationOrTraceOptions);
      }
    },
    initialize: (params) => connection.sendRequest(import_vscode_languageserver_protocol49.InitializeRequest.type, params),
    shutdown: () => connection.sendRequest(import_vscode_languageserver_protocol49.ShutdownRequest.type, void 0),
    exit: () => connection.sendNotification(import_vscode_languageserver_protocol49.ExitNotification.type),
    onLogMessage: (handler) => connection.onNotification(import_vscode_languageserver_protocol49.LogMessageNotification.type, handler),
    onShowMessage: (handler) => connection.onNotification(import_vscode_languageserver_protocol49.ShowMessageNotification.type, handler),
    onTelemetry: (handler) => connection.onNotification(import_vscode_languageserver_protocol49.TelemetryEventNotification.type, handler),
    didChangeConfiguration: (params) => connection.sendNotification(import_vscode_languageserver_protocol49.DidChangeConfigurationNotification.type, params),
    didChangeWatchedFiles: (params) => connection.sendNotification(import_vscode_languageserver_protocol49.DidChangeWatchedFilesNotification.type, params),
    didOpenTextDocument: (params) => connection.sendNotification(import_vscode_languageserver_protocol49.DidOpenTextDocumentNotification.type, params),
    didChangeTextDocument: (params) => connection.sendNotification(import_vscode_languageserver_protocol49.DidChangeTextDocumentNotification.type, params),
    didCloseTextDocument: (params) => connection.sendNotification(import_vscode_languageserver_protocol49.DidCloseTextDocumentNotification.type, params),
    didSaveTextDocument: (params) => connection.sendNotification(import_vscode_languageserver_protocol49.DidSaveTextDocumentNotification.type, params),
    onDiagnostics: (handler) => connection.onNotification(import_vscode_languageserver_protocol49.PublishDiagnosticsNotification.type, handler),
    dispose: () => connection.dispose()
  };
  return result;
}
function ensure(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_path17, import_vscode_languageserver_protocol49, import_os7, logger47, ConsoleLogger, NullLogger, ErrorAction, CloseAction, DefaultErrorHandler, RevealOutputChannelOn, State2, ClientState, SupportedSymbolKinds, SupportedCompletionItemKinds, SupportedSymbolTags, DynamicFeature, DocumentNotifications, DidOpenTextDocumentFeature, DidCloseTextDocumentFeature, DidChangeTextDocumentFeature, WillSaveFeature, WillSaveWaitUntilFeature, DidSaveTextDocumentFeature, FileSystemWatcherFeature, TextDocumentFeature, WorkspaceFeature, CompletionItemFeature, HoverFeature, SignatureHelpFeature, DefinitionFeature, ReferencesFeature, DocumentHighlightFeature, DocumentSymbolFeature, WorkspaceSymbolFeature, CodeActionFeature, CodeLensFeature, DocumentFormattingFeature, DocumentRangeFormattingFeature, DocumentOnTypeFormattingFeature, RenameFeature, DocumentLinkFeature, ConfigurationFeature, ExecuteCommandFeature, MessageTransports, OnReady, BaseLanguageClient;
var init_client = __esm({
  "src/language-client/client.ts"() {
    import_path17 = __toModule(require("path"));
    import_vscode_languageserver_protocol49 = __toModule(require_main2());
    init_esm2();
    init_commands2();
    init_languages();
    init_fs();
    init_is();
    init_lodash();
    init_window();
    init_workspace();
    init_sources2();
    init_progressPart();
    init_async();
    import_os7 = __toModule(require("os"));
    init_converter();
    init_uuid();
    logger47 = require_logger2()("language-client-client");
    ConsoleLogger = class {
      error(message) {
        logger47.error(message);
      }
      warn(message) {
        logger47.warn(message);
      }
      info(message) {
        logger47.info(message);
      }
      log(message) {
        logger47.log(message);
      }
    };
    NullLogger = class {
      error(_message) {
      }
      warn(_message) {
      }
      info(_message) {
      }
      log(_message) {
      }
    };
    (function(ErrorAction2) {
      ErrorAction2[ErrorAction2["Continue"] = 1] = "Continue";
      ErrorAction2[ErrorAction2["Shutdown"] = 2] = "Shutdown";
    })(ErrorAction || (ErrorAction = {}));
    (function(CloseAction2) {
      CloseAction2[CloseAction2["DoNotRestart"] = 1] = "DoNotRestart";
      CloseAction2[CloseAction2["Restart"] = 2] = "Restart";
    })(CloseAction || (CloseAction = {}));
    DefaultErrorHandler = class {
      constructor(name2, maxRestartCount) {
        this.name = name2;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
      }
      error(_error, _message, count) {
        if (count && count <= 3) {
          return 1;
        }
        return 2;
      }
      closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length < this.maxRestartCount) {
          return 2;
        } else {
          let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
          if (diff <= 3 * 60 * 1e3) {
            window_default.showMessage(`The "${this.name}" server crashed ${this.maxRestartCount} times in the last 3 minutes. The server will not be restarted.`, "error");
            return 1;
          } else {
            this.restarts.shift();
            return 2;
          }
        }
      }
    };
    (function(RevealOutputChannelOn2) {
      RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
    })(RevealOutputChannelOn || (RevealOutputChannelOn = {}));
    (function(State3) {
      State3[State3["Stopped"] = 1] = "Stopped";
      State3[State3["Running"] = 2] = "Running";
      State3[State3["Starting"] = 3] = "Starting";
    })(State2 || (State2 = {}));
    (function(ClientState2) {
      ClientState2[ClientState2["Initial"] = 0] = "Initial";
      ClientState2[ClientState2["Starting"] = 1] = "Starting";
      ClientState2[ClientState2["StartFailed"] = 2] = "StartFailed";
      ClientState2[ClientState2["Running"] = 3] = "Running";
      ClientState2[ClientState2["Stopping"] = 4] = "Stopping";
      ClientState2[ClientState2["Stopped"] = 5] = "Stopped";
    })(ClientState || (ClientState = {}));
    SupportedSymbolKinds = [
      import_vscode_languageserver_protocol49.SymbolKind.File,
      import_vscode_languageserver_protocol49.SymbolKind.Module,
      import_vscode_languageserver_protocol49.SymbolKind.Namespace,
      import_vscode_languageserver_protocol49.SymbolKind.Package,
      import_vscode_languageserver_protocol49.SymbolKind.Class,
      import_vscode_languageserver_protocol49.SymbolKind.Method,
      import_vscode_languageserver_protocol49.SymbolKind.Property,
      import_vscode_languageserver_protocol49.SymbolKind.Field,
      import_vscode_languageserver_protocol49.SymbolKind.Constructor,
      import_vscode_languageserver_protocol49.SymbolKind.Enum,
      import_vscode_languageserver_protocol49.SymbolKind.Interface,
      import_vscode_languageserver_protocol49.SymbolKind.Function,
      import_vscode_languageserver_protocol49.SymbolKind.Variable,
      import_vscode_languageserver_protocol49.SymbolKind.Constant,
      import_vscode_languageserver_protocol49.SymbolKind.String,
      import_vscode_languageserver_protocol49.SymbolKind.Number,
      import_vscode_languageserver_protocol49.SymbolKind.Boolean,
      import_vscode_languageserver_protocol49.SymbolKind.Array,
      import_vscode_languageserver_protocol49.SymbolKind.Object,
      import_vscode_languageserver_protocol49.SymbolKind.Key,
      import_vscode_languageserver_protocol49.SymbolKind.Null,
      import_vscode_languageserver_protocol49.SymbolKind.EnumMember,
      import_vscode_languageserver_protocol49.SymbolKind.Struct,
      import_vscode_languageserver_protocol49.SymbolKind.Event,
      import_vscode_languageserver_protocol49.SymbolKind.Operator,
      import_vscode_languageserver_protocol49.SymbolKind.TypeParameter
    ];
    SupportedCompletionItemKinds = [
      import_vscode_languageserver_protocol49.CompletionItemKind.Text,
      import_vscode_languageserver_protocol49.CompletionItemKind.Method,
      import_vscode_languageserver_protocol49.CompletionItemKind.Function,
      import_vscode_languageserver_protocol49.CompletionItemKind.Constructor,
      import_vscode_languageserver_protocol49.CompletionItemKind.Field,
      import_vscode_languageserver_protocol49.CompletionItemKind.Variable,
      import_vscode_languageserver_protocol49.CompletionItemKind.Class,
      import_vscode_languageserver_protocol49.CompletionItemKind.Interface,
      import_vscode_languageserver_protocol49.CompletionItemKind.Module,
      import_vscode_languageserver_protocol49.CompletionItemKind.Property,
      import_vscode_languageserver_protocol49.CompletionItemKind.Unit,
      import_vscode_languageserver_protocol49.CompletionItemKind.Value,
      import_vscode_languageserver_protocol49.CompletionItemKind.Enum,
      import_vscode_languageserver_protocol49.CompletionItemKind.Keyword,
      import_vscode_languageserver_protocol49.CompletionItemKind.Snippet,
      import_vscode_languageserver_protocol49.CompletionItemKind.Color,
      import_vscode_languageserver_protocol49.CompletionItemKind.File,
      import_vscode_languageserver_protocol49.CompletionItemKind.Reference,
      import_vscode_languageserver_protocol49.CompletionItemKind.Folder,
      import_vscode_languageserver_protocol49.CompletionItemKind.EnumMember,
      import_vscode_languageserver_protocol49.CompletionItemKind.Constant,
      import_vscode_languageserver_protocol49.CompletionItemKind.Struct,
      import_vscode_languageserver_protocol49.CompletionItemKind.Event,
      import_vscode_languageserver_protocol49.CompletionItemKind.Operator,
      import_vscode_languageserver_protocol49.CompletionItemKind.TypeParameter
    ];
    SupportedSymbolTags = [
      import_vscode_languageserver_protocol49.SymbolTag.Deprecated
    ];
    (function(DynamicFeature3) {
      function is(value) {
        let candidate = value;
        return candidate && func(candidate.register) && func(candidate.unregister) && func(candidate.dispose) && candidate.registrationType !== void 0;
      }
      DynamicFeature3.is = is;
    })(DynamicFeature || (DynamicFeature = {}));
    DocumentNotifications = class {
      constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._middleware = _middleware;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = new Map();
      }
      static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
          if (workspace_default.match(selector, textDocument) > 0) {
            return true;
          }
        }
        return false;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = this._event(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      callback(data) {
        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
          if (this._middleware) {
            this._middleware(data, (data2) => this._client.sendNotification(this._type, this._createParams(data2)));
          } else {
            this._client.sendNotification(this._type, this._createParams(data));
          }
          this.notificationSent(data);
        }
      }
      notificationSent(_data) {
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const selector of this._selectors.values()) {
          if (workspace_default.match(selector, document2)) {
            return {
              send: (data) => {
                this.callback(data);
              }
            };
          }
        }
        return void 0;
      }
    };
    DidOpenTextDocumentFeature = class extends DocumentNotifications {
      constructor(client, _syncedDocuments) {
        super(client, workspace_default.onDidOpenTextDocument, import_vscode_languageserver_protocol49.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => {
          return { textDocument: convertToTextDocumentItem(textDocument) };
        }, DocumentNotifications.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
      }
      get registrationType() {
        return import_vscode_languageserver_protocol49.DidOpenTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let documentSelector = data.registerOptions.documentSelector;
        workspace_default.textDocuments.forEach((textDocument) => {
          let uri = textDocument.uri.toString();
          if (this._syncedDocuments.has(uri)) {
            return;
          }
          if (workspace_default.match(documentSelector, textDocument) > 0) {
            let middleware = this._client.clientOptions.middleware;
            let didOpen = (textDocument2) => {
              this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            if (middleware.didOpen) {
              middleware.didOpen(textDocument, didOpen);
            } else {
              didOpen(textDocument);
            }
            this._syncedDocuments.set(uri, textDocument);
          }
        });
      }
      notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
      }
    };
    DidCloseTextDocumentFeature = class extends DocumentNotifications {
      constructor(client, _syncedDocuments) {
        super(client, workspace_default.onDidCloseTextDocument, import_vscode_languageserver_protocol49.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => asCloseTextDocumentParams(textDocument), DocumentNotifications.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
      }
      get registrationType() {
        return import_vscode_languageserver_protocol49.DidCloseTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.delete(textDocument.uri.toString());
      }
      unregister(id) {
        let selector = this._selectors.get(id);
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
          if (workspace_default.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument)) {
            let middleware = this._client.clientOptions.middleware;
            let didClose = (textDocument2) => {
              this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            this._syncedDocuments.delete(textDocument.uri.toString());
            if (middleware.didClose) {
              middleware.didClose(textDocument, didClose);
            } else {
              didClose(textDocument);
            }
          }
        });
      }
    };
    DidChangeTextDocumentFeature = class {
      constructor(_client) {
        this._client = _client;
        this._changeData = new Map();
      }
      get registrationType() {
        return import_vscode_languageserver_protocol49.DidChangeTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== import_vscode_languageserver_protocol49.TextDocumentSyncKind.None) {
          this.register({
            id: generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, { syncKind: textDocumentSyncOptions.change })
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = workspace_default.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
          documentSelector: data.registerOptions.documentSelector,
          syncKind: data.registerOptions.syncKind
        });
      }
      callback(event) {
        if (event.contentChanges.length === 0) {
          return;
        }
        let doc = workspace_default.getDocument(event.textDocument.uri);
        if (!doc)
          return;
        let { textDocument } = doc;
        for (const changeData of this._changeData.values()) {
          if (workspace_default.match(changeData.documentSelector, textDocument) > 0) {
            let middleware = this._client.clientOptions.middleware;
            if (changeData.syncKind === import_vscode_languageserver_protocol49.TextDocumentSyncKind.Incremental) {
              if (middleware.didChange) {
                middleware.didChange(event, () => this._client.sendNotification(import_vscode_languageserver_protocol49.DidChangeTextDocumentNotification.type, omit(event, ["bufnr", "original"])));
              } else {
                this._client.sendNotification(import_vscode_languageserver_protocol49.DidChangeTextDocumentNotification.type, omit(event, ["bufnr", "original"]));
              }
            } else if (changeData.syncKind === import_vscode_languageserver_protocol49.TextDocumentSyncKind.Full) {
              let didChange = (event2) => {
                let { textDocument: textDocument2 } = workspace_default.getDocument(event2.textDocument.uri);
                this._client.sendNotification(import_vscode_languageserver_protocol49.DidChangeTextDocumentNotification.type, asChangeTextDocumentParams(textDocument2));
              };
              if (middleware.didChange) {
                middleware.didChange(event, didChange);
              } else {
                didChange(event);
              }
            }
          }
        }
      }
      unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._changeData.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const changeData of this._changeData.values()) {
          if (workspace_default.match(changeData.documentSelector, document2)) {
            return {
              send: (event) => {
                this.callback(event);
              }
            };
          }
        }
        return void 0;
      }
    };
    WillSaveFeature = class extends DocumentNotifications {
      constructor(client) {
        super(client, workspace_default.onWillSaveTextDocument, import_vscode_languageserver_protocol49.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, (willSaveEvent) => asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifications.textDocumentFilter(selectors, willSaveEvent.document));
      }
      get registrationType() {
        return import_vscode_languageserver_protocol49.WillSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSave = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
    };
    WillSaveWaitUntilFeature = class {
      constructor(_client) {
        this._client = _client;
        this._selectors = new Map();
      }
      get registrationType() {
        return import_vscode_languageserver_protocol49.WillSaveTextDocumentWaitUntilRequest.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSaveWaitUntil = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = workspace_default.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      callback(event) {
        if (DocumentNotifications.textDocumentFilter(this._selectors.values(), event.document)) {
          let middleware = this._client.clientOptions.middleware;
          let willSaveWaitUntil = (event2) => {
            return this._client.sendRequest(import_vscode_languageserver_protocol49.WillSaveTextDocumentWaitUntilRequest.type, asWillSaveTextDocumentParams(event2)).then((edits) => {
              return edits ? edits : [];
            }, (e) => {
              window_default.showMessage(`Error on willSaveWaitUntil: ${e}`, "error");
              logger47.error(e);
              return [];
            });
          };
          event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
        }
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
    };
    DidSaveTextDocumentFeature = class extends DocumentNotifications {
      constructor(client) {
        super(client, workspace_default.onDidSaveTextDocument, import_vscode_languageserver_protocol49.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, (textDocument) => asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifications.textDocumentFilter);
        this._includeText = false;
      }
      get registrationType() {
        return import_vscode_languageserver_protocol49.DidSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").didSave = true;
      }
      initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
          const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
          this.register({
            id: generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, saveOptions)
          });
        }
      }
      register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
      }
    };
    FileSystemWatcherFeature = class {
      constructor(_client, _notifyFileEvent) {
        this._notifyFileEvent = _notifyFileEvent;
        this._watchers = new Map();
      }
      get registrationType() {
        return import_vscode_languageserver_protocol49.DidChangeWatchedFilesNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
      }
      initialize(_capabilities, _documentSelector) {
      }
      register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
          return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
          if (!string(watcher.globPattern)) {
            continue;
          }
          let watchCreate = true, watchChange = true, watchDelete = true;
          if (watcher.kind != null) {
            watchCreate = (watcher.kind & import_vscode_languageserver_protocol49.WatchKind.Create) !== 0;
            watchChange = (watcher.kind & import_vscode_languageserver_protocol49.WatchKind.Change) != 0;
            watchDelete = (watcher.kind & import_vscode_languageserver_protocol49.WatchKind.Delete) != 0;
          }
          let fileSystemWatcher = workspace_default.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
          this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
          disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
      }
      registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
          disposables.push(fileSystemWatcher);
          this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
      }
      hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
          fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
            uri: asUri(resource),
            type: import_vscode_languageserver_protocol49.FileChangeType.Created
          }), null, listeners);
        }
        if (watchChange) {
          fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
            uri: asUri(resource),
            type: import_vscode_languageserver_protocol49.FileChangeType.Changed
          }), null, listeners);
        }
        if (watchDelete) {
          fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
            uri: asUri(resource),
            type: import_vscode_languageserver_protocol49.FileChangeType.Deleted
          }), null, listeners);
        }
      }
      unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        }
      }
      dispose() {
        this._watchers.forEach((disposables) => {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        });
        this._watchers.clear();
      }
    };
    TextDocumentFeature = class {
      constructor(_client, _registrationType) {
        this._client = _client;
        this._registrationType = _registrationType;
        this._registrations = new Map();
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getRegistration(documentSelector, capability) {
        if (!capability) {
          return [void 0, void 0];
        } else if (import_vscode_languageserver_protocol49.TextDocumentRegistrationOptions.is(capability)) {
          const id = import_vscode_languageserver_protocol49.StaticRegistrationOptions.hasId(capability) ? capability.id : generateUuid();
          const selector = capability.documentSelector || documentSelector;
          if (selector) {
            return [id, Object.assign({}, capability, { documentSelector: selector })];
          }
        } else if (boolean(capability) && capability === true || import_vscode_languageserver_protocol49.WorkDoneProgressOptions.is(capability)) {
          if (!documentSelector) {
            return [void 0, void 0];
          }
          let options = boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
          return [generateUuid(), options];
        }
        return [void 0, void 0];
      }
      getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
          return void 0;
        }
        return boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
      }
      getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
          let selector = registration.data.registerOptions.documentSelector;
          if (selector !== null && workspace_default.match(selector, textDocument) > 0) {
            return registration.provider;
          }
        }
        return void 0;
      }
      getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
          result.push(item.provider);
        }
        return result;
      }
    };
    WorkspaceFeature = class {
      constructor(_client, _registrationType) {
        this._client = _client;
        this._registrationType = _registrationType;
        this._registrations = new Map();
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
      }
      unregister(id) {
        const registration = this._registrations.get(id);
        if (registration)
          registration.disposable.dispose();
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
          result.push(registration.provider);
        }
        return result;
      }
    };
    CompletionItemFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.CompletionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let snippetSupport = this._client.clientOptions.disableSnippetCompletion !== true;
        let completion = ensure(ensure(capabilities, "textDocument"), "completion");
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
          snippetSupport,
          commitCharactersSupport: true,
          documentationFormat: this._client.supporedMarkupKind,
          deprecatedSupport: true,
          preselectSupport: true,
          insertReplaceSupport: true,
          tagSupport: { valueSet: [import_vscode_languageserver_protocol49.CompletionItemTag.Deprecated] },
          resolveSupport: { properties: ["documentation", "detail", "additionalTextEdits"] },
          insertTextModeSupport: { valueSet: [import_vscode_languageserver_protocol49.InsertTextMode.asIs, import_vscode_languageserver_protocol49.InsertTextMode.adjustIndentation] }
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
      }
      initialize(capabilities, documentSelector) {
        this.index = 0;
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        let triggerCharacters = options.triggerCharacters || [];
        let allCommitCharacters = options.allCommitCharacters || [];
        let priority = options.priority;
        const provider = {
          provideCompletionItems: (document2, position, token, context) => {
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const provideCompletionItems = (document3, position2, context2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.CompletionRequest.type, asCompletionParams(document3, position2, context2), token2).then((result) => result, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.CompletionRequest.type, token2, error, null);
              });
            };
            return middleware.provideCompletionItem ? middleware.provideCompletionItem(document2, position, context, token, provideCompletionItems) : provideCompletionItems(document2, position, context, token);
          },
          resolveCompletionItem: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const resolveCompletionItem = (item2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.CompletionResolveRequest.type, item2, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.CompletionResolveRequest.type, token2, error, item2);
              });
            };
            return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
          } : void 0
        };
        let name2 = this._client.id + (this.index ? "-" + this.index : "");
        sources_default.removeSource(name2);
        const disposable = languages_default.registerCompletionItemProvider(name2, "LS", options.documentSelector || this._client.clientOptions.documentSelector, provider, triggerCharacters, priority, allCommitCharacters);
        this.index = this.index + 1;
        return [disposable, provider];
      }
    };
    HoverFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.HoverRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const hoverCapability = ensure(ensure(capabilities, "textDocument"), "hover");
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = this._client.supporedMarkupKind;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideHover: (document2, position, token) => {
            const client = this._client;
            const provideHover = (document3, position2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.HoverRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.HoverRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideHover ? middleware.provideHover(document2, position, token, provideHover) : provideHover(document2, position, token);
          }
        };
        return [languages_default.registerHoverProvider(options.documentSelector, provider), provider];
      }
    };
    SignatureHelpFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.SignatureHelpRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let config = ensure(ensure(capabilities, "textDocument"), "signatureHelp");
        config.dynamicRegistration = true;
        config.contextSupport = true;
        config.signatureInformation = {
          documentationFormat: this._client.supporedMarkupKind,
          activeParameterSupport: true,
          parameterInformation: {
            labelOffsetSupport: true
          }
        };
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideSignatureHelp: (document2, position, token, context) => {
            const client = this._client;
            const providerSignatureHelp = (document3, position2, context2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.SignatureHelpRequest.type, asSignatureHelpParams(document3, position2, context2), token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.SignatureHelpRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document2, position, context, token, providerSignatureHelp) : providerSignatureHelp(document2, position, context, token);
          }
        };
        const triggerCharacters = options.triggerCharacters || [];
        const disposable = languages_default.registerSignatureHelpProvider(options.documentSelector, provider, triggerCharacters);
        return [disposable, provider];
      }
    };
    DefinitionFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.DefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let definitionSupport = ensure(ensure(capabilities, "textDocument"), "definition");
        definitionSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDefinition: (document2, position, token) => {
            const client = this._client;
            const provideDefinition = (document3, position2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.DefinitionRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.DefinitionRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDefinition ? middleware.provideDefinition(document2, position, token, provideDefinition) : provideDefinition(document2, position, token);
          }
        };
        return [languages_default.registerDefinitionProvider(options.documentSelector, provider), provider];
      }
    };
    ReferencesFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.ReferencesRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "references").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideReferences: (document2, position, options2, token) => {
            const client = this._client;
            const _providerReferences = (document3, position2, options3, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.ReferencesRequest.type, asReferenceParams(document3, position2, options3), token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.ReferencesRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideReferences ? middleware.provideReferences(document2, position, options2, token, _providerReferences) : _providerReferences(document2, position, options2, token);
          }
        };
        return [languages_default.registerReferencesProvider(options.documentSelector, provider), provider];
      }
    };
    DocumentHighlightFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.DocumentHighlightRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "documentHighlight").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentHighlights: (document2, position, token) => {
            const client = this._client;
            const _provideDocumentHighlights = (document3, position2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.DocumentHighlightRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.DocumentHighlightRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document2, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document2, position, token);
          }
        };
        return [languages_default.registerDocumentHighlightProvider(options.documentSelector, provider), provider];
      }
    };
    DocumentSymbolFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.DocumentSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "textDocument"), "documentSymbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentSymbols: (document2, token) => {
            const client = this._client;
            const _provideDocumentSymbols = (document3, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.DocumentSymbolRequest.type, asDocumentSymbolParams(document3), token2).then((data) => {
                if (data === null) {
                  return void 0;
                }
                if (data.length === 0) {
                  return [];
                } else {
                  let element = data[0];
                  if (import_vscode_languageserver_protocol49.DocumentSymbol.is(element)) {
                    return data;
                  } else {
                    return data;
                  }
                }
              }, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.DocumentSymbolRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document2, token, _provideDocumentSymbols) : _provideDocumentSymbols(document2, token);
          }
        };
        const metadata = options.label ? { label: options.label } : void 0;
        return [languages_default.registerDocumentSymbolProvider(options.documentSelector, provider, metadata), provider];
      }
    };
    WorkspaceSymbolFeature = class extends WorkspaceFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.WorkspaceSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "workspace"), "symbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
      }
      initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
      }
      registerLanguageProvider(_options) {
        const provider = {
          provideWorkspaceSymbols: (query, token) => {
            const client = this._client;
            const provideWorkspaceSymbols = (query2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.WorkspaceSymbolRequest.type, { query: query2 }, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.WorkspaceSymbolRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
          }
        };
        return [languages_default.registerWorkspaceSymbolProvider(provider), provider];
      }
    };
    CodeActionFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.CodeActionRequest.type);
        this.disposables = [];
      }
      fillClientCapabilities(capabilities) {
        const cap = ensure(ensure(capabilities, "textDocument"), "codeAction");
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        cap.honorsChangeAnnotations = false;
        cap.resolveSupport = {
          properties: ["edit"]
        };
        cap.codeActionLiteralSupport = {
          codeActionKind: {
            valueSet: [
              import_vscode_languageserver_protocol49.CodeActionKind.Empty,
              import_vscode_languageserver_protocol49.CodeActionKind.QuickFix,
              import_vscode_languageserver_protocol49.CodeActionKind.Refactor,
              import_vscode_languageserver_protocol49.CodeActionKind.RefactorExtract,
              import_vscode_languageserver_protocol49.CodeActionKind.RefactorInline,
              import_vscode_languageserver_protocol49.CodeActionKind.RefactorRewrite,
              import_vscode_languageserver_protocol49.CodeActionKind.Source,
              import_vscode_languageserver_protocol49.CodeActionKind.SourceOrganizeImports
            ]
          }
        };
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const registCommand = (id) => {
          if (commands_default.has(id))
            return;
          const client = this._client;
          const executeCommand = (command, args) => {
            const params = {
              command,
              arguments: args
            };
            return client.sendRequest(import_vscode_languageserver_protocol49.ExecuteCommandRequest.type, params).then(void 0, (error) => {
              client.handleFailedRequest(import_vscode_languageserver_protocol49.ExecuteCommandRequest.type, void 0, error, void 0);
              throw error;
            });
          };
          const middleware = client.clientOptions.middleware;
          this.disposables.push(commands_default.registerCommand(id, (...args) => {
            return middleware.executeCommand ? middleware.executeCommand(id, args, executeCommand) : executeCommand(id, args);
          }, null, true));
        };
        const provider = {
          provideCodeActions: (document2, range, context, token) => {
            const client = this._client;
            const _provideCodeActions = (document3, range2, context2, token2) => {
              const params = {
                textDocument: {
                  uri: document3.uri
                },
                range: range2,
                context: context2
              };
              return client.sendRequest(import_vscode_languageserver_protocol49.CodeActionRequest.type, params, token2).then((values) => {
                if (values === null) {
                  return void 0;
                }
                values.forEach((val) => {
                  var _a2;
                  let cmd = import_vscode_languageserver_protocol49.Command.is(val) ? val.command : (_a2 = val.command) == null ? void 0 : _a2.command;
                  if (cmd && !commands_default.has(cmd))
                    registCommand(cmd);
                });
                return values;
              }, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.CodeActionRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideCodeActions ? middleware.provideCodeActions(document2, range, context, token, _provideCodeActions) : _provideCodeActions(document2, range, context, token);
          },
          resolveCodeAction: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const resolveCodeAction = (item2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.CodeActionResolveRequest.type, item2, token2).then((values) => values, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.CodeActionResolveRequest.type, token2, error, item2);
              });
            };
            return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
          } : void 0
        };
        return [languages_default.registerCodeActionProvider(options.documentSelector, provider, this._client.id, options.codeActionKinds), provider];
      }
      dispose() {
        this.disposables.forEach((o) => {
          o.dispose();
        });
        this.disposables = [];
        super.dispose();
      }
    };
    CodeLensFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.CodeLensRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "codeLens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(import_vscode_languageserver_protocol49.CodeLensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeCodeLensEmitter.fire();
          }
        });
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const emitter = new import_vscode_languageserver_protocol49.Emitter();
        const provider = {
          onDidChangeCodeLenses: emitter.event,
          provideCodeLenses: (document2, token) => {
            const client = this._client;
            const provideCodeLenses = (document3, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.CodeLensRequest.type, asCodeLensParams(document3), token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.CodeLensRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideCodeLenses ? middleware.provideCodeLenses(document2, token, provideCodeLenses) : provideCodeLenses(document2, token);
          },
          resolveCodeLens: options.resolveProvider ? (codeLens, token) => {
            const client = this._client;
            const resolveCodeLens = (codeLens2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.CodeLensResolveRequest.type, codeLens2, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.CodeLensResolveRequest.type, token2, error, codeLens2);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
          } : void 0
        };
        return [languages_default.registerCodeLensProvider(options.documentSelector, provider), { provider, onDidChangeCodeLensEmitter: emitter }];
      }
    };
    DocumentFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.DocumentFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "formatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentFormattingEdits: (document2, options2, token) => {
            const client = this._client;
            const provideDocumentFormattingEdits = (document3, options3, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                options: options3
              };
              return client.sendRequest(import_vscode_languageserver_protocol49.DocumentFormattingRequest.type, params, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.DocumentFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document2, options2, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document2, options2, token);
          }
        };
        return [
          languages_default.registerDocumentFormatProvider(options.documentSelector, provider, this._client.clientOptions.formatterPriority),
          provider
        ];
      }
    };
    DocumentRangeFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.DocumentRangeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "rangeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentRangeFormattingEdits: (document2, range, options2, token) => {
            const client = this._client;
            const provideDocumentRangeFormattingEdits = (document3, range2, options3, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                range: range2,
                options: options3
              };
              return client.sendRequest(import_vscode_languageserver_protocol49.DocumentRangeFormattingRequest.type, params, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.DocumentRangeFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document2, range, options2, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document2, range, options2, token);
          }
        };
        return [languages_default.registerDocumentRangeFormatProvider(options.documentSelector, provider), provider];
      }
    };
    DocumentOnTypeFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.DocumentOnTypeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideOnTypeFormattingEdits: (document2, position, ch, options2, token) => {
            const client = this._client;
            const provideOnTypeFormattingEdits = (document3, position2, ch2, options3, token2) => {
              const params = {
                textDocument: asVersionedTextDocumentIdentifier(document3),
                position: position2,
                ch: ch2,
                options: options3
              };
              return client.sendRequest(import_vscode_languageserver_protocol49.DocumentOnTypeFormattingRequest.type, params, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.DocumentOnTypeFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document2, position, ch, options2, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document2, position, ch, options2, token);
          }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        const characters = [options.firstTriggerCharacter, ...moreTriggerCharacter];
        return [languages_default.registerOnTypeFormattingEditProvider(options.documentSelector, provider, characters), provider];
      }
    };
    RenameFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.RenameRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let rename = ensure(ensure(capabilities, "textDocument"), "rename");
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
          return;
        }
        if (boolean(capabilities.renameProvider)) {
          options.prepareProvider = false;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideRenameEdits: (document2, position, newName, token) => {
            const client = this._client;
            const provideRenameEdits = (document3, position2, newName2, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                position: position2,
                newName: newName2
              };
              return client.sendRequest(import_vscode_languageserver_protocol49.RenameRequest.type, params, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.RenameRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideRenameEdits ? middleware.provideRenameEdits(document2, position, newName, token, provideRenameEdits) : provideRenameEdits(document2, position, newName, token);
          },
          prepareRename: options.prepareProvider ? (document2, position, token) => {
            const client = this._client;
            const prepareRename = (document3, position2, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3),
                position: position2
              };
              return client.sendRequest(import_vscode_languageserver_protocol49.PrepareRenameRequest.type, params, token2).then((result) => {
                if (import_vscode_languageserver_protocol49.Range.is(result)) {
                  return result;
                } else if (this.isDefaultBehavior(result)) {
                  return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
                } else if (result && import_vscode_languageserver_protocol49.Range.is(result.range)) {
                  return {
                    range: result.range,
                    placeholder: result.placeholder
                  };
                }
                return Promise.reject(new Error(`The element can't be renamed.`));
              }, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.PrepareRenameRequest.type, token2, error, void 0);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.prepareRename ? middleware.prepareRename(document2, position, token, prepareRename) : prepareRename(document2, position, token);
          } : void 0
        };
        return [languages_default.registerRenameProvider(options.documentSelector, provider), provider];
      }
      isDefaultBehavior(value) {
        const candidate = value;
        return candidate && boolean(candidate.defaultBehavior);
      }
    };
    DocumentLinkFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.DocumentLinkRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = ensure(ensure(capabilities, "textDocument"), "documentLink");
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentLinks: (document2, token) => {
            const client = this._client;
            const provideDocumentLinks = (document3, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.DocumentLinkRequest.type, {
                textDocument: { uri: document3.uri }
              }, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.DocumentLinkRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document2, token, provideDocumentLinks) : provideDocumentLinks(document2, token);
          },
          resolveDocumentLink: options.resolveProvider ? (link, token) => {
            const client = this._client;
            let resolveDocumentLink = (link2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol49.DocumentLinkResolveRequest.type, link2, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol49.DocumentLinkResolveRequest.type, token2, error, link2);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
          } : void 0
        };
        return [languages_default.registerDocumentLinkProvider(options.documentSelector, provider), provider];
      }
    };
    ConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
      }
      get registrationType() {
        return import_vscode_languageserver_protocol49.DidChangeConfigurationNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
      }
      initialize() {
        var _a2;
        let section2 = (_a2 = this._client.clientOptions.synchronize) == null ? void 0 : _a2.configurationSection;
        if (section2 !== void 0) {
          this.register({
            id: generateUuid(),
            registerOptions: {
              section: section2
            }
          });
        }
      }
      register(data) {
        let { section: section2 } = data.registerOptions;
        let disposable = workspace_default.onDidChangeConfiguration((event) => {
          if (typeof section2 == "string" && !event.affectsConfiguration(section2)) {
            return;
          }
          if (Array.isArray(section2) && !section2.some((v) => event.affectsConfiguration(v))) {
            return;
          }
          if (section2 != void 0) {
            this.onDidChangeConfiguration(data.registerOptions.section);
          }
        });
        this._listeners.set(data.id, disposable);
        if (string(section2) && section2.endsWith(".settings")) {
          let settings = this.getConfiguredSettings(section2);
          if (!settings || emptyObject(settings))
            return;
        }
        if (section2 != void 0) {
          this.onDidChangeConfiguration(data.registerOptions.section);
        }
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
          this._listeners.delete(id);
          disposable.dispose();
        }
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      onDidChangeConfiguration(configurationSection) {
        let isConfigured = typeof configurationSection === "string" && configurationSection.startsWith("languageserver.");
        let sections;
        if (string(configurationSection)) {
          sections = [configurationSection];
        } else {
          sections = configurationSection;
        }
        let didChangeConfiguration = (sections2) => {
          if (sections2 === void 0) {
            this._client.sendNotification(import_vscode_languageserver_protocol49.DidChangeConfigurationNotification.type, { settings: null });
            return;
          }
          this._client.sendNotification(import_vscode_languageserver_protocol49.DidChangeConfigurationNotification.type, {
            settings: isConfigured ? this.getConfiguredSettings(sections2[0]) : this.extractSettingsInformation(sections2)
          });
        };
        let middleware = this.getMiddleware();
        middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections);
      }
      getConfiguredSettings(key) {
        let len = ".settings".length;
        let config = workspace_default.getConfiguration(key.slice(0, -len));
        return config.get("settings", {});
      }
      extractSettingsInformation(keys) {
        function ensurePath(config, path36) {
          let current = config;
          for (let i = 0; i < path36.length - 1; i++) {
            let obj = current[path36[i]];
            if (!obj) {
              obj = Object.create(null);
              current[path36[i]] = obj;
            }
            current = obj;
          }
          return current;
        }
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          let index = key.indexOf(".");
          let config = null;
          if (index >= 0) {
            config = workspace_default.getConfiguration(key.substr(0, index)).get(key.substr(index + 1));
          } else {
            config = workspace_default.getConfiguration(key);
          }
          if (config) {
            let path36 = keys[i].split(".");
            ensurePath(result, path36)[path36[path36.length - 1]] = config;
          }
        }
        return result;
      }
      getMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
          return middleware.workspace.didChangeConfiguration;
        } else {
          return void 0;
        }
      }
    };
    ExecuteCommandFeature = class {
      constructor(_client) {
        this._client = _client;
        this._commands = new Map();
      }
      get registrationType() {
        return import_vscode_languageserver_protocol49.ExecuteCommandRequest.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
      }
      initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
      }
      register(data) {
        const client = this._client;
        const middleware = client.clientOptions.middleware;
        const executeCommand = (command, args) => {
          const params = {
            command,
            arguments: args
          };
          return client.sendRequest(import_vscode_languageserver_protocol49.ExecuteCommandRequest.type, params).then(void 0, (error) => {
            client.handleFailedRequest(import_vscode_languageserver_protocol49.ExecuteCommandRequest.type, void 0, error, void 0);
            throw error;
          });
        };
        if (data.registerOptions.commands) {
          let disposables = [];
          for (const command of data.registerOptions.commands) {
            disposables.push(commands_default.registerCommand(command, (...args) => {
              return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
            }, null, true));
          }
          this._commands.set(data.id, disposables);
        }
      }
      unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
          disposables.forEach((disposable) => disposable.dispose());
        }
      }
      dispose() {
        this._commands.forEach((value) => {
          value.forEach((disposable) => disposable.dispose());
        });
        this._commands.clear();
      }
    };
    (function(MessageTransports2) {
      function is(value) {
        let candidate = value;
        return candidate && import_vscode_languageserver_protocol49.MessageReader.is(value.reader) && import_vscode_languageserver_protocol49.MessageWriter.is(value.writer);
      }
      MessageTransports2.is = is;
    })(MessageTransports || (MessageTransports = {}));
    OnReady = class {
      constructor(_resolve, _reject) {
        this._resolve = _resolve;
        this._reject = _reject;
        this._used = false;
      }
      get isUsed() {
        return this._used;
      }
      resolve() {
        this._used = true;
        this._resolve();
      }
      reject(error) {
        this._used = true;
        this._reject(error);
      }
    };
    BaseLanguageClient = class {
      constructor(id, name2, clientOptions) {
        this._features = [];
        this._dynamicFeatures = new Map();
        var _a2;
        this._id = id;
        this._name = name2;
        if (clientOptions.outputChannel) {
          this._outputChannel = clientOptions.outputChannel;
        } else {
          this._outputChannel = void 0;
        }
        let disableSnippetCompletion = false;
        let suggest = workspace_default.getConfiguration("suggest");
        if (suggest.get("snippetsSupport", true) === false || clientOptions.disableSnippetCompletion) {
          disableSnippetCompletion = true;
        }
        const markdown = { isTrusted: false };
        if (clientOptions.markdown !== void 0 && clientOptions.markdown.isTrusted === true) {
          markdown.isTrusted = true;
        }
        this._clientOptions = {
          disableWorkspaceFolders: clientOptions.disableWorkspaceFolders,
          disableSnippetCompletion,
          disableDynamicRegister: clientOptions.disableDynamicRegister,
          disableDiagnostics: clientOptions.disableDiagnostics,
          disableCompletion: clientOptions.disableCompletion,
          formatterPriority: clientOptions.formatterPriority,
          ignoredRootPaths: clientOptions.ignoredRootPaths,
          documentSelector: clientOptions.documentSelector || [],
          synchronize: clientOptions.synchronize || {},
          diagnosticCollectionName: clientOptions.diagnosticCollectionName,
          outputChannelName: clientOptions.outputChannelName || this._id,
          revealOutputChannelOn: clientOptions.revealOutputChannelOn || 4,
          stdioEncoding: clientOptions.stdioEncoding || "utf8",
          initializationOptions: clientOptions.initializationOptions,
          initializationFailedHandler: clientOptions.initializationFailedHandler,
          progressOnInitialization: !!clientOptions.progressOnInitialization,
          errorHandler: clientOptions.errorHandler || this.createDefaultErrorHandler((_a2 = clientOptions.connectionOptions) == null ? void 0 : _a2.maxRestartCount),
          middleware: clientOptions.middleware || {},
          workspaceFolder: clientOptions.workspaceFolder,
          connectionOptions: clientOptions.connectionOptions,
          markdown
        };
        this.state = 0;
        this._connectionPromise = void 0;
        this._resolvedConnection = void 0;
        this._initializeResult = void 0;
        this._listeners = void 0;
        this._providers = void 0;
        this._diagnostics = void 0;
        this._fileEvents = [];
        this._fileEventDelayer = new Delayer(250);
        this._onReady = new Promise((resolve3, reject) => {
          this._onReadyCallbacks = new OnReady(resolve3, reject);
        });
        this._onStop = void 0;
        this._stateChangeEmitter = new import_vscode_languageserver_protocol49.Emitter();
        this._trace = import_vscode_languageserver_protocol49.Trace.Off;
        this._tracer = {
          log: (messageOrDataObject, data) => {
            if (string(messageOrDataObject)) {
              this.logTrace(messageOrDataObject, data);
            } else {
              this.logObjectTrace(messageOrDataObject);
            }
          }
        };
        this._syncedDocuments = new Map();
        let preferences = workspace_default.getConfiguration("coc.preferences");
        this._markdownSupport = preferences.get("enableMarkdown", true);
        this.registerBuiltinFeatures();
      }
      get supporedMarkupKind() {
        if (this._markdownSupport)
          return [import_vscode_languageserver_protocol49.MarkupKind.Markdown, import_vscode_languageserver_protocol49.MarkupKind.PlainText];
        return [import_vscode_languageserver_protocol49.MarkupKind.PlainText];
      }
      get state() {
        return this._state;
      }
      get id() {
        return this._id;
      }
      get name() {
        return this._name;
      }
      set state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
          this._stateChangeEmitter.fire({ oldState, newState });
        }
      }
      getPublicState() {
        if (this.state === 3) {
          return 2;
        } else if (this.state === 1) {
          return 3;
        } else {
          return 1;
        }
      }
      get initializeResult() {
        return this._initializeResult;
      }
      sendRequest(type, ...params) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          return this._resolvedConnection.sendRequest(type, ...params);
        } catch (error) {
          this.error(`Sending request ${string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onRequest(type, handler) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          return this._resolvedConnection.onRequest(type, handler);
        } catch (error) {
          this.error(`Registering request handler ${string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      sendNotification(type, params) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          this._resolvedConnection.sendNotification(type, params);
        } catch (error) {
          this.error(`Sending notification ${string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onNotification(type, handler) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          return this._resolvedConnection.onNotification(type, handler);
        } catch (error) {
          this.error(`Registering notification handler ${string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onProgress(type, token, handler) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          if (type == import_vscode_languageserver_protocol49.WorkDoneProgress.type) {
            const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
            if (handleWorkDoneProgress !== void 0) {
              return this._resolvedConnection.onProgress(type, token, (params) => {
                handleWorkDoneProgress(token, params, () => handler(params));
              });
            }
          }
          return this._resolvedConnection.onProgress(type, token, handler);
        } catch (error) {
          this.error(`Registering progress handler for token ${token} failed.`, error);
          throw error;
        }
      }
      sendProgress(type, token, value) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          this._resolvedConnection.sendProgress(type, token, value);
        } catch (error) {
          this.error(`Sending progress for token ${token} failed.`, error);
          throw error;
        }
      }
      get clientOptions() {
        return this._clientOptions;
      }
      get onDidChangeState() {
        return this._stateChangeEmitter.event;
      }
      get outputChannel() {
        if (!this._outputChannel) {
          let { outputChannelName } = this._clientOptions;
          this._outputChannel = window_default.createOutputChannel(outputChannelName ? outputChannelName : this._name);
        }
        return this._outputChannel;
      }
      get diagnostics() {
        return this._diagnostics;
      }
      createDefaultErrorHandler(maxRestartCount) {
        return new DefaultErrorHandler(this._id, maxRestartCount != null ? maxRestartCount : 4);
      }
      set trace(value) {
        this._trace = value;
        this.onReady().then(() => {
          this.resolveConnection().then((connection) => {
            connection.trace(this._trace, this._tracer, {
              sendNotification: false,
              traceFormat: this._traceFormat
            });
          });
        }, () => {
        });
      }
      logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
          this.outputChannel.append(`[LSP   - ${new Date().toLocaleTimeString()}] `);
        } else {
          this.outputChannel.append(`[Trace - ${new Date().toLocaleTimeString()}] `);
        }
        if (data) {
          this.outputChannel.appendLine(`${JSON.stringify(data)}`);
        }
      }
      data2String(data) {
        if (data instanceof import_vscode_languageserver_protocol49.ResponseError) {
          const responseError = data;
          return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
        }
        if (data instanceof Error) {
          if (string(data.stack)) {
            return data.stack;
          }
          return data.message;
        }
        if (string(data)) {
          return data;
        }
        return data.toString();
      }
      _appendOutput(type, message, data) {
        let level = 3;
        switch (type) {
          case "Info":
            level = 1;
            break;
          case "Warn":
            level = 2;
            break;
        }
        this.outputChannel.appendLine(`[${type}  - ${new Date().toLocaleTimeString()}] ${message}`);
        let dataString;
        if (data) {
          dataString = this.data2String(data);
          this.outputChannel.appendLine(dataString);
        }
        if (this._clientOptions.revealOutputChannelOn <= level) {
          this.outputChannel.show(true);
        }
      }
      info(message, data) {
        this._appendOutput("Info", message, data);
      }
      warn(message, data) {
        this._appendOutput("Warn", message, data);
      }
      error(message, data) {
        this._appendOutput("Error", message, data);
      }
      logTrace(message, data) {
        this.outputChannel.appendLine(`[Trace - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data) {
          this.outputChannel.appendLine(this.data2String(data));
        }
      }
      needsStart() {
        return this.state === 0 || this.state === 4 || this.state === 5;
      }
      needsStop() {
        return this.state === 1 || this.state === 3;
      }
      onReady() {
        return this._onReady;
      }
      get started() {
        return this.state != 0;
      }
      isConnectionActive() {
        return this.state === 3 && !!this._resolvedConnection;
      }
      start() {
        if (this._onReadyCallbacks.isUsed) {
          this._onReady = new Promise((resolve3, reject) => {
            this._onReadyCallbacks = new OnReady(resolve3, reject);
          });
        }
        this._listeners = [];
        this._providers = [];
        if (!this._diagnostics) {
          let opts = this._clientOptions;
          let name2 = opts.diagnosticCollectionName ? opts.diagnosticCollectionName : this._id;
          this._diagnostics = languages_default.createDiagnosticCollection(name2);
        }
        this.state = 1;
        this.resolveConnection().then((connection) => {
          connection.onLogMessage((message) => {
            let kind;
            switch (message.type) {
              case import_vscode_languageserver_protocol49.MessageType.Error:
                kind = "error";
                this.error(message.message);
                break;
              case import_vscode_languageserver_protocol49.MessageType.Warning:
                kind = "warning";
                this.warn(message.message);
                break;
              case import_vscode_languageserver_protocol49.MessageType.Info:
                kind = "info";
                this.info(message.message);
                break;
              default:
                kind = "log";
                this.outputChannel.appendLine(message.message);
            }
            if (global.hasOwnProperty("__TEST__")) {
              console.log(`[${kind}] ${message.message}`);
              return;
            }
          });
          connection.onShowMessage((message) => {
            switch (message.type) {
              case import_vscode_languageserver_protocol49.MessageType.Error:
                window_default.showErrorMessage(message.message);
                break;
              case import_vscode_languageserver_protocol49.MessageType.Warning:
                window_default.showWarningMessage(message.message);
                break;
              case import_vscode_languageserver_protocol49.MessageType.Info:
                window_default.showInformationMessage(message.message);
                break;
              default:
                window_default.showInformationMessage(message.message);
            }
          });
          connection.onRequest(import_vscode_languageserver_protocol49.ShowMessageRequest.type, (params) => {
            let messageFunc;
            switch (params.type) {
              case import_vscode_languageserver_protocol49.MessageType.Error:
                messageFunc = window_default.showErrorMessage.bind(window_default);
                break;
              case import_vscode_languageserver_protocol49.MessageType.Warning:
                messageFunc = window_default.showWarningMessage.bind(window_default);
                break;
              case import_vscode_languageserver_protocol49.MessageType.Info:
                messageFunc = window_default.showInformationMessage.bind(window_default);
                break;
              default:
                messageFunc = window_default.showInformationMessage.bind(window_default);
            }
            let actions = params.actions || [];
            return messageFunc(params.message, ...actions);
          });
          connection.onRequest(import_vscode_languageserver_protocol49.ShowDocumentRequest.type, async (params) => {
            var _a2;
            const showDocument = async (params2) => {
              var _a3;
              try {
                if (params2.external === true) {
                  await workspace_default.openResource(params2.uri);
                  return { success: true };
                } else {
                  if (params2.selection) {
                    params2.selection.start;
                  }
                  await workspace_default.jumpTo(params2.uri, (_a3 = params2.selection) == null ? void 0 : _a3.start);
                  return { success: true };
                }
              } catch (error) {
                return { success: true };
              }
            };
            const middleware = (_a2 = this._clientOptions.middleware.window) == null ? void 0 : _a2.showDocument;
            if (middleware !== void 0) {
              return middleware(params, showDocument);
            } else {
              return showDocument(params);
            }
          });
          connection.onTelemetry((_data) => {
          });
          connection.listen();
          return this.initialize(connection);
        }).then(void 0, (error) => {
          this.state = 2;
          this._onReadyCallbacks.reject(error);
          this.error("Starting client failed ", error);
        });
        return import_vscode_languageserver_protocol49.Disposable.create(() => {
          if (this.needsStop()) {
            this.stop();
          }
        });
      }
      resolveConnection() {
        if (!this._connectionPromise) {
          this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
      }
      resolveRootPath() {
        if (this._clientOptions.workspaceFolder) {
          return URI.parse(this._clientOptions.workspaceFolder.uri).fsPath;
        }
        let { ignoredRootPaths } = this._clientOptions;
        let config = workspace_default.getConfiguration(this.id);
        let rootPatterns = config.get("rootPatterns", []);
        let required = config.get("requireRootPattern", false);
        let resolved;
        if (rootPatterns && rootPatterns.length) {
          let doc = workspace_default.getDocument(workspace_default.bufnr);
          if (doc && doc.schema == "file") {
            let dir = import_path17.default.dirname(URI.parse(doc.uri).fsPath);
            resolved = resolveRoot(dir, rootPatterns, workspace_default.cwd);
          }
        }
        if (required && !resolved)
          return false;
        let rootPath = resolved || workspace_default.rootPath || workspace_default.cwd;
        if (rootPath === import_os7.default.homedir() || ignoredRootPaths && ignoredRootPaths.includes(rootPath)) {
          this.warn(`Ignored rootPath ${rootPath} of client "${this._id}"`);
          return null;
        }
        return rootPath;
      }
      initialize(connection) {
        this.refreshTrace(connection, false);
        let { initializationOptions, progressOnInitialization } = this._clientOptions;
        let rootPath = this.resolveRootPath();
        if (rootPath === false) {
          console.warn(`required root pattern not found, server not started.`);
          return;
        }
        let initParams = {
          processId: process.pid,
          rootPath: rootPath ? rootPath : null,
          rootUri: rootPath ? asUri(URI.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: func(initializationOptions) ? initializationOptions() : initializationOptions,
          trace: import_vscode_languageserver_protocol49.Trace.toString(this._trace),
          workspaceFolders: null,
          locale: this.getLocale(),
          clientInfo: {
            name: "coc.nvim",
            version: workspace_default.version
          }
        };
        this.fillInitializeParams(initParams);
        if (progressOnInitialization) {
          const token = generateUuid();
          initParams.workDoneToken = token;
          const part = new ProgressPart(connection, token);
          part.begin({ title: `initializing ${this.id}`, kind: "begin" });
          return this.doInitialize(connection, initParams).then((result) => {
            part.done();
            return result;
          }, (error) => {
            part.cancel();
            throw error;
          });
        } else {
          return this.doInitialize(connection, initParams);
        }
      }
      doInitialize(connection, initParams) {
        return connection.initialize(initParams).then((result) => {
          this._resolvedConnection = connection;
          this._initializeResult = result;
          this.state = 3;
          let textDocumentSyncOptions = void 0;
          if (number(result.capabilities.textDocumentSync)) {
            if (result.capabilities.textDocumentSync === import_vscode_languageserver_protocol49.TextDocumentSyncKind.None) {
              textDocumentSyncOptions = {
                openClose: false,
                change: import_vscode_languageserver_protocol49.TextDocumentSyncKind.None,
                save: void 0
              };
            } else {
              textDocumentSyncOptions = {
                openClose: true,
                change: result.capabilities.textDocumentSync,
                save: {
                  includeText: false
                }
              };
            }
          } else if (result.capabilities.textDocumentSync != null && result.capabilities.textDocumentSync !== void 0) {
            textDocumentSyncOptions = result.capabilities.textDocumentSync;
          }
          this._capabilities = Object.assign({}, result.capabilities, {
            resolvedTextDocumentSync: textDocumentSyncOptions
          });
          if (!this._clientOptions.disableDiagnostics) {
            connection.onDiagnostics((params) => this.handleDiagnostics(params));
          }
          connection.onRequest(import_vscode_languageserver_protocol49.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
          connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
          connection.onRequest(import_vscode_languageserver_protocol49.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
          connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
          connection.onRequest(import_vscode_languageserver_protocol49.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
          connection.sendNotification(import_vscode_languageserver_protocol49.InitializedNotification.type, {});
          this.hookFileEvents(connection);
          this.hookConfigurationChanged(connection);
          this.initializeFeatures(connection);
          this._onReadyCallbacks.resolve();
          return result;
        }).then(void 0, (error) => {
          if (this._clientOptions.initializationFailedHandler) {
            if (this._clientOptions.initializationFailedHandler(error)) {
              this.initialize(connection);
            } else {
              this.stop();
              this._onReadyCallbacks.reject(error);
            }
          } else if (error instanceof import_vscode_languageserver_protocol49.ResponseError && error.data && error.data.retry) {
            window_default.showPrompt(error.message + " Retry?").then((confirmed) => {
              if (confirmed) {
                this.initialize(connection);
              } else {
                this.stop();
                this._onReadyCallbacks.reject(error);
              }
            });
          } else {
            if (error && error.message) {
              window_default.showMessage(error.message, "error");
            }
            this.error("Server initialization failed.", error);
            this.stop();
            this._onReadyCallbacks.reject(error);
          }
          throw error;
        });
      }
      stop() {
        this._initializeResult = void 0;
        if (!this._connectionPromise) {
          this.state = 5;
          return Promise.resolve();
        }
        if (this.state === 4 && this._onStop) {
          return this._onStop;
        }
        this.state = 4;
        this.cleanUp();
        return this._onStop = this.resolveConnection().then((connection) => {
          return connection.shutdown().then(() => {
            connection.exit();
            connection.dispose();
            this.state = 5;
            this.cleanUpChannel();
            this._onStop = void 0;
            this._connectionPromise = void 0;
            this._resolvedConnection = void 0;
          });
        }).catch((e) => {
          logger47.error("Error on stop languageserver:", e);
          this.state = 5;
          this.cleanUpChannel();
          this._onStop = void 0;
          this._connectionPromise = void 0;
          this._resolvedConnection = void 0;
        });
      }
      cleanUp(channel = true, diagnostics = true) {
        if (this._listeners) {
          this._listeners.forEach((listener) => listener.dispose());
          this._listeners = void 0;
        }
        if (this._providers) {
          this._providers.forEach((provider) => provider.dispose());
          this._providers = void 0;
        }
        for (let feature of this._features.values()) {
          if (typeof feature.dispose === "function") {
            feature.dispose();
          } else {
            logger47.error(`Feature can't be disposed`, feature);
          }
        }
        if (this._syncedDocuments) {
          this._syncedDocuments.clear();
        }
        if (channel) {
          this.cleanUpChannel();
        }
        if (this._diagnostics) {
          if (diagnostics) {
            this._diagnostics.dispose();
            this._diagnostics = void 0;
          } else {
            this._diagnostics.clear();
          }
        }
      }
      cleanUpChannel() {
        if (this._outputChannel) {
          this._outputChannel.dispose();
          this._outputChannel = void 0;
        }
      }
      notifyFileEvent(event) {
        var _a2;
        const client = this;
        function didChangeWatchedFile(event2) {
          client._fileEvents.push(event2);
          client._fileEventDelayer.trigger(() => {
            client.onReady().then(() => {
              client.resolveConnection().then((connection) => {
                if (client.isConnectionActive()) {
                  connection.didChangeWatchedFiles({ changes: client._fileEvents });
                }
                client._fileEvents = [];
              });
            }, (error) => {
              client.error(`Notify file events failed.`, error);
            });
          });
        }
        const workSpaceMiddleware = (_a2 = this.clientOptions.middleware) == null ? void 0 : _a2.workspace;
        (workSpaceMiddleware == null ? void 0 : workSpaceMiddleware.didChangeWatchedFile) ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event);
      }
      handleDiagnostics(params) {
        if (!this._diagnostics) {
          return;
        }
        let { uri, diagnostics } = params;
        let middleware = this.clientOptions.middleware.handleDiagnostics;
        if (middleware) {
          middleware(uri, diagnostics, (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2));
        } else {
          this.setDiagnostics(uri, diagnostics);
        }
      }
      setDiagnostics(uri, diagnostics) {
        var _a2;
        if (!this._diagnostics) {
          return;
        }
        const separate = workspace_default.getConfiguration("diagnostic").get("separateRelatedInformationAsDiagnostics");
        if (separate && diagnostics.length > 0) {
          const entries = new Map();
          entries.set(uri, diagnostics);
          for (const diagnostic of diagnostics) {
            if ((_a2 = diagnostic.relatedInformation) == null ? void 0 : _a2.length) {
              let message = `${diagnostic.message}

Related diagnostics:
`;
              for (const info of diagnostic.relatedInformation) {
                const basename = import_path17.default.basename(URI.parse(info.location.uri).fsPath);
                const ln = info.location.range.start.line;
                message = `${message}
${basename}(line ${ln + 1}): ${info.message}`;
                const diags = entries.get(info.location.uri) || [];
                diags.push(import_vscode_languageserver_protocol49.Diagnostic.create(info.location.range, info.message, import_vscode_languageserver_protocol49.DiagnosticSeverity.Hint, diagnostic.code, diagnostic.source));
                entries.set(info.location.uri, diags);
              }
              diagnostic.message = message;
            }
            this._diagnostics.set(Array.from(entries));
          }
        } else {
          this._diagnostics.set(uri, diagnostics);
        }
      }
      createConnection() {
        let errorHandler = (error, message, count) => {
          logger47.error("connection error:", error, message);
          this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
          this.handleConnectionClosed();
        };
        return this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8").then((transports) => {
          return createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        });
      }
      handleConnectionClosed() {
        if (this.state === 5) {
          return;
        }
        try {
          if (this._resolvedConnection) {
            this._resolvedConnection.dispose();
          }
        } catch (error) {
        }
        let action = 1;
        if (this.state !== 4) {
          try {
            action = this._clientOptions.errorHandler.closed();
          } catch (error) {
          }
        }
        this._connectionPromise = void 0;
        this._resolvedConnection = void 0;
        if (action === 1) {
          this.error("Connection to server got closed. Server will not be restarted.");
          if (this.state === 1) {
            this._onReadyCallbacks.reject(new Error(`Connection to server got closed. Server will not be restarted.`));
            this.state = 2;
          } else {
            this.state = 5;
          }
          this.cleanUp(false, true);
        } else if (action === 2) {
          this.info("Connection to server got closed. Server will restart.");
          this.cleanUp(false, true);
          this.state = 0;
          this.start();
        }
      }
      restart() {
        this.cleanUp(true, false);
        this.start();
      }
      handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === 2) {
          this.error("Connection to server is erroring. Shutting down server.");
          this.stop();
        }
      }
      hookConfigurationChanged(connection) {
        workspace_default.onDidChangeConfiguration(() => {
          this.refreshTrace(connection, true);
        });
      }
      refreshTrace(connection, sendNotification = false) {
        let config = workspace_default.getConfiguration(this._id);
        let trace = import_vscode_languageserver_protocol49.Trace.Off;
        let traceFormat = import_vscode_languageserver_protocol49.TraceFormat.Text;
        if (config) {
          const traceConfig = config.get("trace.server", "off");
          if (typeof traceConfig === "string") {
            trace = import_vscode_languageserver_protocol49.Trace.fromString(traceConfig);
          } else {
            trace = import_vscode_languageserver_protocol49.Trace.fromString(config.get("trace.server.verbosity", "off"));
            traceFormat = import_vscode_languageserver_protocol49.TraceFormat.fromString(config.get("trace.server.format", "text"));
          }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
          sendNotification,
          traceFormat: this._traceFormat
        });
      }
      hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents)
          return;
        let watchers;
        if (Array.isArray(fileEvents)) {
          watchers = fileEvents;
        } else {
          watchers = [fileEvents];
        }
        if (!watchers) {
          return;
        }
        this._dynamicFeatures.get(import_vscode_languageserver_protocol49.DidChangeWatchedFilesNotification.type.method).registerRaw(generateUuid(), watchers);
      }
      registerFeatures(features) {
        for (let feature of features) {
          this.registerFeature(feature);
        }
      }
      registerFeature(feature) {
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
          const registrationType = feature.registrationType;
          this._dynamicFeatures.set(registrationType.method, feature);
        }
      }
      getFeature(request2) {
        return this._dynamicFeatures.get(request2);
      }
      registerBuiltinFeatures() {
        this.registerFeature(new ConfigurationFeature(this));
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new DidChangeTextDocumentFeature(this));
        this.registerFeature(new WillSaveFeature(this));
        this.registerFeature(new WillSaveWaitUntilFeature(this));
        this.registerFeature(new DidSaveTextDocumentFeature(this));
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        if (!this._clientOptions.disableCompletion) {
          this.registerFeature(new CompletionItemFeature(this));
        }
        this.registerFeature(new HoverFeature(this));
        this.registerFeature(new SignatureHelpFeature(this));
        this.registerFeature(new DefinitionFeature(this));
        this.registerFeature(new ReferencesFeature(this));
        this.registerFeature(new DocumentHighlightFeature(this));
        this.registerFeature(new DocumentSymbolFeature(this));
        this.registerFeature(new WorkspaceSymbolFeature(this));
        this.registerFeature(new CodeActionFeature(this));
        this.registerFeature(new CodeLensFeature(this));
        this.registerFeature(new DocumentFormattingFeature(this));
        this.registerFeature(new DocumentRangeFormattingFeature(this));
        this.registerFeature(new DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new RenameFeature(this));
        this.registerFeature(new DocumentLinkFeature(this));
        this.registerFeature(new ExecuteCommandFeature(this));
      }
      fillInitializeParams(params) {
        for (let feature of this._features) {
          if (func(feature.fillInitializeParams)) {
            feature.fillInitializeParams(params);
          }
        }
      }
      computeClientCapabilities() {
        const result = {};
        ensure(result, "workspace").applyEdit = true;
        const workspaceEdit = ensure(ensure(result, "workspace"), "workspaceEdit");
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [import_vscode_languageserver_protocol49.ResourceOperationKind.Create, import_vscode_languageserver_protocol49.ResourceOperationKind.Rename, import_vscode_languageserver_protocol49.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = import_vscode_languageserver_protocol49.FailureHandlingKind.TextOnlyTransactional;
        const diagnostics = ensure(ensure(result, "textDocument"), "publishDiagnostics");
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [import_vscode_languageserver_protocol49.DiagnosticTag.Unnecessary, import_vscode_languageserver_protocol49.DiagnosticTag.Deprecated] };
        const windowCapabilities = ensure(result, "window");
        const showMessage = ensure(windowCapabilities, "showMessage");
        showMessage.messageActionItem = { additionalPropertiesSupport: false };
        const showDocument = ensure(windowCapabilities, "showDocument");
        showDocument.support = false;
        const generalCapabilities = ensure(result, "general");
        generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
        generalCapabilities.markdown = { parser: "marked", version: "1.1.0" };
        for (let feature of this._features) {
          feature.fillClientCapabilities(result);
        }
        return result;
      }
      initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
          feature.initialize(this._capabilities, documentSelector);
        }
      }
      handleRegistrationRequest(params) {
        if (this.clientOptions.disableDynamicRegister)
          return Promise.resolve();
        return new Promise((resolve3, reject) => {
          for (const registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (!feature) {
              reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
              return;
            }
            const options = registration.registerOptions || {};
            options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;
            const data = {
              id: registration.id,
              registerOptions: options
            };
            try {
              feature.register(data);
            } catch (err) {
              reject(err);
              return;
            }
          }
          resolve3();
        });
      }
      handleUnregistrationRequest(params) {
        return new Promise((resolve3, reject) => {
          for (let unregistration of params.unregisterations) {
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (!feature) {
              reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
              return;
            }
            feature.unregister(unregistration.id);
          }
          resolve3();
        });
      }
      handleApplyWorkspaceEdit(params) {
        let workspaceEdit = params.edit;
        let openTextDocuments = new Map();
        workspace_default.textDocuments.forEach((document2) => openTextDocuments.set(document2.uri.toString(), document2));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
          for (const change of workspaceEdit.documentChanges) {
            if (import_vscode_languageserver_protocol49.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
              let textDocument = openTextDocuments.get(change.textDocument.uri);
              if (textDocument && textDocument.version !== change.textDocument.version) {
                versionMismatch = true;
                break;
              }
            }
          }
        }
        if (versionMismatch) {
          return Promise.resolve({ applied: false });
        }
        return workspace_default.applyEdit(params.edit).then((value) => {
          return { applied: value };
        });
      }
      getLocale() {
        const lang = process.env.LANG;
        if (!lang)
          return "en";
        return lang.split(".")[0];
      }
      handleFailedRequest(type, token, error, defaultValue) {
        if (error instanceof import_vscode_languageserver_protocol49.ResponseError) {
          if (error.code === import_vscode_languageserver_protocol49.LSPErrorCodes.RequestCancelled) {
            if (token !== void 0 && token.isCancellationRequested) {
              return defaultValue;
            }
          } else if (error.code === import_vscode_languageserver_protocol49.LSPErrorCodes.ContentModified) {
            return defaultValue;
          }
        }
        this.error(`Request ${type.method} failed.`, error);
      }
      logFailedRequest(type, error) {
        if (error instanceof import_vscode_languageserver_protocol49.ResponseError && error.code === import_vscode_languageserver_protocol49.LSPErrorCodes.RequestCancelled) {
          return;
        }
        this.error(`Request ${type.method} failed.`, error);
      }
    };
  }
});

// src/language-client/colorProvider.ts
function ensure2(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol50, ColorProviderFeature;
var init_colorProvider = __esm({
  "src/language-client/colorProvider.ts"() {
    import_vscode_languageserver_protocol50 = __toModule(require_main2());
    init_languages();
    init_client();
    "use strict";
    ColorProviderFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol50.DocumentColorRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure2(ensure2(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideColorPresentations: (color, context, token) => {
            const client = this._client;
            const provideColorPresentations = (color2, context2, token2) => {
              const requestParams = {
                color: color2,
                textDocument: { uri: context2.document.uri },
                range: context2.range
              };
              return client.sendRequest(import_vscode_languageserver_protocol50.ColorPresentationRequest.type, requestParams, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol50.ColorPresentationRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
          },
          provideDocumentColors: (document2, token) => {
            const client = this._client;
            const provideDocumentColors = (document3, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri }
              };
              return client.sendRequest(import_vscode_languageserver_protocol50.DocumentColorRequest.type, requestParams, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol50.ColorPresentationRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentColors ? middleware.provideDocumentColors(document2, token, provideDocumentColors) : provideDocumentColors(document2, token);
          }
        };
        return [languages_default.registerDocumentColorProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/configuration.ts
function toJSONObject(obj) {
  if (obj) {
    if (Array.isArray(obj)) {
      return obj.map(toJSONObject);
    } else if (typeof obj === "object") {
      const res = Object.create(null);
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          res[key] = toJSONObject(obj[key]);
        }
      }
      return res;
    }
  }
  return obj;
}
var import_vscode_languageserver_protocol51, logger48, ConfigurationFeature2;
var init_configuration3 = __esm({
  "src/language-client/configuration.ts"() {
    import_vscode_languageserver_protocol51 = __toModule(require_main2());
    init_workspace();
    logger48 = require_logger2()("languageclient-configuration");
    ConfigurationFeature2 = class {
      constructor(_client) {
        this._client = _client;
        var _a2;
        let section2 = (_a2 = this._client.clientOptions.synchronize) == null ? void 0 : _a2.configurationSection;
        if (typeof section2 === "string" && section2.startsWith("languageserver.")) {
          this.languageserverSection = section2;
        }
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
      }
      initialize() {
        let client = this._client;
        client.onRequest(import_vscode_languageserver_protocol51.ConfigurationRequest.type, (params, token) => {
          let configuration = (params2) => {
            let result = [];
            for (let item of params2.items) {
              result.push(this.getConfiguration(item.scopeUri, item.section));
            }
            return result;
          };
          let middleware = client.clientOptions.middleware.workspace;
          return middleware && middleware.configuration ? middleware.configuration(params, token, configuration) : configuration(params, token);
        });
      }
      getConfiguration(resource, section2) {
        let result = null;
        if (section2) {
          if (this.languageserverSection) {
            section2 = `${this.languageserverSection}.${section2}`;
          }
          let index = section2.lastIndexOf(".");
          if (index === -1) {
            result = toJSONObject(workspace_default.getConfiguration(void 0, resource).get(section2));
          } else {
            let config = workspace_default.getConfiguration(section2.substr(0, index), resource);
            if (config) {
              result = toJSONObject(config.get(section2.substr(index + 1)));
            }
          }
        } else {
          let config = workspace_default.getConfiguration(this.languageserverSection, resource);
          result = {};
          for (let key of Object.keys(config)) {
            if (config.has(key)) {
              result[key] = toJSONObject(config.get(key));
            }
          }
        }
        return result;
      }
      dispose() {
      }
    };
  }
});

// src/language-client/declaration.ts
function ensure3(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol52, DeclarationFeature;
var init_declaration = __esm({
  "src/language-client/declaration.ts"() {
    import_vscode_languageserver_protocol52 = __toModule(require_main2());
    init_languages();
    init_client();
    init_converter();
    "use strict";
    DeclarationFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol52.DeclarationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let declarationSupport = ensure3(ensure3(capabilities, "textDocument"), "declaration");
        declarationSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDeclaration: (document2, position, token) => {
            const client = this._client;
            const provideDeclaration = (document3, position2, token2) => client.sendRequest(import_vscode_languageserver_protocol52.DeclarationRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
              return client.handleFailedRequest(import_vscode_languageserver_protocol52.DeclarationRequest.type, token2, error, null);
            });
            const middleware = client.clientOptions.middleware;
            return middleware.provideDeclaration ? middleware.provideDeclaration(document2, position, token, provideDeclaration) : provideDeclaration(document2, position, token);
          }
        };
        return [languages_default.registerDeclarationProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/foldingRange.ts
function ensure4(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol53, FoldingRangeFeature;
var init_foldingRange = __esm({
  "src/language-client/foldingRange.ts"() {
    import_vscode_languageserver_protocol53 = __toModule(require_main2());
    init_languages();
    init_client();
    "use strict";
    FoldingRangeFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol53.FoldingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure4(ensure4(capabilities, "textDocument"), "foldingRange");
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5e3;
        capability.lineFoldingOnly = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideFoldingRanges: (document2, context, token) => {
            const client = this._client;
            const provideFoldingRanges = (document3, _, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri }
              };
              return client.sendRequest(import_vscode_languageserver_protocol53.FoldingRangeRequest.type, requestParams, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol53.FoldingRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document2, context, token, provideFoldingRanges) : provideFoldingRanges(document2, context, token);
          }
        };
        return [languages_default.registerFoldingRangeProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/implementation.ts
function ensure5(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol54, ImplementationFeature;
var init_implementation = __esm({
  "src/language-client/implementation.ts"() {
    import_vscode_languageserver_protocol54 = __toModule(require_main2());
    init_languages();
    init_client();
    init_converter();
    ImplementationFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol54.ImplementationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const implementationSupport = ensure5(ensure5(capabilities, "textDocument"), "implementation");
        implementationSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideImplementation: (document2, position, token) => {
            const client = this._client;
            const provideImplementation = (document3, position2, token2) => client.sendRequest(import_vscode_languageserver_protocol54.ImplementationRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
              return client.handleFailedRequest(import_vscode_languageserver_protocol54.ImplementationRequest.type, token2, error, null);
            });
            const middleware = client.clientOptions.middleware;
            return middleware.provideImplementation ? middleware.provideImplementation(document2, position, token, provideImplementation) : provideImplementation(document2, position, token);
          }
        };
        return [languages_default.registerImplementationProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/progress.ts
function ensure6(target, key) {
  if (target[key] === void 0) {
    target[key] = Object.create(null);
  }
  return target[key];
}
var import_vscode_languageserver_protocol55, ProgressFeature;
var init_progress2 = __esm({
  "src/language-client/progress.ts"() {
    import_vscode_languageserver_protocol55 = __toModule(require_main2());
    init_progressPart();
    "use strict";
    ProgressFeature = class {
      constructor(_client) {
        this._client = _client;
        this.activeParts = new Set();
      }
      fillClientCapabilities(capabilities) {
        ensure6(capabilities, "window").workDoneProgress = true;
      }
      initialize() {
        let client = this._client;
        const deleteHandler = (part) => {
          this.activeParts.delete(part);
        };
        const createHandler = (params) => {
          this.activeParts.add(new ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(import_vscode_languageserver_protocol55.WorkDoneProgressCreateRequest.type, createHandler);
      }
      dispose() {
        for (const part of this.activeParts) {
          part.done();
        }
        this.activeParts.clear();
      }
    };
  }
});

// src/language-client/typeDefinition.ts
function ensure7(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol56, TypeDefinitionFeature;
var init_typeDefinition = __esm({
  "src/language-client/typeDefinition.ts"() {
    import_vscode_languageserver_protocol56 = __toModule(require_main2());
    init_languages();
    init_client();
    init_converter();
    TypeDefinitionFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol56.TypeDefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const typeDefinitionSupport = ensure7(ensure7(capabilities, "textDocument"), "typeDefinition");
        typeDefinitionSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideTypeDefinition: (document2, position, token) => {
            const client = this._client;
            const provideTypeDefinition = (document3, position2, token2) => client.sendRequest(import_vscode_languageserver_protocol56.TypeDefinitionRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
              return client.handleFailedRequest(import_vscode_languageserver_protocol56.TypeDefinitionRequest.type, token2, error, null);
            });
            const middleware = client.clientOptions.middleware;
            return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document2, position, token, provideTypeDefinition) : provideTypeDefinition(document2, position, token);
          }
        };
        return [languages_default.registerTypeDefinitionProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/workspaceFolders.ts
function access(target, key) {
  if (target === void 0) {
    return void 0;
  }
  return target[key];
}
function arrayDiff(left, right) {
  return left.filter((element) => !right.includes(element));
}
var import_vscode_languageserver_protocol57, import_os8, logger49, WorkspaceFoldersFeature;
var init_workspaceFolders = __esm({
  "src/language-client/workspaceFolders.ts"() {
    import_vscode_languageserver_protocol57 = __toModule(require_main2());
    init_workspace();
    import_os8 = __toModule(require("os"));
    init_uuid();
    init_esm2();
    "use strict";
    logger49 = require_logger2()("language-client-workspaceFolder");
    WorkspaceFoldersFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
      }
      get registrationType() {
        return import_vscode_languageserver_protocol57.DidChangeWorkspaceFoldersNotification.type;
      }
      getValidWorkspaceFolders() {
        let { workspaceFolders } = workspace_default;
        if (!workspaceFolders || workspaceFolders.length == 0)
          return void 0;
        let home = import_os8.default.homedir();
        let { ignoredRootPaths } = this._client.clientOptions;
        if (!Array.isArray(ignoredRootPaths)) {
          ignoredRootPaths = [];
        }
        let arr = workspaceFolders.filter((o) => {
          let fsPath = URI.parse(o.uri).fsPath;
          return fsPath != home && !ignoredRootPaths.includes(fsPath);
        });
        return arr.length ? arr : void 0;
      }
      asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
          return null;
        }
        return { uri: workspaceFolder.uri, name: workspaceFolder.name };
      }
      fillInitializeParams(params) {
        const folders = this.getValidWorkspaceFolders();
        this._initialFolders = folders;
        if (folders == null) {
          params.workspaceFolders = null;
        } else {
          params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
        }
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
      }
      initialize(capabilities) {
        let client = this._client;
        client.onRequest(import_vscode_languageserver_protocol57.WorkspaceFoldersRequest.type, (token) => {
          let workspaceFolders = () => {
            let folders = this.getValidWorkspaceFolders();
            if (folders === void 0) {
              return null;
            }
            let result = folders.map((folder) => this.asProtocol(folder));
            return result;
          };
          const middleware = client.clientOptions.middleware.workspace;
          return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
        let id;
        if (typeof value === "string") {
          id = value;
        } else if (value === true) {
          id = generateUuid();
        }
        if (id) {
          this.register({
            id,
            registerOptions: void 0
          });
        }
      }
      doSendEvent(addedFolders, removedFolders) {
        let params = {
          event: {
            added: addedFolders.map((folder) => this.asProtocol(folder)),
            removed: removedFolders.map((folder) => this.asProtocol(folder))
          }
        };
        this._client.sendNotification(import_vscode_languageserver_protocol57.DidChangeWorkspaceFoldersNotification.type, params);
      }
      sendInitialEvent(currentWorkspaceFolders) {
        if (this._initialFolders && currentWorkspaceFolders) {
          const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
          const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
          if (added.length > 0 || removed.length > 0) {
            this.doSendEvent(added, removed);
          }
        } else if (this._initialFolders) {
          this.doSendEvent([], this._initialFolders);
        } else if (currentWorkspaceFolders) {
          this.doSendEvent(currentWorkspaceFolders, []);
        }
      }
      register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = workspace_default.onDidChangeWorkspaceFolders((event) => {
          let didChangeWorkspaceFolders = (event2) => {
            this.doSendEvent(event2.added, event2.removed);
          };
          let middleware = client.clientOptions.middleware.workspace;
          middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
        });
        this._listeners.set(id, disposable);
        let workspaceFolders = this.getValidWorkspaceFolders();
        this.sendInitialEvent(workspaceFolders);
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
          return;
        }
        this._listeners.delete(id);
        disposable.dispose();
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
    };
  }
});

// src/language-client/selectionRange.ts
function ensure8(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol58, SelectionRangeFeature;
var init_selectionRange = __esm({
  "src/language-client/selectionRange.ts"() {
    import_vscode_languageserver_protocol58 = __toModule(require_main2());
    init_languages();
    init_client();
    "use strict";
    SelectionRangeFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol58.SelectionRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure8(ensure8(capabilities, "textDocument"), "selectionRange");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideSelectionRanges: (document2, positions2, token) => {
            const client = this._client;
            const provideSelectionRanges = (document3, positions3, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri },
                positions: positions3
              };
              return client.sendRequest(import_vscode_languageserver_protocol58.SelectionRangeRequest.type, requestParams, token2).then((ranges) => ranges, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol58.SelectionRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document2, positions2, token, provideSelectionRanges) : provideSelectionRanges(document2, positions2, token);
          }
        };
        return [languages_default.registerSelectionRangeProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/callHierarchy.ts
function ensure9(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol59, CallHierarchyFeature;
var init_callHierarchy = __esm({
  "src/language-client/callHierarchy.ts"() {
    import_vscode_languageserver_protocol59 = __toModule(require_main2());
    init_languages();
    init_client();
    init_converter();
    "use strict";
    CallHierarchyFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol59.CallHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = ensure9(ensure9(capabilities, "textDocument"), "callHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          prepareCallHierarchy: (document2, position, token) => {
            const client = this._client;
            const prepareCallHierarchy = (document3, position2, token2) => {
              const params = asTextDocumentPositionParams(document3, position2);
              return client.sendRequest(import_vscode_languageserver_protocol59.CallHierarchyPrepareRequest.type, params, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol59.CallHierarchyPrepareRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document2, position, token, prepareCallHierarchy) : prepareCallHierarchy(document2, position, token);
          },
          provideCallHierarchyIncomingCalls: (item, token) => {
            const client = this._client;
            const provideCallHierarchyIncomingCalls = (item2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol59.CallHierarchyIncomingCallsRequest.type, { item: item2 }, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol59.CallHierarchyIncomingCallsRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
          },
          provideCallHierarchyOutgoingCalls: (item, token) => {
            const client = this._client;
            const provideCallHierarchyOutgoingCalls = (item2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol59.CallHierarchyOutgoingCallsRequest.type, { item: item2 }, token2).then((res) => res, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol59.CallHierarchyOutgoingCallsRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
          }
        };
        return [languages_default.registerCallHierarchyProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/semanticTokens.ts
function ensure10(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol60, logger50, SemanticTokensFeature;
var init_semanticTokens = __esm({
  "src/language-client/semanticTokens.ts"() {
    import_vscode_languageserver_protocol60 = __toModule(require_main2());
    init_languages();
    init_converter();
    init_is();
    init_client();
    "use strict";
    logger50 = require_logger2()("languageclient-semanticTokens");
    SemanticTokensFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol60.SemanticTokensRegistrationType.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = ensure10(ensure10(capabilities, "textDocument"), "semanticTokens");
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
          import_vscode_languageserver_protocol60.SemanticTokenTypes.namespace,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.type,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.class,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.enum,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.interface,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.struct,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.typeParameter,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.parameter,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.variable,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.property,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.enumMember,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.event,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.function,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.method,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.macro,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.keyword,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.modifier,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.comment,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.string,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.number,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.regexp,
          import_vscode_languageserver_protocol60.SemanticTokenTypes.operator
        ];
        capability.tokenModifiers = [
          import_vscode_languageserver_protocol60.SemanticTokenModifiers.declaration,
          import_vscode_languageserver_protocol60.SemanticTokenModifiers.definition,
          import_vscode_languageserver_protocol60.SemanticTokenModifiers.readonly,
          import_vscode_languageserver_protocol60.SemanticTokenModifiers.static,
          import_vscode_languageserver_protocol60.SemanticTokenModifiers.deprecated,
          import_vscode_languageserver_protocol60.SemanticTokenModifiers.abstract,
          import_vscode_languageserver_protocol60.SemanticTokenModifiers.async,
          import_vscode_languageserver_protocol60.SemanticTokenModifiers.modification,
          import_vscode_languageserver_protocol60.SemanticTokenModifiers.documentation,
          import_vscode_languageserver_protocol60.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [import_vscode_languageserver_protocol60.TokenFormat.Relative];
        capability.requests = {
          range: true,
          full: {
            delta: true
          }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        ensure10(ensure10(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(import_vscode_languageserver_protocol60.SemanticTokensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeSemanticTokensEmitter.fire();
          }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const fullProvider = boolean(options.full) ? options.full : options.full !== void 0;
        const hasEditProvider = options.full !== void 0 && typeof options.full !== "boolean" && options.full.delta === true;
        const eventEmitter = new import_vscode_languageserver_protocol60.Emitter();
        const documentProvider = fullProvider ? {
          onDidChangeSemanticTokens: eventEmitter.event,
          provideDocumentSemanticTokens: (document2, token) => {
            const client = this._client;
            const middleware = client.clientOptions.middleware;
            const provideDocumentSemanticTokens = (document3, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3)
              };
              return client.sendRequest(import_vscode_languageserver_protocol60.SemanticTokensRequest.type, params, token2).then((result) => result, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol60.SemanticTokensRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document2, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document2, token);
          },
          provideDocumentSemanticTokensEdits: hasEditProvider ? (document2, previousResultId, token) => {
            const client = this._client;
            const middleware = client.clientOptions.middleware;
            const provideDocumentSemanticTokensEdits = (document3, previousResultId2, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3),
                previousResultId: previousResultId2
              };
              return client.sendRequest(import_vscode_languageserver_protocol60.SemanticTokensDeltaRequest.type, params, token2).then((result) => result, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol60.SemanticTokensDeltaRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document2, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document2, previousResultId, token);
          } : void 0
        } : void 0;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider ? {
          provideDocumentRangeSemanticTokens: (document2, range, token) => {
            const client = this._client;
            const middleware = client.clientOptions.middleware;
            const provideDocumentRangeSemanticTokens = (document3, range2, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3),
                range: range2
              };
              return client.sendRequest(import_vscode_languageserver_protocol60.SemanticTokensRangeRequest.type, params, token2).then((result) => result, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol60.SemanticTokensRangeRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document2, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document2, range, token);
          }
        } : void 0;
        const disposables = [];
        if (documentProvider !== void 0) {
          disposables.push(languages_default.registerDocumentSemanticTokensProvider(options.documentSelector, documentProvider, options.legend));
        }
        if (rangeProvider !== void 0) {
          disposables.push(languages_default.registerDocumentRangeSemanticTokensProvider(options.documentSelector, rangeProvider, options.legend));
        }
        return [import_vscode_languageserver_protocol60.Disposable.create(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
      }
    };
  }
});

// src/language-client/linkedEditingRange.ts
function ensure11(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol61, logger51, LinkedEditingFeature;
var init_linkedEditingRange = __esm({
  "src/language-client/linkedEditingRange.ts"() {
    import_vscode_languageserver_protocol61 = __toModule(require_main2());
    init_languages();
    init_client();
    init_converter();
    logger51 = require_logger2()("languageclient-linkedEditingRange");
    LinkedEditingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol61.LinkedEditingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const linkedEditingSupport = ensure11(ensure11(capabilities, "textDocument"), "linkedEditingRange");
        linkedEditingSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideLinkedEditingRanges: (document2, position, token) => {
            const client = this._client;
            const provideLinkedEditing = (document3, position2, token2) => {
              const params = asTextDocumentPositionParams(document3, position2);
              return client.sendRequest(import_vscode_languageserver_protocol61.LinkedEditingRangeRequest.type, params, token2).then((result) => result, (error) => {
                return client.handleFailedRequest(import_vscode_languageserver_protocol61.LinkedEditingRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideLinkedEditingRange ? middleware.provideLinkedEditingRange(document2, position, token, provideLinkedEditing) : provideLinkedEditing(document2, position, token);
          }
        };
        return [languages_default.registerLinkedEditingRangeProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/fileOperations.ts
function ensure12(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
function access2(target, key) {
  return target[key];
}
function assign(target, key, value) {
  target[key] = value;
}
function asCreateDeleteFilesParams(e) {
  return {
    files: e.files.map((f) => ({ uri: f.toString() }))
  };
}
function asRenameFilesParams(e) {
  return {
    files: e.files.map((f) => ({ oldUri: f.oldUri.toString(), newUri: f.newUri.toString() }))
  };
}
var minimatch5, import_vscode_languageserver_protocol62, logger52, FileOperationFeature, NotificationFileOperationFeature, DidCreateFilesFeature, DidRenameFilesFeature, DidDeleteFilesFeature, RequestFileOperationFeature, WillCreateFilesFeature, WillRenameFilesFeature, WillDeleteFilesFeature;
var init_fileOperations = __esm({
  "src/language-client/fileOperations.ts"() {
    minimatch5 = __toModule(require_minimatch());
    import_vscode_languageserver_protocol62 = __toModule(require_main2());
    init_types();
    init_fs();
    init_workspace();
    init_uuid();
    logger52 = require_logger2()("language-client-fileOperations");
    FileOperationFeature = class {
      constructor(client, event, registrationType, clientCapability, serverCapability) {
        this._filters = new Map();
        this._client = client;
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
      }
      get registrationType() {
        return this._registrationType;
      }
      fillClientCapabilities(capabilities) {
        const value = ensure12(ensure12(capabilities, "workspace"), "fileOperations");
        assign(value, "dynamicRegistration", true);
        assign(value, this._clientCapability, true);
      }
      initialize(capabilities) {
        var _a2;
        const options = (_a2 = capabilities.workspace) == null ? void 0 : _a2.fileOperations;
        const capability = options !== void 0 ? access2(options, this._serverCapability) : void 0;
        if ((capability == null ? void 0 : capability.filters) !== void 0) {
          try {
            this.register({
              id: generateUuid(),
              registerOptions: { filters: capability.filters }
            });
          } catch (e) {
            this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
          }
        }
      }
      register(data) {
        if (!this._listener) {
          this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter) => {
          const matcher = new minimatch5.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
          if (!matcher.makeRe()) {
            throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
          }
          return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
      }
      unregister(id) {
        this._filters.delete(id);
        if (this._filters.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._filters.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      async filter(event, prop) {
        const fileMatches = await Promise.all(event.files.map(async (item) => {
          const uri = prop(item);
          const path36 = uri.fsPath.replace(/\\/g, "/");
          for (const filters of this._filters.values()) {
            for (const filter of filters) {
              if (filter.scheme !== void 0 && filter.scheme !== uri.scheme) {
                continue;
              }
              if (filter.matcher.match(path36)) {
                if (filter.kind === void 0) {
                  return true;
                }
                const fileType = await FileOperationFeature.getFileType(uri);
                if (fileType === void 0) {
                  this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                  return true;
                }
                if (fileType === FileType.File && filter.kind === import_vscode_languageserver_protocol62.FileOperationPatternKind.file || fileType === FileType.Directory && filter.kind === import_vscode_languageserver_protocol62.FileOperationPatternKind.folder) {
                  return true;
                }
              } else if (filter.kind === import_vscode_languageserver_protocol62.FileOperationPatternKind.folder) {
                const fileType = await FileOperationFeature.getFileType(uri);
                if (fileType === FileType.Directory && filter.matcher.match(`${path36}/`)) {
                  return true;
                }
              }
            }
          }
          return false;
        }));
        const files = event.files.filter((_, index) => fileMatches[index]);
        return __spreadProps(__spreadValues({}, event), { files });
      }
      static async getFileType(uri) {
        try {
          const stat = await statAsync(uri.fsPath);
          if (stat.isFile()) {
            return FileType.File;
          }
          if (stat.isDirectory()) {
            return FileType.Directory;
          }
          if (stat.isSymbolicLink()) {
            return FileType.SymbolicLink;
          }
          return FileType.Unknown;
        } catch (e) {
          return void 0;
        }
      }
      static asMinimatchOptions(options) {
        if (options === void 0) {
          return void 0;
        }
        if (options.ignoreCase === true) {
          return { nocase: true };
        }
        return void 0;
      }
    };
    NotificationFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = async (event) => {
            this._client.sendNotification(this._notificationType, this._createParams(event));
          };
          this.doSend(filteredEvent, next);
        }
      }
    };
    DidCreateFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onDidCreateFiles, import_vscode_languageserver_protocol62.DidCreateFilesNotification.type, "didCreate", "didCreate", (i) => i, (e) => asCreateDeleteFilesParams(e));
      }
      doSend(event, next) {
        var _a2;
        const middleware = (_a2 = this._client.clientOptions.middleware) == null ? void 0 : _a2.workspace;
        return (middleware == null ? void 0 : middleware.didCreateFiles) ? middleware.didCreateFiles(event, next) : next(event);
      }
    };
    DidRenameFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onDidRenameFiles, import_vscode_languageserver_protocol62.DidRenameFilesNotification.type, "didRename", "didRename", (i) => i.oldUri, (e) => asRenameFilesParams(e));
      }
      doSend(event, next) {
        var _a2;
        const middleware = (_a2 = this._client.clientOptions.middleware) == null ? void 0 : _a2.workspace;
        return (middleware == null ? void 0 : middleware.didRenameFiles) ? middleware.didRenameFiles(event, next) : next(event);
      }
    };
    DidDeleteFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onDidDeleteFiles, import_vscode_languageserver_protocol62.DidDeleteFilesNotification.type, "didDelete", "didDelete", (i) => i, (e) => asCreateDeleteFilesParams(e));
      }
      doSend(event, next) {
        var _a2;
        const middleware = (_a2 = this._client.clientOptions.middleware) == null ? void 0 : _a2.workspace;
        return (middleware == null ? void 0 : middleware.didDeleteFiles) ? middleware.didDeleteFiles(event, next) : next(event);
      }
    };
    RequestFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
      }
      async waitUntil(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = (event) => {
            return this._client.sendRequest(this._requestType, this._createParams(event));
          };
          return this.doSend(filteredEvent, next);
        } else {
          return void 0;
        }
      }
    };
    WillCreateFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onWillCreateFiles, import_vscode_languageserver_protocol62.WillCreateFilesRequest.type, "willCreate", "willCreate", (i) => i, (e) => asCreateDeleteFilesParams(e));
      }
      doSend(event, next) {
        var _a2;
        const middleware = (_a2 = this._client.clientOptions.middleware) == null ? void 0 : _a2.workspace;
        return (middleware == null ? void 0 : middleware.willCreateFiles) ? middleware.willCreateFiles(event, next) : next(event);
      }
    };
    WillRenameFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onWillRenameFiles, import_vscode_languageserver_protocol62.WillRenameFilesRequest.type, "willRename", "willRename", (i) => i.oldUri, (e) => asRenameFilesParams(e));
      }
      doSend(event, next) {
        var _a2;
        const middleware = (_a2 = this._client.clientOptions.middleware) == null ? void 0 : _a2.workspace;
        return (middleware == null ? void 0 : middleware.willRenameFiles) ? middleware.willRenameFiles(event, next) : next(event);
      }
    };
    WillDeleteFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onWillDeleteFiles, import_vscode_languageserver_protocol62.WillDeleteFilesRequest.type, "willDelete", "willDelete", (i) => i, (e) => asCreateDeleteFilesParams(e));
      }
      doSend(event, next) {
        var _a2;
        const middleware = (_a2 = this._client.clientOptions.middleware) == null ? void 0 : _a2.workspace;
        return (middleware == null ? void 0 : middleware.willDeleteFiles) ? middleware.willDeleteFiles(event, next) : next(event);
      }
    };
  }
});

// src/language-client/index.ts
var import_child_process4, import_fs17, import_path18, import_node, ChildProcess2, logger53, Executable, TransportKind, Transport, NodeModule, StreamInfo, ChildProcessInfo, LanguageClient, SettingMonitor, ProposedFeatures;
var init_language_client = __esm({
  "src/language-client/index.ts"() {
    import_child_process4 = __toModule(require("child_process"));
    import_fs17 = __toModule(require("fs"));
    import_path18 = __toModule(require("path"));
    import_node = __toModule(require_node3());
    init_types();
    init_util();
    init_is();
    init_processes();
    init_workspace();
    init_client();
    init_colorProvider();
    init_configuration3();
    init_declaration();
    init_foldingRange();
    init_implementation();
    init_progress2();
    init_typeDefinition();
    init_workspaceFolders();
    init_selectionRange();
    init_callHierarchy();
    init_semanticTokens();
    init_linkedEditingRange();
    init_fileOperations();
    init_client();
    ChildProcess2 = import_child_process4.default.ChildProcess;
    logger53 = require_logger2()("language-client-index");
    (function(Executable3) {
      function is(value) {
        return string(value.command);
      }
      Executable3.is = is;
    })(Executable || (Executable = {}));
    (function(TransportKind2) {
      TransportKind2[TransportKind2["stdio"] = 0] = "stdio";
      TransportKind2[TransportKind2["ipc"] = 1] = "ipc";
      TransportKind2[TransportKind2["pipe"] = 2] = "pipe";
      TransportKind2[TransportKind2["socket"] = 3] = "socket";
    })(TransportKind || (TransportKind = {}));
    (function(Transport3) {
      function isSocket(value) {
        let candidate = value;
        return candidate && candidate.kind === 3 && number(candidate.port);
      }
      Transport3.isSocket = isSocket;
    })(Transport || (Transport = {}));
    (function(NodeModule2) {
      function is(value) {
        return string(value.module);
      }
      NodeModule2.is = is;
    })(NodeModule || (NodeModule = {}));
    (function(StreamInfo2) {
      function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
      }
      StreamInfo2.is = is;
    })(StreamInfo || (StreamInfo = {}));
    (function(ChildProcessInfo2) {
      function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === "boolean";
      }
      ChildProcessInfo2.is = is;
    })(ChildProcessInfo || (ChildProcessInfo = {}));
    LanguageClient = class extends BaseLanguageClient {
      constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name2;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (string(arg2)) {
          id = arg1;
          name2 = arg2;
          serverOptions = arg3;
          clientOptions = arg4;
          forceDebug = !!arg5;
        } else {
          id = arg1.toLowerCase();
          name2 = arg1;
          serverOptions = arg2;
          clientOptions = arg3;
          forceDebug = arg4;
        }
        if (forceDebug === void 0) {
          forceDebug = false;
        }
        super(id, name2, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        this.registerProposedFeatures();
      }
      stop() {
        return super.stop().then(() => {
          if (this._serverProcess) {
            let toCheck = this._serverProcess;
            this._serverProcess = void 0;
            if (this._isDetached === void 0 || !this._isDetached) {
              this.checkProcessDied(toCheck);
            }
            this._isDetached = void 0;
          }
        });
      }
      get serviceState() {
        let state = this._state;
        switch (state) {
          case ClientState.Initial:
            return ServiceStat.Initial;
          case ClientState.Running:
            return ServiceStat.Running;
          case ClientState.StartFailed:
            return ServiceStat.StartFailed;
          case ClientState.Starting:
            return ServiceStat.Starting;
          case ClientState.Stopped:
            return ServiceStat.Stopped;
          case ClientState.Stopping:
            return ServiceStat.Stopping;
          default:
            logger53.error(`Unknown state: ${state}`);
            return ServiceStat.Stopped;
        }
      }
      static stateName(state) {
        switch (state) {
          case ClientState.Initial:
            return "Initial";
          case ClientState.Running:
            return "Running";
          case ClientState.StartFailed:
            return "StartFailed";
          case ClientState.Starting:
            return "Starting";
          case ClientState.Stopped:
            return "Stopped";
          case ClientState.Stopping:
            return "Stopping";
          default:
            return "Unknonw";
        }
      }
      checkProcessDied(childProcess) {
        if (!childProcess || global.hasOwnProperty("__TEST__"))
          return;
        if (global.hasOwnProperty("__TEST__")) {
          process.kill(childProcess.pid, 0);
          return;
        }
        setTimeout(() => {
          try {
            process.kill(childProcess.pid, 0);
            terminate(childProcess);
          } catch (error) {
          }
        }, 2e3);
      }
      handleConnectionClosed() {
        this._serverProcess = void 0;
        super.handleConnectionClosed();
      }
      createMessageTransports(encoding) {
        function getEnvironment(env, fork) {
          if (!env && !fork) {
            return void 0;
          }
          let result = Object.create(null);
          Object.keys(process.env).forEach((key) => result[key] = process.env[key]);
          if (env) {
            Object.keys(env).forEach((key) => result[key] = env[key]);
          }
          return result;
        }
        const debugStartWith = ["--debug=", "--debug-brk=", "--inspect=", "--inspect-brk="];
        const debugEquals = ["--debug", "--debug-brk", "--inspect", "--inspect-brk"];
        function startedInDebugMode() {
          let args = process.execArgv;
          if (args) {
            return args.some((arg) => {
              return debugStartWith.some((value) => arg.startsWith(value)) || debugEquals.some((value) => arg === value);
            });
          }
          return false;
        }
        function assertStdio(process2) {
          if (process2.stdin === null || process2.stdout === null || process2.stderr === null) {
            throw new Error("Process created without stdio streams");
          }
        }
        let server = this._serverOptions;
        if (func(server)) {
          return server().then((result) => {
            if (MessageTransports.is(result)) {
              this._isDetached = !!result.detached;
              return result;
            } else if (StreamInfo.is(result)) {
              this._isDetached = !!result.detached;
              return {
                reader: new import_node.StreamMessageReader(result.reader),
                writer: new import_node.StreamMessageWriter(result.writer)
              };
            } else {
              let cp3;
              if (ChildProcessInfo.is(result)) {
                cp3 = result.process;
                this._isDetached = result.detached;
              } else {
                cp3 = result;
                this._isDetached = false;
              }
              cp3.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
              return {
                reader: new import_node.StreamMessageReader(cp3.stdout),
                writer: new import_node.StreamMessageWriter(cp3.stdin)
              };
            }
          });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
          if (typeof v8debug === "object" || this._forceDebug || startedInDebugMode()) {
            json = runDebug.debug;
          } else {
            json = runDebug.run;
          }
        } else {
          json = server;
        }
        return this._getServerWorkingDir(json.options).then((serverWorkingDir) => {
          if (NodeModule.is(json) && json.module) {
            let node = json;
            let transport = node.transport || 0;
            if (node.runtime) {
              let args = [];
              let options = node.options || Object.create(null);
              if (options.execArgv) {
                options.execArgv.forEach((element) => args.push(element));
              }
              args.push(node.module);
              if (node.args) {
                node.args.forEach((element) => args.push(element));
              }
              const execOptions = Object.create(null);
              execOptions.cwd = serverWorkingDir;
              execOptions.env = getEnvironment(options.env, false);
              const runtime = this._getRuntimePath(node.runtime, serverWorkingDir);
              let pipeName;
              if (transport === 1) {
                execOptions.stdio = [null, null, null, "ipc"];
                args.push("--node-ipc");
              } else if (transport === 0) {
                args.push("--stdio");
              } else if (transport === 2) {
                pipeName = (0, import_node.generateRandomPipeName)();
                args.push(`--pipe=${pipeName}`);
              } else if (Transport.isSocket(transport)) {
                args.push(`--socket=${transport.port}`);
              }
              args.push(`--clientProcessId=${process.pid.toString()}`);
              if (transport === 1 || transport === 0) {
                let serverProcess = import_child_process4.default.spawn(runtime, args, execOptions);
                if (!serverProcess || !serverProcess.pid) {
                  return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                }
                this._serverProcess = serverProcess;
                serverProcess.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                if (transport === 1) {
                  serverProcess.stdout.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                  return Promise.resolve({ reader: new import_node.IPCMessageReader(serverProcess), writer: new import_node.IPCMessageWriter(serverProcess) });
                } else {
                  return Promise.resolve({ reader: new import_node.StreamMessageReader(serverProcess.stdout), writer: new import_node.StreamMessageWriter(serverProcess.stdin) });
                }
              } else if (transport === 2) {
                return (0, import_node.createClientPipeTransport)(pipeName).then((transport2) => {
                  let process2 = import_child_process4.default.spawn(runtime, args, execOptions);
                  if (!process2 || !process2.pid) {
                    return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                  }
                  this._serverProcess = process2;
                  process2.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                  process2.stdout.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                  return transport2.onConnected().then((protocol) => {
                    return { reader: protocol[0], writer: protocol[1] };
                  });
                });
              } else if (Transport.isSocket(transport)) {
                return (0, import_node.createClientSocketTransport)(transport.port).then((transport2) => {
                  let process2 = import_child_process4.default.spawn(runtime, args, execOptions);
                  if (!process2 || !process2.pid) {
                    return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                  }
                  this._serverProcess = process2;
                  process2.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                  process2.stdout.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                  return transport2.onConnected().then((protocol) => {
                    return { reader: protocol[0], writer: protocol[1] };
                  });
                });
              }
            } else {
              let pipeName;
              return new Promise((resolve3, _reject) => {
                let args = node.args && node.args.slice() || [];
                if (transport === 1) {
                  args.push("--node-ipc");
                } else if (transport === 0) {
                  args.push("--stdio");
                } else if (transport === 2) {
                  pipeName = (0, import_node.generateRandomPipeName)();
                  args.push(`--pipe=${pipeName}`);
                } else if (Transport.isSocket(transport)) {
                  args.push(`--socket=${transport.port}`);
                }
                args.push(`--clientProcessId=${process.pid.toString()}`);
                let options = node.options || Object.create(null);
                options.env = getEnvironment(options.env, true);
                options.execArgv = options.execArgv || [];
                options.cwd = serverWorkingDir;
                options.silent = true;
                if (transport === 1 || transport === 0) {
                  let sp = import_child_process4.default.fork(node.module, args || [], options);
                  assertStdio(sp);
                  this._serverProcess = sp;
                  sp.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                  if (transport === 1) {
                    sp.stdout.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                    resolve3({ reader: new import_node.IPCMessageReader(this._serverProcess), writer: new import_node.IPCMessageWriter(this._serverProcess) });
                  } else {
                    resolve3({ reader: new import_node.StreamMessageReader(sp.stdout), writer: new import_node.StreamMessageWriter(sp.stdin) });
                  }
                } else if (transport === 2) {
                  void (0, import_node.createClientPipeTransport)(pipeName).then((transport2) => {
                    let sp = import_child_process4.default.fork(node.module, args || [], options);
                    assertStdio(sp);
                    this._serverProcess = sp;
                    sp.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                    sp.stdout.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                    void transport2.onConnected().then((protocol) => {
                      resolve3({ reader: protocol[0], writer: protocol[1] });
                    });
                  });
                } else if (Transport.isSocket(transport)) {
                  void (0, import_node.createClientSocketTransport)(transport.port).then((transport2) => {
                    let sp = import_child_process4.default.fork(node.module, args || [], options);
                    assertStdio(sp);
                    this._serverProcess = sp;
                    sp.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                    sp.stdout.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
                    void transport2.onConnected().then((protocol) => {
                      resolve3({ reader: protocol[0], writer: protocol[1] });
                    });
                  });
                }
              });
            }
          } else if (Executable.is(json) && json.command) {
            let command = json;
            let args = command.args || [];
            let options = Object.assign({}, command.options);
            options.env = options.env ? Object.assign({}, process.env, options.env) : process.env;
            options.cwd = options.cwd || serverWorkingDir;
            let cmd = workspace_default.expand(json.command);
            let serverProcess = import_child_process4.default.spawn(cmd, args, options);
            serverProcess.on("error", (e) => {
              this.error(e.message);
              logger53.error(e);
            });
            if (!serverProcess || !serverProcess.pid) {
              return Promise.reject(`Launching server "${this.id}" using command ${command.command} failed.`);
            }
            logger53.info(`Language server "${this.id}" started with ${serverProcess.pid}`);
            serverProcess.on("exit", (code) => {
              if (code != 0)
                this.error(`${command.command} exited with code: ${code}`);
            });
            serverProcess.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
            this._serverProcess = serverProcess;
            this._isDetached = !!options.detached;
            return Promise.resolve({ reader: new import_node.StreamMessageReader(serverProcess.stdout), writer: new import_node.StreamMessageWriter(serverProcess.stdin) });
          }
          return Promise.reject(`Unsupported server configuration ${JSON.stringify(server, null, 2)}`);
        });
      }
      _getRuntimePath(runtime, serverWorkingDirectory) {
        if (import_path18.default.isAbsolute(runtime)) {
          return runtime;
        }
        const mainRootPath = this._mainGetRootPath();
        if (mainRootPath !== void 0) {
          const result = import_path18.default.join(mainRootPath, runtime);
          if (import_fs17.default.existsSync(result)) {
            return result;
          }
        }
        if (serverWorkingDirectory !== void 0) {
          const result = import_path18.default.join(serverWorkingDirectory, runtime);
          if (import_fs17.default.existsSync(result)) {
            return result;
          }
        }
        return runtime;
      }
      _mainGetRootPath() {
        let folders = workspace_default.workspaceFolders;
        if (!folders || folders.length === 0) {
          return void 0;
        }
        let folder = folders[0];
        return folder.uri;
      }
      registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
      }
      registerBuiltinFeatures() {
        super.registerBuiltinFeatures();
        this.registerFeature(new ConfigurationFeature2(this));
        this.registerFeature(new TypeDefinitionFeature(this));
        this.registerFeature(new ImplementationFeature(this));
        this.registerFeature(new DeclarationFeature(this));
        this.registerFeature(new ColorProviderFeature(this));
        this.registerFeature(new FoldingRangeFeature(this));
        this.registerFeature(new SelectionRangeFeature(this));
        this.registerFeature(new ProgressFeature(this));
        this.registerFeature(new CallHierarchyFeature(this));
        if (workspace_default.isNvim || workspace_default.isVim && workspace_default.env.textprop) {
          const config = workspace_default.getConfiguration("coc.preferences");
          const enabled = config.get("semanticTokensHighlights", true);
          if (enabled)
            this.registerFeature(new SemanticTokensFeature(this));
        }
        this.registerFeature(new LinkedEditingFeature(this));
        this.registerFeature(new DidCreateFilesFeature(this));
        this.registerFeature(new DidRenameFilesFeature(this));
        this.registerFeature(new DidDeleteFilesFeature(this));
        this.registerFeature(new WillCreateFilesFeature(this));
        this.registerFeature(new WillRenameFilesFeature(this));
        this.registerFeature(new WillDeleteFilesFeature(this));
        if (!this.clientOptions.disableWorkspaceFolders) {
          this.registerFeature(new WorkspaceFoldersFeature(this));
        }
      }
      _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (cwd && !import_path18.default.isAbsolute(cwd))
          cwd = import_path18.default.join(workspace_default.cwd, cwd);
        if (!cwd)
          cwd = workspace_default.cwd;
        if (cwd) {
          return new Promise((s) => {
            import_fs17.default.lstat(cwd, (err, stats) => {
              s(!err && stats.isDirectory() ? cwd : void 0);
            });
          });
        }
        return Promise.resolve(void 0);
      }
      appendOutput(data, encoding) {
        let msg = string(data) ? data : data.toString(encoding);
        this.outputChannel.append(msg.endsWith("\n") ? msg : msg + "\n");
      }
    };
    SettingMonitor = class {
      constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
      }
      start() {
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(this._setting)) {
            this.onDidChangeConfiguration();
          }
        }, null, this._listeners);
        this.onDidChangeConfiguration();
        return {
          dispose: () => {
            disposeAll(this._listeners);
            if (this._client.needsStop()) {
              this._client.stop();
            }
          }
        };
      }
      onDidChangeConfiguration() {
        let index = this._setting.indexOf(".");
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : void 0;
        let enabled = rest ? workspace_default.getConfiguration(primary).get(rest, true) : workspace_default.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
          this._client.start();
        } else if (!enabled && this._client.needsStop()) {
          this._client.stop();
        }
      }
    };
    (function(ProposedFeatures2) {
      function createAll(_client) {
        let result = [];
        return result;
      }
      ProposedFeatures2.createAll = createAll;
    })(ProposedFeatures || (ProposedFeatures = {}));
  }
});

// src/services.ts
function getStateName(state) {
  switch (state) {
    case ServiceStat.Initial:
      return "init";
    case ServiceStat.Running:
      return "running";
    case ServiceStat.Starting:
      return "starting";
    case ServiceStat.StartFailed:
      return "startFailed";
    case ServiceStat.Stopping:
      return "stopping";
    case ServiceStat.Stopped:
      return "stopped";
    default:
      return "unknown";
  }
}
function documentSelectorToLanguageIds(documentSelector) {
  let res = documentSelector.map((filter) => {
    if (typeof filter == "string") {
      return filter;
    }
    return filter.language;
  });
  res = res.filter((s) => typeof s == "string");
  return Array.from(new Set(res));
}
function getLanguageServerOptions(id, name2, config) {
  let { command, module: module2, port, args, filetypes } = config;
  args = args || [];
  if (!filetypes) {
    window_default.showMessage(`Wrong configuration of LS "${name2}", filetypes not found`, "error");
    return null;
  }
  if (!command && !module2 && !port) {
    window_default.showMessage(`Wrong configuration of LS "${name2}", no command or module specified.`, "error");
    return null;
  }
  let serverOptions;
  if (module2) {
    module2 = workspace_default.expand(module2);
    if (!import_fs18.default.existsSync(module2)) {
      window_default.showMessage(`Module file "${module2}" not found for LS "${name2}"`, "error");
      return null;
    }
    serverOptions = {
      module: module2,
      runtime: config.runtime || process.execPath,
      args,
      transport: getTransportKind(config),
      options: getForkOptions(config)
    };
  } else if (command) {
    serverOptions = {
      command,
      args,
      options: getSpawnOptions(config)
    };
  } else if (port) {
    serverOptions = () => new Promise((resolve3, reject) => {
      let client = new import_net2.default.Socket();
      let host = config.host || "127.0.0.1";
      logger54.info(`languageserver "${id}" connecting to ${host}:${port}`);
      client.connect(port, host, () => {
        resolve3({
          reader: client,
          writer: client
        });
      });
      client.on("error", (e) => {
        reject(new Error(`Connection error for ${id}: ${e.message}`));
      });
    });
  }
  let disableWorkspaceFolders = !!config.disableWorkspaceFolders;
  let disableSnippetCompletion = !!config.disableSnippetCompletion;
  let ignoredRootPaths = config.ignoredRootPaths || [];
  let clientOptions = {
    ignoredRootPaths: ignoredRootPaths.map((s) => workspace_default.expand(s)),
    disableWorkspaceFolders,
    disableSnippetCompletion,
    disableDynamicRegister: !!config.disableDynamicRegister,
    disableCompletion: !!config.disableCompletion,
    disableDiagnostics: !!config.disableDiagnostics,
    formatterPriority: config.formatterPriority || 0,
    documentSelector: getDocumentSelector(config.filetypes, config.additionalSchemes),
    revealOutputChannelOn: getRevealOutputChannelOn(config.revealOutputChannelOn),
    synchronize: {
      configurationSection: `${id}.settings`
    },
    diagnosticCollectionName: name2,
    outputChannelName: id,
    stdioEncoding: config.stdioEncoding || "utf8",
    progressOnInitialization: config.progressOnInitialization !== false,
    initializationOptions: config.initializationOptions || {}
  };
  return [clientOptions, serverOptions];
}
function getRevealOutputChannelOn(revealOn) {
  switch (revealOn) {
    case "info":
      return RevealOutputChannelOn.Info;
    case "warn":
      return RevealOutputChannelOn.Warn;
    case "error":
      return RevealOutputChannelOn.Error;
    case "never":
      return RevealOutputChannelOn.Never;
    default:
      return RevealOutputChannelOn.Never;
  }
}
function getDocumentSelector(filetypes, additionalSchemes) {
  let documentSelector = [];
  let schemes = ["file", "untitled"].concat(additionalSchemes || []);
  if (!filetypes)
    return schemes.map((s) => ({ scheme: s }));
  filetypes.forEach((filetype) => {
    documentSelector.push(...schemes.map((scheme) => ({ language: filetype, scheme })));
  });
  return documentSelector;
}
function getTransportKind(config) {
  let { transport, transportPort } = config;
  if (!transport || transport == "ipc")
    return TransportKind.ipc;
  if (transport == "stdio")
    return TransportKind.stdio;
  if (transport == "pipe")
    return TransportKind.pipe;
  return { kind: TransportKind.socket, port: transportPort };
}
function getForkOptions(config) {
  return {
    cwd: config.cwd,
    execArgv: config.execArgv || [],
    env: config.env || void 0
  };
}
function getSpawnOptions(config) {
  return {
    cwd: config.cwd,
    detached: !!config.detached,
    shell: !!config.shell,
    env: config.env || void 0
  };
}
function stateString(state) {
  switch (state) {
    case State2.Running:
      return "running";
    case State2.Starting:
      return "starting";
    case State2.Stopped:
      return "stopped";
    default:
      return "unknown";
  }
}
var import_events18, import_fs18, import_net2, import_vscode_languageserver_protocol63, logger54, ServiceManager, services_default;
var init_services = __esm({
  "src/services.ts"() {
    import_events18 = __toModule(require("events"));
    import_fs18 = __toModule(require("fs"));
    import_net2 = __toModule(require("net"));
    import_vscode_languageserver_protocol63 = __toModule(require_main2());
    init_language_client();
    init_types();
    init_util();
    init_workspace();
    init_window();
    logger54 = require_logger2()("services");
    ServiceManager = class extends import_events18.EventEmitter {
      constructor() {
        super(...arguments);
        this.registered = new Map();
        this.disposables = [];
      }
      init() {
        workspace_default.onDidOpenTextDocument((document2) => {
          this.start(document2);
        }, null, this.disposables);
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("languageserver")) {
            this.createCustomServices();
          }
        }, null, this.disposables);
        this.createCustomServices();
      }
      dispose() {
        this.removeAllListeners();
        disposeAll(this.disposables);
        for (let service of this.registered.values()) {
          service.dispose();
        }
      }
      regist(service) {
        let { id } = service;
        if (!id)
          logger54.error("invalid service configuration. ", service.name);
        if (this.registered.get(id))
          return;
        this.registered.set(id, service);
        logger54.info(`registered service "${id}"`);
        if (this.shouldStart(service)) {
          service.start();
        }
        if (service.state == ServiceStat.Running) {
          this.emit("ready", id);
        }
        service.onServiceReady(() => {
          logger54.info(`service ${id} started`);
          this.emit("ready", id);
        }, null, this.disposables);
        return import_vscode_languageserver_protocol63.Disposable.create(() => {
          service.stop();
          service.dispose();
          this.registered.delete(id);
        });
      }
      getService(id) {
        let service = this.registered.get(id);
        if (!service)
          service = this.registered.get(`languageserver.${id}`);
        return service;
      }
      shouldStart(service) {
        if (service.state != ServiceStat.Initial) {
          return false;
        }
        let selector = service.selector;
        for (let doc of workspace_default.documents) {
          if (workspace_default.match(selector, doc.textDocument)) {
            return true;
          }
        }
        return false;
      }
      start(document2) {
        let services = this.getServices(document2);
        for (let service of services) {
          if (service.state == ServiceStat.Initial) {
            service.start();
          }
        }
      }
      getServices(document2) {
        let res = [];
        for (let service of this.registered.values()) {
          if (workspace_default.match(service.selector, document2) > 0) {
            res.push(service);
          }
        }
        return res;
      }
      stop(id) {
        let service = this.registered.get(id);
        if (!service) {
          window_default.showMessage(`Service ${id} not found`, "error");
          return;
        }
        return Promise.resolve(service.stop());
      }
      stopAll() {
        for (let service of this.registered.values()) {
          service.stop();
        }
      }
      async toggle(id) {
        let service = this.registered.get(id);
        if (!service) {
          window_default.showMessage(`Service ${id} not found`, "error");
          return;
        }
        let { state } = service;
        try {
          if (state == ServiceStat.Running) {
            await Promise.resolve(service.stop());
          } else if (state == ServiceStat.Initial) {
            await service.start();
          } else if (state == ServiceStat.Stopped) {
            await service.restart();
          }
        } catch (e) {
          window_default.showMessage(`Service error: ${e.message}`, "error");
        }
      }
      getServiceStats() {
        let res = [];
        for (let [id, service] of this.registered) {
          res.push({
            id,
            languageIds: documentSelectorToLanguageIds(service.selector),
            state: getStateName(service.state)
          });
        }
        return res;
      }
      createCustomServices() {
        let lspConfig = workspace_default.getConfiguration().get("languageserver", {});
        for (let key of Object.keys(lspConfig)) {
          let config = lspConfig[key];
          if (!this.validServerConfig(key, config)) {
            continue;
          }
          this.registLanguageClient(key, config);
        }
      }
      validServerConfig(key, config) {
        let errors = [];
        if (config.module != null && typeof config.module !== "string") {
          errors.push(`"module" field of languageserver ${key} should be string`);
        }
        if (config.command != null && typeof config.command !== "string") {
          errors.push(`"command" field of languageserver ${key} should be string`);
        }
        if (config.transport != null && typeof config.transport !== "string") {
          errors.push(`"transport" field of languageserver ${key} should be string`);
        }
        if (config.transportPort != null && typeof config.transportPort !== "number") {
          errors.push(`"transportPort" field of languageserver ${key} should be string`);
        }
        if (!Array.isArray(config.filetypes) || !config.filetypes.every((s) => typeof s === "string")) {
          errors.push(`"filetypes" field of languageserver ${key} should be array of string`);
        }
        if (config.additionalSchemes && (!Array.isArray(config.additionalSchemes) || config.additionalSchemes.some((s) => typeof s !== "string"))) {
          errors.push(`"additionalSchemes" field of languageserver ${key} should be array of string`);
        }
        if (errors.length) {
          window_default.showMessage(errors.join("\n"), "error");
          return false;
        }
        return true;
      }
      waitClient(id) {
        let service = this.getService(id);
        if (service && service.state == ServiceStat.Running)
          return Promise.resolve();
        if (service)
          return new Promise((resolve3) => {
            service.onServiceReady(() => {
              resolve3();
            });
          });
        return new Promise((resolve3) => {
          let listener = (clientId) => {
            if (clientId == id || clientId == `languageserver.${id}`) {
              this.off("ready", listener);
              resolve3();
            }
          };
          this.on("ready", listener);
        });
      }
      async registNotification(id, method) {
        await this.waitClient(id);
        let service = this.getService(id);
        if (!service.client) {
          window_default.showMessage(`Not a language client: ${id}`, "error");
          return;
        }
        let client = service.client;
        client.onNotification(method, async (result) => {
          await workspace_default.nvim.call("coc#do_notify", [id, method, result]);
        });
      }
      async sendNotification(id, method, params) {
        if (!method)
          throw new Error(`method required for ontification`);
        let service = this.getService(id);
        if (!service || !service.client)
          throw new Error(`Language server ${id} not found`);
        if (service.state == ServiceStat.Starting) {
          await service.client.onReady();
        }
        if (service.state != ServiceStat.Running) {
          throw new Error(`Language server ${id} not running`);
        }
        await Promise.resolve(service.client.sendNotification(method, params));
      }
      async sendRequest(id, method, params, token) {
        if (!method)
          throw new Error(`method required for sendRequest`);
        let service = this.getService(id);
        if (!service)
          await wait(100);
        service = this.getService(id);
        if (!service || !service.client) {
          throw new Error(`Language server ${id} not found`);
        }
        if (service.state == ServiceStat.Starting) {
          await service.client.onReady();
        }
        if (service.state != ServiceStat.Running) {
          throw new Error(`Language server ${id} not running`);
        }
        if (!token) {
          let tokenSource = new import_vscode_languageserver_protocol63.CancellationTokenSource();
          token = tokenSource.token;
        }
        return await Promise.resolve(service.client.sendRequest(method, params, token));
      }
      registLanguageClient(name2, config) {
        let id = typeof name2 === "string" ? `languageserver.${name2}` : name2.id;
        let disposables = [];
        let onDidServiceReady = new import_vscode_languageserver_protocol63.Emitter();
        let client = typeof name2 === "string" ? null : name2;
        if (this.registered.has(id))
          return;
        let created = false;
        let service = {
          id,
          client,
          name: typeof name2 === "string" ? name2 : name2.name,
          selector: typeof name2 === "string" ? getDocumentSelector(config.filetypes, config.additionalSchemes) : name2.clientOptions.documentSelector,
          state: ServiceStat.Initial,
          onServiceReady: onDidServiceReady.event,
          start: () => {
            if (service.state == ServiceStat.Starting || service.state == ServiceStat.Running) {
              return;
            }
            if (client && !client.needsStart()) {
              return;
            }
            if (created && client) {
              client.restart();
              return Promise.resolve();
            }
            if (!created) {
              if (typeof name2 == "string" && !client) {
                let config2 = workspace_default.getConfiguration().get("languageserver", {})[name2];
                if (!config2 || config2.enable === false)
                  return;
                let opts = getLanguageServerOptions(id, name2, config2);
                if (!opts)
                  return;
                client = new LanguageClient(id, name2, opts[1], opts[0]);
                service.selector = opts[0].documentSelector;
                service.client = client;
              }
              client.onDidChangeState((changeEvent) => {
                let { oldState, newState } = changeEvent;
                if (newState == State2.Starting) {
                  service.state = ServiceStat.Starting;
                } else if (newState == State2.Running) {
                  service.state = ServiceStat.Running;
                } else if (newState == State2.Stopped) {
                  service.state = ServiceStat.Stopped;
                }
                let oldStr = stateString(oldState);
                let newStr = stateString(newState);
                logger54.info(`${client.name} state change: ${oldStr} => ${newStr}`);
              }, null, disposables);
              created = true;
            }
            service.state = ServiceStat.Starting;
            logger54.debug(`starting service: ${id}`);
            let disposable = client.start();
            disposables.push(disposable);
            return new Promise((resolve3) => {
              client.onReady().then(() => {
                onDidServiceReady.fire(void 0);
                resolve3();
              }, (e) => {
                window_default.showMessage(`Server ${id} failed to start: ${e}`, "error");
                logger54.error(`Server ${id} failed to start:`, e);
                service.state = ServiceStat.StartFailed;
                resolve3();
              });
            });
          },
          dispose: async () => {
            onDidServiceReady.dispose();
            disposeAll(disposables);
          },
          stop: async () => {
            if (!client || !client.needsStop())
              return;
            await Promise.resolve(client.stop());
          },
          restart: async () => {
            if (client) {
              service.state = ServiceStat.Starting;
              client.restart();
            } else {
              await service.start();
            }
          }
        };
        return this.regist(service);
      }
    };
    services_default = new ServiceManager();
  }
});

// src/list/configuration.ts
var import_events19, validKeys, ListConfiguration;
var init_configuration4 = __esm({
  "src/list/configuration.ts"() {
    init_workspace();
    init_window();
    import_events19 = __toModule(require("events"));
    validKeys = [
      "<esc>",
      "<space>",
      "<tab>",
      "<s-tab>",
      "<bs>",
      "<right>",
      "<left>",
      "<up>",
      "<down>",
      "<home>",
      "<end>",
      "<cr>",
      "<FocusGained>",
      "<FocusLost>",
      "<ScrollWheelUp>",
      "<ScrollWheelDown>",
      "<LeftMouse>",
      "<LeftDrag>",
      "<LeftRelease>",
      "<2-LeftMouse>",
      "<C-a>",
      "<C-b>",
      "<C-c>",
      "<C-d>",
      "<C-e>",
      "<C-f>",
      "<C-g>",
      "<C-h>",
      "<C-i>",
      "<C-j>",
      "<C-k>",
      "<C-l>",
      "<C-m>",
      "<C-n>",
      "<C-o>",
      "<C-p>",
      "<C-q>",
      "<C-r>",
      "<C-s>",
      "<C-t>",
      "<C-u>",
      "<C-v>",
      "<C-w>",
      "<C-x>",
      "<C-y>",
      "<C-z>",
      "<A-a>",
      "<A-b>",
      "<A-c>",
      "<A-d>",
      "<A-e>",
      "<A-f>",
      "<A-g>",
      "<A-h>",
      "<A-i>",
      "<A-j>",
      "<A-k>",
      "<A-l>",
      "<A-m>",
      "<A-n>",
      "<A-o>",
      "<A-p>",
      "<A-q>",
      "<A-r>",
      "<A-s>",
      "<A-t>",
      "<A-u>",
      "<A-v>",
      "<A-w>",
      "<A-x>",
      "<A-y>",
      "<A-z>"
    ];
    ListConfiguration = class extends import_events19.EventEmitter {
      constructor() {
        super();
        this.configuration = workspace_default.getConfiguration("list");
        this.disposable = workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("list")) {
            this.configuration = workspace_default.getConfiguration("list");
            this.emit("change");
          }
        });
      }
      get(key, defaultValue) {
        return this.configuration.get(key, defaultValue);
      }
      get previousKey() {
        return this.fixKey(this.configuration.get("previousKeymap", "<C-j>"));
      }
      get nextKey() {
        return this.fixKey(this.configuration.get("nextKeymap", "<C-k>"));
      }
      dispose() {
        this.disposable.dispose();
        this.removeAllListeners();
      }
      fixKey(key) {
        if (validKeys.includes(key))
          return key;
        let find = validKeys.find((s) => s.toLowerCase() == key.toLowerCase());
        if (find)
          return find;
        window_default.showMessage(`Configured key "${key}" not supported.`, "error");
        return null;
      }
    };
  }
});

// src/list/mappings.ts
var import_extensions, logger55, Mappings;
var init_mappings = __esm({
  "src/list/mappings.ts"() {
    import_extensions = __toModule(require_extensions());
    init_window();
    init_configuration4();
    logger55 = require_logger2()("list-mappings");
    Mappings = class {
      constructor(manager, nvim, config) {
        this.manager = manager;
        this.nvim = nvim;
        this.config = config;
        this.insertMappings = new Map();
        this.normalMappings = new Map();
        this.userInsertMappings = new Map();
        this.userNormalMappings = new Map();
        let { prompt } = manager;
        this.add("insert", "<C-n>", () => {
          var _a2;
          (_a2 = manager.session) == null ? void 0 : _a2.history.next();
        });
        this.add("insert", "<C-p>", () => {
          var _a2;
          (_a2 = manager.session) == null ? void 0 : _a2.history.previous();
        });
        this.add("insert", "<C-v>", async () => {
          await prompt.paste();
        });
        this.add("insert", "<C-s>", () => manager.switchMatcher());
        this.add("insert", ["<C-m>", "<cr>"], async () => {
          await manager.doAction();
        });
        this.add("insert", ["<tab>", "<C-i>", "	"], () => manager.chooseAction());
        this.add("insert", "<C-o>", () => {
          manager.toggleMode();
        });
        this.add("insert", "<C-c>", () => {
          manager.stop();
          return;
        });
        this.add("insert", "<C-l>", async () => {
          var _a2;
          await ((_a2 = manager.session) == null ? void 0 : _a2.reloadItems());
        });
        this.add("insert", "<left>", () => {
          prompt.moveLeft();
        });
        this.add("insert", "<right>", () => {
          prompt.moveRight();
        });
        this.add("insert", ["<end>", "<C-e>"], () => {
          prompt.moveToEnd();
        });
        this.add("insert", ["<home>", "<C-a>"], () => {
          prompt.moveToStart();
        });
        this.add("insert", ["<C-h>", "<bs>", "<backspace>"], () => {
          prompt.onBackspace();
        });
        this.add("insert", "<C-w>", () => {
          prompt.removeWord();
        });
        this.add("insert", "<C-u>", () => {
          prompt.removeAhead();
        });
        this.add("insert", "<C-r>", () => prompt.insertRegister());
        this.add("insert", "<C-d>", () => manager.feedkeys("<C-d>", false));
        this.add("insert", "<PageUp>", () => manager.feedkeys("<PageUp>", false));
        this.add("insert", "<PageDown>", () => manager.feedkeys("<PageDown>", false));
        this.add("insert", "<down>", () => manager.normal("j"));
        this.add("insert", "<up>", () => manager.normal("k"));
        this.add("insert", ["<ScrollWheelUp>"], this.doScroll.bind(this, "<ScrollWheelUp>"));
        this.add("insert", ["<ScrollWheelDown>"], this.doScroll.bind(this, "<ScrollWheelDown>"));
        this.add("insert", ["<C-f>"], this.doScroll.bind(this, "<C-f>"));
        this.add("insert", ["<C-b>"], this.doScroll.bind(this, "<C-b>"));
        this.add("normal", "t", () => manager.doAction("tabe"));
        this.add("normal", "s", () => manager.doAction("split"));
        this.add("normal", "d", () => manager.doAction("drop"));
        this.add("normal", ["<cr>", "<C-m>", "\r"], () => manager.doAction());
        this.add("normal", "<C-a>", () => {
          var _a2;
          return (_a2 = manager.session) == null ? void 0 : _a2.ui.selectAll();
        });
        this.add("normal", " ", () => {
          var _a2;
          return (_a2 = manager.session) == null ? void 0 : _a2.ui.toggleSelection();
        });
        this.add("normal", "p", () => manager.togglePreview());
        this.add("normal", ["<tab>", "	", "<C-i>"], () => manager.chooseAction());
        this.add("normal", "<C-c>", () => {
          manager.stop();
        });
        this.add("normal", "<C-l>", () => {
          var _a2;
          return (_a2 = manager.session) == null ? void 0 : _a2.reloadItems();
        });
        this.add("normal", "<C-o>", () => {
          var _a2;
          return (_a2 = manager.session) == null ? void 0 : _a2.jumpBack();
        });
        this.add("normal", "<C-e>", () => this.scrollPreview("down"));
        this.add("normal", "<C-y>", () => this.scrollPreview("up"));
        this.add("normal", ["i", "I", "o", "O", "a", "A"], () => manager.toggleMode());
        this.add("normal", "?", () => {
          var _a2;
          return (_a2 = manager.session) == null ? void 0 : _a2.showHelp();
        });
        this.add("normal", ":", async () => {
          await manager.cancel(false);
          await nvim.eval('feedkeys(":")');
        });
        this.add("normal", ["<ScrollWheelUp>"], this.doScroll.bind(this, "<ScrollWheelUp>"));
        this.add("normal", ["<ScrollWheelDown>"], this.doScroll.bind(this, "<ScrollWheelDown>"));
        this.createMappings();
        config.on("change", () => {
          this.createMappings();
        });
      }
      createMappings() {
        let insertMappings = this.config.get("insertMappings", {});
        this.userInsertMappings = this.fixUserMappings(insertMappings);
        let normalMappings = this.config.get("normalMappings", {});
        this.userNormalMappings = this.fixUserMappings(normalMappings);
      }
      fixUserMappings(mappings) {
        let res = new Map();
        for (let [key, value] of Object.entries(mappings)) {
          if (key.length == 1) {
            res.set(key, value);
          } else if (key.startsWith("<") && key.endsWith(">")) {
            if (key.toLowerCase() == "<space>") {
              res.set(" ", value);
            } else if (key.toLowerCase() == "<backspace>") {
              res.set("<bs>", value);
            } else if (validKeys.includes(key)) {
              res.set(key, value);
            } else {
              let find = false;
              for (let i = 0; i < validKeys.length; i++) {
                if (validKeys[i].toLowerCase() == key.toLowerCase()) {
                  find = true;
                  res.set(validKeys[i], value);
                  break;
                }
              }
              if (!find)
                window_default.showMessage(`Invalid list mappings key configuration: "${key}"`, "warning");
            }
          } else {
            window_default.showMessage(`Invalid list mappings key configuration: "${key}"`, "warning");
          }
        }
        return res;
      }
      async doInsertKeymap(key) {
        let nextKey = this.config.nextKey;
        let previousKey = this.config.previousKey;
        let { session } = this.manager;
        if (!session)
          return;
        if (key == nextKey) {
          session.ui.index = session.ui.index + 1;
          return true;
        }
        if (key == previousKey) {
          session.ui.index = session.ui.index - 1;
          return true;
        }
        let expr = this.userInsertMappings.get(key);
        if (expr) {
          await this.evalExpression(expr, "insert");
          return true;
        }
        if (this.insertMappings.has(key)) {
          let fn = this.insertMappings.get(key);
          await Promise.resolve(fn());
          return true;
        }
        return false;
      }
      async doNormalKeymap(key) {
        let expr = this.userNormalMappings.get(key);
        if (expr) {
          await this.evalExpression(expr, "normal");
          return true;
        }
        if (this.normalMappings.has(key)) {
          let fn = this.normalMappings.get(key);
          await Promise.resolve(fn());
          return true;
        }
        return false;
      }
      add(mode, key, fn) {
        let mappings = mode == "insert" ? this.insertMappings : this.normalMappings;
        if (Array.isArray(key)) {
          for (let k of key) {
            mappings.set(k, fn);
          }
        } else {
          mappings.set(key, fn);
        }
      }
      async onError(msg) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        window_default.showMessage(msg, "error");
      }
      async evalExpression(expr, _mode) {
        var _a2, _b, _c, _d, _e, _f, _g;
        if (typeof expr != "string" || !expr.includes(":")) {
          await this.onError(`Invalid list mapping expression: ${expr}`);
          return;
        }
        let { manager } = this;
        let { prompt } = manager;
        let [key, action] = expr.split(":", 2);
        if (key == "do") {
          switch (action.toLowerCase()) {
            case "switch":
              manager.switchMatcher();
              return;
            case "selectall":
              await ((_a2 = manager.session) == null ? void 0 : _a2.ui.selectAll());
              return;
            case "help":
              await ((_b = manager.session) == null ? void 0 : _b.showHelp());
              return;
            case "refresh":
              await ((_c = manager.session) == null ? void 0 : _c.reloadItems());
              return;
            case "exit":
              await manager.cancel();
              return;
            case "stop":
              manager.stop();
              return;
            case "cancel":
              await manager.cancel(false);
              return;
            case "toggle":
              await ((_d = manager.session) == null ? void 0 : _d.ui.toggleSelection());
              return;
            case "jumpback":
              (_e = manager.session) == null ? void 0 : _e.jumpBack();
              return;
            case "previous":
              await manager.normal("k");
              return;
            case "next":
              await manager.normal("j");
              return;
            case "defaultaction":
              await manager.doAction();
              return;
            case "togglemode":
              return manager.toggleMode();
            case "previewtoggle":
              return manager.togglePreview();
            case "previewup":
              return this.scrollPreview("up");
            case "previewdown":
              return this.scrollPreview("down");
            default:
              await this.onError(`'${action}' not supported`);
          }
        } else if (key == "prompt") {
          switch (action) {
            case "previous":
              (_f = manager.session) == null ? void 0 : _f.history.previous();
              return;
            case "next":
              (_g = manager.session) == null ? void 0 : _g.history.next();
              return;
            case "start":
              return prompt.moveToStart();
            case "end":
              return prompt.moveToEnd();
            case "left":
              return prompt.moveLeft();
            case "right":
              return prompt.moveRight();
            case "deleteforward":
              return prompt.onBackspace();
            case "deletebackward":
              return prompt.removeNext();
            case "removetail":
              return prompt.removeTail();
            case "removeahead":
              return prompt.removeAhead();
            case "insertregister":
              prompt.insertRegister();
              return;
            case "paste":
              await prompt.paste();
              return;
            default:
              await this.onError(`prompt '${action}' not supported`);
          }
        } else if (key == "eval") {
          await prompt.eval(action);
        } else if (key == "command") {
          await manager.command(action);
        } else if (key == "action") {
          await manager.doAction(action);
        } else if (key == "feedkeys") {
          await manager.feedkeys(action);
        } else if (key == "normal") {
          await manager.normal(action, false);
        } else if (key == "normal!") {
          await manager.normal(action, true);
        } else if (key == "call") {
          await manager.call(action);
        } else if (key == "expr") {
          let name2 = await manager.call(action);
          if (name2)
            await manager.doAction(name2);
        } else {
          await this.onError(`Invalid expression ${expr}`);
        }
      }
      async doScroll(key) {
        await this.manager.feedkeys(key);
      }
      scrollPreview(dir) {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.call("coc#list#scroll_preview", [dir], true);
        nvim.command("redraw", true);
        void nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/prompt.ts
var import_vscode_languageserver_protocol64, logger56, Prompt;
var init_prompt = __esm({
  "src/list/prompt.ts"() {
    import_vscode_languageserver_protocol64 = __toModule(require_main2());
    logger56 = require_logger2()("list-prompt");
    Prompt = class {
      constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.cusorIndex = 0;
        this._input = "";
        this._mode = "insert";
        this.interactive = false;
        this.requestInput = false;
        this._onDidChangeInput = new import_vscode_languageserver_protocol64.Emitter();
        this.onDidChangeInput = this._onDidChangeInput.event;
      }
      get input() {
        return this._input;
      }
      set input(str) {
        if (this._input == str)
          return;
        this.cusorIndex = str.length;
        this._input = str;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      get mode() {
        return this._mode;
      }
      set mode(val) {
        if (val == this._mode)
          return;
        this._mode = val;
        this.drawPrompt();
      }
      set matcher(val) {
        this._matcher = val;
        this.drawPrompt();
      }
      start(opts) {
        if (opts) {
          this.interactive = opts.interactive;
          this.cusorIndex = opts.input.length;
          this._input = opts.input;
          this._mode = opts.mode;
          this._matcher = opts.interactive ? "" : opts.matcher;
        }
        this.nvim.call("coc#prompt#start_prompt", ["list"], true);
        this.drawPrompt();
      }
      cancel() {
        let { nvim } = this;
        nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      reset() {
        this._input = "";
        this.cusorIndex = 0;
      }
      drawPrompt() {
        let indicator = this.config.get("indicator", ">");
        let { cusorIndex, interactive, input, _matcher } = this;
        let cmds = ['echo ""'];
        if (this.mode == "insert") {
          if (interactive) {
            cmds.push(`echohl MoreMsg | echon 'INTERACTIVE ' | echohl None`);
          } else if (_matcher) {
            cmds.push(`echohl MoreMsg | echon '${_matcher.toUpperCase()} ' | echohl None`);
          }
          cmds.push(`echohl Special | echon '${indicator} ' | echohl None`);
          if (cusorIndex == input.length) {
            cmds.push(`echon '${input.replace(/'/g, "''")}'`);
            cmds.push(`echohl Cursor | echon ' ' | echohl None`);
          } else {
            let pre = input.slice(0, cusorIndex);
            if (pre)
              cmds.push(`echon '${pre.replace(/'/g, "''")}'`);
            cmds.push(`echohl Cursor | echon '${input[cusorIndex].replace(/'/, "''")}' | echohl None`);
            let post = input.slice(cusorIndex + 1);
            cmds.push(`echon '${post.replace(/'/g, "''")}'`);
          }
        } else {
          cmds.push(`echohl MoreMsg | echo "" | echohl None`);
        }
        cmds.push("redraw");
        let cmd = cmds.join("|");
        this.nvim.command(cmd, true);
      }
      moveLeft() {
        if (this.cusorIndex == 0)
          return;
        this.cusorIndex = this.cusorIndex - 1;
        this.drawPrompt();
      }
      moveRight() {
        if (this.cusorIndex == this._input.length)
          return;
        this.cusorIndex = this.cusorIndex + 1;
        this.drawPrompt();
      }
      moveToEnd() {
        if (this.cusorIndex == this._input.length)
          return;
        this.cusorIndex = this._input.length;
        this.drawPrompt();
      }
      moveToStart() {
        if (this.cusorIndex == 0)
          return;
        this.cusorIndex = 0;
        this.drawPrompt();
      }
      onBackspace() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        this.cusorIndex = cusorIndex - 1;
        this._input = `${pre.slice(0, pre.length - 1)}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeNext() {
        let { cusorIndex, input } = this;
        if (cusorIndex == input.length - 1)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex + 1);
        this._input = `${pre}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeWord() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        let remain = pre.replace(/[\w$]+([^\w$]+)?$/, "");
        this.cusorIndex = cusorIndex - (pre.length - remain.length);
        this._input = `${remain}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeTail() {
        let { cusorIndex, input } = this;
        if (cusorIndex == input.length)
          return;
        let pre = input.slice(0, cusorIndex);
        this._input = pre;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeAhead() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let post = input.slice(cusorIndex);
        this.cusorIndex = 0;
        this._input = post;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      async acceptCharacter(ch) {
        if (this.requestInput) {
          this.requestInput = false;
          if (/^[0-9a-z"%#*+/:\-.]$/.test(ch)) {
            let text = await this.nvim.call("getreg", ch);
            text = text.replace(/\n/g, " ");
            this.addText(text);
          }
        } else {
          this.addText(ch);
        }
      }
      insertRegister() {
        this.requestInput = true;
      }
      async paste() {
        let text = await this.nvim.eval("@*");
        text = text.replace(/\n/g, "");
        if (!text)
          return;
        this.addText(text);
      }
      async eval(expression) {
        let text = await this.nvim.call("eval", [expression]);
        text = text.replace(/\n/g, "");
        this.addText(text);
      }
      addText(text) {
        let { cusorIndex, input } = this;
        this.cusorIndex = cusorIndex + text.length;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        this._input = `${pre}${text}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
    };
  }
});

// src/util/fuzzy.ts
function getCharCodes(str) {
  let res = [];
  for (let i = 0, l = str.length; i < l; i++) {
    res.push(str.charCodeAt(i));
  }
  return res;
}
function wordChar(ch) {
  return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
}
function caseMatch(input, code) {
  if (input == code)
    return true;
  if (input >= 97 && input <= 122 && code + 32 === input)
    return true;
  return false;
}
function fuzzyChar(a, b) {
  let ca = a.charCodeAt(0);
  let cb = b.charCodeAt(0);
  if (ca === cb)
    return true;
  if (ca >= 97 && ca <= 122 && cb + 32 === ca)
    return true;
  return false;
}
function fuzzyMatch(needle, text) {
  let totalCount = needle.length;
  if (needle.length > text.length)
    return false;
  let i = 0;
  for (let j = 0; j < text.length; j++) {
    if (i === totalCount)
      break;
    let code = text.charCodeAt(j);
    let m = needle[i];
    if (code === m) {
      i = i + 1;
      continue;
    }
    if (m >= 97 && m <= 122 && code + 32 === m) {
      i = i + 1;
      continue;
    }
  }
  return i === totalCount;
}
var init_fuzzy = __esm({
  "src/util/fuzzy.ts"() {
  }
});

// src/list/history.ts
var logger57, InputHistory;
var init_history = __esm({
  "src/list/history.ts"() {
    init_fuzzy();
    init_workspace();
    logger57 = require_logger2()("list-history");
    InputHistory = class {
      constructor(prompt, name2) {
        this.prompt = prompt;
        this.name = name2;
        this.index = -1;
        this.loaded = [];
        this.current = [];
        this.db = workspace_default.createDatabase(`list-${name2}-history`);
        this.key = Buffer.from(workspace_default.cwd).toString("base64");
      }
      filter() {
        let { input } = this.prompt;
        if (input == this.curr)
          return;
        this.historyInput = "";
        let codes = getCharCodes(input);
        this.current = this.loaded.filter((s) => fuzzyMatch(codes, s));
        this.index = -1;
      }
      get curr() {
        return this.index == -1 ? null : this.current[this.index];
      }
      load(input) {
        let { db } = this;
        input = input || "";
        let arr = db.fetch(this.key);
        if (!arr || !Array.isArray(arr)) {
          this.loaded = [];
        } else {
          this.loaded = arr;
        }
        this.index = -1;
        this.current = this.loaded.filter((s) => s.startsWith(input));
      }
      add() {
        let { loaded, db, prompt } = this;
        let { input } = prompt;
        if (!input || input.length < 2 || input == this.historyInput)
          return;
        let idx = loaded.indexOf(input);
        if (idx != -1)
          loaded.splice(idx, 1);
        loaded.push(input);
        if (loaded.length > 200) {
          loaded = loaded.slice(-200);
        }
        db.push(this.key, loaded);
      }
      previous() {
        let { current, index } = this;
        if (!current || !current.length)
          return;
        if (index <= 0) {
          this.index = current.length - 1;
        } else {
          this.index = index - 1;
        }
        this.historyInput = this.prompt.input = current[this.index] || "";
      }
      next() {
        let { current, index } = this;
        if (!current || !current.length)
          return;
        if (index == current.length - 1) {
          this.index = 0;
        } else {
          this.index = index + 1;
        }
        this.historyInput = this.prompt.input = current[this.index] || "";
      }
    };
  }
});

// src/list/ui.ts
var import_debounce5, import_vscode_languageserver_protocol65, logger58, ListUI;
var init_ui = __esm({
  "src/list/ui.ts"() {
    import_debounce5 = __toModule(require_debounce());
    import_vscode_languageserver_protocol65 = __toModule(require_main2());
    init_events();
    init_util();
    init_workspace();
    logger58 = require_logger2()("list-ui");
    ListUI = class {
      constructor(nvim, name2, listOptions, config) {
        this.nvim = nvim;
        this.name = name2;
        this.listOptions = listOptions;
        this.config = config;
        this.newTab = false;
        this.currIndex = 0;
        this.items = [];
        this.disposables = [];
        this.selected = new Set();
        this._onDidChangeLine = new import_vscode_languageserver_protocol65.Emitter();
        this._onDidOpen = new import_vscode_languageserver_protocol65.Emitter();
        this._onDidClose = new import_vscode_languageserver_protocol65.Emitter();
        this._onDidLineChange = new import_vscode_languageserver_protocol65.Emitter();
        this._onDoubleClick = new import_vscode_languageserver_protocol65.Emitter();
        this.onDidChangeLine = this._onDidChangeLine.event;
        this.onDidLineChange = this._onDidLineChange.event;
        this.onDidOpen = this._onDidOpen.event;
        this.onDidClose = this._onDidClose.event;
        this.onDidDoubleClick = this._onDoubleClick.event;
        this.signOffset = config.get("signOffset");
        this.matchHighlightGroup = config.get("matchHighlightGroup", "Search");
        this.newTab = listOptions.position == "tab";
        events_default.on("BufWinLeave", async (bufnr) => {
          if (bufnr != this.bufnr || this.window == null)
            return;
          this.window = null;
          this._onDidClose.fire(bufnr);
        }, null, this.disposables);
        events_default.on("CursorMoved", async (bufnr, cursor) => {
          if (bufnr != this.bufnr)
            return;
          this.onLineChange(cursor[0] - 1);
        }, null, this.disposables);
        let debounced = (0, import_debounce5.default)(async (bufnr) => {
          if (bufnr != this.bufnr)
            return;
          let [winid, start, end] = await nvim.eval('[win_getid(),line("w0"),line("w$")]');
          if (end < 300 || winid != this.winid)
            return;
          nvim.pauseNotification();
          this.doHighlight(start - 1, end);
          nvim.command("redraw", true);
          void nvim.resumeNotification(false, true);
        }, 100);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        events_default.on("CursorMoved", debounced, null, this.disposables);
      }
      get bufnr() {
        var _a2;
        return (_a2 = this.buffer) == null ? void 0 : _a2.id;
      }
      get winid() {
        var _a2;
        return (_a2 = this.window) == null ? void 0 : _a2.id;
      }
      get limitLines() {
        return this.config.get("limitLines", 3e4);
      }
      onLineChange(index) {
        if (this.currIndex == index)
          return;
        this.currIndex = index;
        this._onDidChangeLine.fire(index);
      }
      set index(n) {
        if (n < 0 || n >= this.items.length)
          return;
        let { nvim } = this;
        nvim.pauseNotification();
        this.setCursor(n + 1, 0);
        nvim.command("redraw", true);
        void nvim.resumeNotification(false, true);
      }
      get index() {
        return this.currIndex;
      }
      getItem(index) {
        return this.items[index];
      }
      get item() {
        let { window: window2 } = this;
        if (!window2)
          return Promise.resolve(null);
        return window2.cursor.then((cursor) => {
          this.currIndex = cursor[0] - 1;
          return this.items[this.currIndex];
        });
      }
      async echoMessage(item) {
        let { items } = this;
        let idx = items.indexOf(item);
        let msg = `[${idx + 1}/${items.length}] ${item.label || ""}`;
        this.nvim.callTimer("coc#util#echo_lines", [[msg]], true);
      }
      async updateItem(item, index) {
        if (!this.bufnr)
          return;
        let obj = Object.assign({ resolved: true }, item);
        if (index < this.length) {
          this.items[index] = obj;
          let { nvim } = this;
          nvim.pauseNotification();
          this.buffer.setOption("modifiable", true, true);
          nvim.call("setbufline", [this.bufnr, index + 1, obj.label], true);
          this.buffer.setOption("modifiable", false, true);
          await nvim.resumeNotification();
        }
      }
      async getItems() {
        if (this.length == 0 || !this.window)
          return [];
        let mode = await this.nvim.call("mode");
        if (mode == "v" || mode == "V") {
          let [start, end] = await this.getSelectedRange();
          let res = [];
          for (let i = start; i <= end; i++) {
            let item2 = this.items[i - 1];
            if (item2)
              res.push(item2);
          }
          return res;
        }
        let { selectedItems } = this;
        if (selectedItems.length)
          return selectedItems;
        let item = await this.item;
        return item == null ? [] : [item];
      }
      async onMouse(event) {
        let { nvim, window: window2 } = this;
        if (!window2)
          return;
        let [winid, lnum, col] = await nvim.eval(`[v:mouse_winid,v:mouse_lnum,v:mouse_col]`);
        if (event == "mouseDown") {
          this.mouseDown = { winid, lnum, col, current: winid == window2.id };
          return;
        }
        let current = winid == window2.id;
        if (current && event == "doubleClick") {
          this.setCursor(lnum, 0);
          this._onDoubleClick.fire();
        }
        if (current && event == "mouseDrag") {
          if (!this.mouseDown)
            return;
          await this.selectLines(this.mouseDown.lnum, lnum);
        } else if (current && event == "mouseUp") {
          if (!this.mouseDown)
            return;
          if (this.mouseDown.lnum == lnum) {
            this.setCursor(lnum, 0);
            nvim.command("redraw", true);
          } else {
            await this.selectLines(this.mouseDown.lnum, lnum);
          }
        } else if (!current && event == "mouseUp") {
          nvim.pauseNotification();
          nvim.call("win_gotoid", winid, true);
          nvim.call("cursor", [lnum, col], true);
          nvim.command("redraw", true);
          void nvim.resumeNotification(false, true);
        }
      }
      async resume() {
        var _a2;
        let { items, selected, nvim } = this;
        await this.drawItems(items, this.height, true);
        if (!selected.size)
          return;
        nvim.pauseNotification();
        for (let lnum of selected) {
          (_a2 = this.buffer) == null ? void 0 : _a2.placeSign({ lnum, id: this.signOffset + lnum, name: "CocSelected", group: "coc-list" });
        }
        nvim.command("redraw", true);
        void nvim.resumeNotification(false, true);
      }
      async toggleSelection() {
        let { nvim } = this;
        await nvim.call("win_gotoid", [this.winid]);
        let lnum = await nvim.call("line", ".");
        let mode = await nvim.call("mode");
        if (mode == "v" || mode == "V") {
          let [start, end] = await this.getSelectedRange();
          let reverse = start > end;
          if (reverse)
            [start, end] = [end, start];
          for (let i = start; i <= end; i++) {
            this.toggleLine(i);
          }
          this.setCursor(end, 0);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
          return;
        }
        nvim.pauseNotification();
        this.toggleLine(lnum);
        this.setCursor(lnum + 1, 0);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      toggleLine(lnum) {
        let { selected, buffer, signOffset: signOffset2 } = this;
        let exists = selected.has(lnum);
        if (!exists) {
          selected.add(lnum);
          buffer.placeSign({ lnum, id: signOffset2 + lnum, name: "CocSelected", group: "coc-list" });
        } else {
          selected.delete(lnum);
          buffer.unplaceSign({ id: signOffset2 + lnum, group: "coc-list" });
        }
      }
      async selectLines(start, end) {
        let { nvim, signOffset: signOffset2, buffer, length } = this;
        this.clearSelection();
        let { selected } = this;
        nvim.pauseNotification();
        let reverse = start > end;
        if (reverse)
          [start, end] = [end, start];
        for (let i = start; i <= end; i++) {
          if (i > length)
            break;
          selected.add(i);
          buffer.placeSign({ lnum: i, id: signOffset2 + i, name: "CocSelected", group: "coc-list" });
        }
        this.setCursor(end, 0);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      async selectAll() {
        let { length } = this;
        if (length == 0)
          return;
        await this.selectLines(1, length);
      }
      clearSelection() {
        let { selected, signOffset: signOffset2, buffer } = this;
        if (selected.size > 0) {
          let signIds = [];
          for (let lnum of selected) {
            signIds.push(signOffset2 + lnum);
          }
          buffer == null ? void 0 : buffer.unplaceSign({ group: "coc-list" });
          this.selected.clear();
        }
      }
      get ready() {
        if (this.window)
          return Promise.resolve();
        return new Promise((resolve3) => {
          let disposable = this.onDidLineChange(() => {
            disposable.dispose();
            resolve3();
          });
        });
      }
      async drawItems(items, height, reload = false) {
        const { nvim, name: name2, listOptions } = this;
        this.items = items.length > this.limitLines ? items.slice(0, this.limitLines) : items;
        if (!this.window) {
          let { position, numberSelect } = listOptions;
          let [bufnr, winid] = await nvim.call("coc#list#create", [position, height, name2, numberSelect]);
          this.height = height;
          this.buffer = nvim.createBuffer(bufnr);
          let win = this.window = nvim.createWindow(winid);
          let statusSegments = this.config.get("statusLineSegments");
          if (statusSegments)
            win.setOption("statusline", statusSegments.join(" "), true);
          this._onDidOpen.fire(this.bufnr);
        }
        const lines = this.items.map((item) => item.label);
        let newIndex = reload ? this.currIndex : 0;
        this.setLines(lines, false, newIndex);
        this._onDidLineChange.fire(this.currIndex + 1);
      }
      appendItems(items) {
        let curr = this.items.length;
        if (curr >= this.limitLines)
          return;
        let max = this.limitLines - curr;
        let append = items.slice(0, max);
        this.items = this.items.concat(append);
        this.setLines(append.map((item) => item.label), curr > 0, this.currIndex);
      }
      setLines(lines, append = false, index) {
        let { nvim, buffer, window: window2 } = this;
        if (!buffer || !window2)
          return;
        nvim.pauseNotification();
        if (!append) {
          nvim.call("coc#compat#clear_matches", [window2.id], true);
          if (!lines.length) {
            lines = ["No results, press ? on normal mode to get help."];
            nvim.call("coc#compat#matchaddpos", ["Comment", [[1]], 99, window2.id], true);
          }
        }
        buffer.setOption("modifiable", true, true);
        void buffer.setLines(lines, { start: append ? -1 : 0, end: -1, strictIndexing: false }, true);
        buffer.setOption("modifiable", false, true);
        if (!append && index == 0) {
          this.doHighlight(0, 299);
        } else {
          let height = this.newTab ? workspace_default.env.lines : this.height;
          this.doHighlight(Math.max(0, index - height), Math.min(index + height + 1, this.length - 1));
        }
        if (!append) {
          this.currIndex = index;
          window2.setCursor([index + 1, 0], true);
        }
        nvim.command("redraws", true);
        void nvim.resumeNotification(false, true);
      }
      restoreWindow() {
        if (this.newTab)
          return;
        let { winid, height } = this;
        if (winid && height) {
          this.nvim.call("coc#list#restore", [winid, height], true);
        }
      }
      get length() {
        return this.items.length;
      }
      get selectedItems() {
        let { selected, items } = this;
        let res = [];
        for (let i of selected) {
          if (items[i - 1])
            res.push(items[i - 1]);
        }
        return res;
      }
      doHighlight(start, end) {
        let { items } = this;
        let groups = [];
        for (let i = start; i <= Math.min(end, items.length - 1); i++) {
          let { ansiHighlights, highlights } = items[i];
          if (ansiHighlights) {
            for (let hi of ansiHighlights) {
              let { span, hlGroup } = hi;
              groups.push({ hlGroup, priority: 9, pos: [i + 1, span[0] + 1, span[1] - span[0]] });
            }
          }
          if (highlights && Array.isArray(highlights.spans)) {
            let { spans, hlGroup } = highlights;
            for (let span of spans) {
              groups.push({ hlGroup: hlGroup || this.matchHighlightGroup, priority: 11, pos: [i + 1, span[0] + 1, span[1] - span[0]] });
            }
          }
        }
        this.nvim.call("coc#compat#matchaddgroups", [this.window.id, groups], true);
      }
      setCursor(lnum, col) {
        var _a2;
        let { items } = this;
        let max = items.length == 0 ? 1 : items.length;
        if (lnum > max)
          return;
        this.onLineChange(lnum - 1);
        (_a2 = this.window) == null ? void 0 : _a2.setCursor([lnum, col], true);
      }
      async getSelectedRange() {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.eval('feedkeys("\\<esc>", "in")');
        let [, start] = await nvim.call("getpos", "'<");
        let [, end] = await nvim.call("getpos", "'>");
        this.nvim.call("coc#prompt#start_prompt", ["list"], true);
        return [start, end];
      }
      reset() {
        if (this.window) {
          this.window = null;
          this.buffer = null;
        }
      }
      dispose() {
        disposeAll(this.disposables);
        this.nvim.call("coc#window#close", [this.winid || -1], true);
        this.window = null;
        this.buffer = null;
        this.items = [];
        this._onDidChangeLine.dispose();
        this._onDidOpen.dispose();
        this._onDidClose.dispose();
        this._onDidLineChange.dispose();
        this._onDoubleClick.dispose();
      }
    };
  }
});

// src/util/score.ts
function getMatchResult(text, query, filename = "") {
  if (!text)
    return { score: 0 };
  if (!query)
    return { score: 1 };
  let matches = [];
  let codes = getCharCodes(query);
  let filenameIdx = filename ? text.indexOf(filename) : -1;
  let matchBase = filenameIdx != -1 && fuzzyMatch(codes, filename);
  let score5 = 0;
  let c = query[0];
  let idx = 0;
  if (matchBase) {
    if (filename.startsWith(c)) {
      score5 = score5 + 2;
      idx = filenameIdx + 1;
      matches.push(filenameIdx);
    } else if (filename[0].toLowerCase() == c) {
      score5 = score5 + 1.5;
      idx = filenameIdx + 1;
      matches.push(filenameIdx);
    } else {
      for (let i = 1; i < filename.length; i++) {
        if (fuzzyChar(c, filename[i])) {
          score5 = score5 + 1;
          idx = filenameIdx + i + 1;
          matches.push(filenameIdx + i);
          break;
        }
      }
    }
  } else if (text.startsWith(c)) {
    score5 = score5 + 1;
    matches.push(0);
    idx = 1;
  } else {
    for (let i = 1; i < text.length; i++) {
      let pre = text[i - 1];
      if (pre == import_path19.sep && text[i] == c) {
        score5 = score5 + 1;
        matches.push(i);
        idx = i + 1;
        break;
      }
    }
    if (idx == 0) {
      for (let i = 0; i < text.length; i++) {
        if (fuzzyChar(c, text[i])) {
          score5 = score5 + 0.5;
          matches.push(i);
          idx = i + 1;
          break;
        }
      }
    }
  }
  if (idx == 0)
    return { score: 0 };
  if (codes.length == 1)
    return { score: score5, matches };
  return nextResult(codes.slice(1), text, idx, { score: score5, matches });
}
function nextResult(codes, text, idx, curr) {
  let { score: score5, matches } = curr;
  let results = [];
  let c = codes[0];
  let remain = codes.slice(1);
  let result;
  function getRemianResult(index) {
    if (!result)
      return;
    if (remain.length == 0) {
      results.push(result);
    } else if (result) {
      let res = nextResult(remain, text, index, result);
      if (res)
        results.push(res);
    }
  }
  let followed = idx < text.length ? text[idx].charCodeAt(0) : null;
  if (!followed)
    return null;
  if (followed == c) {
    result = { score: score5 + 1, matches: matches.concat([idx]) };
    getRemianResult(idx + 1);
  } else if (caseMatch(c, followed)) {
    result = { score: score5 + 0.5, matches: matches.concat([idx]) };
    getRemianResult(idx + 1);
  }
  if (idx + 1 < text.length) {
    for (let i = idx + 1; i < text.length; i++) {
      let ch = text[i].charCodeAt(0);
      if (text[i - 1] == import_path19.sep && caseMatch(c, ch)) {
        let add = c == ch ? 1 : 0.5;
        result = { score: score5 + add, matches: matches.concat([i]) };
        getRemianResult(i + 1);
        break;
      }
    }
    for (let i = idx + 1; i < text.length; i++) {
      let ch = text[i].charCodeAt(0);
      if (caseMatch(c, ch)) {
        let add = c == ch ? 0.5 : 0.2;
        result = { score: score5 + add, matches: matches.concat([i]) };
        getRemianResult(i + 1);
        break;
      }
    }
  }
  return results.length ? bestResult(results) : null;
}
function bestResult(results) {
  let res = results[0];
  for (let i = 1; i < results.length; i++) {
    if (results[i].score > res.score) {
      res = results[i];
    }
  }
  return res;
}
var import_path19;
var init_score = __esm({
  "src/util/score.ts"() {
    import_path19 = __toModule(require("path"));
    init_fuzzy();
  }
});

// src/list/worker.ts
function getFilterLabel(item) {
  return item.filterText != null ? patchLine(item.filterText, item.label) : item.label;
}
function parseInput(input) {
  let res = [];
  let startIdx = 0;
  let currIdx = 0;
  let prev = "";
  for (; currIdx < input.length; currIdx++) {
    let ch = input[currIdx];
    if (ch.charCodeAt(0) === 32) {
      if (prev && prev != "\\" && startIdx != currIdx) {
        res.push(input.slice(startIdx, currIdx));
        startIdx = currIdx + 1;
      }
    } else {
    }
    prev = ch;
  }
  if (startIdx != input.length) {
    res.push(input.slice(startIdx, input.length));
  }
  return res.map((s) => s.replace(/\\\s/g, " ").trim()).filter((s) => s.length > 0);
}
var import_vscode_languageserver_protocol66, logger59, controlCode, Worker;
var init_worker = __esm({
  "src/list/worker.ts"() {
    import_vscode_languageserver_protocol66 = __toModule(require_main2());
    init_ansiparse();
    init_diff();
    init_fzy();
    init_score();
    init_string();
    init_window();
    init_workspace();
    logger59 = require_logger2()("list-worker");
    controlCode = "";
    Worker = class {
      constructor(nvim, list2, prompt, listOptions, config) {
        this.nvim = nvim;
        this.list = list2;
        this.prompt = prompt;
        this.listOptions = listOptions;
        this.config = config;
        this._loading = false;
        this.totalItems = [];
        this._onDidChangeItems = new import_vscode_languageserver_protocol66.Emitter();
        this._onDidChangeLoading = new import_vscode_languageserver_protocol66.Emitter();
        this.onDidChangeItems = this._onDidChangeItems.event;
        this.onDidChangeLoading = this._onDidChangeLoading.event;
      }
      set loading(loading) {
        if (this._loading == loading)
          return;
        this._loading = loading;
        this._onDidChangeLoading.fire(loading);
      }
      get isLoading() {
        return this._loading;
      }
      async loadItems(context, reload = false) {
        let { list: list2, listOptions } = this;
        this.loading = true;
        let { interactive } = listOptions;
        this.tokenSource = new import_vscode_languageserver_protocol66.CancellationTokenSource();
        let token = this.tokenSource.token;
        let items = await list2.loadItems(context, token);
        if (token.isCancellationRequested)
          return;
        if (!items || Array.isArray(items)) {
          this.tokenSource = null;
          items = items || [];
          this.totalItems = items.map((item) => {
            item.label = this.fixLabel(item.label);
            this.parseListItemAnsi(item);
            return item;
          });
          this.loading = false;
          let filtered;
          if (!interactive) {
            filtered = this.filterItems(items);
          } else {
            filtered = this.convertToHighlightItems(items);
          }
          this._onDidChangeItems.fire({
            items: filtered,
            reload,
            finished: true
          });
        } else {
          let task = items;
          let totalItems = this.totalItems = [];
          let count = 0;
          let currInput = context.input;
          let timer;
          let lastTs;
          let _onData = (finished) => {
            lastTs = Date.now();
            if (count >= totalItems.length)
              return;
            let inputChanged = this.input != currInput;
            if (interactive && inputChanged)
              return;
            if (count == 0 || inputChanged) {
              currInput = this.input;
              count = totalItems.length;
              let items2;
              if (interactive) {
                items2 = this.convertToHighlightItems(totalItems);
              } else {
                items2 = this.filterItems(totalItems);
              }
              this._onDidChangeItems.fire({ items: items2, reload, append: false, finished });
            } else {
              let remain = totalItems.slice(count);
              count = totalItems.length;
              let items2;
              if (!interactive) {
                items2 = this.filterItems(remain);
              } else {
                items2 = this.convertToHighlightItems(remain);
              }
              this._onDidChangeItems.fire({ items: items2, append: true, finished });
            }
          };
          task.on("data", (item) => {
            if (timer)
              clearTimeout(timer);
            if (token.isCancellationRequested)
              return;
            if (interactive && this.input != currInput)
              return;
            item.label = this.fixLabel(item.label);
            this.parseListItemAnsi(item);
            totalItems.push(item);
            if (!lastTs && totalItems.length == 500 || Date.now() - lastTs > 200) {
              _onData();
            } else {
              timer = setTimeout(() => _onData(), 50);
            }
          });
          let onEnd = () => {
            if (task == null)
              return;
            this.tokenSource = null;
            task = null;
            this.loading = false;
            disposable.dispose();
            if (timer)
              clearTimeout(timer);
            if (totalItems.length == 0) {
              this._onDidChangeItems.fire({ items: [], finished: true });
            } else {
              _onData(true);
            }
          };
          let disposable = token.onCancellationRequested(() => {
            if (task) {
              task.dispose();
              onEnd();
            }
          });
          task.on("error", async (error) => {
            if (task == null)
              return;
            task = null;
            this.tokenSource = null;
            this.loading = false;
            disposable.dispose();
            if (timer)
              clearTimeout(timer);
            this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
            window_default.showMessage(`Task error: ${error.toString()}`, "error");
            logger59.error(error);
          });
          task.on("end", onEnd);
        }
      }
      drawItems() {
        let { totalItems } = this;
        let items;
        items = this.filterItems(totalItems);
        this._onDidChangeItems.fire({ items, finished: true });
      }
      stop() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
        this.loading = false;
      }
      get length() {
        return this.totalItems.length;
      }
      get input() {
        return this.prompt.input;
      }
      convertToHighlightItems(items) {
        let { input } = this;
        if (!input)
          return [];
        return items.map((item) => {
          let filterLabel = getFilterLabel(item);
          let res = getMatchResult(filterLabel, input);
          if (!(res == null ? void 0 : res.score))
            return item;
          let highlights = this.getHighlights(filterLabel, res.matches);
          return Object.assign({}, item, { highlights });
        });
      }
      filterItems(items) {
        let { input } = this;
        let { sort, matcher, ignorecase } = this.listOptions;
        let inputs = this.config.extendedSearchMode ? parseInput(input) : [input];
        if (input.length == 0 || inputs.length == 0)
          return items;
        if (matcher == "strict") {
          let filtered2 = [];
          for (let item of items) {
            let spans = [];
            let filterLabel = getFilterLabel(item);
            let match = true;
            for (let input2 of inputs) {
              let idx2 = ignorecase ? filterLabel.toLowerCase().indexOf(input2.toLowerCase()) : filterLabel.indexOf(input2);
              if (idx2 == -1) {
                match = false;
                break;
              }
              spans.push([byteIndex(filterLabel, idx2), byteIndex(filterLabel, idx2 + byteLength(input2))]);
            }
            if (match) {
              filtered2.push(Object.assign({}, item, {
                highlights: { spans }
              }));
            }
          }
          return filtered2;
        }
        if (matcher == "regex") {
          let filtered2 = [];
          let flags = ignorecase ? "iu" : "u";
          let regexes = inputs.reduce((p, c) => {
            try {
              let regex = new RegExp(c, flags);
              p.push(regex);
            } catch (e) {
            }
            return p;
          }, []);
          for (let item of items) {
            let spans = [];
            let filterLabel = getFilterLabel(item);
            let match = true;
            for (let regex of regexes) {
              let ms = filterLabel.match(regex);
              if (ms == null) {
                match = false;
                break;
              }
              spans.push([byteIndex(filterLabel, ms.index), byteIndex(filterLabel, ms.index + byteLength(ms[0]))]);
            }
            if (match) {
              filtered2.push(Object.assign({}, item, {
                highlights: { spans }
              }));
            }
          }
          return filtered2;
        }
        let filtered = [];
        let idx = 0;
        for (let item of items) {
          let filterText = item.filterText || item.label;
          let matchScore2 = 0;
          let matches = [];
          let filterLabel = getFilterLabel(item);
          let match = true;
          for (let input2 of inputs) {
            if (!hasMatch(input2, filterText)) {
              match = false;
              break;
            }
            matches.push(...positions(input2, filterLabel));
            if (sort)
              matchScore2 += score2(input2, filterText);
          }
          if (!match)
            continue;
          let obj = Object.assign({}, item, {
            sortText: typeof item.sortText === "string" ? item.sortText : String.fromCharCode(idx),
            score: matchScore2,
            highlights: this.getHighlights(filterLabel, matches)
          });
          filtered.push(obj);
          idx = idx + 1;
        }
        if (sort && filtered.length) {
          filtered.sort((a, b) => {
            if (a.score != b.score)
              return b.score - a.score;
            if (a.sortText > b.sortText)
              return 1;
            return -1;
          });
        }
        return filtered;
      }
      getHighlights(text, matches) {
        let spans = [];
        if (matches && matches.length) {
          let start = matches.shift();
          let next = matches.shift();
          let curr = start;
          while (next) {
            if (next == curr + 1) {
              curr = next;
              next = matches.shift();
              continue;
            }
            spans.push([byteIndex(text, start), byteIndex(text, curr) + 1]);
            start = next;
            curr = start;
            next = matches.shift();
          }
          spans.push([byteIndex(text, start), byteIndex(text, curr) + 1]);
        }
        return { spans };
      }
      parseListItemAnsi(item) {
        let { label } = item;
        if (item.ansiHighlights || !label.includes(controlCode))
          return;
        let { line, highlights } = parseAnsiHighlights(label);
        item.label = line;
        item.ansiHighlights = highlights;
      }
      fixLabel(label) {
        let { columns } = workspace_default.env;
        label = label.split("\n").join(" ");
        return label.slice(0, columns * 2);
      }
      dispose() {
        this.stop();
      }
    };
  }
});

// src/list/session.ts
var import_debounce6, frames2, logger60, ListSession;
var init_session = __esm({
  "src/list/session.ts"() {
    import_debounce6 = __toModule(require_debounce());
    init_mutex();
    init_extensions2();
    init_highligher();
    init_util();
    init_workspace();
    init_window();
    init_history();
    init_ui();
    init_worker();
    frames2 = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
    logger60 = require_logger2()("list-session");
    ListSession = class {
      constructor(nvim, prompt, list2, listOptions, listArgs = [], config) {
        this.nvim = nvim;
        this.prompt = prompt;
        this.list = list2;
        this.listOptions = listOptions;
        this.listArgs = listArgs;
        this.config = config;
        this.loadingFrame = "";
        this.hidden = false;
        this.disposables = [];
        this.mutex = new Mutex();
        this.args = [];
        this.ui = new ListUI(nvim, list2.name, listOptions, config);
        this.history = new InputHistory(prompt, list2.name);
        this.worker = new Worker(nvim, list2, prompt, listOptions, {
          interactiveDebounceTime: config.get("interactiveDebounceTime", 100),
          extendedSearchMode: config.get("extendedSearchMode", true)
        });
        this.interactiveDebounceTime = config.get("interactiveDebounceTime", 100);
        let debouncedChangeLine = (0, import_debounce6.default)(async () => {
          let [previewing, currwin, lnum] = await nvim.eval('[coc#list#has_preview(),win_getid(),line(".")]');
          if (previewing && currwin == this.winid) {
            await this.doPreview(lnum - 1);
          }
        }, 50);
        this.disposables.push({
          dispose: () => {
            debouncedChangeLine.clear();
          }
        });
        this.ui.onDidChangeLine(debouncedChangeLine, null, this.disposables);
        this.ui.onDidChangeLine(this.resolveItem, this, this.disposables);
        this.ui.onDidLineChange(this.resolveItem, this, this.disposables);
        let debounced = (0, import_debounce6.default)(async () => {
          let { autoPreview } = this.listOptions;
          if (!autoPreview) {
            let [previewing, mode] = await nvim.eval("[coc#list#has_preview(),mode()]");
            if (!previewing || mode != "n")
              return;
          }
          await this.doAction("preview");
        }, 50);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        this.ui.onDidLineChange(debounced, null, this.disposables);
        this.ui.onDidLineChange(() => {
          this.updateStatus();
        }, null, this.disposables);
        this.ui.onDidOpen(async () => {
          if (typeof this.list.doHighlight == "function") {
            this.list.doHighlight();
          }
          if (this.listOptions.first) {
            await this.doAction();
          }
        }, null, this.disposables);
        this.ui.onDidClose(async () => {
          await this.hide();
        }, null, this.disposables);
        this.ui.onDidDoubleClick(async () => {
          await this.doAction();
        }, null, this.disposables);
        this.worker.onDidChangeItems(async ({ items, reload, append, finished }) => {
          let release = await this.mutex.acquire();
          if (!this.hidden) {
            try {
              if (append) {
                this.ui.appendItems(items);
              } else {
                let height = this.config.get("height", 10);
                if (finished && !listOptions.interactive && listOptions.input.length == 0) {
                  height = Math.min(items.length, height);
                }
                await this.ui.drawItems(items, Math.max(1, height), reload);
              }
            } catch (e) {
              nvim.echoError(e);
            }
          }
          release();
        }, null, this.disposables);
        this.worker.onDidChangeLoading((loading) => {
          if (this.hidden)
            return;
          if (loading) {
            this.interval = setInterval(() => {
              let idx = Math.floor(new Date().getMilliseconds() / 100);
              this.loadingFrame = frames2[idx];
              this.updateStatus();
            }, 100);
          } else {
            if (this.interval) {
              this.loadingFrame = "";
              clearInterval(this.interval);
              this.interval = null;
            }
            this.updateStatus();
          }
        }, null, this.disposables);
      }
      async start(args) {
        this.args = args;
        this.cwd = workspace_default.cwd;
        this.hidden = false;
        let { listOptions, listArgs } = this;
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.listArgs = listArgs;
        this.history.load(listOptions.input || "");
        this.window = this.nvim.createWindow(res[0]);
        this.buffer = this.nvim.createBuffer(res[1]);
        this.savedHeight = res[2];
        await this.worker.loadItems(this.context);
      }
      async reloadItems() {
        if (!this.window)
          return;
        let bufnr = await this.nvim.call("winbufnr", [this.window.id]);
        if (bufnr == -1)
          return;
        this.buffer = this.nvim.createBuffer(bufnr);
        await this.worker.loadItems(this.context, true);
      }
      async call(fname) {
        var _a2, _b;
        await this.nvim.call("coc#prompt#stop_prompt", ["list"]);
        let targets = await this.ui.getItems();
        let context = {
          name: this.name,
          args: this.listArgs,
          input: this.prompt.input,
          winid: (_a2 = this.window) == null ? void 0 : _a2.id,
          bufnr: (_b = this.buffer) == null ? void 0 : _b.id,
          targets
        };
        let res = await this.nvim.call(fname, [context]);
        this.prompt.start();
        return res;
      }
      async chooseAction() {
        let { nvim } = this;
        let { actions, defaultAction } = this.list;
        let names = actions.map((o) => o.name);
        let idx = names.indexOf(defaultAction);
        if (idx != -1) {
          names.splice(idx, 1);
          names.unshift(defaultAction);
        }
        let shortcuts = new Set();
        let choices = [];
        let invalids = [];
        for (let name2 of names) {
          let i = 0;
          for (let ch of name2) {
            if (!shortcuts.has(ch)) {
              shortcuts.add(ch);
              choices.push(`${name2.slice(0, i)}&${name2.slice(i)}`);
              break;
            }
            i++;
          }
          if (i == name2.length) {
            invalids.push(name2);
          }
        }
        if (invalids.length) {
          names = names.filter((s) => !invalids.includes(s));
        }
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        let n = await nvim.call("confirm", ["Choose action:", choices.join("\n")]);
        await wait(10);
        this.prompt.start();
        if (n)
          await this.doAction(names[n - 1]);
        if (invalids.length) {
          nvim.echoError(`Can't create shortcut for actions: ${invalids.join(",")} of "${this.name}" list`);
        }
      }
      async doAction(name2) {
        let { list: list2 } = this;
        name2 = name2 || list2.defaultAction;
        let action = list2.actions.find((o) => o.name == name2);
        if (!action) {
          window_default.showMessage(`Action ${name2} not found`, "error");
          return;
        }
        let items;
        if (name2 == "preview") {
          let item = await this.ui.item;
          items = item ? [item] : [];
        } else {
          items = await this.ui.getItems();
        }
        if (items.length)
          await this.doItemAction(items, action);
      }
      async doPreview(index) {
        let item = this.ui.getItem(index);
        let action = this.list.actions.find((o) => o.name == "preview");
        if (!item || !action)
          return;
        await this.doItemAction([item], action);
      }
      async first() {
        await this.doDefaultAction(0);
      }
      async last() {
        await this.doDefaultAction(this.ui.length - 1);
      }
      async previous() {
        await this.doDefaultAction(this.ui.index - 1);
      }
      async next() {
        await this.doDefaultAction(this.ui.index + 1);
      }
      async doDefaultAction(index) {
        let { ui } = this;
        let item = ui.getItem(index);
        if (!item)
          return;
        ui.index = index;
        await this.doItemAction([item], this.defaultAction);
        await ui.echoMessage(item);
      }
      get name() {
        return this.list.name;
      }
      get winid() {
        return this.ui.winid;
      }
      get length() {
        return this.ui.length;
      }
      get defaultAction() {
        let { defaultAction, actions } = this.list;
        let action = actions.find((o) => o.name == defaultAction);
        if (!action)
          throw new Error(`default action "${defaultAction}" not found`);
        return action;
      }
      async hide() {
        if (this.hidden)
          return;
        let { nvim, interval } = this;
        if (interval)
          clearInterval(interval);
        this.hidden = true;
        this.worker.stop();
        this.history.add();
        let { winid } = this.ui;
        this.ui.reset();
        if (this.window && winid) {
          await nvim.call("coc#list#hide", [this.window.id, this.savedHeight, winid]);
          if (workspace_default.isVim) {
            nvim.command("redraw", true);
            await wait(10);
          }
        }
        nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      toggleMode() {
        let mode = this.prompt.mode == "normal" ? "insert" : "normal";
        this.prompt.mode = mode;
        this.listOptions.mode = mode;
        this.updateStatus();
      }
      stop() {
        this.worker.stop();
      }
      async resolveItem() {
        let index = this.ui.index;
        let item = this.ui.getItem(index);
        if (!item || item.resolved)
          return;
        let { list: list2 } = this;
        if (typeof list2.resolveItem == "function") {
          let resolved = await Promise.resolve(list2.resolveItem(item));
          if (resolved && index == this.ui.index) {
            await this.ui.updateItem(resolved, index);
          }
        }
      }
      async showHelp() {
        await this.hide();
        let { list: list2, nvim } = this;
        if (!list2)
          return;
        nvim.pauseNotification();
        nvim.command(`tabe +setl\\ previewwindow [LIST HELP]`, true);
        nvim.command("setl nobuflisted noswapfile buftype=nofile bufhidden=wipe", true);
        await nvim.resumeNotification();
        let hasOptions = list2.options && list2.options.length;
        let buf = await nvim.buffer;
        let highligher = new Highlighter();
        highligher.addLine("NAME", "Label");
        highligher.addLine(`  ${list2.name} - ${list2.description || ""}
`);
        highligher.addLine("SYNOPSIS", "Label");
        highligher.addLine(`  :CocList [LIST OPTIONS] ${list2.name}${hasOptions ? " [ARGUMENTS]" : ""}
`);
        if (list2.detail) {
          highligher.addLine("DESCRIPTION", "Label");
          let lines = list2.detail.split("\n").map((s) => "  " + s);
          highligher.addLine(lines.join("\n") + "\n");
        }
        if (hasOptions) {
          highligher.addLine("ARGUMENTS", "Label");
          highligher.addLine("");
          for (let opt of list2.options) {
            highligher.addLine(opt.name, "Special");
            highligher.addLine(`  ${opt.description}`);
            highligher.addLine("");
          }
          highligher.addLine("");
        }
        let config = workspace_default.getConfiguration(`list.source.${list2.name}`);
        if (Object.keys(config).length) {
          highligher.addLine("CONFIGURATIONS", "Label");
          highligher.addLine("");
          let props = {};
          extensions_default.all.forEach((extension) => {
            let { packageJSON } = extension;
            let { contributes } = packageJSON;
            if (!contributes)
              return;
            let { configuration } = contributes;
            if (configuration) {
              let { properties } = configuration;
              if (properties) {
                for (let key of Object.keys(properties)) {
                  props[key] = properties[key];
                }
              }
            }
          });
          for (let key of Object.keys(config)) {
            let val = config[key];
            let name2 = `list.source.${list2.name}.${key}`;
            let description = props[name2] && props[name2].description ? props[name2].description : key;
            highligher.addLine(`  "${name2}"`, "MoreMsg");
            highligher.addText(` - ${description}, current value: `);
            highligher.addText(JSON.stringify(val), "Special");
          }
          highligher.addLine("");
        }
        highligher.addLine("ACTIONS", "Label");
        highligher.addLine(`  ${list2.actions.map((o) => o.name).join(", ")}`);
        highligher.addLine("");
        highligher.addLine(`see ':h coc-list-options' for available list options.`, "Comment");
        nvim.pauseNotification();
        highligher.render(buf, 0, -1);
        nvim.command("setl nomod", true);
        nvim.command("setl nomodifiable", true);
        nvim.command("normal! gg", true);
        nvim.command("nnoremap <buffer> q :bd!<CR>", true);
        await nvim.resumeNotification();
      }
      switchMatcher() {
        let { matcher, interactive } = this.listOptions;
        if (interactive)
          return;
        const list2 = ["fuzzy", "strict", "regex"];
        let idx = list2.indexOf(matcher) + 1;
        if (idx >= list2.length)
          idx = 0;
        this.listOptions.matcher = list2[idx];
        this.prompt.matcher = list2[idx];
        this.worker.drawItems();
      }
      updateStatus() {
        let { ui, list: list2, nvim } = this;
        if (!ui.winid)
          return;
        let buf = nvim.createBuffer(ui.bufnr);
        let status = {
          mode: this.prompt.mode.toUpperCase(),
          args: this.args.join(" "),
          name: list2.name,
          cwd: this.cwd,
          loading: this.loadingFrame,
          total: this.worker.length
        };
        nvim.pauseNotification();
        buf.setVar("list_status", status, true);
        nvim.command("redraws", true);
        nvim.resumeNotification(false, true).logError();
      }
      get context() {
        let { winid } = this.ui;
        return {
          options: this.listOptions,
          args: this.listArgs,
          input: this.prompt.input,
          cwd: workspace_default.cwd,
          window: this.window,
          buffer: this.buffer,
          listWindow: winid ? this.nvim.createWindow(winid) : void 0
        };
      }
      onMouseEvent(key) {
        switch (key) {
          case "<LeftMouse>":
            return this.ui.onMouse("mouseDown");
          case "<LeftDrag>":
            return this.ui.onMouse("mouseDrag");
          case "<LeftRelease>":
            return this.ui.onMouse("mouseUp");
          case "<2-LeftMouse>":
            return this.ui.onMouse("doubleClick");
        }
      }
      async doNumberSelect(ch) {
        if (!this.listOptions.numberSelect)
          return false;
        let code = ch.charCodeAt(0);
        if (code >= 48 && code <= 57) {
          let n = Number(ch);
          if (n == 0)
            n = 10;
          if (this.ui.length >= n) {
            this.nvim.pauseNotification();
            this.ui.setCursor(n, 0);
            await this.nvim.resumeNotification();
            await this.doAction();
            return true;
          }
        }
        return false;
      }
      jumpBack() {
        let { window: window2, nvim } = this;
        if (window2) {
          nvim.pauseNotification();
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          this.nvim.call("win_gotoid", [window2.id], true);
          nvim.resumeNotification(false, true).logError();
        }
      }
      async resume() {
        if (this.winid)
          await this.hide();
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.hidden = false;
        this.window = this.nvim.createWindow(res[0]);
        this.buffer = this.nvim.createBuffer(res[1]);
        this.savedHeight = res[2];
        this.prompt.start();
        await this.ui.resume();
        if (this.listOptions.autoPreview) {
          await this.doAction("preview");
        }
      }
      async doItemAction(items, action) {
        let { noQuit } = this.listOptions;
        let { nvim } = this;
        let persistAction = action.persist === true || action.name == "preview";
        let persist = this.winid && (persistAction || noQuit);
        try {
          if (persist) {
            if (!persistAction) {
              nvim.pauseNotification();
              nvim.call("coc#prompt#stop_prompt", ["list"], true);
              nvim.call("win_gotoid", [this.context.window.id], true);
              await nvim.resumeNotification();
            }
          } else {
            await this.hide();
          }
          if (action.multiple) {
            await Promise.resolve(action.execute(items, this.context));
          } else if (action.parallel) {
            await Promise.all(items.map((item) => Promise.resolve(action.execute(item, this.context))));
          } else {
            for (let item of items) {
              await Promise.resolve(action.execute(item, this.context));
            }
          }
          if (persist) {
            this.ui.restoreWindow();
          }
          if (action.reload && persist)
            await this.worker.loadItems(this.context, true);
        } catch (e) {
          window_default.showMessage(e.message, "error");
          logger60.error(`Error on action "${action.name}"`, e);
        }
      }
      onInputChange() {
        if (this.timer)
          clearTimeout(this.timer);
        let len = this.worker.length;
        this.listOptions.input = this.prompt.input;
        if (this.listOptions.interactive) {
          this.worker.stop();
          this.timer = setTimeout(async () => {
            await this.worker.loadItems(this.context);
          }, this.interactiveDebounceTime);
        } else if (len) {
          let wait2 = Math.max(Math.min(Math.floor(len / 200), 300), 50);
          this.timer = setTimeout(() => {
            this.worker.drawItems();
          }, wait2);
        }
      }
      dispose() {
        if (!this.hidden) {
          this.hidden = true;
          let { winid } = this.ui;
          this.ui.reset();
          if (this.window && winid) {
            this.nvim.call("coc#list#hide", [this.window.id, this.savedHeight, winid], true);
          }
        }
        if (this.interval) {
          clearInterval(this.interval);
        }
        if (this.timer) {
          clearTimeout(this.timer);
        }
        disposeAll(this.disposables);
        this.worker.dispose();
        this.ui.dispose();
      }
    };
  }
});

// src/list/commandTask.ts
var import_child_process5, import_events21, import_readline3, logger61, CommandTask;
var init_commandTask = __esm({
  "src/list/commandTask.ts"() {
    import_child_process5 = __toModule(require("child_process"));
    import_events21 = __toModule(require("events"));
    import_readline3 = __toModule(require("readline"));
    init_util();
    logger61 = require_logger2()("list-commandTask");
    CommandTask = class extends import_events21.EventEmitter {
      constructor(opt) {
        super();
        this.opt = opt;
        this.disposables = [];
        this.start();
      }
      start() {
        let { cmd, args, cwd, onLine } = this.opt;
        let proc = (0, import_child_process5.spawn)(cmd, args, { cwd, windowsHide: true });
        this.disposables.push({
          dispose: () => {
            proc.kill();
          }
        });
        proc.on("error", (e) => {
          this.emit("error", e.message);
        });
        proc.stderr.on("data", (chunk) => {
          logger61.error(`[${cmd} Error]`, chunk.toString("utf8"));
        });
        const rl = import_readline3.default.createInterface(proc.stdout);
        rl.on("line", (line) => {
          let res = onLine(line);
          if (res)
            this.emit("data", res);
        });
        rl.on("close", () => {
          this.emit("end");
        });
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/list/basic.ts
function getFiletype(filetype) {
  switch (filetype) {
    case "javascriptreact":
      return "javascript";
    case "typescriptreact":
      return "typescript";
    case "latex":
      return "tex";
    default:
      if (filetype.indexOf(".") !== -1)
        return filetype.split(".")[0];
      return filetype;
  }
}
var import_fs19, import_path20, import_readline4, import_vscode_languageserver_protocol67, logger62, BasicList;
var init_basic = __esm({
  "src/list/basic.ts"() {
    import_fs19 = __toModule(require("fs"));
    import_path20 = __toModule(require("path"));
    import_readline4 = __toModule(require("readline"));
    import_vscode_languageserver_protocol67 = __toModule(require_main2());
    init_esm2();
    init_util();
    init_fs();
    init_position();
    init_workspace();
    init_commandTask();
    init_configuration4();
    logger62 = require_logger2()("list-basic");
    BasicList = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.defaultAction = "open";
        this.actions = [];
        this.options = [];
        this.disposables = [];
        this.config = new ListConfiguration();
      }
      get alignColumns() {
        return this.config.get("alignColumns", false);
      }
      get hlGroup() {
        return this.config.get("previewHighlightGroup", "Search");
      }
      get previewHeight() {
        return this.config.get("maxPreviewHeight", 12);
      }
      get splitRight() {
        return this.config.get("previewSplitRight", false);
      }
      get toplineStyle() {
        return this.config.get("previewToplineStyle", "offset");
      }
      get toplineOffset() {
        return this.config.get("previewToplineOffset", 3);
      }
      parseArguments(args) {
        if (!this.optionMap) {
          this.optionMap = new Map();
          for (let opt of this.options) {
            let parts = opt.name.split(/,\s*/g).map((s) => s.replace(/\s+.*/g, ""));
            let name2 = opt.key ? opt.key : parts[parts.length - 1].replace(/^-/, "");
            for (let p of parts) {
              this.optionMap.set(p, { name: name2, hasValue: opt.hasValue });
            }
          }
        }
        let res = {};
        for (let i = 0; i < args.length; i++) {
          let arg = args[i];
          let def = this.optionMap.get(arg);
          if (!def)
            continue;
          let value = true;
          if (def.hasValue) {
            value = args[i + 1] || "";
            i = i + 1;
          }
          res[def.name] = value;
        }
        return res;
      }
      getConfig() {
        return workspace_default.getConfiguration(`list.source.${this.name}`);
      }
      addAction(name2, fn, options) {
        this.createAction(Object.assign({
          name: name2,
          execute: fn
        }, options || {}));
      }
      addMultipleAction(name2, fn, options) {
        this.createAction(Object.assign({
          name: name2,
          multiple: true,
          execute: fn
        }, options || {}));
      }
      createCommandTask(opt) {
        return new CommandTask(opt);
      }
      addLocationActions() {
        this.createAction({
          name: "preview",
          execute: async (item, context) => {
            let loc = await this.convertLocation(item.location);
            await this.previewLocation(loc, context);
          }
        });
        let { nvim } = this;
        this.createAction({
          name: "quickfix",
          multiple: true,
          execute: async (items) => {
            let quickfixItems = await Promise.all(items.map((item) => this.convertLocation(item.location).then((loc) => workspace_default.getQuickfixItem(loc))));
            await nvim.call("setqflist", [quickfixItems]);
            let openCommand = await nvim.getVar("coc_quickfix_open_command");
            nvim.command(typeof openCommand === "string" ? openCommand : "copen", true);
          }
        });
        for (let name2 of ["open", "tabe", "drop", "vsplit", "split"]) {
          this.createAction({
            name: name2,
            execute: async (item) => {
              await this.jumpTo(item.location, name2 == "open" ? null : name2);
            }
          });
        }
      }
      async convertLocation(location) {
        if (typeof location == "string")
          return import_vscode_languageserver_protocol67.Location.create(location, import_vscode_languageserver_protocol67.Range.create(0, 0, 0, 0));
        if (import_vscode_languageserver_protocol67.Location.is(location))
          return location;
        let u = URI.parse(location.uri);
        if (u.scheme != "file")
          return import_vscode_languageserver_protocol67.Location.create(location.uri, import_vscode_languageserver_protocol67.Range.create(0, 0, 0, 0));
        const rl = import_readline4.default.createInterface({
          input: import_fs19.default.createReadStream(u.fsPath, { encoding: "utf8" })
        });
        let match = location.line;
        let n = 0;
        let resolved = false;
        let line = await new Promise((resolve3) => {
          rl.on("line", (line2) => {
            if (resolved)
              return;
            if (line2.includes(match)) {
              rl.removeAllListeners();
              rl.close();
              resolved = true;
              resolve3(line2);
              return;
            }
            n = n + 1;
          });
          rl.on("error", (e) => {
            this.nvim.errWriteLine(`Read ${u.fsPath} error: ${e.message}`);
            resolve3(null);
          });
        });
        if (line != null) {
          let character = location.text ? line.indexOf(location.text) : 0;
          if (character == 0)
            character = line.match(/^\s*/)[0].length;
          let end = import_vscode_languageserver_protocol67.Position.create(n, character + (location.text ? location.text.length : 0));
          return import_vscode_languageserver_protocol67.Location.create(location.uri, import_vscode_languageserver_protocol67.Range.create(import_vscode_languageserver_protocol67.Position.create(n, character), end));
        }
        return import_vscode_languageserver_protocol67.Location.create(location.uri, import_vscode_languageserver_protocol67.Range.create(0, 0, 0, 0));
      }
      async jumpTo(location, command) {
        if (typeof location == "string") {
          await workspace_default.jumpTo(location, null, command);
          return;
        }
        let { range, uri } = await this.convertLocation(location);
        let position = range.start;
        if (position.line == 0 && position.character == 0 && comparePosition(position, range.end) == 0) {
          position = null;
        }
        await workspace_default.jumpTo(uri, position, command);
      }
      createAction(action) {
        let { name: name2 } = action;
        let idx = this.actions.findIndex((o) => o.name == name2);
        if (idx !== -1)
          this.actions.splice(idx, 1);
        this.actions.push(action);
      }
      async previewLocation(location, context) {
        if (!context.listWindow)
          return;
        let { nvim } = this;
        let { uri, range } = location;
        let doc = workspace_default.getDocument(location.uri);
        let u = URI.parse(uri);
        let lines = [];
        if (doc) {
          lines = doc.getLines();
        } else if (u.scheme == "file") {
          try {
            let content = await readFile(u.fsPath, "utf8");
            lines = content.split(/\r?\n/);
          } catch (e) {
            [`Error on read file ${u.fsPath}`, e.message];
          }
        }
        let config = {
          winid: context.window.id,
          range: emptyRange(range) ? null : range,
          lnum: range.start.line + 1,
          name: u.scheme == "file" ? u.fsPath : uri,
          filetype: doc ? doc.filetype : this.getFiletype(u.fsPath),
          position: context.options.position,
          maxHeight: this.previewHeight,
          splitRight: this.splitRight,
          hlGroup: this.hlGroup,
          scheme: u.scheme,
          toplineStyle: this.toplineStyle,
          toplineOffset: this.toplineOffset
        };
        await nvim.call("coc#list#preview", [lines, config]);
        if (workspace_default.isVim)
          nvim.command("redraw", true);
      }
      async preview(options, context) {
        let { nvim } = this;
        let { bufname, filetype, range, lines, lnum } = options;
        let config = {
          winid: context.window.id,
          lnum: range ? range.start.line + 1 : lnum || 1,
          filetype: filetype || "txt",
          position: context.options.position,
          maxHeight: this.previewHeight,
          splitRight: this.splitRight,
          hlGroup: this.hlGroup,
          toplineStyle: this.toplineStyle,
          toplineOffset: this.toplineOffset
        };
        if (bufname)
          config.name = bufname;
        if (range)
          config.range = range;
        await nvim.call("coc#list#preview", [lines, config]);
        if (workspace_default.isVim)
          nvim.command("redraw", true);
      }
      doHighlight() {
      }
      dispose() {
        disposeAll(this.disposables);
      }
      getFiletype(filepath) {
        let extname = import_path20.default.extname(filepath);
        if (!extname)
          return "";
        for (let doc of workspace_default.documents) {
          let fsPath = URI.parse(doc.uri).fsPath;
          if (import_path20.default.extname(fsPath) == extname) {
            return getFiletype(doc.filetype);
          }
        }
        return "";
      }
    };
  }
});

// src/list/formatting.ts
function formatListItems(align, list2) {
  if (list2.length === 0) {
    return [];
  }
  let processedList = [];
  if (align) {
    const maxWidths = Array(Math.min(...list2.map((item) => item.label.length))).fill(0);
    for (let item of list2) {
      for (let i = 0; i < maxWidths.length; i++) {
        maxWidths[i] = Math.max(maxWidths[i], item.label[i].length);
      }
    }
    processedList = list2.map((item) => __spreadProps(__spreadValues({}, item), {
      label: item.label.map((element, idx) => element.padEnd(maxWidths[idx])).join("	")
    }));
  } else {
    processedList = list2.map((item) => __spreadProps(__spreadValues({}, item), { label: item.label.join("	") }));
  }
  return processedList;
}
function formatPath(format2, pathToFormat) {
  var _a2;
  if (format2 === "hidden") {
    return "";
  } else if (format2 === "full") {
    return pathToFormat;
  } else if (format2 === "short") {
    const segments = pathToFormat.split(import_path21.default.sep);
    if (segments.length < 2) {
      return pathToFormat;
    }
    const shortenedInit = segments.slice(0, segments.length - 2).filter((seg) => seg.length > 0).map((seg) => seg[0]);
    return [...shortenedInit, segments[segments.length - 1]].join(import_path21.default.sep);
  } else {
    const segments = pathToFormat.split(import_path21.default.sep);
    return (_a2 = segments[segments.length - 1]) != null ? _a2 : "";
  }
}
var import_path21;
var init_formatting = __esm({
  "src/list/formatting.ts"() {
    import_path21 = __toModule(require("path"));
  }
});

// src/list/source/commands.ts
function score3(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}
var CommandsList;
var init_commands = __esm({
  "src/list/source/commands.ts"() {
    init_commands2();
    init_events();
    init_workspace();
    init_basic();
    init_formatting();
    CommandsList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "run";
        this.description = "registered commands of coc.nvim";
        this.name = "commands";
        this.mru = workspace_default.createMru("commands");
        this.addAction("run", async (item) => {
          let { cmd } = item.data;
          await events_default.fire("Command", [cmd]);
          commands_default.executeCommand(cmd).logError();
          await commands_default.addRecent(cmd);
        });
        this.addAction("append", async (item) => {
          let { cmd } = item.data;
          await nvim.feedKeys(`:CocCommand ${cmd} `, "n", false);
        });
      }
      async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        let { commandList, onCommandList, titles } = commands_default;
        let ids = commandList.map((c) => c.id).concat(onCommandList);
        for (const id of [...new Set(ids)]) {
          items.push({
            label: [id, ...titles.get(id) ? [titles.get(id)] : []],
            filterText: id,
            data: { cmd: id, score: score3(mruList, id) }
          });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocCommandsTitle /\\t.*$/ contained containedin=CocCommandsLine", true);
        nvim.command("highlight default link CocCommandsTitle Comment", true);
        void nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/location.ts
var import_path22, logger63, LocationList;
var init_location = __esm({
  "src/list/source/location.ts"() {
    init_main();
    import_path22 = __toModule(require("path"));
    init_basic();
    init_workspace();
    init_esm2();
    init_fs();
    init_string();
    logger63 = require_logger2()("list-location");
    LocationList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "open";
        this.description = "show locations saved by g:coc_jump_locations variable";
        this.name = "location";
        this.addLocationActions();
      }
      async loadItems(context, token) {
        let locs = await this.nvim.getVar("coc_jump_locations");
        if (token.isCancellationRequested)
          return [];
        locs = locs || [];
        locs.forEach((loc) => {
          if (!loc.uri) {
            let fullpath = import_path22.default.isAbsolute(loc.filename) ? loc.filename : import_path22.default.join(context.cwd, loc.filename);
            loc.uri = URI.file(fullpath).toString();
          }
          if (!loc.bufnr && workspace_default.getDocument(loc.uri) != null) {
            loc.bufnr = workspace_default.getDocument(loc.uri).bufnr;
          }
          if (!loc.range) {
            let { lnum, col } = loc;
            loc.range = Range.create(lnum - 1, col - 1, lnum - 1, col - 1);
          } else {
            loc.lnum = loc.lnum || loc.range.start.line + 1;
            loc.col = loc.col || loc.range.start.character + 1;
          }
        });
        let bufnr = context.buffer.id;
        let ignoreFilepath = locs.every((o) => o.bufnr && bufnr && o.bufnr == bufnr);
        let items = locs.map((loc) => {
          let filename = ignoreFilepath ? "" : loc.filename;
          let filterText = `${filename}${loc.text.trim()}`;
          if (import_path22.default.isAbsolute(filename)) {
            filename = isParentFolder(context.cwd, filename) ? import_path22.default.relative(context.cwd, filename) : filename;
          }
          let pre = `${filename} |${loc.type ? loc.type + " " : ""}${loc.lnum} col ${loc.col}| `;
          let highlight;
          if (loc.range && loc.range.start.line == loc.range.end.line) {
            let start = byteLength(pre) + byteLength(loc.text.slice(0, loc.range.start.character));
            let end = byteLength(pre) + byteLength(loc.text.slice(0, loc.range.end.character));
            highlight = { hlGroup: "Search", span: [start, end] };
          }
          let label = pre + loc.text;
          return {
            label,
            location: Location.create(loc.uri, loc.range),
            filterText,
            ansiHighlights: highlight ? [highlight] : void 0
          };
        });
        return items;
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocLocationName /\\v^[^|]+/ contained containedin=CocLocationLine", true);
        nvim.command("syntax match CocLocationPosition /\\v\\|\\w*\\s?\\d+\\scol\\s\\d+\\|/ contained containedin=CocLocationLine", true);
        nvim.command("syntax match CocLocationError /Error/ contained containedin=CocLocationPosition", true);
        nvim.command("syntax match CocLocationWarning /Warning/ contained containedin=CocLocationPosition", true);
        nvim.command("highlight default link CocLocationName Directory", true);
        nvim.command("highlight default link CocLocationPosition LineNr", true);
        nvim.command("highlight default link CocLocationError Error", true);
        nvim.command("highlight default link CocLocationWarning WarningMsg", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/list/source/diagnostics.ts
var import_path23, logger64, DiagnosticsList;
var init_diagnostics = __esm({
  "src/list/source/diagnostics.ts"() {
    import_path23 = __toModule(require("path"));
    init_manager();
    init_location();
    init_fs();
    init_formatting();
    logger64 = require_logger2()("list-symbols");
    DiagnosticsList = class extends LocationList {
      constructor() {
        super(...arguments);
        this.defaultAction = "open";
        this.description = "diagnostics of current workspace";
        this.name = "diagnostics";
      }
      async loadItems(context) {
        let list2 = manager_default.getDiagnosticList();
        let { cwd } = context;
        const config = this.getConfig();
        const shouldIncludeCode = config.get("includeCode", true);
        const pathFormat = config.get("pathFormat", "full");
        const unformatted = list2.map((item) => {
          const file = isParentFolder(cwd, item.file) ? import_path23.default.relative(cwd, item.file) : item.file;
          const formattedPath = formatPath(pathFormat, file);
          const formattedPosition = pathFormat !== "hidden" ? [`${formattedPath}:${item.lnum}`] : [];
          const code = shouldIncludeCode ? [`[${item.source}${item.code ? "" : "]"}`, item.code ? `${item.code}]` : ""] : [];
          return {
            label: [...formattedPosition, ...code, item.severity, item.message],
            location: item.location
          };
        });
        return formatListItems(this.alignColumns, unformatted);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocDiagnosticsFile /\\v^\\s*\\S+/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsError /\\tError\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsWarning /\\tWarning\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsInfo /\\tInformation\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsHint /\\tHint\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("highlight default link CocDiagnosticsFile Comment", true);
        nvim.command("highlight default link CocDiagnosticsError CocErrorSign", true);
        nvim.command("highlight default link CocDiagnosticsWarning CocWarningSign", true);
        nvim.command("highlight default link CocDiagnosticsInfo CocInfoSign", true);
        nvim.command("highlight default link CocDiagnosticsHint CocHintSign", true);
        void nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/extensions.ts
function getPriority(stat) {
  switch (stat) {
    case "unknown":
      return 2;
    case "activated":
      return 1;
    case "disabled":
      return -1;
    default:
      return 0;
  }
}
var import_fs_extra7, import_os9, import_path24, logger65, ExtensionList;
var init_extensions = __esm({
  "src/list/source/extensions.ts"() {
    import_fs_extra7 = __toModule(require_lib5());
    import_os9 = __toModule(require("os"));
    import_path24 = __toModule(require("path"));
    init_esm2();
    init_extensions2();
    init_util();
    init_workspace();
    init_window();
    init_basic();
    init_formatting();
    logger65 = require_logger2()("list-extensions");
    ExtensionList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "toggle";
        this.description = "manage coc extensions";
        this.name = "extensions";
        this.addAction("toggle", async (item) => {
          let { id, state } = item.data;
          if (state == "disabled")
            return;
          if (state == "activated") {
            await extensions_default.deactivate(id);
          } else {
            await extensions_default.activate(id);
          }
          await wait(100);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("configuration", async (item) => {
          let { root } = item.data;
          let jsonFile = import_path24.default.join(root, "package.json");
          if (import_fs_extra7.default.existsSync(jsonFile)) {
            let lines = import_fs_extra7.default.readFileSync(jsonFile, "utf8").split(/\r?\n/);
            let idx = lines.findIndex((s) => s.includes('"contributes"'));
            await workspace_default.jumpTo(URI.file(jsonFile).toString(), { line: idx == -1 ? 0 : idx, character: 0 });
          }
        });
        this.addAction("open", async (item) => {
          let { root } = item.data;
          if (workspace_default.env.isiTerm) {
            nvim.call("coc#util#iterm_open", [root], true);
          } else {
            nvim.call("coc#util#open_url", [root], true);
          }
        });
        this.addAction("disable", async (item) => {
          let { id, state } = item.data;
          if (state !== "disabled")
            await extensions_default.toggleExtension(id);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("enable", async (item) => {
          let { id, state } = item.data;
          if (state == "disabled")
            await extensions_default.toggleExtension(id);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("lock", async (item) => {
          let { id } = item.data;
          await extensions_default.toggleLock(id);
        }, { persist: true, reload: true });
        this.addAction("help", async (item) => {
          let { root } = item.data;
          let files = await import_fs_extra7.default.readdir(root);
          let file = files.find((f) => /^readme/i.test(f));
          if (file)
            await workspace_default.callAsync("coc#util#jump", ["edit", import_path24.default.join(root, file)]);
        });
        this.addAction("reload", async (item) => {
          let { id } = item.data;
          await extensions_default.reloadExtension(id);
        }, { persist: true, reload: true });
        this.addAction("fix", async (item) => {
          let { root, isLocal } = item.data;
          let { npm } = extensions_default;
          if (isLocal) {
            window_default.showMessage(`Can't fix for local extension.`, "warning");
            return;
          }
          if (!npm)
            return;
          let folder = import_path24.default.join(root, "node_modules");
          if (import_fs_extra7.default.existsSync(folder)) {
            import_fs_extra7.default.removeSync(folder);
          }
          let terminal = await workspace_default.createTerminal({
            cwd: root
          });
          let shown = await terminal.show(false);
          if (!shown)
            return;
          workspace_default.nvim.command(`startinsert`, true);
          terminal.sendText(`${npm} install --production --ignore-scripts --no-lockfile`, true);
        });
        this.addMultipleAction("uninstall", async (items) => {
          let ids = [];
          for (let item of items) {
            if (item.data.isLocal)
              continue;
            ids.push(item.data.id);
          }
          extensions_default.uninstallExtension(ids).catch((e) => {
            logger65.error(e);
          });
        });
      }
      async loadItems(_context) {
        let items = [];
        let list2 = await extensions_default.getExtensionStates();
        let lockedList = await extensions_default.getLockedList();
        for (let stat of list2) {
          let prefix = "+";
          if (stat.state == "disabled") {
            prefix = "-";
          } else if (stat.state == "activated") {
            prefix = "*";
          } else if (stat.state == "unknown") {
            prefix = "?";
          }
          let root = await this.nvim.call("resolve", stat.root);
          let locked = lockedList.includes(stat.id);
          items.push({
            label: [`${prefix} ${stat.id}${locked ? " \uE0A2" : ""}`, ...stat.isLocal ? ["[RTP]"] : [], stat.version, root.replace(import_os9.default.homedir(), "~")],
            filterText: stat.id,
            data: {
              id: stat.id,
              root,
              state: stat.state,
              isLocal: stat.isLocal,
              priority: getPriority(stat.state)
            }
          });
        }
        items.sort((a, b) => {
          if (a.data.priority != b.data.priority) {
            return b.data.priority - a.data.priority;
          }
          return b.data.id - a.data.id ? 1 : -1;
        });
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocExtensionsActivited /\\v^\\*/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsLoaded /\\v^\\+/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsDisabled /\\v^-/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsName /\\v%3c\\S+/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsRoot /\\v\\t[^\\t]*$/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsLocal /\\v\\[RTP\\]/ contained containedin=CocExtensionsLine", true);
        nvim.command("highlight default link CocExtensionsActivited Special", true);
        nvim.command("highlight default link CocExtensionsLoaded Normal", true);
        nvim.command("highlight default link CocExtensionsDisabled Comment", true);
        nvim.command("highlight default link CocExtensionsName String", true);
        nvim.command("highlight default link CocExtensionsLocal MoreMsg", true);
        nvim.command("highlight default link CocExtensionsRoot Comment", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/list/source/folders.ts
var import_path25, import_fs_extra8, FoldList;
var init_folders = __esm({
  "src/list/source/folders.ts"() {
    import_path25 = __toModule(require("path"));
    init_esm2();
    import_fs_extra8 = __toModule(require_lib5());
    init_fs();
    init_workspace();
    init_window();
    init_basic();
    FoldList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "edit";
        this.description = "list of current workspace folders";
        this.name = "folders";
        this.addAction("edit", async (item) => {
          let newPath = await nvim.call("input", ["Folder: ", item.label, "dir"]);
          let stat = await statAsync(newPath);
          if (!stat || !stat.isDirectory()) {
            window_default.showMessage(`invalid path: ${newPath}`, "error");
            return;
          }
          workspace_default.renameWorkspaceFolder(item.label, newPath);
        });
        this.addAction("delete", async (item) => {
          workspace_default.removeWorkspaceFolder(item.label);
        }, { reload: true, persist: true });
        this.addAction("newfile", async (item) => {
          let file = await window_default.requestInput("File name", item.label + "/");
          let dir = import_path25.default.dirname(file);
          let stat = await statAsync(dir);
          if (!stat || !stat.isDirectory()) {
            import_fs_extra8.default.mkdirpSync(dir);
          }
          await workspace_default.createFile(file, { overwrite: false, ignoreIfExists: true });
          await this.jumpTo(URI.file(file).toString());
        });
      }
      async loadItems(_context) {
        return workspace_default.folderPaths.map((p) => ({ label: p }));
      }
    };
  }
});

// src/list/source/links.ts
function formatUri(uri) {
  if (!uri.startsWith("file:"))
    return uri;
  let filepath = URI.parse(uri).fsPath;
  return isParentFolder(workspace_default.cwd, filepath) ? import_path26.default.relative(workspace_default.cwd, filepath) : filepath;
}
var import_path26, LinksList;
var init_links = __esm({
  "src/list/source/links.ts"() {
    init_languages();
    init_workspace();
    import_path26 = __toModule(require("path"));
    init_basic();
    init_main();
    init_esm2();
    init_fs();
    LinksList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "open";
        this.description = "links of current buffer";
        this.name = "links";
        this.addAction("open", async (item) => {
          let { target } = item.data;
          let uri = URI.parse(target);
          if (uri.scheme.startsWith("http")) {
            await nvim.call("coc#util#open_url", target);
          } else {
            await workspace_default.jumpTo(target);
          }
        });
        this.addAction("jump", async (item) => {
          let { location } = item.data;
          await workspace_default.jumpTo(location.uri, location.range.start);
        });
      }
      async loadItems(context, token) {
        let buf = await context.window.buffer;
        let doc = workspace_default.getDocument(buf.id);
        if (!doc)
          return null;
        let items = [];
        let links2 = await languages_default.getDocumentLinks(doc.textDocument, token);
        if (links2 == null) {
          throw new Error("Links provider not found.");
        }
        let res = [];
        for (let link of links2) {
          if (link.target) {
            items.push({
              label: formatUri(link.target),
              data: {
                target: link.target,
                location: Location.create(doc.uri, link.range)
              }
            });
          } else {
            link = await languages_default.resolveDocumentLink(link);
            if (link.target) {
              items.push({
                label: formatUri(link.target),
                data: {
                  target: link.target,
                  location: Location.create(doc.uri, link.range)
                }
              });
            }
            res.push(link);
          }
        }
        return items;
      }
    };
  }
});

// src/list/source/lists.ts
function score4(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}
var LinksList2;
var init_lists = __esm({
  "src/list/source/lists.ts"() {
    init_basic();
    init_mru();
    init_formatting();
    LinksList2 = class extends BasicList {
      constructor(nvim, listMap) {
        super(nvim);
        this.listMap = listMap;
        this.name = "lists";
        this.defaultAction = "open";
        this.description = "registered lists of coc.nvim";
        this.mru = new Mru("lists");
        this.addAction("open", async (item) => {
          let { name: name2 } = item.data;
          await this.mru.add(name2);
          await nvim.command(`CocList ${name2}`);
        });
      }
      async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        for (let list2 of this.listMap.values()) {
          if (list2.name == "lists")
            continue;
          items.push({
            label: [list2.name, ...list2.description ? [list2.description] : []],
            data: {
              name: list2.name,
              interactive: list2.interactive,
              score: score4(mruList, list2.name)
            }
          });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocListsDesc /\\t.*$/ contained containedin=CocListsLine", true);
        nvim.command("highlight default link CocListsDesc Comment", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/util/convert.ts
function getSymbolKind(kind) {
  switch (kind) {
    case import_vscode_languageserver_protocol68.SymbolKind.File:
      return "File";
    case import_vscode_languageserver_protocol68.SymbolKind.Module:
      return "Module";
    case import_vscode_languageserver_protocol68.SymbolKind.Namespace:
      return "Namespace";
    case import_vscode_languageserver_protocol68.SymbolKind.Package:
      return "Package";
    case import_vscode_languageserver_protocol68.SymbolKind.Class:
      return "Class";
    case import_vscode_languageserver_protocol68.SymbolKind.Method:
      return "Method";
    case import_vscode_languageserver_protocol68.SymbolKind.Property:
      return "Property";
    case import_vscode_languageserver_protocol68.SymbolKind.Field:
      return "Field";
    case import_vscode_languageserver_protocol68.SymbolKind.Constructor:
      return "Constructor";
    case import_vscode_languageserver_protocol68.SymbolKind.Enum:
      return "Enum";
    case import_vscode_languageserver_protocol68.SymbolKind.Interface:
      return "Interface";
    case import_vscode_languageserver_protocol68.SymbolKind.Function:
      return "Function";
    case import_vscode_languageserver_protocol68.SymbolKind.Variable:
      return "Variable";
    case import_vscode_languageserver_protocol68.SymbolKind.Constant:
      return "Constant";
    case import_vscode_languageserver_protocol68.SymbolKind.String:
      return "String";
    case import_vscode_languageserver_protocol68.SymbolKind.Number:
      return "Number";
    case import_vscode_languageserver_protocol68.SymbolKind.Boolean:
      return "Boolean";
    case import_vscode_languageserver_protocol68.SymbolKind.Array:
      return "Array";
    case import_vscode_languageserver_protocol68.SymbolKind.Object:
      return "Object";
    case import_vscode_languageserver_protocol68.SymbolKind.Key:
      return "Key";
    case import_vscode_languageserver_protocol68.SymbolKind.Null:
      return "Null";
    case import_vscode_languageserver_protocol68.SymbolKind.EnumMember:
      return "EnumMember";
    case import_vscode_languageserver_protocol68.SymbolKind.Struct:
      return "Struct";
    case import_vscode_languageserver_protocol68.SymbolKind.Event:
      return "Event";
    case import_vscode_languageserver_protocol68.SymbolKind.Operator:
      return "Operator";
    case import_vscode_languageserver_protocol68.SymbolKind.TypeParameter:
      return "TypeParameter";
    default:
      return "Unknown";
  }
}
var import_vscode_languageserver_protocol68;
var init_convert = __esm({
  "src/util/convert.ts"() {
    import_vscode_languageserver_protocol68 = __toModule(require_main2());
  }
});

// src/list/source/outline.ts
function getFilterText(s, kind) {
  return `${s.name}${kind ? ` ${kind}` : ""}`;
}
function sortSymbols(a, b) {
  let ra = a.selectionRange;
  let rb = b.selectionRange;
  if (ra.start.line != rb.start.line) {
    return ra.start.line - rb.start.line;
  }
  return ra.start.character - rb.start.character;
}
var import_path27, import_which3, logger66, Outline;
var init_outline = __esm({
  "src/list/source/outline.ts"() {
    import_path27 = __toModule(require("path"));
    init_main();
    init_esm2();
    import_which3 = __toModule(require_which());
    init_languages();
    init_util();
    init_fs();
    init_workspace();
    init_location();
    init_convert();
    init_formatting();
    logger66 = require_logger2()("list-symbols");
    Outline = class extends LocationList {
      constructor() {
        super(...arguments);
        this.description = "symbols of current document";
        this.name = "outline";
        this.options = [{
          name: "-k, -kind KIND",
          hasValue: true,
          description: "filters also by kind"
        }];
      }
      async loadItems(context, token) {
        let buf = await context.window.buffer;
        let document2 = workspace_default.getDocument(buf.id);
        if (!document2)
          return null;
        let config = this.getConfig();
        let ctagsFilestypes = config.get("ctagsFilestypes", []);
        let symbols;
        let args = this.parseArguments(context.args);
        if (!ctagsFilestypes.includes(document2.filetype)) {
          symbols = await languages_default.getDocumentSymbol(document2.textDocument, token);
        }
        if (token.isCancellationRequested)
          return [];
        if (!symbols)
          return await this.loadCtagsSymbols(document2);
        if (symbols.length == 0)
          return [];
        let filterKind = args.kind ? args.kind.toLowerCase() : null;
        let items = [];
        let isSymbols = !symbols[0].hasOwnProperty("location");
        if (isSymbols) {
          let addSymbols = function(symbols2, level = 0) {
            symbols2.sort(sortSymbols);
            for (let s of symbols2) {
              let kind = getSymbolKind(s.kind);
              let location = Location.create(document2.uri, s.selectionRange);
              items.push({
                label: [`${"| ".repeat(level)}${s.name}`, `[${kind}]`, `${s.range.start.line + 1}`],
                filterText: getFilterText(s, args.kind == "" ? kind : null),
                location,
                data: { kind }
              });
              if (s.children && s.children.length) {
                addSymbols(s.children, level + 1);
              }
            }
          };
          addSymbols(symbols);
          if (filterKind) {
            items = items.filter((o) => o.data.kind.toLowerCase().indexOf(filterKind) == 0);
          }
        } else {
          symbols.sort((a, b) => {
            let sa = a.location.range.start;
            let sb = b.location.range.start;
            let d = sa.line - sb.line;
            return d == 0 ? sa.character - sb.character : d;
          });
          for (let s of symbols) {
            let kind = getSymbolKind(s.kind);
            if (s.name.endsWith(") callback"))
              continue;
            if (filterKind && !kind.toLowerCase().startsWith(filterKind)) {
              continue;
            }
            if (s.location.uri === void 0) {
              s.location.uri = document2.uri;
            }
            items.push({
              label: [s.name, `[${kind}]`, `${s.location.range.start.line + 1}`],
              filterText: getFilterText(s, args.kind == "" ? kind : null),
              location: s.location
            });
          }
        }
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocOutlineName /\\v\\s?[^\\t]+\\s/ contained containedin=CocOutlineLine", true);
        nvim.command("syntax match CocOutlineIndentLine /\\v\\|/ contained containedin=CocOutlineLine,CocOutlineName", true);
        nvim.command("syntax match CocOutlineKind /\\[\\w\\+\\]/ contained containedin=CocOutlineLine", true);
        nvim.command("syntax match CocOutlineLine /\\d\\+$/ contained containedin=CocOutlineLine", true);
        nvim.command("highlight default link CocOutlineName Normal", true);
        nvim.command("highlight default link CocOutlineIndentLine Comment", true);
        nvim.command("highlight default link CocOutlineKind Typedef", true);
        nvim.command("highlight default link CocOutlineLine Comment", true);
        nvim.resumeNotification(false, true).logError();
      }
      async loadCtagsSymbols(document2) {
        if (!import_which3.default.sync("ctags", { nothrow: true })) {
          return [];
        }
        let uri = URI.parse(document2.uri);
        let extname = import_path27.default.extname(uri.fsPath);
        let content = "";
        let tempname = await this.nvim.call("tempname");
        let filepath = `${tempname}.${extname}`;
        let escaped = await this.nvim.call("fnameescape", filepath);
        await writeFile(escaped, document2.getDocumentContent());
        try {
          content = await runCommand(`ctags -f - --excmd=number --language-force=${document2.filetype} ${escaped}`);
        } catch (e) {
        }
        if (!content.trim().length) {
          content = await runCommand(`ctags -f - --excmd=number ${escaped}`);
        }
        content = content.trim();
        if (!content)
          return [];
        let lines = content.split(/\r?\n/);
        let items = [];
        for (let line of lines) {
          let parts = line.split("	");
          if (parts.length < 4)
            continue;
          let lnum = Number(parts[2].replace(/;"$/, ""));
          let text = document2.getline(lnum - 1);
          if (!text)
            continue;
          let idx = text.indexOf(parts[0]);
          let start = idx == -1 ? 0 : idx;
          let range = Range.create(lnum - 1, start, lnum - 1, start + parts[0].length);
          items.push({
            label: `${parts[0]} [${parts[3]}] ${lnum}`,
            filterText: parts[0],
            location: Location.create(document2.uri, range),
            data: { line: lnum }
          });
        }
        items.sort((a, b) => a.data.line - b.data.line);
        return items;
      }
    };
  }
});

// src/list/source/services.ts
var ServicesList;
var init_services2 = __esm({
  "src/list/source/services.ts"() {
    init_services();
    init_basic();
    init_util();
    init_formatting();
    ServicesList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "toggle";
        this.description = "registered services of coc.nvim";
        this.name = "services";
        this.addAction("toggle", async (item) => {
          let { id } = item.data;
          await services_default.toggle(id);
          await wait(100);
        }, { persist: true, reload: true });
      }
      async loadItems(_context) {
        let stats = services_default.getServiceStats();
        stats.sort((a, b) => a.id > b.id ? -1 : 1);
        return formatListItems(this.alignColumns, stats.map((stat) => {
          let prefix = stat.state == "running" ? "*" : " ";
          return {
            label: [prefix, stat.id, `[${stat.state}]`, stat.languageIds.join(", ")],
            data: { id: stat.id }
          };
        }));
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocServicesPrefix /\\v^./ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesName /\\v%3c\\S+/ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesStat /\\v\\t\\[\\w+\\]/ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesLanguages /\\v(\\])@<=.*$/ contained containedin=CocServicesLine", true);
        nvim.command("highlight default link CocServicesPrefix Special", true);
        nvim.command("highlight default link CocServicesName Type", true);
        nvim.command("highlight default link CocServicesStat Statement", true);
        nvim.command("highlight default link CocServicesLanguages Comment", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/list/source/sources.ts
function fixWidth(str, width) {
  if (str.length > width) {
    return str.slice(0, width - 1) + ".";
  }
  return str + " ".repeat(width - str.length);
}
var logger67, SourcesList;
var init_sources = __esm({
  "src/list/source/sources.ts"() {
    init_main();
    init_esm2();
    init_sources2();
    init_workspace();
    init_basic();
    logger67 = require_logger2()("list-sources");
    SourcesList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "toggle";
        this.description = "registered completion sources";
        this.name = "sources";
        this.addAction("toggle", async (item) => {
          let { name: name2 } = item.data;
          sources_default.toggleSource(name2);
        }, { persist: true, reload: true });
        this.addAction("refresh", async (item) => {
          let { name: name2 } = item.data;
          await sources_default.refresh(name2);
        }, { persist: true, reload: true });
        this.addAction("open", async (item) => {
          let { location } = item;
          if (location)
            await this.jumpTo(location);
        });
      }
      async loadItems(context) {
        let stats = sources_default.sourceStats();
        let filetype = await context.buffer.getOption("filetype");
        let map = workspace_default.env.disabledSources;
        let disables = map ? map[filetype] || [] : [];
        stats.sort((a, b) => {
          if (a.type != b.type)
            return a.type < b.type ? 1 : -1;
          return a.name > b.name ? -1 : 1;
        });
        return stats.map((stat) => {
          let prefix = stat.disabled ? " " : "*";
          if (disables && disables.includes(stat.name)) {
            prefix = "-";
          }
          let location;
          if (stat.filepath) {
            location = Location.create(URI.file(stat.filepath).toString(), Range.create(0, 0, 0, 0));
          }
          return {
            label: `${prefix} ${fixWidth(stat.name, 22)} ${fixWidth("[" + stat.shortcut + "]", 10)} ${fixWidth(stat.triggerCharacters.join(""), 10)} ${fixWidth(stat.priority.toString(), 3)} ${stat.filetypes.join(",")}`,
            location,
            data: { name: stat.name }
          };
        });
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocSourcesPrefix /\\v^./ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesName /\\v%3c\\S+/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesType /\\v%25v.*%36v/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesPriority /\\v%46v.*%50v/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesFileTypes /\\v\\S+$/ contained containedin=CocSourcesLine", true);
        nvim.command("highlight default link CocSourcesPrefix Special", true);
        nvim.command("highlight default link CocSourcesName Type", true);
        nvim.command("highlight default link CocSourcesPriority Number", true);
        nvim.command("highlight default link CocSourcesFileTypes Comment", true);
        nvim.command("highlight default link CocSourcesType Statement", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/symbols.ts
var import_path28, import_minimatch5, import_vscode_languageserver_protocol69, logger68, Symbols;
var init_symbols = __esm({
  "src/list/source/symbols.ts"() {
    import_path28 = __toModule(require("path"));
    import_minimatch5 = __toModule(require_minimatch());
    init_esm2();
    init_languages();
    init_workspace();
    init_location();
    init_convert();
    init_fs();
    init_fzy();
    import_vscode_languageserver_protocol69 = __toModule(require_main2());
    init_formatting();
    logger68 = require_logger2()("list-symbols");
    Symbols = class extends LocationList {
      constructor() {
        super(...arguments);
        this.interactive = true;
        this.description = "search workspace symbols";
        this.detail = "Symbols list is provided by server, it works on interactive mode only.";
        this.name = "symbols";
        this.options = [{
          name: "-k, -kind KIND",
          description: "Filter symbols by kind.",
          hasValue: true
        }];
      }
      async loadItems(context, token) {
        let { input } = context;
        this.cwd = context.cwd;
        let args = this.parseArguments(context.args);
        let filterKind = args.kind ? args.kind.toLowerCase() : "";
        if (!context.options.interactive) {
          throw new Error("Symbols only works on interactive mode");
        }
        let symbols = await languages_default.getWorkspaceSymbols(input, token);
        if (!symbols) {
          throw new Error("No workspace symbols provider registered");
        }
        let config = this.getConfig();
        let excludes = config.get("excludes", []);
        let items = [];
        for (let s of symbols) {
          let kind = getSymbolKind(s.kind);
          if (filterKind && kind.toLowerCase() != filterKind) {
            continue;
          }
          let file = URI.parse(s.location.uri).fsPath;
          if (isParentFolder(workspace_default.cwd, file)) {
            file = import_path28.default.relative(workspace_default.cwd, file);
          }
          if (excludes.some((p) => (0, import_minimatch5.default)(file, p))) {
            continue;
          }
          items.push({
            label: [s.name, `[${kind}]`, file],
            filterText: `${s.name}`,
            location: s.location,
            data: { original: s, kind: s.kind, file, score: score2(input, s.name) }
          });
        }
        items.sort((a, b) => {
          if (a.data.score != b.data.score) {
            return b.data.score - a.data.score;
          }
          if (a.data.kind != b.data.kind) {
            return a.data.kind - b.data.kind;
          }
          return a.data.file.length - b.data.file.length;
        });
        return formatListItems(this.alignColumns, items);
      }
      async resolveItem(item) {
        let s = item.data.original;
        if (!s)
          return null;
        let tokenSource = new import_vscode_languageserver_protocol69.CancellationTokenSource();
        let resolved = await languages_default.resolveWorkspaceSymbol(s, tokenSource.token);
        if (!resolved)
          return null;
        let kind = getSymbolKind(resolved.kind);
        let file = URI.parse(resolved.location.uri).fsPath;
        if (isParentFolder(this.cwd, file)) {
          file = import_path28.default.relative(this.cwd, file);
        }
        return {
          label: `${s.name} [${kind}]	${file}`,
          filterText: `${s.name}`,
          location: s.location
        };
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocSymbolsName /\\v^\\s*\\S+/ contained containedin=CocSymbolsLine", true);
        nvim.command("syntax match CocSymbolsKind /\\[\\w\\+\\]\\s*\\t/ contained containedin=CocSymbolsLine", true);
        nvim.command("syntax match CocSymbolsFile /\\S\\+$/ contained containedin=CocSymbolsLine", true);
        nvim.command("highlight default link CocSymbolsName Normal", true);
        nvim.command("highlight default link CocSymbolsKind Typedef", true);
        nvim.command("highlight default link CocSymbolsFile Comment", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/list/manager.ts
var import_debounce7, import_vscode_languageserver_protocol70, logger69, mouseKeys, ListManager, manager_default2;
var init_manager3 = __esm({
  "src/list/manager.ts"() {
    import_debounce7 = __toModule(require_debounce());
    import_vscode_languageserver_protocol70 = __toModule(require_main2());
    init_events();
    init_extensions2();
    init_util();
    init_workspace();
    init_window();
    init_configuration4();
    init_mappings();
    init_prompt();
    init_session();
    init_commands();
    init_diagnostics();
    init_extensions();
    init_folders();
    init_links();
    init_lists();
    init_location();
    init_outline();
    init_services2();
    init_sources();
    init_symbols();
    logger69 = require_logger2()("list-manager");
    mouseKeys = ["<LeftMouse>", "<LeftDrag>", "<LeftRelease>", "<2-LeftMouse>"];
    ListManager = class {
      constructor() {
        this.plugTs = 0;
        this.sessionsMap = new Map();
        this.disposables = [];
        this.listMap = new Map();
      }
      init(nvim) {
        this.nvim = nvim;
        this.config = new ListConfiguration();
        this.prompt = new Prompt(nvim, this.config);
        this.mappings = new Mappings(this, nvim, this.config);
        let signText = this.config.get("selectedSignText", "*");
        nvim.command(`sign define CocSelected text=${signText} texthl=CocSelectedText linehl=CocSelectedLine`, true);
        events_default.on("InputChar", this.onInputChar, this, this.disposables);
        let debounced = (0, import_debounce7.default)(async () => {
          let session = await this.getCurrentSession();
          if (session)
            this.prompt.drawPrompt();
        }, 100);
        events_default.on("FocusGained", debounced, null, this.disposables);
        events_default.on("WinEnter", (winid) => {
          let session = this.getSessionByWinid(winid);
          if (session)
            this.prompt.start(session.listOptions);
        }, null, this.disposables);
        events_default.on("WinLeave", (winid) => {
          let session = this.getSessionByWinid(winid);
          if (session)
            this.prompt.cancel();
        }, null, this.disposables);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        this.prompt.onDidChangeInput(() => {
          let { session } = this;
          if (!session)
            return;
          session.onInputChange();
          session.history.filter();
        });
        this.registerList(new LinksList(nvim));
        this.registerList(new LocationList(nvim));
        this.registerList(new Symbols(nvim));
        this.registerList(new Outline(nvim));
        this.registerList(new CommandsList(nvim));
        this.registerList(new ExtensionList(nvim));
        this.registerList(new DiagnosticsList(nvim));
        this.registerList(new SourcesList(nvim));
        this.registerList(new ServicesList(nvim));
        this.registerList(new LinksList2(nvim, this.listMap));
        this.registerList(new FoldList(nvim));
      }
      async start(args) {
        let res = this.parseArgs(args);
        if (!res)
          return;
        let { name: name2 } = res.list;
        let curr = this.sessionsMap.get(name2);
        if (curr)
          curr.dispose();
        this.prompt.start(res.options);
        let session = new ListSession(this.nvim, this.prompt, res.list, res.options, res.listArgs, this.config);
        this.sessionsMap.set(name2, session);
        this.lastSession = session;
        try {
          await session.start(args);
        } catch (e) {
          this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
          let msg = e instanceof Error ? e.message : e.toString();
          window_default.showMessage(`Error on "CocList ${name2}": ${msg}`, "error");
          logger69.error(e);
        }
      }
      getSessionByWinid(winid) {
        for (let session of this.sessionsMap.values()) {
          if (session && session.winid == winid) {
            this.lastSession = session;
            return session;
          }
        }
        return null;
      }
      async getCurrentSession() {
        let { id } = await this.nvim.window;
        for (let session of this.sessionsMap.values()) {
          if (session && session.winid == id) {
            this.lastSession = session;
            return session;
          }
        }
        return null;
      }
      async resume(name2) {
        var _a2;
        if (!name2) {
          await ((_a2 = this.session) == null ? void 0 : _a2.resume());
        } else {
          let session = this.sessionsMap.get(name2);
          if (!session) {
            window_default.showMessage(`Can't find exists ${name2} list`);
            return;
          }
          await session.resume();
        }
      }
      async doAction(name2) {
        let lastSession = this.lastSession;
        if (!lastSession)
          return;
        await lastSession.doAction(name2);
      }
      async first(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.first();
      }
      async last(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.last();
      }
      async previous(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.previous();
      }
      async next(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.next();
      }
      getSession(name2) {
        if (!name2)
          return this.session;
        return this.sessionsMap.get(name2);
      }
      async cancel(close = true) {
        this.prompt.cancel();
        if (!close)
          return;
        if (this.session)
          await this.session.hide();
      }
      reset() {
        this.prompt.cancel();
        this.lastSession = void 0;
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      switchMatcher() {
        var _a2;
        (_a2 = this.session) == null ? void 0 : _a2.switchMatcher();
      }
      async togglePreview() {
        let { nvim } = this;
        let winid = await nvim.call("coc#list#get_preview", [0]);
        if (winid != -1) {
          await nvim.call("coc#window#close", [winid]);
          await nvim.command("redraw");
        } else {
          await this.doAction("preview");
        }
      }
      async chooseAction() {
        let { lastSession } = this;
        if (lastSession)
          await lastSession.chooseAction();
      }
      parseArgs(args) {
        let options = [];
        let interactive = false;
        let autoPreview = false;
        let numberSelect = false;
        let noQuit = false;
        let first = false;
        let name2;
        let input = "";
        let matcher = "fuzzy";
        let position = "bottom";
        let listArgs = [];
        let listOptions = [];
        for (let arg of args) {
          if (!name2 && arg.startsWith("-")) {
            listOptions.push(arg);
          } else if (!name2) {
            if (!/^\w+$/.test(arg)) {
              window_default.showMessage(`Invalid list option: "${arg}"`, "error");
              return null;
            }
            name2 = arg;
          } else {
            listArgs.push(arg);
          }
        }
        name2 = name2 || "lists";
        let config = workspace_default.getConfiguration(`list.source.${name2}`);
        if (!listOptions.length && !listArgs.length)
          listOptions = config.get("defaultOptions", []);
        if (!listArgs.length)
          listArgs = config.get("defaultArgs", []);
        for (let opt of listOptions) {
          if (opt.startsWith("--input")) {
            input = opt.slice(8);
          } else if (opt == "--number-select" || opt == "-N") {
            numberSelect = true;
          } else if (opt == "--auto-preview" || opt == "-A") {
            autoPreview = true;
          } else if (opt == "--regex" || opt == "-R") {
            matcher = "regex";
          } else if (opt == "--strict" || opt == "-S") {
            matcher = "strict";
          } else if (opt == "--interactive" || opt == "-I") {
            interactive = true;
          } else if (opt == "--top") {
            position = "top";
          } else if (opt == "--tab") {
            position = "tab";
          } else if (opt == "--ignore-case" || opt == "--normal" || opt == "--no-sort") {
            options.push(opt.slice(2));
          } else if (opt == "--first") {
            first = true;
          } else if (opt == "--no-quit") {
            noQuit = true;
          } else {
            window_default.showMessage(`Invalid option "${opt}" of list`, "error");
            return null;
          }
        }
        let list2 = this.listMap.get(name2);
        if (!list2) {
          window_default.showMessage(`List ${name2} not found`, "error");
          return null;
        }
        if (interactive && !list2.interactive) {
          window_default.showMessage(`Interactive mode of "${name2}" list not supported`, "error");
          return null;
        }
        return {
          list: list2,
          listArgs,
          options: {
            numberSelect,
            autoPreview,
            noQuit,
            first,
            input,
            interactive,
            matcher,
            position,
            ignorecase: options.includes("ignore-case") ? true : false,
            mode: !options.includes("normal") ? "insert" : "normal",
            sort: !options.includes("no-sort") ? true : false
          }
        };
      }
      async onInputChar(session, ch, charmod) {
        if (session != "list")
          return;
        let { mode } = this.prompt;
        let now = Date.now();
        if (ch == "<plug>" || this.plugTs && now - this.plugTs < 20) {
          this.plugTs = now;
          return;
        }
        if (!ch)
          return;
        if (ch == "<esc>") {
          await this.cancel();
          return;
        }
        if (mode == "insert") {
          await this.onInsertInput(ch, charmod);
        } else {
          await this.onNormalInput(ch, charmod);
        }
      }
      async onInsertInput(ch, charmod) {
        let { session } = this;
        if (!session)
          return;
        if (mouseKeys.includes(ch)) {
          await this.onMouseEvent(ch);
          return;
        }
        let n = await session.doNumberSelect(ch);
        if (n)
          return;
        let done = await this.mappings.doInsertKeymap(ch);
        if (done || charmod)
          return;
        if (ch.startsWith("<") && ch.endsWith(">"))
          return;
        for (let s of ch) {
          let code = s.codePointAt(0);
          if (code == 65533)
            return;
          if (code < 32 || code >= 127 && code <= 159)
            return;
          await this.prompt.acceptCharacter(s);
        }
      }
      async onNormalInput(ch, _charmod) {
        if (mouseKeys.includes(ch)) {
          await this.onMouseEvent(ch);
          return;
        }
        let used = await this.mappings.doNormalKeymap(ch);
        if (!used)
          await this.feedkeys(ch);
      }
      onMouseEvent(key) {
        if (this.session)
          return this.session.onMouseEvent(key);
      }
      async feedkeys(key, remap = true) {
        let { nvim } = this;
        key = key.startsWith("<") && key.endsWith(">") ? `\\${key}` : key;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.call("eval", [`feedkeys("${key}", "${remap ? "i" : "in"}")`]);
        this.prompt.start();
      }
      async command(command) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.command(command);
        this.prompt.start();
      }
      async normal(command, bang = true) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.command(`normal${bang ? "!" : ""} ${command}`);
        this.prompt.start();
      }
      async call(fname) {
        if (this.session)
          return await this.session.call(fname);
      }
      get session() {
        return this.lastSession;
      }
      registerList(list2) {
        const { name: name2 } = list2;
        let exists = this.listMap.get(name2);
        if (this.listMap.has(name2)) {
          if (exists) {
            if (typeof exists.dispose == "function") {
              exists.dispose();
            }
            this.listMap.delete(name2);
          }
          window_default.showMessage(`list "${name2}" recreated.`);
        }
        this.listMap.set(name2, list2);
        let config = workspace_default.getConfiguration(`list.source.${name2}`);
        let defaultAction = config.get("defaultAction");
        if (defaultAction && list2.actions.find((o) => o.name == defaultAction)) {
          list2.defaultAction = defaultAction;
        }
        extensions_default.addSchemeProperty(`list.source.${name2}.defaultAction`, {
          type: "string",
          default: null,
          description: `Default default action of "${name2}" list.`
        });
        extensions_default.addSchemeProperty(`list.source.${name2}.defaultOptions`, {
          type: "array",
          default: list2.interactive ? ["--interactive"] : [],
          description: `Default list options of "${name2}" list, only used when both list option and argument are empty.`,
          uniqueItems: true,
          items: {
            type: "string",
            enum: [
              "--top",
              "--normal",
              "--no-sort",
              "--input",
              "--tab",
              "--strict",
              "--regex",
              "--ignore-case",
              "--number-select",
              "--interactive",
              "--auto-preview",
              "--first",
              "--no-quit"
            ]
          }
        });
        extensions_default.addSchemeProperty(`list.source.${name2}.defaultArgs`, {
          type: "array",
          default: [],
          description: `Default argument list of "${name2}" list, only used when list argument is empty.`,
          uniqueItems: true,
          items: { type: "string" }
        });
        return import_vscode_languageserver_protocol70.Disposable.create(() => {
          if (typeof list2.dispose == "function") {
            list2.dispose();
          }
          this.listMap.delete(name2);
        });
      }
      get names() {
        return Array.from(this.listMap.keys());
      }
      get descriptions() {
        let d = {};
        for (let name2 of this.listMap.keys()) {
          let list2 = this.listMap.get(name2);
          d[name2] = list2.description;
        }
        return d;
      }
      async loadItems(name2) {
        let args = [name2];
        let res = this.parseArgs(args);
        if (!res)
          return;
        let { list: list2, options, listArgs } = res;
        let source = new import_vscode_languageserver_protocol70.CancellationTokenSource();
        let token = source.token;
        let arr = await this.nvim.eval('[win_getid(),bufnr("%")]');
        let items = await list2.loadItems({
          options,
          args: listArgs,
          input: "",
          cwd: workspace_default.cwd,
          window: this.nvim.createWindow(arr[0]),
          buffer: this.nvim.createBuffer(arr[1]),
          listWindow: null
        }, token);
        return items;
      }
      toggleMode() {
        let lastSession = this.lastSession;
        if (lastSession)
          lastSession.toggleMode();
      }
      get isActivated() {
        var _a2;
        return ((_a2 = this.session) == null ? void 0 : _a2.winid) != null;
      }
      stop() {
        let lastSession = this.lastSession;
        if (lastSession)
          lastSession.stop();
      }
      dispose() {
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        if (this.config) {
          this.config.dispose();
        }
        this.lastSession = void 0;
        disposeAll(this.disposables);
      }
    };
    manager_default2 = new ListManager();
  }
});

// src/snippets/string.ts
var SnippetString;
var init_string2 = __esm({
  "src/snippets/string.ts"() {
    SnippetString = class {
      constructor(value) {
        this._tabstop = 1;
        this.value = value || "";
      }
      static isSnippetString(thing) {
        if (thing instanceof SnippetString) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return typeof thing.value === "string";
      }
      static _escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      appendText(str) {
        this.value += SnippetString._escape(str);
        return this;
      }
      appendTabstop(num = this._tabstop++) {
        this.value += "$";
        this.value += num;
        return this;
      }
      appendPlaceholder(value, num = this._tabstop++) {
        if (typeof value === "function") {
          const nested = new SnippetString();
          nested._tabstop = this._tabstop;
          value(nested);
          this._tabstop = nested._tabstop;
          value = nested.value;
        } else {
          value = SnippetString._escape(value);
        }
        this.value += "${";
        this.value += num;
        this.value += ":";
        this.value += value;
        this.value += "}";
        return this;
      }
      appendChoice(values, num = this._tabstop++) {
        const value = values.map((s) => s.replace(/\$|}|\\|,/g, "\\$&")).join(",");
        this.value += "${";
        this.value += num;
        this.value += "|";
        this.value += value;
        this.value += "|}";
        return this;
      }
      appendVariable(name2, defaultValue) {
        if (typeof defaultValue === "function") {
          const nested = new SnippetString();
          nested._tabstop = this._tabstop;
          defaultValue(nested);
          this._tabstop = nested._tabstop;
          defaultValue = nested.value;
        } else if (typeof defaultValue === "string") {
          defaultValue = defaultValue.replace(/\$|}/g, "\\$&");
        }
        this.value += "${";
        this.value += name2;
        if (defaultValue) {
          this.value += ":";
          this.value += defaultValue;
        }
        this.value += "}";
        return this;
      }
    };
  }
});

// src/tree/index.ts
var init_tree = __esm({
  "src/tree/index.ts"() {
    init_TreeItem();
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BasicList: () => BasicList,
  Buffer: () => import_neovim.Buffer,
  CancellationToken: () => import_vscode_languageserver_protocol71.CancellationToken,
  CancellationTokenSource: () => import_vscode_languageserver_protocol71.CancellationTokenSource,
  ClientState: () => ClientState,
  CloseAction: () => CloseAction,
  CodeActionKind: () => import_vscode_languageserver_protocol71.CodeActionKind,
  CompletionItemKind: () => import_vscode_languageserver_protocol71.CompletionItemKind,
  CompletionTriggerKind: () => import_vscode_languageserver_protocol71.CompletionTriggerKind,
  ConfigurationTarget: () => ConfigurationTarget,
  Diagnostic: () => import_vscode_languageserver_protocol71.Diagnostic,
  DiagnosticSeverity: () => import_vscode_languageserver_protocol71.DiagnosticSeverity,
  DiagnosticTag: () => import_vscode_languageserver_protocol71.DiagnosticTag,
  Disposable: () => import_vscode_languageserver_protocol71.Disposable,
  DocumentHighlightKind: () => import_vscode_languageserver_protocol71.DocumentHighlightKind,
  Emitter: () => import_vscode_languageserver_protocol71.Emitter,
  ErrorAction: () => ErrorAction,
  Event: () => import_vscode_languageserver_protocol71.Event,
  FileChangeType: () => import_vscode_languageserver_protocol71.FileChangeType,
  FileType: () => FileType,
  FloatFactory: () => FloatFactory,
  Highligher: () => Highlighter,
  InsertTextFormat: () => import_vscode_languageserver_protocol71.InsertTextFormat,
  LanguageClient: () => LanguageClient,
  Location: () => import_vscode_languageserver_protocol71.Location,
  LocationLink: () => import_vscode_languageserver_protocol71.LocationLink,
  MarkupKind: () => import_vscode_languageserver_protocol71.MarkupKind,
  MessageLevel: () => MessageLevel,
  MessageTransports: () => MessageTransports,
  Mru: () => Mru,
  Mutex: () => Mutex,
  Neovim: () => import_neovim.Neovim,
  NotificationType: () => import_vscode_languageserver_protocol71.NotificationType,
  NotificationType0: () => import_vscode_languageserver_protocol71.NotificationType0,
  NullLogger: () => NullLogger,
  PatternType: () => PatternType,
  Position: () => import_vscode_languageserver_protocol71.Position,
  ProgressType: () => import_vscode_languageserver_protocol71.ProgressType,
  Range: () => import_vscode_languageserver_protocol71.Range,
  RequestType: () => import_vscode_languageserver_protocol71.RequestType,
  RequestType0: () => import_vscode_languageserver_protocol71.RequestType0,
  RevealOutputChannelOn: () => RevealOutputChannelOn,
  ServiceStat: () => ServiceStat,
  SettingMonitor: () => SettingMonitor,
  SignatureHelpTriggerKind: () => import_vscode_languageserver_protocol71.SignatureHelpTriggerKind,
  SnippetString: () => SnippetString,
  SourceType: () => SourceType,
  State: () => State2,
  SymbolKind: () => import_vscode_languageserver_protocol71.SymbolKind,
  TextDocumentFeature: () => TextDocumentFeature,
  TextEdit: () => import_vscode_languageserver_protocol71.TextEdit,
  TransportKind: () => TransportKind,
  TreeItem: () => TreeItem,
  TreeItemCollapsibleState: () => TreeItemCollapsibleState,
  Uri: () => URI,
  Watchman: () => Watchman,
  Window: () => import_neovim.Window,
  ansiparse: () => ansiparse,
  commands: () => commands_default,
  concurrent: () => concurrent,
  diagnosticManager: () => manager_default,
  disposeAll: () => disposeAll,
  download: () => download,
  events: () => events_default,
  executable: () => executable,
  extensions: () => extensions_default,
  fetch: () => fetch,
  isRunning: () => isRunning,
  languages: () => languages_default,
  listManager: () => manager_default2,
  runCommand: () => runCommand,
  services: () => services_default,
  snippetManager: () => manager_default3,
  sources: () => sources_default,
  wait: () => wait,
  watchFile: () => watchFile,
  window: () => window_default,
  workspace: () => workspace_default
});
var import_neovim, import_vscode_languageserver_protocol71;
var init_src = __esm({
  "src/index.ts"() {
    init_commands2();
    init_events();
    init_languages();
    init_mru();
    init_floatFactory();
    init_fetch();
    init_download();
    init_highligher();
    init_services();
    init_sources2();
    init_workspace();
    init_window();
    init_extensions2();
    init_manager3();
    init_manager4();
    init_string2();
    init_manager();
    init_ansiparse();
    init_watchman();
    init_basic();
    init_mutex();
    init_esm2();
    import_neovim = __toModule(require_lib6());
    import_vscode_languageserver_protocol71 = __toModule(require_main2());
    init_types();
    init_language_client();
    init_util();
    init_tree();
  }
});

// src/util/factory.ts
function removedGlobalStub(name2) {
  return () => {
    throw new Error(`process.${name2}() is not allowed in extension sandbox`);
  };
}
function makeRequireFunction() {
  const req = (p) => {
    if (p === "coc.nvim") {
      return init_src(), src_exports;
    }
    return this.require(p);
  };
  req.resolve = (request2) => Module._resolveFilename(request2, this);
  req.main = process.mainModule;
  req.extensions = Module._extensions;
  req.cache = Module._cache;
  return req;
}
function compileInSandbox(sandbox) {
  return function(content, filename) {
    const require2 = makeRequireFunction.call(this);
    const dirname3 = import_path29.default.dirname(filename);
    const newContent = content.replace(/^\#\!.*/, "");
    const wrapper = Module.wrap(newContent);
    const compiledWrapper = vm.runInContext(wrapper, sandbox, { filename });
    const args = [this.exports, require2, this, filename, dirname3];
    return compiledWrapper.apply(this.exports, args);
  };
}
function createSandbox(filename, logger113) {
  const module2 = new Module(filename);
  module2.paths = Module._nodeModulePaths(filename);
  const sandbox = vm.createContext({
    module: module2,
    Buffer,
    console: {
      debug: (...args) => {
        logger113.debug.apply(logger113, args);
      },
      log: (...args) => {
        logger113.info.apply(logger113, args);
      },
      error: (...args) => {
        logger113.error.apply(logger113, args);
      },
      info: (...args) => {
        logger113.info.apply(logger113, args);
      },
      warn: (...args) => {
        logger113.warn.apply(logger113, args);
      }
    }
  });
  defaults(sandbox, global);
  sandbox.Reflect = Reflect;
  sandbox.require = function sandboxRequire(p) {
    const oldCompile = Module.prototype._compile;
    Module.prototype._compile = compileInSandbox(sandbox);
    const moduleExports = sandbox.module.require(p);
    Module.prototype._compile = oldCompile;
    return moduleExports;
  };
  sandbox.process = new process.constructor();
  for (let key of Object.keys(process)) {
    sandbox.process[key] = process[key];
  }
  REMOVED_GLOBALS.forEach((name2) => {
    sandbox.process[name2] = removedGlobalStub(name2);
  });
  sandbox.process["chdir"] = () => {
  };
  sandbox.process.umask = (mask) => {
    if (typeof mask !== "undefined") {
      throw new Error("Cannot use process.umask() to change mask (read-only)");
    }
    return process.umask();
  };
  return sandbox;
}
function createExtension(id, filename, isEmpty2 = false) {
  if (isEmpty2 || !import_fs27.default.existsSync(filename))
    return {
      activate: () => {
      },
      deactivate: null
    };
  const sandbox = createSandbox(filename, createLogger(`extension:${id}`));
  delete Module._cache[require.resolve(filename)];
  const defaultImport = sandbox.require(filename);
  const activate = defaultImport && defaultImport.activate || defaultImport;
  if (typeof activate !== "function") {
    return { activate: () => {
    }, deactivate: null };
  }
  return {
    activate,
    deactivate: typeof defaultImport.deactivate === "function" ? defaultImport.deactivate : null
  };
}
var import_fs27, import_path29, vm, createLogger, logger70, Module, REMOVED_GLOBALS;
var init_factory = __esm({
  "src/util/factory.ts"() {
    import_fs27 = __toModule(require("fs"));
    import_path29 = __toModule(require("path"));
    vm = __toModule(require("vm"));
    init_lodash();
    createLogger = require_logger2();
    logger70 = createLogger("util-factoroy");
    Module = require("module");
    REMOVED_GLOBALS = [
      "reallyExit",
      "abort",
      "umask",
      "setuid",
      "setgid",
      "setgroups",
      "_fatalException",
      "exit",
      "kill"
    ];
  }
});

// src/extensions.ts
var import_debounce8, import_fs_extra9, import_isuri2, import_path30, import_semver2, import_vscode_languageserver_protocol72, import_which4, import_extensions7, createLogger2, logger71, ExtensionType, Extensions, extensions_default;
var init_extensions2 = __esm({
  "src/extensions.ts"() {
    import_debounce8 = __toModule(require_debounce());
    init_main3();
    import_fs_extra9 = __toModule(require_lib5());
    import_isuri2 = __toModule(require_isuri());
    import_path30 = __toModule(require("path"));
    import_semver2 = __toModule(require_semver2());
    import_vscode_languageserver_protocol72 = __toModule(require_main2());
    init_esm2();
    import_which4 = __toModule(require_which());
    init_commands2();
    init_events();
    init_db();
    init_floatFactory();
    init_installBuffer();
    init_installer();
    init_memos();
    init_util();
    init_array();
    import_extensions7 = __toModule(require_extensions());
    init_factory();
    init_fs();
    init_is();
    init_watchman();
    init_workspace();
    init_window();
    createLogger2 = require_logger2();
    logger71 = createLogger2("extensions");
    (function(ExtensionType2) {
      ExtensionType2[ExtensionType2["Global"] = 0] = "Global";
      ExtensionType2[ExtensionType2["Local"] = 1] = "Local";
      ExtensionType2[ExtensionType2["SingleFile"] = 2] = "SingleFile";
      ExtensionType2[ExtensionType2["Internal"] = 3] = "Internal";
    })(ExtensionType || (ExtensionType = {}));
    Extensions = class {
      constructor() {
        this.extensions = new Map();
        this.disabled = new Set();
        this._onDidLoadExtension = new import_vscode_languageserver_protocol72.Emitter();
        this._onDidActiveExtension = new import_vscode_languageserver_protocol72.Emitter();
        this._onDidUnloadExtension = new import_vscode_languageserver_protocol72.Emitter();
        this._additionalSchemes = {};
        this.activated = false;
        this.disposables = [];
        this.ready = true;
        this.onDidLoadExtension = this._onDidLoadExtension.event;
        this.onDidActiveExtension = this._onDidActiveExtension.event;
        this.onDidUnloadExtension = this._onDidUnloadExtension.event;
        let folder = global.hasOwnProperty("__TEST__") ? import_path30.default.join(__dirname, "__tests__") : process.env.COC_DATA_HOME;
        let root = this.root = import_path30.default.join(folder, "extensions");
        if (!import_fs_extra9.default.existsSync(root)) {
          import_fs_extra9.default.mkdirpSync(root);
        }
        let jsonFile = import_path30.default.join(root, "package.json");
        if (!import_fs_extra9.default.existsSync(jsonFile)) {
          import_fs_extra9.default.writeFileSync(jsonFile, '{"dependencies":{}}', "utf8");
        }
        let filepath = import_path30.default.join(root, "db.json");
        this.db = new DB(filepath);
      }
      get outputChannel() {
        if (this._outputChannel)
          return this._outputChannel;
        this._outputChannel = window_default.createOutputChannel("extensions");
        return this._outputChannel;
      }
      async init() {
        let extensionObj = this.db.fetch("extension") || {};
        let keys = Object.keys(extensionObj);
        for (let key of keys) {
          if (extensionObj[key].disabled == true) {
            this.disabled.add(key);
          }
        }
        if (process.env.COC_NO_PLUGINS)
          return;
        let stats = await this.globalExtensionStats();
        let localStats = await this.localExtensionStats(stats.map((o) => o.id));
        stats = stats.concat(localStats);
        this.memos = new Memos(import_path30.default.resolve(this.root, "../memos.json"));
        stats.map((stat) => {
          let extensionType = stat.isLocal ? 1 : 0;
          try {
            this.createExtension(stat.root, stat.packageJSON, extensionType);
          } catch (e) {
            logger71.error(`Error on create ${stat.root}:`, e);
          }
        });
        await this.loadFileExtensions();
        commands_default.register({
          id: "extensions.forceUpdateAll",
          execute: async () => {
            let arr = await this.cleanExtensions();
            logger71.info(`Force update extensions: ${arr}`);
            await this.installExtensions(arr);
          }
        }, false, "remove all global extensions and install them");
        workspace_default.onDidRuntimePathChange(async (paths) => {
          for (let p of paths) {
            if (p && this.checkDirectory(p) === true) {
              await this.loadExtension(p);
            }
          }
        }, null, this.disposables);
      }
      activateExtensions() {
        this.activated = true;
        for (let item of this.extensions.values()) {
          let { id, packageJSON } = item.extension;
          this.setupActiveEvents(id, packageJSON).logError();
        }
        let floatFactory = new FloatFactory(workspace_default.nvim);
        events_default.on("CursorMoved", (0, import_debounce8.debounce)(async (bufnr) => {
          if (this.installBuffer && bufnr == this.installBuffer.bufnr) {
            let lnum = await workspace_default.nvim.call("line", ["."]);
            let msgs = this.installBuffer.getMessages(lnum - 1);
            let docs = msgs && msgs.length ? [{ content: msgs.join("\n"), filetype: "txt" }] : [];
            await floatFactory.show(docs, { modes: ["n"] });
          }
        }, 500));
        if (global.hasOwnProperty("__TEST__"))
          return;
        this.checkExtensions().logError();
        let config = workspace_default.getConfiguration("coc.preferences");
        let interval = config.get("extensionUpdateCheck", "never");
        let silent = config.get("silentAutoupdate", true);
        if (interval != "never") {
          let now = new Date();
          let day = new Date(now.getFullYear(), now.getMonth(), now.getDate() - (interval == "daily" ? 0 : 7));
          let ts = this.db.fetch("lastUpdate");
          if (ts && Number(ts) > day.getTime())
            return;
          this.outputChannel.appendLine("Start auto update...");
          this.updateExtensions(false, silent).logError();
        }
      }
      async updateExtensions(sync, silent = false) {
        if (!this.npm)
          return;
        let lockedList = await this.getLockedList();
        let stats = await this.globalExtensionStats();
        stats = stats.filter((o) => ![...lockedList, ...this.disabled].includes(o.id));
        this.db.push("lastUpdate", Date.now());
        if (silent) {
          window_default.showMessage("Updating extensions, checkout output:///extensions for details.", "more");
        }
        let installBuffer = this.installBuffer = new InstallBuffer(true, sync, silent ? this.outputChannel : void 0);
        installBuffer.setExtensions(stats.map((o) => o.id));
        await installBuffer.show(workspace_default.nvim);
        let createInstaller = createInstallerFactory(this.npm, this.modulesFolder);
        let fn = (stat) => {
          let { id } = stat;
          installBuffer.startProgress([id]);
          let url = stat.exotic ? stat.uri : null;
          let installer = createInstaller(id);
          installer.on("message", (msg, isProgress) => {
            installBuffer.addMessage(id, msg, isProgress);
          });
          return installer.update(url).then((directory) => {
            installBuffer.finishProgress(id, true);
            if (directory) {
              this.loadExtension(directory).logError();
            }
          }, (err) => {
            installBuffer.addMessage(id, err.message);
            installBuffer.finishProgress(id, false);
          });
        };
        await concurrent(stats, fn, silent ? 1 : 3);
      }
      async checkExtensions() {
        let { globalExtensions } = workspace_default.env;
        if (globalExtensions && globalExtensions.length) {
          let names = this.filterGlobalExtensions(globalExtensions);
          this.installExtensions(names).logError();
        }
      }
      get installer() {
        return createInstallerFactory(this.npm, this.modulesFolder);
      }
      async installExtensions(list2 = []) {
        let { npm } = this;
        if (!npm || !list2.length)
          return;
        list2 = distinct(list2);
        let installBuffer = this.installBuffer = new InstallBuffer();
        installBuffer.setExtensions(list2);
        await installBuffer.show(workspace_default.nvim);
        let createInstaller = createInstallerFactory(this.npm, this.modulesFolder);
        let fn = (key) => {
          installBuffer.startProgress([key]);
          let installer = createInstaller(key);
          installer.on("message", (msg, isProgress) => {
            installBuffer.addMessage(key, msg, isProgress);
          });
          return installer.install().then((name2) => {
            installBuffer.finishProgress(key, true);
            let directory = import_path30.default.join(this.modulesFolder, name2);
            this.loadExtension(directory).logError();
          }, (err) => {
            installBuffer.addMessage(key, err.message);
            installBuffer.finishProgress(key, false);
            logger71.error(`Error on install ${key}`, err);
          });
        };
        await concurrent(list2, fn);
      }
      getMissingExtensions() {
        let json = this.loadJson() || { dependencies: {} };
        let ids = [];
        for (let key of Object.keys(json.dependencies)) {
          let folder = import_path30.default.join(this.modulesFolder, key);
          if (!import_fs_extra9.default.existsSync(folder)) {
            let val = json.dependencies[key];
            if (val.startsWith("http")) {
              ids.push(val);
            } else {
              ids.push(key);
            }
          }
        }
        return ids;
      }
      get npm() {
        let npm = workspace_default.getConfiguration("npm").get("binPath", "npm");
        npm = workspace_default.expand(npm);
        for (let exe of [npm, "yarnpkg", "yarn", "npm"]) {
          try {
            let res = import_which4.default.sync(exe);
            return res;
          } catch (e) {
            continue;
          }
        }
        window_default.showMessage(`Can't find npm or yarn in your $PATH`, "error");
        return null;
      }
      get all() {
        return Array.from(this.extensions.values()).map((o) => o.extension).filter((o) => !this.isDisabled(o.id));
      }
      getExtension(id) {
        return this.extensions.get(id);
      }
      getExtensionState(id) {
        let disabled = this.isDisabled(id);
        if (disabled)
          return "disabled";
        let item = this.extensions.get(id);
        if (!item)
          return "unknown";
        let { extension } = item;
        return extension.isActive ? "activated" : "loaded";
      }
      async getExtensionStates() {
        let localStats = await this.localExtensionStats([]);
        let globalStats = await this.globalExtensionStats();
        return localStats.concat(globalStats.filter((o) => localStats.find((s) => s.id == o.id) == null));
      }
      async getLockedList() {
        let obj = await this.db.fetch("extension");
        obj = obj || {};
        return Object.keys(obj).filter((id) => obj[id].locked === true);
      }
      async toggleLock(id) {
        let key = `extension.${id}.locked`;
        let locked = await this.db.fetch(key);
        if (locked) {
          this.db.delete(key);
        } else {
          this.db.push(key, true);
        }
      }
      async toggleExtension(id) {
        let state = this.getExtensionState(id);
        if (state == null)
          return;
        if (state == "activated") {
          await this.deactivate(id);
        }
        let key = `extension.${id}.disabled`;
        this.db.push(key, state == "disabled" ? false : true);
        if (state != "disabled") {
          this.disabled.add(id);
          await this.unloadExtension(id);
        } else {
          this.disabled.delete(id);
          let folder = import_path30.default.join(this.modulesFolder, id);
          if (import_fs_extra9.default.existsSync(folder)) {
            await this.loadExtension(folder);
          }
        }
        await wait(200);
      }
      async reloadExtension(id) {
        let item = this.extensions.get(id);
        if (!item) {
          window_default.showMessage(`Extension ${id} not registered`, "error");
          return;
        }
        if (item.type == 3) {
          window_default.showMessage(`Can't reload internal extension "${item.id}"`, "warning");
          return;
        }
        if (item.type == 2) {
          await this.loadExtensionFile(item.filepath);
        } else if (item.directory) {
          await this.loadExtension(item.directory);
        } else {
          window_default.showMessage(`Can't reload extension ${item.id}`, "warning");
        }
      }
      async cleanExtensions() {
        let dir = this.modulesFolder;
        if (!import_fs_extra9.default.existsSync(dir))
          return [];
        let ids = this.globalExtensions;
        let res = [];
        for (let id of ids) {
          let directory = import_path30.default.join(dir, id);
          let stat = await import_fs_extra9.default.lstat(directory);
          if (!stat || stat && stat.isSymbolicLink())
            continue;
          await this.unloadExtension(id);
          await import_fs_extra9.default.remove(directory);
          res.push(id);
        }
        return res;
      }
      async uninstallExtension(ids) {
        try {
          if (!ids.length)
            return;
          let [globals2, filtered] = splitArray(ids, (id) => this.globalExtensions.includes(id));
          if (filtered.length) {
            window_default.showMessage(`Extensions ${filtered} not global extensions, can't uninstall!`, "warning");
          }
          let json = this.loadJson() || { dependencies: {} };
          for (let id of globals2) {
            await this.unloadExtension(id);
            delete json.dependencies[id];
            let folder = import_path30.default.join(this.modulesFolder, id);
            if (import_fs_extra9.default.existsSync(folder)) {
              await import_fs_extra9.default.remove(folder);
            }
          }
          const sortedObj = { dependencies: {} };
          Object.keys(json.dependencies).sort().forEach((k) => {
            sortedObj.dependencies[k] = json.dependencies[k];
          });
          let jsonFile = import_path30.default.join(this.root, "package.json");
          import_fs_extra9.default.writeFileSync(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: "utf8" });
          window_default.showMessage(`Removed: ${globals2.join(" ")}`);
        } catch (e) {
          window_default.showMessage(`Uninstall failed: ${e.message}`, "error");
        }
      }
      isDisabled(id) {
        return this.disabled.has(id);
      }
      has(id) {
        return this.extensions.has(id);
      }
      isActivated(id) {
        let item = this.extensions.get(id);
        if (item && item.extension.isActive) {
          return true;
        }
        return false;
      }
      async loadExtension(folder) {
        try {
          let parentFolder = import_path30.default.dirname(folder);
          let isLocal = import_path30.default.normalize(parentFolder) != import_path30.default.normalize(this.modulesFolder);
          let jsonFile = import_path30.default.join(folder, "package.json");
          let packageJSON = JSON.parse(import_fs_extra9.default.readFileSync(jsonFile, "utf8"));
          let { name: name2 } = packageJSON;
          if (this.isDisabled(name2))
            return false;
          await this.unloadExtension(name2);
          this.createExtension(folder, Object.freeze(packageJSON), isLocal ? 1 : 0);
          return true;
        } catch (e) {
          window_default.showMessage(`Error on load extension from "${folder}": ${e.message}`, "error");
          logger71.error(`Error on load extension from ${folder}`, e);
          return false;
        }
      }
      async loadFileExtensions() {
        if (!process.env.COC_VIMCONFIG)
          return;
        let folder = import_path30.default.join(process.env.COC_VIMCONFIG, "coc-extensions");
        if (!import_fs_extra9.default.existsSync(folder))
          return;
        let files = await import_fs_extra9.default.readdir(folder);
        files = files.filter((f) => f.endsWith(".js"));
        for (let file of files) {
          await this.loadExtensionFile(import_path30.default.join(folder, file));
        }
      }
      loadedExtensions() {
        return Array.from(this.extensions.keys());
      }
      async watchExtension(id) {
        let item = this.extensions.get(id);
        if (!item) {
          window_default.showMessage(`extension ${id} not found`, "error");
          return;
        }
        if (id.startsWith("single-")) {
          window_default.showMessage(`watching ${item.filepath}`);
          this.disposables.push(watchFile(item.filepath, async () => {
            await this.loadExtensionFile(item.filepath);
            window_default.showMessage(`reloaded ${id}`);
          }));
        } else {
          let watchmanPath = workspace_default.getWatchmanPath();
          if (!watchmanPath) {
            window_default.showMessage("watchman not found", "error");
            return;
          }
          let client = await Watchman.createClient(watchmanPath, item.directory);
          if (!client) {
            window_default.showMessage(`Can't create watchman client, check output:///watchman`);
            return;
          }
          window_default.showMessage(`watching ${item.directory}`);
          this.disposables.push(client);
          client.subscribe("**/*.js", async () => {
            await this.reloadExtension(id);
            window_default.showMessage(`reloaded ${id}`);
          }).then((disposable) => {
            this.disposables.push(disposable);
          }, (e) => {
            logger71.error(e);
          });
        }
      }
      async loadExtensionFile(filepath) {
        let filename = import_path30.default.basename(filepath);
        let basename = import_path30.default.basename(filepath, ".js");
        let name2 = "single-" + basename;
        if (this.isDisabled(name2))
          return;
        let root = import_path30.default.dirname(filepath);
        let packageJSON = {
          name: name2,
          main: filename,
          engines: { coc: "^0.0.79" }
        };
        let confpath = import_path30.default.join(root, basename + ".json");
        let stat = await statAsync(confpath);
        if (stat && stat.isFile()) {
          let content = await readFile(confpath, "utf8");
          let obj = JSON.parse(content);
          if (obj) {
            let attrs = ["activationEvents", "contributes"];
            for (const attr of attrs) {
              if (obj[attr]) {
                packageJSON[attr] = obj[attr];
              }
            }
          }
        }
        await this.unloadExtension(name2);
        this.createExtension(root, packageJSON, 2);
      }
      async activate(id) {
        if (this.isDisabled(id)) {
          throw new Error(`Extension ${id} is disabled!`);
        }
        let item = this.extensions.get(id);
        if (!item) {
          throw new Error(`Extension ${id} not registered!`);
        }
        let { extension } = item;
        if (extension.isActive)
          return true;
        await Promise.resolve(extension.activate());
        if (extension.isActive) {
          this._onDidActiveExtension.fire(extension);
          return true;
        }
        return false;
      }
      async deactivate(id) {
        let item = this.extensions.get(id);
        if (!item)
          return false;
        await Promise.resolve(item.deactivate());
        return true;
      }
      async call(id, method, args) {
        let item = this.extensions.get(id);
        if (!item)
          throw new Error(`extension ${id} not registered`);
        let { extension } = item;
        if (!extension.isActive) {
          await this.activate(id);
        }
        let { exports: exports2 } = extension;
        if (!exports2 || !exports2.hasOwnProperty(method)) {
          throw new Error(`method ${method} not found on extension ${id}`);
        }
        return await Promise.resolve(exports2[method].apply(null, args));
      }
      getExtensionApi(id) {
        let item = this.extensions.get(id);
        if (!item)
          return null;
        let { extension } = item;
        return extension.isActive ? extension.exports : null;
      }
      registerExtension(extension, deactivate) {
        let { id, packageJSON } = extension;
        this.extensions.set(id, { id, type: 3, extension, deactivate, isLocal: true });
        let { contributes } = packageJSON;
        if (contributes) {
          let { configuration } = contributes;
          if (configuration && configuration.properties) {
            let { properties } = configuration;
            let props = {};
            for (let key of Object.keys(properties)) {
              let val = properties[key].default;
              if (val != null)
                props[key] = val;
            }
            workspace_default.configurations.extendsDefaults(props);
          }
        }
        this._onDidLoadExtension.fire(extension);
        this.setupActiveEvents(id, packageJSON).logError();
      }
      get globalExtensions() {
        let json = this.loadJson();
        if (!json || !json.dependencies)
          return [];
        return Object.keys(json.dependencies);
      }
      async globalExtensionStats() {
        let json = this.loadJson();
        if (!json || !json.dependencies)
          return [];
        let { modulesFolder } = this;
        let res = await Promise.all(Object.keys(json.dependencies).map((key) => new Promise(async (resolve3) => {
          try {
            let val = json.dependencies[key];
            let root = import_path30.default.join(modulesFolder, key);
            let res2 = this.checkDirectory(root);
            if (res2 instanceof Error) {
              window_default.showMessage(`Unable to load global extension at ${root}: ${res2.message}`, "error");
              logger71.error(`Error on load ${root}`, res2);
              return resolve3(null);
            }
            let content = await readFile(import_path30.default.join(root, "package.json"), "utf8");
            root = await import_fs_extra9.default.realpath(root);
            let obj = JSON.parse(content);
            let version2 = obj ? obj.version || "" : "";
            let description = obj ? obj.description || "" : "";
            let uri = import_isuri2.default.isValid(val) ? val : "";
            resolve3({
              id: key,
              isLocal: false,
              version: version2,
              description,
              exotic: /^https?:/.test(val),
              uri: uri.replace(/\.git(#master)?$/, ""),
              root,
              state: this.getExtensionState(key),
              packageJSON: Object.freeze(obj)
            });
          } catch (e) {
            logger71.error(e);
            resolve3(null);
          }
        })));
        return res.filter((info) => info != null);
      }
      async localExtensionStats(excludes) {
        let runtimepath = await workspace_default.nvim.eval("&runtimepath");
        let paths = runtimepath.split(",");
        let res = await Promise.all(paths.map((root) => new Promise(async (resolve3) => {
          try {
            let res2 = this.checkDirectory(root);
            if (res2 !== true)
              return resolve3(null);
            let jsonFile = import_path30.default.join(root, "package.json");
            let content = await readFile(jsonFile, "utf8");
            let obj = JSON.parse(content);
            let exist = this.extensions.get(obj.name);
            if (exist && !exist.isLocal) {
              logger71.info(`Extension "${obj.name}" in runtimepath already loaded.`);
              return resolve3(null);
            }
            if (excludes.includes(obj.name)) {
              logger71.info(`Skipped load vim plugin from "${root}", "${obj.name}" already global extension.`);
              return resolve3(null);
            }
            let version2 = obj ? obj.version || "" : "";
            let description = obj ? obj.description || "" : "";
            resolve3({
              id: obj.name,
              isLocal: true,
              version: version2,
              description,
              exotic: false,
              root,
              state: this.getExtensionState(obj.name),
              packageJSON: Object.freeze(obj)
            });
          } catch (e) {
            logger71.error(e);
            resolve3(null);
          }
        })));
        return res.filter((info) => info != null);
      }
      loadJson() {
        let { root } = this;
        let jsonFile = import_path30.default.join(root, "package.json");
        if (!import_fs_extra9.default.existsSync(jsonFile))
          return null;
        let errors = [];
        let content = import_fs_extra9.default.readFileSync(jsonFile, "utf8");
        let data = parse3(content, errors, { allowTrailingComma: true });
        if (errors && errors.length > 0) {
          window_default.showMessage(`Error on parse ${jsonFile}`, "error");
          workspace_default.nvim.call("coc#util#open_file", ["edit", jsonFile], true);
        }
        return data;
      }
      get schemes() {
        return this._additionalSchemes;
      }
      addSchemeProperty(key, def) {
        this._additionalSchemes[key] = def;
        workspace_default.configurations.extendsDefaults({ [key]: def.default });
      }
      async setupActiveEvents(id, packageJSON) {
        let { activationEvents } = packageJSON;
        if (!this.canActivate(id))
          return;
        if (!activationEvents || Array.isArray(activationEvents) && activationEvents.includes("*")) {
          await this.activate(id).catch((e) => {
            window_default.showMessage(`Error on activate extension ${id}: ${e.message}`);
            this.outputChannel.appendLine(`Error on activate extension ${id}.
${e.message}
 ${e.stack}`);
          });
          return;
        }
        let disposables = [];
        let active = () => {
          disposeAll(disposables);
          return new Promise((resolve3) => {
            if (!this.canActivate(id)) {
              this.outputChannel.appendLine(`Extension ${id} is disabled or not loaded.`);
              return resolve3();
            }
            let timer = setTimeout(() => {
              this.outputChannel.appendLine(`Extension ${id} activate cost more than 1s`);
              resolve3();
            }, 1e3);
            this.activate(id).then(() => {
              clearTimeout(timer);
              resolve3();
            }, (e) => {
              clearTimeout(timer);
              window_default.showMessage(`Error on activate extension ${id}: ${e.message}`);
              this.outputChannel.appendLine(`Error on activate extension ${id}:${e.message}
 ${e.stack}`);
              resolve3();
            });
          });
        };
        for (let eventName of activationEvents) {
          let parts = eventName.split(":");
          let ev = parts[0];
          if (ev == "onLanguage") {
            if (workspace_default.filetypes.has(parts[1])) {
              await active();
              return;
            }
            workspace_default.onDidOpenTextDocument((document2) => {
              if (document2.languageId == parts[1]) {
                void active();
              }
            }, null, disposables);
          } else if (ev == "onCommand") {
            commands_default.onCommandList.push(parts[1]);
            events_default.on("Command", async (command) => {
              if (command == parts[1]) {
                await active();
                await wait(500);
              }
            }, null, disposables);
          } else if (ev == "workspaceContains") {
            let check = async () => {
              let folders = workspace_default.workspaceFolders.map((o) => URI.parse(o.uri).fsPath);
              for (let folder of folders) {
                if (inDirectory(folder, parts[1].split(/\s+/))) {
                  await active();
                  return true;
                }
              }
            };
            let res = await check();
            if (res)
              return;
            workspace_default.onDidChangeWorkspaceFolders(check, null, disposables);
          } else if (ev == "onFileSystem") {
            for (let doc of workspace_default.documents) {
              let u = URI.parse(doc.uri);
              if (u.scheme == parts[1]) {
                await active();
                return;
              }
            }
            workspace_default.onDidOpenTextDocument((document2) => {
              let u = URI.parse(document2.uri);
              if (u.scheme == parts[1]) {
                void active();
              }
            }, null, disposables);
          } else {
            window_default.showMessage(`Unsupported event ${eventName} of ${id}`, "error");
          }
        }
      }
      createExtension(root, packageJSON, type) {
        let id = packageJSON.name;
        let isActive = false;
        let result;
        let filename = import_path30.default.join(root, packageJSON.main || "index.js");
        let ext;
        let subscriptions = [];
        let exports2;
        let extension = {
          activate: () => {
            if (result)
              return result;
            let context = {
              subscriptions,
              extensionPath: root,
              globalState: this.memos.createMemento(`${id}|global`),
              workspaceState: this.memos.createMemento(`${id}|${workspace_default.rootPath}`),
              asAbsolutePath: (relativePath) => import_path30.default.join(root, relativePath),
              storagePath: import_path30.default.join(this.root, `${id}-data`),
              logger: createLogger2(id)
            };
            if (!ext) {
              try {
                let isEmpty2 = !(packageJSON.engines || {}).hasOwnProperty("coc");
                ext = createExtension(id, filename, isEmpty2);
              } catch (e) {
                logger71.error(`Error on createExtension ${id} from ${filename}`, e);
                return;
              }
            }
            result = new Promise((resolve3, reject) => {
              try {
                Promise.resolve(ext.activate(context)).then((res) => {
                  isActive = true;
                  exports2 = res;
                  resolve3(res);
                }, (e) => {
                  logger71.error(`Error on active extension ${id}: ${e.message}`, e);
                  reject(e);
                });
              } catch (e) {
                logger71.error(`Error on active extension ${id}: ${e.stack}`, e);
                reject(e);
              }
            });
            return result;
          }
        };
        Object.defineProperties(extension, {
          id: {
            get: () => id,
            enumerable: true
          },
          packageJSON: {
            get: () => packageJSON,
            enumerable: true
          },
          extensionPath: {
            get: () => root,
            enumerable: true
          },
          isActive: {
            get: () => isActive,
            enumerable: true
          },
          exports: {
            get: () => {
              if (!isActive)
                throw new Error(`Invalid access to exports, extension "${id}" not activated`);
              return exports2;
            },
            enumerable: true
          }
        });
        this.extensions.set(id, {
          id,
          type,
          isLocal: type == 1,
          extension,
          directory: root,
          filepath: filename,
          deactivate: () => {
            if (!isActive)
              return;
            result = void 0;
            exports2 = void 0;
            isActive = false;
            disposeAll(subscriptions);
            subscriptions.splice(0, subscriptions.length);
            subscriptions = [];
            if (ext && ext.deactivate) {
              try {
                return Promise.resolve(ext.deactivate()).catch((e) => {
                  logger71.error(`Error on ${id} deactivate: `, e);
                });
              } catch (e) {
                logger71.error(`Error on ${id} deactivate: `, e);
              }
            }
          }
        });
        let { contributes } = packageJSON;
        if (contributes) {
          let { configuration, rootPatterns, commands } = contributes;
          if (configuration && configuration.properties) {
            let { properties } = configuration;
            let props = {};
            for (let key of Object.keys(properties)) {
              let val = properties[key].default;
              if (val != null)
                props[key] = val;
            }
            workspace_default.configurations.extendsDefaults(props);
          }
          if (rootPatterns && rootPatterns.length) {
            for (let item of rootPatterns) {
              workspace_default.addRootPattern(item.filetype, item.patterns);
            }
          }
          if (commands && commands.length) {
            for (let cmd of commands) {
              commands_default.titles.set(cmd.command, cmd.title);
            }
          }
        }
        this._onDidLoadExtension.fire(extension);
        if (this.activated) {
          this.setupActiveEvents(id, packageJSON).logError();
        }
      }
      filterGlobalExtensions(names) {
        let map = new Map();
        names.forEach((def) => {
          let name2 = this.getExtensionName(def);
          if (name2)
            map.set(name2, def);
        });
        let json = this.loadJson();
        let urls = [];
        let exists = [];
        if (json && json.dependencies) {
          for (let key of Object.keys(json.dependencies)) {
            let val = json.dependencies[key];
            if (typeof val !== "string")
              continue;
            if (import_fs_extra9.default.existsSync(import_path30.default.join(this.modulesFolder, key, "package.json"))) {
              exists.push(key);
              if (/^https?:/.test(val)) {
                urls.push(val);
              }
            }
          }
        }
        for (let name2 of map.keys()) {
          if (this.disabled.has(name2) || this.extensions.has(name2)) {
            map.delete(name2);
            continue;
          }
          if (/^https?:/.test(name2) && urls.some((url) => url.startsWith(name2)) || exists.includes(name2)) {
            map.delete(name2);
          }
        }
        return Array.from(map.values());
      }
      getExtensionName(def) {
        if (/^https?:/.test(def))
          return def;
        if (!def.includes("@"))
          return def;
        return def.replace(/@[\d.]+$/, "");
      }
      get modulesFolder() {
        return import_path30.default.join(this.root, global.hasOwnProperty("__TEST__") ? "" : "node_modules");
      }
      canActivate(id) {
        return !this.disabled.has(id) && this.extensions.has(id);
      }
      async unloadExtension(id) {
        let item = this.extensions.get(id);
        if (item) {
          await this.deactivate(id);
          this.extensions.delete(id);
          this._onDidUnloadExtension.fire(id);
        }
      }
      checkDirectory(folder) {
        try {
          let jsonFile = import_path30.default.join(folder, "package.json");
          if (!import_fs_extra9.default.existsSync(jsonFile))
            throw new Error("package.json not found");
          let packageJSON = JSON.parse(import_fs_extra9.default.readFileSync(jsonFile, "utf8"));
          let { name: name2, engines, main } = packageJSON;
          if (!name2 || !engines)
            throw new Error(`can't find name & engines in package.json`);
          if (!engines || !objectLiteral(engines)) {
            throw new Error(`invalid engines in ${jsonFile}`);
          }
          if (main && !import_fs_extra9.default.existsSync(import_path30.default.join(folder, main))) {
            throw new Error(`main file ${main} not found, you may need to build the project.`);
          }
          let keys = Object.keys(engines);
          if (!keys.includes("coc") && !keys.includes("vscode")) {
            throw new Error(`Engines in package.json doesn't have coc or vscode`);
          }
          if (keys.includes("coc")) {
            let required = engines["coc"].replace(/^\^/, ">=");
            if (!import_semver2.default.satisfies(workspace_default.version, required)) {
              throw new Error(`Please update coc.nvim, ${packageJSON.name} requires coc.nvim ${engines["coc"]}`);
            }
          }
          return true;
        } catch (e) {
          return e;
        }
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    extensions_default = new Extensions();
  }
});

// src/sources/source.ts
var logger72, Source;
var init_source = __esm({
  "src/sources/source.ts"() {
    init_types();
    init_string();
    init_workspace();
    logger72 = require_logger2()("sources-source");
    Source = class {
      constructor(option) {
        this._disabled = false;
        this.nvim = workspace_default.nvim;
        this.name = option.name;
        this.filepath = option.filepath || "";
        this.sourceType = option.sourceType || SourceType.Native;
        this.isSnippet = !!option.isSnippet;
        this.defaults = option;
      }
      get priority() {
        return this.getConfig("priority", 1);
      }
      get triggerOnly() {
        let triggerOnly = this.defaults["triggerOnly"];
        if (typeof triggerOnly == "boolean")
          return triggerOnly;
        if (!this.triggerCharacters && !this.triggerPatterns)
          return false;
        return Array.isArray(this.triggerPatterns) && this.triggerPatterns.length != 0;
      }
      get triggerCharacters() {
        return this.getConfig("triggerCharacters", null);
      }
      get optionalFns() {
        return this.defaults["optionalFns"] || [];
      }
      get triggerPatterns() {
        let patterns = this.getConfig("triggerPatterns", null);
        if (!patterns || patterns.length == 0)
          return null;
        return patterns.map((s) => typeof s === "string" ? new RegExp(s + "$") : s);
      }
      get shortcut() {
        let shortcut = this.getConfig("shortcut", "");
        return shortcut ? shortcut : this.name.slice(0, 3);
      }
      get enable() {
        if (this._disabled)
          return false;
        return this.getConfig("enable", true);
      }
      get filetypes() {
        return this.getConfig("filetypes", null);
      }
      get disableSyntaxes() {
        return this.getConfig("disableSyntaxes", []);
      }
      getConfig(key, defaultValue) {
        let config = workspace_default.getConfiguration(`coc.source.${this.name}`);
        defaultValue = this.defaults.hasOwnProperty(key) ? this.defaults[key] : defaultValue;
        return config.get(key, defaultValue);
      }
      toggle() {
        this._disabled = !this._disabled;
      }
      get firstMatch() {
        return this.getConfig("firstMatch", true);
      }
      get menu() {
        let { shortcut } = this;
        return shortcut ? `[${shortcut}]` : "";
      }
      filterWords(words, opt) {
        let { firstMatch } = this;
        let res = [];
        let { input } = opt;
        let cword = opt.word;
        if (!input.length)
          return [];
        let cFirst = input[0];
        for (let word of words) {
          if (!word || word.length < 3)
            continue;
          if (firstMatch && cFirst != word[0])
            continue;
          if (!firstMatch && cFirst.toLowerCase() != word[0].toLowerCase())
            continue;
          if (word == cword || word == input)
            continue;
          res.push(word);
        }
        return res;
      }
      fixStartcol(opt, valids) {
        let { col, input, line, bufnr } = opt;
        let start = byteSlice(line, 0, col);
        let document2 = workspace_default.getDocument(bufnr);
        if (!document2)
          return col;
        let { chars } = document2;
        for (let i = start.length - 1; i >= 0; i--) {
          let c = start[i];
          if (!chars.isKeywordChar(c) && !valids.includes(c)) {
            break;
          }
          input = `${c}${input}`;
          col = col - 1;
        }
        opt.col = col;
        opt.input = input;
        return col;
      }
      async shouldComplete(opt) {
        let { disableSyntaxes } = this;
        if (opt.synname && disableSyntaxes && disableSyntaxes.length) {
          let synname = (opt.synname || "").toLowerCase();
          if (disableSyntaxes.findIndex((s) => synname.includes(s.toLowerCase())) !== -1) {
            return false;
          }
        }
        let fn = this.defaults["shouldComplete"];
        if (typeof fn === "function")
          return await Promise.resolve(fn.call(this, opt));
        return true;
      }
      async refresh() {
        let fn = this.defaults["refresh"];
        if (typeof fn === "function")
          await Promise.resolve(fn.call(this));
      }
      async onCompleteDone(item, opt) {
        let fn = this.defaults["onCompleteDone"];
        if (typeof fn === "function")
          await Promise.resolve(fn.call(this, item, opt));
      }
      async doComplete(opt, token) {
        let fn = this.defaults["doComplete"];
        if (typeof fn === "function")
          return await Promise.resolve(fn.call(this, opt, token));
        return null;
      }
    };
  }
});

// src/sources/source-language.ts
function getStartColumn(line, items) {
  let first = items[0];
  if (!first.textEdit)
    return null;
  let range = import_vscode_languageserver_protocol73.InsertReplaceEdit.is(first.textEdit) ? first.textEdit.replace : first.textEdit.range;
  let { character } = range.start;
  for (let i = 1; i < Math.min(10, items.length); i++) {
    let o = items[i];
    if (!o.textEdit)
      return null;
    let r = import_vscode_languageserver_protocol73.InsertReplaceEdit.is(o.textEdit) ? o.textEdit.replace : o.textEdit.range;
    if (r.start.character !== character)
      return null;
  }
  return byteIndex(line, character);
}
function getKindString(kind, map, defaultValue = "") {
  return map.get(kind) || defaultValue;
}
function getWord(item, opt, invalidInsertCharacters) {
  let { label, data, insertTextFormat, insertText, textEdit } = item;
  let word;
  let newText;
  if (data && typeof data.word === "string")
    return data.word;
  if (textEdit) {
    let range = import_vscode_languageserver_protocol73.InsertReplaceEdit.is(textEdit) ? textEdit.replace : textEdit.range;
    newText = textEdit.newText;
    if (range && range.start.line == range.end.line) {
      let { line, col, colnr } = opt;
      let character = characterIndex(line, col);
      if (range.start.character > character) {
        let before = line.slice(character, range.start.character);
        newText = before + newText;
      } else {
        let start = line.slice(range.start.character, character);
        if (start.length && newText.startsWith(start)) {
          newText = newText.slice(start.length);
        }
      }
      character = characterIndex(line, colnr - 1);
      if (range.end.character > character) {
        let end = line.slice(character, range.end.character);
        if (newText.endsWith(end)) {
          newText = newText.slice(0, -end.length);
        }
      }
    }
  } else {
    newText = insertText;
  }
  if (insertTextFormat == import_vscode_languageserver_protocol73.InsertTextFormat.Snippet && newText && newText.includes("$")) {
    let parser2 = new SnippetParser();
    let text = parser2.text(newText);
    word = text ? getValidWord(text, invalidInsertCharacters) : label;
  } else {
    word = getValidWord(newText, invalidInsertCharacters) || label;
  }
  return word || "";
}
function getValidWord(text, invalidChars) {
  if (!text)
    return "";
  if (!invalidChars.length)
    return text;
  for (let i = 0; i < text.length; i++) {
    let c = text[i];
    if (invalidChars.includes(c)) {
      return text.slice(0, i);
    }
  }
  return text;
}
var import_vscode_languageserver_protocol73, logger73, LanguageSource;
var init_source_language = __esm({
  "src/sources/source-language.ts"() {
    import_vscode_languageserver_protocol73 = __toModule(require_main2());
    init_commands2();
    init_manager4();
    init_parser2();
    init_position();
    init_string();
    init_window();
    init_workspace();
    logger73 = require_logger2()("source-language");
    LanguageSource = class {
      constructor(name2, shortcut, provider, documentSelector, triggerCharacters, allCommitCharacters, priority, completeConfig) {
        this.name = name2;
        this.shortcut = shortcut;
        this.provider = provider;
        this.documentSelector = documentSelector;
        this.triggerCharacters = triggerCharacters;
        this.allCommitCharacters = allCommitCharacters;
        this.completeConfig = completeConfig;
        this._enabled = true;
        this.resolvedIndexes = new Set();
        this.completeItems = [];
        this.priority = typeof priority === "number" ? priority : completeConfig.priority;
      }
      get enable() {
        return this._enabled;
      }
      toggle() {
        this._enabled = !this._enabled;
      }
      shouldCommit(item, character) {
        let completeItem = this.completeItems[item.index];
        if (!completeItem)
          return false;
        let commitCharacters = [...this.allCommitCharacters, ...completeItem.commitCharacters || []];
        return commitCharacters.includes(character);
      }
      async doComplete(opt, token) {
        let { provider, name: name2 } = this;
        let { triggerCharacter, bufnr } = opt;
        this.filetype = opt.filetype;
        this.resolvedIndexes.clear();
        this.completeItems = [];
        let triggerKind = this.getTriggerKind(opt);
        let position = this.getPosition(opt);
        let context = { triggerKind, option: opt };
        if (triggerKind == import_vscode_languageserver_protocol73.CompletionTriggerKind.TriggerCharacter)
          context.triggerCharacter = triggerCharacter;
        let result;
        try {
          let doc = workspace_default.getDocument(bufnr);
          result = await Promise.resolve(provider.provideCompletionItems(doc.textDocument, position, token, context));
        } catch (e) {
          logger73.error(`Complete "${name2}" error:`, e);
          return null;
        }
        if (!result || token.isCancellationRequested)
          return null;
        let completeItems = Array.isArray(result) ? result : result.items;
        if (!completeItems || completeItems.length == 0)
          return null;
        this.completeItems = completeItems;
        let startcol = getStartColumn(opt.line, completeItems);
        let option = Object.assign({}, opt);
        let prefix;
        if (startcol != null) {
          if (startcol < option.col) {
            prefix = byteSlice(opt.line, startcol, option.col);
          }
          option.col = startcol;
        }
        let items = completeItems.map((o, index) => {
          let item = this.convertVimCompleteItem(o, this.shortcut, option, prefix);
          item.index = index;
          return item;
        });
        let isIncomplete = typeof result["isIncomplete"] === "boolean" ? result["isIncomplete"] : false;
        return { startcol, isIncomplete, items };
      }
      async onCompleteResolve(item, token) {
        let { index } = item;
        let resolving = this.completeItems[index];
        if (!resolving || this.resolvedIndexes.has(index))
          return;
        let hasResolve = typeof this.provider.resolveCompletionItem === "function";
        if (hasResolve) {
          this.resolvedIndexes.add(index);
          try {
            let resolved = await Promise.resolve(this.provider.resolveCompletionItem(Object.assign({}, resolving), token));
            if (!resolved || token.isCancellationRequested) {
              this.resolvedIndexes.delete(index);
            } else if (resolved !== resolving) {
              Object.assign(resolving, resolved);
            }
          } catch (e) {
            this.resolvedIndexes.delete(index);
            logger73.error(`Error on complete resolve: ${e.message}`, e.stack);
          }
        }
        if (typeof item.documentation === "undefined") {
          let { documentation, detail } = resolving;
          if (!documentation && !detail)
            return;
          let docs = [];
          if (detail && !item.detailShown && detail != item.word) {
            detail = detail.replace(/\n\s*/g, " ");
            if (detail.length) {
              let isText = /^[\w-\s.,\t\n]+$/.test(detail);
              docs.push({ filetype: isText ? "txt" : this.filetype, content: detail });
            }
          }
          if (documentation) {
            if (typeof documentation == "string") {
              docs.push({ filetype: "markdown", content: documentation });
            } else if (documentation.value) {
              docs.push({
                filetype: documentation.kind == "markdown" ? "markdown" : "txt",
                content: documentation.value
              });
            }
          }
          item.documentation = docs;
        }
      }
      async onCompleteDone(vimItem, opt) {
        let item = this.completeItems[vimItem.index];
        if (!item)
          return;
        let line = opt.linenr - 1;
        if (item.insertText != null && !item.textEdit) {
          item.textEdit = {
            range: import_vscode_languageserver_protocol73.Range.create(line, opt.col, line, opt.colnr - 1),
            newText: item.insertText
          };
        }
        if (vimItem.line)
          Object.assign(opt, { line: vimItem.line });
        try {
          let isSnippet = await this.applyTextEdit(item, vimItem.word, opt);
          let { additionalTextEdits } = item;
          if (additionalTextEdits && item.textEdit) {
            let r = import_vscode_languageserver_protocol73.InsertReplaceEdit.is(item.textEdit) ? item.textEdit.replace : item.textEdit.range;
            additionalTextEdits = additionalTextEdits.filter((edit2) => {
              let er = import_vscode_languageserver_protocol73.InsertReplaceEdit.is(edit2) ? edit2.replace : edit2.range;
              if (rangeOverlap(r, er)) {
                logger73.error("Filtered overlap additionalTextEdit:", edit2);
                return false;
              }
              return true;
            });
          }
          await this.applyAdditionalEdits(additionalTextEdits, opt.bufnr, isSnippet);
          if (isSnippet)
            await manager_default3.selectCurrentPlaceholder();
          if (item.command && commands_default.has(item.command.command)) {
            void commands_default.execute(item.command);
          }
        } catch (e) {
          logger73.error("Error on CompleteDone:", e);
        }
      }
      async applyTextEdit(item, word, option) {
        let { nvim } = workspace_default;
        let { textEdit } = item;
        if (!textEdit)
          return false;
        let { line, bufnr, linenr } = option;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return false;
        let newText = textEdit.newText;
        let range = import_vscode_languageserver_protocol73.InsertReplaceEdit.is(textEdit) ? textEdit.replace : textEdit.range;
        let isSnippet = item.insertTextFormat === import_vscode_languageserver_protocol73.InsertTextFormat.Snippet;
        let start = line.substr(0, range.start.character);
        let end = line.substr(range.end.character);
        if (isSnippet && this.completeConfig.snippetsSupport === false) {
          isSnippet = false;
          newText = word;
        }
        if (isSnippet) {
          let currline = doc.getline(linenr - 1);
          let endCharacter = currline.length - end.length;
          let r = import_vscode_languageserver_protocol73.Range.create(linenr - 1, range.start.character, linenr - 1, endCharacter);
          return await manager_default3.insertSnippet(newText, false, r, item.insertTextMode);
        }
        let newLines = `${start}${newText}${end}`.split(/\r?\n/);
        if (newLines.length == 1) {
          await nvim.call("coc#util#setline", [linenr, newLines[0]]);
          await window_default.moveTo(import_vscode_languageserver_protocol73.Position.create(linenr - 1, (start + newText).length));
        } else {
          let buffer = nvim.createBuffer(bufnr);
          await buffer.setLines(newLines, {
            start: linenr - 1,
            end: linenr,
            strictIndexing: false
          });
          let line2 = linenr - 1 + newLines.length - 1;
          let character = newLines[newLines.length - 1].length - end.length;
          await window_default.moveTo({ line: line2, character });
        }
        return false;
      }
      getTriggerKind(opt) {
        let { triggerCharacters } = this;
        let isTrigger = triggerCharacters.includes(opt.triggerCharacter);
        let triggerKind = import_vscode_languageserver_protocol73.CompletionTriggerKind.Invoked;
        if (opt.triggerForInComplete) {
          triggerKind = import_vscode_languageserver_protocol73.CompletionTriggerKind.TriggerForIncompleteCompletions;
        } else if (isTrigger) {
          triggerKind = import_vscode_languageserver_protocol73.CompletionTriggerKind.TriggerCharacter;
        }
        return triggerKind;
      }
      async applyAdditionalEdits(textEdits, bufnr, snippet) {
        if (!textEdits || textEdits.length == 0)
          return;
        let document2 = workspace_default.getDocument(bufnr);
        if (!document2)
          return;
        await document2.patchChange(true);
        let changed = null;
        let pos = await window_default.getCursorPosition();
        if (!snippet)
          changed = getChangedFromEdits(pos, textEdits);
        await document2.applyEdits(textEdits);
        if (changed)
          await window_default.moveTo(import_vscode_languageserver_protocol73.Position.create(pos.line + changed.line, pos.character + changed.character));
      }
      convertVimCompleteItem(item, shortcut, opt, prefix) {
        var _a2;
        let { echodocSupport, detailMaxLength, invalidInsertCharacters, detailField, labels, defaultKindText } = this.completeConfig;
        let hasAdditionalEdit = item.additionalTextEdits && item.additionalTextEdits.length > 0;
        let isSnippet = item.insertTextFormat === import_vscode_languageserver_protocol73.InsertTextFormat.Snippet || hasAdditionalEdit;
        let label = item.label.trim();
        let obj = {
          word: getWord(item, opt, invalidInsertCharacters),
          abbr: label,
          menu: `[${shortcut}]`,
          kind: getKindString(item.kind, labels, defaultKindText),
          sortText: item.sortText || null,
          sourceScore: item["score"] || null,
          filterText: item.filterText || label,
          isSnippet,
          dup: item.data && item.data.dup == 0 ? 0 : 1
        };
        if (prefix) {
          if (!obj.filterText.startsWith(prefix)) {
            if (item.textEdit && item.textEdit.newText.startsWith(prefix)) {
              obj.filterText = item.textEdit.newText.split(/\r?\n/)[0];
            }
          }
          if (!item.textEdit && !obj.word.startsWith(prefix)) {
            obj.word = `${prefix}${obj.word}`;
          }
        }
        if (item && item.detail && detailField != "preview") {
          let detail = item.detail.replace(/\n\s*/g, " ");
          if (byteLength(detail) < detailMaxLength) {
            if (detailField == "menu") {
              obj.menu = `${detail} ${obj.menu}`;
            } else if (detailField == "abbr") {
              obj.abbr = `${obj.abbr} - ${detail}`;
            }
            obj.detailShown = 1;
          }
        }
        if (item.documentation) {
          obj.info = typeof item.documentation == "string" ? item.documentation : item.documentation.value;
        } else {
          obj.info = "";
        }
        if (obj.word == "")
          obj.empty = 1;
        if (item.textEdit)
          obj.line = opt.line;
        if (item.kind == import_vscode_languageserver_protocol73.CompletionItemKind.Folder && !obj.abbr.endsWith("/")) {
          obj.abbr = obj.abbr + "/";
        }
        if (echodocSupport && item.kind >= 2 && item.kind <= 4) {
          let fields = [item.detail || "", obj.abbr, obj.word];
          for (let s of fields) {
            if (s.includes("(")) {
              obj.signature = s;
              break;
            }
          }
        }
        if (item.preselect)
          obj.preselect = true;
        if ((_a2 = item.data) == null ? void 0 : _a2.optional)
          obj.abbr = obj.abbr + "?";
        return obj;
      }
      getPosition(opt) {
        let { line, linenr, colnr } = opt;
        let part = byteSlice(line, 0, colnr - 1);
        return {
          line: linenr - 1,
          character: part.length
        };
      }
    };
  }
});

// src/sources/source-vim.ts
var logger74, VimSource;
var init_source_vim = __esm({
  "src/sources/source-vim.ts"() {
    init_fuzzy();
    init_string();
    init_workspace();
    init_window();
    init_source();
    logger74 = require_logger2()("sources-source-vim");
    VimSource = class extends Source {
      async callOptinalFunc(fname, args) {
        let exists = this.optionalFns.includes(fname);
        if (!exists)
          return null;
        let name2 = `coc#source#${this.name}#${fname}`;
        let res;
        try {
          res = await this.nvim.call(name2, args);
        } catch (e) {
          window_default.showMessage(`Vim error from source ${this.name}: ${e.message}`, "error");
          return null;
        }
        return res;
      }
      async shouldComplete(opt) {
        let shouldRun = await super.shouldComplete(opt);
        if (!shouldRun)
          return false;
        if (!this.optionalFns.includes("should_complete"))
          return true;
        let res = await this.callOptinalFunc("should_complete", [opt]);
        return !!res;
      }
      async refresh() {
        await this.callOptinalFunc("refresh", []);
      }
      async onCompleteDone(item, _opt) {
        if (!this.optionalFns.includes("on_complete"))
          return;
        await this.callOptinalFunc("on_complete", [item]);
      }
      onEnter(bufnr) {
        if (!this.optionalFns.includes("on_enter"))
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        let { filetypes } = this;
        if (filetypes && !filetypes.includes(doc.filetype))
          return;
        this.callOptinalFunc("on_enter", [{
          bufnr,
          uri: doc.uri,
          languageId: doc.filetype
        }]).logError();
      }
      async doComplete(opt, token) {
        let { col, input, line, colnr } = opt;
        let startcol = await this.callOptinalFunc("get_startcol", [opt]);
        if (token.isCancellationRequested)
          return;
        if (startcol) {
          if (startcol < 0)
            return null;
          startcol = Number(startcol);
          if (isNaN(startcol) || startcol < 0)
            startcol = col;
          if (startcol !== col) {
            input = byteSlice(line, startcol, colnr - 1);
            opt = Object.assign({}, opt, {
              col: startcol,
              changed: col - startcol,
              input
            });
          }
        }
        let items = await this.nvim.callAsync("coc#util#do_complete", [this.name, opt]);
        if (!items || items.length == 0 || token.isCancellationRequested)
          return null;
        if (this.firstMatch && input.length) {
          let ch = input[0];
          items = items.filter((item) => {
            let cfirst = item.filterText ? item.filterText[0] : item.word[0];
            return fuzzyChar(ch, cfirst);
          });
        }
        items = items.map((item) => {
          if (typeof item == "string") {
            return { word: item, menu: this.menu, isSnippet: this.isSnippet };
          }
          let menu = item.menu ? item.menu + " " : "";
          item.menu = `${menu}${this.menu}`;
          item.isSnippet = this.isSnippet;
          delete item.user_data;
          return item;
        });
        let res = { items };
        if (startcol)
          res.startcol = startcol;
        return res;
      }
    };
  }
});

// src/sources/native/around.ts
var around_exports = {};
__export(around_exports, {
  default: () => Around,
  regist: () => regist
});
function regist(sourceMap) {
  sourceMap.set("around", new Around());
  return import_vscode_languageserver_protocol74.Disposable.create(() => {
    sourceMap.delete("around");
  });
}
var import_vscode_languageserver_protocol74, logger75, Around;
var init_around = __esm({
  "src/sources/native/around.ts"() {
    import_vscode_languageserver_protocol74 = __toModule(require_main2());
    init_source();
    init_workspace();
    logger75 = require_logger2()("sources-around");
    Around = class extends Source {
      constructor() {
        super({
          name: "around",
          filepath: __filename
        });
      }
      doComplete(opt) {
        let { bufnr, input } = opt;
        if (input.length === 0)
          return null;
        let document2 = workspace_default.getDocument(bufnr);
        if (!document2)
          return null;
        let words = document2.words;
        let moreWords = document2.getMoreWords();
        words.push(...moreWords);
        words = this.filterWords(words, opt);
        return Promise.resolve({
          items: words.map((word) => ({
            word,
            menu: this.menu
          }))
        });
      }
    };
  }
});

// src/sources/native/buffer.ts
var buffer_exports = {};
__export(buffer_exports, {
  default: () => Buffer3,
  regist: () => regist2
});
function regist2(sourceMap) {
  sourceMap.set("buffer", new Buffer3());
  return import_vscode_languageserver_protocol75.Disposable.create(() => {
    sourceMap.delete("buffer");
  });
}
var import_vscode_languageserver_protocol75, logger76, Buffer3;
var init_buffer2 = __esm({
  "src/sources/native/buffer.ts"() {
    import_vscode_languageserver_protocol75 = __toModule(require_main2());
    init_source();
    init_workspace();
    logger76 = require_logger2()("sources-buffer");
    Buffer3 = class extends Source {
      constructor() {
        super({
          name: "buffer",
          filepath: __filename
        });
      }
      get ignoreGitignore() {
        return this.getConfig("ignoreGitignore", true);
      }
      getWords(bufnr) {
        let { ignoreGitignore } = this;
        let words = [];
        workspace_default.documents.forEach((document2) => {
          if (document2.bufnr == bufnr)
            return;
          if (ignoreGitignore && document2.isIgnored)
            return;
          for (let word of document2.words) {
            if (!words.includes(word)) {
              words.push(word);
            }
          }
        });
        return words;
      }
      doComplete(opt) {
        let { bufnr, input } = opt;
        if (input.length == 0)
          return null;
        let words = this.getWords(bufnr);
        words = this.filterWords(words, opt);
        return Promise.resolve({
          items: words.map((word) => ({
            word,
            menu: this.menu
          }))
        });
      }
    };
  }
});

// src/sources/native/file.ts
var file_exports = {};
__export(file_exports, {
  default: () => File,
  regist: () => regist3
});
function regist3(sourceMap) {
  sourceMap.set("file", new File());
  return import_vscode_languageserver_protocol76.Disposable.create(() => {
    sourceMap.delete("file");
  });
}
var import_fs29, import_minimatch6, import_path31, import_util38, import_vscode_languageserver_protocol76, logger77, pathRe, File;
var init_file = __esm({
  "src/sources/native/file.ts"() {
    import_fs29 = __toModule(require("fs"));
    import_minimatch6 = __toModule(require_minimatch());
    import_path31 = __toModule(require("path"));
    import_util38 = __toModule(require("util"));
    import_vscode_languageserver_protocol76 = __toModule(require_main2());
    init_source();
    init_fs();
    init_string();
    init_workspace();
    logger77 = require_logger2()("sources-file");
    pathRe = /(?:\.{0,2}|~|\$HOME|([\w]+)|[a-zA-Z]:|)(\/|\\)(?:[\u4e00-\u9fa5\w.@()-]+(\/|\\))*(?:[\u4e00-\u9fa5\w.@()-])*$/;
    File = class extends Source {
      constructor() {
        super({
          name: "file",
          filepath: __filename
        });
      }
      resolveEnvVariables(str) {
        let replaced = str;
        replaced = replaced.replace(/%([^%]+)%/g, (_, n) => process.env[n]);
        replaced = replaced.replace(/\$([A-Z_]+[A-Z0-9_]*)|\${([A-Z0-9_]*)}/gi, (_, a, b) => process.env[a || b]);
        return replaced;
      }
      getPathOption(opt) {
        let { line, colnr } = opt;
        let part = byteSlice(line, 0, colnr - 1);
        part = this.resolveEnvVariables(part);
        if (!part || part.endsWith("//"))
          return null;
        let ms = part.match(pathRe);
        if (ms && ms.length) {
          const pathstr = workspace_default.expand(ms[0]);
          let input = ms[0].match(/[^/\\]*$/)[0];
          return { pathstr, part: ms[1], startcol: colnr - input.length - 1, input };
        }
        return null;
      }
      async getFileItem(root, filename) {
        let f = import_path31.default.join(root, filename);
        let stat = await statAsync(f);
        if (stat) {
          let abbr = stat.isDirectory() ? filename + "/" : filename;
          let word = filename;
          return { word, abbr };
        }
        return null;
      }
      filterFiles(files) {
        let ignoreHidden = this.getConfig("ignoreHidden", true);
        let ignorePatterns = this.getConfig("ignorePatterns", []);
        return files.filter((f) => {
          if (f == null)
            return false;
          if (ignoreHidden && f.startsWith("."))
            return false;
          for (let p of ignorePatterns) {
            if ((0, import_minimatch6.default)(f, p, { dot: true }))
              return false;
          }
          return true;
        });
      }
      async getItemsFromRoot(pathstr, root) {
        let res = [];
        let part = pathstr.endsWith("/") ? pathstr : import_path31.default.dirname(pathstr);
        let dir = import_path31.default.isAbsolute(pathstr) ? part : import_path31.default.join(root, part);
        try {
          let stat = await statAsync(dir);
          if (stat && stat.isDirectory()) {
            let files = await import_util38.default.promisify(import_fs29.default.readdir)(dir);
            files = this.filterFiles(files);
            let items = await Promise.all(files.map((filename) => this.getFileItem(dir, filename)));
            res = res.concat(items);
          }
          res = res.filter((item) => item != null);
          return res;
        } catch (e) {
          logger77.error(`Error on list files:`, e);
          return res;
        }
      }
      get trimSameExts() {
        return this.getConfig("trimSameExts", []);
      }
      async doComplete(opt) {
        let { col, filepath } = opt;
        let option = this.getPathOption(opt);
        if (!option)
          return null;
        let { pathstr, part, startcol, input } = option;
        if (startcol < opt.col)
          return null;
        let startPart = opt.col == startcol ? "" : byteSlice(opt.line, opt.col, startcol);
        let dirname3 = import_path31.default.dirname(filepath);
        let ext = import_path31.default.extname(import_path31.default.basename(filepath));
        let cwd = await this.nvim.call("getcwd", []);
        let root;
        if (pathstr.startsWith(".")) {
          root = filepath ? import_path31.default.dirname(filepath) : cwd;
        } else if (pathstr.startsWith("/")) {
          root = pathstr.endsWith("/") ? pathstr : import_path31.default.dirname(pathstr);
        } else if (part) {
          if (import_fs29.default.existsSync(import_path31.default.join(dirname3, part))) {
            root = dirname3;
          } else if (import_fs29.default.existsSync(import_path31.default.join(cwd, part))) {
            root = cwd;
          }
        } else {
          root = cwd;
        }
        if (!root)
          return null;
        let items = await this.getItemsFromRoot(pathstr, root);
        let trimExt = this.trimSameExts.includes(ext);
        let first = input[0];
        if (first && col == startcol)
          items = items.filter((o) => o.word[0] === first);
        return {
          items: items.map((item) => {
            let ex = import_path31.default.extname(item.word);
            item.word = trimExt && ex === ext ? item.word.replace(ext, "") : item.word;
            return {
              word: `${startPart}${item.word}`,
              abbr: `${startPart}${item.abbr}`,
              menu: this.menu
            };
          })
        };
      }
    };
  }
});

// src/sources/index.ts
var sources_exports = {};
__export(sources_exports, {
  Sources: () => Sources,
  default: () => sources_default
});
var import_fast_diff3, import_fs31, import_path32, import_util39, import_vscode_languageserver_protocol77, logger78, Sources, sources_default;
var init_sources2 = __esm({
  "src/sources/index.ts"() {
    import_fast_diff3 = __toModule(require_diff());
    import_fs31 = __toModule(require("fs"));
    import_path32 = __toModule(require("path"));
    import_util39 = __toModule(require("util"));
    import_vscode_languageserver_protocol77 = __toModule(require_main2());
    init_events();
    init_extensions2();
    init_types();
    init_util();
    init_fs();
    init_match();
    init_object();
    init_string();
    init_window();
    init_workspace();
    init_source();
    init_source_language();
    init_source_vim();
    logger78 = require_logger2()("sources");
    Sources = class {
      constructor() {
        this.sourceMap = new Map();
        this.disposables = [];
        this.remoteSourcePaths = [];
      }
      init() {
        this.loadCompleteConfig();
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("suggest")) {
            this.loadCompleteConfig();
          }
        }, null, this.disposables);
        this.createNativeSources();
        this.createRemoteSources();
        events_default.on("BufEnter", this.onDocumentEnter, this, this.disposables);
        workspace_default.watchOption("runtimepath", async (oldValue, newValue) => {
          let result = (0, import_fast_diff3.default)(oldValue, newValue);
          for (let [changeType, value] of result) {
            if (changeType == 1) {
              let paths = value.replace(/,$/, "").split(",");
              for (let p of paths) {
                if (p)
                  await this.createVimSources(p);
              }
            }
          }
        }, this.disposables);
      }
      loadCompleteConfig() {
        let suggest = workspace_default.getConfiguration("suggest");
        let labels = suggest.get("completionItemKindLabels", {});
        let map = new Map([
          [import_vscode_languageserver_protocol77.CompletionItemKind.Text, labels["text"] || "v"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Method, labels["method"] || "f"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Function, labels["function"] || "f"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Constructor, typeof labels["constructor"] == "function" ? "f" : labels["constructor"]],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Field, labels["field"] || "m"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Variable, labels["variable"] || "v"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Class, labels["class"] || "C"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Interface, labels["interface"] || "I"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Module, labels["module"] || "M"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Property, labels["property"] || "m"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Unit, labels["unit"] || "U"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Value, labels["value"] || "v"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Enum, labels["enum"] || "E"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Keyword, labels["keyword"] || "k"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Snippet, labels["snippet"] || "S"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Color, labels["color"] || "v"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.File, labels["file"] || "F"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Reference, labels["reference"] || "r"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Folder, labels["folder"] || "F"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.EnumMember, labels["enumMember"] || "m"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Constant, labels["constant"] || "v"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Struct, labels["struct"] || "S"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Event, labels["event"] || "E"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.Operator, labels["operator"] || "O"],
          [import_vscode_languageserver_protocol77.CompletionItemKind.TypeParameter, labels["typeParameter"] || "T"]
        ]);
        let floatEnable = suggest.get("floatEnable", true);
        let detailField = suggest.get("detailField", "preview");
        if (detailField == "preview" && (!floatEnable || !workspace_default.floatSupported)) {
          detailField = "menu";
        }
        this.completeConfig = Object.assign(this.completeConfig || {}, {
          labels: map,
          floatEnable,
          detailField,
          defaultKindText: labels["default"] || "",
          priority: suggest.get("languageSourcePriority", 99),
          echodocSupport: suggest.get("echodocSupport", false),
          snippetsSupport: suggest.get("snippetsSupport", true),
          detailMaxLength: suggest.get("detailMaxLength", 100),
          invalidInsertCharacters: suggest.get("invalidInsertCharacters", ["(", "<", "{", "[", "\r", "\n"])
        });
      }
      get nvim() {
        return workspace_default.nvim;
      }
      createNativeSources() {
        try {
          this.disposables.push((init_around(), around_exports).regist(this.sourceMap));
          this.disposables.push((init_buffer2(), buffer_exports).regist(this.sourceMap));
          this.disposables.push((init_file(), file_exports).regist(this.sourceMap));
        } catch (e) {
          console.error("Create source error:" + e.message);
        }
      }
      createLanguageSource(name2, shortcut, selector, provider, triggerCharacters, priority, allCommitCharacters) {
        let source = new LanguageSource(name2, shortcut, provider, selector, triggerCharacters || [], allCommitCharacters || [], priority, this.completeConfig);
        logger78.debug("created service source", name2);
        this.sourceMap.set(name2, source);
        return {
          dispose: () => {
            this.sourceMap.delete(name2);
          }
        };
      }
      async createVimSourceExtension(nvim, filepath) {
        let name2 = import_path32.default.basename(filepath, ".vim");
        try {
          await nvim.command(`source ${filepath}`);
          let fns = await nvim.call("coc#util#remote_fns", name2);
          for (let fn of ["init", "complete"]) {
            if (!fns.includes(fn)) {
              window_default.showMessage(`${fn} not found for source ${name2}`, "error");
              return null;
            }
          }
          let props = await nvim.call(`coc#source#${name2}#init`, []);
          let packageJSON = {
            name: `coc-source-${name2}`,
            engines: {
              coc: ">= 0.0.1"
            },
            activationEvents: props.filetypes ? props.filetypes.map((f) => `onLanguage:${f}`) : ["*"],
            contributes: {
              configuration: {
                properties: {
                  [`coc.source.${name2}.enable`]: {
                    type: "boolean",
                    default: true
                  },
                  [`coc.source.${name2}.firstMatch`]: {
                    type: "boolean",
                    default: !!props.firstMatch
                  },
                  [`coc.source.${name2}.triggerCharacters`]: {
                    type: "number",
                    default: props.triggerCharacters || []
                  },
                  [`coc.source.${name2}.priority`]: {
                    type: "number",
                    default: props.priority || 9
                  },
                  [`coc.source.${name2}.shortcut`]: {
                    type: "string",
                    default: props.shortcut || name2.slice(0, 3).toUpperCase(),
                    description: "Shortcut text shown in complete menu."
                  },
                  [`coc.source.${name2}.disableSyntaxes`]: {
                    type: "array",
                    default: [],
                    items: {
                      type: "string"
                    }
                  },
                  [`coc.source.${name2}.filetypes`]: {
                    type: "array",
                    default: props.filetypes || null,
                    description: "Enabled filetypes.",
                    items: {
                      type: "string"
                    }
                  }
                }
              }
            }
          };
          let source = new VimSource({
            name: name2,
            filepath,
            sourceType: SourceType.Remote,
            optionalFns: fns.filter((n) => !["init", "complete"].includes(n))
          });
          let isActive = false;
          let extension = {
            id: packageJSON.name,
            packageJSON,
            exports: void 0,
            extensionPath: filepath,
            activate: () => {
              isActive = true;
              this.addSource(source);
              return Promise.resolve();
            }
          };
          Object.defineProperty(extension, "isActive", {
            get: () => isActive
          });
          extensions_default.registerExtension(extension, () => {
            isActive = false;
            this.removeSource(source);
          });
        } catch (e) {
          window_default.showMessage(`Error on create vim source ${name2}: ${e.message}`, "error");
        }
      }
      createRemoteSources() {
        let { runtimepath } = workspace_default.env;
        let paths = runtimepath.split(",");
        for (let path36 of paths) {
          this.createVimSources(path36).logError();
        }
      }
      async createVimSources(pluginPath) {
        if (this.remoteSourcePaths.includes(pluginPath))
          return;
        this.remoteSourcePaths.push(pluginPath);
        let folder = import_path32.default.join(pluginPath, "autoload/coc/source");
        let stat = await statAsync(folder);
        if (stat && stat.isDirectory()) {
          let arr = await import_util39.default.promisify(import_fs31.default.readdir)(folder);
          arr = arr.filter((s) => s.endsWith(".vim"));
          let files = arr.map((s) => import_path32.default.join(folder, s));
          if (files.length == 0)
            return;
          await Promise.all(files.map((p) => this.createVimSourceExtension(this.nvim, p)));
        }
      }
      get names() {
        return Array.from(this.sourceMap.keys());
      }
      get sources() {
        return Array.from(this.sourceMap.values());
      }
      has(name2) {
        return this.names.findIndex((o) => o == name2) != -1;
      }
      getSource(name2) {
        if (!name2)
          return null;
        return this.sourceMap.get(name2) || null;
      }
      shouldCommit(item, commitCharacter) {
        if (!item || !item.source)
          return false;
        let source = this.getSource(item.source);
        if (source && source.sourceType == SourceType.Service && typeof source.shouldCommit === "function") {
          return source.shouldCommit(item, commitCharacter);
        }
        return false;
      }
      getCompleteSources(opt) {
        let { filetype } = opt;
        let pre = byteSlice(opt.line, 0, opt.colnr - 1);
        let isTriggered = opt.input == "" && !!opt.triggerCharacter;
        let uri = getUri(opt.filepath, opt.bufnr, "", workspace_default.env.isCygwin);
        if (isTriggered)
          return this.getTriggerSources(pre, filetype, uri);
        return this.getNormalSources(opt.filetype, uri);
      }
      getNormalSources(filetype, uri) {
        return this.sources.filter((source) => {
          let { filetypes, triggerOnly, documentSelector, enable } = source;
          if (!enable || triggerOnly || filetypes && !filetypes.includes(filetype)) {
            return false;
          }
          if (documentSelector && score(documentSelector, uri, filetype) == 0) {
            return false;
          }
          if (this.disabledByLanguageId(source, filetype)) {
            return false;
          }
          return true;
        });
      }
      checkTrigger(source, pre, character) {
        let { triggerCharacters, triggerPatterns } = source;
        if (!triggerCharacters && !triggerPatterns)
          return false;
        if (character && triggerCharacters && triggerCharacters.includes(character)) {
          return true;
        }
        if (triggerPatterns && triggerPatterns.findIndex((p) => p.test(pre)) !== -1) {
          return true;
        }
        return false;
      }
      shouldTrigger(pre, languageId, uri) {
        let sources = this.getTriggerSources(pre, languageId, uri);
        return sources.length > 0;
      }
      getTriggerSources(pre, languageId, uri) {
        let character = pre.length ? pre[pre.length - 1] : "";
        if (!character)
          return [];
        return this.sources.filter((source) => {
          let { filetypes, enable, documentSelector } = source;
          if (!enable || filetypes && !filetypes.includes(languageId)) {
            return false;
          }
          if (documentSelector && score(documentSelector, uri, languageId) == 0) {
            return false;
          }
          if (this.disabledByLanguageId(source, languageId))
            return false;
          return this.checkTrigger(source, pre, character);
        });
      }
      addSource(source) {
        let { name: name2 } = source;
        if (this.names.includes(name2)) {
          logger78.warn(`Recreate source ${name2}`);
        }
        this.sourceMap.set(name2, source);
        return import_vscode_languageserver_protocol77.Disposable.create(() => {
          this.sourceMap.delete(name2);
        });
      }
      removeSource(source) {
        let name2 = typeof source == "string" ? source : source.name;
        this.sourceMap.delete(name2);
      }
      async refresh(name2) {
        for (let source of this.sources) {
          if (!name2 || source.name == name2) {
            if (typeof source.refresh === "function") {
              await Promise.resolve(source.refresh());
            }
          }
        }
      }
      toggleSource(name2) {
        if (!name2)
          return;
        let source = this.getSource(name2);
        if (!source)
          return;
        if (typeof source.toggle === "function") {
          source.toggle();
        }
      }
      sourceStats() {
        let res = [];
        let items = this.sources;
        for (let item of items) {
          res.push({
            name: item.name,
            priority: item.priority,
            triggerCharacters: item.triggerCharacters || [],
            shortcut: item.shortcut || "",
            filetypes: item.filetypes || [],
            filepath: item.filepath || "",
            type: item.sourceType == SourceType.Native ? "native" : item.sourceType == SourceType.Remote ? "remote" : "service",
            disabled: !item.enable
          });
        }
        return res;
      }
      onDocumentEnter(bufnr) {
        let { sources } = this;
        for (let s of sources) {
          if (s.enable && typeof s.onEnter == "function") {
            s.onEnter(bufnr);
          }
        }
      }
      createSource(config) {
        if (!config.name || !config.doComplete) {
          throw new Error(`name and doComplete required for createSource`);
        }
        let source = new Source(Object.assign({ sourceType: SourceType.Service }, config));
        return this.addSource(source);
      }
      disabledByLanguageId(source, languageId) {
        let map = workspace_default.env.disabledSources;
        if (isEmpty(map))
          return false;
        let list2 = map ? map[languageId] : [];
        return Array.isArray(list2) && list2.includes(source.name);
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    sources_default = new Sources();
  }
});

// src/completion/match.ts
function nextWordIndex(start = 0, codes) {
  for (let i = start; i < codes.length; i++) {
    if (isWordIndex(i, codes)) {
      return i;
    }
  }
  return -1;
}
function upperCase(code) {
  return code >= 65 && code <= 90;
}
function isWordIndex(index, codes) {
  if (index == 0)
    return true;
  let curr = codes[index];
  if (!wordChar(curr))
    return false;
  let pre = codes[index - 1];
  if (!wordChar(pre))
    return true;
  if (upperCase(curr) && !upperCase(pre))
    return true;
  return false;
}
function matchScore(word, input) {
  if (input.length == 0 || word.length < input.length)
    return 0;
  let codes = getCharCodes(word);
  let curr = codes[0];
  let score5 = 0;
  let first = input[0];
  let idx = 1;
  let allowFuzzy = true;
  if (caseMatch(first, curr)) {
    score5 = first == curr ? 5 : 2.5;
    idx = 1;
  } else {
    let next2 = nextWordIndex(1, codes);
    if (next2 != -1) {
      if (caseMatch(first, codes[next2])) {
        score5 = first == codes[next2] ? 2.5 : 2;
        idx = next2 + 1;
      }
    }
    if (score5 == 0) {
      for (let i = 1; i < codes.length; i++) {
        if (caseMatch(first, codes[i])) {
          score5 = first == codes[i] ? 1 : 0.5;
          idx = i + 1;
          allowFuzzy = false;
        }
      }
    }
  }
  if (input.length == 1 || score5 == 0)
    return score5;
  let next = nextScore(codes, idx, input.slice(1), allowFuzzy);
  return next == 0 ? 0 : score5 + next;
}
function nextScore(codes, index, inputCodes, allowFuzzy = true) {
  if (index >= codes.length)
    return 0;
  let scores = [];
  let input = inputCodes[0];
  let len = codes.length;
  let isFinal = inputCodes.length == 1;
  if (!wordChar(input)) {
    for (let i = index; i < len; i++) {
      if (codes[i] == input) {
        if (isFinal)
          return 1;
        let next = nextScore(codes, i + 1, inputCodes.slice(1), allowFuzzy);
        return next == 0 ? 0 : 1 + next;
      }
    }
    return 0;
  }
  let curr = codes[index];
  let match = caseMatch(input, curr);
  if (match) {
    let score5 = input == curr ? 1 : 0.5;
    if (!isFinal) {
      let next = nextScore(codes, index + 1, inputCodes.slice(1), allowFuzzy);
      score5 = next == 0 ? 0 : score5 + next;
    }
    scores.push(score5);
  }
  if (wordChar(input) && !isWordIndex(index, codes)) {
    let idx = nextWordIndex(index + 1, codes);
    if (idx !== -1) {
      let next = codes[idx];
      if (caseMatch(input, next)) {
        let score5 = input == next ? 1 : 0.75;
        if (!isFinal) {
          let next2 = nextScore(codes, idx + 1, inputCodes.slice(1), allowFuzzy);
          score5 = next2 == 0 ? 0 : score5 + next2;
        }
        scores.push(score5);
      }
    }
  }
  if (!match && allowFuzzy) {
    for (let i = index + 1; i < len; i++) {
      let code = codes[i];
      if (caseMatch(input, code)) {
        let score5 = input == code ? 0.1 : 0.05;
        if (!isFinal) {
          let next = nextScore(codes, i + 1, inputCodes.slice(1), false);
          score5 = next == 0 ? 0 : score5 + next;
        }
        scores.push(score5);
      }
    }
  }
  if (!scores.length)
    return 0;
  return Math.max(...scores);
}
var init_match2 = __esm({
  "src/completion/match.ts"() {
    init_fuzzy();
  }
});

// src/completion/complete.ts
var import_vscode_languageserver_protocol78, logger79, FIRST_TIMEOUT, Complete;
var init_complete = __esm({
  "src/completion/complete.ts"() {
    import_vscode_languageserver_protocol78 = __toModule(require_main2());
    init_fuzzy();
    init_string();
    init_match2();
    logger79 = require_logger2()("completion-complete");
    FIRST_TIMEOUT = 500;
    Complete = class {
      constructor(option, document2, config, sources, nvim) {
        this.option = option;
        this.document = document2;
        this.config = config;
        this.sources = sources;
        this.nvim = nvim;
        this.results = [];
        this.completing = new Set();
        this._canceled = false;
        this.tokenSources = new Map();
        this._onDidComplete = new import_vscode_languageserver_protocol78.Emitter();
        this.onDidComplete = this._onDidComplete.event;
      }
      get isCompleting() {
        return this.completing.size > 0;
      }
      get isCanceled() {
        return this._canceled;
      }
      get isEmpty() {
        return this.results.length == 0;
      }
      get startcol() {
        return this.option.col || 0;
      }
      get input() {
        return this.option.input;
      }
      get isIncomplete() {
        return this.results.findIndex((o) => o.isIncomplete) !== -1;
      }
      async completeSource(source) {
        let { col } = this.option;
        let opt = Object.assign({}, this.option);
        let timeout = this.config.timeout;
        timeout = Math.max(Math.min(timeout, 15e3), 500);
        try {
          if (typeof source.shouldComplete === "function") {
            let shouldRun = await Promise.resolve(source.shouldComplete(opt));
            if (!shouldRun)
              return null;
          }
          let start = Date.now();
          let oldSource = this.tokenSources.get(source.name);
          if (oldSource)
            oldSource.cancel();
          let tokenSource = new import_vscode_languageserver_protocol78.CancellationTokenSource();
          this.tokenSources.set(source.name, tokenSource);
          await new Promise((resolve3, reject) => {
            let { name: name2 } = source;
            let timer = setTimeout(() => {
              this.nvim.command(`echohl WarningMsg| echom 'source ${source.name} timeout after ${timeout}ms'|echohl None`, true);
              tokenSource.cancel();
            }, timeout);
            let cancelled = false;
            let called = false;
            let empty = false;
            let ft = setTimeout(() => {
              if (called)
                return;
              empty = true;
              resolve3(void 0);
            }, FIRST_TIMEOUT);
            let onFinished = () => {
              if (called)
                return;
              called = true;
              disposable.dispose();
              clearTimeout(ft);
              clearTimeout(timer);
              this.tokenSources.delete(name2);
            };
            let disposable = tokenSource.token.onCancellationRequested(() => {
              disposable.dispose();
              this.completing.delete(name2);
              cancelled = true;
              onFinished();
              logger79.debug(`Source "${name2}" cancelled`);
              resolve3(void 0);
            });
            this.completing.add(name2);
            Promise.resolve(source.doComplete(opt, tokenSource.token)).then((result) => {
              this.completing.delete(name2);
              if (cancelled)
                return;
              onFinished();
              let dt = Date.now() - start;
              logger79.debug(`Source "${name2}" takes ${dt}ms`);
              if (result && result.items && result.items.length) {
                result.priority = source.priority;
                result.source = name2;
                if (empty && result.startcol && result.startcol != col) {
                  this.results = [result];
                } else {
                  let { results } = this;
                  let idx = results.findIndex((o) => o.source == name2);
                  if (idx != -1) {
                    results.splice(idx, 1, result);
                  } else {
                    results.push(result);
                  }
                }
                if (empty)
                  this._onDidComplete.fire();
                resolve3(void 0);
              } else {
                let { results } = this;
                this.results = results.filter((res) => res.source != name2);
                resolve3(void 0);
              }
            }, (err) => {
              this.completing.delete(name2);
              onFinished();
              reject(err);
            });
          });
        } catch (err) {
          this.nvim.command(`echoerr 'Complete ${source.name} error: ${err.message.replace(/'/g, "''")}'`, true);
          logger79.error("Complete error:", source.name, err);
        }
      }
      async completeInComplete(resumeInput) {
        let { results, document: document2 } = this;
        let remains = results.filter((res) => !res.isIncomplete);
        remains.forEach((res) => {
          res.items.forEach((item) => delete item.user_data);
        });
        let arr = results.filter((res) => res.isIncomplete);
        let names = arr.map((o) => o.source);
        let { input, colnr, linenr } = this.option;
        Object.assign(this.option, {
          input: resumeInput,
          line: document2.getline(linenr - 1),
          colnr: colnr + (resumeInput.length - input.length),
          triggerCharacter: null,
          triggerForInComplete: true
        });
        let sources = this.sources.filter((s) => names.includes(s.name));
        await Promise.all(sources.map((s) => this.completeSource(s)));
        return this.filterResults(resumeInput, Math.floor(Date.now() / 1e3));
      }
      filterResults(input, cid = 0) {
        let { results } = this;
        results.sort((a, b) => {
          if (a.source == "tabnine")
            return 1;
          if (b.source == "tabnine")
            return -1;
          return b.priority - a.priority;
        });
        let { snippetIndicator, removeDuplicateItems, fixInsertedWord, asciiCharactersOnly } = this.config;
        let followPart = !fixInsertedWord || cid == 0 ? "" : this.getFollowPart();
        if (results.length == 0)
          return [];
        let arr = [];
        let codes = getCharCodes(input);
        let words = new Set();
        for (let i = 0, l = results.length; i < l; i++) {
          let res = results[i];
          let { items, source, priority } = res;
          for (let idx = 0; idx < items.length; idx++) {
            let item = items[idx];
            if (!item || typeof item.word !== "string") {
              continue;
            }
            let { word } = item;
            if (asciiCharactersOnly && !/^[\x00-\x7F]*$/.test(word)) {
              continue;
            }
            if (!item.dup && words.has(word))
              continue;
            if (removeDuplicateItems && !item.isSnippet && words.has(word) && item.line == void 0)
              continue;
            let filterText = item.filterText || item.word;
            item.filterText = filterText;
            if (filterText.length < input.length)
              continue;
            let score5 = item.kind && filterText == input ? 64 : matchScore(filterText, codes);
            if (input.length && score5 == 0)
              continue;
            if (followPart.length && !item.isSnippet) {
              if (item.word.endsWith(followPart)) {
                let { word: word2 } = item;
                item.word = item.word.slice(0, -followPart.length);
                item.abbr = item.abbr || word2;
              }
            }
            if (!item.user_data) {
              let user_data = { cid, source };
              user_data.index = item.index || idx;
              if (item.isSnippet) {
                let abbr = item.abbr || item.word;
                if (!abbr.endsWith(snippetIndicator)) {
                  item.abbr = `${item.abbr || item.word}${snippetIndicator}`;
                }
              }
              if (item.signature)
                user_data.signature = item.signature;
              item.user_data = JSON.stringify(user_data);
              item.source = source;
            }
            item.priority = priority;
            item.abbr = item.abbr || item.word;
            item.score = input.length ? score5 * (item.sourceScore || 1) : 0;
            item.localBonus = this.localBonus ? this.localBonus.get(filterText) || 0 : 0;
            words.add(word);
            if (item.isSnippet && input.length && item.word == input) {
              item.preselect = true;
            }
            arr.push(item);
          }
        }
        arr.sort((a, b) => {
          let sa = a.sortText;
          let sb = b.sortText;
          let wa = a.filterText;
          let wb = b.filterText;
          if (a.score != b.score)
            return b.score - a.score;
          if (a.priority != b.priority)
            return b.priority - a.priority;
          if (sa && sb && sa != sb)
            return sa < sb ? -1 : 1;
          if (a.localBonus != b.localBonus) {
            if (a.localBonus && b.localBonus && wa != wb) {
              if (wa.startsWith(wb))
                return 1;
              if (wb.startsWith(wa))
                return -1;
            }
            return b.localBonus - a.localBonus;
          }
          switch (this.config.defaultSortMethod) {
            case "none":
              return 0;
            case "alphabetical":
              return a.filterText.localeCompare(b.filterText);
            case "length":
            default:
              return a.filterText.length - b.filterText.length;
          }
        });
        return this.limitCompleteItems(arr.slice(0, this.config.maxItemCount));
      }
      limitCompleteItems(items) {
        let { highPrioritySourceLimit, lowPrioritySourceLimit } = this.config;
        if (!highPrioritySourceLimit && !lowPrioritySourceLimit)
          return items;
        let counts = new Map();
        return items.filter((item) => {
          let { priority, source } = item;
          let isLow = priority < 90;
          let curr = counts.get(source) || 0;
          if (lowPrioritySourceLimit && isLow && curr == lowPrioritySourceLimit || highPrioritySourceLimit && !isLow && curr == highPrioritySourceLimit) {
            return false;
          }
          counts.set(source, curr + 1);
          return true;
        });
      }
      hasMatch(input) {
        let { results } = this;
        if (!results)
          return false;
        let codes = getCharCodes(input);
        for (let i = 0, l = results.length; i < l; i++) {
          let items = results[i].items;
          let idx = items.findIndex((item) => fuzzyMatch(codes, item.filterText || item.word));
          if (idx !== -1)
            return true;
        }
        return false;
      }
      async doComplete() {
        let opts = this.option;
        let { line, colnr, linenr, col } = this.option;
        if (this.config.localityBonus) {
          let line2 = linenr - 1;
          this.localBonus = this.document.getLocalifyBonus(import_vscode_languageserver_protocol78.Position.create(line2, opts.col - 1), import_vscode_languageserver_protocol78.Position.create(line2, colnr));
        } else {
          this.localBonus = new Map();
        }
        await Promise.all(this.sources.map((s) => this.completeSource(s)));
        let { results } = this;
        if (results.length == 0)
          return [];
        let engrossResult = results.find((r) => r.startcol != null && r.startcol != col);
        if (engrossResult) {
          let { startcol } = engrossResult;
          opts.col = startcol;
          opts.input = byteSlice(line, startcol, colnr - 1);
          this.results = [engrossResult];
        }
        logger79.info(`Results from: ${this.results.map((s) => s.source).join(",")}`);
        return this.filterResults(opts.input, Math.floor(Date.now() / 1e3));
      }
      resolveCompletionItem(item) {
        let { results } = this;
        if (!results)
          return null;
        try {
          if (item.user_data) {
            let { source } = JSON.parse(item.user_data);
            let result = results.find((res) => res.source == source);
            return result.items.find((o) => o.user_data == item.user_data);
          }
          for (let result of results) {
            let res = result.items.find((o) => o.abbr == item.abbr && o.info == item.info);
            if (res)
              return res;
          }
          return null;
        } catch (e) {
          return null;
        }
      }
      getFollowPart() {
        let { colnr, line } = this.option;
        let idx = characterIndex(line, colnr - 1);
        if (idx == line.length)
          return "";
        let part = line.slice(idx - line.length);
        return part.match(/^\S?[\w-]*/)[0];
      }
      dispose() {
        if (this._canceled)
          return;
        this._onDidComplete.dispose();
        this._canceled = true;
        for (let tokenSource of this.tokenSources.values()) {
          tokenSource.cancel();
        }
        this.tokenSources.clear();
        this.sources = [];
        this.results = [];
      }
    };
  }
});

// src/completion/floating.ts
var logger80, Floating;
var init_floating = __esm({
  "src/completion/floating.ts"() {
    init_markdown();
    logger80 = require_logger2()("floating");
    Floating = class {
      constructor(nvim, isVim7) {
        this.nvim = nvim;
        this.isVim = isVim7;
        this.winid = 0;
        this.bufnr = 0;
      }
      async show(docs, bounding, config, token) {
        let { nvim } = this;
        docs = docs.filter((o) => o.content.trim().length > 0);
        let { lines, codes, highlights } = parseDocuments(docs, { excludeImages: config.excludeImages });
        if (lines.length == 0) {
          this.close();
          return;
        }
        let opts = {
          codes,
          highlights,
          maxWidth: config.maxWidth || 80,
          pumbounding: bounding
        };
        if (config.border)
          opts.border = [1, 1, 1, 1];
        if (config.highlight)
          opts.highlight = config.highlight;
        if (config.borderhighlight)
          opts.borderhighlight = config.borderhighlight;
        if (!this.isVim) {
          if (typeof config.winblend === "number")
            opts.winblend = config.winblend;
          opts.focusable = config.focusable === true ? 1 : 0;
          if (config.shadow)
            opts.shadow = 1;
        }
        let res = await nvim.call("coc#float#create_pum_float", [this.winid, this.bufnr, lines, opts]);
        if (this.isVim)
          nvim.command("redraw", true);
        if (!res || res.length == 0)
          return;
        this.winid = res[0];
        this.bufnr = res[1];
        if (token.isCancellationRequested) {
          this.close();
          return;
        }
      }
      close() {
        let { winid, nvim } = this;
        this.winid = 0;
        if (!winid)
          return;
        nvim.call("coc#float#close", [winid], true);
        if (this.isVim)
          nvim.command("redraw", true);
      }
    };
  }
});

// src/completion/index.ts
var import_vscode_languageserver_protocol79, import_debounce9, logger81, completeItemKeys, Completion, completion_default;
var init_completion = __esm({
  "src/completion/index.ts"() {
    import_vscode_languageserver_protocol79 = __toModule(require_main2());
    init_events();
    init_sources2();
    init_util();
    init_is();
    init_workspace();
    init_complete();
    init_floating();
    import_debounce9 = __toModule(require_debounce());
    init_string();
    init_object();
    logger81 = require_logger2()("completion");
    completeItemKeys = ["abbr", "menu", "info", "kind", "icase", "dup", "empty", "user_data"];
    Completion = class {
      constructor() {
        this.activated = false;
        this.disposables = [];
        this.complete = null;
        this.changedTick = 0;
        this.insertCharTs = 0;
        this.insertLeaveTs = 0;
      }
      init() {
        this.config = this.getCompleteConfig();
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("suggest")) {
            this.config = this.getCompleteConfig();
          }
        }, null, this.disposables);
        workspace_default.watchOption("completeopt", async (_, newValue) => {
          workspace_default.env.completeOpt = newValue;
          if (!this.isActivated)
            return;
          if (this.config.autoTrigger === "always") {
            let content = await this.nvim.call("execute", ["verbose set completeopt"]);
            let lines = content.split(/\r?\n/);
            console.error(`Some plugin change completeopt during completion: ${lines[lines.length - 1].trim()}!`);
          }
        }, this.disposables);
        this.excludeImages = workspace_default.getConfiguration("coc.preferences").get("excludeImageLinksInMarkdownDocument");
        this.floating = new Floating(workspace_default.nvim, workspace_default.env.isVim);
        events_default.on(["InsertCharPre", "MenuPopupChanged", "TextChangedI", "CursorMovedI", "InsertLeave"], () => {
          if (this.triggerTimer) {
            clearTimeout(this.triggerTimer);
            this.triggerTimer = null;
          }
        }, this, this.disposables);
        events_default.on("InsertCharPre", this.onInsertCharPre, this, this.disposables);
        events_default.on("InsertLeave", this.onInsertLeave, this, this.disposables);
        events_default.on("InsertEnter", this.onInsertEnter, this, this.disposables);
        events_default.on("TextChangedP", this.onTextChangedP, this, this.disposables);
        events_default.on("TextChangedI", this.onTextChangedI, this, this.disposables);
        let fn = (0, import_debounce9.default)(this.onPumChange.bind(this), 20);
        this.disposables.push({
          dispose: () => {
            fn.clear();
          }
        });
        events_default.on("CompleteDone", async (item) => {
          this.popupEvent = null;
          if (!this.activated)
            return;
          fn.clear();
          this.cancelResolve();
          this.floating.close();
          await this.onCompleteDone(item);
        }, this, this.disposables);
        this.cancelResolve();
        events_default.on("MenuPopupChanged", (ev) => {
          if (!this.activated || this.isCommandLine)
            return;
          if (equals(this.popupEvent, ev))
            return;
          this.cancelResolve();
          this.popupEvent = ev;
          fn();
        }, this, this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      get option() {
        if (!this.complete)
          return null;
        return this.complete.option;
      }
      get selectedItem() {
        if (!this.popupEvent)
          return null;
        let { completed_item } = this.popupEvent;
        return vimCompleteItem(completed_item) ? completed_item : null;
      }
      get isCommandLine() {
        var _a2;
        return (_a2 = this.document) == null ? void 0 : _a2.uri.endsWith("%5BCommand%20Line%5D");
      }
      get isActivated() {
        return this.activated;
      }
      get document() {
        if (!this.option)
          return null;
        return workspace_default.getDocument(this.option.bufnr);
      }
      getCompleteConfig() {
        let suggest = workspace_default.getConfiguration("suggest");
        function getConfig(key, defaultValue) {
          return suggest.get(key, defaultValue);
        }
        let keepCompleteopt = getConfig("keepCompleteopt", false);
        let autoTrigger = getConfig("autoTrigger", "always");
        if (keepCompleteopt && autoTrigger != "none") {
          let { completeOpt } = workspace_default;
          if (!completeOpt.includes("noinsert") && !completeOpt.includes("noselect")) {
            autoTrigger = "none";
          }
        }
        let floatEnable = workspace_default.floatSupported && getConfig("floatEnable", true);
        let acceptSuggestionOnCommitCharacter = workspace_default.env.pumevent && getConfig("acceptSuggestionOnCommitCharacter", false);
        return {
          autoTrigger,
          floatEnable,
          keepCompleteopt,
          floatConfig: getConfig("floatConfig", {}),
          defaultSortMethod: getConfig("defaultSortMethod", "length"),
          removeDuplicateItems: getConfig("removeDuplicateItems", false),
          disableMenuShortcut: getConfig("disableMenuShortcut", false),
          acceptSuggestionOnCommitCharacter,
          disableKind: getConfig("disableKind", false),
          disableMenu: getConfig("disableMenu", false),
          previewIsKeyword: getConfig("previewIsKeyword", "@,48-57,_192-255"),
          enablePreview: getConfig("enablePreview", false),
          enablePreselect: getConfig("enablePreselect", false),
          triggerCompletionWait: getConfig("triggerCompletionWait", 100),
          labelMaxLength: getConfig("labelMaxLength", 200),
          triggerAfterInsertEnter: getConfig("triggerAfterInsertEnter", false),
          noselect: getConfig("noselect", true),
          numberSelect: getConfig("numberSelect", false),
          maxItemCount: getConfig("maxCompleteItemCount", 50),
          timeout: getConfig("timeout", 500),
          minTriggerInputLength: getConfig("minTriggerInputLength", 1),
          snippetIndicator: getConfig("snippetIndicator", "~"),
          fixInsertedWord: getConfig("fixInsertedWord", true),
          localityBonus: getConfig("localityBonus", true),
          highPrioritySourceLimit: getConfig("highPrioritySourceLimit", null),
          lowPrioritySourceLimit: getConfig("lowPrioritySourceLimit", null),
          asciiCharactersOnly: getConfig("asciiCharactersOnly", false)
        };
      }
      async startCompletion(option) {
        this.pretext = byteSlice(option.line, 0, option.colnr - 1);
        try {
          await this._doComplete(option);
        } catch (e) {
          this.stop();
          logger81.error("Complete error:", e.stack);
        }
      }
      async resumeCompletion(force = false) {
        let { document: document2, complete } = this;
        if (!document2 || complete.isCanceled || !complete.results || complete.results.length == 0)
          return;
        let search = this.getResumeInput();
        if (search == this.input && !force)
          return;
        if (!search || search.endsWith(" ") || !search.startsWith(complete.input)) {
          this.stop();
          return;
        }
        this.input = search;
        let items = [];
        if (complete.isIncomplete) {
          await document2.patchChange(true);
          let { changedtick } = document2;
          items = await complete.completeInComplete(search);
          if (complete.isCanceled || document2.changedtick != changedtick)
            return;
        } else {
          items = complete.filterResults(search);
        }
        if (!complete.isCompleting && items.length === 0) {
          this.stop();
          return;
        }
        await this.showCompletion(complete.option.col, items);
      }
      hasSelected() {
        if (workspace_default.env.pumevent)
          return this.selectedItem != null;
        if (!this.config.noselect)
          return true;
        return false;
      }
      async showCompletion(col, items) {
        let { nvim, document: document2, option } = this;
        let { numberSelect, disableKind, labelMaxLength, disableMenuShortcut, disableMenu } = this.config;
        let preselect = this.config.enablePreselect ? items.findIndex((o) => o.preselect) : -1;
        if (numberSelect && option.input.length && !/^\d/.test(option.input)) {
          items = items.map((item, i) => {
            let idx = i + 1;
            if (i < 9) {
              return Object.assign({}, item, {
                abbr: item.abbr ? `${idx} ${item.abbr}` : `${idx} ${item.word}`
              });
            }
            return item;
          });
          nvim.call("coc#_map", [], true);
        }
        this.changedTick = document2.changedtick;
        let validKeys2 = completeItemKeys.slice();
        if (disableKind)
          validKeys2 = validKeys2.filter((s) => s != "kind");
        if (disableMenu)
          validKeys2 = validKeys2.filter((s) => s != "menu");
        let vimItems = items.map((item) => {
          let obj = { word: item.word, equal: 1 };
          for (let key of validKeys2) {
            if (item.hasOwnProperty(key)) {
              if (disableMenuShortcut && key == "menu") {
                obj[key] = item[key].replace(/\[.+\]$/, "");
              } else if (key == "abbr" && item[key].length > labelMaxLength) {
                obj[key] = item[key].slice(0, labelMaxLength);
              } else {
                obj[key] = item[key];
              }
            }
          }
          return obj;
        });
        nvim.call("coc#_do_complete", [col, vimItems, preselect], true);
      }
      async _doComplete(option) {
        let { source } = option;
        let { nvim, config } = this;
        let doc = workspace_default.getDocument(option.bufnr);
        if (!doc || !doc.attached)
          return;
        option.filetype = doc.filetype;
        this.input = option.input;
        let arr = [];
        if (source == null) {
          arr = sources_default.getCompleteSources(option);
        } else {
          let s = sources_default.getSource(source);
          if (s)
            arr.push(s);
        }
        if (!arr.length)
          return;
        await doc.patchChange();
        if (doc.changedtick != option.changedtick)
          return;
        let complete = new Complete(option, doc, config, arr, nvim);
        this.start(complete);
        let items = await this.complete.doComplete();
        if (complete.isCanceled)
          return;
        if (items.length == 0 && !complete.isCompleting) {
          this.stop();
          return;
        }
        complete.onDidComplete(async () => {
          if (this.selectedItem != null)
            return;
          let search = this.getResumeInput();
          if (complete.isCanceled || search == null)
            return;
          let { input } = this.option;
          if (search == input) {
            let items2 = complete.filterResults(search, Math.floor(Date.now() / 1e3));
            await this.showCompletion(option.col, items2);
          } else {
            await this.resumeCompletion();
          }
        });
        if (items.length) {
          let search = this.getResumeInput();
          if (search == option.input) {
            await this.showCompletion(option.col, items);
          } else {
            await this.resumeCompletion(true);
          }
        }
      }
      async onTextChangedP(bufnr, info) {
        let { option, document: document2 } = this;
        let pretext = this.pretext = info.pre;
        if (!option || option.bufnr != bufnr || info.changedtick == this.changedTick)
          return;
        let hasInsert = this.latestInsert != null;
        this.lastInsert = null;
        if (info.pre.match(/^\s*/)[0] !== option.line.match(/^\s*/)[0]) {
          logger81.warn("Complete stopped by indent change.");
          this.stop(false);
          return;
        }
        if (!hasInsert || !pretext)
          return;
        if (sources_default.shouldTrigger(pretext, document2.filetype, document2.uri)) {
          await this.triggerCompletion(document2, pretext);
        } else {
          await this.resumeCompletion();
        }
      }
      async onTextChangedI(bufnr, info) {
        let { nvim, latestInsertChar, option } = this;
        let noChange = this.pretext == info.pre;
        let pretext = this.pretext = info.pre;
        this.lastInsert = null;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        if (!this.activated) {
          if (!latestInsertChar)
            return;
          let triggerSources = sources_default.getTriggerSources(pretext, doc.filetype, doc.uri);
          if (triggerSources.length) {
            await this.triggerCompletion(doc, this.pretext);
            return;
          }
          this.triggerTimer = setTimeout(async () => {
            await this.triggerCompletion(doc, pretext);
          }, this.config.triggerCompletionWait);
          return;
        }
        if (!option || bufnr != option.bufnr)
          return;
        if (option.linenr != info.lnum || option.col >= info.col - 1) {
          this.stop();
          return;
        }
        if (noChange && !latestInsertChar) {
          this.stop(false);
          return;
        }
        if (pretext && this.selectedItem && this.config.acceptSuggestionOnCommitCharacter && latestInsertChar) {
          let resolvedItem = this.getCompleteItem(this.selectedItem);
          let last = pretext[pretext.length - 1];
          if (sources_default.shouldCommit(resolvedItem, last)) {
            let { linenr, col, line, colnr } = this.option;
            this.stop();
            let { word } = resolvedItem;
            let newLine = `${line.slice(0, col)}${word}${latestInsertChar}${line.slice(colnr - 1)}`;
            await nvim.call("coc#util#setline", [linenr, newLine]);
            let curcol = col + word.length + 2;
            await nvim.call("cursor", [linenr, curcol]);
            await doc.patchChange();
            return;
          }
        }
        if (sources_default.shouldTrigger(pretext, doc.filetype, doc.uri)) {
          await this.triggerCompletion(doc, pretext);
        } else {
          await this.resumeCompletion();
        }
      }
      async triggerCompletion(doc, pre) {
        if (!doc || !doc.attached) {
          logger81.warn("Document not attached, suggest disabled.");
          return;
        }
        let shouldTrigger = this.shouldTrigger(doc, pre);
        if (!shouldTrigger)
          return;
        if (doc.getVar("suggest_disable")) {
          logger81.warn(`Suggest disabled by b:coc_suggest_disable`);
          return;
        }
        await doc.patchChange();
        let [disabled, option] = await this.nvim.eval('[get(b:,"coc_suggest_disable",0),coc#util#get_complete_option()]');
        if (disabled == 1) {
          logger81.warn(`Suggest disabled by b:coc_suggest_disable`);
          return;
        }
        if (option.blacklist && option.blacklist.includes(option.input)) {
          logger81.warn(`Suggest disabled by b:coc_suggest_blacklist`, option.blacklist);
          return;
        }
        if (pre.length) {
          option.triggerCharacter = pre.slice(-1);
        }
        logger81.debug("trigger completion with", option);
        await this.startCompletion(option);
      }
      async onCompleteDone(item) {
        let { document: document2, isActivated } = this;
        if (!isActivated || !document2 || !vimCompleteItem(item))
          return;
        let opt = Object.assign({}, this.option);
        let resolvedItem = this.getCompleteItem(item);
        this.stop();
        if (!resolvedItem)
          return;
        let timestamp = this.insertCharTs;
        let insertLeaveTs = this.insertLeaveTs;
        let source = new import_vscode_languageserver_protocol79.CancellationTokenSource();
        await this.doCompleteResolve(resolvedItem, source.token);
        source.dispose();
        await wait(50);
        if (this.insertCharTs != timestamp || this.insertLeaveTs != insertLeaveTs)
          return;
        let [visible, lnum, pre] = await this.nvim.eval(`[pumvisible(),line('.'),strpart(getline('.'), 0, col('.') - 1)]`);
        if (visible || lnum != opt.linenr || this.activated || !pre.endsWith(resolvedItem.word))
          return;
        await document2.patchChange(true);
        await this.doCompleteDone(resolvedItem, opt);
      }
      async doCompleteResolve(item, token) {
        let source = sources_default.getSource(item.source);
        if (source && typeof source.onCompleteResolve == "function") {
          try {
            await Promise.resolve(source.onCompleteResolve(item, token));
          } catch (e) {
            logger81.error("Error on complete resolve:", e.stack);
          }
        }
      }
      async doCompleteDone(item, opt) {
        let data = JSON.parse(item.user_data);
        let source = sources_default.getSource(data.source);
        if (source && typeof source.onCompleteDone === "function") {
          await Promise.resolve(source.onCompleteDone(item, opt));
        }
      }
      async onInsertLeave() {
        this.insertLeaveTs = Date.now();
        this.stop(false);
      }
      async onInsertEnter(bufnr) {
        if (!this.config.triggerAfterInsertEnter || this.config.autoTrigger !== "always")
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        let pre = await this.nvim.eval(`strpart(getline('.'), 0, col('.') - 1)`);
        if (!pre)
          return;
        await this.triggerCompletion(doc, pre);
      }
      async onInsertCharPre(character) {
        this.lastInsert = {
          character,
          timestamp: Date.now()
        };
        this.insertCharTs = this.lastInsert.timestamp;
      }
      get latestInsert() {
        let { lastInsert } = this;
        if (!lastInsert || Date.now() - lastInsert.timestamp > 500) {
          return null;
        }
        return lastInsert;
      }
      get latestInsertChar() {
        let { latestInsert } = this;
        if (!latestInsert)
          return "";
        return latestInsert.character;
      }
      shouldTrigger(doc, pre) {
        let autoTrigger = this.config.autoTrigger;
        if (autoTrigger == "none")
          return false;
        if (sources_default.shouldTrigger(pre, doc.filetype, doc.uri))
          return true;
        if (autoTrigger !== "always" || this.isActivated)
          return false;
        let last = pre.slice(-1);
        if (last && (doc.isWord(pre.slice(-1)) || last.codePointAt(0) > 255)) {
          let minLength = this.config.minTriggerInputLength;
          if (minLength == 1)
            return true;
          let input = this.getInput(doc, pre);
          return input.length >= minLength;
        }
        return false;
      }
      async onPumChange() {
        if (!this.popupEvent)
          return;
        let { col, row, height, width, scrollbar } = this.popupEvent;
        let bounding = { col, row, height, width, scrollbar };
        let resolvedItem = this.getCompleteItem(this.selectedItem);
        if (!resolvedItem) {
          this.floating.close();
          return;
        }
        let source = this.resolveTokenSource = new import_vscode_languageserver_protocol79.CancellationTokenSource();
        let { token } = source;
        await this.doCompleteResolve(resolvedItem, token);
        if (this.resolveTokenSource == source) {
          this.resolveTokenSource = null;
        }
        source.dispose();
        if (token.isCancellationRequested)
          return;
        let docs = resolvedItem.documentation;
        if (!docs && resolvedItem.info) {
          let { info } = resolvedItem;
          let isText = /^[\w-\s.,\t]+$/.test(info);
          docs = [{ filetype: isText ? "txt" : this.document.filetype, content: info }];
        }
        if (!docs || docs.length == 0) {
          this.floating.close();
        } else {
          if (this.config.floatEnable) {
            let source2 = new import_vscode_languageserver_protocol79.CancellationTokenSource();
            await this.floating.show(docs, bounding, Object.assign({}, this.config.floatConfig, {
              excludeImages: this.excludeImages
            }), source2.token);
          }
          if (!this.isActivated) {
            this.floating.close();
          }
        }
      }
      start(complete) {
        let { activated } = this;
        this.activated = true;
        if (activated) {
          this.complete.dispose();
        }
        this.complete = complete;
        if (!this.config.keepCompleteopt) {
          this.nvim.command(`noa set completeopt=${this.completeOpt}`, true);
        }
      }
      cancelResolve() {
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
          this.resolveTokenSource = null;
        }
      }
      stop(hide = true) {
        let { nvim } = this;
        if (!this.activated)
          return;
        this.cancelResolve();
        this.floating.close();
        this.activated = false;
        if (this.complete) {
          this.complete.dispose();
          this.complete = null;
        }
        nvim.pauseNotification();
        if (hide) {
          nvim.call("coc#_hide", [], true);
        }
        if (this.config.numberSelect) {
          nvim.call("coc#_unmap", [], true);
        }
        if (!this.config.keepCompleteopt) {
          nvim.command(`noa set completeopt=${workspace_default.completeOpt}`, true);
        }
        nvim.command(`let g:coc#_context = {'start': 0, 'preselect': -1,'candidates': []}`, true);
        nvim.resumeNotification(false, true);
      }
      getInput(document2, pre) {
        let input = "";
        for (let i = pre.length - 1; i >= 0; i--) {
          let ch = i == 0 ? null : pre[i - 1];
          if (!ch || !document2.isWord(ch)) {
            input = pre.slice(i, pre.length);
            break;
          }
        }
        return input;
      }
      getResumeInput() {
        let { option, pretext } = this;
        if (!option)
          return null;
        let buf = Buffer.from(pretext, "utf8");
        if (buf.length < option.col)
          return null;
        let input = buf.slice(option.col).toString("utf8");
        if (option.blacklist && option.blacklist.includes(input))
          return null;
        return input;
      }
      get completeOpt() {
        let { noselect, enablePreview } = this.config;
        let preview = enablePreview && !workspace_default.env.pumevent ? ",preview" : "";
        if (noselect)
          return `noselect,menuone${preview}`;
        return `noinsert,menuone${preview}`;
      }
      getCompleteItem(item) {
        if (!this.complete || !vimCompleteItem(item))
          return null;
        return this.complete.resolveCompletionItem(item);
      }
      dispose() {
        this.resolveTokenSource = null;
        disposeAll(this.disposables);
      }
    };
    completion_default = new Completion();
  }
});

// src/snippets/snippet.ts
var import_vscode_languageserver_protocol80, logger82, CocSnippet;
var init_snippet = __esm({
  "src/snippets/snippet.ts"() {
    import_vscode_languageserver_protocol80 = __toModule(require_main2());
    init_main2();
    init_position();
    init_parser2();
    init_string();
    logger82 = require_logger2()("snippets-snipet");
    CocSnippet = class {
      constructor(_snippetString, position, _variableResolver) {
        this._snippetString = _snippetString;
        this.position = position;
        this._variableResolver = _variableResolver;
        this._parser = new SnippetParser();
      }
      async init() {
        const snippet = this._parser.parse(this._snippetString, true);
        let { _variableResolver } = this;
        if (_variableResolver) {
          await snippet.resolveVariables(_variableResolver);
        }
        this.tmSnippet = snippet;
        this.update();
      }
      adjustPosition(characterCount, lineCount) {
        let { line, character } = this.position;
        this.position = {
          line: line + lineCount,
          character: character + characterCount
        };
        this.update();
      }
      adjustTextEdit(edit2, changedLine) {
        let { range, newText } = edit2;
        if (comparePosition(this.range.start, range.end) < 0) {
          let { start, end } = range;
          let overlaped = end.character - this.range.start.character;
          if (changedLine && comparePosition(this.range.start, start) > 0 && isSingleLine(range) && start.character - overlaped >= 0 && changedLine.slice(start.character - overlaped, start.character) == changedLine.slice(this.range.start.character, this.range.start.character + overlaped)) {
            edit2.range = range = import_vscode_languageserver_protocol80.Range.create(start.line, start.character - overlaped, end.line, end.character - overlaped);
          } else {
            return false;
          }
        }
        if (!newText.includes("\n") && comparePosition(range.start, range.end) == 0 && comparePosition(this.range.start, range.start) == 0) {
          let idx = this._placeholders.findIndex((o) => comparePosition(o.range.start, range.start) == 0);
          if (idx !== -1)
            return false;
        }
        let changed = getChangedPosition(this.range.start, edit2);
        if (changed.line == 0 && changed.character == 0)
          return true;
        this.adjustPosition(changed.character, changed.line);
        return true;
      }
      get isPlainText() {
        if (this._placeholders.length > 1)
          return false;
        return this._placeholders.every((o) => o.value == "");
      }
      get finalCount() {
        return this._placeholders.filter((o) => o.isFinalTabstop).length;
      }
      toString() {
        return this.tmSnippet.toString();
      }
      get range() {
        let { position } = this;
        const content = this.tmSnippet.toString();
        const doc = TextDocument2.create("untitled:/1", "snippet", 0, content);
        const pos = doc.positionAt(content.length);
        const end = pos.line == 0 ? position.character + pos.character : pos.character;
        return import_vscode_languageserver_protocol80.Range.create(position, import_vscode_languageserver_protocol80.Position.create(position.line + pos.line, end));
      }
      get firstPlaceholder() {
        let index = 0;
        for (let p of this._placeholders) {
          if (p.index == 0)
            continue;
          if (index == 0 || p.index < index) {
            index = p.index;
          }
        }
        return this.getPlaceholder(index);
      }
      get lastPlaceholder() {
        let index = 0;
        for (let p of this._placeholders) {
          if (index == 0 || p.index > index) {
            index = p.index;
          }
        }
        return this.getPlaceholder(index);
      }
      getPlaceholderById(id) {
        return this._placeholders.find((o) => o.id == id);
      }
      getPlaceholder(index) {
        let placeholders = this._placeholders.filter((o) => o.index == index);
        let filtered = placeholders.filter((o) => !o.transform);
        return filtered.length ? filtered[0] : placeholders[0];
      }
      getPrevPlaceholder(index) {
        if (index == 0)
          return this.lastPlaceholder;
        let prev = this.getPlaceholder(index - 1);
        if (!prev)
          return this.getPrevPlaceholder(index - 1);
        return prev;
      }
      getNextPlaceholder(index) {
        let indexes = this._placeholders.map((o) => o.index);
        let max = Math.max.apply(null, indexes);
        if (index >= max)
          return this.finalPlaceholder;
        let next = this.getPlaceholder(index + 1);
        if (!next)
          return this.getNextPlaceholder(index + 1);
        return next;
      }
      get finalPlaceholder() {
        return this._placeholders.find((o) => o.isFinalTabstop);
      }
      getPlaceholderByRange(range) {
        return this._placeholders.find((o) => rangeInRange(range, o.range));
      }
      insertSnippet(placeholder, snippet, range) {
        let { start } = placeholder.range;
        let editStart = import_vscode_languageserver_protocol80.Position.create(range.start.line - start.line, range.start.line == start.line ? range.start.character - start.character : range.start.character);
        let editEnd = import_vscode_languageserver_protocol80.Position.create(range.end.line - start.line, range.end.line == start.line ? range.end.character - start.character : range.end.character);
        let editRange2 = import_vscode_languageserver_protocol80.Range.create(editStart, editEnd);
        let first = this.tmSnippet.insertSnippet(snippet, placeholder.id, editRange2);
        this.update();
        return first;
      }
      updatePlaceholder(placeholder, edit2) {
        let { range } = this;
        let { value, id, index } = placeholder;
        let newText = editRange(placeholder.range, value, edit2);
        let delta = 0;
        if (!newText.includes("\n")) {
          for (let p of this._placeholders) {
            if (p.index == index && p.id < id && p.line == placeholder.range.start.line) {
              let text = this.tmSnippet.getPlaceholderText(p.id, newText);
              delta = delta + byteLength(text) - byteLength(p.value);
            }
          }
        }
        if (placeholder.isVariable) {
          this.tmSnippet.updateVariable(id, newText);
        } else {
          this.tmSnippet.updatePlaceholder(id, newText);
        }
        let endPosition = adjustPosition(range.end, edit2);
        let snippetEdit = {
          range: import_vscode_languageserver_protocol80.Range.create(range.start, endPosition),
          newText: this.tmSnippet.toString()
        };
        this.update();
        return { edits: [snippetEdit], delta };
      }
      update() {
        const snippet = this.tmSnippet;
        const { line, character } = this.position;
        const document2 = TextDocument2.create("untitled:/1", "snippet", 0, snippet.toString());
        const { placeholders, variables, maxIndexNumber } = snippet;
        const variableIndexMap = new Map();
        let variableIndex = maxIndexNumber + 1;
        this._placeholders = [...placeholders, ...variables].map((p, idx) => {
          const offset = snippet.offset(p);
          const position = document2.positionAt(offset);
          const start = {
            line: line + position.line,
            character: position.line == 0 ? character + position.character : position.character
          };
          let index;
          if (p instanceof Variable) {
            let key = p.name;
            if (variableIndexMap.has(key)) {
              index = variableIndexMap.get(key);
            } else {
              variableIndexMap.set(key, variableIndex);
              index = variableIndex;
              variableIndex = variableIndex + 1;
            }
          } else {
            index = p.index;
          }
          const value = p.toString();
          const lines = value.split(/\r?\n/);
          let res = {
            range: import_vscode_languageserver_protocol80.Range.create(start, {
              line: start.line + lines.length - 1,
              character: lines.length == 1 ? start.character + value.length : lines[lines.length - 1].length
            }),
            transform: p.transform != null,
            line: start.line,
            id: idx,
            index,
            value,
            isVariable: p instanceof Variable,
            isFinalTabstop: p.index === 0
          };
          Object.defineProperty(res, "snippet", {
            enumerable: false
          });
          if (p instanceof Placeholder && p.choice) {
            let { options } = p.choice;
            if (options && options.length) {
              res.choice = options.map((o) => o.value);
            }
          }
          return res;
        });
      }
    };
  }
});

// src/snippets/variableResolve.ts
var import_path33, logger83, SnippetVariableResolver;
var init_variableResolve = __esm({
  "src/snippets/variableResolve.ts"() {
    import_path33 = __toModule(require("path"));
    init_window();
    logger83 = require_logger2()("snippets-variable");
    SnippetVariableResolver = class {
      constructor() {
        this._variableToValue = {};
        const currentDate = new Date();
        Object.assign(this._variableToValue, {
          CURRENT_YEAR: currentDate.getFullYear().toString(),
          CURRENT_YEAR_SHORT: currentDate.getFullYear().toString().slice(-2),
          CURRENT_MONTH: (currentDate.getMonth() + 1).toString(),
          CURRENT_DATE: currentDate.getDate().toString(),
          CURRENT_HOUR: currentDate.getHours().toString(),
          CURRENT_MINUTE: currentDate.getMinutes().toString(),
          CURRENT_SECOND: currentDate.getSeconds().toString(),
          CURRENT_DAY_NAME: currentDate.toLocaleString("en-US", { weekday: "long" }),
          CURRENT_DAY_NAME_SHORT: currentDate.toLocaleString("en-US", { weekday: "short" }),
          CURRENT_MONTH_NAME: currentDate.toLocaleString("en-US", { month: "long" }),
          CURRENT_MONTH_NAME_SHORT: currentDate.toLocaleString("en-US", { month: "short" }),
          TM_FILENAME: null,
          TM_FILENAME_BASE: null,
          TM_DIRECTORY: null,
          TM_FILEPATH: null,
          YANK: null,
          TM_LINE_INDEX: null,
          TM_LINE_NUMBER: null,
          TM_CURRENT_LINE: null,
          TM_CURRENT_WORD: null,
          TM_SELECTED_TEXT: null,
          CLIPBOARD: null
        });
      }
      async resolveValue(name2) {
        let { nvim } = window_default;
        if (["TM_FILENAME", "TM_FILENAME_BASE", "TM_DIRECTORY", "TM_FILEPATH"].includes(name2)) {
          let filepath = await nvim.eval('expand("%:p")');
          if (name2 == "TM_FILENAME")
            return import_path33.default.basename(filepath);
          if (name2 == "TM_FILENAME_BASE")
            return import_path33.default.basename(filepath, import_path33.default.extname(filepath));
          if (name2 == "TM_DIRECTORY")
            return import_path33.default.dirname(filepath);
          if (name2 == "TM_FILEPATH")
            return filepath;
        }
        if (name2 == "YANK") {
          let yank = await nvim.call("getreg", ['""']);
          return yank;
        }
        if (name2 == "TM_LINE_INDEX") {
          let lnum = await nvim.call("line", ["."]);
          return (lnum - 1).toString();
        }
        if (name2 == "TM_LINE_NUMBER") {
          let lnum = await nvim.call("line", ["."]);
          return lnum.toString();
        }
        if (name2 == "TM_CURRENT_LINE") {
          let line = await nvim.call("getline", ["."]);
          return line;
        }
        if (name2 == "TM_CURRENT_WORD") {
          let word = await nvim.eval(`expand('<cword>')`);
          return word;
        }
        if (name2 == "TM_SELECTED_TEXT") {
          let text = await nvim.eval(`get(g:,'coc_selected_text', '')`);
          return text;
        }
        if (name2 == "CLIPBOARD") {
          return await nvim.eval("@*");
        }
      }
      async resolve(variable) {
        const name2 = variable.name;
        let resolved = this._variableToValue[name2];
        if (resolved != null)
          return resolved.toString();
        let value = await this.resolveValue(name2);
        if (value)
          return value;
        if (variable.children && variable.children.length) {
          return variable.toString();
        }
        if (!this._variableToValue.hasOwnProperty(name2)) {
          return name2;
        }
        return "";
      }
    };
  }
});

// src/util/textedit.ts
function singleLineEdit(edit2) {
  let { range, newText } = edit2;
  return range.start.line == range.end.line && newText.indexOf("\n") == -1;
}
var init_textedit = __esm({
  "src/util/textedit.ts"() {
  }
});

// src/snippets/session.ts
function normalizeSnippetString(snippet, indent, opts) {
  let lines = snippet.split(/\r?\n/);
  let ind = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
  let tabSize = opts.tabSize || 2;
  lines = lines.map((line, idx) => {
    let space = line.match(/^\s*/)[0];
    let pre = space;
    let isTab = space.startsWith("	");
    if (isTab && opts.insertSpaces) {
      pre = ind.repeat(space.length);
    } else if (!isTab && !opts.insertSpaces) {
      pre = ind.repeat(space.length / tabSize);
    }
    return (idx == 0 || line.length == 0 ? "" : indent) + pre + line.slice(space.length);
  });
  return lines.join("\n");
}
var import_vscode_languageserver_protocol81, logger84, SnippetSession;
var init_session2 = __esm({
  "src/snippets/session.ts"() {
    import_vscode_languageserver_protocol81 = __toModule(require_main2());
    init_completion();
    init_position();
    init_string();
    init_workspace();
    init_window();
    init_events();
    init_snippet();
    init_variableResolve();
    init_textedit();
    logger84 = require_logger2()("snippets-session");
    SnippetSession = class {
      constructor(nvim, bufnr) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this._isActive = false;
        this._currId = 0;
        this.applying = false;
        this.preferComplete = false;
        this._snippet = null;
        this._onCancelEvent = new import_vscode_languageserver_protocol81.Emitter();
        this.onCancel = this._onCancelEvent.event;
        let suggest = workspace_default.getConfiguration("suggest");
        this.preferComplete = suggest.get("preferCompleteThanJumpPlaceholder", false);
      }
      async start(snippetString, select = true, range, insertTextMode) {
        const { document: document2 } = this;
        if (!document2 || !document2.attached)
          return false;
        void events_default.fire("InsertSnippet", []);
        if (!range) {
          let position2 = await window_default.getCursorPosition();
          range = import_vscode_languageserver_protocol81.Range.create(position2, position2);
        }
        let position = range.start;
        const formatOptions = await workspace_default.getFormatOptions(this.document.uri);
        await document2.patchChange(true);
        const currentLine = document2.getline(position.line);
        const currentIndent = currentLine.match(/^\s*/)[0];
        let inserted = "";
        if (insertTextMode === import_vscode_languageserver_protocol81.InsertTextMode.asIs) {
          inserted = snippetString;
        } else {
          inserted = normalizeSnippetString(snippetString, currentIndent, formatOptions);
        }
        const resolver = new SnippetVariableResolver();
        const snippet = new CocSnippet(inserted, position, resolver);
        await snippet.init();
        const edit2 = import_vscode_languageserver_protocol81.TextEdit.replace(range, snippet.toString());
        if (snippetString.endsWith("\n") && currentLine.slice(position.character).length) {
          edit2.newText = edit2.newText + currentIndent;
          inserted = inserted + currentIndent;
        }
        this.applying = true;
        await document2.applyEdits([edit2]);
        this.applying = false;
        if (this._isActive) {
          let placeholder = this.findPlaceholder(range);
          if (placeholder && !placeholder.isFinalTabstop) {
            let index = this.snippet.insertSnippet(placeholder, inserted, range);
            let p = this.snippet.getPlaceholder(index);
            this._currId = p.id;
            if (select)
              await this.selectPlaceholder(p);
            return true;
          }
        }
        if (snippet.isPlainText) {
          this.deactivate();
          let placeholder = snippet.finalPlaceholder;
          await window_default.moveTo(placeholder.range.start);
          return false;
        }
        this._snippet = snippet;
        this._currId = snippet.firstPlaceholder.id;
        if (select)
          await this.selectPlaceholder(snippet.firstPlaceholder);
        this.activate();
        return true;
      }
      activate() {
        if (this._isActive)
          return;
        this._isActive = true;
        this.nvim.call("coc#snippet#enable", [], true);
      }
      deactivate() {
        if (this._isActive) {
          this._isActive = false;
          this._snippet = null;
          this.nvim.call("coc#snippet#disable", [], true);
          logger84.debug("[SnippetManager::cancel]");
        }
        this._onCancelEvent.fire(void 0);
        this._onCancelEvent.dispose();
      }
      get isActive() {
        return this._isActive;
      }
      async nextPlaceholder() {
        if (!this.isActive)
          return;
        await this.document.patchChange();
        let curr = this.placeholder;
        let next = this.snippet.getNextPlaceholder(curr.index);
        await this.selectPlaceholder(next);
      }
      async previousPlaceholder() {
        if (!this.isActive)
          return;
        await this.document.patchChange();
        let curr = this.placeholder;
        let prev = this.snippet.getPrevPlaceholder(curr.index);
        await this.selectPlaceholder(prev);
      }
      async synchronizeUpdatedPlaceholders(change, changedLine) {
        if (!this.isActive || !this.document || this.applying)
          return;
        let edit2 = { range: change.range, newText: change.text };
        let { snippet } = this;
        let adjusted = snippet.adjustTextEdit(edit2, changedLine);
        if (adjusted)
          return;
        let currRange = this.placeholder.range;
        if (changedLine != null && singleLineEdit(edit2) && !rangeInRange(edit2.range, currRange) && isSingleLine(currRange) && changedLine.slice(currRange.start.character, currRange.end.character) == this.placeholder.value && events_default.cursor && events_default.cursor.bufnr == this.bufnr && events_default.cursor.lnum == edit2.range.start.line + 1) {
          let col = events_default.cursor.col;
          let preText = changedLine.slice(0, currRange.start.character);
          let postText = changedLine.slice(currRange.end.character);
          let newLine = this.document.getline(edit2.range.start.line);
          if (newLine.startsWith(preText) && newLine.endsWith(postText)) {
            let endCharacter = newLine.length - postText.length;
            let cursorIdx = characterIndex(newLine, col - 1);
            if (cursorIdx >= preText.length && cursorIdx <= endCharacter) {
              let newText = newLine.slice(preText.length, endCharacter);
              edit2 = import_vscode_languageserver_protocol81.TextEdit.replace(currRange, newText);
            }
          }
        }
        if (comparePosition(edit2.range.start, snippet.range.end) > 0) {
          if (!edit2.newText)
            return;
          logger84.info("Content change after snippet, cancelling snippet session");
          this.deactivate();
          return;
        }
        let placeholder = this.findPlaceholder(edit2.range);
        if (!placeholder) {
          logger84.info("Change outside placeholder, cancelling snippet session");
          this.deactivate();
          return;
        }
        if (placeholder.isFinalTabstop && snippet.finalCount <= 1) {
          logger84.info("Change final placeholder, cancelling snippet session");
          this.deactivate();
          return;
        }
        this._currId = placeholder.id;
        let { edits, delta } = snippet.updatePlaceholder(placeholder, edit2);
        if (!edits.length)
          return;
        this.applying = true;
        await this.document.applyEdits(edits);
        this.applying = false;
        if (delta) {
          await this.nvim.call("coc#cursor#move_by_col", delta);
        }
      }
      async selectCurrentPlaceholder(triggerAutocmd = true) {
        let placeholder = this.snippet.getPlaceholderById(this._currId);
        if (placeholder)
          await this.selectPlaceholder(placeholder, triggerAutocmd);
      }
      async selectPlaceholder(placeholder, triggerAutocmd = true) {
        let { nvim, document: document2 } = this;
        if (!document2 || !placeholder)
          return;
        let { start, end } = placeholder.range;
        const len = end.character - start.character;
        const col = byteLength(document2.getline(start.line).slice(0, start.character)) + 1;
        this._currId = placeholder.id;
        if (placeholder.choice) {
          await nvim.call("coc#snippet#show_choices", [start.line + 1, col, len, placeholder.choice]);
          if (triggerAutocmd)
            nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
        } else {
          await this.select(placeholder, triggerAutocmd);
        }
      }
      async select(placeholder, triggerAutocmd = true) {
        let { range, value, isFinalTabstop } = placeholder;
        let { document: document2, nvim } = this;
        let { start, end } = range;
        let { textDocument } = document2;
        let len = textDocument.offsetAt(end) - textDocument.offsetAt(start);
        let line = document2.getline(start.line);
        let col = line ? byteLength(line.slice(0, start.character)) : 0;
        let endLine = document2.getline(end.line);
        let endCol = endLine ? byteLength(endLine.slice(0, end.character)) : 0;
        nvim.setVar("coc_last_placeholder", {
          bufnr: document2.bufnr,
          current_text: value,
          start: { line: start.line, col, character: start.character },
          end: { line: end.line, col: endCol, character: end.character }
        }, true);
        let [ve, selection, pumvisible, mode] = await nvim.eval("[&virtualedit, &selection, pumvisible(), mode()]");
        let move_cmd = "";
        if (pumvisible && this.preferComplete) {
          let pre = completion_default.hasSelected() ? "" : "\\<C-n>";
          await nvim.eval(`feedkeys("${pre}\\<C-y>", 'in')`);
          return;
        }
        if (mode != "n")
          move_cmd += "\\<Esc>";
        if (len == 0) {
          if (col == 0 || !mode.startsWith("i") && col < byteLength(line)) {
            move_cmd += "i";
          } else {
            move_cmd += "a";
          }
        } else {
          move_cmd += "v";
          endCol = await this.getVirtualCol(end.line + 1, endCol);
          if (selection == "inclusive") {
            if (end.character == 0) {
              move_cmd += `${end.line}G`;
            } else {
              move_cmd += `${end.line + 1}G${endCol}|`;
            }
          } else if (selection == "old") {
            move_cmd += `${end.line + 1}G${endCol}|`;
          } else {
            move_cmd += `${end.line + 1}G${endCol + 1}|`;
          }
          col = await this.getVirtualCol(start.line + 1, col);
          move_cmd += `o${start.line + 1}G${col + 1}|o\\<c-g>`;
        }
        if (mode == "i" && move_cmd == "\\<Esc>a") {
          move_cmd = "";
        }
        nvim.pauseNotification();
        nvim.setOption("virtualedit", "onemore", true);
        nvim.call("cursor", [start.line + 1, col + (move_cmd == "a" ? 0 : 1)], true);
        if (move_cmd) {
          nvim.call("eval", [`feedkeys("${move_cmd}", 'in')`], true);
        }
        if (mode == "i") {
          nvim.call("coc#_cancel", [], true);
        }
        nvim.setOption("virtualedit", ve, true);
        if (isFinalTabstop) {
          if (this.snippet.finalCount == 1) {
            logger84.info("Jump to final placeholder, cancelling snippet session");
            this.deactivate();
          } else {
            nvim.call("coc#snippet#disable", [], true);
          }
        }
        if (workspace_default.env.isVim)
          nvim.command("redraw", true);
        await nvim.resumeNotification();
        if (triggerAutocmd)
          nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
      }
      async getVirtualCol(line, col) {
        let { nvim } = this;
        return await nvim.eval(`virtcol([${line}, ${col}])`);
      }
      async checkPosition() {
        if (!this.isActive)
          return;
        let position = await window_default.getCursorPosition();
        if (this.snippet && positionInRange(position, this.snippet.range) != 0) {
          logger84.info("Cursor insert out of range, cancelling snippet session");
          this.deactivate();
        }
      }
      findPlaceholder(range) {
        if (!this.snippet)
          return null;
        let { placeholder } = this;
        if (placeholder && rangeInRange(range, placeholder.range))
          return placeholder;
        return this.snippet.getPlaceholderByRange(range) || null;
      }
      get placeholder() {
        if (!this.snippet)
          return null;
        return this.snippet.getPlaceholderById(this._currId);
      }
      get snippet() {
        return this._snippet;
      }
      get document() {
        return workspace_default.getDocument(this.bufnr);
      }
    };
  }
});

// src/snippets/manager.ts
var logger85, SnippetManager, manager_default3;
var init_manager4 = __esm({
  "src/snippets/manager.ts"() {
    init_events();
    init_workspace();
    init_window();
    init_parser2();
    init_session2();
    init_variableResolve();
    init_string2();
    logger85 = require_logger2()("snippets-manager");
    SnippetManager = class {
      constructor() {
        this.sessionMap = new Map();
        this.disposables = [];
        workspace_default.onDidChangeTextDocument(async (e) => {
          let session = this.getSession(e.bufnr);
          if (session) {
            let firstLine = e.originalLines[e.contentChanges[0].range.start.line] || "";
            await session.synchronizeUpdatedPlaceholders(e.contentChanges[0], firstLine);
          }
        }, null, this.disposables);
        workspace_default.onDidCloseTextDocument((textDocument) => {
          let doc = workspace_default.getDocument(textDocument.uri);
          if (!doc)
            return;
          let session = this.getSession(doc.bufnr);
          if (session)
            session.deactivate();
        }, null, this.disposables);
        events_default.on("BufEnter", async (bufnr) => {
          let session = this.getSession(bufnr);
          if (!this.statusItem)
            return;
          if (session && session.isActive) {
            this.statusItem.show();
          } else {
            this.statusItem.hide();
          }
        }, null, this.disposables);
        events_default.on("InsertEnter", async () => {
          let { session } = this;
          if (!session)
            return;
          await session.checkPosition();
        }, null, this.disposables);
      }
      init() {
        let config = workspace_default.getConfiguration("coc.preferences");
        this.statusItem = window_default.createStatusBarItem(0);
        this.statusItem.text = config.get("snippetStatusText", "SNIP");
      }
      async insertSnippet(snippet, select = true, range, insertTextMode) {
        let { bufnr } = workspace_default;
        let session = this.getSession(bufnr);
        if (!session) {
          session = new SnippetSession(workspace_default.nvim, bufnr);
          this.sessionMap.set(bufnr, session);
          session.onCancel(() => {
            this.sessionMap.delete(bufnr);
            if (workspace_default.bufnr == bufnr) {
              this.statusItem.hide();
            }
          });
        }
        let snippetStr = SnippetString.isSnippetString(snippet) ? snippet.value : snippet;
        let isActive = await session.start(snippetStr, select, range, insertTextMode);
        if (isActive)
          this.statusItem.show();
        return isActive;
      }
      async selectCurrentPlaceholder(triggerAutocmd = true) {
        let { session } = this;
        if (session)
          return await session.selectCurrentPlaceholder(triggerAutocmd);
      }
      async nextPlaceholder() {
        let { session } = this;
        if (session) {
          await session.nextPlaceholder();
        } else {
          workspace_default.nvim.call("coc#snippet#disable", [], true);
          this.statusItem.hide();
        }
        return "";
      }
      async previousPlaceholder() {
        let { session } = this;
        if (session) {
          await session.previousPlaceholder();
        } else {
          workspace_default.nvim.call("coc#snippet#disable", [], true);
          this.statusItem.hide();
        }
        return "";
      }
      cancel() {
        let session = this.getSession(workspace_default.bufnr);
        if (session)
          return session.deactivate();
        workspace_default.nvim.call("coc#snippet#disable", [], true);
        if (this.statusItem)
          this.statusItem.hide();
      }
      get session() {
        let session = this.getSession(workspace_default.bufnr);
        return session && session.isActive ? session : null;
      }
      isActived(bufnr) {
        let session = this.getSession(bufnr);
        return session && session.isActive ? true : false;
      }
      jumpable() {
        let { session } = this;
        if (!session)
          return false;
        let placeholder = session.placeholder;
        if (placeholder && !placeholder.isFinalTabstop) {
          return true;
        }
        return false;
      }
      getSession(bufnr) {
        return this.sessionMap.get(bufnr);
      }
      async resolveSnippet(body) {
        let parser2 = new SnippetParser();
        const snippet = parser2.parse(body, true);
        const resolver = new SnippetVariableResolver();
        await snippet.resolveVariables(resolver);
        return snippet;
      }
      dispose() {
        this.cancel();
        for (let d of this.disposables) {
          d.dispose();
        }
      }
    };
    manager_default3 = new SnippetManager();
  }
});

// src/commands.ts
var import_vscode_languageserver_protocol82, logger86, CommandItem, CommandManager, commands_default;
var init_commands2 = __esm({
  "src/commands.ts"() {
    import_vscode_languageserver_protocol82 = __toModule(require_main2());
    init_esm2();
    init_manager();
    init_manager4();
    init_util();
    init_workspace();
    init_window();
    logger86 = require_logger2()("commands");
    CommandItem = class {
      constructor(id, impl, thisArg, internal = false) {
        this.id = id;
        this.impl = impl;
        this.thisArg = thisArg;
        this.internal = internal;
      }
      execute(...args) {
        let { impl, thisArg } = this;
        return impl.apply(thisArg, args || []);
      }
      dispose() {
        this.thisArg = null;
        this.impl = null;
      }
    };
    CommandManager = class {
      constructor() {
        this.commands = new Map();
        this.titles = new Map();
        this.onCommandList = [];
      }
      init(nvim, plugin) {
        this.mru = workspace_default.createMru("commands");
        this.register({
          id: "vscode.open",
          execute: async (url) => {
            nvim.call("coc#util#open_url", url.toString(), true);
          }
        }, true);
        this.register({
          id: "workbench.action.reloadWindow",
          execute: async () => {
            await nvim.command("edit");
          }
        }, true);
        this.register({
          id: "editor.action.insertSnippet",
          execute: async (edit2) => {
            nvim.call("coc#_cancel", [], true);
            return await manager_default3.insertSnippet(edit2.newText, true, edit2.range);
          }
        }, true);
        this.register({
          id: "editor.action.doCodeAction",
          execute: async (action) => {
            await plugin.cocAction("doCodeAction", action);
          }
        }, true);
        this.register({
          id: "editor.action.triggerSuggest",
          execute: async () => {
            await wait(60);
            nvim.call("coc#start", [], true);
          }
        }, true);
        this.register({
          id: "editor.action.triggerParameterHints",
          execute: async () => {
            await wait(60);
            await plugin.cocAction("showSignatureHelp");
          }
        }, true);
        this.register({
          id: "editor.action.addRanges",
          execute: async (ranges) => {
            await plugin.cocAction("addRanges", ranges);
          }
        }, true);
        this.register({
          id: "editor.action.restart",
          execute: async () => {
            await wait(30);
            nvim.command("CocRestart", true);
          }
        }, true);
        this.register({
          id: "editor.action.showReferences",
          execute: async (_filepath, _position, references) => {
            await workspace_default.showLocations(references);
          }
        }, true);
        this.register({
          id: "editor.action.rename",
          execute: async (uri, position) => {
            await workspace_default.jumpTo(uri, position);
            await plugin.cocAction("rename");
          }
        }, true);
        this.register({
          id: "editor.action.format",
          execute: async () => {
            await plugin.cocAction("format");
          }
        }, true);
        this.register({
          id: "workspace.clearWatchman",
          execute: async () => {
            let res = await window_default.runTerminalCommand("watchman watch-del-all");
            if (res.success)
              window_default.showMessage("Cleared watchman watching directories.");
          }
        }, false, "run watch-del-all for watchman to free up memory.");
        this.register({
          id: "workspace.workspaceFolders",
          execute: async () => {
            let folders = workspace_default.workspaceFolders;
            let lines = folders.map((folder) => URI.parse(folder.uri).fsPath);
            await window_default.echoLines(lines);
          }
        }, false, "show opened workspaceFolders.");
        this.register({
          id: "workspace.renameCurrentFile",
          execute: async () => {
            await workspace_default.renameCurrent();
          }
        }, false, "change current filename to a new name and reload it.");
        this.register({
          id: "extensions.toggleAutoUpdate",
          execute: async () => {
            let config = workspace_default.getConfiguration("coc.preferences");
            let interval = config.get("extensionUpdateCheck", "daily");
            if (interval == "never") {
              config.update("extensionUpdateCheck", "daily", true);
              window_default.showMessage("Extension auto update enabled.", "more");
            } else {
              config.update("extensionUpdateCheck", "never", true);
              window_default.showMessage("Extension auto update disabled.", "more");
            }
          }
        }, false, "toggle auto update of extensions.");
        this.register({
          id: "workspace.diagnosticRelated",
          execute: () => manager_default.jumpRelated()
        }, false, "jump to related locations of current diagnostic.");
        this.register({
          id: "workspace.showOutput",
          execute: async (name2) => {
            if (name2) {
              window_default.showOutputChannel(name2);
            } else {
              let names = workspace_default.channelNames;
              if (names.length == 0)
                return;
              if (names.length == 1) {
                window_default.showOutputChannel(names[0]);
              } else {
                let idx = await window_default.showQuickpick(names);
                if (idx == -1)
                  return;
                let name3 = names[idx];
                window_default.showOutputChannel(name3);
              }
            }
          }
        }, false, "open output buffer to show output from languageservers or extensions.");
        this.register({
          id: "document.showIncomingCalls",
          execute: async () => {
            await plugin.cocAction("showIncomingCalls");
          }
        }, false, "show incoming calls in tree view.");
        this.register({
          id: "document.showOutgoingCalls",
          execute: async () => {
            await plugin.cocAction("showOutgoingCalls");
          }
        }, false, "show outgoing calls in tree view.");
        this.register({
          id: "document.echoFiletype",
          execute: async () => {
            let bufnr = await nvim.call("bufnr", "%");
            let doc = workspace_default.getDocument(bufnr);
            if (!doc)
              return;
            await window_default.echoLines([doc.filetype]);
          }
        }, false, "echo the mapped filetype of the current buffer");
        this.register({
          id: "document.renameCurrentWord",
          execute: async () => {
            let bufnr = await nvim.call("bufnr", "%");
            let doc = workspace_default.getDocument(bufnr);
            if (!doc)
              return;
            let edit2 = await plugin.cocAction("getWordEdit");
            if (!edit2) {
              window_default.showMessage("Invalid position", "warning");
              return;
            }
            let ranges = [];
            let { changes, documentChanges } = edit2;
            if (changes) {
              let edits = changes[doc.uri];
              if (edits)
                ranges = edits.map((e) => e.range);
            } else if (documentChanges) {
              for (let c of documentChanges) {
                if (import_vscode_languageserver_protocol82.TextDocumentEdit.is(c) && c.textDocument.uri == doc.uri) {
                  ranges = c.edits.map((e) => e.range);
                }
              }
            }
            if (ranges.length) {
              await plugin.cocAction("addRanges", ranges);
            }
          }
        }, false, "rename word under cursor in current buffer by use multiple cursors.");
        this.register({
          id: "document.jumpToNextSymbol",
          execute: async () => {
            let doc = await workspace_default.document;
            if (!doc)
              return;
            let ranges = await plugin.cocAction("symbolRanges");
            if (!ranges)
              return;
            let { textDocument } = doc;
            let offset = await window_default.getOffset();
            ranges.sort((a, b) => {
              if (a.start.line != b.start.line) {
                return a.start.line - b.start.line;
              }
              return a.start.character - b.start.character;
            });
            for (let i = 0; i <= ranges.length - 1; i++) {
              if (textDocument.offsetAt(ranges[i].start) > offset) {
                await window_default.moveTo(ranges[i].start);
                return;
              }
            }
            await window_default.moveTo(ranges[0].start);
          }
        }, false, "Jump to next symbol highlight position.");
        this.register({
          id: "workspace.openLocation",
          execute: async (winid, loc, openCommand) => {
            if (winid)
              await nvim.call("win_gotoid", [winid]);
            await workspace_default.jumpTo(loc.uri, loc.range.start, openCommand);
          }
        }, true);
        this.register({
          id: "document.jumpToPrevSymbol",
          execute: async () => {
            let doc = await workspace_default.document;
            if (!doc)
              return;
            let ranges = await plugin.cocAction("symbolRanges");
            if (!ranges)
              return;
            let { textDocument } = doc;
            let offset = await window_default.getOffset();
            ranges.sort((a, b) => {
              if (a.start.line != b.start.line) {
                return a.start.line - b.start.line;
              }
              return a.start.character - b.start.character;
            });
            for (let i = ranges.length - 1; i >= 0; i--) {
              if (textDocument.offsetAt(ranges[i].end) < offset) {
                await window_default.moveTo(ranges[i].start);
                return;
              }
            }
            await window_default.moveTo(ranges[ranges.length - 1].start);
          }
        }, false, "Jump to previous symbol highlight position.");
      }
      get commandList() {
        let res = [];
        for (let item of this.commands.values()) {
          if (!item.internal)
            res.push(item);
        }
        return res;
      }
      dispose() {
        for (const registration of this.commands.values()) {
          registration.dispose();
        }
        this.commands.clear();
      }
      execute(command) {
        let args = [command.command];
        let arr = command.arguments;
        if (arr)
          args.push(...arr);
        return this.executeCommand.apply(this, args);
      }
      register(command, internal = false, description) {
        for (const id of Array.isArray(command.id) ? command.id : [command.id]) {
          this.registerCommand(id, command.execute, command, internal);
          if (description)
            this.titles.set(id, description);
        }
        return command;
      }
      has(id) {
        return this.commands.has(id);
      }
      unregister(id) {
        let item = this.commands.get(id);
        if (!item)
          return;
        item.dispose();
        this.commands.delete(id);
      }
      registerCommand(id, impl, thisArg, internal = false) {
        if (id.startsWith("_"))
          internal = true;
        this.commands.set(id, new CommandItem(id, impl, thisArg, internal));
        return import_vscode_languageserver_protocol82.Disposable.create(() => {
          this.commands.delete(id);
        });
      }
      executeCommand(command, ...rest) {
        let cmd = this.commands.get(command);
        if (!cmd)
          throw new Error(`Command: ${command} not found`);
        return Promise.resolve(cmd.execute.apply(cmd, rest));
      }
      async addRecent(cmd) {
        await this.mru.add(cmd);
        await workspace_default.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
      }
      async repeatCommand() {
        let mruList = await this.mru.load();
        let first = mruList[0];
        if (first) {
          await this.executeCommand(first);
          await workspace_default.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
        }
      }
    };
    commands_default = new CommandManager();
  }
});

// src/cursors/range.ts
var logger87, TextRange;
var init_range = __esm({
  "src/cursors/range.ts"() {
    init_main();
    init_position();
    logger87 = require_logger2()("cursors-range");
    TextRange = class {
      constructor(line, start, end, text, preCount) {
        this.line = line;
        this.start = start;
        this.end = end;
        this.text = text;
        this.preCount = preCount;
        this.currStart = start;
        this.currEnd = end;
      }
      add(offset, add) {
        let { text, preCount } = this;
        let pre = offset == 0 ? "" : text.slice(0, offset);
        let post = text.slice(offset);
        this.text = `${pre}${add}${post}`;
        this.currStart = this.currStart + preCount * add.length;
        this.currEnd = this.currEnd + (preCount + 1) * add.length;
      }
      replace(begin, end, add = "") {
        let { text, preCount } = this;
        let pre = begin == 0 ? "" : text.slice(0, begin);
        let post = text.slice(end);
        this.text = pre + add + post;
        let l = end - begin - add.length;
        this.currStart = this.currStart - preCount * l;
        this.currEnd = this.currEnd - (preCount + 1) * l;
      }
      get range() {
        return Range.create(this.line, this.start, this.line, this.end);
      }
      get currRange() {
        return Range.create(this.line, this.currStart, this.line, this.currEnd);
      }
      applyEdit(edit2) {
        let { range, newText } = edit2;
        let start = range.start.character;
        let end = range.end.character;
        let isAdd = start == end;
        if (isAdd) {
          this.add(start - this.currStart, newText);
        } else {
          this.replace(start - this.currStart, end - this.currStart, newText);
        }
      }
      adjustFromEdit(edit2) {
        let { range, newText } = edit2;
        if (comparePosition(range.start, Position.create(this.line, this.currEnd)) > 0) {
          return;
        }
        let newLines = newText.split("\n");
        let changeCount = newLines.length - (range.end.line - range.start.line + 1);
        this.line = this.line + changeCount;
        if (range.end.line == this.line) {
          let remove = range.start.line == range.end.line ? range.end.character - range.start.character : range.end.character;
          if (newLines.length > 1 && range.start.line == range.end.line) {
            remove = remove + range.start.character;
          }
          let add = 0;
          if (newLines.length > 1) {
            add = newLines[newLines.length - 1].length;
          } else {
            if (range.start.line == range.end.line) {
              add = newText.length;
            } else {
              add = range.start.character + newText.length;
            }
          }
          let delta = add - remove;
          for (let key of ["start", "end", "currStart", "currEnd"]) {
            this[key] += delta;
          }
        }
      }
      sync() {
        this.start = this.currStart;
        this.end = this.currEnd;
      }
      get textEdit() {
        return {
          range: this.range,
          newText: this.text
        };
      }
    };
  }
});

// src/cursors/util.ts
function splitRange(doc, range) {
  let splited = [];
  for (let i = range.start.line; i <= range.end.line; i++) {
    let curr = doc.getline(i) || "";
    let sc = i == range.start.line ? range.start.character : 0;
    let ec = i == range.end.line ? range.end.character : curr.length;
    if (sc == ec)
      continue;
    splited.push(import_vscode_languageserver_protocol83.Range.create(i, sc, i, ec));
  }
  return splited;
}
function getVisualRanges(doc, range) {
  let { start, end } = range;
  if (start.line > end.line) {
    [start, end] = [end, start];
  }
  let sc = start.character < end.character ? start.character : end.character;
  let ec = start.character < end.character ? end.character : start.character;
  let ranges = [];
  for (let i = start.line; i <= end.line; i++) {
    let line = doc.getline(i);
    ranges.push(import_vscode_languageserver_protocol83.Range.create(i, sc, i, Math.min(line.length, ec)));
  }
  return ranges;
}
function adjustPosition2(position, delta) {
  let { line, character } = delta;
  return import_vscode_languageserver_protocol83.Position.create(position.line + line, line == 0 ? position.character + character : character);
}
function equalEdit(one, two) {
  if (one.newText.length != two.newText.length)
    return false;
  let { range } = one;
  if (range.end.character - range.start.character != two.range.end.character - two.range.start.character) {
    return false;
  }
  return true;
}
var import_vscode_languageserver_protocol83;
var init_util4 = __esm({
  "src/cursors/util.ts"() {
    import_vscode_languageserver_protocol83 = __toModule(require_main2());
  }
});

// src/cursors/session.ts
var import_fast_diff4, import_vscode_languageserver_protocol84, logger88, CursorSession;
var init_session3 = __esm({
  "src/cursors/session.ts"() {
    import_fast_diff4 = __toModule(require_diff());
    import_vscode_languageserver_protocol84 = __toModule(require_main2());
    init_main2();
    init_events();
    init_position();
    init_window();
    init_workspace();
    init_range();
    init_util4();
    logger88 = require_logger2()("cursors-session");
    CursorSession = class {
      constructor(nvim, doc, config) {
        this.nvim = nvim;
        this.doc = doc;
        this.config = config;
        this._onDidCancel = new import_vscode_languageserver_protocol84.Emitter();
        this.onDidCancel = this._onDidCancel.event;
        this.disposables = [];
        this.ranges = [];
        this.activated = true;
        this.changing = false;
        this.changed = false;
        this.textDocument = this.doc.textDocument;
        this.buffer.setVar("coc_cursors_activated", 1, true);
        let { cancelKey, nextKey, previousKey } = this.config;
        this.disposables.push(workspace_default.registerLocalKeymap("n", cancelKey, () => {
          this.cancel();
        }, true));
        this.disposables.push(workspace_default.registerLocalKeymap("n", nextKey, async () => {
          if (!this.activated)
            return;
          let ranges = this.ranges.map((o) => o.currRange);
          let curr = await window_default.getCursorPosition();
          for (let r of ranges) {
            if (comparePosition(r.start, curr) > 0) {
              await window_default.moveTo(r.start);
              return;
            }
          }
          if (ranges.length)
            await window_default.moveTo(ranges[0].start);
        }, true));
        this.disposables.push(workspace_default.registerLocalKeymap("n", previousKey, async () => {
          if (!this.activated)
            return;
          let ranges = this.ranges.map((o) => o.currRange);
          ranges.reverse();
          let curr = await window_default.getCursorPosition();
          for (let r of ranges) {
            if (comparePosition(r.end, curr) < 0) {
              await window_default.moveTo(r.start);
              return;
            }
          }
          if (ranges.length)
            await window_default.moveTo(ranges[ranges.length - 1].start);
        }, true));
        this.doc.onDocumentChange(this.onChange, this, this.disposables);
      }
      async onChange(e) {
        if (!this.activated || this.ranges.length == 0)
          return;
        if (this.changing)
          return;
        let change = e.contentChanges[0];
        let { text, range } = change;
        let intersect = this.ranges.some((r) => rangeIntersect(range, r.currRange));
        let begin = this.ranges[0].currRange.start;
        if (text.endsWith("\n") && comparePosition(begin, range.end) == 0) {
          intersect = false;
        }
        if (!intersect) {
          this.ranges.forEach((r) => {
            r.adjustFromEdit({ range, newText: text });
          });
          this.doHighlights();
          this.textDocument = this.doc.textDocument;
          return;
        }
        this.changed = true;
        let textRange = this.getTextRange(range, text);
        if (textRange) {
          await this.applySingleEdit(textRange, { range, newText: text });
        } else {
          this.applyComposedEdit(e.original, { range, newText: text });
          if (this.activated) {
            this.ranges.forEach((r) => {
              r.sync();
            });
            this.textDocument = this.doc.textDocument;
          }
        }
      }
      doHighlights() {
        let { nvim, buffer, ranges } = this;
        buffer.clearNamespace("cursors");
        let arr = ranges.map((o) => o.currRange);
        buffer.highlightRanges("cursors", "CocCursorRange", arr);
        nvim.command("redraw", true);
      }
      addRanges(ranges) {
        let { nvim, doc } = this;
        if (this.changed) {
          window_default.showMessage(`Can't add ranges after range change.`);
          return false;
        }
        this.ranges = this.ranges.filter((r) => {
          let { currRange } = r;
          return !ranges.some((range) => rangeOverlap(range, currRange));
        });
        let { textDocument } = doc;
        for (let range of ranges) {
          let { line } = range.start;
          let textRange = new TextRange(line, range.start.character, range.end.character, textDocument.getText(range), 0);
          this.ranges.push(textRange);
        }
        this.ranges.sort((a, b) => comparePosition(a.range.start, b.range.start));
        let preCount = 0;
        let currline = -1;
        for (let range of this.ranges) {
          let { line } = range;
          if (line != currline) {
            preCount = 0;
          }
          range.preCount = preCount;
          preCount = preCount + 1;
          currline = line;
        }
        nvim.pauseNotification();
        this.doHighlights();
        nvim.resumeNotification(false, true);
        return true;
      }
      cancel() {
        if (!this.activated)
          return;
        let { nvim } = this;
        this.activated = false;
        let { cancelKey, nextKey, previousKey } = this.config;
        nvim.pauseNotification();
        this.buffer.clearNamespace("cursors");
        this.buffer.setVar("coc_cursors_activated", 0, true);
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
        this._onDidCancel.fire();
      }
      dispose() {
        if (!this.doc)
          return;
        this._onDidCancel.dispose();
        for (let disposable of this.disposables) {
          disposable.dispose();
        }
        this.ranges = [];
        this.doc = null;
        this.textDocument = null;
      }
      get buffer() {
        return this.nvim.createBuffer(this.doc.bufnr);
      }
      getTextRange(range, text) {
        let { ranges } = this;
        if (text.indexOf("\n") !== -1 || range.start.line != range.end.line) {
          return null;
        }
        ranges.sort((a, b) => {
          if (a.line != b.line)
            return a.line - b.line;
          return a.currRange.start.character - b.currRange.start.character;
        });
        for (let i = 0; i < ranges.length; i++) {
          let r = ranges[i];
          if (rangeInRange(range, r.currRange)) {
            return r;
          }
          if (r.line != range.start.line) {
            continue;
          }
          if (text.length && range.start.character == r.currRange.end.character) {
            let next = ranges[i + 1];
            if (!next)
              return r;
            return positionInRange(next.currRange.start, range) ? null : r;
          }
        }
        return null;
      }
      adjustRanges(textRange, range, text) {
        let { ranges } = this;
        if (range.start.character == range.end.character) {
          let isEnd = textRange.currRange.end.character == range.start.character;
          if (isEnd) {
            ranges.forEach((r) => {
              r.add(r.text.length, text);
            });
          } else {
            let d = range.start.character - textRange.currRange.start.character;
            ranges.forEach((r) => {
              r.add(Math.min(r.text.length, d), text);
            });
          }
        } else {
          let d = range.end.character - range.start.character;
          let isEnd = textRange.currRange.end.character == range.end.character;
          if (isEnd) {
            if (textRange.currRange.start.character == range.start.character) {
              if (text.includes(textRange.text)) {
                let idx = text.indexOf(textRange.text);
                let pre = idx == 0 ? "" : text.slice(0, idx);
                let post = text.slice(idx + textRange.text.length);
                if (pre)
                  ranges.forEach((r) => r.add(0, pre));
                if (post)
                  ranges.forEach((r) => r.add(r.text.length, post));
              } else if (textRange.text.includes(text)) {
                let idx = textRange.text.indexOf(text);
                let offset = textRange.text.length - (idx + text.length);
                if (idx != 0)
                  ranges.forEach((r) => r.replace(0, idx));
                if (offset > 0)
                  ranges.forEach((r) => r.replace(r.text.length - offset, r.text.length));
              } else {
                this.cancel();
              }
            } else {
              ranges.forEach((r) => {
                let l = r.text.length;
                r.replace(Math.max(0, l - d), l, text);
              });
            }
          } else {
            let start = range.start.character - textRange.currRange.start.character;
            ranges.forEach((r) => {
              let l = r.text.length;
              r.replace(start, Math.min(start + d, l), text);
            });
          }
        }
      }
      addRange(range, text) {
        if (this.changed) {
          window_default.showMessage(`Can't add range after range change.`);
          return;
        }
        let { ranges } = this;
        let idx = ranges.findIndex((o) => rangeIntersect(o.range, range));
        if (idx !== -1) {
          ranges.splice(idx, 1);
          for (let r of ranges) {
            if (r.line == range.start.line && r.start > range.start.character) {
              r.preCount = r.preCount - 1;
            }
          }
        } else {
          let preCount = 0;
          let idx2 = 0;
          let { line } = range.start;
          for (let r of ranges) {
            if (r.line > line || r.line == line && r.start > range.end.character) {
              break;
            }
            if (r.line == line)
              preCount++;
            idx2++;
          }
          let created = new TextRange(line, range.start.character, range.end.character, text, preCount);
          ranges.splice(idx2, 0, created);
          for (let r of ranges) {
            if (r.line == range.start.line && r.start > range.start.character) {
              r.preCount = r.preCount + 1;
            }
          }
        }
        if (this.ranges.length == 0) {
          this.cancel();
        } else {
          this.doHighlights();
        }
      }
      async applySingleEdit(textRange, edit2) {
        let { range, newText } = edit2;
        let { doc } = this;
        this.adjustRanges(textRange, range, newText);
        if (this.ranges.length == 1) {
          this.doHighlights();
          return;
        }
        let edits = this.ranges.map((o) => o.textEdit);
        let content = TextDocument2.applyEdits(this.textDocument, edits);
        let newLines = content.split("\n");
        let changedLnum = new Set();
        let arr = [];
        for (let r of this.ranges) {
          if (!changedLnum.has(r.line)) {
            changedLnum.add(r.line);
            arr.push([r.line, newLines[r.line]]);
          }
        }
        let { nvim } = this;
        this.changing = true;
        await doc.changeLines(arr);
        this.changing = false;
        if (this.activated) {
          this.ranges.forEach((r) => {
            r.sync();
          });
          this.textDocument = this.doc.textDocument;
        }
        nvim.pauseNotification();
        let { cursor } = events_default;
        if (textRange.preCount > 0 && cursor.bufnr == doc.bufnr && textRange.line + 1 == cursor.lnum) {
          let changed = textRange.preCount * (newText.length - (range.end.character - range.start.character));
          nvim.call("cursor", [cursor.lnum, cursor.col + changed], true);
        }
        this.doHighlights();
        nvim.resumeNotification(false, true);
      }
      applyComposedEdit(original, edit2) {
        let { range, newText } = edit2;
        let { ranges } = this;
        let doc = TextDocument2.create("file:///1", "", 0, original);
        let edits = [];
        let diffs = (0, import_fast_diff4.default)(original, newText);
        let offset = 0;
        for (let i = 0; i < diffs.length; i++) {
          let diff = diffs[i];
          let pos = adjustPosition2(range.start, doc.positionAt(offset));
          if (diff[0] == import_fast_diff4.default.EQUAL) {
            offset = offset + diff[1].length;
          } else if (diff[0] == import_fast_diff4.default.DELETE) {
            let end = adjustPosition2(range.start, doc.positionAt(offset + diff[1].length));
            if (diffs[i + 1] && diffs[i + 1][0] == import_fast_diff4.default.INSERT) {
              edits.push({ range: import_vscode_languageserver_protocol84.Range.create(pos, end), newText: diffs[i + 1][1] });
              i = i + 1;
            } else {
              edits.push({ range: import_vscode_languageserver_protocol84.Range.create(pos, end), newText: "" });
            }
            offset = offset + diff[1].length;
          } else if (diff[0] == import_fast_diff4.default.INSERT) {
            edits.push({ range: import_vscode_languageserver_protocol84.Range.create(pos, pos), newText: diff[1] });
          }
        }
        if (edits.some((edit3) => edit3.newText.includes("\n") || edit3.range.start.line != edit3.range.end.line)) {
          this.cancel();
          return;
        }
        if (edits.length == ranges.length) {
          let last;
          for (let i = 0; i < edits.length; i++) {
            let edit3 = edits[i];
            let textRange = this.ranges[i];
            if (!rangeIntersect(textRange.currRange, edit3.range)) {
              this.cancel();
              return;
            }
            if (last && !equalEdit(edit3, last)) {
              this.cancel();
              return;
            }
            textRange.applyEdit(edit3);
            last = edit3;
          }
        } else if (edits.length == ranges.length * 2) {
          for (let i = 0; i < edits.length - 1; i = i + 2) {
            let edit3 = edits[i];
            let next = edits[i + 1];
            if (edit3.newText.length == 0 && next.newText.length == 0) {
              let textRange = this.ranges[i / 2];
              if (comparePosition(textRange.currRange.end, next.range.end) != 0) {
                this.cancel();
                return;
              }
              let start = edit3.range.start.character - textRange.currRange.start.character;
              textRange.replace(start, edit3.range.end.character - edit3.range.start.character, "");
              let offset2 = next.range.end.character - next.range.start.character;
              let len = textRange.text.length;
              textRange.replace(len - offset2, len);
            } else if (emptyRange(edit3.range) && emptyRange(next.range)) {
              let textRange = this.ranges[i / 2];
              if (comparePosition(textRange.currRange.end, next.range.start) != 0) {
                this.cancel();
                return;
              }
              let start = edit3.range.start.character - textRange.currRange.start.character;
              textRange.add(start, edit3.newText);
              let len = textRange.text.length;
              textRange.add(len, next.newText);
            } else {
              this.cancel();
              return;
            }
          }
        } else {
          this.cancel();
          return;
        }
        this.doHighlights();
      }
    };
  }
});

// src/cursors/index.ts
var logger89, Cursors;
var init_cursors = __esm({
  "src/cursors/index.ts"() {
    init_main();
    init_events();
    init_position();
    init_window();
    init_workspace();
    init_session3();
    init_util4();
    logger89 = require_logger2()("cursors");
    Cursors = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.sessionsMap = new Map();
        this.disposables = [];
        this.loadConfig();
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("cursors")) {
            this.loadConfig();
          }
        }, null, this.disposables);
        events_default.on("BufUnload", (bufnr) => {
          let session = this.getSession(bufnr);
          if (!session)
            return;
          session.dispose();
          this.sessionsMap.delete(bufnr);
        }, null, this.disposables);
      }
      loadConfig() {
        let config = workspace_default.getConfiguration("cursors");
        this.config = {
          nextKey: config.get("nextKey", "<C-n>"),
          previousKey: config.get("previousKey", "<C-p>"),
          cancelKey: config.get("cancelKey", "<esc>")
        };
      }
      getSession(bufnr) {
        return this.sessionsMap.get(bufnr);
      }
      async isActivated() {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        return this.sessionsMap.get(bufnr) != null;
      }
      async select(bufnr, kind, mode) {
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached) {
          window_default.showMessage(`buffer ${bufnr} not attached.`);
          return;
        }
        let { nvim } = this;
        let session = this.createSession(doc);
        let pos = await window_default.getCursorPosition();
        let range;
        if (kind == "operator") {
          await nvim.command(`normal! ${mode == "line" ? `'[` : "`["}`);
          let start = await window_default.getCursorPosition();
          await nvim.command(`normal! ${mode == "line" ? `']` : "`]"}`);
          let end = await window_default.getCursorPosition();
          await window_default.moveTo(pos);
          let relative = comparePosition(start, end);
          if (relative == 0)
            return;
          if (relative >= 0)
            [start, end] = [end, start];
          let line = doc.getline(end.line);
          if (end.character < line.length) {
            end.character = end.character + 1;
          }
          let ranges = splitRange(doc, Range.create(start, end));
          for (let r of ranges) {
            let text = doc.textDocument.getText(r);
            session.addRange(r, text);
          }
        } else if (kind == "word") {
          range = doc.getWordRangeAtPosition(pos);
          if (!range) {
            let line2 = doc.getline(pos.line);
            if (pos.character == line2.length) {
              range = Range.create(pos.line, Math.max(0, line2.length - 1), pos.line, line2.length);
            } else {
              range = Range.create(pos.line, pos.character, pos.line, pos.character + 1);
            }
          }
          let line = doc.getline(pos.line);
          let text = line.slice(range.start.character, range.end.character);
          session.addRange(range, text);
        } else if (kind == "position") {
          let line = doc.getline(pos.line);
          if (pos.character >= line.length) {
            range = Range.create(pos.line, line.length - 1, pos.line, line.length);
          } else {
            range = Range.create(pos.line, pos.character, pos.line, pos.character + 1);
          }
          session.addRange(range, line.slice(range.start.character, range.end.character));
        } else if (kind == "range") {
          await nvim.call("eval", 'feedkeys("\\<esc>", "in")');
          let range2 = await workspace_default.getSelectedRange(mode, doc);
          if (!range2 || comparePosition(range2.start, range2.end) == 0)
            return;
          let ranges = mode == "" ? getVisualRanges(doc, range2) : splitRange(doc, range2);
          for (let r of ranges) {
            let text = doc.textDocument.getText(r);
            session.addRange(r, text);
          }
        } else {
          window_default.showMessage(`${kind} not supported`, "error");
          return;
        }
        if (kind == "word" || kind == "position") {
          await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
        }
      }
      createSession(doc) {
        let session = this.getSession(doc.bufnr);
        if (session)
          return session;
        session = new CursorSession(this.nvim, doc, this.config);
        this.sessionsMap.set(doc.bufnr, session);
        session.onDidCancel(() => {
          session.dispose();
          this.sessionsMap.delete(doc.bufnr);
        });
        return session;
      }
      async addRanges(ranges) {
        let { nvim } = this;
        let bufnr = await nvim.call("bufnr", ["%"]);
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached) {
          window_default.showMessage("Document not attached", "error");
          return false;
        }
        let session = this.createSession(doc);
        return session.addRanges(ranges);
      }
      reset() {
        for (let session of this.sessionsMap.values()) {
          session.cancel();
        }
        this.sessionsMap.clear();
      }
      dispose() {
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        for (let disposable of this.disposables) {
          disposable.dispose();
        }
      }
    };
  }
});

// src/handler/codeActions.ts
var import_vscode_languageserver_protocol85, logger90, CodeActions;
var init_codeActions = __esm({
  "src/handler/codeActions.ts"() {
    init_manager();
    import_vscode_languageserver_protocol85 = __toModule(require_main2());
    init_commands2();
    init_workspace();
    init_window();
    init_languages();
    logger90 = require_logger2()("handler-codeActions");
    CodeActions = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        handler.addDisposable(commands_default.registerCommand("editor.action.organizeImport", async (bufnr) => {
          await this.organizeImport(bufnr);
        }));
        commands_default.titles.set("editor.action.organizeImport", "run organize import code action.");
      }
      async codeActionRange(start, end, only) {
        let { doc } = await this.handler.getCurrentState();
        await doc.synchronize();
        let line = doc.getline(end - 1);
        let range = import_vscode_languageserver_protocol85.Range.create(start - 1, 0, end - 1, line.length);
        let codeActions = await this.getCodeActions(doc, range, only ? [only] : null);
        if (!codeActions || codeActions.length == 0) {
          window_default.showMessage(`No${only ? " " + only : ""} code action available`, "warning");
          return;
        }
        let idx = await window_default.showMenuPicker(codeActions.map((o) => o.title), "Choose action");
        let action = codeActions[idx];
        if (action)
          await this.applyCodeAction(action);
      }
      async organizeImport(bufnr) {
        let { doc } = await this.handler.getCurrentState();
        if (bufnr && doc.bufnr != bufnr)
          return;
        await doc.synchronize();
        let actions = await this.getCodeActions(doc, void 0, [import_vscode_languageserver_protocol85.CodeActionKind.SourceOrganizeImports]);
        if (actions && actions.length) {
          await this.applyCodeAction(actions[0]);
          return;
        }
        throw new Error("Organize import action not found.");
      }
      async getCodeActions(doc, range, only) {
        range = range || import_vscode_languageserver_protocol85.Range.create(0, 0, doc.lineCount, 0);
        let diagnostics = manager_default.getDiagnosticsInRange(doc.textDocument, range);
        let context = { diagnostics };
        if (only && Array.isArray(only))
          context.only = only;
        let codeActions = await this.handler.withRequestToken("code action", (token) => {
          return languages_default.getCodeActions(doc.textDocument, range, context, token);
        });
        if (!codeActions || codeActions.length == 0)
          return [];
        codeActions = codeActions.filter((o) => !o.disabled);
        codeActions.sort((a, b) => {
          if (a.isPreferred && !b.isPreferred)
            return -1;
          if (b.isPreferred && !a.isPreferred)
            return 1;
          return 0;
        });
        return codeActions;
      }
      get floatActions() {
        if (!workspace_default.floatSupported)
          return false;
        let config = workspace_default.getConfiguration("coc.preferences");
        return config.get("floatActions", true);
      }
      async doCodeAction(mode, only) {
        let { doc } = await this.handler.getCurrentState();
        let range;
        if (mode)
          range = await workspace_default.getSelectedRange(mode, doc);
        await doc.synchronize();
        let codeActions = await this.getCodeActions(doc, range, Array.isArray(only) ? only : null);
        if (typeof only == "string") {
          codeActions = codeActions.filter((o) => o.title == only || o.command && o.command.title == only);
        } else if (Array.isArray(only)) {
          codeActions = codeActions.filter((o) => only.some((k) => o.kind && o.kind.startsWith(k)));
        }
        if (!codeActions || codeActions.length == 0) {
          window_default.showMessage(`No${only ? " " + only : ""} code action available`, "warning");
          return;
        }
        if (only && codeActions.length == 1) {
          await this.applyCodeAction(codeActions[0]);
          return;
        }
        let idx = this.floatActions ? await window_default.showMenuPicker(codeActions.map((o) => o.title), "Choose action") : await window_default.showQuickpick(codeActions.map((o) => o.title));
        let action = codeActions[idx];
        if (action)
          await this.applyCodeAction(action);
      }
      async getCurrentCodeActions(mode, only) {
        let { doc } = await this.handler.getCurrentState();
        let range;
        if (mode)
          range = await workspace_default.getSelectedRange(mode, doc);
        return await this.getCodeActions(doc, range, only);
      }
      async doQuickfix() {
        let actions = await this.getCurrentCodeActions("line", [import_vscode_languageserver_protocol85.CodeActionKind.QuickFix]);
        if (!actions || actions.length == 0) {
          throw new Error("No quickfix action available");
        }
        await this.applyCodeAction(actions[0]);
        this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-fix-current)", -1)`, true);
      }
      async applyCodeAction(action) {
        if (action.disabled) {
          throw new Error(`Action "${action.title}" is disabled: ${action.disabled.reason}`);
        }
        action = await this.handler.withRequestToken("resolve codeAction", (token) => {
          return languages_default.resolveCodeAction(action, token);
        });
        let { edit: edit2, command } = action;
        if (edit2)
          await workspace_default.applyEdit(edit2);
        if (command)
          await commands_default.execute(command);
      }
    };
  }
});

// src/handler/codelens/buffer.ts
var import_debounce10, import_vscode_languageserver_protocol86, logger91, CodeLensBuffer;
var init_buffer3 = __esm({
  "src/handler/codelens/buffer.ts"() {
    import_debounce10 = __toModule(require_debounce());
    import_vscode_languageserver_protocol86 = __toModule(require_main2());
    init_commands2();
    init_languages();
    init_window();
    init_workspace();
    logger91 = require_logger2()("codelens-buffer");
    CodeLensBuffer = class {
      constructor(nvim, bufnr, config) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this.config = config;
        this.fetchCodelenses = (0, import_debounce10.default)(() => {
          void this._fetchCodeLenses();
        }, 200);
        this.resolveCodeLens = (0, import_debounce10.default)(() => {
          void this._resolveCodeLenses();
        }, 200);
        this.fetchCodelenses();
      }
      currentCodeLens() {
        var _a2;
        return (_a2 = this.codeLenses) == null ? void 0 : _a2.codeLenses;
      }
      get enabled() {
        return this.textDocument && this.config.enabled && languages_default.hasProvider("codeLens", this.textDocument);
      }
      async forceFetch() {
        this.fetchCodelenses.clear();
        await this._fetchCodeLenses();
      }
      get textDocument() {
        var _a2;
        return (_a2 = workspace_default.getDocument(this.bufnr)) == null ? void 0 : _a2.textDocument;
      }
      async _fetchCodeLenses() {
        var _a2, _b;
        if (!this.enabled)
          return;
        this.cancel();
        let noFetch = !this.isChanged && !((_a2 = this.codeLenses) == null ? void 0 : _a2.hasError);
        if (!noFetch) {
          let { textDocument } = this;
          let version2 = textDocument.version;
          let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
          let token = tokenSource.token;
          let codeLenses2 = await languages_default.getCodeLens(textDocument, token);
          this.tokenSource = void 0;
          if (token.isCancellationRequested)
            return;
          if (!Array.isArray(codeLenses2) || codeLenses2.length == 0)
            return;
          let hasError = codeLenses2.some((o) => o == null);
          this.codeLenses = { version: version2, codeLenses: codeLenses2.filter((o) => o != null), hasError };
        }
        let codeLenses = (_b = this.codeLenses) == null ? void 0 : _b.codeLenses;
        if (codeLenses == null ? void 0 : codeLenses.length) {
          await this._resolveCodeLenses();
        }
      }
      async _resolveCodeLenses() {
        if (!this.enabled || !this.codeLenses || this.isChanged)
          return;
        let { codeLenses } = this.codeLenses;
        let [bufnr, start, end] = await this.nvim.eval(`[bufnr('%'),line('w0'),line('w$')]`);
        if (this.isChanged || bufnr != this.bufnr)
          return;
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
        }
        codeLenses = codeLenses.filter((o) => {
          let lnum = o.range.start.line + 1;
          return lnum >= start && lnum <= end;
        });
        if (codeLenses.length) {
          let tokenSource = this.resolveTokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
          let token = tokenSource.token;
          await Promise.all(codeLenses.map((codeLens) => languages_default.resolveCodeLens(codeLens, token)));
          this.resolveTokenSource = void 0;
          if (token.isCancellationRequested || this.isChanged)
            return;
        }
        if (!this.srcId)
          this.srcId = await this.nvim.createNamespace("coc-codelens");
        this.nvim.pauseNotification();
        this.clear(start - 1, end);
        this.setVirtualText(codeLenses);
        await this.nvim.resumeNotification();
      }
      get isChanged() {
        if (!this.textDocument || !this.codeLenses)
          return true;
        let { version: version2 } = this.codeLenses;
        return this.textDocument.version !== version2;
      }
      setVirtualText(codeLenses) {
        if (codeLenses.length == 0)
          return;
        let list2 = new Map();
        for (let codeLens of codeLenses) {
          let { range, command } = codeLens;
          if (!command)
            continue;
          let { line } = range.start;
          if (list2.has(line)) {
            list2.get(line).push(codeLens);
          } else {
            list2.set(line, [codeLens]);
          }
        }
        for (let lnum of list2.keys()) {
          let codeLenses2 = list2.get(lnum);
          let commands = codeLenses2.map((codeLens) => codeLens.command);
          commands = commands.filter((c) => c && c.title);
          let chunks = [];
          let n_commands = commands.length;
          for (let i = 0; i < n_commands; i++) {
            let c = commands[i];
            chunks.push([c.title.replace(/(\r\n|\r|\n|\s)+/g, " "), "CocCodeLens"]);
            if (i != n_commands - 1) {
              chunks.push([this.config.subseparator, "CocCodeLens"]);
            }
          }
          chunks.unshift([`${this.config.separator} `, "CocCodeLens"]);
          this.nvim.call("nvim_buf_set_virtual_text", [this.bufnr, this.srcId, lnum, chunks, {}], true);
        }
      }
      clear(start = 0, end = -1) {
        if (!this.srcId)
          return;
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.clearNamespace(this.srcId, start, end);
      }
      cleanUp() {
        this.clear();
        this.codeLenses = void 0;
      }
      getCodelenses() {
        var _a2;
        return (_a2 = this.codeLenses) == null ? void 0 : _a2.codeLenses;
      }
      async doAction(line) {
        var _a2;
        let { codeLenses } = (_a2 = this.codeLenses) != null ? _a2 : {};
        if (!(codeLenses == null ? void 0 : codeLenses.length))
          return;
        let commands = [];
        for (let codeLens of codeLenses) {
          let { range, command } = codeLens;
          if (!command || !range)
            continue;
          if (line == range.start.line) {
            commands.push(command);
          }
        }
        if (!commands.length)
          return;
        if (commands.length == 1) {
          await commands_default.execute(commands[0]);
        } else {
          let res = await window_default.showMenuPicker(commands.map((c) => c.title));
          if (res == -1)
            return;
          await commands_default.execute(commands[res]);
        }
      }
      cancel() {
        this.resolveCodeLens.clear();
        this.fetchCodelenses.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      onChange() {
        this.cancel();
        this.fetchCodelenses();
      }
      dispose() {
        this.clear();
        this.cancel();
        this.codeLenses = void 0;
      }
    };
  }
});

// src/handler/codelens/index.ts
var logger92, CodeLensManager2;
var init_codelens = __esm({
  "src/handler/codelens/index.ts"() {
    init_events();
    init_util();
    init_workspace();
    init_buffer3();
    logger92 = require_logger2()("codelens");
    CodeLensManager2 = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        this.setConfiguration();
        if (!workspace_default.isNvim)
          return;
        workspace_default.onDidChangeConfiguration((e) => {
          this.setConfiguration(e);
        });
        this.buffers = workspace_default.registerBufferSync((doc) => {
          if (doc.buftype != "")
            return void 0;
          return new CodeLensBuffer(nvim, doc.bufnr, this.config);
        });
        this.listen();
      }
      listen() {
        events_default.on("CursorMoved", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf)
            buf.resolveCodeLens();
        }, null, this.disposables);
        events_default.on("CursorHold", async (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf)
            await buf.forceFetch();
        }, this, this.disposables);
      }
      async checkProvider() {
        for (let buf of this.buffers.items) {
          await buf.forceFetch();
        }
      }
      setConfiguration(e) {
        if (e && !e.affectsConfiguration("codeLens"))
          return;
        let config = workspace_default.getConfiguration("codeLens");
        let enable = this.nvim.hasFunction("nvim_buf_set_virtual_text") && config.get("enable", false);
        if (e && enable != this.config.enabled) {
          if (enable) {
            this.listen();
          } else {
            disposeAll(this.disposables);
          }
          for (let buf of this.buffers.items) {
            if (enable) {
              buf.fetchCodelenses();
            } else {
              buf.cleanUp();
            }
          }
        }
        this.config = Object.assign(this.config || {}, {
          enabled: enable,
          separator: config.get("separator", "\u2023"),
          subseparator: config.get("subseparator", " ")
        });
      }
      async doAction() {
        let [bufnr, line] = await this.nvim.eval(`[bufnr("%"),line(".")-1]`);
        let buf = this.buffers.getItem(bufnr);
        await (buf == null ? void 0 : buf.doAction(line));
      }
      dispose() {
        this.buffers.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/util/color.ts
function pad(str) {
  return str.length == 1 ? `0${str}` : str;
}
function toHexString(color) {
  let c = toHexColor(color);
  return `${pad(c.red.toString(16))}${pad(c.green.toString(16))}${pad(c.blue.toString(16))}`;
}
function toHexColor(color) {
  let { red, green, blue: blue2 } = color;
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue2 * 255)
  };
}
function isDark(color) {
  let rgb = [color.red, color.green, color.blue];
  let lum = [];
  for (let i = 0; i < rgb.length; i++) {
    let chan = rgb[i];
    lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
  }
  let luma = 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  return luma <= 0.5;
}
var init_color = __esm({
  "src/util/color.ts"() {
  }
});

// src/handler/colors/colorBuffer.ts
var import_debounce11, import_vscode_languageserver_protocol87, logger93, ColorBuffer;
var init_colorBuffer = __esm({
  "src/handler/colors/colorBuffer.ts"() {
    import_debounce11 = __toModule(require_debounce());
    import_vscode_languageserver_protocol87 = __toModule(require_main2());
    init_languages();
    init_array();
    init_object();
    init_position();
    init_color();
    init_workspace();
    logger93 = require_logger2()("colors-buffer");
    ColorBuffer = class {
      constructor(nvim, bufnr, enabled, usedColors) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this.enabled = enabled;
        this.usedColors = usedColors;
        this._colors = [];
        this.highlight = (0, import_debounce11.default)(() => {
          void this.doHighlight();
        }, global.hasOwnProperty("__TEST__") ? 10 : 500);
      }
      onChange() {
        this.cancel();
        this.highlight();
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      get colors() {
        return this._colors;
      }
      hasColor() {
        return this._colors.length > 0;
      }
      setState(enabled) {
        this.enabled = enabled;
        if (enabled) {
          this.highlight();
        } else {
          this.clearHighlight();
        }
      }
      async doHighlight() {
        let doc = workspace_default.getDocument(this.bufnr);
        if (!doc || !this.enabled)
          return;
        try {
          this.tokenSource = new import_vscode_languageserver_protocol87.CancellationTokenSource();
          let { token } = this.tokenSource;
          if (this.version && doc.version == this.version)
            return;
          let { version: version2 } = doc;
          let colors;
          colors = await languages_default.provideDocumentColors(doc.textDocument, token);
          colors = colors || [];
          if (token.isCancellationRequested)
            return;
          this.version = version2;
          await this.addHighlight(colors);
        } catch (e) {
          logger93.error("Error on highlight:", e);
        }
      }
      async addHighlight(colors) {
        colors = colors || [];
        if (equals(this._colors, colors))
          return;
        let { nvim } = this;
        this._colors = colors;
        let groups = group(colors, 100);
        nvim.pauseNotification();
        this.buffer.clearNamespace("color");
        this.defineColors(colors);
        void nvim.resumeNotification(false, true);
        for (let colors2 of groups) {
          nvim.pauseNotification();
          let colorRanges = this.getColorRanges(colors2);
          for (let o of colorRanges) {
            this.highlightColor(o.ranges, o.color);
          }
          void nvim.resumeNotification(false, true);
        }
        if (workspace_default.isVim)
          this.nvim.command("redraw", true);
      }
      highlightColor(ranges, color) {
        let hlGroup = `BG${toHexString(color)}`;
        this.buffer.highlightRanges("color", hlGroup, ranges);
      }
      defineColors(colors) {
        for (let color of colors) {
          let hex = toHexString(color.color);
          if (!this.usedColors.has(hex)) {
            this.nvim.command(`hi BG${hex} guibg=#${hex} guifg=#${isDark(color.color) ? "ffffff" : "000000"}`, true);
            this.usedColors.add(hex);
          }
        }
      }
      getColorRanges(infos) {
        let res = [];
        for (let info of infos) {
          let { color, range } = info;
          let idx = res.findIndex((o) => equals(toHexColor(o.color), toHexColor(color)));
          if (idx == -1) {
            res.push({
              color,
              ranges: [range]
            });
          } else {
            let r = res[idx];
            r.ranges.push(range);
          }
        }
        return res;
      }
      clearHighlight() {
        this.highlight.clear();
        this._colors = [];
        this.version = null;
        this.buffer.clearNamespace("color");
      }
      hasColorAtPosition(position) {
        let { colors } = this;
        return colors.some((o) => positionInRange(position, o.range) == 0);
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      dispose() {
        this.highlight.clear();
        this.cancel();
      }
    };
  }
});

// src/handler/colors/index.ts
var import_vscode_languageserver_protocol88, logger94, Colors;
var init_colors = __esm({
  "src/handler/colors/index.ts"() {
    import_vscode_languageserver_protocol88 = __toModule(require_main2());
    init_commands2();
    init_extensions2();
    init_languages();
    init_util();
    init_color();
    init_window();
    init_workspace();
    init_colorBuffer();
    logger94 = require_logger2()("colors-index");
    Colors = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this._enabled = true;
        this.disposables = [];
        let config = workspace_default.getConfiguration("coc.preferences");
        this._enabled = config.get("colorSupport", true);
        let usedColors = new Set();
        this.highlighters = workspace_default.registerBufferSync((doc) => {
          let buf = new ColorBuffer(this.nvim, doc.bufnr, this._enabled, usedColors);
          buf.highlight();
          return buf;
        });
        extensions_default.onDidActiveExtension(() => {
          this.highlightAll();
        }, null, this.disposables);
        workspace_default.onDidChangeConfiguration(async (e) => {
          if (e.affectsConfiguration("coc.preferences.colorSupport")) {
            let config2 = workspace_default.getConfiguration("coc.preferences");
            let enabled = config2.get("colorSupport", true);
            this._enabled = enabled;
            for (let buf of this.highlighters.items) {
              buf.setState(enabled);
            }
          }
        }, null, this.disposables);
        this.disposables.push(commands_default.registerCommand("editor.action.pickColor", () => {
          return this.pickColor();
        }));
        commands_default.titles.set("editor.action.pickColor", "pick color from system color picker when possible.");
        this.disposables.push(commands_default.registerCommand("editor.action.colorPresentation", () => {
          return this.pickPresentation();
        }));
        commands_default.titles.set("editor.action.colorPresentation", "change color presentation.");
      }
      async pickPresentation() {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvier("documentColor", doc.textDocument);
        let info = await this.getColorInformation(doc.bufnr);
        if (!info)
          return window_default.showMessage("Color not found at current position", "warning");
        let document2 = await workspace_default.document;
        let tokenSource = new import_vscode_languageserver_protocol88.CancellationTokenSource();
        let presentations = await languages_default.provideColorPresentations(info, document2.textDocument, tokenSource.token);
        if (!(presentations == null ? void 0 : presentations.length))
          return;
        let res = await window_default.showMenuPicker(presentations.map((o) => o.label), "choose color:");
        if (res == -1)
          return;
        let presentation = presentations[res];
        let { textEdit, additionalTextEdits, label } = presentation;
        if (!textEdit)
          textEdit = { range: info.range, newText: label };
        await document2.applyEdits([textEdit]);
        if (additionalTextEdits) {
          await document2.applyEdits(additionalTextEdits);
        }
      }
      async pickColor() {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvier("documentColor", doc.textDocument);
        let info = await this.getColorInformation(doc.bufnr);
        if (!info)
          return window_default.showMessage("Color not found at current position", "warning");
        let { color } = info;
        let colorArr = [(color.red * 255).toFixed(0), (color.green * 255).toFixed(0), (color.blue * 255).toFixed(0)];
        let res = await this.nvim.call("coc#util#pick_color", [colorArr]);
        if (!res)
          return;
        let hex = toHexString({
          red: res[0] / 65535,
          green: res[1] / 65535,
          blue: res[2] / 65535,
          alpha: 1
        });
        let document2 = await workspace_default.document;
        await document2.applyEdits([{
          range: info.range,
          newText: `#${hex}`
        }]);
      }
      get enabled() {
        return this._enabled;
      }
      clearHighlight(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return;
        highlighter.clearHighlight();
      }
      hasColor(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return false;
        return highlighter.hasColor();
      }
      hasColorAtPosition(bufnr, position) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return false;
        return highlighter.hasColorAtPosition(position);
      }
      highlightAll() {
        for (let buf of this.highlighters.items) {
          buf.highlight();
        }
      }
      async doHighlight(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (highlighter)
          await highlighter.doHighlight();
      }
      async getColorInformation(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return null;
        let position = await window_default.getCursorPosition();
        for (let info of highlighter.colors) {
          let { range } = info;
          let { start, end } = range;
          if (position.line == start.line && position.character >= start.character && position.character <= end.character) {
            return info;
          }
        }
        return null;
      }
      dispose() {
        this.highlighters.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/commands.ts
var logger95, isVim6, Commands;
var init_commands3 = __esm({
  "src/handler/commands.ts"() {
    init_commands2();
    init_events();
    init_manager3();
    logger95 = require_logger2()("handler-commands");
    isVim6 = process.env.VIM_NODE_RPC == "1";
    Commands = class {
      constructor(nvim, env) {
        this.nvim = nvim;
        this.env = env;
        for (let item of env.vimCommands) {
          this.addVimCommand(item);
        }
      }
      addVimCommand(cmd) {
        let id = `vim.${cmd.id}`;
        commands_default.registerCommand(id, () => {
          this.nvim.command(cmd.cmd, true);
          if (isVim6)
            this.nvim.command("redraw", true);
        });
        if (cmd.title)
          commands_default.titles.set(id, cmd.title);
      }
      getCommandList() {
        return commands_default.commandList.map((o) => o.id);
      }
      async repeat() {
        await commands_default.repeatCommand();
      }
      async runCommand(id, ...args) {
        if (id) {
          await events_default.fire("Command", [id]);
          let res = await commands_default.executeCommand(id, ...args);
          if (args.length == 0) {
            await commands_default.addRecent(id);
          }
          return res;
        } else {
          await manager_default2.start(["commands"]);
        }
      }
      getCommands() {
        let list2 = commands_default.commandList;
        let res = [];
        let { titles } = commands_default;
        for (let item of list2) {
          res.push({
            id: item.id,
            title: titles.get(item.id) || ""
          });
        }
        return res;
      }
    };
  }
});

// src/handler/fold.ts
var FoldHandler;
var init_fold = __esm({
  "src/handler/fold.ts"() {
    init_languages();
    init_workspace();
    FoldHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
      }
      async fold(kind) {
        let { doc, winid } = await this.handler.getCurrentState();
        this.handler.checkProvier("foldingRange", doc.textDocument);
        await doc.synchronize();
        let win = this.nvim.createWindow(winid);
        let foldlevel = await this.nvim.eval("&foldlevel");
        let ranges = await this.handler.withRequestToken("foldingrange", (token) => {
          return languages_default.provideFoldingRanges(doc.textDocument, {}, token);
        }, true);
        if (!ranges || !ranges.length)
          return false;
        if (kind)
          ranges = ranges.filter((o) => o.kind == kind);
        ranges.sort((a, b) => b.startLine - a.startLine);
        this.nvim.pauseNotification();
        win.setOption("foldmethod", "manual", true);
        this.nvim.command("normal! zE", true);
        for (let range of ranges) {
          let { startLine, endLine } = range;
          let cmd = `${startLine + 1}, ${endLine + 1}fold`;
          this.nvim.command(cmd, true);
        }
        win.setOption("foldenable", true, true);
        win.setOption("foldlevel", foldlevel, true);
        if (workspace_default.isVim)
          this.nvim.command("redraw", true);
        await this.nvim.resumeNotification();
        return true;
      }
    };
  }
});

// src/handler/format.ts
var import_vscode_languageserver_protocol89, logger96, pairs, FormatHandler;
var init_format2 = __esm({
  "src/handler/format.ts"() {
    import_vscode_languageserver_protocol89 = __toModule(require_main2());
    init_events();
    init_languages();
    init_manager4();
    init_position();
    init_string();
    init_window();
    init_workspace();
    logger96 = require_logger2()("handler-format");
    pairs = new Map([
      ["<", ">"],
      [">", "<"],
      ["{", "}"],
      ["[", "]"],
      ["(", ")"]
    ]);
    FormatHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.loadPreferences();
        handler.addDisposable(workspace_default.onDidChangeConfiguration(this.loadPreferences, this));
        handler.addDisposable(workspace_default.onWillSaveTextDocument((event) => {
          let { languageId } = event.document;
          let filetypes = this.preferences.formatOnSaveFiletypes;
          if (filetypes.includes(languageId) || filetypes.includes("*")) {
            let willSaveWaitUntil = async () => {
              if (!languages_default.hasFormatProvider(event.document)) {
                logger96.warn(`Format provider not found for ${event.document.uri}`);
                return void 0;
              }
              let options = await workspace_default.getFormatOptions(event.document.uri);
              let tokenSource = new import_vscode_languageserver_protocol89.CancellationTokenSource();
              let timer = setTimeout(() => {
                logger96.warn(`Format on save ${event.document.uri} timeout after 0.5s`);
                tokenSource.cancel();
              }, 500);
              let textEdits = await languages_default.provideDocumentFormattingEdits(event.document, options, tokenSource.token);
              clearTimeout(timer);
              if (!textEdits && !tokenSource.token.isCancellationRequested) {
                logger96.want(`Format on save ${event.document.uri} get undefined result.`);
              }
              return textEdits;
            };
            event.waitUntil(willSaveWaitUntil());
          }
        }));
        let enterTs;
        let enterBufnr;
        handler.addDisposable(events_default.on("Enter", async (bufnr) => {
          enterTs = Date.now();
          enterBufnr = bufnr;
        }));
        handler.addDisposable(events_default.on("CursorMovedI", async (bufnr) => {
          if (bufnr == enterBufnr && Date.now() - enterTs < 100) {
            await this.handleEnter(bufnr);
          }
        }));
        let changedTs;
        let lastInsert;
        handler.addDisposable(events_default.on("InsertCharPre", async () => {
          lastInsert = Date.now();
        }));
        handler.addDisposable(events_default.on("TextChangedI", async (bufnr, info) => {
          changedTs = Date.now();
          if (!lastInsert || changedTs - lastInsert > 300)
            return;
          lastInsert = null;
          let pre = info.pre[info.pre.length - 1];
          if (pre)
            await this.tryFormatOnType(pre, bufnr);
        }));
        let lastEnterBufnr;
        let lastEnterTs;
        handler.addDisposable(events_default.on("InsertEnter", (bufnr) => {
          lastEnterBufnr = bufnr;
          lastEnterTs = Date.now();
        }));
        handler.addDisposable(events_default.on("TextChangedI", async (bufnr, info) => {
          if (!this.preferences.formatOnType && !/^\s*$/.test(info.pre))
            return;
          if (lastEnterBufnr != bufnr || !lastEnterTs || Date.now() - lastEnterTs > 30)
            return;
          lastEnterBufnr = void 0;
          await this.tryFormatOnType("\n", bufnr, true);
        }));
      }
      loadPreferences(e) {
        if (!e || e.affectsConfiguration("coc.preferences")) {
          let config = workspace_default.getConfiguration("coc.preferences");
          this.preferences = {
            formatOnType: config.get("formatOnType", false),
            formatOnSaveFiletypes: config.get("formatOnSaveFiletypes", []),
            formatOnTypeFiletypes: config.get("formatOnTypeFiletypes", []),
            bracketEnterImprove: config.get("bracketEnterImprove", true)
          };
        }
      }
      async tryFormatOnType(ch, bufnr, newLine = false) {
        if (!ch || isWord(ch) || !this.preferences.formatOnType)
          return;
        if (manager_default3.getSession(bufnr) != null)
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached || doc.isCommandLine)
          return;
        const filetypes = this.preferences.formatOnTypeFiletypes;
        if (filetypes.length && !filetypes.includes(doc.filetype) && !filetypes.includes("*")) {
          return;
        }
        if (!languages_default.hasProvider("formatOnType", doc.textDocument)) {
          logger96.warn(`Format on type provider not found for buffer: ${doc.uri}`);
          return;
        }
        if (!languages_default.canFormatOnType(ch, doc.textDocument))
          return;
        let position;
        let edits = await this.handler.withRequestToken("Format on type", async (token) => {
          position = await window_default.getCursorPosition();
          let origLine = doc.getline(position.line - 1);
          if (newLine && /^\s*$/.test(origLine))
            return;
          let pos = newLine ? { line: position.line - 1, character: origLine.length } : position;
          await doc.synchronize();
          return await languages_default.provideDocumentOnTypeEdits(ch, doc.textDocument, pos, token);
        });
        if (!edits || !edits.length)
          return;
        let changed = getChangedFromEdits(position, edits);
        await doc.applyEdits(edits);
        let to = changed ? import_vscode_languageserver_protocol89.Position.create(position.line + changed.line, position.character + changed.character) : null;
        if (to && !newLine)
          await window_default.moveTo(to);
      }
      async formatCurrentBuffer() {
        let { doc } = await this.handler.getCurrentState();
        return await this.documentFormat(doc);
      }
      async formatCurrentRange(mode) {
        let { doc } = await this.handler.getCurrentState();
        return await this.documentRangeFormat(doc, mode);
      }
      async documentFormat(doc) {
        await doc.synchronize();
        if (!languages_default.hasFormatProvider(doc.textDocument)) {
          throw new Error(`Format provider not found for buffer: ${doc.bufnr}`);
        }
        let options = await workspace_default.getFormatOptions(doc.uri);
        let textEdits = await this.handler.withRequestToken("format", (token) => {
          return languages_default.provideDocumentFormattingEdits(doc.textDocument, options, token);
        });
        if (textEdits && textEdits.length > 0) {
          await doc.applyEdits(textEdits);
          return true;
        }
        return false;
      }
      async handleEnter(bufnr) {
        let { nvim } = this;
        let { bracketEnterImprove } = this.preferences;
        await this.tryFormatOnType("\n", bufnr);
        if (bracketEnterImprove) {
          let line = await nvim.call("line", ".") - 1;
          let doc = workspace_default.getDocument(bufnr);
          if (!doc)
            return;
          await doc.patchChange();
          let pre = doc.getline(line - 1);
          let curr = doc.getline(line);
          let prevChar = pre[pre.length - 1];
          if (prevChar && pairs.has(prevChar)) {
            let nextChar = curr.trim()[0];
            if (nextChar && pairs.get(prevChar) == nextChar) {
              let edits = [];
              let opts = await workspace_default.getFormatOptions(doc.uri);
              let space = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
              let currIndent = curr.match(/^\s*/)[0];
              let pos = import_vscode_languageserver_protocol89.Position.create(line - 1, pre.length);
              if (doc.filetype == "vim") {
                let newText = "\n" + currIndent + space;
                edits.push({ range: import_vscode_languageserver_protocol89.Range.create(line, currIndent.length, line, currIndent.length), newText: "  \\ " });
                newText = newText + "\\ ";
                edits.push({ range: import_vscode_languageserver_protocol89.Range.create(pos, pos), newText });
                await doc.applyEdits(edits);
                await window_default.moveTo(import_vscode_languageserver_protocol89.Position.create(line, newText.length - 1));
              } else {
                await nvim.eval(`feedkeys("\\<Esc>O", 'in')`);
              }
            }
          }
        }
      }
      async documentRangeFormat(doc, mode) {
        this.handler.checkProvier("formatRange", doc.textDocument);
        await doc.synchronize();
        let range;
        if (mode) {
          range = await workspace_default.getSelectedRange(mode, doc);
          if (!range)
            return -1;
        } else {
          let [lnum, count, mode2] = await this.nvim.eval("[v:lnum,v:count,mode()]");
          if (count == 0 || mode2 == "i" || mode2 == "R")
            return -1;
          range = import_vscode_languageserver_protocol89.Range.create(lnum - 1, 0, lnum - 1 + count, 0);
        }
        let options = await workspace_default.getFormatOptions(doc.uri);
        let textEdits = await this.handler.withRequestToken("Format range", (token) => {
          return languages_default.provideDocumentRangeFormattingEdits(doc.textDocument, range, options, token);
        });
        if (textEdits && textEdits.length > 0) {
          await doc.applyEdits(textEdits);
          return 0;
        }
        return -1;
      }
    };
  }
});

// src/handler/highlights.ts
var import_vscode_languageserver_protocol90, logger97, Highlights;
var init_highlights = __esm({
  "src/handler/highlights.ts"() {
    import_vscode_languageserver_protocol90 = __toModule(require_main2());
    init_events();
    init_languages();
    init_util();
    init_workspace();
    logger97 = require_logger2()("documentHighlight");
    Highlights = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlights = new Map();
        events_default.on(["CursorMoved", "CursorMovedI"], () => {
          this.cancel();
          this.clearHighlights();
        }, null, this.disposables);
      }
      clearHighlights() {
        if (this.highlights.size == 0)
          return;
        for (let winid of this.highlights.keys()) {
          let win = this.nvim.createWindow(winid);
          win.clearMatchGroup("^CocHighlight");
        }
        this.highlights.clear();
      }
      async highlight() {
        let { nvim } = this;
        this.cancel();
        let [bufnr, winid, pos, cursors] = await nvim.eval(`[bufnr("%"),win_getid(),coc#cursor#position(),get(b:,'coc_cursors_activated',0)]`);
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached || cursors)
          return;
        if (!languages_default.hasProvider("documentHighlight", doc.textDocument))
          return;
        let highlights = await this.getHighlights(doc, import_vscode_languageserver_protocol90.Position.create(pos[0], pos[1]));
        if (!highlights)
          return;
        let groups = {};
        for (let hl of highlights) {
          if (!hl.range)
            continue;
          let hlGroup = hl.kind == import_vscode_languageserver_protocol90.DocumentHighlightKind.Text ? "CocHighlightText" : hl.kind == import_vscode_languageserver_protocol90.DocumentHighlightKind.Read ? "CocHighlightRead" : "CocHighlightWrite";
          groups[hlGroup] = groups[hlGroup] || [];
          groups[hlGroup].push(hl.range);
        }
        let win = nvim.createWindow(winid);
        nvim.pauseNotification();
        win.clearMatchGroup("^CocHighlight");
        for (let hlGroup of Object.keys(groups)) {
          win.highlightRanges(hlGroup, groups[hlGroup], -1, true);
        }
        if (workspace_default.isVim)
          nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
        this.highlights.set(winid, highlights);
      }
      async getSymbolsRanges() {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvier("documentHighlight", doc.textDocument);
        let highlights = await this.getHighlights(doc, position);
        if (!highlights)
          return null;
        return highlights.map((o) => o.range);
      }
      hasHighlights(winid) {
        return this.highlights.get(winid) != null;
      }
      async getHighlights(doc, position) {
        let line = doc.getline(position.line);
        let ch = line[position.character];
        if (!ch || !doc.isWord(ch))
          return null;
        await doc.synchronize();
        this.tokenSource = new import_vscode_languageserver_protocol90.CancellationTokenSource();
        let source = this.tokenSource;
        let highlights = await languages_default.getDocumentHighLight(doc.textDocument, position, source.token);
        if (source == this.tokenSource) {
          source.dispose();
          this.tokenSource = null;
        }
        if (source.token.isCancellationRequested)
          return null;
        return highlights;
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      dispose() {
        this.highlights.clear();
        this.cancel();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/hover.ts
function addDocument(docs, text, filetype, isPreview = false) {
  let content = text.trim();
  if (!content.length)
    return;
  if (isPreview && filetype !== "markdown") {
    content = "``` " + filetype + "\n" + content + "\n```";
  }
  docs.push({ content, filetype });
}
function isDocumentation(obj) {
  if (!obj)
    return false;
  return typeof obj.filetype === "string" && typeof obj.content === "string";
}
async function readLines(uri, start, end) {
  let doc = workspace_default.getDocument(uri);
  if (doc)
    return doc.getLines(start, end + 1);
  let fsPath = URI.parse(uri).fsPath;
  if (!import_fs33.default.existsSync(fsPath))
    return [];
  return await readFileLines(fsPath, start, end);
}
var import_fs33, import_vscode_languageserver_protocol91, logger98, HoverHandler;
var init_hover = __esm({
  "src/handler/hover.ts"() {
    import_fs33 = __toModule(require("fs"));
    import_vscode_languageserver_protocol91 = __toModule(require_main2());
    init_esm2();
    init_languages();
    init_floatFactory();
    init_util();
    init_fs();
    init_workspace();
    logger98 = require_logger2()("handler-hover");
    HoverHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.documentLines = [];
        this.hasProvider = false;
        this.excludeImages = true;
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        this.hoverFactory = new FloatFactory(nvim);
        this.disposables.push(this.hoverFactory);
      }
      registerProvider() {
        if (this.hasProvider)
          return;
        this.hasProvider = true;
        let { nvim } = this;
        let provider = {
          onDidChange: null,
          provideTextDocumentContent: async () => {
            nvim.pauseNotification();
            nvim.command("setlocal conceallevel=2 nospell nofoldenable wrap", true);
            nvim.command("setlocal bufhidden=wipe nobuflisted", true);
            nvim.command("setfiletype markdown", true);
            nvim.command(`if winnr('j') != winnr('k') | exe "normal! z${Math.min(this.documentLines.length, this.config.previewMaxHeight)}\\<cr> | endif"`, true);
            await nvim.resumeNotification();
            return this.documentLines.join("\n");
          }
        };
        this.disposables.push(workspace_default.registerTextDocumentContentProvider("coc", provider));
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("hover")) {
          let config = workspace_default.getConfiguration("hover");
          let target = config.get("target", "float");
          this.config = {
            floatConfig: config.get("floatConfig", {}),
            autoHide: config.get("autoHide", true),
            target: target == "float" && !workspace_default.floatSupported ? "preview" : target,
            previewMaxHeight: config.get("previewMaxHeight", 12)
          };
          if (this.config.target == "preview") {
            this.registerProvider();
          }
          let preferences = workspace_default.getConfiguration("coc.preferences");
          this.excludeImages = preferences.get("excludeImageLinksInMarkdownDocument", true);
        }
      }
      async onHover(hoverTarget) {
        let { doc, position, winid } = await this.handler.getCurrentState();
        if (hoverTarget == "preview")
          this.registerProvider();
        this.handler.checkProvier("hover", doc.textDocument);
        await doc.synchronize();
        let hovers = await this.handler.withRequestToken("hover", (token) => {
          return languages_default.getHover(doc.textDocument, position, token);
        }, true);
        if (hovers == null || !hovers.length)
          return false;
        let hover = hovers.find((o) => import_vscode_languageserver_protocol91.Range.is(o.range));
        if (hover == null ? void 0 : hover.range) {
          let win = this.nvim.createWindow(winid);
          win.highlightRanges("CocHoverRange", [hover.range], 99, true);
          this.timer = setTimeout(() => {
            win.clearMatchGroup("CocHoverRange");
            if (workspace_default.isVim)
              this.nvim.command("redraw", true);
          }, 500);
        }
        await this.previewHover(hovers, hoverTarget);
        return true;
      }
      async definitionHover(hoverTarget) {
        const { doc, position } = await this.handler.getCurrentState();
        if (hoverTarget == "preview")
          this.registerProvider();
        this.handler.checkProvier("hover", doc.textDocument);
        await doc.synchronize();
        const hovers = await this.handler.withRequestToken("hover", (token) => {
          return languages_default.getHover(doc.textDocument, position, token);
        }, true);
        if (!(hovers == null ? void 0 : hovers.length))
          return false;
        const defs = await this.handler.withRequestToken("definitionHover", (token) => {
          return languages_default.getDefinitionLinks(doc.textDocument, position, token);
        }, false);
        if (defs == null ? void 0 : defs.length) {
          for (const def of defs) {
            if (!def.targetRange)
              continue;
            const { start, end } = def.targetRange;
            const endLine = end.line - start.line >= 100 ? start.line + 100 : end.character == 0 ? end.line - 1 : end.line;
            let lines = await readLines(def.targetUri, start.line, endLine);
            if (lines.length) {
              let indent = lines[0].match(/^\s*/)[0];
              if (indent)
                lines = lines.map((l) => l.startsWith(indent) ? l.substring(indent.length) : l);
              hovers.push({ content: lines.join("\n"), filetype: doc.filetype });
            }
          }
        }
        await this.previewHover(hovers, hoverTarget);
        return true;
      }
      async previewHover(hovers, target) {
        let docs = [];
        target = target || this.config.target;
        let isPreview = target === "preview";
        for (let hover of hovers) {
          if (isDocumentation(hover)) {
            docs.push(hover);
            continue;
          }
          let { contents } = hover;
          if (Array.isArray(contents)) {
            for (let item of contents) {
              if (typeof item === "string") {
                addDocument(docs, item, "markdown", isPreview);
              } else {
                addDocument(docs, item.value, item.language, isPreview);
              }
            }
          } else if (import_vscode_languageserver_protocol91.MarkedString.is(contents)) {
            if (typeof contents == "string") {
              addDocument(docs, contents, "markdown", isPreview);
            } else {
              addDocument(docs, contents.value, contents.language, isPreview);
            }
          } else if (import_vscode_languageserver_protocol91.MarkupContent.is(contents)) {
            addDocument(docs, contents.value, isMarkdown(contents) ? "markdown" : "txt", isPreview);
          }
        }
        if (target == "float") {
          let config = this.hoverFactory.applyFloatConfig({
            modes: ["n"],
            autoHide: this.config.autoHide,
            excludeImages: this.excludeImages,
            maxWidth: 80
          }, this.config.floatConfig);
          await this.hoverFactory.show(docs, config);
          return;
        }
        let lines = docs.reduce((p, c) => {
          let arr = c.content.split(/\r?\n/);
          if (p.length > 0)
            p.push("");
          p.push(...arr);
          return p;
        }, []);
        if (target == "echo") {
          const msg = lines.join("\n").trim();
          await this.nvim.call("coc#util#echo_hover", [msg]);
        } else {
          this.documentLines = lines;
          await this.nvim.command(`noswapfile pedit coc://document`);
        }
      }
      async getHover() {
        let result = [];
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvier("hover", doc.textDocument);
        await doc.synchronize();
        let tokenSource = new import_vscode_languageserver_protocol91.CancellationTokenSource();
        let hovers = await languages_default.getHover(doc.textDocument, position, tokenSource.token);
        if (Array.isArray(hovers)) {
          for (let h of hovers) {
            let { contents } = h;
            if (Array.isArray(contents)) {
              contents.forEach((c) => {
                result.push(typeof c === "string" ? c : c.value);
              });
            } else if (import_vscode_languageserver_protocol91.MarkupContent.is(contents)) {
              result.push(contents.value);
            } else {
              result.push(typeof contents === "string" ? contents : contents.value);
            }
          }
        }
        result = result.filter((s) => s != null && s.length > 0);
        return result;
      }
      dispose() {
        if (this.timer)
          clearTimeout(this.timer);
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/links.ts
var import_vscode_languageserver_protocol92, Links;
var init_links2 = __esm({
  "src/handler/links.ts"() {
    import_vscode_languageserver_protocol92 = __toModule(require_main2());
    init_languages();
    init_position();
    init_workspace();
    Links = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
      }
      async getLinks() {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvier("documentLink", doc.textDocument);
        let links2 = await this.handler.withRequestToken("links", (token) => {
          return languages_default.getDocumentLinks(doc.textDocument, token);
        });
        return links2 || [];
      }
      async openLink(link) {
        if (!link.target) {
          link = await languages_default.resolveDocumentLink(link);
          if (!link.target)
            throw new Error(`Failed to resolve link target`);
        }
        await workspace_default.openResource(link.target);
      }
      async openCurrentLink() {
        let [line, character] = await this.nvim.call("coc#cursor#position");
        let links2 = await this.getLinks();
        if (!links2 || links2.length == 0)
          return false;
        let position = import_vscode_languageserver_protocol92.Position.create(line, character);
        for (let link of links2) {
          if (positionInRange(position, link.range) == 0) {
            await this.openLink(link);
            return true;
          }
        }
        return false;
      }
    };
  }
});

// src/handler/locations.ts
var import_vscode_languageserver_protocol93, logger99, LocationsHandler;
var init_locations = __esm({
  "src/handler/locations.ts"() {
    import_vscode_languageserver_protocol93 = __toModule(require_main2());
    init_esm2();
    init_languages();
    init_services();
    init_workspace();
    logger99 = require_logger2()("handler-hover");
    LocationsHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
      }
      async request(method, fn) {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvier(method, doc.textDocument);
        await doc.synchronize();
        return await this.handler.withRequestToken(method, (token) => {
          return fn(doc.textDocument, position, token);
        }, true);
      }
      async definitions() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvier("definition", doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_vscode_languageserver_protocol93.CancellationTokenSource();
        return languages_default.getDefinition(doc.textDocument, position, tokenSource.token);
      }
      async declarations() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvier("declaration", doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_vscode_languageserver_protocol93.CancellationTokenSource();
        return languages_default.getDeclaration(doc.textDocument, position, tokenSource.token);
      }
      async typeDefinitions() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvier("typeDefinition", doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_vscode_languageserver_protocol93.CancellationTokenSource();
        return languages_default.getTypeDefinition(doc.textDocument, position, tokenSource.token);
      }
      async implementations() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvier("implementation", doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_vscode_languageserver_protocol93.CancellationTokenSource();
        return languages_default.getImplementation(doc.textDocument, position, tokenSource.token);
      }
      async references() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvier("reference", doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_vscode_languageserver_protocol93.CancellationTokenSource();
        return languages_default.getReferences(doc.textDocument, { includeDeclaration: true }, position, tokenSource.token);
      }
      async gotoDefinition(openCommand) {
        let definition = await this.request("definition", (doc, position, token) => {
          return languages_default.getDefinition(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
      }
      async gotoDeclaration(openCommand) {
        let definition = await this.request("declaration", (doc, position, token) => {
          return languages_default.getDeclaration(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? Array.isArray(definition) ? definition.length > 0 : true : false;
      }
      async gotoTypeDefinition(openCommand) {
        let definition = await this.request("typeDefinition", (doc, position, token) => {
          return languages_default.getTypeDefinition(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
      }
      async gotoImplementation(openCommand) {
        let definition = await this.request("implementation", (doc, position, token) => {
          return languages_default.getImplementation(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
      }
      async gotoReferences(openCommand, includeDeclaration = true) {
        let definition = await this.request("reference", (doc, position, token) => {
          return languages_default.getReferences(doc, { includeDeclaration }, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
      }
      async getTagList() {
        let { doc, position } = await this.handler.getCurrentState();
        let word = await this.nvim.call("expand", "<cword>");
        if (!word)
          return null;
        if (!languages_default.hasProvider("definition", doc.textDocument))
          return null;
        let tokenSource = new import_vscode_languageserver_protocol93.CancellationTokenSource();
        let definitions = await languages_default.getDefinition(doc.textDocument, position, tokenSource.token);
        if (!definitions || !definitions.length)
          return null;
        return definitions.map((location) => {
          let parsedURI = URI.parse(location.uri);
          const filename = parsedURI.scheme == "file" ? parsedURI.fsPath : parsedURI.toString();
          return {
            name: word,
            cmd: `keepjumps ${location.range.start.line + 1} | normal ${location.range.start.character + 1}|`,
            filename
          };
        });
      }
      async findLocations(id, method, params, openCommand) {
        let { doc, position } = await this.handler.getCurrentState();
        params = params || {};
        Object.assign(params, {
          textDocument: { uri: doc.uri },
          position
        });
        let res = await services_default.sendRequest(id, method, params);
        res = res || [];
        let locations = [];
        if (Array.isArray(res)) {
          locations = res;
        } else if (res.hasOwnProperty("location") && res.hasOwnProperty("children")) {
          let getLocation2 = (item) => {
            locations.push(item.location);
            if (item.children && item.children.length) {
              for (let loc of item.children) {
                getLocation2(loc);
              }
            }
          };
          getLocation2(res);
        }
        await this.handleLocations(locations, openCommand);
      }
      async handleLocations(definition, openCommand) {
        if (!definition)
          return;
        let locations = Array.isArray(definition) ? definition : [definition];
        locations = locations.map((o) => import_vscode_languageserver_protocol93.LocationLink.is(o) ? import_vscode_languageserver_protocol93.Location.create(o.targetUri, o.targetRange) : o);
        let len = locations.length;
        if (len == 0)
          return;
        if (len == 1 && openCommand !== false) {
          let { uri, range } = locations[0];
          await workspace_default.jumpTo(uri, range.start, openCommand);
        } else {
          await workspace_default.showLocations(locations);
        }
      }
      dispose() {
      }
    };
  }
});

// src/handler/search.ts
function getPathFromArgs(args) {
  if (args.length < 2)
    return void 0;
  let len = args.length;
  if (args[len - 1].startsWith("-"))
    return void 0;
  if (args[len - 2].startsWith("-"))
    return void 0;
  return args[len - 1];
}
var import_child_process6, import_events36, import_path34, import_readline5, logger100, defaultArgs, controlCode2, Task2, Search;
var init_search = __esm({
  "src/handler/search.ts"() {
    init_mutex();
    import_child_process6 = __toModule(require("child_process"));
    import_events36 = __toModule(require("events"));
    import_path34 = __toModule(require("path"));
    import_readline5 = __toModule(require("readline"));
    init_main();
    init_highligher();
    init_ansiparse();
    init_window();
    logger100 = require_logger2()("handler-search");
    defaultArgs = ["--color", "ansi", "--colors", "path:fg:black", "--colors", "line:fg:green", "--colors", "match:fg:red", "--no-messages", "--heading", "-n"];
    controlCode2 = "";
    Task2 = class extends import_events36.EventEmitter {
      start(cmd, args, cwd) {
        this.process = (0, import_child_process6.spawn)(cmd, args, { cwd });
        this.process.on("error", (e) => {
          this.emit("error", e.message);
        });
        const rl = import_readline5.default.createInterface(this.process.stdout);
        let start;
        let fileItem;
        let lines = [];
        let highlights = [];
        let create = true;
        rl.on("line", (content) => {
          if (content.includes(controlCode2)) {
            let items = ansiparse(content);
            if (items[0].foreground == "black") {
              fileItem = { filepath: import_path34.default.join(cwd, items[0].text), ranges: [] };
              return;
            }
            let normalLine = items[0].foreground == "green";
            if (normalLine) {
              let lnum = parseInt(items[0].text, 10) - 1;
              let padlen2 = items[0].text.length + 1;
              if (create) {
                start = lnum;
                create = false;
              }
              let line = "";
              for (let item of items) {
                if (item.foreground == "red") {
                  let l = lnum - start;
                  let c = line.length - padlen2;
                  highlights.push(Range.create(l, c, l, c + item.text.length));
                }
                line += item.text;
              }
              let currline = line.slice(padlen2);
              lines.push(currline);
            }
          } else {
            let fileEnd = content.trim().length == 0;
            if (fileItem && (fileEnd || content.trim() == "--")) {
              let fileRange = {
                lines,
                highlights,
                start,
                end: start + lines.length
              };
              fileItem.ranges.push(fileRange);
            }
            if (fileEnd) {
              this.emit("item", fileItem);
              fileItem = null;
            }
            lines = [];
            highlights = [];
            create = true;
          }
        });
        rl.on("close", () => {
          if (fileItem) {
            if (lines.length) {
              let fileRange = {
                lines,
                highlights,
                start,
                end: start + lines.length
              };
              fileItem.ranges.push(fileRange);
            }
            this.emit("item", fileItem);
          }
          lines = highlights = fileItem = null;
          this.emit("end");
        });
      }
      dispose() {
        if (this.process) {
          this.process.kill();
        }
      }
    };
    Search = class {
      constructor(nvim, cmd = "rg") {
        this.nvim = nvim;
        this.cmd = cmd;
      }
      run(args, cwd, refactorBuf) {
        let { nvim, cmd } = this;
        let { afterContext, beforeContext } = refactorBuf.config;
        let argList = ["-A", afterContext.toString(), "-B", beforeContext.toString()].concat(defaultArgs, args);
        let p = getPathFromArgs(args);
        if (p)
          argList.pop();
        argList.push("--", p ? import_path34.default.isAbsolute(p) ? p : `./${p.replace(/^\.\//, "")}` : "./");
        this.task = new Task2();
        this.task.start(cmd, argList, cwd);
        let mutex = new Mutex();
        let files = 0;
        let matches = 0;
        let start = Date.now();
        let fileItems = [];
        const addFileItems = async () => {
          if (fileItems.length == 0)
            return;
          let items = fileItems.slice();
          fileItems = [];
          const release = await mutex.acquire();
          try {
            await refactorBuf.addFileItems(items);
          } catch (e) {
            logger100.error(e);
          }
          release();
        };
        return new Promise((resolve3, reject) => {
          let interval = setInterval(addFileItems, 300);
          this.task.on("item", async (fileItem) => {
            files++;
            matches = matches + fileItem.ranges.reduce((p2, r) => p2 + r.highlights.length, 0);
            fileItems.push(fileItem);
          });
          this.task.on("error", (message) => {
            clearInterval(interval);
            window_default.showMessage(`Error on command "${cmd}": ${message}`, "error");
            this.task = null;
            reject(new Error(message));
          });
          this.task.on("end", async () => {
            clearInterval(interval);
            try {
              await addFileItems();
              const release = await mutex.acquire();
              release();
              this.task.removeAllListeners();
              this.task = null;
              let buf = refactorBuf.buffer;
              if (buf) {
                nvim.pauseNotification();
                if (files == 0) {
                  buf.setLines(["No match found"], { start: 1, end: 2, strictIndexing: false }, true);
                  buf.addHighlight({ line: 1, srcId: -1, colEnd: -1, colStart: 0, hlGroup: "Error" }).logError();
                  buf.setOption("modified", false, true);
                } else {
                  let highligher = new Highlighter();
                  highligher.addText("Files", "MoreMsg");
                  highligher.addText(": ");
                  highligher.addText(`${files} `, "Number");
                  highligher.addText("Matches", "MoreMsg");
                  highligher.addText(": ");
                  highligher.addText(`${matches} `, "Number");
                  highligher.addText("Duration", "MoreMsg");
                  highligher.addText(": ");
                  highligher.addText(`${Date.now() - start}ms`, "Number");
                  highligher.render(buf, 1, 2);
                }
                buf.setOption("modified", false, true);
                await nvim.resumeNotification(false, true);
              }
            } catch (e) {
              reject(e);
              return;
            }
            resolve3();
          });
        });
      }
      abort() {
        var _a2;
        (_a2 = this.task) == null ? void 0 : _a2.dispose();
      }
    };
  }
});

// src/handler/refactor/buffer.ts
function adjustRange(range, offset) {
  let { start, end } = range;
  return import_vscode_languageserver_protocol94.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
var import_fast_diff5, import_path35, import_vscode_languageserver_protocol94, logger101, SEPARATOR, RefactorBuffer;
var init_buffer4 = __esm({
  "src/handler/refactor/buffer.ts"() {
    import_fast_diff5 = __toModule(require_diff());
    import_path35 = __toModule(require("path"));
    import_vscode_languageserver_protocol94 = __toModule(require_main2());
    init_main2();
    init_esm2();
    init_commands2();
    init_highligher();
    init_util();
    init_fs();
    init_mutex();
    init_object();
    init_string();
    init_window();
    init_workspace();
    logger101 = require_logger2()("handler-refactorBuffer");
    SEPARATOR = "\u3000";
    RefactorBuffer = class {
      constructor(bufnr, srcId, nvim, config, opts) {
        this.bufnr = bufnr;
        this.srcId = srcId;
        this.nvim = nvim;
        this.config = config;
        this.opts = opts;
        this.mutex = new Mutex();
        this._disposed = false;
        this.disposables = [];
        this._fileItems = [];
        this.matchIds = new Set();
        this.changing = false;
        this.disposables.push(workspace_default.registerLocalKeymap("n", "<CR>", this.splitOpen.bind(this), true));
        workspace_default.onDidChangeTextDocument(this.onDocumentChange, this, this.disposables);
      }
      get fileItems() {
        return this._fileItems;
      }
      onChange(e) {
        if (this.changing)
          return;
        let doc = this.document;
        let { nvim, _fileItems: fileItems } = this;
        if (!fileItems.length)
          return;
        let change = e.contentChanges[0];
        if (!("range" in change))
          return;
        let { original } = e;
        if (change.range.end.line < 2)
          return;
        doc.buffer.setOption("modified", true, true);
        let { range, text } = change;
        let lines = text.split("\n");
        let lineChange = lines.length - (range.end.line - range.start.line) - 1;
        if (lineChange == 0)
          return;
        let lineChanges = [];
        if (text.includes("\u3000")) {
          let startLine = range.start.line;
          let diffs = (0, import_fast_diff5.default)(original, text);
          let offset = 0;
          let orig = TextDocument2.create("file:///1", "", 0, original);
          for (let i = 0; i < diffs.length; i++) {
            let diff = diffs[i];
            let pos = orig.positionAt(offset);
            if (diff[0] == import_fast_diff5.default.EQUAL) {
              offset = offset + diff[1].length;
            } else if (diff[0] == import_fast_diff5.default.DELETE) {
              let end = orig.positionAt(offset + diff[1].length);
              if (diffs[i + 1] && diffs[i + 1][0] == import_fast_diff5.default.INSERT) {
                let delta = diffs[i + 1][1].split("\n").length - (end.line - pos.line) - 1;
                if (delta != 0)
                  lineChanges.push({ delta, lnum: pos.line + startLine });
                i = i + 1;
              } else {
                let delta = -(end.line - pos.line);
                if (delta != 0)
                  lineChanges.push({ delta, lnum: pos.line + startLine });
              }
              offset = offset + diff[1].length;
            } else if (diff[0] == import_fast_diff5.default.INSERT) {
              let delta = diff[1].split("\n").length - 1;
              if (delta != 0)
                lineChanges.push({ delta, lnum: pos.line + startLine });
            }
          }
        } else {
          lineChanges = [{ delta: lineChange, lnum: range.start.line }];
        }
        let changed = false;
        for (let item of fileItems) {
          for (let range2 of item.ranges) {
            let arr = lineChanges.filter((o) => o.lnum < range2.lnum - 1);
            if (arr.length) {
              let total = arr.reduce((p, c) => p + c.delta, 0);
              range2.lnum = range2.lnum + total;
              changed = true;
            }
          }
        }
        if (!changed)
          return;
        nvim.pauseNotification();
        this.highlightLineNr();
        nvim.resumeNotification().then((res) => {
          if (Array.isArray(res) && res[1] != null) {
            logger101.error(`Error on highlightLineNr:`, res[1]);
          }
        }).logError();
      }
      async onDocumentChange(e) {
        if (e.bufnr == this.bufnr || this.changing)
          return;
        let { uri } = e.textDocument;
        let { range, text } = e.contentChanges[0];
        let filepath = URI.parse(uri).fsPath;
        let fileItem = this._fileItems.find((o) => o.filepath == filepath);
        if (!fileItem)
          return;
        let lineChange = text.split("\n").length - (range.end.line - range.start.line) - 1;
        let edits = [];
        for (let i = 0; i < fileItem.ranges.length; i++) {
          let r = fileItem.ranges[i];
          if (range.start.line >= r.end) {
            continue;
          }
          if (range.end.line < r.start) {
            if (lineChange == 0) {
              continue;
            } else {
              r.start = r.start + lineChange;
              r.end = r.end + lineChange;
            }
          } else {
            let doc = workspace_default.getDocument(uri);
            let newLines = doc.getLines(r.start, r.end);
            if (!newLines.length) {
              fileItem.ranges.splice(i, 1);
              edits.push({
                range: this.getFileRangeRange(r, false),
                newText: ""
              });
            } else {
              r.end = r.start + newLines.length;
              edits.push({
                range: this.getFileRangeRange(r, true),
                newText: newLines.join("\n") + "\n"
              });
            }
          }
        }
        this._fileItems = this._fileItems.filter((o) => o.ranges && o.ranges.length > 0);
        if (edits.length) {
          this.changing = true;
          await this.document.applyEdits(edits);
          this.changing = false;
        }
        this.nvim.pauseNotification();
        this.highlightLineNr();
        this.buffer.setOption("modified", false, true);
        await this.nvim.resumeNotification();
      }
      async getFileChanges() {
        if (this._disposed)
          return [];
        let changes = [];
        let lines = await this.buffer.lines;
        lines.push(SEPARATOR);
        let arr = [];
        let fsPath;
        let lnum;
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i];
          if (line.startsWith(SEPARATOR)) {
            if (fsPath) {
              changes.push({
                filepath: fsPath,
                lines: arr.slice(),
                lnum
              });
              fsPath = void 0;
              arr = [];
            }
            if (line.length > 1) {
              let ms = line.match(/^\u3000(.*)/);
              if (ms) {
                fsPath = this.getAbsolutePath(ms[1].replace(/\s+$/, ""));
                lnum = i + 1;
                arr = [];
              }
            }
          } else {
            arr.push(line);
          }
        }
        return changes;
      }
      async splitOpen() {
        let { nvim } = this;
        let win = nvim.createWindow(this.opts.fromWinid);
        let valid = await win.valid;
        let lines = await nvim.eval('getline(1,line("."))');
        let len = lines.length;
        for (let i = 0; i < len; i++) {
          let line = lines[len - i - 1];
          let ms = line.match(/^\u3000(.+)/);
          if (ms) {
            let filepath = ms[1].trim();
            let r = this.getLinesRange(len - i);
            if (!r)
              return;
            let lnum = r[0] + i - 1;
            let bufname = this.getAbsolutePath(filepath);
            nvim.pauseNotification();
            if (valid) {
              nvim.call("win_gotoid", [this.opts.fromWinid], true);
              this.nvim.call("coc#util#jump", ["edit", bufname, [lnum, 1]], true);
            } else {
              this.nvim.call("coc#util#jump", ["belowright vs", bufname, [lnum, 1]], true);
            }
            nvim.command("normal! zz", true);
            let [, err] = await nvim.resumeNotification();
            if (err)
              window_default.showMessage(`Error on open ${filepath}: ${err}`, "error");
            if (!valid) {
              this.opts.fromWinid = await nvim.call("win_getid");
            }
            break;
          }
        }
      }
      async addFileItems(items) {
        if (this._disposed)
          return;
        let { cwd } = this.opts;
        let { document: document2 } = this;
        const release = await this.mutex.acquire();
        try {
          await document2.synchronize();
          for (let item of items) {
            let fileItem = this._fileItems.find((o) => o.filepath == item.filepath);
            if (fileItem) {
              fileItem.ranges.push(...item.ranges);
            } else {
              this._fileItems.push(item);
            }
          }
          let count = document2.lineCount;
          let highligher = new Highlighter();
          let hlRanges = [];
          for (let item of items) {
            for (let range of item.ranges) {
              highligher.addLine(SEPARATOR);
              highligher.addLine(SEPARATOR);
              range.lnum = count + highligher.length;
              highligher.addText(`${isParentFolder(cwd, item.filepath) ? import_path35.default.relative(cwd, item.filepath) : item.filepath}`);
              let n = String(range.start + 1).length + String(range.end).length + 4;
              if (!this.srcId)
                highligher.addText(" ".repeat(n));
              let base = 0 - highligher.length - count;
              if (range.highlights) {
                hlRanges.push(...range.highlights.map((r) => adjustRange(r, base)));
              }
              let { lines } = range;
              if (!lines) {
                lines = await this.getLines(item.filepath, range.start, range.end);
                range.lines = lines;
              }
              highligher.addLines(lines);
            }
          }
          let { nvim, buffer } = this;
          this.changing = true;
          nvim.pauseNotification();
          highligher.render(buffer, count);
          this.highlightLineNr();
          buffer.setOption("modified", false, true);
          buffer.setOption("undolevels", 1e3, true);
          if (count == 2 && hlRanges.length) {
            let pos = hlRanges[0].start;
            nvim.call("coc#cursor#move_to", [pos.line, pos.character], true);
          }
          if (workspace_default.isVim) {
            nvim.command("redraw", true);
          }
          let [, err] = await nvim.resumeNotification();
          if (err)
            throw new Error(err[2]);
          await document2.patchChange();
          this.changing = false;
          await commands_default.executeCommand("editor.action.addRanges", hlRanges);
        } catch (e) {
          this.changing = false;
          logger101.error(`Error on add file item:`, e);
        }
        release();
      }
      async save() {
        let { nvim } = this;
        let doc = this.document;
        let { buffer } = doc;
        await doc.patchChange();
        let changes = await this.getFileChanges();
        if (!changes)
          return;
        changes.sort((a, b) => a.lnum - b.lnum);
        let removeList = [];
        let deltaMap = new Map();
        for (let i = 0; i < changes.length; i++) {
          let change = changes[i];
          let { filepath, lnum } = change;
          let curr = deltaMap.get(filepath) || 0;
          let item = this._fileItems.find((o) => o.filepath == filepath);
          let range = item ? item.ranges.find((o) => o.lnum == lnum) : null;
          if (!range || equals(range.lines, change.lines)) {
            removeList.push(i);
            if (curr && range) {
              range.start = range.start + curr;
              range.end = range.end + curr;
            }
            continue;
          }
          change.start = range.start;
          change.end = range.end;
          if (curr != 0)
            range.start = range.start + curr;
          if (change.lines.length != range.lines.length) {
            let delta = change.lines.length - range.lines.length;
            let total = delta + curr;
            deltaMap.set(filepath, total);
            range.end = range.end + total;
          } else {
            range.end = range.end + curr;
          }
          range.lines = change.lines;
        }
        if (removeList.length)
          changes = changes.filter((_, i) => !removeList.includes(i));
        if (changes.length == 0) {
          window_default.showMessage("No change.", "more");
          await buffer.setOption("modified", false);
          return false;
        }
        let changeMap = {};
        for (let change of changes) {
          let uri = URI.file(change.filepath).toString();
          let edits = changeMap[uri] || [];
          edits.push({
            range: import_vscode_languageserver_protocol94.Range.create(change.start, 0, change.end, 0),
            newText: change.lines.join("\n") + "\n"
          });
          changeMap[uri] = edits;
        }
        this.changing = true;
        await workspace_default.applyEdit({ changes: changeMap });
        this.changing = false;
        nvim.pauseNotification();
        buffer.setOption("modified", false, true);
        if (this.config.saveToFile) {
          nvim.command("silent noa wa", true);
        }
        this.highlightLineNr();
        await nvim.resumeNotification();
        return true;
      }
      getFileRange(lnum) {
        for (let item of this._fileItems) {
          for (let r of item.ranges) {
            if (r.lnum == lnum) {
              return r;
            }
          }
        }
      }
      getLinesRange(lnum) {
        for (let item of this._fileItems) {
          for (let range of item.ranges) {
            if (range.lnum == lnum) {
              return [range.start, range.end];
            }
          }
        }
      }
      async getLines(fsPath, start, end) {
        let uri = URI.file(fsPath).toString();
        let doc = workspace_default.getDocument(uri);
        if (doc)
          return doc.getLines(start, end);
        return await readFileLines(fsPath, start, end - 1);
      }
      getAbsolutePath(filepath) {
        if (import_path35.default.isAbsolute(filepath))
          return filepath;
        return import_path35.default.join(this.opts.cwd, filepath);
      }
      getFileRangeRange(range, lineOnly = true) {
        let { document: document2 } = this;
        if (!document2)
          return null;
        let { lnum } = range;
        let first = document2.getline(lnum - 1);
        if (!first.startsWith("\u3000"))
          return null;
        let start = lineOnly ? lnum : lnum - 1;
        let end = document2.lineCount;
        for (let i = lnum; i < document2.lineCount; i++) {
          let line = document2.getline(i);
          if (line.startsWith("\u3000")) {
            end = lineOnly ? i : i + 1;
            break;
          }
        }
        return import_vscode_languageserver_protocol94.Range.create(start, 0, end, 0);
      }
      highlightLineNr() {
        let { _fileItems: fileItems, nvim, srcId, bufnr } = this;
        let { winid, cwd } = this.opts;
        let info = {};
        if (srcId) {
          nvim.call("nvim_buf_clear_namespace", [bufnr, srcId, 0, -1], true);
          for (let item of fileItems) {
            for (let range of item.ranges) {
              let text = `${range.start + 1}:${range.end}`;
              info[range.lnum] = [range.start + 1, range.end];
              nvim.call("nvim_buf_set_virtual_text", [bufnr, srcId, range.lnum - 1, [[text, "LineNr"]], {}], true);
            }
          }
        } else {
          if (this.matchIds.size) {
            nvim.call("coc#highlight#clear_matches", [winid, Array.from(this.matchIds)], true);
            this.matchIds.clear();
          }
          let id = 2e3;
          for (let item of fileItems) {
            let filename = `${cwd ? import_path35.default.relative(cwd, item.filepath) : item.filepath}`;
            let col = byteLength(filename) + 1;
            for (let range of item.ranges) {
              let text = `:${range.start + 1}:${range.end}`;
              for (let i = 0; i < text.length; i++) {
                let ch = text[i];
                this.matchIds.add(id);
                info[range.lnum] = [range.start + 1, range.end];
                nvim.call("matchaddpos", ["Conceal", [[range.lnum, col + i]], 99, id, { conceal: ch, window: winid }], true);
                id++;
              }
            }
          }
        }
        this.buffer.setVar("line_infos", info, true);
      }
      get valid() {
        return this.buffer.valid;
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      get document() {
        if (this._disposed)
          return null;
        return workspace_default.getDocument(this.bufnr);
      }
      dispose() {
        this._disposed = true;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/refactor/index.ts
function adjustRange2(range, offset) {
  let { start, end } = range;
  return import_vscode_languageserver_protocol95.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
function emptyWorkspaceEdit(edit2) {
  let { changes, documentChanges } = edit2;
  if (documentChanges && documentChanges.length)
    return false;
  if (changes && Object.keys(changes).length)
    return false;
  return true;
}
var import_vscode_languageserver_protocol95, logger102, name, refactorId, Refactor;
var init_refactor = __esm({
  "src/handler/refactor/index.ts"() {
    import_vscode_languageserver_protocol95 = __toModule(require_main2());
    init_esm2();
    init_languages();
    init_util();
    init_fs();
    init_workspace();
    init_search();
    init_buffer4();
    logger102 = require_logger2()("handler-refactor");
    name = "__coc_refactor__";
    refactorId = 0;
    Refactor = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.buffers = new Map();
        this.disposables = [];
        this._onCreate = new import_vscode_languageserver_protocol95.Emitter();
        this.onCreate = this._onCreate.event;
        if (workspace_default.isNvim && this.nvim.hasFunction("nvim_buf_set_virtual_text")) {
          this.srcId = workspace_default.createNameSpace("coc-refactor");
        }
        this.setConfiguration();
        workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
        workspace_default.onDidCloseTextDocument((e) => {
          let buf = this.buffers.get(e.bufnr);
          if (buf) {
            buf.dispose();
            this.buffers.delete(e.bufnr);
          }
        }, null, this.disposables);
        workspace_default.onDidChangeTextDocument((e) => {
          let buf = this.buffers.get(e.bufnr);
          if (buf)
            buf.onChange(e);
        }, null, this.disposables);
      }
      setConfiguration(e) {
        if (e && !e.affectsConfiguration("refactor"))
          return;
        let config = workspace_default.getConfiguration("refactor");
        this.config = Object.assign(this.config || {}, {
          afterContext: config.get("afterContext", 3),
          beforeContext: config.get("beforeContext", 3),
          openCommand: config.get("openCommand", "edit"),
          saveToFile: config.get("saveToFile", true)
        });
      }
      async doRefactor() {
        let { doc, position } = await this.handler.getCurrentState();
        if (!languages_default.hasProvider("rename", doc.textDocument)) {
          throw new Error(`Rename provider not found for current buffer`);
        }
        await doc.synchronize();
        let edit2 = await this.handler.withRequestToken("refactor", async (token) => {
          let res = await languages_default.prepareRename(doc.textDocument, position, token);
          if (token.isCancellationRequested)
            return null;
          if (res === false)
            throw new Error(`Provider returns null on prepare, unable to rename at current position`);
          let edit3 = await languages_default.provideRenameEdits(doc.textDocument, position, "NewName", token);
          if (token.isCancellationRequested)
            return null;
          if (!edit3)
            throw new Error("Provider returns null for rename edits.");
          return edit3;
        });
        if (edit2) {
          await this.fromWorkspaceEdit(edit2, doc.filetype);
        }
      }
      async search(args) {
        let buf = await this.createRefactorBuffer();
        if (!buf)
          return;
        let cwd = await this.nvim.call("getcwd", []);
        let search = new Search(this.nvim);
        await search.run(args, cwd, buf);
      }
      async save(bufnr) {
        let buf = this.buffers.get(bufnr);
        if (buf)
          return await buf.save();
      }
      getBuffer(bufnr) {
        return this.buffers.get(bufnr);
      }
      async createRefactorBuffer(filetype) {
        let { nvim } = this;
        let [fromWinid, cwd] = await nvim.eval("[win_getid(),getcwd()]");
        let { openCommand } = this.config;
        nvim.pauseNotification();
        nvim.command(`${openCommand} ${name}${refactorId++}`, true);
        nvim.command(`setl buftype=acwrite nobuflisted bufhidden=wipe nofen wrap conceallevel=2 concealcursor=n`, true);
        nvim.command(`setl undolevels=-1 nolist nospell noswapfile foldmethod=expr foldexpr=coc#util#refactor_foldlevel(v:lnum)`, true);
        nvim.command(`setl foldtext=coc#util#refactor_fold_text(v:foldstart)`, true);
        nvim.call("setline", [1, ["Save current buffer to make changes", SEPARATOR]], true);
        nvim.call("matchadd", ["Comment", "\\%1l"], true);
        nvim.call("matchadd", ["Conceal", "^\\%u3000"], true);
        nvim.call("matchadd", ["Label", "^\\%u3000\\zs\\S\\+"], true);
        nvim.command("setl nomod", true);
        if (filetype)
          nvim.command(`runtime! syntax/${filetype}.vim`, true);
        nvim.call("coc#util#do_autocmd", ["CocRefactorOpen"], true);
        let [, err] = await nvim.resumeNotification();
        if (err)
          return;
        let [bufnr, win] = await nvim.eval('[bufnr("%"),win_getid()]');
        let opts = { fromWinid, winid: win, cwd };
        await workspace_default.document;
        let buf = new RefactorBuffer(bufnr, this.srcId, this.nvim, this.config, opts);
        this.buffers.set(bufnr, buf);
        return buf;
      }
      async fromLines(lines) {
        let buf = await this.createRefactorBuffer();
        if (buf)
          await buf.buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false });
        return buf;
      }
      async fromLocations(locations, filetype) {
        if (!locations || locations.length == 0)
          return null;
        let changes = {};
        let edit2 = { changes };
        for (let location of locations) {
          let edits = changes[location.uri] || [];
          edits.push({ range: location.range, newText: "" });
          changes[location.uri] = edits;
        }
        return await this.fromWorkspaceEdit(edit2, filetype);
      }
      async fromWorkspaceEdit(edit2, filetype) {
        if (!edit2 || emptyWorkspaceEdit(edit2))
          return void 0;
        let items = [];
        let { beforeContext, afterContext } = this.config;
        let { changes, documentChanges } = edit2;
        if (!changes) {
          changes = {};
          for (let change of documentChanges || []) {
            if (import_vscode_languageserver_protocol95.TextDocumentEdit.is(change)) {
              let { textDocument, edits } = change;
              if (textDocument.uri.startsWith("file:")) {
                changes[textDocument.uri] = edits;
              }
            }
          }
        }
        for (let key of Object.keys(changes)) {
          let max = await this.getLineCount(key);
          let edits = changes[key];
          let ranges = [];
          let start = null;
          let end = null;
          let highlights = [];
          edits.sort((a, b) => a.range.start.line - b.range.start.line);
          for (let edit3 of edits) {
            let { line } = edit3.range.start;
            let s = Math.max(0, line - beforeContext);
            if (start != null && s < end) {
              end = Math.min(max, line + afterContext + 1);
              highlights.push(adjustRange2(edit3.range, start));
            } else {
              if (start != null)
                ranges.push({ start, end, highlights });
              start = s;
              end = Math.min(max, line + afterContext + 1);
              highlights = [adjustRange2(edit3.range, start)];
            }
          }
          if (start != null)
            ranges.push({ start, end, highlights });
          items.push({
            ranges,
            filepath: URI.parse(key).fsPath
          });
        }
        let buf = await this.createRefactorBuffer(filetype);
        await buf.addFileItems(items);
        return buf;
      }
      async getLineCount(uri) {
        let doc = workspace_default.getDocument(uri);
        if (doc)
          return doc.lineCount;
        return await getFileLineCount(URI.parse(uri).fsPath);
      }
      reset() {
        if (this.timer) {
          clearTimeout(this.timer);
        }
        for (let buf of this.buffers.values()) {
          buf.dispose();
        }
        this.buffers.clear();
      }
      dispose() {
        if (this.timer) {
          clearTimeout(this.timer);
        }
        this._onCreate.dispose();
        for (let buf of this.buffers.values()) {
          buf.dispose();
        }
        this.buffers.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/rename.ts
var import_vscode_languageserver_protocol96, logger103, Rename;
var init_rename = __esm({
  "src/handler/rename.ts"() {
    import_vscode_languageserver_protocol96 = __toModule(require_main2());
    init_languages();
    init_position();
    init_window();
    init_workspace();
    logger103 = require_logger2()("handler-rename");
    Rename = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
      }
      async getWordEdit() {
        let { doc, position } = await this.handler.getCurrentState();
        let range = doc.getWordRangeAtPosition(position);
        if (!range || emptyRange(range))
          return null;
        let curname = doc.textDocument.getText(range);
        if (languages_default.hasProvider("rename", doc.textDocument)) {
          await doc.synchronize();
          let requestTokenSource = new import_vscode_languageserver_protocol96.CancellationTokenSource();
          let res = await languages_default.prepareRename(doc.textDocument, position, requestTokenSource.token);
          if (res === false)
            return null;
          let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position, curname, requestTokenSource.token);
          if (edit2)
            return edit2;
        }
        window_default.showMessage("Rename provider not found, extract word ranges from current buffer", "more");
        let ranges = doc.getSymbolRanges(curname);
        return {
          changes: {
            [doc.uri]: ranges.map((r) => ({ range: r, newText: curname }))
          }
        };
      }
      async rename(newName) {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvier("rename", doc.textDocument);
        await doc.synchronize();
        let token = new import_vscode_languageserver_protocol96.CancellationTokenSource().token;
        let res = await languages_default.prepareRename(doc.textDocument, position, token);
        if (res === false) {
          window_default.showMessage("Invalid position for rename", "warning");
          return false;
        }
        let curname;
        if (!newName) {
          if (import_vscode_languageserver_protocol96.Range.is(res)) {
            curname = doc.textDocument.getText(res);
            await window_default.moveTo(res.start);
          } else if (res && typeof res.placeholder === "string") {
            curname = res.placeholder;
          } else {
            curname = await this.nvim.eval('expand("<cword>")');
          }
          newName = await window_default.requestInput("New name", curname);
        }
        if (!newName)
          return false;
        let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position, newName, token);
        if (token.isCancellationRequested || !edit2)
          return false;
        await workspace_default.applyEdit(edit2);
        if (workspace_default.isVim)
          this.nvim.command("redraw", true);
        return true;
      }
    };
  }
});

// src/handler/selectionRange.ts
var import_vscode_languageserver_protocol97, SelectionRangeHandler;
var init_selectionRange2 = __esm({
  "src/handler/selectionRange.ts"() {
    import_vscode_languageserver_protocol97 = __toModule(require_main2());
    init_languages();
    init_object();
    init_position();
    init_window();
    init_workspace();
    SelectionRangeHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.selectionRange = null;
      }
      async getSelectionRanges() {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvier("selectionRange", doc.textDocument);
        await doc.synchronize();
        let selectionRanges = await this.handler.withRequestToken("selection ranges", (token) => {
          return languages_default.getSelectionRanges(doc.textDocument, [position], token);
        });
        return selectionRanges;
      }
      async selectRange(visualmode, forward) {
        let { nvim } = this;
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvier("selectionRange", doc.textDocument);
        let positions2 = [];
        if (!forward && (!this.selectionRange || !visualmode))
          return;
        if (visualmode) {
          let range = await workspace_default.getSelectedRange(visualmode, doc);
          positions2.push(range.start, range.end);
        } else {
          let position = await window_default.getCursorPosition();
          positions2.push(position);
        }
        if (!forward) {
          let curr = import_vscode_languageserver_protocol97.Range.create(positions2[0], positions2[1]);
          let { selectionRange: selectionRange2 } = this;
          while (selectionRange2 && selectionRange2.parent) {
            if (equals(selectionRange2.parent.range, curr)) {
              break;
            }
            selectionRange2 = selectionRange2.parent;
          }
          if (selectionRange2 && selectionRange2.parent) {
            await workspace_default.selectRange(selectionRange2.range);
          }
          return;
        }
        await doc.synchronize();
        let selectionRanges = await this.handler.withRequestToken("selection ranges", (token) => {
          return languages_default.getSelectionRanges(doc.textDocument, positions2, token);
        });
        if (!selectionRanges || selectionRanges.length == 0)
          return;
        let mode = await nvim.eval("mode()");
        if (mode != "n")
          await nvim.eval(`feedkeys("\\<Esc>", 'in')`);
        let selectionRange;
        if (selectionRanges.length == 1) {
          selectionRange = selectionRanges[0];
        } else {
          let end = positions2[1] || positions2[0];
          let r = import_vscode_languageserver_protocol97.Range.create(positions2[0], end);
          selectionRange = selectionRanges[0];
          while (selectionRange) {
            if (equals(r, selectionRange.range)) {
              selectionRange = selectionRange.parent;
              continue;
            }
            if (positionInRange(positions2[0], selectionRange.range) == 0 && positionInRange(end, selectionRange.range) == 0) {
              break;
            }
            selectionRange = selectionRange.parent;
          }
        }
        if (!selectionRange)
          return;
        this.selectionRange = selectionRanges[0];
        await workspace_default.selectRange(selectionRange.range);
      }
    };
  }
});

// src/handler/callHierarchy.ts
function isCallHierarchyItem(item) {
  if (item && item.name && item.kind && import_vscode_languageserver_protocol98.Range.is(item.range) && item.uri)
    return true;
  return false;
}
var import_path36, import_vscode_languageserver_protocol98, logger104, _CallHierarchyHandler, CallHierarchyHandler;
var init_callHierarchy2 = __esm({
  "src/handler/callHierarchy.ts"() {
    import_path36 = __toModule(require("path"));
    import_vscode_languageserver_protocol98 = __toModule(require_main2());
    init_esm2();
    init_commands2();
    init_events();
    init_languages();
    init_tree();
    init_TreeView();
    init_util();
    init_lodash();
    init_workspace();
    logger104 = require_logger2()("Handler-callHierarchy");
    _CallHierarchyHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlightWinids = new Set();
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        this.disposables.push(commands_default.registerCommand(_CallHierarchyHandler.commandId, async (winid, item, openCommand) => {
          var _a2;
          let { nvim: nvim2 } = this;
          await nvim2.call("win_gotoid", [winid]);
          await workspace_default.jumpTo(item.uri, item.selectionRange.start, openCommand);
          let win = await nvim2.window;
          win.clearMatchGroup(_CallHierarchyHandler.rangesHighlight);
          win.highlightRanges(_CallHierarchyHandler.rangesHighlight, [item.selectionRange], 10, true);
          if (!((_a2 = item.ranges) == null ? void 0 : _a2.length))
            return;
          if (item.sourceUri) {
            let doc = workspace_default.getDocument(item.sourceUri);
            if (!doc)
              return;
            let winid2 = await nvim2.call("coc#compat#buf_win_id", [doc.bufnr]);
            if (winid2 == -1)
              return;
            if (winid2 != win.id) {
              win = nvim2.createWindow(winid2);
              win.clearMatchGroup(_CallHierarchyHandler.rangesHighlight);
            }
          }
          win.highlightRanges(_CallHierarchyHandler.rangesHighlight, item.ranges, 100, true);
          this.highlightWinids.add(win.id);
        }, null, true));
        events_default.on("BufWinEnter", (_, winid) => {
          if (this.highlightWinids.has(winid)) {
            this.highlightWinids.delete(winid);
            let win = nvim.createWindow(winid);
            win.clearMatchGroup(_CallHierarchyHandler.rangesHighlight);
          }
        }, null, this.disposables);
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("callHierarchy")) {
          let c = workspace_default.getConfiguration("callHierarchy");
          this.config = {
            splitCommand: c.get("splitCommand"),
            openCommand: c.get("openCommand"),
            enableTooltip: c.get("enableTooltip")
          };
        }
      }
      createProvider(doc, winid, position, kind) {
        let _onDidChangeTreeData = new import_vscode_languageserver_protocol98.Emitter();
        let source;
        let rootItems;
        const cancel = () => {
          if (source) {
            source.cancel();
            source.dispose();
            source = null;
          }
        };
        const findParent = (curr, element) => {
          let children = curr.children;
          if (!Array.isArray(children))
            return void 0;
          let find = children.find((o) => o == element);
          if (find)
            return curr;
          for (let item of children) {
            let res = findParent(item, element);
            if (res)
              return res;
          }
        };
        let provider = {
          kind,
          onDidChangeTreeData: _onDidChangeTreeData.event,
          getTreeItem: (element) => {
            var _a2;
            let item = new TreeItem(element.name, element.children ? TreeItemCollapsibleState.Expanded : TreeItemCollapsibleState.Collapsed);
            if (this.config.enableTooltip) {
              item.tooltip = import_path36.default.relative(workspace_default.cwd, URI.parse(element.uri).fsPath);
            }
            item.description = element.detail;
            item.deprecated = (_a2 = element.tags) == null ? void 0 : _a2.includes(import_vscode_languageserver_protocol98.SymbolTag.Deprecated);
            item.icon = this.handler.getIcon(element.kind);
            item.command = {
              command: _CallHierarchyHandler.commandId,
              title: "open location",
              arguments: [winid, element, this.config.openCommand]
            };
            return item;
          },
          getChildren: async (element) => {
            cancel();
            source = new import_vscode_languageserver_protocol98.CancellationTokenSource();
            let { token } = source;
            if (!element) {
              if (!rootItems) {
                rootItems = await this.prepare(doc, position, token);
                if (!(rootItems == null ? void 0 : rootItems.length))
                  return;
              }
              for (let o of rootItems) {
                let children = await this.getChildren(doc, o, provider.kind, token);
                if (token.isCancellationRequested)
                  break;
                if (Array.isArray(children))
                  o.children = children;
              }
              return rootItems;
            }
            if (element.children)
              return element.children;
            let items = await this.getChildren(doc, element, provider.kind, token);
            source = null;
            if (token.isCancellationRequested)
              return [];
            element.children = items;
            return items;
          },
          resolveActions: () => {
            return [{
              title: "Open in new tab",
              handler: async (element) => {
                await commands_default.executeCommand(_CallHierarchyHandler.commandId, winid, element, "tabe");
              }
            }, {
              title: "Show Incoming Calls",
              handler: (element) => {
                rootItems = [omit(element, ["children", "ranges", "sourceUri"])];
                provider.kind = "incoming";
                _onDidChangeTreeData.fire(void 0);
              }
            }, {
              title: "Show Outgoing Calls",
              handler: (element) => {
                rootItems = [omit(element, ["children", "ranges", "sourceUri"])];
                provider.kind = "outgoing";
                _onDidChangeTreeData.fire(void 0);
              }
            }, {
              title: "Dismiss",
              handler: async (element) => {
                let parentElement;
                for (let curr of rootItems) {
                  parentElement = findParent(curr, element);
                  if (parentElement)
                    break;
                }
                if (!parentElement)
                  return;
                let idx = parentElement.children.findIndex((o) => o === element);
                parentElement.children.splice(idx, 1);
                _onDidChangeTreeData.fire(parentElement);
              }
            }];
          },
          dispose: () => {
            cancel();
            _onDidChangeTreeData.dispose();
            rootItems = void 0;
            _onDidChangeTreeData = void 0;
          }
        };
        return provider;
      }
      async getChildren(doc, item, kind, token) {
        let items = [];
        if (kind == "incoming") {
          let res = await languages_default.provideIncomingCalls(doc, item, token);
          if (res)
            items = res.map((o) => Object.assign(o.from, { ranges: o.fromRanges }));
        } else {
          let res = await languages_default.provideOutgoingCalls(doc, item, token);
          if (res)
            items = res.map((o) => Object.assign(o.to, { ranges: o.fromRanges, sourceUri: item.uri }));
        }
        return items;
      }
      async prepare(doc, position, token) {
        this.handler.checkProvier("callHierarchy", doc);
        const res = await languages_default.prepareCallHierarchy(doc, position, token);
        return isCallHierarchyItem(res) ? [res] : res;
      }
      async getCallHierarchyItems(item, kind) {
        const { doc, position } = await this.handler.getCurrentState();
        const source = new import_vscode_languageserver_protocol98.CancellationTokenSource();
        if (!item) {
          await doc.synchronize();
          let res = await this.prepare(doc.textDocument, position, source.token);
          item = res ? res[0] : void 0;
          if (!res)
            return void 0;
        }
        let method = kind == "incoming" ? "provideIncomingCalls" : "provideOutgoingCalls";
        return await languages_default[method](doc.textDocument, item, source.token);
      }
      async getIncoming(item) {
        return await this.getCallHierarchyItems(item, "incoming");
      }
      async getOutgoing(item) {
        return await this.getCallHierarchyItems(item, "outgoing");
      }
      async showCallHierarchyTree(kind) {
        const { doc, position, winid } = await this.handler.getCurrentState();
        await doc.synchronize();
        let provider = this.createProvider(doc.textDocument, winid, position, kind);
        let treeView = new BasicTreeView("calls", { treeDataProvider: provider });
        treeView.title = `${kind.toUpperCase()} CALLS`;
        provider.onDidChangeTreeData((e) => {
          if (!e)
            treeView.title = `${provider.kind.toUpperCase()} CALLS`;
        });
        treeView.onDidChangeVisibility((e) => {
          if (!e.visible)
            provider.dispose();
        });
        this.disposables.push(treeView);
        await treeView.show(this.config.splitCommand);
      }
      dispose() {
        this.highlightWinids.clear();
        disposeAll(this.disposables);
      }
    };
    CallHierarchyHandler = _CallHierarchyHandler;
    CallHierarchyHandler.commandId = "callHierarchy.reveal";
    CallHierarchyHandler.rangesHighlight = "CocSelectedRange";
  }
});

// src/handler/semanticTokensHighlights/buffer.ts
var import_debounce12, import_vscode_languageserver_protocol99, logger105, SEMANTIC_HLGROUP_PREFIX, NAMESPACE, SemanticTokensBuffer;
var init_buffer5 = __esm({
  "src/handler/semanticTokensHighlights/buffer.ts"() {
    import_debounce12 = __toModule(require_debounce());
    import_vscode_languageserver_protocol99 = __toModule(require_main2());
    init_languages();
    init_workspace();
    logger105 = require_logger2()("semanticTokens-buffer");
    SEMANTIC_HLGROUP_PREFIX = "CocSem_";
    NAMESPACE = "semanticTokens";
    SemanticTokensBuffer = class {
      constructor(nvim, bufnr, config) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this.config = config;
        this.highlight = (0, import_debounce12.default)(() => {
          this.doHighlight().catch((e) => {
            logger105.error("Error on semanticTokens highlight:", e.stack);
          });
        }, global.hasOwnProperty("__TEST__") ? 10 : 2e3);
        this.highlight();
      }
      onChange() {
        this.cancel();
        this.highlight();
      }
      async forceHighlight() {
        this.cancel();
        this.highlight.clear();
        await this.doHighlight();
      }
      get highlights() {
        return this._highlights;
      }
      get enabled() {
        if (!this.config.enabled)
          return false;
        let doc = workspace_default.getDocument(this.bufnr);
        if (!doc || !doc.attached)
          return false;
        return languages_default.hasProvider("semanticTokens", doc.textDocument);
      }
      get previousVersion() {
        if (!this.previousResults)
          return void 0;
        return this.previousResults.version;
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      checkState() {
        if (!this.config.enabled)
          throw new Error("SemanticTokens highlights disabled by configuration");
        let doc = workspace_default.getDocument(this.bufnr);
        if (!doc || !doc.attached)
          throw new Error("Document not attached");
        if (!languages_default.hasProvider("semanticTokens", doc.textDocument))
          throw new Error("SemanticTokens provider not found, your languageserver may not support it");
      }
      setState(enabled) {
        if (enabled) {
          this.highlight();
        } else {
          this.highlight.clear();
          this.clearHighlight();
        }
      }
      async doHighlight() {
        if (!this.enabled)
          return;
        let doc = workspace_default.getDocument(this.bufnr);
        const { nvim } = this;
        let winid = await nvim.call("bufwinid", [this.bufnr]);
        if (winid == -1)
          return;
        const curr = await this.requestHighlights(doc);
        if (!curr)
          return;
        if (!curr.length) {
          this.clearHighlight();
          return;
        }
        let prev = [];
        if (workspace_default.env.updateHighlight) {
          prev = await nvim.call("coc#highlight#get_highlights", [this.bufnr, NAMESPACE]);
        }
        const { highlights, lines } = this.calculateHighlightUpdates(prev, curr);
        nvim.pauseNotification();
        if (!workspace_default.env.updateHighlight) {
          this.buffer.clearNamespace(NAMESPACE, 0, -1);
        } else {
          for (const ln of lines) {
            this.buffer.clearNamespace(NAMESPACE, ln, ln + 1);
          }
        }
        const groups = {};
        if (highlights.length) {
          for (const h of highlights) {
            const range = import_vscode_languageserver_protocol99.Range.create(h.lnum, h.colStart, h.lnum, h.colEnd);
            groups[h.hlGroup] = groups[h.hlGroup] || [];
            groups[h.hlGroup].push(range);
          }
        }
        for (const hlGroup of Object.keys(groups)) {
          this.buffer.highlightRanges(NAMESPACE, hlGroup, groups[hlGroup]);
        }
        nvim.resumeNotification(false, true);
        if (workspace_default.isVim)
          nvim.command("redraw", true);
      }
      calculateHighlightUpdates(prev, curr) {
        const stringCompare = Intl.Collator("en").compare;
        function compare(a, b) {
          return a.lnum - b.lnum || a.colStart - b.colStart || a.colEnd - b.colEnd || stringCompare(a.hlGroup, b.hlGroup);
        }
        prev = prev.slice().sort(compare);
        curr = curr.slice().sort(compare);
        const prevByLine = new Map();
        for (const hl of prev) {
          if (!prevByLine.has(hl.lnum))
            prevByLine.set(hl.lnum, []);
          prevByLine.get(hl.lnum).push(hl);
        }
        const currByLine = new Map();
        for (const hl of curr) {
          if (!currByLine.has(hl.lnum))
            currByLine.set(hl.lnum, []);
          currByLine.get(hl.lnum).push(hl);
        }
        const lastLine = Math.max((prev[prev.length - 1] || { lnum: 0 }).lnum, (curr[curr.length - 1] || { lnum: 0 }).lnum);
        const lineNumbersToUpdate = new Set();
        for (let i = 0; i <= lastLine; i++) {
          const ph = prevByLine.has(i);
          const ch = currByLine.has(i);
          if (ph !== ch) {
            lineNumbersToUpdate.add(i);
            continue;
          } else if (!ph && !ch) {
            continue;
          }
          const pp = prevByLine.get(i);
          const cc = currByLine.get(i);
          if (pp.length !== cc.length) {
            lineNumbersToUpdate.add(i);
            continue;
          }
          for (let j = 0; j < pp.length; j++) {
            if (compare(pp[j], cc[j]) !== 0) {
              lineNumbersToUpdate.add(i);
              continue;
            }
          }
        }
        let highlights = [];
        for (const line of lineNumbersToUpdate) {
          highlights = highlights.concat(currByLine.get(line) || []);
        }
        return { highlights, lines: lineNumbersToUpdate };
      }
      async requestHighlights(doc, forceFull) {
        const legend = languages_default.getLegend(doc.textDocument);
        if (!legend)
          return void 0;
        this.cancel();
        this.tokenSource = new import_vscode_languageserver_protocol99.CancellationTokenSource();
        const { token } = this.tokenSource;
        const hasEditProvider = languages_default.hasSemanticTokensEdits(doc.textDocument);
        const previousResult = forceFull ? null : this.previousResults;
        let result;
        let version2 = doc.textDocument.version;
        if (hasEditProvider && (previousResult == null ? void 0 : previousResult.resultId)) {
          result = await languages_default.provideDocumentSemanticTokensEdits(doc.textDocument, previousResult.resultId, token);
        } else {
          result = await languages_default.provideDocumentSemanticTokens(doc.textDocument, token);
        }
        this.tokenSource = null;
        if (token.isCancellationRequested || !result)
          return void 0;
        let tokens = [];
        if (import_vscode_languageserver_protocol99.SemanticTokens.is(result)) {
          tokens = result.data;
        } else {
          tokens = previousResult.tokens;
          result.edits.forEach((e) => {
            if (e.deleteCount > 0) {
              tokens.splice(e.start, e.deleteCount, ...e.data);
            } else {
              tokens.splice(e.start, 0, ...e.data);
            }
          });
        }
        this.previousResults = { resultId: result.resultId, tokens, version: version2 };
        const relatives = [];
        for (let i = 0; i < tokens.length; i += 5) {
          const deltaLine = tokens[i];
          const deltaStartCharacter = tokens[i + 1];
          const length = tokens[i + 2];
          const tokenType = tokens[i + 3];
          const group2 = SEMANTIC_HLGROUP_PREFIX + legend.tokenTypes[tokenType];
          relatives.push({
            group: group2,
            deltaLine,
            deltaStartCharacter,
            length
          });
        }
        const res = [];
        let currentLine = 0;
        let currentCharacter = 0;
        for (const {
          group: group2,
          deltaLine,
          deltaStartCharacter,
          length
        } of relatives) {
          const lnum = currentLine + deltaLine;
          const colStart = deltaLine === 0 ? currentCharacter + deltaStartCharacter : deltaStartCharacter;
          const colEnd = colStart + length;
          currentLine = lnum;
          currentCharacter = colStart;
          res.push({
            hlGroup: group2,
            lnum,
            colStart,
            colEnd
          });
        }
        this._highlights = res;
        return res;
      }
      clearHighlight() {
        this.buffer.clearNamespace(NAMESPACE);
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      dispose() {
        this.highlight.clear();
        this.previousResults = void 0;
        this.cancel();
      }
    };
  }
});

// src/handler/semanticTokensHighlights/index.ts
var logger106, headGroup, SemanticTokensHighlights;
var init_semanticTokensHighlights = __esm({
  "src/handler/semanticTokensHighlights/index.ts"() {
    init_commands2();
    init_events();
    init_languages();
    init_highligher();
    init_util();
    init_window();
    init_workspace();
    init_buffer5();
    logger106 = require_logger2()("semanticTokens");
    headGroup = "Statement";
    SemanticTokensHighlights = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        commands_default.register({
          id: "semanticTokens.checkCurrent",
          execute: async () => {
            try {
              let item = await this.getCurrentItem();
              item.checkState();
            } catch (e) {
              window_default.showMessage(e.message, "error");
              return;
            }
            window_default.showMessage("Semantic tokens provider found for current buffer", "more");
          }
        }, false, "check semantic tokens provider for current buffer");
        commands_default.register({
          id: "semanticTokens.clearCurrent",
          execute: async () => {
            let buf = await nvim.buffer;
            buf.clearNamespace(NAMESPACE, 0, -1);
          }
        }, false, "clear semantic tokens highlights of current buffer");
        commands_default.register({
          id: "semanticTokens.clearAll",
          execute: async () => {
            let bufs = await nvim.buffers;
            for (let buf of bufs) {
              buf.clearNamespace(NAMESPACE, 0, -1);
            }
          }
        }, false, "clear semantic tokens highlights of all buffers");
        this.disposables.push({
          dispose: () => {
            commands_default.unregister("semanticTokens.checkCurrentBuffer");
          }
        });
        events_default.on("BufEnter", (bufnr) => {
          let item = this.highlighters.getItem(bufnr);
          if (!item)
            return;
          let doc = workspace_default.getDocument(bufnr);
          if (!doc || doc.textDocument.version == item.previousVersion)
            return;
          item.forceHighlight().catch((e) => {
            logger106.error(`Error on semantic highlighters:`, e);
          });
        }, null, this.disposables);
        this.highlighters = workspace_default.registerBufferSync((doc) => {
          return new SemanticTokensBuffer(this.nvim, doc.bufnr, this.config);
        });
        languages_default.onDidSemanticTokensRefresh((selector) => {
          for (let item of this.highlighters.items) {
            let doc = workspace_default.getDocument(item.bufnr);
            if (doc && workspace_default.match(selector, doc.textDocument)) {
              item.highlight();
            }
          }
        }, null, this.disposables);
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("coc.preferences")) {
          let config = workspace_default.getConfiguration("coc.preferences");
          let enabled = config.get("semanticTokensHighlights", true);
          if (workspace_default.isVim && !workspace_default.env.textprop) {
            enabled = false;
          }
          if (this.config && enabled != this.config.enabled) {
            if (this.highlighters) {
              for (let buf of this.highlighters.items) {
                buf.setState(enabled);
              }
            }
          }
          if (!this.config) {
            this.config = { enabled };
          } else {
            this.config.enabled = enabled;
          }
        }
      }
      async getCurrentItem() {
        let buf = await this.nvim.buffer;
        let highlighter = this.highlighters.getItem(buf.id);
        if (!highlighter)
          throw new Error("current buffer not attached");
        return highlighter;
      }
      async highlightCurrent() {
        let highlighter = await this.getCurrentItem();
        highlighter.checkState();
        await highlighter.forceHighlight();
      }
      async showHiglightInfo() {
        if (!this.config.enabled)
          throw new Error("Semantic highlights is disabled by configuration.");
        let item = await this.getCurrentItem();
        item.checkState();
        let highlights = item.highlights || [];
        let highlighter = new Highlighter();
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command(`vs +setl\\ buftype=nofile __coc_semantic_highlights_${item.bufnr}__`, true);
        nvim.command(`setl bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1`, true);
        nvim.call("bufnr", ["%"], true);
        let res = await nvim.resumeNotification();
        if (res[1])
          throw new Error(`Error on buffer create: ${res[1]}`);
        let bufnr = res[0][2];
        highlighter.addLine("Semantic highlights info", headGroup);
        highlighter.addLine("");
        highlighter.addLine("The number of semantic tokens: ");
        highlighter.addText(String(highlights.length), "Number");
        highlighter.addLine("");
        highlighter.addLine("Semantic highlight groups used by current buffer", headGroup);
        highlighter.addLine("");
        const groups = [...new Set(highlights.map(({ hlGroup }) => hlGroup))];
        for (const hlGroup of groups) {
          highlighter.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text: hlGroup, hlGroup }]);
          highlighter.addLine("");
        }
        highlighter.addLine("Tokens types that current Language Server supported:", headGroup);
        highlighter.addLine("");
        let doc = workspace_default.getDocument(item.bufnr);
        const legend = languages_default.getLegend(doc.textDocument);
        if (legend == null ? void 0 : legend.tokenTypes.length) {
          for (const t of [...new Set(legend.tokenTypes)]) {
            highlighter.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text: `CocSem_${t}`, hlGroup: `CocSem_${t}` }]);
            highlighter.addLine("");
          }
        } else {
          highlighter.addLine("No token types supported", "Comment");
        }
        highlighter.addLine("Tokens modifiers that current Language Server supported:", headGroup);
        highlighter.addLine("");
        if (legend == null ? void 0 : legend.tokenModifiers.length) {
          for (const t of [...new Set(legend.tokenModifiers)]) {
            highlighter.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text: `CocSem_${t}`, hlGroup: `CocSem_${t}` }]);
            highlighter.addLine("");
          }
        } else {
          highlighter.addLine("No token modifiers supported", "Comment");
        }
        nvim.pauseNotification();
        highlighter.render(nvim.createBuffer(bufnr));
        nvim.resumeNotification(false, true);
      }
      dispose() {
        this.highlighters.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/signature.ts
var import_vscode_languageserver_protocol100, logger107, Signature;
var init_signature = __esm({
  "src/handler/signature.ts"() {
    import_vscode_languageserver_protocol100 = __toModule(require_main2());
    init_events();
    init_languages();
    init_floatFactory();
    init_util();
    init_string();
    init_workspace();
    logger107 = require_logger2()("handler-signature");
    Signature = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.signatureFactory = new FloatFactory(nvim);
        this.loadConfiguration();
        this.disposables.push(this.signatureFactory);
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        events_default.on("CursorMovedI", async (bufnr, cursor) => {
          let pos = this.lastPosition;
          if (!pos)
            return;
          if (pos.bufnr == bufnr && pos.lnum == cursor[0] && pos.col <= cursor[1])
            return;
          this.signatureFactory.close();
        }, null, this.disposables);
        events_default.on(["InsertLeave", "BufEnter"], () => {
          var _a2;
          (_a2 = this.tokenSource) == null ? void 0 : _a2.cancel();
        }, null, this.disposables);
        events_default.on("TextChangedI", () => {
          if (this.config.hideOnChange) {
            this.signatureFactory.close();
          }
        }, null, this.disposables);
        events_default.on("TextInsert", async (bufnr, info, character) => {
          if (!this.config.trigger)
            return;
          let doc = this.getTextDocument(bufnr);
          if (!doc || !languages_default.shouldTriggerSignatureHelp(doc.textDocument, character))
            return;
          await this._triggerSignatureHelp(doc, { line: info.lnum - 1, character: info.pre.length }, false);
        }, null, this.disposables);
      }
      getTextDocument(bufnr) {
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || doc.isCommandLine || !doc.attached)
          return;
        return doc;
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("signature")) {
          let config = workspace_default.getConfiguration("signature");
          let target = config.get("target", "float");
          if (target == "float" && !workspace_default.floatSupported) {
            target = "echo";
          }
          this.config = {
            target,
            floatConfig: config.get("floatConfig", {}),
            trigger: config.get("enable", true),
            wait: Math.max(config.get("triggerSignatureWait", 500), 200),
            preferAbove: config.get("preferShownAbove", true),
            hideOnChange: config.get("hideOnTextChange", false)
          };
        }
      }
      async triggerSignatureHelp() {
        let { doc, position, mode } = await this.handler.getCurrentState();
        if (!languages_default.hasProvider("signature", doc.textDocument))
          return false;
        let offset = 0;
        let character = position.character;
        if (mode == "s") {
          let placeholder = await this.nvim.getVar("coc_last_placeholder");
          if (placeholder) {
            let { start, end, bufnr } = placeholder;
            if (bufnr == doc.bufnr && start.line == end.line && start.line == position.line) {
              position = import_vscode_languageserver_protocol100.Position.create(start.line, start.character);
              offset = character - position.character;
            }
          }
        }
        return await this._triggerSignatureHelp(doc, position, true, offset);
      }
      async _triggerSignatureHelp(doc, position, invoke = true, offset = 0) {
        var _a2;
        (_a2 = this.tokenSource) == null ? void 0 : _a2.cancel();
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol100.CancellationTokenSource();
        let token = tokenSource.token;
        token.onCancellationRequested(() => {
          tokenSource.dispose();
          this.tokenSource = void 0;
        });
        let { target } = this.config;
        let timer = this.timer = setTimeout(() => {
          tokenSource.cancel();
        }, this.config.wait);
        await doc.patchChange(true);
        let signatureHelp = await languages_default.getSignatureHelp(doc.textDocument, position, token, {
          isRetrigger: this.signatureFactory.checkRetrigger(doc.bufnr),
          triggerKind: invoke ? import_vscode_languageserver_protocol100.SignatureHelpTriggerKind.Invoked : import_vscode_languageserver_protocol100.SignatureHelpTriggerKind.TriggerCharacter
        });
        clearTimeout(timer);
        if (token.isCancellationRequested)
          return false;
        if (!signatureHelp || signatureHelp.signatures.length == 0) {
          this.signatureFactory.close();
          return false;
        }
        let { activeSignature, signatures } = signatureHelp;
        if (activeSignature) {
          let [active] = signatures.splice(activeSignature, 1);
          if (active)
            signatures.unshift(active);
        }
        if (target == "echo") {
          this.echoSignature(signatureHelp);
        } else {
          await this.showSignatureHelp(doc, position, signatureHelp, offset);
        }
        return true;
      }
      async showSignatureHelp(doc, position, signatureHelp, offset) {
        let { signatures, activeParameter } = signatureHelp;
        let paramDoc = null;
        let startOffset = offset;
        let docs = signatures.reduce((p, c, idx) => {
          var _a2;
          let activeIndexes = null;
          let nameIndex = c.label.indexOf("(");
          if (idx == 0 && activeParameter != null) {
            let active = (_a2 = c.parameters) == null ? void 0 : _a2[activeParameter];
            if (active) {
              let after = c.label.slice(nameIndex == -1 ? 0 : nameIndex);
              paramDoc = active.documentation;
              if (typeof active.label === "string") {
                let str = after.slice(0);
                let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
                let index = ms ? ms.index : str.indexOf(active.label);
                if (index != -1) {
                  activeIndexes = [
                    index + nameIndex,
                    index + active.label.length + nameIndex
                  ];
                }
              } else {
                activeIndexes = active.label;
              }
            }
          }
          if (activeIndexes == null) {
            activeIndexes = [nameIndex + 1, nameIndex + 1];
          }
          if (offset == startOffset) {
            offset = offset + activeIndexes[0] + 1;
          }
          p.push({
            content: c.label,
            filetype: doc.filetype,
            active: activeIndexes
          });
          if (paramDoc) {
            let content2 = typeof paramDoc === "string" ? paramDoc : paramDoc.value;
            if (content2.trim().length) {
              p.push({
                content: content2,
                filetype: isMarkdown(c.documentation) ? "markdown" : "txt"
              });
            }
          }
          if (idx == 0 && c.documentation) {
            let { documentation } = c;
            let content2 = typeof documentation === "string" ? documentation : documentation.value;
            if (content2.trim().length) {
              p.push({
                content: content2,
                filetype: isMarkdown(c.documentation) ? "markdown" : "txt"
              });
            }
          }
          return p;
        }, []);
        let content = doc.getline(position.line, false).slice(0, position.character);
        this.lastPosition = { bufnr: doc.bufnr, lnum: position.line + 1, col: byteLength(content) + 1 };
        const excludeImages = workspace_default.getConfiguration("coc.preferences").get("excludeImageLinksInMarkdownDocument");
        let config = this.signatureFactory.applyFloatConfig({
          preferTop: this.config.preferAbove,
          autoHide: false,
          offsetX: offset,
          modes: ["i", "ic", "s"],
          excludeImages
        }, this.config.floatConfig);
        await this.signatureFactory.show(docs, config);
      }
      echoSignature(signatureHelp) {
        var _a2;
        let { signatures, activeParameter } = signatureHelp;
        let columns = workspace_default.env.columns;
        signatures = signatures.slice(0, workspace_default.env.cmdheight);
        let signatureList = [];
        for (let signature of signatures) {
          let parts = [];
          let { label } = signature;
          label = label.replace(/\n/g, " ");
          if (label.length >= columns - 16) {
            label = label.slice(0, columns - 16) + "...";
          }
          let nameIndex = label.indexOf("(");
          if (nameIndex == -1) {
            parts = [{ text: label, type: "Normal" }];
          } else {
            parts.push({
              text: label.slice(0, nameIndex),
              type: "Label"
            });
            let after = label.slice(nameIndex);
            if (signatureList.length == 0 && activeParameter != null) {
              let active = (_a2 = signature.parameters) == null ? void 0 : _a2[activeParameter];
              if (active) {
                let start;
                let end;
                if (typeof active.label === "string") {
                  let str = after.slice(0);
                  let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
                  let idx = ms ? ms.index : str.indexOf(active.label);
                  if (idx == -1) {
                    parts.push({ text: after, type: "Normal" });
                  } else {
                    start = idx;
                    end = idx + active.label.length;
                  }
                } else {
                  [start, end] = active.label;
                  start = start - nameIndex;
                  end = end - nameIndex;
                }
                if (start != null && end != null) {
                  parts.push({ text: after.slice(0, start), type: "Normal" });
                  parts.push({ text: after.slice(start, end), type: "MoreMsg" });
                  parts.push({ text: after.slice(end), type: "Normal" });
                }
              }
            } else {
              parts.push({
                text: after,
                type: "Normal"
              });
            }
          }
          signatureList.push(parts);
        }
        this.nvim.callTimer("coc#util#echo_signatures", [signatureList], true);
      }
      dispose() {
        disposeAll(this.disposables);
        if (this.timer) {
          clearTimeout(this.timer);
        }
      }
    };
  }
});

// src/handler/symbols/util.ts
function convertSymbols(symbols) {
  let res = [];
  let arr = symbols.slice();
  arr.sort(sortDocumentSymbols);
  arr.forEach((s) => addDocumentSymbol(res, s, 0));
  return res;
}
function sortDocumentSymbols(a, b) {
  let ra = a.selectionRange;
  let rb = b.selectionRange;
  return comparePosition(ra.start, rb.start);
}
function addDocumentSymbol(res, sym, level) {
  let { name: name2, selectionRange, kind, children, range } = sym;
  let { start } = selectionRange || range;
  res.push({
    col: start.character + 1,
    lnum: start.line + 1,
    text: name2,
    level,
    kind: getSymbolKind(kind),
    range,
    selectionRange
  });
  if (children && children.length) {
    children.sort(sortDocumentSymbols);
    for (let sym2 of children) {
      addDocumentSymbol(res, sym2, level + 1);
    }
  }
}
function isDocumentSymbol(a) {
  return a && !a.hasOwnProperty("location");
}
function isDocumentSymbols(a) {
  return isDocumentSymbol(a[0]);
}
var init_util5 = __esm({
  "src/handler/symbols/util.ts"() {
    init_convert();
    init_position();
  }
});

// src/handler/symbols/buffer.ts
var import_debounce13, import_vscode_languageserver_protocol101, SymbolsBuffer;
var init_buffer6 = __esm({
  "src/handler/symbols/buffer.ts"() {
    import_debounce13 = __toModule(require_debounce());
    import_vscode_languageserver_protocol101 = __toModule(require_main2());
    init_languages();
    init_util();
    init_workspace();
    init_util5();
    SymbolsBuffer = class {
      constructor(bufnr) {
        this.bufnr = bufnr;
        this.disposables = [];
        this.autoUpdate = false;
        this._onDidUpdate = new import_vscode_languageserver_protocol101.Emitter();
        this.onDidUpdate = this._onDidUpdate.event;
        this.fetchSymbols = (0, import_debounce13.default)(() => {
          this._fetchSymbols().logError();
        }, global.hasOwnProperty("__TEST__") ? 10 : 500);
      }
      async getSymbols() {
        var _a2;
        let doc = workspace_default.getDocument(this.bufnr);
        if (!doc)
          return [];
        await doc.patchChange();
        this.autoUpdate = true;
        if (doc.version == this.version && ((_a2 = this.symbols) == null ? void 0 : _a2.length))
          return this.symbols;
        this.cancel();
        await this._fetchSymbols();
        return this.symbols;
      }
      onChange() {
        this.cancel();
        if (this.autoUpdate) {
          this.fetchSymbols();
        }
      }
      get textDocument() {
        var _a2;
        return (_a2 = workspace_default.getDocument(this.bufnr)) == null ? void 0 : _a2.textDocument;
      }
      async _fetchSymbols() {
        let { textDocument } = this;
        if (!textDocument)
          return;
        let { version: version2 } = textDocument;
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol101.CancellationTokenSource();
        let { token } = tokenSource;
        let symbols = await languages_default.getDocumentSymbol(textDocument, token);
        this.tokenSource = void 0;
        if (symbols == null || token.isCancellationRequested)
          return;
        let res;
        if (isDocumentSymbols(symbols)) {
          res = symbols;
        } else {
          res = symbols.map((o) => {
            let sym = import_vscode_languageserver_protocol101.DocumentSymbol.create(o.name, "", o.kind, o.location.range, o.location.range);
            if (o.deprecated)
              sym.tags = [import_vscode_languageserver_protocol101.SymbolTag.Deprecated];
            return sym;
          });
        }
        this.version = version2;
        this.symbols = res;
        this._onDidUpdate.fire(res);
      }
      cancel() {
        this.fetchSymbols.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      dispose() {
        this.cancel();
        this.symbols = void 0;
        this._onDidUpdate.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/tree/BasicDataProvider.ts
function isIcon(obj) {
  if (!obj)
    return false;
  return typeof obj.text === "string" && typeof obj.hlGroup === "string";
}
function sameTreeNode(one, two) {
  if (one.label === two.label && one.deprecated === two.deprecated && one.key === two.key) {
    return true;
  }
  return false;
}
function sameTreeNodes(one, two) {
  if (one.length !== two.length)
    return false;
  return one.every((v, idx) => sameTreeNode(v, two[idx]));
}
var import_vscode_languageserver_protocol102, BasicDataProvider;
var init_BasicDataProvider = __esm({
  "src/tree/BasicDataProvider.ts"() {
    init_esm_node();
    import_vscode_languageserver_protocol102 = __toModule(require_main2());
    init_commands2();
    init_util();
    init_TreeItem();
    BasicDataProvider = class {
      constructor(opts) {
        this.opts = opts;
        this.disposables = [];
        this._onDidChangeTreeData = new import_vscode_languageserver_protocol102.Emitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        this.invokeCommand = `_invoke_${v4_default()}`;
        this.disposables.push(commands_default.registerCommand(this.invokeCommand, async (node) => {
          if (typeof opts.handleClick === "function") {
            await opts.handleClick(node);
          } else {
            console.error("Handler not found");
          }
        }, null, true));
        if (typeof opts.resolveActions === "function") {
          this.resolveActions = opts.resolveActions.bind(this);
        }
      }
      iterate(node, parentNode, level, fn) {
        let res = fn(node, parentNode, level);
        if (res === false)
          return false;
        if (Array.isArray(node.children)) {
          for (let element of node.children) {
            let res2 = this.iterate(element, node, level + 1, fn);
            if (res2 === false)
              return false;
          }
        }
        return res;
      }
      updateNodes(old, data, parentNode, fireEvent = true) {
        let sameNodes = sameTreeNodes(old, data);
        const applyNode = (previous, curr, fireEvent2) => {
          var _a2, _b, _c, _d, _e, _f;
          let changed = false;
          for (let key of Object.keys(curr)) {
            if (["children", "key"].includes(key))
              continue;
            previous[key] = curr[key];
          }
          if (((_a2 = previous.children) == null ? void 0 : _a2.length) && !((_b = curr.children) == null ? void 0 : _b.length)) {
            delete previous.children;
            changed = true;
          }
          if (!((_c = previous.children) == null ? void 0 : _c.length) && ((_d = curr.children) == null ? void 0 : _d.length)) {
            previous.children = curr.children;
            changed = true;
          }
          if (changed) {
            if (fireEvent2)
              this._onDidChangeTreeData.fire(previous);
            return;
          }
          if (((_e = previous.children) == null ? void 0 : _e.length) && ((_f = curr.children) == null ? void 0 : _f.length)) {
            this.updateNodes(previous.children, curr.children, previous, fireEvent2);
          }
        };
        if (sameNodes) {
          for (let i = 0; i < old.length; i++) {
            applyNode(old[i], data[i], fireEvent);
          }
        } else {
          let oldNodes = old.splice(0, old.length);
          let used = new Set();
          for (let i = 0; i < data.length; i++) {
            let curr = data[i];
            let findIndex;
            if (curr.key) {
              findIndex = oldNodes.findIndex((o, i2) => !used.has(i2) && o.key == curr.key);
            } else {
              findIndex = oldNodes.findIndex((o, i2) => !used.has(i2) && o.label == curr.label);
            }
            if (findIndex === -1) {
              old[i] = curr;
            } else {
              used.add(findIndex);
              let previous = oldNodes[findIndex];
              applyNode(previous, curr, false);
              old[i] = previous;
            }
          }
          if (fireEvent) {
            this._onDidChangeTreeData.fire(parentNode);
          }
        }
      }
      update(data, reset) {
        if (!this.data)
          return;
        if (reset) {
          this.data = data || [];
          this._onDidChangeTreeData.fire(void 0);
        } else {
          this.updateNodes(this.data, data || [], void 0);
        }
        return this.data;
      }
      getTreeItem(node) {
        var _a2;
        let label = node.label;
        let { expandLevel } = this.opts;
        let item;
        if (!((_a2 = node.children) == null ? void 0 : _a2.length)) {
          item = new TreeItem(label);
        } else {
          if (expandLevel && expandLevel > 0) {
            let level = this.getLevel(node);
            let state = level && level <= expandLevel ? TreeItemCollapsibleState.Expanded : TreeItemCollapsibleState.Collapsed;
            item = new TreeItem(label, state);
          } else {
            item = new TreeItem(label, TreeItemCollapsibleState.Collapsed);
          }
        }
        item.description = node.description;
        if (node.deprecated)
          item.deprecated = true;
        if (node.tooltip)
          item.tooltip = node.tooltip;
        if (isIcon(node.icon)) {
          item.icon = node.icon;
        } else if (typeof this.opts.resolveIcon === "function") {
          let res = this.opts.resolveIcon(node);
          if (res)
            item.icon = res;
        }
        return item;
      }
      async getChildren(element) {
        if (element)
          return element.children || [];
        if (this.data)
          return this.data;
        let data = await Promise.resolve(this.opts.provideData());
        if (!Array.isArray(data))
          throw new Error(`Unable to fetch data`);
        this.data = data;
        return data;
      }
      getParent(element) {
        if (!this.data)
          return void 0;
        let find;
        for (let item of this.data) {
          let res = this.iterate(item, null, 0, (node, parentNode) => {
            if (node === element) {
              find = parentNode;
              return false;
            }
          });
          if (res === false)
            break;
        }
        return find;
      }
      getLevel(element) {
        if (!this.data)
          return void 0;
        let level = 0;
        for (let item of this.data) {
          let res = this.iterate(item, null, 1, (node, _parentNode, l) => {
            if (node === element) {
              level = l;
              return false;
            }
          });
          if (res === false)
            break;
        }
        return level;
      }
      async resolveTreeItem(item, element, token) {
        if (typeof this.opts.resolveItem === "function") {
          let res = await Promise.resolve(this.opts.resolveItem(item, element, token));
          if (res)
            Object.assign(item, res);
        }
        if (!item.command) {
          item.command = {
            title: `invoke ${element.label}`,
            command: this.invokeCommand,
            arguments: [element]
          };
        }
        return item;
      }
      dispose() {
        this.data = [];
        this._onDidChangeTreeData.dispose();
        if (typeof this.opts.onDispose === "function") {
          this.opts.onDispose();
        }
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/symbols/outline.ts
var import_debounce14, import_vscode_languageserver_protocol103, logger108, SymbolsOutline;
var init_outline2 = __esm({
  "src/handler/symbols/outline.ts"() {
    import_debounce14 = __toModule(require_debounce());
    import_vscode_languageserver_protocol103 = __toModule(require_main2());
    init_events();
    init_languages();
    init_BasicDataProvider();
    init_TreeView();
    init_util();
    init_position();
    init_window();
    init_workspace();
    logger108 = require_logger2()("symbols-outline");
    SymbolsOutline = class {
      constructor(nvim, buffers, handler) {
        this.nvim = nvim;
        this.buffers = buffers;
        this.handler = handler;
        this.providersMap = new Map();
        this.treeViews = new WeakMap();
        this.originalWins = new WeakMap();
        this.disposables = [];
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        events_default.on("BufUnload", async (bufnr) => {
          let provider = this.providersMap.get(bufnr);
          if (!provider)
            return;
          this.providersMap.delete(bufnr);
          provider.dispose();
          let views = this.treeViews.get(provider);
          this.treeViews.delete(provider);
          for (let view of views) {
            if (!view.visible)
              continue;
            let winid = this.originalWins.get(view);
            if (winid && this.config.checkBufferSwitch) {
              let nr = await nvim.call("win_id2win", [winid]);
              if (nr) {
                let win = nvim.createWindow(view.windowId);
                win.setVar("target_bufnr", -1, true);
                let timer = setTimeout(() => {
                  if (view.visible)
                    view.dispose();
                }, 200);
                this.disposables.push({
                  dispose: () => {
                    clearTimeout(timer);
                  }
                });
                continue;
              }
            }
            view.dispose();
          }
        }, null, this.disposables);
        events_default.on("BufEnter", (0, import_debounce14.default)(() => {
          void this._onBufEnter();
        }, global.hasOwnProperty("__TEST__") ? 100 : 300), null, this.disposables);
        events_default.on("CursorHold", async (bufnr) => {
          if (!this.config.followCursor)
            return;
          let provider = this.providersMap.get(bufnr);
          if (!provider)
            return;
          let views = this.treeViews.get(provider);
          if (!views || !views.length)
            return;
          let winid = await this.nvim.call("coc#window#find", ["cocViewId", "OUTLINE"]);
          if (winid == -1)
            return;
          let view = views.find((o) => o.windowId == winid);
          if (!view)
            return;
          let pos = await window_default.getCursorPosition();
          let curr;
          let checkNode = (node) => {
            if (positionInRange(pos, node.range) != 0)
              return false;
            curr = node;
            if (Array.isArray(node.children)) {
              for (let n of node.children) {
                if (checkNode(n))
                  break;
              }
            }
            return true;
          };
          let nodes = await Promise.resolve(provider.getChildren());
          for (let n of nodes) {
            if (checkNode(n))
              break;
          }
          if (curr)
            await view.reveal(curr);
        }, null, this.disposables);
      }
      async _onBufEnter() {
        if (!this.config.checkBufferSwitch)
          return;
        let [curr, bufnr, winid] = await this.nvim.eval(`[win_getid(),bufnr('%'),coc#window#find('cocViewId', 'OUTLINE')]`);
        if (curr == winid || winid == -1)
          return;
        if (!this.buffers.getItem(bufnr))
          return;
        let win = this.nvim.createWindow(winid);
        let target = await win.getVar("target_bufnr");
        if (target == bufnr)
          return;
        await this.show(1);
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("outline")) {
          let c = workspace_default.getConfiguration("outline");
          this.config = {
            splitCommand: c.get("splitCommand"),
            followCursor: c.get("followCursor"),
            keepWindow: c.get("keepWindow"),
            expandLevel: c.get("expandLevel"),
            checkBufferSwitch: c.get("checkBufferSwitch"),
            sortBy: c.get("sortBy"),
            showLineNumber: c.get("showLineNumber"),
            codeActionKinds: c.get("codeActionKinds")
          };
        }
      }
      convertSymbolToNode(documentSymbol, sortFn) {
        var _a2;
        return {
          label: documentSymbol.name,
          tooltip: documentSymbol.detail,
          description: this.config.showLineNumber ? `${documentSymbol.selectionRange.start.line + 1}` : void 0,
          icon: this.handler.getIcon(documentSymbol.kind),
          deprecated: (_a2 = documentSymbol.tags) == null ? void 0 : _a2.includes(import_vscode_languageserver_protocol103.SymbolTag.Deprecated),
          kind: documentSymbol.kind,
          range: documentSymbol.range,
          selectRange: documentSymbol.selectionRange,
          children: Array.isArray(documentSymbol.children) ? documentSymbol.children.map((o) => {
            return this.convertSymbolToNode(o, sortFn);
          }).sort(sortFn) : void 0
        };
      }
      setMessage(provider, msg) {
        let views = this.treeViews.get(provider);
        if (views) {
          views.forEach((view) => {
            view.message = msg;
          });
        }
      }
      createProvider(buf) {
        let { bufnr } = buf;
        let { sortBy } = this.config;
        let { nvim } = this;
        let sortFn = (a, b) => {
          if (sortBy === "name") {
            return a.label < b.label ? -1 : 1;
          }
          if (sortBy === "category") {
            if (a.kind == b.kind)
              return a.label < b.label ? -1 : 1;
            return a.kind - b.kind;
          }
          return comparePosition(a.selectRange.start, b.selectRange.start);
        };
        let convertSymbols2 = (symbols) => {
          return symbols.map((s) => this.convertSymbolToNode(s, sortFn)).sort(sortFn);
        };
        let disposable;
        let provider = new BasicDataProvider({
          expandLevel: this.config.expandLevel,
          provideData: async () => {
            let doc = workspace_default.getDocument(bufnr);
            if (!languages_default.hasProvider("documentSymbol", doc.textDocument)) {
              throw new Error("Document symbol provider not found");
            }
            this.setMessage(provider, "Loading document symbols");
            let arr = await buf.getSymbols();
            if (!arr || arr.length == 0) {
              throw new Error("Empty symbols returned from language server. ");
            }
            disposable = buf.onDidUpdate((symbols) => {
              provider.update(convertSymbols2(symbols));
            });
            this.setMessage(provider, void 0);
            return convertSymbols2(arr);
          },
          handleClick: async (item) => {
            let winnr = await nvim.call("bufwinnr", [bufnr]);
            if (winnr == -1)
              return;
            nvim.pauseNotification();
            nvim.command(`${winnr}wincmd w`, true);
            let pos = item.selectRange.start;
            nvim.call("coc#cursor#move_to", [pos.line, pos.character], true);
            nvim.command(`normal! zz`, true);
            let buf2 = nvim.createBuffer(bufnr);
            buf2.highlightRanges("outline-hover", "CocHoverRange", [item.selectRange]);
            nvim.command("redraw", true);
            await nvim.resumeNotification();
            setTimeout(() => {
              buf2.clearNamespace("outline-hover");
              nvim.command("redraw", true);
            }, global.hasOwnProperty("__TEST__") ? 10 : 300);
          },
          resolveActions: async (_, element) => {
            let winnr = await nvim.call("bufwinnr", [bufnr]);
            if (winnr == -1)
              return;
            let doc = workspace_default.getDocument(bufnr);
            let actions = await this.handler.getCodeActions(doc, element.range, this.config.codeActionKinds);
            let arr = actions.map((o) => {
              return {
                title: o.title,
                handler: async () => {
                  let position = element.range.start;
                  await nvim.command(`${winnr}wincmd w`);
                  await this.nvim.call("coc#cursor#move_to", [position.line, position.character]);
                  await this.handler.applyCodeAction(o);
                }
              };
            });
            return [...arr, {
              title: "Visual Select",
              handler: async (item) => {
                await nvim.command(`${winnr}wincmd w`);
                await workspace_default.selectRange(item.range);
              }
            }];
          },
          onDispose: () => {
            this.providersMap.delete(buf.bufnr);
            if (disposable)
              disposable.dispose();
          }
        });
        return provider;
      }
      async show(keep) {
        await workspace_default.document;
        let [bufnr, winid] = await this.nvim.eval('[bufnr("%"),win_getid()]');
        let buf = this.buffers.getItem(bufnr);
        if (!buf)
          throw new Error("Document not attached");
        let provider = this.providersMap.get(bufnr);
        if (!provider) {
          provider = this.createProvider(buf);
          this.providersMap.set(bufnr, provider);
        }
        let treeView = new BasicTreeView("OUTLINE", {
          enableFilter: true,
          treeDataProvider: provider
        });
        this.originalWins.set(treeView, winid);
        let arr = this.treeViews.get(provider) || [];
        arr.push(treeView);
        this.treeViews.set(provider, arr);
        treeView.onDidChangeVisibility(({ visible }) => {
          if (visible || !this.treeViews.has(provider))
            return;
          let arr2 = this.treeViews.get(provider) || [];
          arr2 = arr2.filter((s) => s !== treeView);
          this.originalWins.delete(treeView);
          if (arr2.length) {
            this.treeViews.set(provider, arr2);
            return;
          }
          provider.dispose();
          this.treeViews.delete(provider);
        });
        await treeView.show(this.config.splitCommand);
        if (treeView.windowId) {
          let win = this.nvim.createWindow(treeView.windowId);
          win.setVar("target_bufnr", bufnr, true);
        }
        if (keep == 1 || keep === void 0 && this.config.keepWindow) {
          await this.nvim.command("wincmd p");
        }
      }
      has(bufnr) {
        return this.providersMap.has(bufnr);
      }
      async hide() {
        let winid = await this.nvim.call("coc#window#find", ["cocViewId", "OUTLINE"]);
        if (winid == -1)
          return;
        await this.nvim.call("coc#window#close", [winid]);
      }
      dispose() {
        for (let provider of this.providersMap.values()) {
          provider.dispose();
          for (let view of this.treeViews.get(provider)) {
            view.dispose();
          }
        }
        this.providersMap.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/symbols/index.ts
var import_vscode_languageserver_protocol104, Symbols2;
var init_symbols2 = __esm({
  "src/handler/symbols/index.ts"() {
    import_vscode_languageserver_protocol104 = __toModule(require_main2());
    init_events();
    init_languages();
    init_util();
    init_object();
    init_position();
    init_window();
    init_workspace();
    init_buffer6();
    init_outline2();
    init_util5();
    Symbols2 = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.buffers = workspace_default.registerBufferSync((doc) => {
          if (doc.buftype != "")
            return void 0;
          return new SymbolsBuffer(doc.bufnr);
        });
        this.outline = new SymbolsOutline(nvim, this.buffers, handler);
        events_default.on("CursorHold", async (bufnr) => {
          if (!this.functionUpdate || !this.buffers.getItem(bufnr))
            return;
          await this.getCurrentFunctionSymbol(bufnr);
        }, null, this.disposables);
        events_default.on("InsertEnter", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf)
            buf.cancel();
        }, null, this.disposables);
      }
      get functionUpdate() {
        let config = workspace_default.getConfiguration("coc.preferences");
        return config.get("currentFunctionSymbolAutoUpdate", false);
      }
      get labels() {
        return workspace_default.getConfiguration("suggest").get("completionItemKindLabels", {});
      }
      async getWorkspaceSymbols(input) {
        this.handler.checkProvier("workspaceSymbols", null);
        let tokenSource = new import_vscode_languageserver_protocol104.CancellationTokenSource();
        return await languages_default.getWorkspaceSymbols(input, tokenSource.token);
      }
      async resolveWorkspaceSymbol(symbolInfo) {
        var _a2;
        if ((_a2 = symbolInfo.location) == null ? void 0 : _a2.uri)
          return symbolInfo;
        let tokenSource = new import_vscode_languageserver_protocol104.CancellationTokenSource();
        return await languages_default.resolveWorkspaceSymbol(symbolInfo, tokenSource.token);
      }
      async getDocumentSymbols(bufnr) {
        let buf = this.buffers.getItem(bufnr);
        if (!buf)
          return;
        let res = await buf.getSymbols();
        return res ? convertSymbols(res) : void 0;
      }
      async getCurrentFunctionSymbol(bufnr) {
        if (!bufnr)
          bufnr = await this.nvim.call("bufnr", ["%"]);
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached)
          return;
        if (!languages_default.hasProvider("documentSymbol", doc.textDocument))
          return;
        let position = await window_default.getCursorPosition();
        let symbols = await this.getDocumentSymbols(bufnr);
        let buffer = this.nvim.createBuffer(bufnr);
        if (!symbols || symbols.length === 0) {
          buffer.setVar("coc_current_function", "", true);
          this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
          return "";
        }
        symbols = symbols.filter((s) => [
          "Class",
          "Method",
          "Function",
          "Struct"
        ].includes(s.kind));
        let functionName = "";
        for (let sym of symbols.reverse()) {
          if (sym.range && positionInRange(position, sym.range) == 0 && !sym.text.endsWith(") callback")) {
            functionName = sym.text;
            let label = this.labels[sym.kind.toLowerCase()];
            if (label)
              functionName = `${label} ${functionName}`;
            break;
          }
        }
        if (this.functionUpdate) {
          buffer.setVar("coc_current_function", functionName, true);
          this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
        }
        return functionName;
      }
      async selectSymbolRange(inner, visualmode, supportedSymbols) {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvier("documentSymbol", doc.textDocument);
        let range;
        if (visualmode) {
          range = await workspace_default.getSelectedRange(visualmode, doc);
        } else {
          let pos = await window_default.getCursorPosition();
          range = import_vscode_languageserver_protocol104.Range.create(pos, pos);
        }
        let symbols = await this.getDocumentSymbols(doc.bufnr);
        if (!symbols || symbols.length === 0) {
          window_default.showMessage("No symbols found", "warning");
          return;
        }
        symbols = symbols.filter((s) => supportedSymbols.includes(s.kind));
        let selectRange;
        for (let sym of symbols.reverse()) {
          if (sym.range && !equals(sym.range, range) && rangeInRange(range, sym.range)) {
            selectRange = sym.range;
            break;
          }
        }
        if (inner && selectRange) {
          let { start, end } = selectRange;
          let line = doc.getline(start.line + 1);
          let endLine = doc.getline(end.line - 1);
          selectRange = import_vscode_languageserver_protocol104.Range.create(start.line + 1, line.match(/^\s*/)[0].length, end.line - 1, endLine.length);
        }
        if (selectRange) {
          await workspace_default.selectRange(selectRange);
        } else if (["v", "V", ""].includes(visualmode)) {
          await this.nvim.command("normal! gv");
        }
      }
      async showOutline(keep) {
        await this.outline.show(keep);
      }
      async hideOutline() {
        await this.outline.hide();
      }
      hasOutline(bufnr) {
        return this.outline.has(bufnr);
      }
      dispose() {
        this.outline.dispose();
        this.buffers.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/index.ts
var import_vscode_languageserver_protocol105, logger109, Handler;
var init_handler = __esm({
  "src/handler/index.ts"() {
    import_vscode_languageserver_protocol105 = __toModule(require_main2());
    init_events();
    init_languages();
    init_util();
    init_window();
    init_workspace();
    init_codeActions();
    init_codelens();
    init_colors();
    init_commands3();
    init_fold();
    init_format2();
    init_highlights();
    init_hover();
    init_links2();
    init_locations();
    init_refactor();
    init_rename();
    init_selectionRange2();
    init_callHierarchy2();
    init_semanticTokensHighlights();
    init_signature();
    init_symbols2();
    init_convert();
    logger109 = require_logger2()("Handler");
    Handler = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        this.requestStatusItem = window_default.createStatusBarItem(0, { progress: true });
        events_default.on(["CursorMoved", "CursorMovedI", "InsertEnter", "InsertSnippet", "InsertLeave"], () => {
          if (this.requestTokenSource) {
            this.requestTokenSource.cancel();
            this.requestTokenSource = null;
          }
        }, null, this.disposables);
        this.labels = workspace_default.getConfiguration("suggest").get("completionItemKindLabels", {});
        this.fold = new FoldHandler(nvim, this);
        this.links = new Links(nvim, this);
        this.codeLens = new CodeLensManager2(nvim);
        this.colors = new Colors(nvim, this);
        this.format = new FormatHandler(nvim, this);
        this.symbols = new Symbols2(nvim, this);
        this.refactor = new Refactor(nvim, this);
        this.hover = new HoverHandler(nvim, this);
        this.locations = new LocationsHandler(nvim, this);
        this.signature = new Signature(nvim, this);
        this.rename = new Rename(nvim, this);
        this.codeActions = new CodeActions(nvim, this);
        this.commands = new Commands(nvim, workspace_default.env);
        this.callHierarchy = new CallHierarchyHandler(nvim, this);
        this.documentHighlighter = new Highlights(nvim, this);
        this.semanticHighlighter = new SemanticTokensHighlights(nvim, this);
        this.selectionRange = new SelectionRangeHandler(nvim, this);
        this.disposables.push({
          dispose: () => {
            this.callHierarchy.dispose();
            this.codeLens.dispose();
            this.refactor.dispose();
            this.signature.dispose();
            this.symbols.dispose();
            this.hover.dispose();
            this.locations.dispose();
            this.colors.dispose();
            this.documentHighlighter.dispose();
            this.semanticHighlighter.dispose();
          }
        });
      }
      async getCurrentState() {
        let { nvim } = this;
        let [bufnr, [line, character], winid, mode] = await nvim.eval("[bufnr('%'),coc#cursor#position(),win_getid(),mode()]");
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached)
          throw new Error(`current buffer ${bufnr} not attached`);
        return {
          doc,
          mode,
          position: import_vscode_languageserver_protocol105.Position.create(line, character),
          winid
        };
      }
      addDisposable(disposable) {
        this.disposables.push(disposable);
      }
      checkProvier(id, document2) {
        if (!languages_default.hasProvider(id, document2)) {
          throw new Error(`${id} provider not found for current buffer, your language server doesn't support it.`);
        }
      }
      async withRequestToken(name2, fn, checkEmpty) {
        if (this.requestTokenSource) {
          this.requestTokenSource.cancel();
          this.requestTokenSource.dispose();
        }
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
        }
        let statusItem = this.requestStatusItem;
        this.requestTokenSource = new import_vscode_languageserver_protocol105.CancellationTokenSource();
        let { token } = this.requestTokenSource;
        token.onCancellationRequested(() => {
          statusItem.text = `${name2} request canceled`;
          statusItem.isProgress = false;
          this.requestTimer = setTimeout(() => {
            statusItem.hide();
          }, 500);
        });
        statusItem.isProgress = true;
        statusItem.text = `requesting ${name2}`;
        statusItem.show();
        let res;
        try {
          res = await Promise.resolve(fn(token));
        } catch (e) {
          window_default.showMessage(e.message, "error");
          logger109.error(`Error on ${name2}`, e);
        }
        if (this.requestTokenSource) {
          this.requestTokenSource.dispose();
          this.requestTokenSource = void 0;
        }
        if (token.isCancellationRequested)
          return null;
        statusItem.hide();
        if (checkEmpty && (!res || Array.isArray(res) && res.length == 0)) {
          window_default.showMessage(`${name2} not found`, "warning");
          return null;
        }
        return res;
      }
      getIcon(kind) {
        let { labels } = this;
        let kindText = getSymbolKind(kind);
        let defaultIcon = typeof labels["default"] === "string" ? labels["default"] : kindText[0].toLowerCase();
        let text = kindText == "Unknown" ? "" : labels[kindText[0].toLowerCase() + kindText.slice(1)];
        if (!text || typeof text !== "string")
          text = defaultIcon;
        return {
          text,
          hlGroup: kindText == "Unknown" ? "CocSymbolDefault" : `CocSymbol${kindText}`
        };
      }
      async getCodeActions(doc, range, only) {
        return await this.codeActions.getCodeActions(doc, range, only);
      }
      async applyCodeAction(action) {
        await this.codeActions.applyCodeAction(action);
      }
      async hasProvider(id) {
        let bufnr = await this.nvim.call("bufnr", "%");
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return false;
        return languages_default.hasProvider(id, doc.textDocument);
      }
      dispose() {
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
        }
        disposeAll(this.disposables);
      }
    };
  }
});

// src/plugin.ts
var import_events43, import_fs37, import_path37, import_vscode_languageserver_protocol106, logger110, Plugin;
var init_plugin = __esm({
  "src/plugin.ts"() {
    import_events43 = __toModule(require("events"));
    import_fs37 = __toModule(require("fs"));
    import_path37 = __toModule(require("path"));
    import_vscode_languageserver_protocol106 = __toModule(require_main2());
    init_esm2();
    init_commands2();
    init_completion();
    init_cursors();
    init_manager();
    init_events();
    init_extensions2();
    init_handler();
    init_manager3();
    init_services();
    init_manager4();
    init_sources2();
    init_types();
    init_window();
    init_workspace();
    logger110 = require_logger2()("plugin");
    Plugin = class extends import_events43.EventEmitter {
      constructor(nvim) {
        super();
        this.nvim = nvim;
        this._ready = false;
        this.actions = new Map();
        Object.defineProperty(workspace_default, "nvim", {
          get: () => this.nvim
        });
        workspace_default.onDidChangeWorkspaceFolders(() => {
          nvim.setVar("WorkspaceFolders", workspace_default.folderPaths, true);
        });
        this.cursors = new Cursors(nvim);
        commands_default.init(nvim, this);
        this.addAction("checkJsonExtension", () => {
          if (extensions_default.has("coc-json"))
            return;
          window_default.showMessage(`Run :CocInstall coc-json for json intellisense`, "more");
        });
        this.addAction("rootPatterns", (bufnr) => {
          let doc = workspace_default.getDocument(bufnr);
          if (!doc)
            return null;
          return {
            buffer: workspace_default.getRootPatterns(doc, PatternType.Buffer),
            server: workspace_default.getRootPatterns(doc, PatternType.LanguageServer),
            global: workspace_default.getRootPatterns(doc, PatternType.Global)
          };
        });
        this.addAction("getConfig", async (key) => {
          let document2 = await workspace_default.document;
          return workspace_default.getConfiguration(key, document2 ? document2.uri : void 0);
        });
        this.addAction("doAutocmd", async (id, ...args) => {
          let autocmd = workspace_default.autocmds.get(id);
          if (autocmd) {
            try {
              await Promise.resolve(autocmd.callback.apply(autocmd.thisArg, args));
            } catch (e) {
              logger110.error(`Error on autocmd ${autocmd.event}`, e);
              window_default.showMessage(`Error on autocmd ${autocmd.event}: ${e.message}`);
            }
          }
        });
        this.addAction("openLog", async () => {
          let file = logger110.getLogFile();
          await workspace_default.jumpTo(URI.file(file).toString());
        });
        this.addAction("attach", () => workspace_default.attach());
        this.addAction("detach", () => workspace_default.detach());
        this.addAction("doKeymap", async (key, defaultReturn = "", pressed) => {
          let keymap = workspace_default.keymaps.get(key);
          if (!keymap) {
            logger110.error(`keymap for ${key} not found`);
            this.nvim.command(`silent! unmap <buffer> ${pressed.startsWith("{") && pressed.endsWith("}") ? `<${pressed.slice(1, -1)}>` : pressed}`, true);
            return defaultReturn;
          }
          let [fn, repeat2] = keymap;
          let res = await Promise.resolve(fn());
          if (repeat2)
            await nvim.command(`silent! call repeat#set("\\<Plug>(coc-${key})", -1)`);
          return res != null ? res : defaultReturn;
        });
        this.addAction("registExtensions", async (...folders) => {
          for (let folder of folders) {
            await extensions_default.loadExtension(folder);
          }
        });
        this.addAction("snippetCheck", async (checkExpand, checkJump) => {
          if (checkExpand && !extensions_default.has("coc-snippets")) {
            console.error("coc-snippets required for check expand status!");
            return false;
          }
          if (checkJump) {
            let jumpable = manager_default3.jumpable();
            if (jumpable)
              return true;
          }
          if (checkExpand) {
            let api = extensions_default.getExtensionApi("coc-snippets");
            if (api && api.hasOwnProperty("expandable")) {
              let expandable = await Promise.resolve(api.expandable());
              if (expandable)
                return true;
            }
          }
          return false;
        });
        this.addAction("snippetNext", () => manager_default3.nextPlaceholder());
        this.addAction("snippetPrev", () => manager_default3.previousPlaceholder());
        this.addAction("snippetCancel", () => manager_default3.cancel());
        this.addAction("openLocalConfig", () => window_default.openLocalConfig());
        this.addAction("showInfo", async () => {
          if (!this.infoChannel) {
            this.infoChannel = window_default.createOutputChannel("info");
          } else {
            this.infoChannel.clear();
          }
          let channel = this.infoChannel;
          channel.appendLine("## versions");
          channel.appendLine("");
          let out = await this.nvim.call("execute", ["version"]);
          let first = out.trim().split(/\r?\n/, 2)[0].replace(/\(.*\)/, "").trim();
          channel.appendLine("vim version: " + first + `${workspace_default.isVim ? " " + workspace_default.env.version : ""}`);
          channel.appendLine("node version: " + process.version);
          channel.appendLine("coc.nvim version: " + this.version);
          channel.appendLine("coc.nvim directory: " + import_path37.default.dirname(__dirname));
          channel.appendLine("term: " + (process.env.TERM_PROGRAM || process.env.TERM));
          channel.appendLine("platform: " + process.platform);
          channel.appendLine("");
          channel.appendLine("## Log of coc.nvim");
          channel.appendLine("");
          let file = logger110.getLogFile();
          if (import_fs37.default.existsSync(file)) {
            let content = import_fs37.default.readFileSync(file, { encoding: "utf8" });
            channel.appendLine(content);
          }
          channel.show();
        });
        this.addAction("findLocations", (id, method, params, openCommand) => {
          return this.handler.locations.findLocations(id, method, params, openCommand);
        });
        this.addAction("hasProvider", (id) => this.handler.hasProvider(id));
        this.addAction("getTagList", () => this.handler.locations.getTagList());
        this.addAction("hasSelected", () => completion_default.hasSelected());
        this.addAction("listNames", () => manager_default2.names);
        this.addAction("listDescriptions", () => manager_default2.descriptions);
        this.addAction("listLoadItems", (name2) => manager_default2.loadItems(name2));
        this.addAction("search", (...args) => this.handler.refactor.search(args));
        this.addAction("cursorsSelect", (bufnr, kind, mode) => this.cursors.select(bufnr, kind, mode));
        this.addAction("fillDiagnostics", (bufnr) => manager_default.setLocationlist(bufnr));
        this.addAction("saveRefactor", (bufnr) => this.handler.refactor.save(bufnr));
        this.addAction("commandList", () => this.handler.commands.getCommandList());
        this.addAction("selectSymbolRange", (inner, visualmode, supportedSymbols) => this.handler.symbols.selectSymbolRange(inner, visualmode, supportedSymbols));
        this.addAction("openList", (...args) => manager_default2.start(args));
        this.addAction("listResume", (name2) => manager_default2.resume(name2));
        this.addAction("listCancel", () => manager_default2.cancel(true));
        this.addAction("listPrev", (name2) => manager_default2.previous(name2));
        this.addAction("listNext", (name2) => manager_default2.next(name2));
        this.addAction("listFirst", (name2) => manager_default2.first(name2));
        this.addAction("listLast", (name2) => manager_default2.last(name2));
        this.addAction("sendRequest", (id, method, params) => services_default.sendRequest(id, method, params));
        this.addAction("sendNotification", (id, method, params) => services_default.sendNotification(id, method, params));
        this.addAction("registNotification", (id, method) => services_default.registNotification(id, method));
        this.addAction("updateConfig", (section2, val) => workspace_default.configurations.updateUserConfig({ [section2]: val }));
        this.addAction("links", () => this.handler.links.getLinks());
        this.addAction("openLink", () => this.handler.links.openCurrentLink());
        this.addAction("pickColor", () => this.handler.colors.pickColor());
        this.addAction("colorPresentation", () => this.handler.colors.pickPresentation());
        this.addAction("highlight", () => this.handler.documentHighlighter.highlight());
        this.addAction("fold", (kind) => this.handler.fold.fold(kind));
        this.addAction("startCompletion", (option) => completion_default.startCompletion(option));
        this.addAction("stopCompletion", () => completion_default.stop(false));
        this.addAction("sourceStat", () => sources_default.sourceStats());
        this.addAction("refreshSource", (name2) => sources_default.refresh(name2));
        this.addAction("toggleSource", (name2) => sources_default.toggleSource(name2));
        this.addAction("diagnosticRefresh", (bufnr) => manager_default.refresh(bufnr));
        this.addAction("diagnosticInfo", () => manager_default.echoMessage());
        this.addAction("diagnosticToggle", () => manager_default.toggleDiagnostic());
        this.addAction("diagnosticToggleBuffer", async (bufnr) => {
          if (!bufnr)
            bufnr = await nvim.call("bufnr", ["%"]);
          return manager_default.toggleDiagnosticBuffer(bufnr);
        });
        this.addAction("diagnosticNext", (severity) => manager_default.jumpNext(severity));
        this.addAction("diagnosticPrevious", (severity) => manager_default.jumpPrevious(severity));
        this.addAction("diagnosticPreview", () => manager_default.preview());
        this.addAction("diagnosticList", () => manager_default.getDiagnosticList());
        this.addAction("jumpDefinition", (openCommand) => this.handler.locations.gotoDefinition(openCommand));
        this.addAction("definitions", () => this.handler.locations.definitions());
        this.addAction("jumpDeclaration", (openCommand) => this.handler.locations.gotoDeclaration(openCommand));
        this.addAction("declarations", () => this.handler.locations.declarations());
        this.addAction("jumpImplementation", (openCommand) => this.handler.locations.gotoImplementation(openCommand));
        this.addAction("implementations", () => this.handler.locations.implementations());
        this.addAction("jumpTypeDefinition", (openCommand) => this.handler.locations.gotoTypeDefinition(openCommand));
        this.addAction("typeDefinitions", () => this.handler.locations.typeDefinitions());
        this.addAction("jumpReferences", (openCommand) => this.handler.locations.gotoReferences(openCommand));
        this.addAction("references", () => this.handler.locations.references());
        this.addAction("jumpUsed", (openCommand) => this.handler.locations.gotoReferences(openCommand, false));
        this.addAction("doHover", (hoverTarget) => this.handler.hover.onHover(hoverTarget));
        this.addAction("definitionHover", (hoverTarget) => this.handler.hover.definitionHover(hoverTarget));
        this.addAction("getHover", () => this.handler.hover.getHover());
        this.addAction("showSignatureHelp", () => this.handler.signature.triggerSignatureHelp());
        this.addAction("documentSymbols", async (bufnr) => {
          if (!bufnr) {
            let doc = await workspace_default.document;
            bufnr = doc.bufnr;
          }
          return await this.handler.symbols.getDocumentSymbols(bufnr);
        });
        this.addAction("ensureDocument", async () => {
          let doc = await workspace_default.document;
          return doc && doc.attached;
        });
        this.addAction("symbolRanges", () => this.handler.documentHighlighter.getSymbolsRanges());
        this.addAction("selectionRanges", () => this.handler.selectionRange.getSelectionRanges());
        this.addAction("rangeSelect", (visualmode, forward) => this.handler.selectionRange.selectRange(visualmode, forward));
        this.addAction("rename", (newName) => this.handler.rename.rename(newName));
        this.addAction("getWorkspaceSymbols", (input) => this.handler.symbols.getWorkspaceSymbols(input));
        this.addAction("resolveWorkspaceSymbol", (symbolInfo) => this.handler.symbols.resolveWorkspaceSymbol(symbolInfo));
        this.addAction("formatSelected", (mode) => this.handler.format.formatCurrentRange(mode));
        this.addAction("format", () => this.handler.format.formatCurrentBuffer());
        this.addAction("commands", () => this.handler.commands.getCommands());
        this.addAction("services", () => services_default.getServiceStats());
        this.addAction("toggleService", (name2) => services_default.toggle(name2));
        this.addAction("codeAction", (mode, only) => this.handler.codeActions.doCodeAction(mode, only));
        this.addAction("organizeImport", () => this.handler.codeActions.organizeImport());
        this.addAction("fixAll", () => this.handler.codeActions.doCodeAction(null, [import_vscode_languageserver_protocol106.CodeActionKind.SourceFixAll]));
        let codeActions = [];
        this.addAction("doCodeAction", (codeAction) => {
          if (codeAction.index == null) {
            throw new Error(`index should exists with codeAction`);
          }
          let action = codeActions[codeAction.index];
          if (!action)
            throw new Error(`invalid codeAction index: ${codeAction.index}`);
          return this.handler.codeActions.applyCodeAction(action);
        });
        this.addAction("codeActions", async (mode, only) => {
          codeActions = await this.handler.codeActions.getCurrentCodeActions(mode, only);
          return codeActions.map((o, idx) => Object.assign({ index: idx }, o));
        });
        this.addAction("quickfixes", async (mode) => {
          codeActions = await this.handler.codeActions.getCurrentCodeActions(mode, [import_vscode_languageserver_protocol106.CodeActionKind.QuickFix]);
          return codeActions.map((o, idx) => Object.assign({ index: idx }, o));
        });
        this.addAction("codeLensAction", () => this.handler.codeLens.doAction());
        this.addAction("runCommand", (...args) => this.handler.commands.runCommand(...args));
        this.addAction("doQuickfix", () => this.handler.codeActions.doQuickfix());
        this.addAction("refactor", () => this.handler.refactor.doRefactor());
        this.addAction("repeatCommand", () => this.handler.commands.repeat());
        this.addAction("installExtensions", (...list2) => extensions_default.installExtensions(list2));
        this.addAction("updateExtensions", (sync) => extensions_default.updateExtensions(sync));
        this.addAction("extensionStats", () => extensions_default.getExtensionStates());
        this.addAction("loadedExtensions", () => extensions_default.loadedExtensions());
        this.addAction("watchExtension", (id) => extensions_default.watchExtension(id));
        this.addAction("activeExtension", (name2) => extensions_default.activate(name2));
        this.addAction("deactivateExtension", (name2) => extensions_default.deactivate(name2));
        this.addAction("reloadExtension", (name2) => extensions_default.reloadExtension(name2));
        this.addAction("toggleExtension", (name2) => extensions_default.toggleExtension(name2));
        this.addAction("uninstallExtension", (...args) => extensions_default.uninstallExtension(args));
        this.addAction("getCurrentFunctionSymbol", () => this.handler.symbols.getCurrentFunctionSymbol());
        this.addAction("showOutline", (keep) => this.handler.symbols.showOutline(keep));
        this.addAction("hideOutline", () => this.handler.symbols.hideOutline());
        this.addAction("getWordEdit", () => this.handler.rename.getWordEdit());
        this.addAction("addCommand", (cmd) => this.handler.commands.addVimCommand(cmd));
        this.addAction("addRanges", (ranges) => this.cursors.addRanges(ranges));
        this.addAction("currentWorkspacePath", () => workspace_default.rootPath);
        this.addAction("selectCurrentPlaceholder", (triggerAutocmd) => manager_default3.selectCurrentPlaceholder(!!triggerAutocmd));
        this.addAction("codeActionRange", (start, end, only) => this.handler.codeActions.codeActionRange(start, end, only));
        this.addAction("incomingCalls", (item) => this.handler.callHierarchy.getIncoming(item));
        this.addAction("outgoingCalls", (item) => this.handler.callHierarchy.getOutgoing(item));
        this.addAction("showIncomingCalls", () => this.handler.callHierarchy.showCallHierarchyTree("incoming"));
        this.addAction("showOutgoingCalls", () => this.handler.callHierarchy.showCallHierarchyTree("outgoing"));
        this.addAction("semanticHighlight", () => this.handler.semanticHighlighter.highlightCurrent());
        this.addAction("showSemanticHighlightInfo", () => this.handler.semanticHighlighter.showHiglightInfo());
      }
      addAction(key, fn) {
        if (this.actions.has(key)) {
          throw new Error(`Action ${key} already exists`);
        }
        this.actions.set(key, fn);
      }
      async init() {
        let { nvim } = this;
        let s = Date.now();
        try {
          await extensions_default.init();
          await workspace_default.init();
          manager_default3.init();
          completion_default.init();
          manager_default.init();
          manager_default2.init(nvim);
          sources_default.init();
          this.handler = new Handler(nvim);
          services_default.init();
          extensions_default.activateExtensions();
          workspace_default.setupDynamicAutocmd(true);
          nvim.pauseNotification();
          nvim.setVar("WorkspaceFolders", workspace_default.folderPaths, true);
          nvim.setVar("coc_service_initialized", 1, true);
          nvim.call("coc#util#do_autocmd", ["CocNvimInit"], true);
          nvim.resumeNotification(false, true);
          this._ready = true;
          await events_default.fire("ready", []);
          logger110.info(`coc.nvim ${this.version} initialized with node: ${process.version} after ${Date.now() - s}ms`);
          this.emit("ready");
        } catch (e) {
          nvim.echoError(e);
        }
      }
      get isReady() {
        return this._ready;
      }
      get ready() {
        if (this._ready)
          return Promise.resolve();
        return new Promise((resolve3) => {
          this.once("ready", () => {
            resolve3();
          });
        });
      }
      get version() {
        return workspace_default.version + (true ? "-f021999eb2" : "");
      }
      hasAction(method) {
        return this.actions.has(method);
      }
      async cocAction(method, ...args) {
        let fn = this.actions.get(method);
        if (!fn)
          throw new Error(`Action "${method}" not exists`);
        let ts = Date.now();
        let res = await Promise.resolve(fn.apply(null, args));
        let dt = Date.now() - ts;
        if (dt > 500)
          logger110.warn(`Slow action "${method}" cost ${dt}ms`);
        return res;
      }
      getHandler() {
        return this.handler;
      }
      dispose() {
        this.removeAllListeners();
        extensions_default.dispose();
        manager_default2.dispose();
        workspace_default.dispose();
        window_default.dispose();
        sources_default.dispose();
        services_default.stopAll();
        services_default.dispose();
        if (this.handler) {
          this.handler.dispose();
        }
        manager_default3.dispose();
        commands_default.dispose();
        completion_default.dispose();
        manager_default.dispose();
      }
    };
  }
});

// src/attach.ts
var attach_exports = {};
__export(attach_exports, {
  default: () => attach_default
});
var import_neovim2, import_log4js, import_semver3, logger111, isTest, ACTIONS_NO_WAIT, attach_default;
var init_attach = __esm({
  "src/attach.ts"() {
    import_neovim2 = __toModule(require_lib6());
    import_log4js = __toModule(require_log4js());
    init_events();
    init_plugin();
    import_semver3 = __toModule(require_semver2());
    init_is();
    init_esm2();
    init_package();
    logger111 = require_logger2()("attach");
    isTest = global.hasOwnProperty("__TEST__");
    ACTIONS_NO_WAIT = ["installExtensions", "updateExtensions"];
    attach_default = (opts, requestApi = true) => {
      const nvim = (0, import_neovim2.attach)(opts, import_log4js.default.getLogger("node-client"), requestApi);
      if (!global.hasOwnProperty("__TEST__")) {
        nvim.call("coc#util#path_replace_patterns").then((prefixes) => {
          if (objectLiteral(prefixes)) {
            const old_uri = URI.file;
            URI.file = (path36) => {
              path36 = path36.replace(/\\/g, "/");
              Object.keys(prefixes).forEach((k) => path36 = path36.replace(new RegExp("^" + k), prefixes[k]));
              return old_uri(path36);
            };
          }
        }).logError();
      }
      nvim.setVar("coc_process_pid", process.pid, true);
      const plugin = new Plugin(nvim);
      let clientReady = false;
      let initialized = false;
      nvim.on("notification", async (method, args) => {
        switch (method) {
          case "VimEnter": {
            if (!initialized && clientReady) {
              initialized = true;
              await plugin.init();
            }
            break;
          }
          case "Log": {
            logger111.debug(...args);
            break;
          }
          case "TaskExit":
          case "TaskStderr":
          case "TaskStdout":
          case "GlobalChange":
          case "PromptInsert":
          case "InputChar":
          case "MenuInput":
          case "OptionSet":
          case "FloatBtnClick":
            await events_default.fire(method, args);
            break;
          case "CocAutocmd":
            logger111.trace("Notification autocmd:", ...args);
            await events_default.fire(args[0], args.slice(1));
            break;
          default: {
            let exists = plugin.hasAction(method);
            if (!exists) {
              if (global.hasOwnProperty("__TEST__"))
                return;
              console.error(`action "${method}" not exists`);
              return;
            }
            try {
              if (!plugin.isReady) {
                logger111.warn(`Plugin not ready when received "${method}"`, args);
              } else {
                logger111.info("receive notification:", method, args);
              }
              await plugin.ready;
              await plugin.cocAction(method, ...args);
            } catch (e) {
              console.error(`Error on "${method}": ${e.message || e.toString()}`);
              logger111.error(`Notification error:`, method, args, e);
            }
          }
        }
      });
      nvim.on("request", async (method, args, resp) => {
        if (method == "redraw") {
          resp.send();
          return;
        }
        let timer = setTimeout(() => {
          logger111.error("Request cost more than 3s", method, args);
        }, 3e3);
        try {
          if (method == "CocAutocmd") {
            logger111.trace("Request autocmd:", ...args);
            await events_default.fire(args[0], args.slice(1));
            resp.send(void 0);
          } else {
            if (!plugin.isReady && !ACTIONS_NO_WAIT.includes(method)) {
              logger111.warn(`Plugin not ready on request "${method}"`, args);
              resp.send("Plugin not ready", true);
              return;
            }
            logger111.info("Request action:", method, args);
            let res = await plugin.cocAction(method, ...args);
            resp.send(res);
          }
          clearTimeout(timer);
        } catch (e) {
          clearTimeout(timer);
          resp.send(e.message || e.toString(), true);
          logger111.error(`Request error:`, method, args, e);
        }
      });
      nvim.channelId.then(async (channelId) => {
        clientReady = true;
        if (isTest)
          nvim.command(`let g:coc_node_channel_id = ${channelId}`, true);
        let { major, minor, patch } = import_semver3.default.parse(version);
        nvim.setClientInfo("coc", { major, minor, patch }, "remote", {}, {});
        let entered = await nvim.getVvar("vim_did_enter");
        if (entered && !initialized) {
          initialized = true;
          await plugin.init();
        }
      }).catch((e) => {
        console.error(`Channel create error: ${e.message}`);
      });
      return plugin;
    };
  }
});

// src/main.ts
require_extensions();
Object.defineProperty(console, "log", {
  value() {
    logger112.info(...arguments);
  }
});
var logger112 = require_logger2()("server");
var attach2 = (init_attach(), attach_exports).default;
attach2({ reader: process.stdin, writer: process.stdout });
process.on("uncaughtException", function(err) {
  let msg = "Uncaught exception: " + err.message;
  console.error(msg);
  logger112.error("uncaughtException", err.stack);
});
process.on("unhandledRejection", function(reason, p) {
  if (reason instanceof Error) {
    console.error("UnhandledRejection: " + reason.message + "\n" + reason.stack);
  } else {
    console.error("UnhandledRejection: " + reason);
  }
  logger112.error("unhandledRejection ", p, reason);
});
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/*!
 * ISC License
 *
 * Copyright (c) 2018, Andrea Giammarchi, @WebReflection
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
 *
 * @copyright Yusuke Kawasaki
 * @license MIT
 * @constructor
 * @see https://github.com/kawanet/event-lite
 * @see http://kawanet.github.io/event-lite/EventLite.html
 * @example
 * var EventLite = require("event-lite");
 *
 * function MyClass() {...}             // your class
 *
 * EventLite.mixin(MyClass.prototype);  // import event methods
 *
 * var obj = new MyClass();
 * obj.on("foo", function() {...});     // add event listener
 * obj.once("bar", function() {...});   // add one-time event listener
 * obj.emit("foo");                     // dispatch event
 * obj.emit("bar");                     // dispatch another event
 * obj.off("foo");                      // remove event listener
 */
