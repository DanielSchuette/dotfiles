     disables Horizontal Scroll Bar mode at startup (*note Scroll
     Bars::).

'iconName' (class 'Title')
     Name to display in the icon.

'internalBorder' (class 'BorderWidth')
     Width of the internal frame border, in pixels.

'lineSpacing' (class 'LineSpacing')
     Additional space between lines, in pixels.

'menuBackground' (class 'Background')
     The background color of the menus in non-toolkit versions of Emacs.
     (For toolkit versions, see *note Lucid Resources::, also see *note
     Motif Resources::, and see *note GTK resources::.)

'menuBar' (class 'MenuBar')
     If the value of this resource is 'off' or 'false' or '0', Emacs
     disables Menu Bar mode at startup (*note Menu Bars::).

'minibuffer' (class 'Minibuffer')
     If 'none', Emacs will not make a minibuffer in this frame; it will
     use a separate minibuffer frame instead.

'paneFont' (class 'Font')
     Font name for menu pane titles, in non-toolkit versions of Emacs.
     (For toolkit versions, see *note Lucid Resources::, also see *note
     Motif Resources::, and see *note GTK resources::.)

'paneForeground' (class 'Foreground')
     Foreground color for menu pane titles, in non-toolkit versions of
     Emacs.  (For toolkit versions, see *note Lucid Resources::, also
     see *note Motif Resources::, and see *note GTK resources::.)

'pointerColor' (class 'Foreground')
     Color of the mouse cursor.  This has no effect in many graphical
     desktop environments, as they do not let Emacs change the mouse
     cursor this way.

'privateColormap' (class 'PrivateColormap')
     If 'on', use a private color map, in the case where the default
     visual of class PseudoColor and Emacs is using it.

'reverseVideo' (class 'ReverseVideo')
     Switch foreground and background default colors if 'on', use colors
     as specified if 'off'.

'screenGamma' (class 'ScreenGamma')
     Gamma correction for colors, equivalent to the frame parameter
     'screen-gamma'.

'scrollBar' (class 'ScrollBar')
     If the value of this resource is 'off' or 'false' or '0', Emacs
     disables Scroll Bar mode at startup (*note Scroll Bars::).

'scrollBarWidth' (class 'ScrollBarWidth')
     The scroll bar width in pixels, equivalent to the frame parameter
     'scroll-bar-width'.  Do not set this resource if Emacs is compiled
     with GTK+ support.

'selectionFont' (class 'SelectionFont')
     Font name for pop-up menu items, in non-toolkit versions of Emacs.
     (For toolkit versions, see *note Lucid Resources::, also see *note
     Motif Resources::, and see *note GTK resources::.)

'selectionForeground' (class 'SelectionForeground')
     Foreground color for pop-up menu items, in non-toolkit versions of
     Emacs.  (For toolkit versions, see *note Lucid Resources::, also
     see *note Motif Resources::, and see *note GTK resources::.)

'selectionTimeout' (class 'SelectionTimeout')
     Number of milliseconds to wait for a selection reply.  If the
     selection owner doesn't reply in this time, we give up.  A value of
     0 means wait as long as necessary.

'synchronous' (class 'Synchronous')
     Run Emacs in synchronous mode if 'on'.  Synchronous mode is useful
     for debugging X problems.

'title' (class 'Title')
     Name to display in the title bar of the initial Emacs frame.

'toolBar' (class 'ToolBar')
     If the value of this resource is 'off' or 'false' or '0', Emacs
     disables Tool Bar mode at startup (*note Tool Bars::).

'tabBar' (class 'TabBar')
     If the value of this resource is 'on' or 'yes' or '1', Emacs
     enables Tab Bar mode at startup (*note Tab Bars::).

'useXIM' (class 'UseXIM')
     Disable use of X input methods (XIM) if 'false' or 'off'.  This is
     only relevant if your Emacs is built with XIM support.  It might be
     useful to turn off XIM on slow X client/server links.

'verticalScrollBars' (class 'ScrollBars')
     Give frames scroll bars on the left if 'left', on the right if
     'right'; don't have scroll bars if 'off' (*note Scroll Bars::).

'visualClass' (class 'VisualClass')
     The "visual class" for X color display.  If specified, the value
     should start with one of 'TrueColor', 'PseudoColor', 'DirectColor',
     'StaticColor', 'GrayScale', and 'StaticGray', followed by '-DEPTH',
     where DEPTH is the number of color planes.

   You can also use X resources to customize individual Emacs faces
(*note Faces::).  For example, setting the resource
'FACE.attributeForeground' is equivalent to customizing the 'foreground'
attribute of the face FACE.  However, we recommend customizing faces
from within Emacs, instead of using X resources.  *Note Face
Customization::.

==============================================================================
File: emacs.info,  Node: |Lucid_Resources|,  Next: |Motif_Resources|,  Prev: |Table_of_Resources|,  Up: |X_Resources|
==============================================================================

                                                               *Lucid_Resources*

D.3 Lucid Menu And Dialog X Resources
=====--------------------------------

If Emacs is compiled with the X toolkit support using Lucid widgets, you
can use X resources to customize the appearance of the menu bar (*note
Menu Bar::), pop-up menus, and dialog boxes (*note Dialog Boxes::).  The
resources for the menu bar fall in the 'pane.menubar' class (following,
as always, either the name of the Emacs executable or 'Emacs' for all
Emacs invocations).  The resources for the pop-up menu are in the
'menu*' class.  The resources for dialog boxes are in the 'dialog*'
class.

   For example, to display menu bar entries with the 'Courier-12' font
(*note Fonts::), write this:

     Emacs.pane.menubar.font: Courier-12

Lucid widgets can display multilingual text in your locale.  To enable
this, specify a 'fontSet' resource instead of a 'font' resource.  *Note
Fontsets::.  If both 'font' and 'fontSet' resources are specified, the
'fontSet' resource is used.

   Here is a list of resources for menu bars, pop-up menus, and dialogs:

'font'
     Font for menu item text.
'fontSet'
     Fontset for menu item text.
'background'
     Background color.
'buttonForeground'
     Foreground color for a selected item.
'foreground'
     Foreground color.
'horizontalSpacing'
     Horizontal spacing in pixels between items.  Default is 3.
'verticalSpacing'
     Vertical spacing in pixels between items.  Default is 2.
'arrowSpacing'
     Horizontal spacing between the arrow (which indicates a submenu)
     and the associated text.  Default is 10.
'shadowThickness'
     Thickness of shadow lines for 3D buttons, arrows, and other
     graphical elements.  Default is 1.
'margin'
     Margin of the menu bar, in characters.  Default is 1.

==============================================================================
File: emacs.info,  Node: |Motif_Resources|,  Next: |GTK_resources|,  Prev: |Lucid_Resources|,  Up: |X_Resources|
==============================================================================

                                                               *Motif_Resources*

D.4 Motif Menu X Resources
=====---------------------

If Emacs is compiled with the X toolkit support using Motif or LessTif
widgets, you can use X resources to customize the appearance of the menu
bar (*note Menu Bar::), pop-up menus, and dialog boxes (*note Dialog
Boxes::).  However, the resources are organized differently from Lucid
widgets.

   The resource names for the menu bar are in the 'pane.menubar' class,
and they must be specified in this form:

     Emacs.pane.menubar.SUBWIDGET.RESOURCE: VALUE

For pop-up menus, the resources are in the 'menu*' class, instead of
'pane.menubar'.  For dialog boxes, they are in 'dialog'.  In each case,
each individual menu string is a subwidget; the subwidget's name is the
same as the menu item string.  For example, the 'File' menu in the menu
bar is a subwidget named 'emacs.pane.menubar.File'.

   Typically, you want to specify the same resources for the whole menu
bar.  To do this, use '*' instead of a specific subwidget name.  For
example, to specify the font '8x16' for all menu bar items, including
submenus, write this:

     Emacs.pane.menubar.*.fontList: 8x16

   Each item in a submenu also has its own name for X resources; for
example, the 'File' submenu has an item named 'Save (current buffer)'.
A resource specification for a submenu item looks like this:

     Emacs.pane.menubar.popup_*.MENU.ITEM.RESOURCE: VALUE

For example, here's how to specify the font for the 'Save (current
buffer)' item:

     Emacs.pane.menubar.popup_*.File.Save (current buffer).fontList: 8x16

For an item in a second-level submenu, such as 'Complete Word' under
'Spell Checking' under 'Tools', the resource fits this template:

     Emacs.pane.menubar.popup_.popup_.MENU.RESOURCE: VALUE

For example,

     Emacs.pane.menubar.popup_.popup_.Spell Checking.Complete Word: VALUE

(This should be one long line.)

   If you want the submenu items to look different from the menu bar
itself, you must first specify the resource for all of them, then
override the value for submenus alone.  Here is an example:

     Emacs.pane.menubar.*.fontList: 9x18
     Emacs.pane.menubar.popup_*.fontList: 8x16

   To specify resources for the LessTif file-selection box, use 'fsb*',
like this:

     Emacs.fsb*.fontList: 8x16

   Here is a list of resources for LessTif menu bars and pop-up menus:

'armColor'
     The color to show in an armed button.
'fontList'
     The font to use.
'marginBottom'
'marginHeight'
'marginLeft'
'marginRight'
'marginTop'
'marginWidth'
     Amount of space to leave around the item, within the border.
'borderWidth'
     The width of the border around the menu item, on all sides.
'shadowThickness'
     The width of the border shadow.
'bottomShadowColor'
     The color for the border shadow, on the bottom and the right.
'topShadowColor'
     The color for the border shadow, on the top and the left.

==============================================================================
File: emacs.info,  Node: |GTK_resources|,  Prev: |Motif_Resources|,  Up: |X_Resources|
==============================================================================

                                                                 *GTK_resources*

D.5 GTK+ resources
=====-------------

If Emacs is compiled with GTK+ toolkit support, the simplest way to
customize its GTK+ widgets (e.g., menus, dialogs, tool bars and scroll
bars) is to choose an appropriate GTK+ theme, for example with the GNOME
theme selector.

   In GTK+ version 2, you can also use "GTK+ resources" to customize the
appearance of GTK+ widgets used by Emacs.  These resources are specified
in either the file '~/.emacs.d/gtkrc' (for Emacs-specific GTK+
resources), or '~/.gtkrc-2.0' (for general GTK+ resources).  We
recommend using '~/.emacs.d/gtkrc', since GTK+ seems to ignore
'~/.gtkrc-2.0' when running GConf with GNOME.  Note, however, that some
GTK+ themes may override customizations in '~/.emacs.d/gtkrc'; there is
nothing we can do about this.  GTK+ resources do not affect aspects of
Emacs unrelated to GTK+ widgets, such as fonts and colors in the main
Emacs window; those are governed by normal X resources (*note
Resources::).

   The following sections describe how to customize GTK+ resources for
Emacs.  For details about GTK+ resources, see the GTK+ API document at
<https://developer.gnome.org/gtk2/stable/gtk2-Resource-Files.html>.

   In GTK+ version 3, GTK+ resources have been replaced by a completely
different system.  The appearance of GTK+ widgets is now determined by
CSS-like style files: 'gtk-3.0/gtk.css' in the GTK+ installation
directory, and '~/.themes/THEME/gtk-3.0/gtk.css' for local style
settings (where THEME is the name of the current GTK+ theme).
Therefore, the description of GTK+ resources in this section does not
apply to GTK+ 3.  For details about the GTK+ 3 styling system, see
<https://developer.gnome.org/gtk3/3.0/GtkCssProvider.html>.

MENU

* |GTK_Resource_Basics|::   Basic usage of GTK+ resources.
* |GTK_Widget_Names|::      How GTK+ widgets are named.
* |GTK_Names_in_Emacs|::    GTK+ widgets used by Emacs.
* |GTK_styles|::            What can be customized in a GTK+ widget.

==============================================================================
File: emacs.info,  Node: |GTK_Resource_Basics|,  Next: |GTK_Widget_Names|,  Up: |GTK_resources|
==============================================================================

                                                           *GTK_Resource_Basics*

D.5.1 GTK+ Resource Basics
--------------------------

In a GTK+ 2 resource file (usually '~/.emacs.d/gtkrc'), the simplest
kind of a resource setting simply assigns a value to a variable.  For
example, putting the following line in the resource file changes the
font on all GTK+ widgets to 'courier-12':

     gtk-font-name = "courier 12"

Note that in this case the font name must be supplied as a GTK font
pattern (also called a "Pango font name"), not as a Fontconfig-style
font name or XLFD.  *Note Fonts::.

   To customize widgets you first define a "style", and then apply the
style to the widgets.  Here is an example that sets the font for menus
('#' characters indicate comments):

     # Define the style 'my_style'.
     style "my_style"
     {
       font_name = "helvetica bold 14"
     }

     # Specify that widget type 'emacs-menuitem' uses 'my_style'.
     widget "emacs-menuitem" style "my_style"

The widget name in this example contains wildcards, so the style is
applied to all widgets matching 'emacs-menuitem'.  The widgets are
named by the way they are contained, from the outer widget to the inner
widget.  Here is another example that applies 'my_style' specifically to
the Emacs menu bar:

     widget "Emacs.pane.menubar.*" style "my_style"

   Here is a more elaborate example, showing how to change the parts of
the scroll bar:

     style "scroll"
     {
       fg[NORMAL] = "red"     # Arrow color.
       bg[NORMAL] = "yellow"  # Thumb and background around arrow.
       bg[ACTIVE] = "blue"    # Trough color.
       bg[PRELIGHT] = "white" # Thumb color when the mouse is over it.
     }

     widget "verticalScrollBar" style "scroll"

==============================================================================
File: emacs.info,  Node: |GTK_Widget_Names|,  Next: |GTK_Names_in_Emacs|,  Prev: |GTK_Resource_Basics|,  Up: |GTK_resources|
==============================================================================

                                                              *GTK_Widget_Names*

D.5.2 GTK+ widget names
-----------------------

A GTK+ widget is specified by a "widget name" and a "widget class".  The
widget name refers to a specific widget (e.g., 'emacs-menuitem'), while
the widget class refers to a collection of similar widgets (e.g.,
'GtkMenuItem').  A widget always has a class, but need not have a name.

   "Absolute names" are sequences of widget names or widget classes,
corresponding to hierarchies of widgets embedded within other widgets.
For example, if a 'GtkWindow' named 'top' contains a 'GtkVBox' named
'box', which in turn contains a 'GtkMenuBar' called 'menubar', the
absolute class name of the menu-bar widget is
'GtkWindow.GtkVBox.GtkMenuBar', and its absolute widget name is
'top.box.menubar'.

   GTK+ resource files can contain two types of commands for specifying
widget appearances:

'widget'
     specifies a style for widgets based on the class name, or just the
     class.

'widget_class'
     specifies a style for widgets based on the class name.

See the previous subsection for examples of using the 'widget' command;
the 'widget_class' command is used similarly.  Note that the widget
name/class and the style must be enclosed in double-quotes, and these
commands must be at the top level in the GTK+ resource file.

   As previously noted, you may specify a widget name or class with
shell wildcard syntax: '*' matches zero or more characters and '?'
matches one character.  This example assigns a style to all widgets:

     widget "*" style "my_style"

==============================================================================
File: emacs.info,  Node: |GTK_Names_in_Emacs|,  Next: |GTK_styles|,  Prev: |GTK_Widget_Names|,  Up: |GTK_resources|
==============================================================================

                                                            *GTK_Names_in_Emacs*

D.5.3 GTK+ Widget Names in Emacs
--------------------------------

The GTK+ widgets used by an Emacs frame are listed below:

'Emacs' (class 'GtkWindow')
     'pane' (class 'GtkVBox')
          'menubar' (class 'GtkMenuBar')
               [menu item widgets]
          [unnamed widget] (class 'GtkHandleBox')
               'emacs-toolbar' (class 'GtkToolbar')
                    [tool bar item widgets]
          'emacs' (class 'GtkFixed')
               'verticalScrollBar' (class 'GtkVScrollbar')

The contents of Emacs windows are drawn in the 'emacs' widget.  Note
that even if there are multiple Emacs windows, each scroll bar widget is
named 'verticalScrollBar'.

   For example, here are two different ways to set the menu bar style:

     widget "Emacs.pane.menubar.*" style "my_style"
     widget_class "GtkWindow.GtkVBox.GtkMenuBar.*" style "my_style"

   For GTK+ dialogs, Emacs uses a widget named 'emacs-dialog', of class
'GtkDialog'.  For file selection, Emacs uses a widget named
'emacs-filedialog', of class 'GtkFileSelection'.

   Because the widgets for pop-up menus and dialogs are free-standing
windows and not contained in the 'Emacs' widget, their GTK+ absolute
names do not start with 'Emacs'.  To customize these widgets, use
wildcards like this:

     widget "emacs-dialog" style "my_dialog_style"
     widget "emacs-filedialog style "my_file_style"
     widget "emacs-menuitem style "my_menu_style"

   If you want to apply a style to all menus in Emacs, use this:

     widget_class "Menu" style "my_menu_style"

==============================================================================
File: emacs.info,  Node: |GTK_styles|,  Prev: |GTK_Names_in_Emacs|,  Up: |GTK_resources|
==============================================================================

                                                                    *GTK_styles*

D.5.4 GTK+ styles
-----------------

Here is an example of two GTK+ style declarations:

     pixmap_path "/usr/share/pixmaps:/usr/include/X11/pixmaps"

     style "default"
     {
       font_name = "helvetica 12"

       bg[NORMAL] = { 0.83, 0.80, 0.73 }
       bg[SELECTED] = { 0.0, 0.55, 0.55 }
       bg[INSENSITIVE] = { 0.77, 0.77, 0.66 }
       bg[ACTIVE] = { 0.0, 0.55, 0.55 }
       bg[PRELIGHT] = { 0.0, 0.55, 0.55 }

       fg[NORMAL] = "black"
       fg[SELECTED] = { 0.9, 0.9, 0.9 }
       fg[ACTIVE] = "black"
       fg[PRELIGHT] = { 0.9, 0.9, 0.9 }

       base[INSENSITIVE] = "#777766"
       text[INSENSITIVE] = { 0.60, 0.65, 0.57 }

       bg_pixmap[NORMAL] = "background.xpm"
       bg_pixmap[INSENSITIVE] = "background.xpm"
       bg_pixmap[ACTIVE] = "background.xpm"
       bg_pixmap[PRELIGHT] = "<none>"

     }

     style "ruler" = "default"
     {
       font_name = "helvetica 8"
     }


   The style 'ruler' inherits from 'default'.  This way you can build on
existing styles.  The syntax for fonts and colors is described below.

   As this example shows, it is possible to specify several values for
foreground and background depending on the widget's "state".  The
possible states are:

'NORMAL'
     This is the default state for widgets.

'ACTIVE'
     This is the state for a widget that is ready to do something.  It
     is also for the trough of a scroll bar, i.e., 'bg[ACTIVE] = "red"'
     sets the scroll bar trough to red.  Buttons that have been armed
     (pressed but not released yet) are in this state.

'PRELIGHT'
     This is the state for a widget that can be manipulated, when the
     mouse pointer is over it--for example when the mouse is over the
     thumb in the scroll bar or over a menu item.  When the mouse is
     over a button that is not pressed, the button is in this state.

'SELECTED'
     This is the state for data that has been selected by the user.  It
     can be selected text or items selected in a list.  This state is
     not used in Emacs.

'INSENSITIVE'
     This is the state for widgets that are visible, but they cannot be
     manipulated in the usual way--for example, buttons that can't be
     pressed, and disabled menu items.  To display disabled menu items
     in yellow, use 'fg[INSENSITIVE] = "yellow"'.

   Here are the things that can go in a style declaration:

'bg[STATE] = COLOR'
     This specifies the background color for the widget.  Note that
     editable text doesn't use 'bg'; it uses 'base' instead.

'base[STATE] = COLOR'
     This specifies the background color for editable text.  In Emacs,
     this color is used for the background of the text fields in the
     file dialog.

'bg_pixmap[STATE] = "PIXMAP"'
     This specifies an image background (instead of a background color).
     PIXMAP should be the image file name.  GTK+ can use a number of
     image file formats, including XPM, XBM, GIF, JPEG and PNG.  If you
     want a widget to use the same image as its parent, use '<parent>'.
     If you don't want any image, use '<none>'.  '<none>' is the way to
     cancel a background image inherited from a parent style.

     You can't specify the file by its absolute file name.  GTK+ looks
     for the pixmap file in directories specified in 'pixmap_path'.
     'pixmap_path' is a colon-separated list of directories within
     double quotes, specified at the top level in a 'gtkrc' file (i.e.,
     not inside a style definition; see example above):

          pixmap_path "/usr/share/pixmaps:/usr/include/X11/pixmaps"

'fg[STATE] = COLOR'
     This specifies the foreground color for widgets to use.  It is the
     color of text in menus and buttons, and the color for the arrows in
     the scroll bar.  For editable text, use 'text'.

'text[STATE] = COLOR'
     This is the color for editable text.  In Emacs, this color is used
     for the text fields in the file dialog.

'font_name = "FONT"'
     This specifies the font for text in the widget.  FONT is a
     GTK-style (or Pango) font name, like 'Sans Italic 10'.  *Note
     Fonts::.  The names are case insensitive.

   There are three ways to specify a color: a color name, an RGB
triplet, or a GTK-style RGB triplet.  *Note Colors::, for a description
of color names and RGB triplets.  Color names should be enclosed with
double quotes, e.g., '"red"'.  RGB triplets should be written without
double quotes, e.g., '#ff0000'.  GTK-style RGB triplets have the form
'{ R, G, B }', where R, G and B are either integers in the range 0-65535
or floats in the range 0.0-1.0.

==============================================================================
File: emacs.info,  Node: |Antinews|,  Next: |Mac_OS_/_GNUstep|,  Prev: |X_Resources|,  Up: |Top|
==============================================================================

                                                                      *Antinews*

Appendix E Emacs 26 Antinews
*****=======================

For those users who live backwards in time, here is information about
downgrading to Emacs version 26.3.  We hope you will enjoy the greater
simplicity that results from the absence of many Emacs 27.1 features.

   * Emacs no longer uses GMP, the GNU Multiple Precision library, and
     doesn't support Lisp integers greater than 'most-positive-fixnum'
     or smaller than 'most-negative-fixnum'.  We now have only one kind
     of a Lisp integer.  This simplifies many Lisp programs that use
     integers, and makes integer calculations always fast.  If you want
     larger values, use Lisp floats, as Emacs has done since day one.

   * Emacs no longer supports HarfBuzz as the engine for shaping complex
     text.  As you move back in time, we will gradually shed off all
     traces of support for complex text shaping, and this is one step in
     that direction.

   * We have removed support for building with the Jansson library, and
     consequently the native support for JSON parsing is gone.  The
     importance of JSON decreases as we go back in time, so for now
     using the Lisp code for handling it should be good enough; in one
     of the past Emacs versions, we intend to remove even that, as
     useless bloat.

     The library for supporting JSONRPC applications was removed for the
     same reason.

   * The "portable dumper" feature is gone.  We are once again using the
     field-proven "unexec" way of dumping Emacs.  With that, the hope
     for being able to re-dump your customized Emacs session is also
     gone: why would anyone want to record their random customization
     experiments on disk, and restore them the next time they start
     Emacs?  And true Emacsers don't restart their Emacs sessions
     anyway.

   * We dropped the support for XDG-style configuration directories and
     the 'XDG_CONFIG_HOME' environment variable.  There's once again
     only one place where Emacs looks for its init files: the
     '~/.emacs.d' directory, with the '~/.emacs' file as fallback.  We
     think this will go a long way towards preventing confusion among
     users who for some reason have 'XDG_CONFIG_HOME' set, thus risking
     to have their init files randomly spread between two places.  In
     one of the past Emacs versions, we intend to further simplify this,
     removing the '~/.emacs.d' place and leaving only '~/.emacs'; stay
     tuned.

     For similar reasons, we've removed the "early init" file.  You can
     now again use all the tricks you want to initialize variables like
     'package-user-dir' and 'package-load-list' just in time for the
     packages to load.

     'emacsclient' no longer supports XDG-style directory trees, either.

   * TLS connections are back to their lenient security settings.  We
     decided that too tight security settings are an annoyance for
     users, and make little sense considering the world-wide tendency to
     have fewer and fewer network security problems as we move back in
     time (those issues will be completely gone when networks disappear
     in some distant past).

   * The 'server-after-make-frame-hook' hook was deleted, in preparation
     for removing the entire daemon business in some past Emacs version.
     You will be glad to learn that setting up the GUI customizations of
     your sessions is now once again as easy as it ever was, with just
     the 'after-make-frame-functions' to use.

   * The 'flex' completion style was removed.  We feel that it
     unnecessarily complicates the Emacs user experience, and therefore
     will continue to remove other tricky completion styles, until in
     some past Emacs version we get to a single original style Emacs
     pioneered decades ago.  Long live simplicity; down with
     complications!

   * The optional display of the fill-column indicator is no longer
     supported.  With the display sizes becoming smaller and smaller as
     you move back in time, we feel that the display itself will always
     show you where to fill or wrap your text, and do this much more
     easily and reliably than any such display indicator.

   * We removed the features that made visiting large files easier.
     Thus, Emacs will no longer suggest visiting a large file literally,
     nor offer the 'so-long' mode to deal with overly-long lines.  We
     decided that this simplification is worthwhile, given that the
     general tendency of having very large files is becoming a rarity as
     we move back in time.

   * We have removed the feature that displayed echo-area messages
     without hiding content of the active minibuffer.  This should
     prevent user confusion from having two unrelated pieces of text
     staring at them, with no clear separation between them.  Users with
     good memories (and Emacs users are all expected to be of that kind)
     will have no trouble keeping the minibuffer text in their minds,
     and typing the responses without actually seeing the prompts.

   * Horizontal scrolling using the mouse or touchpad has been removed.
     In the past, wide monitors will become less popular, so horizontal
     scrolling will no longer be needed.  Removal of the mouse support
     for horizontal scrolling is the first step towards its complete
     removal in prior Emacs versions.

   * The 'main-thread' variable and 'list-threads' were removed, and
     'thread-join' no longer returns the result of the finished thread.
     We intend to remove the support for Lisp threads in some past Emacs
     version, so we continue removing the associated complexities and
     features as we go back in time.

   * Tab bar and window tab-lines were removed.  This should make the
     Emacs display simpler and less cluttered, and help those users who
     disable menu bar and tool bar in their GUI sessions.  The fashion
     to provide tabs in every GUI application out there is gaining less
     and less popularity as we move back in time, and will completely
     disappear at some past point; removing the tabs from Emacs is the
     step in that direction.

   * Displaying line numbers for a buffer is only possibly using add-on
     features, such as 'linum-mode', which can only display the numbers
     in the display margins.  Line-number display using these features
     is also slow, as we firmly believe such a feature is un-Emacsy and
     should not have been included in Emacs to begin with.
     Consequently, 'display-line-numbers-mode' was removed.

   * On our permanent quest for simplifying Emacs, we've removed the
     support for changing the font size by turning the mouse wheel.

   * Several commands, deemed to be unnecessary complications, have been
     removed.  Examples include 'make-empty-file',
     'font-lock-refontify', 'xref-find-definitions-at-mouse',
     'make-frame-on-monitor', and 'diff-buffers'.

   * To keep up with decreasing computer memory capacity and disk space,
     many other functions and files have been eliminated in Emacs 26.3.

==============================================================================
File: emacs.info,  Node: |Mac_OS_/_GNUstep|,  Next: |Microsoft_Windows|,  Prev: |Antinews|,  Up: |Top|
==============================================================================

                                                              *Mac_OS_/_GNUstep*

Appendix F Emacs and macOS / GNUstep
*****===============================

This section describes the peculiarities of using Emacs built with the
GNUstep libraries on GNU/Linux or other operating systems, or on macOS
with native window system support.  On macOS, Emacs can be built either
without window system support, with X11, or with the Cocoa interface;
this section only applies to the Cocoa build.  This does not support
versions before macOS 10.6.

   GNUstep is free software; macOS is not.  Because it is a non-free
operating system, macOS denies its users the freedom that every computer
user deserves.  That is an injustice.  For your freedom's sake, we urge
you to switch to a free operating system.

   We support GNU Emacs on proprietary operating systems because we hope
this taste of freedom will inspire users to escape from them.

   For various historical and technical reasons, Emacs uses the term
'Nextstep' internally, instead of "Cocoa" or "macOS"; for instance, most
of the commands and variables described in this section begin with
'ns-', which is short for 'Nextstep'.  NeXTstep was an application
interface released by NeXT Inc. during the 1980s, of which Cocoa is a
direct descendant.  Apart from Cocoa, there is another NeXTstep-style
system: GNUstep, which is free software.  As of this writing, Emacs
GNUstep support is in alpha status (*note GNUstep Support::), but we
hope to improve it in the future.

MENU

* |Mac_/_GNUstep_Basics|::        Basic Emacs usage under GNUstep or macOS.
* |Mac_/_GNUstep_Customization|:: Customizations under GNUstep or macOS.
* |Mac_/_GNUstep_Events|::        How window system events are handled.
* |GNUstep_Support|::             Details on status of GNUstep support.

==============================================================================
File: emacs.info,  Node: |Mac_/_GNUstep_Basics|,  Next: |Mac_/_GNUstep_Customization|,  Up: |Mac_OS_/_GNUstep|
==============================================================================

                                                          *Mac_/_GNUstep_Basics*

F.1 Basic Emacs usage under macOS and GNUstep
=====----------------------------------------

By default, the <Alt> and <Option> keys are the same as <Meta>.  The Mac
<Cmd> key is the same as <Super>, and Emacs provides a set of key
bindings using this modifier key that mimic other Mac / GNUstep
applications (*note Mac / GNUstep Events::).  You can change these
bindings in the usual way (*note Key Bindings::).  The modifiers
themselves can be customized; *note Mac / GNUstep Customization::.

   'S-mouse-1' adjusts the region to the click position, just like
'mouse-3' ('mouse-save-then-kill'); it does not pop up a menu for
changing the default face, as 'S-mouse-1' normally does (*note Text
Scale::).  This change makes Emacs behave more like other Mac / GNUstep
applications.

   When you open or save files using the menus, or using the 'Cmd-o' and
'Cmd-S' bindings, Emacs uses graphical file dialogs to read file names.
However, if you use the regular Emacs key sequences, such as 'C-x C-f',
Emacs uses the minibuffer to read file names.

   On GNUstep, in an X-windows environment you need to use 'Cmd-c'
instead of one of the 'C-w' or 'M-w' commands to transfer text to the X
primary selection; otherwise, Emacs will use the clipboard selection.
Likewise, 'Cmd-y' (instead of 'C-y') yanks from the X primary selection
instead of the kill-ring or clipboard.

F.1.1 Grabbing environment variables
------------------------------------

Many programs which may run under Emacs, like latex or man, depend on
the settings of environment variables.  If Emacs is launched from the
shell, it will automatically inherit these environment variables and its
subprocesses will inherit them from it.  But if Emacs is launched from
the Finder it is not a descendant of any shell, so its environment
variables haven't been set, which often causes the subprocesses it
launches to behave differently than they would when launched from the
shell.

   For the PATH and MANPATH variables, a system-wide method of setting
PATH is recommended on macOS, using the '/etc/paths' files and the
'/etc/paths.d' directory.

==============================================================================
File: emacs.info,  Node: |Mac_/_GNUstep_Customization|,  Next: |Mac_/_GNUstep_Events|,  Prev: |Mac_/_GNUstep_Basics|,  Up: |Mac_OS_/_GNUstep|
==============================================================================

                                                   *Mac_/_GNUstep_Customization*

F.2 Mac / GNUstep Customization
=====--------------------------

There are a few customization options that are specific to the Nextstep
port.  For example, they affect things such as the modifier keys and the
fullscreen behavior.  To see all such options, use 'M-x customize-group
<RET> ns <RET>'.

F.2.1 Modifier keys
-------------------

The following variables control the behavior of the actual modifier
keys:

'ns-alternate-modifier'
'ns-right-alternate-modifier'
     The left and right <Option> or <Alt> keys.

'ns-command-modifier'
'ns-right-command-modifier'
     The left and right <Command> keys.

'ns-control-modifier'
'ns-right-control-modifier'
     The left and right <Control> keys.

'ns-function-modifier'
     The <Function> (fn) key.

   The value of each variable is either a symbol, describing the key for
any purpose, or a list of the form '(:ordinary SYMBOL :function SYMBOL
:mouse SYMBOL)', which describes the modifier when used with ordinary
keys, function keys (that do not produce a character, such as arrow
keys), and mouse clicks.

   If the SYMBOL is one of 'control', 'meta', 'alt', 'super' or 'hyper',
this describes the Emacs modifier it represents.  If SYMBOL is 'none',
Emacs does not use the key, which retains its standard behavior.  For
instance, the <Option> key in macOS is then used for composing
additional characters.

   The variables for right-hand keys, like
'ns-right-alternate-modifier', may also be set to 'left', which means to
use the same behavior as the corresponding left-hand key.

F.2.2 Frame Variables
---------------------

'ns-use-proxy-icon'
     This variable specifies whether to display the proxy icon in the
     titlebar.

'ns-confirm-quit'
     This variable specifies whether to display a graphical confirmation
     dialogue on quitting.

'ns-auto-hide-menu-bar'
     This variable specifies whether the macOS menu bar is hidden when
     an Emacs frame is selected.  If non-nil the menu bar is not shown
     unless the mouse pointer is moved near to the top of the screen.

'ns-use-native-fullscreen'
     This variable controls whether to use native, or non-native
     fullscreen.  Native fullscreen is only available on macOS 10.7 and
     above.

F.2.3 macOS Trackpad/Mousewheel Variables
-----------------------------------------

These variables only apply to macOS 10.7 (Lion) and above.

'ns-use-mwheel-acceleration'
     This variable controls whether Emacs ignores the system mousewheel
     acceleration.  When nil each 'click' of the mousewheel will
     correspond exactly with one mousewheel event.  When non-nil, the
     default, each 'click' may correspond with more than one mousewheel
     event, depending on the user's input.

'ns-use-mwheel-momentum'
     This variable controls whether Emacs ignores the system 'momentum'
     when scrolling using a trackpad.  When non-nil, the default,
     scrolling rapidly may result in the buffer continuing to scroll for
     a short while after the user has lifted their fingers off the
     trackpad.

'ns-mwheel-line-height'
     This variable controls the sensitivity of scrolling with the
     trackpad.  Apple trackpads scroll by pixels, not lines, so Emacs
     converts the system's pixel values into lines.  When set to a
     number, this variable sets the number of pixels Emacs will consider
     as one line.  When nil or a non-number the default line height is
     used.

     Setting a lower number makes the trackpad more sensitive, and a
     higher number makes the trackpad less sensitive.

F.2.4 Font Panel
----------------

The standard Mac / GNUstep font panel is accessible with 'M-x
ns-popup-font-panel' and will set the default font in the frame most
recently used or clicked on.

==============================================================================
File: emacs.info,  Node: |Mac_/_GNUstep_Events|,  Next: |GNUstep_Support|,  Prev: |Mac_/_GNUstep_Customization|,  Up: |Mac_OS_/_GNUstep|
==============================================================================

                                                          *Mac_/_GNUstep_Events*

F.3 Windowing System Events under macOS / GNUstep
=====--------------------------------------------

Nextstep applications receive a number of special events which have no X
equivalent.  These are sent as specially defined key events, which do
not correspond to any sequence of keystrokes.  Under Emacs, these key
events can be bound to functions just like ordinary keystrokes.  Here is
a list of these events.

<ns-open-file>
     This event occurs when another Nextstep application requests that
     Emacs open a file.  A typical reason for this would be a user
     double-clicking a file in the Finder application.  By default,
     Emacs responds to this event by opening a new frame and visiting
     the file in that frame ('ns-find-file').  As an exception, if the
     selected buffer is the 'scratch' buffer, Emacs visits the file in
     the selected frame.

     You can change how Emacs responds to a 'ns-open-file' event by
     changing the variable 'ns-pop-up-frames'.  Its default value,
     'fresh', is what we have just described.  A value of 't' means to
     always visit the file in a new frame.  A value of 'nil' means to
     always visit the file in the selected frame.

<ns-open-temp-file>
     This event occurs when another application requests that Emacs open
     a temporary file.  By default, this is handled by just generating a
     'ns-open-file' event, the results of which are described above.

<ns-open-file-line>
     Some applications, such as ProjectBuilder and gdb, request not only
     a particular file, but also a particular line or sequence of lines
     in the file.  Emacs handles this by visiting that file and
     highlighting the requested line ('ns-open-file-select-line').

<ns-drag-n-drop>
     This event occurs when a user drags an object from another
     application into an Emacs frame.  The default behavior is to open a
     file in the window under the mouse, or to insert text at point of
     the window under the mouse.

     The sending application has some limited ability to decide how
     Emacs handles the sent object, but the user may override the
     default behavior by holding one or more modifier key.

     'control'
          Insert as text in the current buffer.  If the object is a
          file, this will insert the filename.
     'alt/option'
          Attempt to open the object as though it is a file or URL.
     'super/command'
          Perform the default action for the type.  This can be useful
          when an application is overriding the default behavior.

     The modifier keys listed above are defined by macOS and are
     unaffected by user changes to the modifiers in Emacs.

<ns-change-font>
     This event occurs when the user selects a font in a Nextstep font
     panel (which can be opened with 'Cmd-t').  The default behavior is
     to adjust the font of the selected frame
     ('ns-respond-to-changefont').  The name and size of the selected
     font are stored in the variables 'ns-input-font' and
     'ns-input-fontsize', respectively.

<ns-power-off>
     This event occurs when the user logs out and Emacs is still
     running, or when "Quit Emacs" is chosen from the application menu.
     The default behavior is to save all file-visiting buffers.

   Emacs also allows users to make use of Nextstep services, via a set
of commands whose names begin with 'ns-service-' and end with the name
of the service.  Type 'M-x ns-service-<TAB>' to see a list of these
commands.  These functions either operate on marked text (replacing it
with the result) or take a string argument and return the result as a
string.  You can also use the Lisp function 'ns-perform-service' to pass
arbitrary strings to arbitrary services and receive the results back.
Note that you may need to restart Emacs to access newly-available
services.

==============================================================================
File: emacs.info,  Node: |GNUstep_Support|,  Prev: |Mac_/_GNUstep_Events|,  Up: |Mac_OS_/_GNUstep|
==============================================================================

                                                               *GNUstep_Support*

F.4 GNUstep Support
=====--------------

Emacs can be built and run under GNUstep, but there are still issues to
be addressed.  Interested developers should contact
<emacs-devel@gnu.org>.

==============================================================================
File: emacs.info,  Node: |Microsoft_Windows|,  Next: |Manifesto|,  Prev: |Mac_OS_/_GNUstep|,  Up: |Top|
==============================================================================

                                                             *Microsoft_Windows*

Appendix G Emacs and Microsoft Windows/MS-DOS
*****========================================

This section describes peculiarities of using Emacs on Microsoft
Windows.  Some of these peculiarities are also relevant to Microsoft's
older MS-DOS operating system.  However, Emacs features that are
relevant _only_ to MS-DOS are described in a separate section (*note
MS-DOS::).

   MS-Windows is a non-free operating system; that means it denies its
users the freedom that every computer user deserves.  That is an
injustice.  For your freedom's sake, we urge you to switch to a free
operating system.

   We support GNU Emacs on proprietary operating systems because we hope
this taste of freedom will inspire users to escape from them.

   The behavior of Emacs on MS-Windows is reasonably similar to what is
documented in the rest of the manual, including support for long file
names, multiple frames, scroll bars, mouse menus, and subprocesses.
However, a few special considerations apply, and they are described
here.

MENU

* |Windows_Startup|::     How to start Emacs on Windows.
* |Text_and_Binary|::     Text files use CRLF to terminate lines.
* |Windows_Files|::       File-name conventions on Windows.
* |ls_in_Lisp|::          Emulation of 'ls' for Dired.
* |Windows_HOME|::        Where Emacs looks for your '.emacs' and
                          where it starts up.
* |Windows_Keyboard|::    Windows-specific keyboard features.
* |Windows_Mouse|::       Windows-specific mouse features.
* |Windows_Processes|::   Running subprocesses on Windows.
* |Windows_Printing|::    How to specify the printer on MS-Windows.
* |Windows_Fonts|::       Specifying fonts on MS-Windows.
* |Windows_Misc|::        Miscellaneous Windows features.
* |MS_DOS|::              Using Emacs on MS-DOS.

==============================================================================
File: emacs.info,  Node: |Windows_Startup|,  Next: |Text_and_Binary|,  Up: |Microsoft_Windows|
==============================================================================

                                                               *Windows_Startup*

G.1 How to Start Emacs on MS-Windows
=====-------------------------------

There are several ways of starting Emacs on MS-Windows:

  1. From the desktop shortcut icon: either double-click the left mouse
     button on the icon, or click once, then press <RET>.  The desktop
     shortcut should specify as its "Target" (in the "Properties" of the
     shortcut) the full absolute file name of 'runemacs.exe', _not_ of
     'emacs.exe'.  This is because 'runemacs.exe' hides the console
     window that would have been created if the target of the shortcut
     were 'emacs.exe' (which is a console program, as far as Windows is
     concerned).  If you use this method, Emacs starts in the directory
     specified by the shortcut.  To control where that is, right-click
     on the shortcut, select "Properties", and in the "Shortcut" tab
     modify the "Start in" field to your liking.

  2. From a task-bar shortcut icon, by clicking once the left mouse
     button.  Windows versions since Vista allow you to create such
     shortcuts by "pinning" the icon of a running program that appears
     in the task bar.  You can do that with Emacs, but afterwards you
     will have to change the properties of the pinned shortcut to run
     'runemacs.exe', _not_ of 'emacs.exe'.  You can also pin Emacs to
     the task bar by clicking the right mouse button on its icon in the
     Start menu, then selecting 'Pin to taskbar'.  Once again, be sure
     to specify 'runemacs.exe' as the program to run.  You can control
     where Emacs starts by setting the "Start in" field of the
     shortcut's Properties.

  3. From the Command Prompt window, by typing 'emacs <RET>' at the
     prompt.  The Command Prompt window where you did that will not be
     available for invoking other commands until Emacs exits.  In this
     case, Emacs will start in the current directory of the Windows
     shell.

  4. From the Command Prompt window, by typing 'runemacs <RET>' at the
     prompt.  The Command Prompt window where you did that will be
     immediately available for invoking other commands.  In this case,
     Emacs will start in the current directory of the Windows shell.

  5. From the Windows 'Run' dialog (normally reached by clicking the
     'Start' button).  Typing 'runemacs <RET>' into the dialog will
     start Emacs in the parent directory of the Windows equivalent of
     your user's 'HOME' directory, see *note Windows HOME::.

  6. Via 'emacsclient.exe' or 'emacsclientw.exe', which allow you to
     invoke Emacs from other programs, and to reuse a running Emacs
     process for serving editing jobs required by other programs.  *Note
     Emacs Server::.  The difference between 'emacsclient.exe' and
     'emacsclientw.exe' is that the former is a console program, while
     the latter is a Windows GUI program.  Both programs wait for Emacs
     to signal that the editing job is finished, before they exit and
     return control to the program that invoked them.  Which one of them
     to use in each case depends on the expectations of the program that
     needs editing services.  If that program is itself a console
     (text-mode) program, you should use 'emacsclient.exe', so that any
     of its messages and prompts appear in the same command window as
     those of the invoking program.  By contrast, if the invoking
     program is a GUI program, you will be better off using
     'emacsclientw.exe', because 'emacsclient.exe' will pop up a command
     window if it is invoked from a GUI program.  A notable situation
     where you would want 'emacsclientw.exe' is when you right-click on
     a file in the Windows Explorer and select "Open With" from the
     pop-up menu.  Use the '--alternate-editor=' or '-a' options if
     Emacs might not be running (or not running as a server) when
     'emacsclient' is invoked--that will always give you an editor.  When
     invoked via 'emacsclient', Emacs will start in the current
     directory of the program that invoked 'emacsclient'.

   Note that, due to limitations of MS-Windows, Emacs cannot have both
GUI and text-mode frames in the same session.  It also cannot open
text-mode frames on more than a single "Command Prompt" window, because
each Windows program can have only one console at any given time.  For
these reasons, if you invoke 'emacsclient' with the '-c' option, and the
Emacs server runs in a text-mode session, Emacs will always create a new
text-mode frame in the same "Command Prompt" window where it was
started; a GUI frame will be created only if the server runs in a GUI
session.  Similarly, if you invoke 'emacsclient' with the '-t' option,
Emacs will create a GUI frame if the server runs in a GUI session, or a
text-mode frame when the session runs in text mode in a "Command Prompt"
window.  *Note emacsclient Options::.

==============================================================================
File: emacs.info,  Node: |Text_and_Binary|,  Next: |Windows_Files|,  Prev: |Windows_Startup|,  Up: |Microsoft_Windows|
==============================================================================

                                                               *Text_and_Binary*

G.2 Text Files and Binary Files
=====--------------------------

GNU Emacs uses newline characters to separate text lines.  This is the
convention used on GNU, Unix, and other POSIX-compliant systems.

   By contrast, MS-DOS and MS-Windows normally use carriage return
followed by linefeed, a two-character sequence, to separate text lines.
(Linefeed is the same character as newline.)  Therefore, convenient
editing of typical files with Emacs requires conversion of these
end-of-line (EOL) sequences.  And that is what Emacs normally does: it
converts carriage return followed by linefeed into newline when reading
files, and converts newline into carriage return followed by linefeed
when writing files.  The same mechanism that handles conversion of
international character codes does this conversion also (*note Coding
Systems::).

   One consequence of this special format-conversion of most files is
that character positions as reported by Emacs (*note Position Info::) do
not agree with the file size information known to the operating system.

   In addition, if Emacs recognizes from a file's contents that it uses
newline rather than carriage return followed by linefeed as its line
separator, it does not perform EOL conversion when reading or writing
that file.  Thus, you can read and edit files from GNU and Unix systems
on MS-DOS with no special effort, and they will retain their Unix-style
end-of-line convention after you edit them.

   The mode line indicates whether end-of-line translation was used for
the current buffer.  If MS-DOS end-of-line translation is in use for the
buffer, the MS-Windows build of Emacs displays a backslash '\' after the
coding system mnemonic near the beginning of the mode line (*note Mode
Line::).  If no EOL translation was performed, the string '(Unix)' is
displayed instead of the backslash, to alert you that the file's EOL
format is not the usual carriage return followed by linefeed.

   To visit a file and specify whether it uses DOS-style or Unix-style
end-of-line, specify a coding system (*note Text Coding::).  For
example, 'C-x <RET> c unix <RET> C-x C-f foobar.txt' visits the file
'foobar.txt' without converting the EOLs; if some line ends with a
carriage return followed by linefeed pair, Emacs will display '^M' at
the end of that line.  Similarly, you can direct Emacs to save a buffer
in a specified EOL format with the 'C-x <RET> f' command.  For example,
to save a buffer with Unix EOL format, type 'C-x <RET> f unix <RET> C-x
C-s'.  If you visit a file with DOS EOL conversion, then save it with
Unix EOL format, that effectively converts the file to Unix EOL style,
like the 'dos2unix' program.

   When you use NFS, Samba, or some other similar method to access file
systems that reside on computers using GNU or Unix systems, Emacs should
not perform end-of-line translation on any files in these file
systems--not even when you create a new file.  To request this, designate
these file systems as "untranslated" file systems by calling the
function 'add-untranslated-filesystem'.  It takes one argument: the file
system name, including a drive letter and optionally a directory.  For
example,

     (add-untranslated-filesystem "Z:")

designates drive Z as an untranslated file system, and

     (add-untranslated-filesystem "Z:\\foo")

designates directory '\foo' on drive Z as an untranslated file system.

   Most often you would use 'add-untranslated-filesystem' in your
'.emacs' or 'init.el' init file, or in 'site-start.el' so that all the
users at your site get the benefit of it.

   To countermand the effect of 'add-untranslated-filesystem', use the
function 'remove-untranslated-filesystem'.  This function takes one
argument, which should be a string just like the one that was used
previously with 'add-untranslated-filesystem'.

   Designating a file system as untranslated does not affect character
set conversion, only end-of-line conversion.  Essentially, it directs
Emacs to default to creating new files with the Unix-style convention of
using newline at the end of a line.  *Note Coding Systems::.

==============================================================================
File: emacs.info,  Node: |Windows_Files|,  Next: |ls_in_Lisp|,  Prev: |Text_and_Binary|,  Up: |Microsoft_Windows|
==============================================================================

                                                                 *Windows_Files*

G.3 File Names on MS-Windows
=====-----------------------

MS-Windows and MS-DOS normally use a backslash, '\', to separate name
units within a file name, instead of the slash used on other systems.
Emacs on MS-DOS/MS-Windows permits use of either slash or backslash, and
also knows about drive letters in file names.

   On MS-DOS/MS-Windows, file names are case-insensitive, so Emacs by
default ignores letter-case in file names during completion.  To this
end, the default value of 'read-file-name-completion-ignore-case' is
non-'nil' on MS-DOS/MS-Windows.  *Note Completion Options::.

   The variable 'w32-get-true-file-attributes' controls whether Emacs
should issue additional system calls to determine more accurately file
attributes in primitives like 'file-attributes' and
'directory-files-and-attributes'.  These additional calls are needed to
report correct file ownership, link counts and file types for special
files such as pipes.  Without these system calls, file ownership will be
attributed to the current user, link counts will be always reported as
1, and special files will be reported as regular files.

   If the value of this variable is 'local' (the default), Emacs will
issue these additional system calls only for files on local fixed
drives.  Any other non-'nil' value means do this even for removable and
remote volumes, where this could potentially slow down Dired and other
related features.  The value of 'nil' means never issue those system
calls.  Non-'nil' values are more useful on NTFS volumes, which support
hard links and file security, than on FAT, FAT32, and exFAT volumes.

   Unlike Unix, MS-Windows file systems restrict the set of characters
that can be used in a file name.  The following characters are not
allowed:

   * Shell redirection symbols '<', '>', and '|'.

   * Colon ':' (except after the drive letter).

   * Forward slash '/' and backslash '\' (except as directory
     separators).

   * Wildcard characters '*' and '?'.

   * Control characters whose codepoints are 1 through 31 decimal.  In
     particular, newlines in file names are not allowed.

   * The null character, whose codepoint is zero (this limitation exists
     on Unix filesystems as well).

In addition, referencing any file whose name matches a DOS character
device, such as 'NUL' or 'LPT1' or 'PRN' or 'CON', with or without any
file-name extension, will always resolve to those character devices, in
any directory.  Therefore, only use such file names when you want to use
the corresponding character device.

==============================================================================
File: emacs.info,  Node: |ls_in_Lisp|,  Next: |Windows_HOME|,  Prev: |Windows_Files|,  Up: |Microsoft_Windows|
==============================================================================

                                                                    *ls_in_Lisp*

G.4 Emulation of 'ls' on MS-Windows
=====------------------------------

Dired normally uses the external program 'ls' to produce the directory
listing displayed in Dired buffers (*note Dired::).  However, MS-Windows
and MS-DOS systems don't come with such a program, although several
ports of GNU 'ls' are available.  Therefore, Emacs on those systems
_emulates_ 'ls' in Lisp, by using the 'ls-lisp.el' package.  While
'ls-lisp.el' provides a reasonably full emulation of 'ls', there are
some options and features peculiar to that emulation; they are described
in this section.

   The 'ls' emulation supports many of the 'ls' switches, but it doesn't
support all of them.  Here's the list of the switches it does support:
'-A', '-a', '-B', '-C', '-c', '-G', '-g', '-h', '-i', '-n', '-R', '-r',
'-S', '-s', '-t', '-U', '-u', '-v', and '-X'.  The '-F' switch is
partially supported (it appends the character that classifies the file,
but does not prevent symlink following).

   On MS-Windows and MS-DOS, 'ls-lisp.el' is preloaded when Emacs is
built, so the Lisp emulation of 'ls' is always used on those platforms.
If you have a ported 'ls', setting
'ls-lisp-use-insert-directory-program' to a non-'nil' value will revert
to using an external program named by the variable
'insert-directory-program'.

   The order in which 'ls-lisp.el' sorts files depends on several
customizable options described below.

   The default sorting order follows locale-specific rules derived from
your system locale.  You can make the order locale-independent by
customizing 'ls-lisp-use-string-collate' to a 'nil' value.

   On GNU and Unix systems, when the locale's encoding is UTF-8, the
collation order follows the Unicode Collation Algorithm (UCA).  To have
a similar effect on MS-Windows, the variable
'ls-lisp-UCA-like-collation' should have a non-'nil' value (this is the
default).  The resulting sorting order ignores punctuation, symbol
characters, and whitespace characters, so '.foobar', 'foobar' and
'foo bar' will appear together rather than far apart.

   By default, 'ls-lisp.el' uses a case-sensitive sort order for the
directory listing it produces; this is so the listing looks the same as
on other platforms.  If you wish that the files be sorted in
case-insensitive order, set the variable 'ls-lisp-ignore-case' to a
non-'nil' value.

   By default, files and subdirectories are sorted together, to emulate
the behavior of 'ls'.  However, native MS-Windows/MS-DOS file managers
list the directories before the files; if you want that behavior,
customize the option 'ls-lisp-dirs-first' to a non-'nil' value.

   The variable 'ls-lisp-verbosity' controls the file attributes that
'ls-lisp.el' displays.  The value should be either 'nil' or a list that
contains one or more of the symbols 'links', 'uid', and 'gid'.  'links'
means display the count of different file names that are associated with
(a.k.a. "links to") the file's data; this is only useful on NTFS
volumes.  'uid' means display the numerical identifier of the user who
owns the file.  'gid' means display the numerical identifier of the file
owner's group.  The default value is '(links uid gid)' i.e., all the 3
optional attributes are displayed.  The value 'nil' means not to display
any of these attributes.

   The variable 'ls-lisp-emulation' controls the flavor of the 'ls'
emulation by setting the defaults for the 3 options described above:
'ls-lisp-ignore-case', 'ls-lisp-dirs-first', and 'ls-lisp-verbosity'.
The value of this option can be one of the following symbols:

'GNU'
'nil'
     Emulate GNU systems; this is the default.  This sets
     'ls-lisp-ignore-case' and 'ls-lisp-dirs-first' to 'nil', and
     'ls-lisp-verbosity' to '(links uid gid)'.
'UNIX'
     Emulate Unix systems.  Like 'GNU', but sets 'ls-lisp-verbosity' to
     '(links uid)'.
'MacOS'
     Emulate macOS.  Sets 'ls-lisp-ignore-case' to 't', and
     'ls-lisp-dirs-first' and 'ls-lisp-verbosity' to 'nil'.
'MS-Windows'
     Emulate MS-Windows.  Sets 'ls-lisp-ignore-case' and
     'ls-lisp-dirs-first' to 't', and 'ls-lisp-verbosity' to 'nil' on
     Windows 9X and to 't' on modern versions of Windows.  Note that the
     default emulation is _not_ 'MS-Windows', even on Windows, since
     many users of Emacs on those platforms prefer the GNU defaults.

Any other value of 'ls-lisp-emulation' means the same as 'GNU'.
Customizing this option calls the function 'ls-lisp-set-options' to
update the 3 dependent options as needed.  If you change the value of
this variable without using customize after 'ls-lisp.el' is loaded (note
that it is preloaded on MS-Windows and MS-DOS), you can call that
function manually for the same result.

   The variable 'ls-lisp-support-shell-wildcards' controls how file-name
patterns are supported: if it is non-'nil' (the default), they are
treated as shell-style wildcards; otherwise they are treated as Emacs
regular expressions.

   The variable 'ls-lisp-format-time-list' defines how to format the
date and time of files.  _The value of this variable is ignored_, unless
Emacs cannot determine the current locale.  (However, if the value of
'ls-lisp-use-localized-time-format' is non-'nil', Emacs obeys
'ls-lisp-format-time-list' even if the current locale is available; see
below.)

   The value of 'ls-lisp-format-time-list' is a list of 2 strings.  The
first string is used if the file was modified within the current year,
while the second string is used for older files.  In each of these two
strings you can use '%'-sequences to substitute parts of the time.  For
example:
     ("%b %e %H:%M" "%b %e  %Y")

Note that the strings substituted for these '%'-sequences depend on the
current locale.  *Note (elisp)Time Parsing::, for more about format time
specs.

   Normally, Emacs formats the file time stamps in either traditional or
ISO-style time format.  However, if the value of the variable
'ls-lisp-use-localized-time-format' is non-'nil', Emacs formats file
time stamps according to what 'ls-lisp-format-time-list' specifies.  The
'%'-sequences in 'ls-lisp-format-time-list' produce locale-dependent
month and day names, which might cause misalignment of columns in Dired
display.  The default value of 'ls-lisp-use-localized-time-format' is
'nil'.

==============================================================================
File: emacs.info,  Node: |Windows_HOME|,  Next: |Windows_Keyboard|,  Prev: |ls_in_Lisp|,  Up: |Microsoft_Windows|
==============================================================================

                                                                  *Windows_HOME*

G.5 HOME and Startup Directories on MS-Windows
=====-----------------------------------------

The Windows equivalent of 'HOME' is the "user-specific application data
directory".  The actual location depends on the Windows version; typical
values are 'C:\Documents and Settings\USERNAME\Application Data' on
Windows 2000 up to XP, 'C:\Users\USERNAME\AppData\Roaming' on Windows
Vista and later, and either 'C:\WINDOWS\Application Data' or
'C:\WINDOWS\Profiles\USERNAME\Application Data' on Windows 9X/ME.  If
this directory does not exist or cannot be accessed, Emacs falls back to
'C:\' as the default value of 'HOME'.

   You can override this default value of 'HOME' by explicitly setting
the environment variable 'HOME' to point to any directory on your
system.  'HOME' can be set either from the command shell prompt or from
'Properties' dialog of 'My Computer'.  'HOME' can also be set in the
system registry, *note MS-Windows Registry::.

   For compatibility with older versions of Emacs(1), if there is a file
named '.emacs' in 'C:\', the root directory of drive 'C:', and 'HOME' is
set neither in the environment nor in the Registry, Emacs will treat
'C:\' as the default 'HOME' location, and will not look in the
application data directory, even if it exists.  Note that only '.emacs'
is looked for in 'C:\'; the older name '_emacs' (see below) is not.
This use of 'C:\.emacs' to define 'HOME' is deprecated; Emacs will
display a warning about its use during startup.

   Whatever the final place is, Emacs sets the internal value of the
'HOME' environment variable to point to it, and it will use that
location for other files and directories it normally looks for or
creates in your home directory.

   You can always find out what Emacs thinks is your home directory's
location by typing 'C-x d ~/ <RET>'.  This should present the list of
files in the home directory, and show its full name on the first line.
Likewise, to visit your init file, type 'C-x C-f ~/.emacs <RET>'
(assuming the file's name is '.emacs').

   Your init file can have any name mentioned in *note Init File::.

   Because MS-DOS does not allow file names with leading dots, and older
Windows systems made it hard to create files with such names, the
Windows port of Emacs supports an init file name '_emacs', if such a
file exists in the home directory and '.emacs' does not.  This name is
considered obsolete, so Emacs will display a warning if it is used.

   ---------- Footnotes ----------

   (1) Older versions of Emacs didn't check the application data
directory.

==============================================================================
File: emacs.info,  Node: |Windows_Keyboard|,  Next: |Windows_Mouse|,  Prev: |Windows_HOME|,  Up: |Microsoft_Windows|
==============================================================================

                                                              *Windows_Keyboard*

G.6 Keyboard Usage on MS-Windows
=====---------------------------

This section describes the Windows-specific features related to keyboard
input in Emacs.

   Many key combinations (known as "keyboard shortcuts") that have
conventional uses in MS-Windows programs conflict with traditional Emacs
key bindings.  (These Emacs key bindings were established years before
Microsoft was founded.)  Examples of conflicts include 'C-c', 'C-x',
'C-z', 'C-a', and 'W-<SPC>'.  You can redefine some of them with
meanings more like the MS-Windows meanings by enabling CUA Mode (*note
CUA Bindings::).  Another optional feature which will make Emacs behave
like other Windows applications is Delete Selection mode (*note Using
Region::).

   By default, the key labeled <Alt> is mapped as the <Meta> key.  If
you wish it to produce the 'Alt' modifier instead, set the variable
'w32-alt-is-meta' to a 'nil' value.

   MS-Windows reserves certain key combinations, such as '<Alt>-<TAB>'
and a number of Windows key combinations, for its own use.  These key
combinations are intercepted by the system before Emacs can see them.
Also, on Windows 10, all Windows key combinations are reserved by the
system in such a way that they are never propagated to applications,
even if the system does not currently define a hotkey on the specific
combination.  You can use the 'w32-register-hot-key' function to allow a
key sequence to be seen by Emacs instead of being grabbed by Windows.
When registered as a hot key, the key combination is pulled out of the
system's input queue before it is handled by Windows, effectively
overriding the special meaning of that key sequence for Windows.  The
override is only effective when Emacs is active; with other applications
on the foreground the keys behave normally.

   The argument to 'w32-register-hot-key' must be a single key with a
single modifier, in vector form that would be acceptable to
'define-key'.  The control and shift modifiers have no effect on the
argument.  The meta modifier is interpreted as the <Alt> key if
'w32-alt-is-meta' is 't' (the default), and the super and hyper
modifiers are interpreted according to the bindings of
'w32-lwindow-modifier' and 'w32-rwindow-modifier'.  Additionally, a
modifier with the trailing dash but with no key indicates that all
Windows defined hotkeys for that modifier are to be overridden in the
favor of Emacs.

   For example, '(w32-register-hot-key [M-tab])' lets you use 'M-<TAB>'
normally in Emacs; for instance, to complete the word or symbol at point
at top level, or to complete the current search string against
previously sought strings during incremental search.
'(w32-register-hot-key [s-])' with 'w32-lwindow-modifier' bound to
'super' disables all the Windows' own Windows key based shortcuts.(1)

   Note that 'w32-register-hot-key' checks the 'w32-[lr]window-modifier'
values at the time of the function call.  Thus, you can set
'w32-lwindow-modifier' as 'super', then call '(w32-register-hot-key
[s-r])', and finally set 'w32-rwindow-modifier' as 'super' as well.  The
result is that the left Windows key together with 'R' invokes whichever
function you have bound for the combination in Emacs, and the right
Windows key and 'R' opens the Windows 'Run' dialog.

   The hotkey registrations always also include all the shift and
control modifier combinations for the given hotkey; that is, registering
's-a' as a hotkey gives you 'S-s-a', 'C-s-a' and 'C-S-s-a' as well.

   On Windows 98 and ME, the hotkey registration is more restricted.
The desired hotkey must always be fully specified, and
'w32-phantom-key-code' can be customized to achieve desired results.

   The function 'w32-unregister-hot-key' reverses the effect of
'w32-register-hot-key' for its argument key sequence.

   By default, the <CapsLock> key only affects normal character keys (it
converts lower-case characters to their upper-case variants).  However,
if you set the variable 'w32-capslock-is-shiftlock' to a non-'nil'
value, the <CapsLock> key will affect non-character keys as well, as if
you pressed the <SHIFT> key while typing the non-character key.

   If the variable 'w32-enable-caps-lock' is set to a 'nil' value, the
<CapsLock> key produces the symbol 'capslock' instead of the shifted
version of typed keys.  The default value is 't'.

   Similarly, if 'w32-enable-num-lock' is 'nil', the <NumLock> key will
produce the symbol 'kp-numlock'.  The default is 't', which causes
<NumLock> to work as expected: toggle the meaning of the keys on the
numeric keypad.

   The variable 'w32-apps-modifier' controls the effect of the <Apps>
key (usually located between the right <Alt> and the right <Ctrl> keys).
Its value can be one of the symbols 'hyper', 'super', 'meta', 'alt',
'control', or 'shift' for the respective modifier, or 'nil' to appear as
the key 'apps'.  The default is 'nil'.

   The variable 'w32-lwindow-modifier' determines the effect of the left
Windows key (usually labeled with <start> and the Windows logo).  If its
value is 'nil' (the default), the key will produce the symbol 'lwindow'.
Setting it to one of the symbols 'hyper', 'super', 'meta', 'alt',
'control', or 'shift' will produce the respective modifier.  A similar
variable 'w32-rwindow-modifier' controls the effect of the right Windows
key, and 'w32-scroll-lock-modifier' does the same for the <ScrLock> key.
If these variables are set to 'nil', the right Windows key produces the
symbol 'rwindow' and <ScrLock> produces the symbol 'scroll'.  If you
want <ScrLock> to produce the same effect as in other applications, i.e.
toggle the Scroll Lock LED indication on the keyboard, set
'w32-scroll-lock-modifier' to 't' or any non-'nil' value other than the
above modifier symbols.

   Emacs compiled as a native Windows application normally turns off the
Windows feature that tapping the <Alt> key invokes the Windows menu.
The reason is that the <Alt> serves as <Meta> in Emacs.  When using
Emacs, users often press the <Meta> key temporarily and then change
their minds; if this has the effect of bringing up the Windows menu, it
alters the meaning of subsequent commands.  Many users find this
frustrating.

   You can re-enable Windows's default handling of tapping the <Alt> key
by setting 'w32-pass-alt-to-system' to a non-'nil' value.

   The variables 'w32-pass-lwindow-to-system' and
'w32-pass-rwindow-to-system' determine whether the respective keys are
passed to Windows or swallowed by Emacs.  If the value is 'nil', the
respective key is silently swallowed by Emacs, otherwise it is passed to
Windows.  The default is 't' for both of these variables.  Passing each
of these keys to Windows produces its normal effect: for example,
'<Lwindow>' opens the 'Start' menu, etc.

   The variable 'w32-recognize-altgr' controls whether the <AltGr> key
(if it exists on your keyboard), or its equivalent, the combination of
the right <Alt> and left <Ctrl> keys pressed together, is recognized as
the <AltGr> key.  The default is 't', which means these keys produce
'AltGr'; setting it to 'nil' causes <AltGr> or the equivalent key
combination to be interpreted as the combination of <Ctrl> and <Meta>
modifiers.

   ---------- Footnotes ----------

   (1) There is one known exception: The combination '<Windows>-L' that
locks the workstation is handled by the system on a lower level.  For
this reason, 'w32-register-hot-key' cannot override this key combination
- it always locks the computer.

==============================================================================
File: emacs.info,  Node: |Windows_Mouse|,  Next: |Windows_Processes|,  Prev: |Windows_Keyboard|,  Up: |Microsoft_Windows|
==============================================================================

                                                                 *Windows_Mouse*

G.7 Mouse Usage on MS-Windows
=====------------------------

This section describes the Windows-specific variables related to the
mouse.

   The variable 'w32-mouse-button-tolerance' specifies the time
interval, in milliseconds, for faking middle mouse button press on
2-button mice.  If both mouse buttons are depressed within this time
interval, Emacs generates a middle mouse button click event instead of a
double click on one of the buttons.

   If the variable 'w32-pass-extra-mouse-buttons-to-system' is
non-'nil', Emacs passes the fourth and fifth mouse buttons to Windows.

   The variable 'w32-swap-mouse-buttons' controls which of the 3 mouse
buttons generates the 'mouse-2' events.  When it is 'nil' (the default),
the middle button generates 'mouse-2' and the right button generates
'mouse-3' events.  If this variable is non-'nil', the roles of these two
buttons are reversed.

==============================================================================
File: emacs.info,  Node: |Windows_Processes|,  Next: |Windows_Printing|,  Prev: |Windows_Mouse|,  Up: |Microsoft_Windows|
==============================================================================

                                                             *Windows_Processes*

G.8 Subprocesses on Windows 9X/ME and Windows NT/2K/XP/Vista/7/8/10
=====--------------------------------------------------------------

Emacs compiled as a native Windows application (as opposed to the DOS
version) includes full support for asynchronous subprocesses.  In the
Windows version, synchronous and asynchronous subprocesses work fine on
all versions of MS-Windows, as long as you run only 32-bit or 64-bit
Windows applications.  However, when you run a DOS application in a
subprocess, you may encounter problems or be unable to run the
application at all; and if you run two DOS applications at the same time
in two subprocesses, you may have to reboot your system.

   Since the standard command interpreter (and most command line
utilities) on Windows 9X are DOS applications, these problems are
significant when using that system.  But there's nothing we can do about
them; only Microsoft can fix them.

   If you run just one DOS application subprocess, the subprocess should
work as expected as long as it is "well-behaved" and does not perform
direct screen access or other unusual actions.  If you have a CPU
monitor application, your machine will appear to be 100% busy even when
the DOS application is idle, but this is only an artifact of the way CPU
monitors measure processor load.

   You must terminate the DOS application before you start any other DOS
application in a different subprocess.  Emacs is unable to interrupt or
terminate a DOS subprocess.  The only way you can terminate such a
subprocess is by giving it a command that tells its program to exit.

   If you attempt to run two DOS applications at the same time in
separate subprocesses, the second one that is started will be suspended
until the first one finishes, even if either or both of them are
asynchronous.

   If you can go to the first subprocess, and tell it to exit, the
second subprocess should continue normally.  However, if the second
subprocess is synchronous, Emacs itself will be hung until the first
subprocess finishes.  If it will not finish without user input, then you
have no choice but to reboot if you are running on Windows 9X.  If you
are running on Windows NT and later, you can use a process viewer
application to kill the appropriate instance of NTVDM instead (this will
terminate both DOS subprocesses).

   If you have to reboot Windows 9X in this situation, do not use the
'Shutdown' command on the 'Start' menu; that usually hangs the system.
Instead, type '<Ctrl>-<Alt>-<DEL>' and then choose 'Shutdown'.  That
usually works, although it may take a few minutes to do its job.

   The variable 'w32-quote-process-args' controls how Emacs quotes the
process arguments.  Non-'nil' means quote with the '"' character.  If
the value is a character, Emacs uses that character to escape any quote
characters that appear; otherwise it chooses a suitable escape character
based on the type of the program.

   The variable 'w32-pipe-buffer-size' controls the size of the buffer
Emacs requests from the system when it creates pipes for communications
with subprocesses.  The default value is zero, which lets the OS choose
the size.  Any valid positive value will request a buffer of that size
in bytes.  This can be used to tailor communications with subprocesses
to programs that exhibit unusual behavior with respect to buffering pipe
I/O.

   If you need to invoke MS-DOS programs as Emacs subprocesses, you may
see low rate of reading data from such programs.  Setting the variable
'w32-pipe-read-delay' to a non-zero value may improve throughput in
these cases; we suggest the value of 50 for such situations.  The
default is zero.

   The function 'w32-shell-execute' can be useful for writing customized
commands that run MS-Windows applications registered to handle a certain
standard Windows operation for a specific type of document or file.
This function is a wrapper around the Windows 'ShellExecute' API.  See
the MS-Windows API documentation for more details.

==============================================================================
File: emacs.info,  Node: |Windows_Printing|,  Next: |Windows_Fonts|,  Prev: |Windows_Processes|,  Up: |Microsoft_Windows|
==============================================================================

                                                              *Windows_Printing*

G.9 Printing and MS-Windows
=====----------------------

Printing commands, such as 'lpr-buffer' (*note Printing::) and
'ps-print-buffer' (*note PostScript::) work in MS-DOS and MS-Windows by
sending the output to one of the printer ports, if a POSIX-style 'lpr'
program is unavailable.  The same Emacs variables control printing on
all systems, but in some cases they have different default values on
MS-DOS and MS-Windows.

   Emacs on MS Windows attempts to determine your default printer
automatically (using the function 'default-printer-name').  But in some
rare cases this can fail, or you may wish to use a different printer
from within Emacs.  The rest of this section explains how to tell Emacs
which printer to use.

   If you want to use your local printer, then set the Lisp variable
'lpr-command' to '""' (its default value on Windows) and 'printer-name'
to the name of the printer port--for example, '"PRN"', the usual local
printer port, or '"LPT2"', or '"COM1"' for a serial printer.  You can
also set 'printer-name' to a file name, in which case "printed" output
is actually appended to that file.  If you set 'printer-name' to
'"NUL"', printed output is silently discarded (sent to the system null
device).

   You can also use a printer shared by another machine by setting
'printer-name' to the UNC share name for that printer--for example,
'"//joes_pc/hp4si"'.  (It doesn't matter whether you use forward slashes
or backslashes here.)  To find out the names of shared printers, run the
command 'net view' from the command prompt to obtain a list of servers,
and 'net view SERVER-NAME' to see the names of printers (and
directories) shared by that server.  Alternatively, click the 'Network
Neighborhood' icon on your desktop, and look for machines that share
their printers via the network.

   If the printer doesn't appear in the output of 'net view', or if
setting 'printer-name' to the UNC share name doesn't produce a hardcopy
on that printer, you can use the 'net use' command to connect a local
print port such as '"LPT2"' to the networked printer.  For example,
typing 'net use LPT2: \\joes_pc\hp4si'(1) causes Windows to "capture"
the 'LPT2' port and redirect the printed material to the printer
connected to the machine 'joes_pc'.  After this command, setting
'printer-name' to '"LPT2"' should produce the hardcopy on the networked
printer.

   With some varieties of Windows network software, you can instruct
Windows to capture a specific printer port such as '"LPT2"', and
redirect it to a networked printer via the 'Control Panel->Printers'
applet instead of 'net use'.

   If you set 'printer-name' to a file name, it's best to use an
absolute file name.  Emacs changes the working directory according to
the default directory of the current buffer, so if the file name in
'printer-name' is relative, you will end up with several such files,
each one in the directory of the buffer from which the printing was
done.

   If the value of 'printer-name' is correct, but printing does not
produce the hardcopy on your printer, it is possible that your printer
does not support printing plain text (some cheap printers omit this
functionality).  In that case, try the PostScript print commands,
described below.

   The commands 'print-buffer' and 'print-region' call the 'pr' program,
or use special switches to the 'lpr' program, to produce headers on each
printed page.  MS-DOS and MS-Windows don't normally have these programs,
so by default, the variable 'lpr-headers-switches' is set so that the
requests to print page headers are silently ignored.  Thus,
'print-buffer' and 'print-region' produce the same output as
'lpr-buffer' and 'lpr-region', respectively.  If you do have a suitable
'pr' program (for example, from GNU Coreutils), set
'lpr-headers-switches' to 'nil'; Emacs will then call 'pr' to produce
the page headers, and print the resulting output as specified by
'printer-name'.

   Finally, if you do have an 'lpr' work-alike, you can set the variable
'lpr-command' to '"lpr"'.  Then Emacs will use 'lpr' for printing, as on
other systems.  (If the name of the program isn't 'lpr', set
'lpr-command' to the appropriate value.)  The variable 'lpr-switches'
has its standard meaning when 'lpr-command' is not '""'.  If the
variable 'printer-name' has a string value, it is used as the value for
the '-P' option to 'lpr', as on Unix.

   A parallel set of variables, 'ps-lpr-command', 'ps-lpr-switches', and
'ps-printer-name' (*note PostScript Variables::), defines how PostScript
files should be printed.  These variables are used in the same way as
the corresponding variables described above for non-PostScript printing.
Thus, the value of 'ps-printer-name' is used as the name of the device
(or file) to which PostScript output is sent, just as 'printer-name' is
used for non-PostScript printing.  (There are two distinct sets of
variables in case you have two printers attached to two different ports,
and only one of them is a PostScript printer.)

   The default value of the variable 'ps-lpr-command' is '""', which
causes PostScript output to be sent to the printer port specified by
'ps-printer-name'; but 'ps-lpr-command' can also be set to the name of a
program which will accept PostScript files.  Thus, if you have a
non-PostScript printer, you can set this variable to the name of a
PostScript interpreter program (such as Ghostscript).  Any switches that
need to be passed to the interpreter program are specified using
'ps-lpr-switches'.  (If the value of 'ps-printer-name' is a string, it
will be added to the list of switches as the value for the '-P' option.
This is probably only useful if you are using 'lpr', so when using an
interpreter typically you would set 'ps-printer-name' to something other
than a string so it is ignored.)

   For example, to use Ghostscript for printing on the system's default
printer, put this in your '.emacs' file:

     (setq ps-printer-name t)
     (setq ps-lpr-command "D:/gs6.01/bin/gswin32c.exe")
     (setq ps-lpr-switches '("-q" "-dNOPAUSE" "-dBATCH"
                             "-sDEVICE=mswinpr2"
                             "-sPAPERSIZE=a4"))

(This assumes that Ghostscript is installed in the 'D:/gs6.01'
directory.)

   ---------- Footnotes ----------

   (1) Note that the 'net use' command requires the UNC share name to be
typed with the Windows-style backslashes, while the value of
'printer-name' can be set with either forward- or backslashes.

==============================================================================
File: emacs.info,  Node: |Windows_Fonts|,  Next: |Windows_Misc|,  Prev: |Windows_Printing|,  Up: |Microsoft_Windows|
==============================================================================

                                                                 *Windows_Fonts*

G.10 Specifying Fonts on MS-Windows
=====------------------------------

Starting with Emacs 23, fonts are specified by their name, size and
optional properties.  The format for specifying fonts comes from the
fontconfig library used in modern Free desktops:

       [Family[-PointSize]][:Option1=Value1[:Option2=Value2[...]]]

   The old XLFD based format is also supported for backwards
compatibility.

   Emacs on MS-Windows supports a number of font backends.  Currently,
the 'gdi', 'uniscribe', and 'harfbuzz' backends are available.  The
'gdi' font backend is available on all versions of Windows, and supports
all fonts that are natively supported by Windows.  The 'uniscribe' font
backend is available on Windows 2000 and later, and supports TrueType
and OpenType fonts.  The 'harfbuzz' font backend is available if Emacs
was built with HarfBuzz support, and if the HarfBuzz DLL is installed on
your system; like 'uniscribe', this backend supports only TrueType and
OpenType fonts.  Some languages requiring complex layout can only be
properly supported by the Uniscribe or HarfBuzz backends.  By default,
two backends are enabled for each frame: 'gdi' and either 'harfbuzz' or
'uniscribe', depending on which one is available (if both are available,
only 'harfbuzz' is enabled by default).  The 'harfbuzz' and 'uniscribe'
backends take priority over 'gdi' when Emacs looks for a suitable font.
To override that and use the GDI backend even if Uniscribe is available,
invoke Emacs with the '-xrm Emacs.fontBackend:gdi' command-line
argument, or add a 'Emacs.fontBackend' resource with the value 'gdi' in
the Registry under either the 'HKEY_CURRENT_USER\SOFTWARE\GNU\Emacs' or
the 'HKEY_LOCAL_MACHINE\SOFTWARE\GNU\Emacs' key (*note Resources::).
Similarly, to use the Uniscribe backend even if HarfBuzz is available,
use '-xrm Emacs.fontBackend:uniscribe' on the command line that invokes
Emacs.  You can also request all the 3 backends via the 'font-backend'
frame parameter, but be warned that in that case font searches for
characters for which no fonts are available on the system will take
longer.

   Alternatively, you could specify a font backend for a frame via the
'font-backend' frame parameter, using 'modify-frame-parameters' (*note
(elisp)Parameter Access::).  You can also request specific font
backend(s) for all your frames via 'default-frame-alist' and
'initial-frame-alist' (*note Frame Parameters::).  Note that the value
of the 'font-backend' parameter should be a list of symbols, as in
'(uniscribe)' or '(harfbuzz uniscribe gdi)'.

Optional font properties supported on MS-Windows are:

'weight'
     Specifies the weight of the font.  Special values 'light',
     'medium', 'demibold', 'bold', and 'black' can be specified without
     'weight=' (e.g., 'Courier New-12:bold').  Otherwise, the weight
     should be a numeric value between 100 and 900, or one of the named
     weights in 'font-weight-table'.  If unspecified, a regular font is
     assumed.

'slant'
     Specifies whether the font is italic.  Special values 'roman',
     'italic' and 'oblique' can be specified without 'slant=' (e.g.,
     'Courier New-12:italic').  Otherwise, the slant should be a numeric
     value, or one of the named slants in 'font-slant-table'.  On
     Windows, any slant above 150 is treated as italics, and anything
     below as roman.

'family'
     Specifies the font family, but normally this will be specified at
     the start of the font name.

'pixelsize'
     Specifies the font size in pixels.  This can be used instead of the
     point size specified after the family name.

'adstyle'
     Specifies additional style information for the font.  On
     MS-Windows, the values 'mono', 'sans', 'serif', 'script' and
     'decorative' are recognized.  These are most useful as a fallback
     with the font family left unspecified.

'registry'
     Specifies the character set registry that the font is expected to
     cover.  Most TrueType and OpenType fonts will be Unicode fonts that
     cover several national character sets, but you can narrow down the
     selection of fonts to those that support a particular character set
     by using a specific registry from 'w32-charset-info-alist' here.

'spacing'
     Specifies how the font is spaced.  The 'p' spacing specifies a
     proportional font, and 'm' or 'c' specify a monospaced font.

'foundry'
     Not used on Windows, but for informational purposes and to prevent
     problems with code that expects it to be set, is set internally to
     'raster' for bitmapped fonts, 'outline' for scalable fonts, or
     'unknown' if the type cannot be determined as one of those.

'script'
     Specifies a Unicode subrange the font should support.

     All the scripts known to Emacs (which generally means all the
     scripts defined by the latest Unicode Standard) are recognized on
     MS-Windows.  However, 'GDI' fonts support only a subset of the
     known scripts: 'greek', 'hangul', 'kana', 'kanbun', 'bopomofo',
     'tibetan', 'yi', 'mongolian', 'hebrew', 'arabic', and 'thai'.

'antialias'
     Specifies the antialiasing method.  The value 'none' means no
     antialiasing, 'standard' means use standard antialiasing,
     'subpixel' means use subpixel antialiasing (known as "Cleartype" on
     Windows), and 'natural' means use subpixel antialiasing with
     adjusted spacing between letters.  If unspecified, the font will
     use the system default antialiasing.

   The method used by Emacs on MS-Windows to look for fonts suitable for
displaying a given non-ASCII character might fail for some rare scripts,
specifically those added by Unicode relatively recently, even if you
have fonts installed on your system that support those scripts.  That is
because these scripts have no Unicode Subrange Bits (USBs) defined for
them in the information used by Emacs on MS-Windows to look for fonts.
You can use the 'w32-find-non-USB-fonts' function to overcome these
problems.  It needs to be run once at the beginning of the Emacs
session, and again if you install new fonts.  You can add the following
line to your init file to have this function run every time you start
Emacs:

     (w32-find-non-USB-fonts)

Alternatively, you can run this function manually via 'M-:' (*note Lisp
Eval::) at any time.  On a system that has many fonts installed, running
'w32-find-non-USB-fonts' might take a couple of seconds; if you consider
that to be too long to be run during startup, and if you install new
fonts only rarely, run this function once via 'M-:', and then assign the
value it returns, if non-'nil', to the variable 'w32-non-USB-fonts' in
your init file.  (If the function returns 'nil', you have no fonts
installed that can display characters from the scripts which need this
facility.)

   The variable 'w32-use-w32-font-dialog' controls the way fonts can be
selected via 'S-mouse-1' ('mouse-appearance-menu').  If the value is
't', the default, Emacs uses the standard Windows font selection dialog.
If the value is 'nil', Emacs instead pops a menu of a fixed set of
fonts.  The fonts to appear in the menu are determined by
'w32-fixed-font-alist'.

==============================================================================
File: emacs.info,  Node: |Windows_Misc|,  Next: |MS_DOS|,  Prev: |Windows_Fonts|,  Up: |Microsoft_Windows|
==============================================================================

                                                                  *Windows_Misc*

G.11 Miscellaneous Windows-specific features
=====---------------------------------------

This section describes Windows-specific features that don't fit anywhere
else.

   The variable 'w32-use-visible-system-caret' is a flag that determines
whether to make the system caret visible.  The default when no screen
reader software is in use is 'nil', which means Emacs draws its own
cursor to indicate the position of point.  A non-'nil' value means Emacs
will indicate point location with the system caret; this facilitates use
of screen reader software, and is the default when such software is
detected when running Emacs.  When this variable is non-'nil', other
variables affecting the cursor display have no effect.

   The variable 'w32-grab-focus-on-raise', if set to a non-'nil' value
causes a frame to grab focus when it is raised.  The default is 't',
which fits well with the Windows default click-to-focus policy.

==============================================================================
File: emacs.info,  Node: |MS_DOS|,  Prev: |Windows_Misc|,  Up: |Microsoft_Windows|
==============================================================================

                                                                        *MS_DOS*

G.12 Emacs and MS-DOS
=====----------------

This section briefly describes the peculiarities of using Emacs on
MS-DOS. Information about peculiarities common to MS-DOS and Microsoft's
current operating systems Windows is in *note Microsoft Windows::.

   If you build Emacs for MS-DOS, the binary will also run on Windows
3.X, Windows NT, Windows 9X/ME, or Windows 2000/XP as a DOS application;
all of this chapter applies for all of those systems, if you use an
Emacs that was built for MS-DOS.

   *Note Text and Binary::, for information about Emacs's special
handling of text files under MS-DOS (and Windows).

MENU

* Keyboard: MS-DOS Keyboard.   Keyboard conventions on MS-DOS.
* Mouse: MS-DOS Mouse.         Mouse conventions on MS-DOS.
* Display: MS-DOS Display.     Fonts, frames and display size on MS-DOS.
* Files: MS-DOS File Names.    File name conventions on MS-DOS.
* Printing: MS-DOS Printing.   Printing specifics on MS-DOS.
* I18N: MS-DOS and MULE.       Support for internationalization on MS-DOS.
* Processes: MS-DOS Processes. Running subprocesses on MS-DOS.

==============================================================================
File: emacs.info,  Node: |MS_DOS_Keyboard|,  Next: |MS_DOS_Mouse|,  Up: |MS_DOS|
==============================================================================

                                                               *MS_DOS_Keyboard*

G.12.1 Keyboard Usage on MS-DOS
-------------------------------

The key that is called <DEL> in Emacs (because that's how it is
designated on most workstations) is known as <BS> (backspace) on a PC.
That is why the PC-specific terminal initialization remaps the <BS> key
to act as <DEL>; the <Delete> key is remapped to act as 'C-d' for the
same reasons.

   Emacs built for MS-DOS recognizes 'C-<Break>' as a quit character,
just like 'C-g'.  This is because Emacs cannot detect that you have
typed 'C-g' until it is ready for more input.  As a consequence, you
cannot use 'C-g' to stop a running command (*note Quitting::).  By
contrast, 'C-<Break>' _is_ detected as soon as you type it (as 'C-g' is
on other systems), so it can be used to stop a running command and for
emergency escape (*note Emergency Escape::).

   The PC keyboard maps use the left <Alt> key as the <Meta> key.  You
have two choices for emulating the <SUPER> and <Hyper> keys: choose
either the right <Ctrl> key or the right <Alt> key by setting the
variables 'dos-hyper-key' and 'dos-super-key' to 1 or 2 respectively.
If neither 'dos-super-key' nor 'dos-hyper-key' is 1, then by default the
right <Alt> key is also mapped to the <Meta> key.  However, if the
MS-DOS international keyboard support program 'KEYB.COM' is installed,
Emacs will _not_ map the right <Alt> to <Meta>, since it is used for
accessing characters like '~' and '@' on non-US keyboard layouts; in
this case, you may only use the left <Alt> as <Meta> key.

   The variable 'dos-keypad-mode' is a flag variable that controls what
key codes are returned by keys in the numeric keypad.  You can also
define the keypad <ENTER> key to act like 'C-j', by putting the
following line into your '_emacs' file:

     ;; Make the <ENTER> key from the numeric keypad act as 'C-j'.
     (define-key function-key-map [kp-enter] [?\C-j])

==============================================================================
File: emacs.info,  Node: |MS_DOS_Mouse|,  Next: |MS_DOS_Display|,  Prev: |MS_DOS_Keyboard|,  Up: |MS_DOS|
==============================================================================

                                                                  *MS_DOS_Mouse*

G.12.2 Mouse Usage on MS-DOS
----------------------------

Emacs on MS-DOS supports a mouse (on the default terminal only).  The
mouse commands work as documented, including those that use menus and
the menu bar (*note Menu Bar::).  Scroll bars don't work in MS-DOS
Emacs.  PC mice usually have only two buttons; these act as 'mouse-1'
and 'mouse-2', but if you press both of them together, that has the
effect of 'mouse-3'.  If the mouse does have 3 buttons, Emacs detects
that at startup, and all the 3 buttons function normally, as on X.

   Help strings for menu-bar and pop-up menus are displayed in the echo
area when the mouse pointer moves across the menu items.  Highlighting
of mouse-sensitive text (*note Mouse References::) is also supported.

   Some versions of mouse drivers don't report the number of mouse
buttons correctly.  For example, mice with a wheel report that they have
3 buttons, but only 2 of them are passed to Emacs; the clicks on the
wheel, which serves as the middle button, are not passed.  In these
cases, you can use the 'M-x msdos-set-mouse-buttons' command to tell
Emacs how many mouse buttons to expect.  You could make such a setting
permanent by adding this fragment to your '_emacs' init file:

     ;; Treat the mouse like a 2-button mouse.
     (msdos-set-mouse-buttons 2)

   Emacs built for MS-DOS supports clipboard operations when it runs on
Windows.  Commands that put text on the kill ring, or yank text from the
ring, check the Windows clipboard first, just as Emacs does on the X
Window System (*note Mouse Commands::).  Only the primary selection and
the cut buffer are supported by MS-DOS Emacs on Windows; the secondary
selection always appears as empty.

   Due to the way clipboard access is implemented by Windows, the length
of text you can put into the clipboard is limited by the amount of free
DOS memory that is available to Emacs.  Usually, up to 620KB of text can
be put into the clipboard, but this limit depends on the system
configuration and is lower if you run Emacs as a subprocess of another
program.  If the killed text does not fit, Emacs outputs a message
saying so, and does not put the text into the clipboard.

   Null characters also cannot be put into the Windows clipboard.  If
the killed text includes null characters, Emacs does not put such text
into the clipboard, and displays in the echo area a message to that
effect.

   The variable 'dos-display-scancodes', when non-'nil', directs Emacs
to display the ASCII value and the keyboard scan code of each keystroke;
this feature serves as a complement to the 'view-lossage' command, for
debugging.

==============================================================================
File: emacs.info,  Node: |MS_DOS_Display|,  Next: |MS_DOS_File_Names|,  Prev: |MS_DOS_Mouse|,  Up: |MS_DOS|
==============================================================================

                                                                *MS_DOS_Display*

G.12.3 Display on MS-DOS
------------------------

Display on MS-DOS cannot use font variants, like bold or italic, but it
does support multiple faces, each of which can specify a foreground and
a background color.  Therefore, you can get the full functionality of
Emacs packages that use fonts (such as 'font-lock', Enriched Text mode,
and others) by defining the relevant faces to use different colors.  Use
the 'list-colors-display' command (*note Colors::) and the
'list-faces-display' command (*note Faces::) to see what colors and
faces are available and what they look like.

   *Note MS-DOS and MULE::, later in this chapter, for information on
how Emacs displays glyphs and characters that aren't supported by the
native font built into the DOS display.

   When Emacs starts, it changes the cursor shape to a solid box.  This
is for compatibility with other systems, where the box cursor is the
default in Emacs.  This default shape can be changed to a bar by
specifying the 'cursor-type' parameter in the variable
'default-frame-alist' (*note Creating Frames::).  The MS-DOS terminal
doesn't support a vertical-bar cursor, so the bar cursor is horizontal,
and the 'WIDTH' parameter, if specified by the frame parameters,
actually determines its height.  For this reason, the 'bar' and 'hbar'
cursor types produce the same effect on MS-DOS.  As an extension, the
bar cursor specification can include the starting scan line of the
cursor as well as its width, like this:

      '(cursor-type bar WIDTH . START)

In addition, if the WIDTH parameter is negative, the cursor bar begins
at the top of the character cell.

   The MS-DOS terminal can only display a single frame at a time.  The
Emacs frame facilities work on MS-DOS much as they do on text terminals
(*note Frames::).  When you run Emacs from a DOS window on MS-Windows,
you can make the visible frame smaller than the full screen, but Emacs
still cannot display more than a single frame at a time.

   The 'dos-mode4350' command switches the display to 43 or 50 lines,
depending on your hardware; the 'dos-mode25' command switches to the
default 80x25 screen size.

   By default, Emacs only knows how to set screen sizes of 80 columns by
25, 28, 35, 40, 43 or 50 rows.  However, if your video adapter has
special video modes that will switch the display to other sizes, you can
have Emacs support those too.  When you ask Emacs to switch the frame to
N rows by M columns dimensions, it checks if there is a variable called
'screen-dimensions-NxM', and if so, uses its value (which must be an
integer) as the video mode to switch to.  (Emacs switches to that video
mode by calling the BIOS 'Set Video Mode' function with the value of
'screen-dimensions-NxM' in the 'AL' register.)  For example, suppose
your adapter will switch to 66x80 dimensions when put into video mode
85.  Then you can make Emacs support this screen size by putting the
following into your '_emacs' file:

     (setq screen-dimensions-66x80 85)

   Since Emacs on MS-DOS can only set the frame size to specific
supported dimensions, it cannot honor every possible frame resizing
request.  When an unsupported size is requested, Emacs chooses the next
larger supported size beyond the specified size.  For example, if you
ask for 36x80 frame, you will get 40x80 instead.

   The variables 'screen-dimensions-NxM' are used only when they exactly
match the specified size; the search for the next larger supported size
ignores them.  In the above example, even if your VGA supports 38x80
dimensions and you define a variable 'screen-dimensions-38x80' with a
suitable value, you will still get 40x80 screen when you ask for a 36x80
frame.  If you want to get the 38x80 size in this case, you can do it by
setting the variable named 'screen-dimensions-36x80' with the same video
mode value as 'screen-dimensions-38x80'.

   Changing frame dimensions on MS-DOS has the effect of changing all
the other frames to the new dimensions.

==============================================================================
File: emacs.info,  Node: |MS_DOS_File_Names|,  Next: |MS_DOS_Printing|,  Prev: |MS_DOS_Display|,  Up: |MS_DOS|
==============================================================================

                                                             *MS_DOS_File_Names*

G.12.4 File Names on MS-DOS
---------------------------

On MS-DOS, file names are case-insensitive and limited to eight
characters, plus optionally a period and three more characters.  Emacs
knows enough about these limitations to handle file names that were
meant for other operating systems.  For instance, leading dots '.' in
file names are invalid in MS-DOS, so Emacs transparently converts them
to underscores '_'; thus your default init file (*note Init File::) is
called '_emacs' on MS-DOS.  Excess characters before or after the period
are generally ignored by MS-DOS itself; thus, if you visit the file
'LongFileName.EvenLongerExtension', you will silently get
'longfile.eve', but Emacs will still display the long file name on the
mode line.  Other than that, it's up to you to specify file names which
are valid under MS-DOS; the transparent conversion as described above
only works on file names built into Emacs.

   The above restrictions on the file names on MS-DOS make it almost
impossible to construct the name of a backup file (*note Backup Names::)
without losing some of the original file name characters.  For example,
the name of a backup file for 'docs.txt' is 'docs.tx~' even if single
backup is used.

   If you run Emacs as a DOS application under Windows 9X, Windows ME,
or Windows 2000/XP, you can turn on support for long file names.  If you
do that, Emacs doesn't truncate file names or convert them to lower
case; instead, it uses the file names that you specify, verbatim.  To
enable long file name support, set the environment variable 'LFN' to 'y'
before starting Emacs.  Unfortunately, Windows NT doesn't allow DOS
programs to access long file names, so Emacs built for MS-DOS will only
see their short 8+3 aliases.

   MS-DOS has no notion of home directory, so Emacs on MS-DOS pretends
that the directory where it is installed is the value of the 'HOME'
environment variable.  That is, if your Emacs binary, 'emacs.exe', is in
the directory 'c:/utils/emacs/bin', then Emacs acts as if 'HOME' were
set to 'c:/utils/emacs'.  In particular, that is where Emacs looks for
the init file '_emacs'.  With this in mind, you can use '~' in file
names as an alias for the home directory, as you would on GNU or Unix.
You can also set 'HOME' variable in the environment before starting
Emacs; its value will then override the above default behavior.

   Emacs on MS-DOS handles the name '/dev' specially, because of a
feature in the emulator libraries of DJGPP that pretends I/O devices
have names in that directory.  We recommend that you avoid using an
actual directory named '/dev' on any disk.

==============================================================================
File: emacs.info,  Node: |MS_DOS_Printing|,  Next: |MS_DOS_and_MULE|,  Prev: |MS_DOS_File_Names|,  Up: |MS_DOS|
==============================================================================

                                                               *MS_DOS_Printing*

G.12.5 Printing and MS-DOS
--------------------------

Printing commands, such as 'lpr-buffer' (*note Printing::) and
'ps-print-buffer' (*note PostScript::) can work on MS-DOS by sending the
output to one of the printer ports, if a POSIX-style 'lpr' program is
unavailable.  The same Emacs variables control printing on all systems,
but in some cases they have different default values on MS-DOS.

   *Note Windows Printing::, for details about setting up printing to a
networked printer.

   Some printers expect DOS codepage encoding of non-ASCII text, even
though they are connected to a Windows machine that uses a different
encoding for the same locale.  For example, in the Latin-1 locale, DOS
uses codepage 850 whereas Windows uses codepage 1252.  *Note MS-DOS and
MULE::.  When you print to such printers from Windows, you can use the
'C-x <RET> c' ('universal-coding-system-argument') command before 'M-x
lpr-buffer'; Emacs will then convert the text to the DOS codepage that
you specify.  For example, 'C-x <RET> c cp850-dos <RET> M-x lpr-region
<RET>' will print the region while converting it to the codepage 850
encoding.

   For backwards compatibility, the value of 'dos-printer'
('dos-ps-printer'), if it has a value, overrides the value of
'printer-name' ('ps-printer-name'), on MS-DOS.

==============================================================================
File: emacs.info,  Node: |MS_DOS_and_MULE|,  Next: |MS_DOS_Processes|,  Prev: |MS_DOS_Printing|,  Up: |MS_DOS|
==============================================================================

                                                               *MS_DOS_and_MULE*

G.12.6 International Support on MS-DOS
--------------------------------------

Emacs on MS-DOS supports the same international character sets as it
does on GNU, Unix and other platforms (*note International::), including
coding systems for converting between the different character sets.
However, due to incompatibilities between MS-DOS/MS-Windows and other
systems, there are several DOS-specific aspects of this support that you
should be aware of.  This section describes these aspects.

   The description below is largely specific to the MS-DOS port of
Emacs, especially where it talks about practical implications for Emacs
users.

'M-x dos-codepage-setup'
     Set up Emacs display and coding systems as appropriate for the
     current DOS codepage.

   MS-DOS is designed to support one character set of 256 characters at
any given time, but gives you a variety of character sets to choose
from.  The alternative character sets are known as "DOS codepages".
Each codepage includes all 128 ASCII characters, but the other 128
characters (codes 128 through 255) vary from one codepage to another.
Each DOS codepage is identified by a 3-digit number, such as 850, 862,
etc.

   In contrast to X, which lets you use several fonts at the same time,
MS-DOS normally doesn't allow use of several codepages in a single
session.  MS-DOS was designed to load a single codepage at system
startup, and require you to reboot in order to change it(1).  Much the
same limitation applies when you run DOS executables on other systems
such as MS-Windows.

   For multibyte operation on MS-DOS, Emacs needs to know which
characters the chosen DOS codepage can display.  So it queries the
system shortly after startup to get the chosen codepage number, and
stores the number in the variable 'dos-codepage'.  Some systems return
the default value 437 for the current codepage, even though the actual
codepage is different.  (This typically happens when you use the
codepage built into the display hardware.)  You can specify a different
codepage for Emacs to use by setting the variable 'dos-codepage' in your
init file.

   Multibyte Emacs supports only certain DOS codepages: those which can
display Far-Eastern scripts, like the Japanese codepage 932, and those
that encode a single ISO 8859 character set.

   The Far-Eastern codepages can directly display one of the MULE
character sets for these countries, so Emacs simply sets up to use the
appropriate terminal coding system that is supported by the codepage.
The special features described in the rest of this section mostly
pertain to codepages that encode ISO 8859 character sets.

   For the codepages that correspond to one of the ISO character sets,
Emacs knows the character set based on the codepage number.  Emacs
automatically creates a coding system to support reading and writing
files that use the current codepage, and uses this coding system by
default.  The name of this coding system is 'cpNNN', where NNN is the
codepage number.(2)

   All the 'cpNNN' coding systems use the letter 'D' (for "DOS") as
their mode-line mnemonic.  Since both the terminal coding system and the
default coding system for file I/O are set to the proper 'cpNNN' coding
system at startup, it is normal for the mode line on MS-DOS to begin
with '-DD\-'.  *Note Mode Line::.  Far-Eastern DOS terminals do not use
the 'cpNNN' coding systems, and thus their initial mode line looks like
the Emacs default.

   Since the codepage number also indicates which script you are using,
Emacs automatically runs 'set-language-environment' to select the
language environment for that script (*note Language Environments::).

   If a buffer contains a character belonging to some other ISO 8859
character set, not the one that the chosen DOS codepage supports, Emacs
displays it using a sequence of ASCII characters.  For example, if the
current codepage doesn't have a glyph for the letter '??' (small 'o' with
a grave accent), it is displayed as '{`o}', where the braces serve as a
visual indication that this is a single character.  (This may look
awkward for some non-Latin characters, such as those from Greek or
Hebrew alphabets, but it is still readable by a person who knows the
language.)  Even though the character may occupy several columns on the
screen, it is really still just a single character, and all Emacs
commands treat it as one.

   MS-Windows provides its own codepages, which are different from the
DOS codepages for the same locale.  For example, DOS codepage 850
supports the same character set as Windows codepage 1252; DOS codepage
855 supports the same character set as Windows codepage 1251, etc.  The
MS-Windows version of Emacs uses the current codepage for display when
invoked with the '-nw' option.

   ---------- Footnotes ----------

   (1) Normally, one particular codepage is burnt into the display
memory, while other codepages can be installed by modifying system
configuration files, such as 'CONFIG.SYS', and rebooting.  While there
is third-party software that allows changing the codepage without
rebooting, we describe here how a stock MS-DOS system behaves.

   (2) The standard Emacs coding systems for ISO 8859 are not quite
right for the purpose, because typically the DOS codepage does not match
the standard ISO character codes.  For example, the letter 'c,' ('c' with
cedilla) has code 231 in the standard Latin-1 character set, but the
corresponding DOS codepage 850 uses code 135 for this glyph.

==============================================================================
File: emacs.info,  Node: |MS_DOS_Processes|,  Prev: |MS_DOS_and_MULE|,  Up: |MS_DOS|
==============================================================================

                                                              *MS_DOS_Processes*

G.12.7 Subprocesses on MS-DOS
-----------------------------

Because MS-DOS is a single-process "operating system", asynchronous
subprocesses are not available.  In particular, Shell mode and its
variants do not work.  Most Emacs features that use asynchronous
subprocesses also don't work on MS-DOS, including Shell mode and GUD.
When in doubt, try and see; commands that don't work output an error
message saying that asynchronous processes aren't supported.

   Compilation under Emacs with 'M-x compile', searching files with 'M-x
grep' and displaying differences between files with 'M-x diff' do work,
by running the inferior processes synchronously.  This means you cannot
do any more editing until the inferior process finishes.

   Spell checking also works, by means of special support for
synchronous invocation of the 'ispell' program.  This is slower than the
asynchronous invocation on other platforms

   Instead of the Shell mode, which doesn't work on MS-DOS, you can use
the 'M-x eshell' command.  This invokes the Eshell package that
implements a POSIX-like shell entirely in Emacs Lisp.

   By contrast, Emacs compiled as a native Windows application does
support asynchronous subprocesses.  *Note Windows Processes::.

   Printing commands, such as 'lpr-buffer' (*note Printing::) and
'ps-print-buffer' (*note PostScript::), work in MS-DOS by sending the
output to one of the printer ports.  *Note MS-DOS Printing::.

   When you run a subprocess synchronously on MS-DOS, make sure the
program terminates and does not try to read keyboard input.  If the
program does not terminate on its own, you will be unable to terminate
it, because MS-DOS provides no general way to terminate a process.
Pressing 'C-c' or 'C-<Break>' might sometimes help in these cases.

   Accessing files on other machines is not supported on MS-DOS.  Other
network-oriented commands such as sending mail, Web browsing, remote
login, etc., don't work either, unless network access is built into
MS-DOS with some network redirector.

   Dired on MS-DOS uses the 'ls-lisp' package (*note ls in Lisp::).
Therefore, Dired on MS-DOS supports only some of the possible options
you can mention in the 'dired-listing-switches' variable.  The options
that work are '-A', '-a', '-c', '-i', '-r', '-S', '-s', '-t', and '-u'.

==============================================================================
File: emacs.info,  Node: |Manifesto|,  Next: |Glossary|,  Prev: |Microsoft_Windows|,  Up: |Top|
==============================================================================

                                                                     *Manifesto*

The GNU Manifesto
*****============

     The GNU Manifesto which appears below was written by Richard
     Stallman at the beginning of the GNU project, to ask for
     participation and support.  For the first few years, it was updated
     in minor ways to account for developments, but now it seems best to
     leave it unchanged as most people have seen it.

     Since that time, we have learned about certain common
     misunderstandings that different wording could help avoid.
     Footnotes added in 1993 help clarify these points.

     For up-to-date information about available GNU software, please see
     our web site, <https://www.gnu.org>.  For software tasks and other
     ways to contribute, see <https://www.gnu.org/help>.

What's GNU? Gnu's Not Unix!
=====----------------------

GNU, which stands for Gnu's Not Unix, is the name for the complete
Unix-compatible software system which I am writing so that I can give it
away free to everyone who can use it.(1)  Several other volunteers are
helping me.  Contributions of time, money, programs and equipment are
greatly needed.

   So far we have an Emacs text editor with Lisp for writing editor
commands, a source level debugger, a yacc-compatible parser generator, a
linker, and around 35 utilities.  A shell (command interpreter) is
nearly completed.  A new portable optimizing C compiler has compiled
itself and may be released this year.  An initial kernel exists but many
more features are needed to emulate Unix.  When the kernel and compiler
are finished, it will be possible to distribute a GNU system suitable
for program development.  We will use TeX as our text formatter, but an
nroff is being worked on.  We will use the free, portable X window
system as well.  After this we will add a portable Common Lisp, an
Empire game, a spreadsheet, and hundreds of other things, plus on-line
documentation.  We hope to supply, eventually, everything useful that
normally comes with a Unix system, and more.

   GNU will be able to run Unix programs, but will not be identical to
Unix.  We will make all improvements that are convenient, based on our
experience with other operating systems.  In particular, we plan to have
longer file names, file version numbers, a crashproof file system, file
name completion perhaps, terminal-independent display support, and
perhaps eventually a Lisp-based window system through which several Lisp
programs and ordinary Unix programs can share a screen.  Both C and Lisp
will be available as system programming languages.  We will try to
support UUCP, MIT Chaosnet, and Internet protocols for communication.

   GNU is aimed initially at machines in the 68000/16000 class with
virtual memory, because they are the easiest machines to make it run on.
The extra effort to make it run on smaller machines will be left to
someone who wants to use it on them.

   To avoid horrible confusion, please pronounce the "G" in the word
"GNU" when it is the name of this project.

Why I Must Write GNU
=====---------------

I consider that the golden rule requires that if I like a program I must
share it with other people who like it.  Software sellers want to divide
the users and conquer them, making each user agree not to share with
others.  I refuse to break solidarity with other users in this way.  I
cannot in good conscience sign a nondisclosure agreement or a software
license agreement.  For years I worked within the Artificial
Intelligence Lab to resist such tendencies and other inhospitalities,
but eventually they had gone too far: I could not remain in an
institution where such things are done for me against my will.

   So that I can continue to use computers without dishonor, I have
decided to put together a sufficient body of free software so that I
will be able to get along without any software that is not free.  I have
resigned from the AI lab to deny MIT any legal excuse to prevent me from
giving GNU away.

Why GNU Will Be Compatible with Unix
=====-------------------------------

Unix is not my ideal system, but it is not too bad.  The essential
features of Unix seem to be good ones, and I think I can fill in what
Unix lacks without spoiling them.  And a system compatible with Unix
would be convenient for many other people to adopt.

How GNU Will Be Available
=====--------------------

GNU is not in the public domain.  Everyone will be permitted to modify
and redistribute GNU, but no distributor will be allowed to restrict its
further redistribution.  That is to say, proprietary modifications will
not be allowed.  I want to make sure that all versions of GNU remain
free.

Why Many Other Programmers Want to Help
=====----------------------------------

I have found many other programmers who are excited about GNU and want
to help.

   Many programmers are unhappy about the commercialization of system
software.  It may enable them to make more money, but it requires them
to feel in conflict with other programmers in general rather than feel
as comrades.  The fundamental act of friendship among programmers is the
sharing of programs; marketing arrangements now typically used
essentially forbid programmers to treat others as friends.  The
purchaser of software must choose between friendship and obeying the
law.  Naturally, many decide that friendship is more important.  But
those who believe in law often do not feel at ease with either choice.
They become cynical and think that programming is just a way of making
money.

   By working on and using GNU rather than proprietary programs, we can
be hospitable to everyone and obey the law.  In addition, GNU serves as
an example to inspire and a banner to rally others to join us in
sharing.  This can give us a feeling of harmony which is impossible if
we use software that is not free.  For about half the programmers I talk
to, this is an important happiness that money cannot replace.

How You Can Contribute
=====-----------------

I am asking computer manufacturers for donations of machines and money.
I'm asking individuals for donations of programs and work.

   One consequence you can expect if you donate machines is that GNU
will run on them at an early date.  The machines should be complete,
ready to use systems, approved for use in a residential area, and not in
need of sophisticated cooling or power.

   I have found very many programmers eager to contribute part-time work
for GNU.  For most projects, such part-time distributed work would be
very hard to coordinate; the independently-written parts would not work
together.  But for the particular task of replacing Unix, this problem
is absent.  A complete Unix system contains hundreds of utility
programs, each of which is documented separately.  Most interface
specifications are fixed by Unix compatibility.  If each contributor can
write a compatible replacement for a single Unix utility, and make it
work properly in place of the original on a Unix system, then these
utilities will work right when put together.  Even allowing for Murphy
to create a few unexpected problems, assembling these components will be
a feasible task.  (The kernel will require closer communication and will
be worked on by a small, tight group.)

   If I get donations of money, I may be able to hire a few people full
or part time.  The salary won't be high by programmers' standards, but
I'm looking for people for whom building community spirit is as
important as making money.  I view this as a way of enabling dedicated
people to devote their full energies to working on GNU by sparing them
the need to make a living in another way.

Why All Computer Users Will Benefit
=====------------------------------

Once GNU is written, everyone will be able to obtain good system
software free, just like air.(2)

   This means much more than just saving everyone the price of a Unix
license.  It means that much wasteful duplication of system programming
effort will be avoided.  This effort can go instead into advancing the
state of the art.

   Complete system sources will be available to everyone.  As a result,
a user who needs changes in the system will always be free to make them
himself, or hire any available programmer or company to make them for
him.  Users will no longer be at the mercy of one programmer or company
which owns the sources and is in sole position to make changes.

   Schools will be able to provide a much more educational environment
by encouraging all students to study and improve the system code.
Harvard's computer lab used to have the policy that no program could be
installed on the system if its sources were not on public display, and
upheld it by actually refusing to install certain programs.  I was very
much inspired by this.

   Finally, the overhead of considering who owns the system software and
what one is or is not entitled to do with it will be lifted.

   Arrangements to make people pay for using a program, including
licensing of copies, always incur a tremendous cost to society through
the cumbersome mechanisms necessary to figure out how much (that is,
which programs) a person must pay for.  And only a police state can
force everyone to obey them.  Consider a space station where air must be
manufactured at great cost: charging each breather per liter of air may
be fair, but wearing the metered gas mask all day and all night is
intolerable even if everyone can afford to pay the air bill.  And the TV
cameras everywhere to see if you ever take the mask off are outrageous.
It's better to support the air plant with a head tax and chuck the
masks.

   Copying all or parts of a program is as natural to a programmer as
breathing, and as productive.  It ought to be as free.

Some Easily Rebutted Objections to GNU's Goals
=====-----------------------------------------

     "Nobody will use it if it is free, because that means they can't
     rely on any support."

     "You have to charge for the program to pay for providing the
     support."

   If people would rather pay for GNU plus service than get GNU free
without service, a company to provide just service to people who have
obtained GNU free ought to be profitable.(3)

   We must distinguish between support in the form of real programming
work and mere handholding.  The former is something one cannot rely on
from a software vendor.  If your problem is not shared by enough people,
the vendor will tell you to get lost.

   If your business needs to be able to rely on support, the only way is
to have all the necessary sources and tools.  Then you can hire any
available person to fix your problem; you are not at the mercy of any
individual.  With Unix, the price of sources puts this out of
consideration for most businesses.  With GNU this will be easy.  It is
still possible for there to be no available competent person, but this
problem cannot be blamed on distribution arrangements.  GNU does not
eliminate all the world's problems, only some of them.

   Meanwhile, the users who know nothing about computers need
handholding: doing things for them which they could easily do themselves
but don't know how.

   Such services could be provided by companies that sell just
hand-holding and repair service.  If it is true that users would rather
spend money and get a product with service, they will also be willing to
buy the service having got the product free.  The service companies will
compete in quality and price; users will not be tied to any particular
one.  Meanwhile, those of us who don't need the service should be able
to use the program without paying for the service.

     "You cannot reach many people without advertising, and you must
     charge for the program to support that."

     "It's no use advertising a program people can get free."

   There are various forms of free or very cheap publicity that can be
used to inform numbers of computer users about something like GNU.  But
it may be true that one can reach more microcomputer users with
advertising.  If this is really so, a business which advertises the
service of copying and mailing GNU for a fee ought to be successful
enough to pay for its advertising and more.  This way, only the users
who benefit from the advertising pay for it.

   On the other hand, if many people get GNU from their friends, and
such companies don't succeed, this will show that advertising was not
really necessary to spread GNU.  Why is it that free market advocates
don't want to let the free market decide this?(4)

     "My company needs a proprietary operating system to get a
     competitive edge."

   GNU will remove operating system software from the realm of
competition.  You will not be able to get an edge in this area, but
neither will your competitors be able to get an edge over you.  You and
they will compete in other areas, while benefiting mutually in this one.
If your business is selling an operating system, you will not like GNU,
but that's tough on you.  If your business is something else, GNU can
save you from being pushed into the expensive business of selling
operating systems.

   I would like to see GNU development supported by gifts from many
manufacturers and users, reducing the cost to each.(5)

     "Don't programmers deserve a reward for their creativity?"

   If anything deserves a reward, it is social contribution.  Creativity
can be a social contribution, but only in so far as society is free to
use the results.  If programmers deserve to be rewarded for creating
innovative programs, by the same token they deserve to be punished if
they restrict the use of these programs.

     "Shouldn't a programmer be able to ask for a reward for his
     creativity?"

   There is nothing wrong with wanting pay for work, or seeking to
maximize one's income, as long as one does not use means that are
destructive.  But the means customary in the field of software today are
based on destruction.

   Extracting money from users of a program by restricting their use of
it is destructive because the restrictions reduce the amount and the
ways that the program can be used.  This reduces the amount of wealth
that humanity derives from the program.  When there is a deliberate
choice to restrict, the harmful consequences are deliberate destruction.

   The reason a good citizen does not use such destructive means to
become wealthier is that, if everyone did so, we would all become poorer
from the mutual destructiveness.  This is Kantian ethics; or, the Golden
Rule.  Since I do not like the consequences that result if everyone
hoards information, I am required to consider it wrong for one to do so.
Specifically, the desire to be rewarded for one's creativity does not
justify depriving the world in general of all or part of that
creativity.

     "Won't programmers starve?"

   I could answer that nobody is forced to be a programmer.  Most of us
cannot manage to get any money for standing on the street and making
faces.  But we are not, as a result, condemned to spend our lives
standing on the street making faces, and starving.  We do something
else.

   But that is the wrong answer because it accepts the questioner's
implicit assumption: that without ownership of software, programmers
cannot possibly be paid a cent.  Supposedly it is all or nothing.

   The real reason programmers will not starve is that it will still be
possible for them to get paid for programming; just not paid as much as
now.

   Restricting copying is not the only basis for business in software.
It is the most common basis because it brings in the most money.  If it
were prohibited, or rejected by the customer, software business would
move to other bases of organization which are now used less often.
There are always numerous ways to organize any kind of business.

   Probably programming will not be as lucrative on the new basis as it
is now.  But that is not an argument against the change.  It is not
considered an injustice that sales clerks make the salaries that they
now do.  If programmers made the same, that would not be an injustice
either.  (In practice they would still make considerably more than
that.)

     "Don't people have a right to control how their creativity is
     used?"

   "Control over the use of one's ideas" really constitutes control over
other people's lives; and it is usually used to make their lives more
difficult.

   People who have studied the issue of intellectual property rights(6)
carefully (such as lawyers) say that there is no intrinsic right to
intellectual property.  The kinds of supposed intellectual property
rights that the government recognizes were created by specific acts of
legislation for specific purposes.

   For example, the patent system was established to encourage inventors
to disclose the details of their inventions.  Its purpose was to help
society rather than to help inventors.  At the time, the life span of 17
years for a patent was short compared with the rate of advance of the
state of the art.  Since patents are an issue only among manufacturers,
for whom the cost and effort of a license agreement are small compared
with setting up production, the patents often do not do much harm.  They
do not obstruct most individuals who use patented products.

   The idea of copyright did not exist in ancient times, when authors
frequently copied other authors at length in works of non-fiction.  This
practice was useful, and is the only way many authors' works have
survived even in part.  The copyright system was created expressly for
the purpose of encouraging authorship.  In the domain for which it was
invented--books, which could be copied economically only on a printing
press--it did little harm, and did not obstruct most of the individuals
who read the books.

   All intellectual property rights are just licenses granted by society
because it was thought, rightly or wrongly, that society as a whole
would benefit by granting them.  But in any particular situation, we
have to ask: are we really better off granting such license?  What kind
of act are we licensing a person to do?

   The case of programs today is very different from that of books a
hundred years ago.  The fact that the easiest way to copy a program is
from one neighbor to another, the fact that a program has both source
code and object code which are distinct, and the fact that a program is
used rather than read and enjoyed, combine to create a situation in
which a person who enforces a copyright is harming society as a whole
both materially and spiritually; in which a person should not do so
regardless of whether the law enables him to.

     "Competition makes things get done better."

   The paradigm of competition is a race: by rewarding the winner, we
encourage everyone to run faster.  When capitalism really works this
way, it does a good job; but its defenders are wrong in assuming it
always works this way.  If the runners forget why the reward is offered
and become intent on winning, no matter how, they may find other
strategies--such as, attacking other runners.  If the runners get into a
fist fight, they will all finish late.

   Proprietary and secret software is the moral equivalent of runners in
a fist fight.  Sad to say, the only referee we've got does not seem to
object to fights; he just regulates them ("For every ten yards you run,
you can fire one shot").  He really ought to break them up, and penalize
runners for even trying to fight.

     "Won't everyone stop programming without a monetary incentive?"

   Actually, many people will program with absolutely no monetary
incentive.  Programming has an irresistible fascination for some people,
usually the people who are best at it.  There is no shortage of
professional musicians who keep at it even though they have no hope of
making a living that way.

   But really this question, though commonly asked, is not appropriate
to the situation.  Pay for programmers will not disappear, only become
less.  So the right question is, will anyone program with a reduced
monetary incentive?  My experience shows that they will.

   For more than ten years, many of the world's best programmers worked
at the Artificial Intelligence Lab for far less money than they could
have had anywhere else.  They got many kinds of non-monetary rewards:
fame and appreciation, for example.  And creativity is also fun, a
reward in itself.

   Then most of them left when offered a chance to do the same
interesting work for a lot of money.

   What the facts show is that people will program for reasons other
than riches; but if given a chance to make a lot of money as well, they
will come to expect and demand it.  Low-paying organizations do poorly
in competition with high-paying ones, but they do not have to do badly
if the high-paying ones are banned.

     "We need the programmers desperately.  If they demand that we stop
     helping our neighbors, we have to obey."

   You're never so desperate that you have to obey this sort of demand.
Remember: millions for defense, but not a cent for tribute!

     "Programmers need to make a living somehow."

   In the short run, this is true.  However, there are plenty of ways
that programmers could make a living without selling the right to use a
program.  This way is customary now because it brings programmers and
businessmen the most money, not because it is the only way to make a
living.  It is easy to find other ways if you want to find them.  Here
are a number of examples.

   A manufacturer introducing a new computer will pay for the porting of
operating systems onto the new hardware.

   The sale of teaching, hand-holding and maintenance services could
also employ programmers.

   People with new ideas could distribute programs as freeware(7),
asking for donations from satisfied users, or selling hand-holding
services.  I have met people who are already working this way
successfully.

   Users with related needs can form users' groups, and pay dues.  A
group would contract with programming companies to write programs that
the group's members would like to use.

   All sorts of development can be funded with a Software Tax:

     Suppose everyone who buys a computer has to pay x percent of the
     price as a software tax.  The government gives this to an agency
     like the NSF to spend on software development.

     But if the computer buyer makes a donation to software development
     himself, he can take a credit against the tax.  He can donate to
     the project of his own choosing--often, chosen because he hopes to
     use the results when it is done.  He can take a credit for any
     amount of donation up to the total tax he had to pay.

     The total tax rate could be decided by a vote of the payers of the
     tax, weighted according to the amount they will be taxed on.

     The consequences:

        * The computer-using community supports software development.
        * This community decides what level of support is needed.
        * Users who care which projects their share is spent on can
          choose this for themselves.

   In the long run, making programs free is a step toward the
post-scarcity world, where nobody will have to work very hard just to
make a living.  People will be free to devote themselves to activities
that are fun, such as programming, after spending the necessary ten
hours a week on required tasks such as legislation, family counseling,
robot repair and asteroid prospecting.  There will be no need to be able
to make a living from programming.

   We have already greatly reduced the amount of work that the whole
society must do for its actual productivity, but only a little of this
has translated itself into leisure for workers because much
nonproductive activity is required to accompany productive activity.
The main causes of this are bureaucracy and isometric struggles against
competition.  Free software will greatly reduce these drains in the area
of software production.  We must do this, in order for technical gains
in productivity to translate into less work for us.

   ---------- Footnotes ----------

   (1) The wording here was careless.  The intention was that nobody
would have to pay for _permission_ to use the GNU system.  But the words
don't make this clear, and people often interpret them as saying that
copies of GNU should always be distributed at little or no charge.  That
was never the intent; later on, the manifesto mentions the possibility
of companies providing the service of distribution for a profit.
Subsequently I have learned to distinguish carefully between "free" in
the sense of freedom and "free" in the sense of price.  Free software is
software that users have the freedom to distribute and change.  Some
users may obtain copies at no charge, while others pay to obtain
copies--and if the funds help support improving the software, so much the
better.  The important thing is that everyone who has a copy has the
freedom to cooperate with others in using it.

   (2) This is another place I failed to distinguish carefully between
the two different meanings of "free." The statement as it stands is not
false--you can get copies of GNU software at no charge, from your friends
or over the net.  But it does suggest the wrong idea.

   (3) Several such companies now exist.

   (4) The Free Software Foundation raises most of its funds from a
distribution service, although it is a charity rather than a company.
If _no one_ chooses to obtain copies by ordering from the FSF, it will
be unable to do its work.  But this does not mean that proprietary
restrictions are justified to force every user to pay.  If a small
fraction of all the users order copies from the FSF, that is sufficient
to keep the FSF afloat.  So we ask users to choose to support us in this
way.  Have you done your part?

   (5) A group of computer companies recently pooled funds to support
maintenance of the GNU C Compiler.

   (6) In the 80s I had not yet realized how confusing it was to speak
of "the issue" of "intellectual property." That term is obviously
biased; more subtle is the fact that it lumps together various disparate
laws which raise very different issues.  Nowadays I urge people to
reject the term "intellectual property" entirely, lest it lead others to
suppose that those laws form one coherent issue.  The way to be clear is
to discuss patents, copyrights, and trademarks separately.  See
<https://www.gnu.org/philosophy/not-ipr.xhtml> for more explanation of
how this term spreads confusion and bias.

   (7) Subsequently we have discovered the need to distinguish between
"free software" and "freeware".  The term "freeware" means software you
are free to redistribute, but usually you are not free to study and
change the source code, so most of it is not free software.  See
<https://www.gnu.org/philosophy/words-to-avoid.html> for more
explanation.

==============================================================================
File: emacs.info,  Node: |Glossary|,  Next: |Acknowledgments|,  Prev: |Manifesto|,  Up: |Top|
==============================================================================

                                                                      *Glossary*

Glossary
*****===

Abbrev
     An abbrev is a text string that expands into a different text
     string when present in the buffer.  For example, you might define a
     few letters as an abbrev for a long phrase that you want to insert
     frequently.  *Note Abbrevs::.

Aborting
     Aborting means getting out of a recursive edit (q.v.).  The
     commands 'C-]' and 'M-x top-level' are used for this.  *Note
     Quitting::.

Active Region
     Setting the mark (q.v.) at a position in the text also activates
     it.  When the mark is active, we call the region an active region.
     *Note Mark::.

<Alt>
     Alt is the name of a modifier bit that a keyboard input character
     may have.  To make a character Alt, type it while holding down the
     <Alt> key.  Such characters are given names that start with
     '<Alt>-' (usually written 'A-' for short).  (Note that many
     terminals have a key labeled <Alt> that is really a <Meta> key.)
     *Note Alt: User Input.

Argument
     *Note Glossary---Numeric Argument::.

ASCII character
     An ASCII character is either an ASCII control character or an ASCII
     printing character.  *Note User Input::.

ASCII control character
     An ASCII control character is the Control version of an upper-case
     letter, or the Control version of one of the characters '@[\]^_?'.

ASCII printing character
     ASCII letters, digits, space, and the following punctuation
     characters: '!@#$%^&*()_-+=|\~`{}[]:;"'<>,.?/'.

Auto Fill Mode
     Auto Fill mode is a minor mode (q.v.) in which text that you insert
     is automatically broken into lines of a given maximum width.  *Note
     Filling::.

Auto Saving
     Auto saving is the practice of periodically saving the contents of
     an Emacs buffer in a specially-named file, so that the information
     will be preserved if the buffer is lost due to a system error or
     user error.  *Note Auto Save::.

Autoloading
     Emacs can automatically load Lisp libraries when a Lisp program
     requests a function from those libraries.  This is called
     "autoloading".  *Note Lisp Libraries::.

Backtrace
     A backtrace is a trace of a series of function calls showing how a
     program arrived at a certain point.  It is used mainly for finding
     and correcting bugs (q.v.).  Emacs can display a backtrace when it
     signals an error or when you type 'C-g' (*note
     Glossary---Quitting::).  *Note Checklist::.

Backup File
     A backup file records the contents that a file had before the
     current editing session.  Emacs makes backup files automatically to
     help you track down or cancel changes you later regret making.
     *Note Backup::.

Balancing Parentheses
     Emacs can balance parentheses (or other matching delimiters) either
     manually or automatically.  You do manual balancing with the
     commands to move over parenthetical groupings (*note Moving by
     Parens::).  Automatic balancing works by blinking or highlighting
     the delimiter that matches the one you just inserted, or inserting
     the matching delimiter for you (*note Matching Parens: Matching.).

Balanced Expressions
     A balanced expression is a syntactically recognizable expression,
     such as a symbol, number, string constant, block, or parenthesized
     expression in C.  *Note Balanced Expressions: Expressions.

Balloon Help
     *Note Glossary---Tooltips::.

Base Buffer
     A base buffer is a buffer whose text is shared by an indirect
     buffer (q.v.).

Bidirectional Text
     Some human languages, such as English, are written from left to
     right.  Others, such as Arabic, are written from right to left.
     Emacs supports both of these forms, as well as any mixture of
     them--this is "bidirectional text".  *Note Bidirectional Editing::.

Bind
     To bind a key sequence means to give it a binding (q.v.).  *Note
     Rebinding::.

Binding
     A key sequence gets its meaning in Emacs by having a binding, which
     is a command (q.v.)--a Lisp function that is run when you type that
     sequence.  *Note Binding: Commands.  Customization often involves
     rebinding a character to a different command function.  The
     bindings of all key sequences are recorded in the keymaps (q.v.).
     *Note Keymaps::.

Blank Lines
     Blank lines are lines that contain only whitespace.  Emacs has
     several commands for operating on the blank lines in the buffer.
     *Note Blank Lines::.

Bookmark
     Bookmarks are akin to registers (q.v.) in that they record
     positions in buffers to which you can return later.  Unlike
     registers, bookmarks persist between Emacs sessions.  *Note
     Bookmarks::.

Border
     A border is a thin space along the edge of the frame, used just for
     spacing, not for displaying anything.  An Emacs frame has an
     ordinary external border, outside of everything including the menu
     bar, plus an internal border that surrounds the text windows, their
     scroll bars and fringes, and separates them from the menu bar and
     tool bar.  You can customize both borders with options and
     resources (*note Borders X::).  Borders are not the same as fringes
     (q.v.).

Buffer
     The buffer is the basic editing unit; one buffer corresponds to one
     text being edited.  You normally have several buffers, but at any
     time you are editing only one, the current buffer, though several
     can be visible when you are using multiple windows or frames
     (q.v.).  Most buffers are visiting (q.v.) some file.  *Note
     Buffers::.

Buffer Selection History
     Emacs keeps a buffer selection history that records how recently
     each Emacs buffer has been selected.  This is used for choosing
     which buffer to select.  *Note Buffers::.

Bug
     A bug is an incorrect or unreasonable behavior of a program, or
     inaccurate or confusing documentation.  Emacs developers treat bug
     reports, both in Emacs code and its documentation, very seriously
     and ask you to report any bugs you find.  *Note Bugs::.

Button Down Event
     A button down event is the kind of input event (q.v.) generated
     right away when you press down on a mouse button.  *Note Mouse
     Buttons::.

By Default
     *Note Glossary---Default::.

Byte Compilation
     *Note Glossary---Compilation::.

cf.
c.f.
     Short for "confer" in Latin, which means "compare with" or "compare
     to".  The second variant, "c.f.", is a widespread misspelling.

'C-'
     'C-' in the name of a character is an abbreviation for Control.
     *Note C-: User Input.

'C-M-'
     'C-M-' in the name of a character is an abbreviation for
     Control-Meta.  If your terminal lacks a real <Meta> key, you type a
     Control-Meta character by typing <ESC> and then typing the
     corresponding Control character.  *Note C-M-: User Input.

Case Conversion
     Case conversion means changing text from upper case to lower case
     or vice versa.  *Note Case::.

Case Folding
     Case folding means ignoring the differences between case variants
     of the same letter: upper-case, lower-case, and title-case.  Emacs
     performs case folding by default in text search.  *Note Lax
     Search::.

Character
     Characters form the contents of an Emacs buffer.  Also, key
     sequences (q.v.) are usually made up of characters (though they may
     include other input events as well).  *Note User Input::.

Character Folding
     Character folding means ignoring differences between similarly
     looking characters, such as between 'a', and 'a"' and '??'.  Emacs
     performs character folding by default in text search.  *Note Lax
     Search::.

Character Set
     Emacs supports a number of character sets, each of which represents
     a particular alphabet or script.  *Note International::.

Character Terminal
     *Note Glossary---Text Terminal::.

Click Event
     A click event is the kind of input event (q.v.) generated when you
     press a mouse button and release it without moving the mouse.
     *Note Mouse Buttons::.

Client
     *Note Glossary---Server::.

Clipboard
     A clipboard is a buffer provided by the window system for
     transferring text between applications.  On the X Window System,
     the clipboard is provided in addition to the primary selection
     (q.v.); on MS-Windows and Mac, the clipboard is used _instead_ of
     the primary selection.  *Note Clipboard::.

Coding System
     A coding system is a way to encode text characters in a file or in
     a stream of information.  Emacs has the ability to convert text to
     or from a variety of coding systems when reading or writing it.
     *Note Coding Systems::.

Command
     A command is a Lisp function specially defined to be able to serve
     as a key binding in Emacs or to be invoked by its name (*note
     Glossary---Command Name::).  When you type a key sequence (q.v.),
     its binding (q.v.) is looked up in the relevant keymaps (q.v.) to
     find the command to run.  *Note Commands::.

Command History
     *Note Glossary---Minibuffer History::.

Command Name
     A command name is the name of a Lisp symbol that is a command
     (*note Commands::).  You can invoke any command by its name using
     'M-x' (*note M-x: M-x.).

Comment
     A comment is text in a program which is intended only for humans
     reading the program, and which is specially marked so that it will
     be ignored when the program is loaded or compiled.  Emacs offers
     special commands for creating, aligning and killing comments.
     *Note Comments::.

Common Lisp
     Common Lisp is a dialect of Lisp (q.v.) much larger and more
     powerful than Emacs Lisp.  Emacs provides a subset of Common Lisp
     in the CL package.  *Note Common Lisp: (cl)Top.

Compilation
     Compilation is the process of creating an executable program from
     source code.  Emacs has commands for compiling files of Emacs Lisp
     code (*note (elisp)Byte Compilation::) and programs in C and other
     languages (*note Compilation::).  Byte-compiled Emacs Lisp code
     loads and executes faster.

Complete Key
     A complete key is a key sequence that fully specifies one action to
     be performed by Emacs.  For example, 'X' and 'C-f' and 'C-x m' are
     complete keys.  Complete keys derive their meanings from being
     bound (*note Glossary---Bind::) to commands (q.v.).  Thus, 'X' is
     conventionally bound to a command to insert 'X' in the buffer; 'C-x
     m' is conventionally bound to a command to begin composing a mail
     message.  *Note Keys::.

Completion
     Completion is what Emacs does when it automatically expands an
     abbreviation for a name into the entire name.  Completion is done
     for minibuffer (q.v.) arguments when the set of possible valid
     inputs is known; for example, on command names, buffer names, and
     file names.  Completion usually occurs when <TAB>, <SPC> or <RET>
     is typed.  *Note Completion::.

Continuation Line
     When a line of text is longer than the width of the window, it
     normally takes up more than one screen line when displayed (but see
     *note Glossary---Truncation::).  We say that the text line is
     continued, and all screen lines used for it after the first are
     called continuation lines.  *Note Continuation Lines::.  A related
     Emacs feature is filling (q.v.).

Control Character
     A control character is a character that you type by holding down
     the <Ctrl> key.  Some control characters also have their own keys,
     so that you can type them without using <Ctrl>.  For example,
     <RET>, <TAB>, <ESC> and <DEL> are all control characters.  *Note
     User Input::.

Copyleft
     A copyleft is a notice giving the public legal permission to
     redistribute and modify a program or other work of art, but
     requiring modified versions to carry similar permission.  Copyright
     is normally used to keep users divided and helpless; with copyleft
     we turn that around to empower users and encourage them to
     cooperate.

     The particular form of copyleft used by the GNU project is called
     the GNU General Public License.  *Note Copying::.

<Ctrl>
     The <Ctrl> or control key is what you hold down in order to enter a
     control character (q.v.).  *Note Glossary---C-::.

Current Buffer
     The current buffer in Emacs is the Emacs buffer on which most
     editing commands operate.  You can select any Emacs buffer as the
     current one.  *Note Buffers::.

Current Line
     The current line is the line that point is on (*note Point::).

Current Paragraph
     The current paragraph is the paragraph that point is in.  If point
     is between two paragraphs, the current paragraph is the one that
     follows point.  *Note Paragraphs::.

Current Defun
     The current defun is the defun (q.v.) that point is in.  If point
     is between defuns, the current defun is the one that follows point.
     *Note Defuns::.

Cursor
     The cursor is the rectangle on the screen which indicates the
     position (called point; q.v.) at which insertion and deletion takes
     place.  The cursor is on or under the character that follows point.
     Often people speak of "the cursor" when, strictly speaking, they
     mean "point".  *Note Cursor: Point.

Customization
     Customization is making minor changes in the way Emacs works, to
     reflect your preferences or needs.  It is often done by setting
     variables (*note Variables::) or faces (*note Face
     Customization::), or by rebinding key sequences (*note Keymaps::).

Cut and Paste
     *Note Glossary---Killing::, and *note Glossary---Yanking::.

Daemon
     A daemon is a standard term for a system-level process that runs in
     the background.  Daemons are often started when the system first
     starts up.  When Emacs runs in daemon-mode, it does not open a
     display.  You connect to it with the 'emacsclient' program.  *Note
     Emacs Server::.

Default Argument
     The default for an argument is the value that will be assumed if
     you do not specify one.  When the minibuffer is used to read an
     argument, the default argument is used if you just type <RET>.
     *Note Minibuffer::.

Default
     A default is the value that is used for a certain purpose when you
     do not explicitly specify a value to use.

Default Directory
     When you specify a file name that does not start with '/' or '~',
     it is interpreted relative to the current buffer's default
     directory.  (On MS systems, file names that start with a drive
     letter 'X:' are treated as absolute, not relative.)  *Note Default
     Directory: Minibuffer File.

Defun
     A defun is a major definition at the top level in a program.  The
     name "defun" comes from Lisp, where most such definitions use the
     construct 'defun'.  *Note Defuns::.

<DEL>
     <DEL> is a character that runs the command to delete one character
     of text before the cursor.  It is typically either the <Delete> key
     or the <BACKSPACE> key, whichever one is easy to type.  *Note DEL:
     Erasing.

Deletion
     Deletion means erasing text without copying it into the kill ring
     (q.v.).  The alternative is killing (q.v.).  *Note Deletion:
     Killing.

Deletion of Files
     Deleting a file means erasing it from the file system.  (Note that
     some systems use the concept of a trash can, or recycle bin, to
     allow you to undelete files.)  *Note Misc File Ops: Misc File Ops.

Deletion of Messages
     Deleting a message (in Rmail, and other mail clients) means
     flagging it to be eliminated from your mail file.  Until you
     expunge (q.v.) the Rmail file, you can still undelete the messages
     you have deleted.  *Note Rmail Deletion::.

Deletion of Windows
     Deleting a window means eliminating it from the screen.  Other
     windows expand to use up the space.  The text that was in the
     window is not lost, and you can create a new window with the same
     dimensions as the old if you wish.  *Note Windows::.

Directory
     File directories are named collections in the file system, within
     which you can place individual files or subdirectories.  They are
     sometimes referred to as "folders".  *Note Directories::.

Directory Local Variable
     A directory local variable is a local variable (q.v.) that applies
     to all the files within a certain directory.  *Note Directory
     Variables::.

Directory Name
     On GNU and other Unix-like systems, directory names are strings
     that end in '/'.  For example, '/no-such-dir/' is a directory name
     whereas '/tmp' is not, even though '/tmp' names a file that happens
     to be a directory.  On MS-Windows the relationship is more
     complicated.  *Note (elisp)Directory Names::.

Dired
     Dired is the Emacs facility that displays the contents of a file
     directory and allows you to "edit the directory", performing
     operations on the files in the directory.  *Note Dired::.

Disabled Command
     A disabled command is one that you may not run without special
     confirmation.  The usual reason for disabling a command is that it
     is confusing for beginning users.  *Note Disabling::.

Down Event
     Short for "button down event" (q.v.).

Drag Event
     A drag event is the kind of input event (q.v.) generated when you
     press a mouse button, move the mouse, and then release the button.
     *Note Mouse Buttons::.

Dribble File
     A dribble file is a file into which Emacs writes all the characters
     that you type on the keyboard.  Dribble files can be used to make a
     record for debugging Emacs bugs.  Emacs does not make a dribble
     file unless you tell it to.  *Note Bugs::.

e.g.
     Short for "exempli gratia" in Latin, which means "for example".

Echo Area
     The echo area is the bottom line of the screen, used for echoing
     the arguments to commands, for asking questions, and showing brief
     messages (including error messages).  The messages are stored in
     the buffer 'Messages' so you can review them later.  *Note Echo
     Area::.

Echoing
     Echoing is acknowledging the receipt of input events by displaying
     them (in the echo area).  Emacs never echoes single-character key
     sequences; longer key sequences echo only if you pause while typing
     them.

Electric
     We say that a character is electric if it is normally
     self-inserting (q.v.), but the current major mode (q.v.) redefines
     it to do something else as well.  For example, some programming
     language major modes define particular delimiter characters to
     reindent the line, or insert one or more newlines in addition to
     self-insertion.

End Of Line
     End of line is a character or a sequence of characters that
     indicate the end of a text line.  On GNU and Unix systems, this is
     a newline (q.v.), but other systems have other conventions.  *Note
     end-of-line: Coding Systems.  Emacs can recognize several
     end-of-line conventions in files and convert between them.

Environment Variable
     An environment variable is one of a collection of variables stored
     by the operating system, each one having a name and a value.  Emacs
     can access environment variables set by its parent shell, and it
     can set variables in the environment it passes to programs it
     invokes.  *Note Environment::.

EOL
     *Note Glossary---End Of Line::.

Error
     An error occurs when an Emacs command cannot execute in the current
     circumstances.  When an error occurs, execution of the command
     stops (unless the command has been programmed to do otherwise) and
     Emacs reports the error by displaying an error message (q.v.).

Error Message
     An error message is output displayed by Emacs when you ask it to do
     something impossible (such as, killing text forward when point is
     at the end of the buffer), or when a command malfunctions in some
     way.  Such messages appear in the echo area, accompanied by a beep.

<ESC>
     <ESC> is a character used as a prefix for typing Meta characters on
     keyboards lacking a <Meta> key.  Unlike the <Meta> key (which, like
     the <SHIFT> key, is held down while another character is typed),
     you press the <ESC> key as you would press a letter key, and it
     applies to the next character you type.

etc.
     Short for "et cetera" in Latin, which means "and so on".

Expression
     *Note Glossary---Balanced Expression::.

Expunging
     Expunging an Rmail, Gnus newsgroup, or Dired buffer is an operation
     that truly discards the messages or files you have previously
     flagged for deletion.

Face
     A face is a style of displaying characters.  It specifies
     attributes such as font family and size, foreground and background
     colors, underline and strike-through, background stipple, etc.
     Emacs provides features to associate specific faces with portions
     of buffer text, in order to display that text as specified by the
     face attributes.  *Note Faces::.

File Local Variable
     A file local variable is a local variable (q.v.) specified in a
     given file.  *Note File Variables::, and *note Glossary---Directory
     Local Variable::.

File Locking
     Emacs uses file locking to notice when two different users start to
     edit one file at the same time.  *Note Interlocking::.

File Name
     A file name is a name that refers to a file.  File names may be
     relative or absolute; the meaning of a relative file name depends
     on the current directory, but an absolute file name refers to the
     same file regardless of which directory is current.  On GNU and
     Unix systems, an absolute file name starts with a slash (the root
     directory) or with '~/' or '~USER/' (a home directory).  On
     MS-Windows/MS-DOS, an absolute file name can also start with a
     drive letter and a colon, e.g., 'D:'.

     Some people use the term "pathname" for file names, but we do not;
     we use the word "path" only in the term "search path" (q.v.).

File-Name Component
     A file-name component names a file directly within a particular
     directory.  On GNU and Unix systems, a file name is a sequence of
     file-name components, separated by slashes.  For example, 'foo/bar'
     is a file name containing two components, 'foo' and 'bar'; it
     refers to the file named 'bar' in the directory named 'foo' in the
     current directory.  MS-DOS/MS-Windows file names can also use
     backslashes to separate components, as in 'foo\bar'.

Fill Prefix
     The fill prefix is a string that should be expected at the
     beginning of each line when filling is done.  It is not regarded as
     part of the text to be filled.  *Note Filling::.

Filling
     Filling text means adjusting the position of line-breaks to shift
     text between consecutive lines, so that all the lines are
     approximately the same length.  *Note Filling::.  Some other
     editors call this feature "line wrapping".

Font Lock
     Font Lock is a mode that highlights parts of buffer text in
     different faces, according to the syntax.  Some other editors refer
     to this as "syntax highlighting".  For example, all comments (q.v.)
     might be colored red.  *Note Font Lock::.

Fontset
     A fontset is a named collection of fonts.  A fontset specification
     lists character sets and which font to use to display each of them.
     Fontsets make it easy to change several fonts at once by specifying
     the name of a fontset, rather than changing each font separately.
     *Note Fontsets::.

Formfeed Character
     *Note Glossary---Page::.

Frame
     A frame is a rectangular cluster of Emacs windows.  Emacs starts
     out with one frame, but you can create more.  You can subdivide
     each frame into Emacs windows (q.v.).  When you are using a window
     system (q.v.), more than one frame can be visible at the same time.
     *Note Frames::.  Some other editors use the term "window" for this,
     but in Emacs a window means something else.

Free Software
     Free software is software that gives you the freedom to share,
     study and modify it.  Emacs is free software, part of the GNU
     project (q.v.), and distributed under a copyleft (q.v.) license
     called the GNU General Public License.  *Note Copying::.

Free Software Foundation
     The Free Software Foundation (FSF) is a charitable foundation
     dedicated to promoting the development of free software (q.v.).
     For more information, see the FSF website (https://fsf.org/).

Fringe
     On a graphical display (q.v.), there's a narrow portion of the
     frame (q.v.) between the text area and the window's border.  These
     "fringes" are used to display symbols that provide information
     about the buffer text (*note Fringes::).  Emacs displays the fringe
     using a special face (q.v.) called 'fringe'.  *Note fringe: Faces.

FSF
     *Note Glossary---Free Software Foundation::.

FTP
     FTP is an acronym for File Transfer Protocol.  This is one standard
     method for retrieving remote files (q.v.).

Function Key
     A function key is a key on the keyboard that sends input but does
     not correspond to any character.  *Note Function Keys::.

Global
     Global means "independent of the current environment; in effect
     throughout Emacs".  It is the opposite of local (q.v.).  Particular
     examples of the use of "global" appear below.

Global Abbrev
     A global definition of an abbrev (q.v.) is effective in all major
     modes that do not have local (q.v.) definitions for the same
     abbrev.  *Note Abbrevs::.

Global Keymap
     The global keymap (q.v.) contains key bindings that are in effect
     everywhere, except when overridden by local key bindings in a major
     mode's local keymap (q.v.).  *Note Keymaps::.

Global Mark Ring
     The global mark ring records the series of buffers you have
     recently set a mark (q.v.) in.  In many cases you can use this to
     backtrack through buffers you have been editing, or in which you
     have found tags (*note Glossary---Tags Table::).  *Note Global Mark
     Ring::.

Global Substitution
     Global substitution means replacing each occurrence of one string
     by another string throughout a large amount of text.  *Note
     Replace::.

Global Variable
     The global value of a variable (q.v.) takes effect in all buffers
     that do not have their own local (q.v.) values for the variable.
     *Note Variables::.

GNU
     GNU is a recursive acronym for GNU's Not Unix, and it refers to a
     Unix-compatible operating system which is free software (q.v.).
     *Note Manifesto::.  GNU is normally used with Linux as the kernel
     since Linux works better than the GNU kernel.  For more
     information, see the GNU website (https://www.gnu.org/).

Graphic Character
     Graphic characters are those assigned pictorial images rather than
     just names.  All the non-Meta (q.v.) characters except for the
     Control (q.v.) characters are graphic characters.  These include
     letters, digits, punctuation, and spaces; they do not include <RET>
     or <ESC>.  In Emacs, typing a graphic character inserts that
     character (in ordinary editing modes).  *Note Inserting Text::.

Graphical Display
     A graphical display is one that can display images and multiple
     fonts.  Usually it also has a window system (q.v.).

Highlighting
     Highlighting text means displaying it with a different foreground
     and/or background color to make it stand out from the rest of the
     text in the buffer.

     Emacs uses highlighting in several ways.  It highlights the region
     whenever it is active (*note Mark::).  Incremental search also
     highlights matches (*note Incremental Search::).  *Note
     Glossary---Font Lock::.

Hardcopy
     Hardcopy means printed output.  Emacs has various commands for
     printing the contents of Emacs buffers.  *Note Printing::.

<HELP>
     <HELP> is the Emacs name for 'C-h' or <F1>.  You can type <HELP> at
     any time to ask what options you have, or to ask what a command
     does.  *Note Help::.

Help Echo
     Help echo is a short message displayed in the echo area (q.v.) when
     the mouse pointer is located on portions of display that require
     some explanations.  Emacs displays help echo for menu items, parts
     of the mode line, tool-bar buttons, etc.  On graphical displays,
     the messages can be displayed as tooltips (q.v.).  *Note
     Tooltips::.

Home Directory
     Your home directory contains your personal files.  On a multi-user
     GNU or Unix system, each user has his or her own home directory.
     When you start a new login session, your home directory is the
     default directory in which to start.  A standard shorthand for your
     home directory is '~'.  Similarly, '~USER' represents the home
     directory of some other user.

Hook
     A hook is a list of functions to be called on specific occasions,
     such as saving a buffer in a file, major mode activation, etc.  By
     customizing the various hooks, you can modify Emacs's behavior
     without changing any of its code.  *Note Hooks::.

Hyper
     Hyper is the name of a modifier bit that a keyboard input character
     may have.  To make a character Hyper, type it while holding down
     the <Hyper> key.  Such characters are given names that start with
     'Hyper-' (usually written 'H-' for short).  *Note Modifier Keys::.

i.e.
     Short for "id est" in Latin, which means "that is".

Iff
     "Iff" means "if and only if".  This terminology comes from
     mathematics.  Try to avoid using this term in documentation, since
     many are unfamiliar with it and mistake it for a typo.

Inbox
     An inbox is a file in which mail is delivered by the operating
     system.  Rmail transfers mail from inboxes to Rmail files in which
     the mail is then stored permanently or until explicitly deleted.
     *Note Rmail Inbox::.

Incremental Search
     Emacs provides an incremental search facility, whereby Emacs begins
     searching for a string as soon as you type the first character.  As
     you type more characters, it refines the search.  *Note Incremental
     Search::.

Indentation
     Indentation means blank space at the beginning of a line.  Most
     programming languages have conventions for using indentation to
     illuminate the structure of the program, and Emacs has special
     commands to adjust indentation.  *Note Indentation::.

Indirect Buffer
     An indirect buffer is a buffer that shares the text of another
     buffer, called its base buffer (q.v.).  *Note Indirect Buffers::.

Info
     Info is the hypertext format used by the GNU project for writing
     documentation.

Input Event
     An input event represents, within Emacs, one action taken by the
     user on the terminal.  Input events include typing characters,
     typing function keys, pressing or releasing mouse buttons, and
     switching between Emacs frames.  *Note User Input::.

Input Method
     An input method is a system for entering non-ASCII text characters
     by typing sequences of ASCII characters (q.v.).  *Note Input
     Methods::.

Insertion
     Insertion means adding text into the buffer, either from the
     keyboard or from some other place in Emacs.

Interlocking
     *Note Glossary---File Locking::.

Isearch
     *Note Glossary---Incremental Search::.

Justification
     Justification means adding extra spaces within lines of text in
     order to adjust the position of the text edges.  *Note Fill
     Commands::.

Key Binding
     *Note Glossary---Binding::.

Keyboard Macro
     Keyboard macros are a way of defining new Emacs commands from
     sequences of existing ones, with no need to write a Lisp program.
     You can use a macro to record a sequence of commands, then play
     them back as many times as you like.  *Note Keyboard Macros::.

Keyboard Shortcut
     A keyboard shortcut is a key sequence (q.v.) that invokes a
     command.  What some programs call "assigning a keyboard shortcut",
     Emacs calls "binding a key sequence".  *Note Glossary---Binding::.

Key Sequence
     A key sequence (key, for short) is a sequence of input events
     (q.v.) that are meaningful as a single unit.  If the key sequence
     is enough to specify one action, it is a complete key (q.v.); if it
     is not enough, it is a prefix key (q.v.).  *Note Keys::.

Keymap
     The keymap is the data structure that records the bindings (q.v.)
     of key sequences to the commands that they run.  For example, the
     global keymap binds the character 'C-n' to the command function
     'next-line'.  *Note Keymaps::.

Keyboard Translation Table
     The keyboard translation table is an array that translates the
     character codes that come from the terminal into the character
     codes that make up key sequences.

Kill Ring
     The kill ring is where all text you have killed (*note
     Glossary---Killing::) recently is saved.  You can reinsert any of
     the killed text still in the ring; this is called yanking (q.v.).
     *Note Yanking::.

Killing
     Killing means erasing text and saving it on the kill ring so it can
     be yanked (q.v.) later.  Some other systems call this "cutting".
     Most Emacs commands that erase text perform killing, as opposed to
     deletion (q.v.).  *Note Killing::.

Killing a Job
     Killing a job (such as, an invocation of Emacs) means making it
     cease to exist.  Any data within it, if not saved in a file, is
     lost.  *Note Exiting::.

Language Environment
     Your choice of language environment specifies defaults for the
     input method (q.v.) and coding system (q.v.).  *Note Language
     Environments::.  These defaults are relevant if you edit non-ASCII
     text (*note International::).

Line Wrapping
     *Note Glossary---Filling::.

Lisp
     Lisp is a programming language.  Most of Emacs is written in a
     dialect of Lisp, called Emacs Lisp, which is extended with special
     features that make it especially suitable for text editing tasks.

List
     A list is, approximately, a text string beginning with an open
     parenthesis and ending with the matching close parenthesis.  In C
     mode and other non-Lisp modes, groupings surrounded by other kinds
     of matched delimiters appropriate to the language, such as braces,
     are also considered lists.  Emacs has special commands for many
     operations on lists.  *Note Moving by Parens::.

Local
     Local means "in effect only in a particular context"; the relevant
     kind of context is a particular function execution, a particular
     buffer, or a particular major mode.  It is the opposite of "global"
     (q.v.).  Specific uses of "local" in Emacs terminology appear
     below.

Local Abbrev
     A local abbrev definition is effective only if a particular major
     mode is selected.  In that major mode, it overrides any global
     definition for the same abbrev.  *Note Abbrevs::.

Local Keymap
     A local keymap is used in a particular major mode; the key bindings
     (q.v.) in the current local keymap override global bindings of the
     same key sequences.  *Note Keymaps::.

Local Variable
     A local value of a variable (q.v.) applies to only one buffer.
     *Note Locals::.

'M-'
     'M-' in the name of a character is an abbreviation for <Meta>, one
     of the modifier keys that can accompany any character.  *Note M-:
     User Input.

'M-C-'
     'M-C-' in the name of a character is an abbreviation for
     Control-Meta; it means the same thing as 'C-M-' (q.v.).

'M-x'
     'M-x' is the key sequence that is used to call an Emacs command by
     name.  This is how you run commands that are not bound to key
     sequences.  *Note M-x: M-x.

Mail
     Mail means messages sent from one user to another through the
     computer system, to be read at the recipient's convenience.  Emacs
     has commands for composing and sending mail, and for reading and
     editing the mail you have received.  *Note Sending Mail::.  *Note
     Rmail::, for one way to read mail with Emacs.

Mail Composition Method
     A mail composition method is a program runnable within Emacs for
     editing and sending a mail message.  Emacs lets you select from
     several alternative mail composition methods.  *Note Mail
     Methods::.

Major Mode
     The Emacs major modes are a mutually exclusive set of options, each
     of which configures Emacs for editing a certain sort of text.
     Ideally, each programming language has its own major mode.  *Note
     Major Modes::.

Margin
     The space between the usable part of a window (including the
     fringe) and the window edge.

Mark
     The mark points to a position in the text.  It specifies one end of
     the region (q.v.), point being the other end.  Many commands
     operate on all the text from point to the mark.  Each buffer has
     its own mark.  *Note Mark::.

Mark Ring
     The mark ring is used to hold several recent previous locations of
     the mark, in case you want to move back to them.  Each buffer has
     its own mark ring; in addition, there is a single global mark ring
     (q.v.).  *Note Mark Ring::.

Menu Bar
     The menu bar is a line at the top of an Emacs frame.  It contains
     words you can click on with the mouse to bring up menus, or you can
     use a keyboard interface to navigate it.  *Note Menu Bars::.

Message
     *Note Glossary---Mail::.

Meta
     Meta is the name of a modifier bit which you can use in a command
     character.  To enter a meta character, you hold down the <Meta> key
     while typing the character.  We refer to such characters with names
     that start with 'Meta-' (usually written 'M-' for short).  For
     example, 'M-<' is typed by holding down <Meta> and at the same time
     typing '<' (which itself is done, on most terminals, by holding
     down <SHIFT> and typing ',').  *Note Meta: User Input.

     On some terminals, the <Meta> key is actually labeled <Alt> or
     <Edit>.

Meta Character
     A Meta character is one whose character code includes the Meta bit.

Minibuffer
     The minibuffer is the window that appears when necessary inside the
     echo area (q.v.), used for reading arguments to commands.  *Note
     Minibuffer::.

Minibuffer History
     The minibuffer history records the text you have specified in the
     past for minibuffer arguments, so you can conveniently use the same
     text again.  *Note Minibuffer History::.

Minor Mode
     A minor mode is an optional feature of Emacs, which can be switched
     on or off independently of all other features.  Each minor mode has
     a command to turn it on or off.  Some minor modes are global
     (q.v.), and some are local (q.v.).  *Note Minor Modes::.

Minor Mode Keymap
     A minor mode keymap is a keymap that belongs to a minor mode and is
     active when that mode is enabled.  Minor mode keymaps take
     precedence over the buffer's local keymap, just as the local keymap
     takes precedence over the global keymap.  *Note Keymaps::.

Mode Line
     The mode line is the line at the bottom of each window (q.v.),
     giving status information on the buffer displayed in that window.
     *Note Mode Line::.

Modified Buffer
     A buffer (q.v.) is modified if its text has been changed since the
     last time the buffer was saved (or since it was created, if it has
     never been saved).  *Note Saving::.

Moving Text
     Moving text means erasing it from one place and inserting it in
     another.  The usual way to move text is by killing (q.v.) it and
     then yanking (q.v.) it.  *Note Killing::.

MULE
     Prior to Emacs 23, MULE was the name of a software package which
     provided a "MULtilingual Enhancement" to Emacs, by adding support
     for multiple character sets (q.v.).  MULE was later integrated into
     Emacs, and much of it was replaced when Emacs gained internal
     Unicode support in version 23.

     Some parts of Emacs that deal with character set support still use
     the MULE name.  *Note International::.

Multibyte Character
     A multibyte character is a character that takes up several bytes in
     a buffer.  Emacs uses multibyte characters to represent non-ASCII
     text, since the number of non-ASCII characters is much more than
     256.  *Note International Characters: International Chars.

Named Mark
     A named mark is a register (q.v.), in its role of recording a
     location in text so that you can move point to that location.
     *Note Registers::.

Narrowing
     Narrowing means creating a restriction (q.v.) that limits editing
     in the current buffer to only a part of the text.  Text outside
     that part is inaccessible for editing (or viewing) until the
     boundaries are widened again, but it is still there, and saving the
     file saves it all.  *Note Narrowing::.

Newline
     Control-J characters in the buffer terminate lines of text and are
     therefore also called newlines.  *Note Glossary---End Of Line::.

'nil'
     'nil' is a value usually interpreted as a logical "false".  Its
     opposite is 't', interpreted as "true".

Numeric Argument
     A numeric argument is a number, specified before a command, to
     change the effect of the command.  Often the numeric argument
     serves as a repeat count.  *Note Arguments::.

Overwrite Mode
     Overwrite mode is a minor mode.  When it is enabled, ordinary text
     characters replace the existing text after point rather than
     pushing it to one side.  *Note Minor Modes::.

Package
     A package is a collection of Lisp code that you download and
     automatically install from within Emacs.  Packages provide a
     convenient way to add new features.  *Note Packages::.

Page
     A page is a unit of text, delimited by formfeed characters (ASCII
     control-L, code 014) at the beginning of a line.  Some Emacs
     commands are provided for moving over and operating on pages.
     *Note Pages::.

Paragraph
     Paragraphs are the medium-size unit of human-language text.  There
     are special Emacs commands for moving over and operating on
     paragraphs.  *Note Paragraphs::.

Parsing
     We say that certain Emacs commands parse words or expressions in
     the text being edited.  Really, all they know how to do is find the
     other end of a word or expression.

Point
     Point is the place in the buffer at which insertion and deletion
     occur.  Point is considered to be between two characters, not at
     one character.  The terminal's cursor (q.v.) indicates the location
     of point.  *Note Point::.

Prefix Argument
     *Note Glossary---Numeric Argument::.

Prefix Key
     A prefix key is a key sequence (q.v.) whose sole function is to
     introduce a set of longer key sequences.  'C-x' is an example of
     prefix key; any two-character sequence starting with 'C-x' is
     therefore a legitimate key sequence.  *Note Keys::.

Primary Selection
     The primary selection is one particular X selection (q.v.); it is
     the selection that most X applications use for transferring text to
     and from other applications.

     The Emacs commands that mark or select text set the primary
     selection, and clicking the mouse inserts text from the primary
     selection when appropriate.  *Note Shift Selection::.

Prompt
     A prompt is text used to ask you for input.  Displaying a prompt is
     called prompting.  Emacs prompts always appear in the echo area
     (q.v.).  One kind of prompting happens when the minibuffer is used
     to read an argument (*note Minibuffer::); the echoing that happens
     when you pause in the middle of typing a multi-character key
     sequence is also a kind of prompting (*note Echo Area::).

q.v.
     Short for "quod vide" in Latin, which means "which see".

Query-Replace
     Query-replace is an interactive string replacement feature provided
     by Emacs.  *Note Query Replace::.

Quitting
     Quitting means canceling a partially typed command or a running
     command, using 'C-g' (or 'C-<BREAK>' on MS-DOS). *Note Quitting::.

Quoting
     Quoting means depriving a character of its usual special
     significance.  The most common kind of quoting in Emacs is with
     'C-q'.  What constitutes special significance depends on the
     context and on convention.  For example, an ordinary character as
     an Emacs command inserts itself; so in this context, a special
     character is any character that does not normally insert itself
     (such as <DEL>, for example), and quoting it makes it insert itself
     as if it were not special.  Not all contexts allow quoting.  *Note
     Quoting: Inserting Text.

Quoting File Names
     Quoting a file name turns off the special significance of
     constructs such as '$', '~' and ':'.  *Note Quoted File Names::.

Read-Only Buffer
     A read-only buffer is one whose text you are not allowed to change.
     Normally Emacs makes buffers read-only when they contain text which
     has a special significance to Emacs; for example, Dired buffers.
     Visiting a file that is write-protected also makes a read-only
     buffer.  *Note Buffers::.

Rectangle
     A rectangle consists of the text in a given range of columns on a
     given range of lines.  Normally you specify a rectangle by putting
     point at one corner and putting the mark at the diagonally opposite
     corner.  *Note Rectangles::.

Recursive Editing Level
     A recursive editing level is a state in which part of the execution
     of a command involves asking you to edit some text.  This text may
     or may not be the same as the text to which the command was
     applied.  The mode line (q.v.) indicates recursive editing levels
     with square brackets ('[' and ']').  *Note Recursive Edit::.

Redisplay
     Redisplay is the process of correcting the image on the screen to
     correspond to changes that have been made in the text being edited.
     *Note Redisplay: Screen.

Regexp
     *Note Glossary---Regular Expression::.

Region
     The region is the text between point (q.v.) and the mark (q.v.).
     Many commands operate on the text of the region.  *Note Region:
     Mark.

Register
     Registers are named slots in which text, buffer positions, or
     rectangles can be saved for later use.  *Note Registers::.  A
     related Emacs feature is bookmarks (q.v.).

Regular Expression
     A regular expression is a pattern that can match various text
     strings; for example, 'a[0-9]+' matches 'a' followed by one or more
     digits.  *Note Regexps::.

Remote File
     A remote file is a file that is stored on a system other than your
     own.  Emacs can access files on other computers provided that they
     are reachable from your machine over the network, and (obviously)
     that you have a supported method to gain access to those files.
     *Note Remote Files::.

Repeat Count
     *Note Glossary---Numeric Argument::.

Replacement
     *Note Glossary---Global Substitution::.

Restriction
     A buffer's restriction is the amount of text, at the beginning or
     the end of the buffer, that is temporarily inaccessible.  Giving a
     buffer a nonzero amount of restriction is called narrowing (q.v.);
     removing a restriction is called widening (q.v.).  *Note
     Narrowing::.

<RET>
     <RET> is a character that in Emacs runs the command to insert a
     newline into the text.  It is also used to terminate most arguments
     read in the minibuffer (q.v.).  *Note Return: User Input.

Reverting
     Reverting means returning to the original state.  For example,
     Emacs lets you revert a buffer by re-reading its file from disk.
     *Note Reverting::.

Saving
     Saving a buffer means copying its text into the file that was
     visited (q.v.) in that buffer.  This is the way text in files
     actually gets changed by your Emacs editing.  *Note Saving::.

Scroll Bar
     A scroll bar is a tall thin hollow box that appears at the side of
     a window.  You can use mouse commands in the scroll bar to scroll
     the window.  The scroll bar feature is supported only under
     windowing systems.  *Note Scroll Bars::.

Scrolling
     Scrolling means shifting the text in the Emacs window so as to see
     a different part of the buffer.  *Note Scrolling::.

Searching
     Searching means moving point to the next occurrence of a specified
     string or the next match for a specified regular expression.  *Note
     Search::.

Search Path
     A search path is a list of directories, to be used for searching
     for files for certain purposes.  For example, the variable
     'load-path' holds a search path for finding Lisp library files.
     *Note Lisp Libraries::.

Secondary Selection
     The secondary selection is one particular X selection (q.v.); some
     X applications can use it for transferring text to and from other
     applications.  Emacs has special mouse commands for transferring
     text using the secondary selection.  *Note Secondary Selection::.

Selected Frame
     The selected frame is the one your input currently operates on.
     *Note Frames::.

Selected Window
     The selected window is the one your input currently operates on.
     *Note Basic Window::.

Selecting a Buffer
     Selecting a buffer means making it the current (q.v.) buffer.
     *Note Select Buffer::.

Selection
     Windowing systems allow an application program to specify
     selections whose values are text.  A program can also read the
     selections that other programs have set up.  This is the principal
     way of transferring text between window applications.  Emacs has
     commands to work with the primary (q.v.) selection and the
     secondary (q.v.) selection, and also with the clipboard (q.v.).

Self-Documentation
     Self-documentation is the feature of Emacs that can tell you what
     any command does, or give you a list of all commands related to a
     topic you specify.  You ask for self-documentation with the help
     character, 'C-h'.  *Note Help::.

Self-Inserting Character
     A character is self-inserting if typing that character inserts that
     character in the buffer.  Ordinary printing and whitespace
     characters are self-inserting in Emacs, except in certain special
     major modes.

Sentences
     Emacs has commands for moving by or killing by sentences.  *Note
     Sentences::.

Server
     Within Emacs, you can start a "server" process, which listens for
     connections from "clients".  This offers a faster alternative to
     starting several Emacs instances.  *Note Emacs Server::, and *note
     Glossary---Daemon::.

Sexp
     A sexp (short for "s-expression") is the basic syntactic unit of
     Lisp in its textual form: either a list, or Lisp atom.  Sexps are
     also the balanced expressions (q.v.) of the Lisp language; this is
     why the commands for editing balanced expressions have 'sexp' in
     their name.  *Note Sexps: Expressions.

Simultaneous Editing
     Simultaneous editing means two users modifying the same file at
     once.  Simultaneous editing, if not detected, can cause one user to
     lose his or her work.  Emacs detects all cases of simultaneous
     editing, and warns one of the users to investigate.  *Note
     Interlocking: Interlocking.

<SPC>
     <SPC> is the space character, which you enter by pressing the space
     bar.

Speedbar
     The speedbar is a special tall frame that provides fast access to
     Emacs buffers, functions within those buffers, Info nodes, and
     other interesting parts of text within Emacs.  *Note Speedbar::.

Spell Checking
     Spell checking means checking correctness of the written form of
     each one of the words in a text.  Emacs can use various external
     spelling-checker programs to check the spelling of parts of a
     buffer via a convenient user interface.  *Note Spelling::.

String
     A string is a kind of Lisp data object that contains a sequence of
     characters.  Many Emacs variables are intended to have strings as
     values.  The Lisp syntax for a string consists of the characters in
     the string with a '"' before and another '"' after.  A '"' that is
     part of the string must be written as '\"' and a '\' that is part
     of the string must be written as '\\'.  All other characters,
     including newline, can be included just by writing them inside the
     string; however, backslash sequences as in C, such as '\n' for
     newline or '\241' using an octal character code, are allowed as
     well.

String Substitution
     *Note Glossary---Global Substitution::.

Syntax Highlighting
     *Note Glossary---Font Lock::.

Syntax Table
     The syntax table tells Emacs which characters are part of a word,
     which characters balance each other like parentheses, etc.  *Note
     Syntax Tables: (elisp)Syntax Tables.

Super
     Super is the name of a modifier bit that a keyboard input character
     may have.  To make a character Super, type it while holding down
     the <SUPER> key.  Such characters are given names that start with
     'Super-' (usually written 's-' for short).  *Note Modifier Keys::.

Suspending
     Suspending Emacs means stopping it temporarily and returning
     control to its parent process, which is usually a shell.  Unlike
     killing a job (q.v.), you can later resume the suspended Emacs job
     without losing your buffers, unsaved edits, undo history, etc.
     *Note Exiting::.

<TAB>
     <TAB> is the tab character.  In Emacs it is typically used for
     indentation or completion.

Tab Bar
     The tab bar is a row of tabs at the top of an Emacs frame.
     Clicking on one of these tabs switches named persistent window
     configurations.  *Note Tab Bars::.

Tab Line
     The tab line is a line of tabs at the top of an Emacs window.
     Clicking on one of these tabs switches window buffers.  *Note Tab
     Line::.

Tags Table
     A tags table is a file that serves as an index to the function
     definitions in one or more other files.  *Note Tags Tables::.

Termscript File
     A termscript file contains a record of all characters sent by Emacs
     to the terminal.  It is used for tracking down bugs in Emacs
     redisplay.  Emacs does not make a termscript file unless you tell
     it to.  *Note Bugs::.

Text

     "Text" has two meanings (*note Text::):

        * Data consisting of a sequence of characters, as opposed to
          binary numbers, executable programs, and the like.  The basic
          contents of an Emacs buffer (aside from the text properties,
          q.v.) are always text in this sense.

        * Data consisting of written human language (as opposed to
          programs), or following the stylistic conventions of human
          language.

Text Terminal
     A text terminal, or character terminal, is a display that is
     limited to displaying text in character units.  Such a terminal
     cannot control individual pixels it displays.  Emacs supports a
     subset of display features on text terminals.

Text Properties
     Text properties are annotations recorded for particular characters
     in the buffer.  Images in the buffer are recorded as text
     properties; they also specify formatting information.  *Note
     Editing Format Info::.

Theme
     A theme is a set of customizations (q.v.) that give Emacs a
     particular appearance or behavior.  For example, you might use a
     theme for your favorite set of faces (q.v.).

Tool Bar
     The tool bar is a line (sometimes multiple lines) of icons at the
     top of an Emacs frame.  Clicking on one of these icons executes a
     command.  You can think of this as a graphical relative of the menu
     bar (q.v.).  *Note Tool Bars::.

Tooltips
     Tooltips are small windows displaying a help echo (q.v.) text,
     which explains parts of the display, lists useful options available
     via mouse clicks, etc.  *Note Tooltips::.

Top Level
     Top level is the normal state of Emacs, in which you are editing
     the text of the file you have visited.  You are at top level
     whenever you are not in a recursive editing level (q.v.) or the
     minibuffer (q.v.), and not in the middle of a command.  You can get
     back to top level by aborting (q.v.) and quitting (q.v.).  *Note
     Quitting::.

Transient Mark Mode
     The default behavior of the mark (q.v.) and region (q.v.), in which
     setting the mark activates it and highlights the region, is called
     Transient Mark mode.  In GNU Emacs 23 and onwards, it is enabled by
     default.  *Note Disabled Transient Mark::.

Transposition
     Transposing two units of text means putting each one into the place
     formerly occupied by the other.  There are Emacs commands to
     transpose two adjacent characters, words, balanced expressions
     (q.v.) or lines (*note Transpose::).

Trash Can
     *Note Glossary---Deletion of Files::.

Truncation
     Truncating text lines in the display means leaving out any text on
     a line that does not fit within the right margin of the window
     displaying it.  *Note Truncation: Continuation Lines, and *note
     Glossary---Continuation Line::.

TTY
     *Note Glossary---Text Terminal::.

Undoing
     Undoing means making your previous editing go in reverse, bringing
     back the text that existed earlier in the editing session.  *Note
     Undo::.

Unix
     Unix is a class of multi-user computer operating systems with a
     long history.  There are several implementations today.  The GNU
     project (q.v.) aims to develop a complete Unix-like operating
     system that is free software (q.v.).

User Option
     A user option is a face (q.v.) or a variable (q.v.) that exists so
     that you can customize Emacs by setting it to a new value.  *Note
     Easy Customization::.

Variable
     A variable is an object in Lisp that can store an arbitrary value.
     Emacs uses some variables for internal purposes, and has others
     (known as "user options"; q.v.) just so that you can set their
     values to control the behavior of Emacs.  The variables used in
     Emacs that you are likely to be interested in are listed in the
     Variables Index in this manual (*note Variable Index::).  *Note
     Variables::, for information on variables.

Version Control
     Version control systems keep track of multiple versions of a source
     file.  They provide a more powerful alternative to keeping backup
     files (q.v.).  *Note Version Control::.

Visiting
     Visiting a file means loading its contents into a buffer (q.v.)
     where they can be edited.  *Note Visiting::.

Whitespace
     Whitespace is any run of consecutive formatting characters (space,
     tab, newline, backspace, etc.).

Widening
     Widening is removing any restriction (q.v.) on the current buffer;
     it is the opposite of narrowing (q.v.).  *Note Narrowing::.

Window
     Emacs divides a frame (q.v.) into one or more windows, each of
     which can display the contents of one buffer (q.v.) at any time.
     *Note Screen::, for basic information on how Emacs uses the screen.
     *Note Windows::, for commands to control the use of windows.  Some
     other editors use the term "window" for what we call a "frame" in
     Emacs.

Window System
     A window system is software that operates on a graphical display
     (q.v.), to subdivide the screen so that multiple applications can
     have their own windows at the same time.  All modern operating
     systems include a window system.

Word Abbrev
     *Note Glossary---Abbrev::.

Word Search
     Word search is searching for a sequence of words, considering the
     punctuation between them as insignificant.  *Note Word Search::.

Yanking
     Yanking means reinserting text previously killed (q.v.).  It can be
     used to undo a mistaken kill, or for copying or moving text.  Some
     other systems call this "pasting".  *Note Yanking::.

==============================================================================
File: emacs.info,  Node: |Acknowledgments|,  Next: |Key_Index|,  Prev: |Glossary|,  Up: |Top|
==============================================================================

                                                               *Acknowledgments*

Acknowledgments
*****==========

Many people have contributed code included in the Free Software
Foundation's distribution of GNU Emacs.  To show our appreciation for
their public spirit, we list here in alphabetical order those who have
written substantial portions.  Others too numerous to mention have
reported and fixed bugs, and added features to many parts of Emacs.  We
thank them for their generosity as well.

   This list is intended to mention every contributor of a major package
or feature we currently distribute; if you know of someone we have
omitted, please make a bug report.  More comprehensive information is
available in the 'ChangeLog' files, summarized in the file 'etc/AUTHORS'
in the distribution.

   * Per Abrahamsen wrote the customization facilities, as well as
     'double.el', for typing accented characters not normally available
     from the keyboard; 'xt-mouse.el', which allows mouse commands
     through Xterm; 'gnus-cus.el', which implements customization
     commands for Gnus; 'gnus-cite.el', a citation-parsing facility for
     news articles; 'gnus-score.el', scoring for Gnus; 'cpp.el', which
     hides or highlights parts of C programs according to preprocessor
     conditionals; and the widget library files 'wid-browse.el',
     'wid-edit.el', 'widget.el'.  He also co-wrote 'gnus-soup.el'.

   * Tomas Abrahamsson wrote 'artist.el', a package for producing ASCII
     art with a mouse or with keyboard keys.

   * Jay K. Adams wrote 'jka-compr.el' and 'jka-cmpr-hook.el', providing
     automatic decompression and recompression for compressed files.

   * Michael Albinus wrote 'dbus.el', a package that implements the
     D-Bus message bus protocol; 'zeroconf.el', a mode for browsing
     Avahi services; 'secrets.el', an interface to keyring daemons for
     storing confidential data; and 'filenotify.el' and the associated
     low-level interface routines, for watching file status changes.  He
     and Kai Grossjohann wrote the Tramp package, which provides
     transparent remote file editing using ssh, ftp, and other network
     protocols.  He and Daniel Pittman wrote 'tramp-cache.el'.

   * Ralf Angeli wrote 'scroll-lock.el', a minor mode which keeps the
     point vertically fixed by scrolling the window when moving up and
     down in the buffer.

   * Aure'lien Aptel added dynamic module support to Emacs.  Philipp
     Stephani and others also worked on the dynamic module code.

   * Joe Arceneaux wrote the original text property implementation, and
     implemented support for X11.

   * Emil ??stro"m, Milan Zamaza, and Stefan Bruda wrote 'prolog.el', a
     mode for editing Prolog (and Mercury) code.

   * Miles Bader wrote 'image-file.el', support code for visiting image
     files; 'minibuf-eldef.el', a minor mode that hides the minibuffer
     default value when appropriate; 'rfn-eshadow.el', shadowing of
     'read-file-name' input; 'mb-depth.el', display of minibuffer depth;
     'button.el', the library that implements clickable buttons;
     'face-remap.el', a package for changing the default face in
     individual buffers; and 'macroexp.el' for macro-expansion.  He also
     worked on an early version of the lexical binding code.

   * David Bakhash wrote 'strokes.el', a mode for controlling Emacs by
     moving the mouse in particular patterns.

   * Juanma Barranquero wrote 'emacs-lock.el' (based on the original
     version by Tom Wurgler), which makes it harder to exit with
     valuable buffers unsaved; and 'frameset.el', for saving and
     restoring the frame/window setup.  He also made many other
     contributions to other areas, including MS Windows support.

   * Eli Barzilay wrote 'calculator.el', a desktop calculator for Emacs.

   * Steven L. Baur wrote 'footnote.el' which lets you include footnotes
     in email messages; and 'gnus-audio.el' and 'earcon.el', which
     provide sound effects for Gnus.  He also wrote 'gnus-setup.el'.

   * Alexander L. Belikoff, Sergey Berezin, Sacha Chua, David Edmondson,
     Noah Friedman, Andreas Fuchs, Mario Lang, Ben Mesander, Lawrence
     Mitchell, Gergely Nagy, Michael Olson, Per Persson, Jorgen Scha"fer,
     Alex Schroeder, and Tom Tromey wrote ERC, an advanced Internet
     Relay Chat client (for more information, see the file 'CREDITS' in
     the ERC distribution).

   * Scott Bender, Michael Brouwer, Christophe de Dinechin, Carl Edman,
     Christian Limpach and Adrian Robert developed and maintained the
     NeXTstep port of Emacs.

   * Stephen Berman wrote 'todo-mode.el' (based on the original version
     by Oliver Seidel), a package for maintaining 'TODO' list files.

   * Anna M. Bigatti wrote 'cal-html.el', which produces HTML calendars.

   * Ray Blaak and Simon South wrote 'opascal.el', a mode for editing
     Object Pascal source code.

   * Martin Blais, Stefan Merten, and David Goodger wrote 'rst.el', a
     mode for editing reStructuredText documents.

   * Jim Blandy wrote Emacs 19's input system, brought its configuration
     and build process up to the GNU coding standards, and contributed
     to the frame support and multi-face support.  Jim also wrote
     'tvi970.el', terminal support for the TeleVideo 970 terminals; and
     co-wrote 'wyse50.el' (q.v.).

   * Per Bothner wrote 'term.el', a terminal emulator in an Emacs
     buffer.

   * Terrence M. Brannon wrote 'landmark.el', a neural-network robot
     that learns landmarks.

   * Frank Bresz wrote 'diff.el', a program to display 'diff' output.

   * Peter Breton implemented 'dirtrack.el', a library for tracking
     directory changes in shell buffers; 'filecache.el', which records
     which directories your files are in; 'locate.el', which interfaces
     to the 'locate' command; 'find-lisp.el', an Emacs Lisp emulation of
     the 'find' program; 'net-utils.el'; and the generic mode feature.

   * Emmanuel Briot wrote 'xml.el', an XML parser for Emacs; and
     'ada-prj.el', editing of Ada mode project files, as well as
     co-authoring 'ada-mode.el' and 'ada-xref.el'.

   * Kevin Broadey wrote 'foldout.el', providing folding extensions to
     Emacs's outline modes.

   * David M. Brown wrote 'array.el', for editing arrays and other
     tabular data.

   * W??odek Bzyl and Ryszard Kubiak wrote 'ogonek.el', a package for
     changing the encoding of Polish characters.

   * Bill Carpenter provided 'feedmail.el', a package for massaging
     outgoing mail messages and sending them through various popular
     mailers.

   * Per Cederqvist and Inge Wallin wrote 'ewoc.el', an Emacs widget for
     manipulating object collections.  Per Cederqvist, Inge Wallin, and
     Thomas Bellman wrote 'avl-tree.el', for balanced binary trees.

   * Hans Chalupsky wrote 'advice.el', an overloading mechanism for
     Emacs Lisp functions; and 'trace.el', a tracing facility for Emacs
     Lisp.

   * Chris Chase, Carsten Dominik, and J. D. Smith wrote IDLWAVE mode,
     for editing IDL and WAVE CL.

   * Bob Chassell wrote 'texnfo-upd.el', 'texinfo.el', and
     'makeinfo.el', modes and utilities for working with Texinfo files;
     and 'page-ext.el', commands for extended page handling.  He also
     wrote the Emacs Lisp introduction.  *Note (eintr)Top::.

   * Jihyun Cho wrote 'hanja-util.el' and 'hangul.el', utilities for
     Korean Hanja.

   * Andrew Choi and Yamamoto Mitsuharu wrote the Carbon support, used
     prior to Emacs 23 for macOS.  Yamamoto Mitsuharu continued to
     contribute to macOS support in the newer Nextstep port; and also
     improved support for multi-monitor displays.

   * Chong Yidong was the Emacs co-maintainer from Emacs 23 to 24.3.  He
     made many improvements to the Emacs display engine.  He also wrote
     'tabulated-list.el', a generic major mode for lists of data; and
     improved support for themes and packages.

   * James Clark wrote SGML mode, a mode for editing SGML documents; and
     nXML mode, a mode for editing XML documents.  He also contributed
     to Emacs's dumping procedures.

   * Mike Clarkson wrote 'edt.el', an emulation of DEC's EDT editor.

   * Glynn Clements provided 'gamegrid.el' and a couple of games that
     use it, Snake and Tetris.

   * Andrew Cohen wrote 'spam-wash.el', to decode and clean email before
     it is analyzed for spam.

   * Daniel Colascione wrote the portable dumping code in 'pdumper.c'
     and elsewhere.  He also implemented double-buffering for X-based
     GUI frames, and the original support for loading shared-object
     modules into Emacs.

   * Theresa O'Connor wrote 'json.el', a file for parsing and generating
     JSON files.

   * Georges Brun-Cottan and Stefan Monnier wrote 'easy-mmode.el', a
     package for easy definition of major and minor modes.

   * Andrew Csillag wrote M4 mode ('m4-mode.el').

   * Doug Cutting and Jamie Zawinski wrote 'disass.el', a disassembler
     for compiled Emacs Lisp code.

   * Mathias Dahl wrote 'image-dired.el', a package for viewing image
     files as thumbnails.

   * Julien Danjou wrote an implementation of desktop notifications
     ('notifications.el', and related packages for ERC and Gnus); and
     'color.el', a library for general color manipulation.  He also made
     various contributions to Gnus.

   * Vivek Dasmohapatra wrote 'htmlfontify.el', to convert a buffer or
     source tree to HTML.

   * Matthieu Devin wrote 'delsel.el', a package to make newly-typed
     text replace the current selection.

   * Eric Ding wrote 'goto-addr.el',

   * Jan Dja"rv added support for the GTK+ toolkit and X drag-and-drop.
     He also wrote 'dynamic-setting.el'.

   * Carsten Dominik wrote RefTeX, a package for setting up labels and
     cross-references in LaTeX documents; and co-wrote IDLWAVE mode
     (q.v.).  He was the original author of Org mode, for maintaining
     notes, todo lists, and project planning.  Bastien Guerry
     subsequently took over maintainership.  Benjamin Andresen, Thomas
     Baumann, Joel Boehland, Jan Bo"cker, Lennart Borgman, Baoqiu Cui,
     Dan Davison, Christian Egli, Eric S. Fraga, Daniel German, Chris
     Gray, Konrad Hinsen, Tassilo Horn, Philip Jackson, Martyn Jago,
     Thorsten Jolitz, Jambunathan K, Tokuya Kameshima, Sergey Litvinov,
     David Maus, Ross Patterson, Juan Pechiar, Sebastian Rose, Eric
     Schulte, Paul Sexton, Ulf Stegemann, Andy Stewart, Christopher
     Suckling, David O'Toole, John Wiegley, Zhang Weize, Piotr
     Zieli??ski, and others also wrote various Org mode components.  For
     more information, *note (org)History and Acknowledgments::.

   * Scott Draves wrote 'tq.el', help functions for maintaining
     transaction queues between Emacs and its subprocesses.

   * Benjamin Drieu wrote 'pong.el', an implementation of the classical
     pong game.

   * Viktor Dukhovni wrote support for dumping under SunOS version 4.

   * John Eaton and Kurt Hornik wrote Octave mode.

   * Rolf Ebert, Markus Heritsch, and Emmanuel Briot wrote Ada mode.

   * Paul Eggert integrated the Gnulib portability library, and made
     many other portability fixes to the C code; as well as his
     contributions to VC and the calendar.

   * Stephen Eglen wrote 'mspools.el', which tells you which Procmail
     folders have mail waiting in them.

   * Torbjo"rn Einarsson wrote 'f90.el', a mode for Fortran 90 files.

   * Tsugutomo Enami co-wrote the support for international character
     sets.

   * David Engster wrote 'mairix.el' and 'nnmairix.el', an interface to
     the Mairix indexing tool.

   * Hans Henrik Eriksen wrote 'simula.el', a mode for editing SIMULA 87
     code.

   * Michael Ernst wrote 'reposition.el', a command for recentering a
     function's source code and preceding comment on the screen.

   * Ata Etemadi wrote 'cdl.el', functions for working with Common Data
     Language source code.

   * Frederick Farnbach implemented 'morse.el', which converts text to
     Morse code.

   * Oscar Figueiredo wrote EUDC, the Emacs Unified Directory Client,
     which is an interface to directory servers via LDAP, CCSO PH/QI, or
     BBDB; and 'ldap.el', the LDAP client interface.

   * Fred Fish wrote the support for dumping COFF executable files.

   * Karl Fogel wrote 'bookmark.el', which implements named
     placeholders; 'mail-hist.el', a history mechanism for outgoing mail
     messages; and 'saveplace.el', for preserving point's location in
     files between editing sessions.

   * Gary Foster wrote 'scroll-all.el', a mode for scrolling several
     buffers together.

   * Romain Francoise contributed ACL (Access Control List) support, for
     preserving extended file attributes on backup and copy.

   * Noah Friedman wrote 'rlogin.el', an interface to Rlogin,
     'type-break.el', which reminds you to take periodic breaks from
     typing, and 'eldoc-mode', a mode to show the defined parameters or
     the doc string for the Lisp function near point.

   * Shigeru Fukaya wrote a testsuite for the byte-compiler.

   * Keith Gabryelski wrote 'hexl.el', a mode for editing binary files.

   * Kevin Gallagher rewrote and enhanced the EDT emulation, and wrote
     'flow-ctrl.el', a package for coping with unsuppressible XON/XOFF
     flow control.

   * Fabi??n E. Gallina rewrote 'python.el', the major mode for the
     Python programming language used in Emacs 24.3 onwards.

   * Kevin Gallo added multiple-frame support for Windows NT and wrote
     'w32-win.el', support functions for the MS-Windows window system.

   * Juan Le??n Lahoz Garc??a wrote 'wdired.el', a package for performing
     file operations by directly editing Dired buffers.

   * Howard Gayle wrote much of the C and Lisp code for display tables
     and case tables.  He also wrote 'rot13.el', a command to display
     the plain-text form of a buffer encoded with the Caesar cipher;
     'vt100-led.el', a package for controlling the LEDs on
     VT100-compatible terminals; and much of the support for ISO-8859
     European character sets (which includes 'iso-ascii.el',
     'iso-insert.el', 'iso-swed.el', 'iso-syntax.el', 'iso-transl.el',
     and 'swedish.el').

   * Stephen Gildea made the Emacs quick reference card, and made many
     contributions for 'time-stamp.el', a package for maintaining
     last-change time stamps in files.

   * Julien Gilles wrote 'gnus-ml.el', a mailing list minor mode for
     Gnus.

   * David Gillespie wrote the Common Lisp compatibility packages;
     'Calc', an advanced calculator and mathematical tool, since
     maintained and developed by Jay Belanger; 'complete.el', a partial
     completion mechanism; and 'edmacro.el', a package for editing
     keyboard macros.

   * Bob Glickstein wrote 'sregex.el', a facility for writing regexps
     using a Lisp-like syntax.

   * Boris Goldowsky wrote 'avoid.el', a package to keep the mouse
     cursor out of the way of the text cursor; 'shadowfile.el', a
     package for keeping identical copies of files in more than one
     place; 'format.el', a package for reading and writing files in
     various formats; 'enriched.el', a package for saving text
     properties in files; 'facemenu.el', a package for specifying faces;
     and 'descr-text.el', describing text and character properties.

   * Michelangelo Grigni wrote 'ffap.el' which visits a file, taking the
     file name from the buffer.

   * Odd Gripenstam wrote 'dcl-mode.el' for editing DCL command files.

   * Michael Gschwind wrote 'iso-cvt.el', a package to convert between
     the ISO 8859-1 character set and the notations for non-ASCII
     characters used by TeX and net tradition.

   * Bastien Guerry wrote 'gnus-bookmark.el', bookmark support for Gnus;
     as well as helping to maintain Org mode (q.v.).

   * Henry Guillaume wrote 'find-file.el', a package to visit files
     related to the currently visited file.

   * Doug Gwyn wrote the portable 'alloca' implementation.

   * Ken'ichi Handa implemented most of the support for international
     character sets, and wrote most of the Emacs 23 font handling code.
     He also wrote 'composite.el', which provides a minor mode that
     composes characters automatically when they are displayed;
     'isearch-x.el', a facility for searching non-ASCII text; and
     'ps-bdf.el', a BDF font support for printing non-ASCII text on a
     PostScript printer.  Together with Naoto Takahashi, he wrote
     'quail.el', an input facility for typing non-ASCII text from an
     ASCII keyboard.

   * Jesper Harder wrote 'yenc.el', for decoding yenc encoded messages.

   * Alexandru Harsanyi wrote a library for accessing SOAP web services.

   * K. Shane Hartman wrote 'chistory.el' and 'echistory.el', packages
     for browsing command history lists; 'electric.el' and 'helper.el',
     which provide an alternative command loop and appropriate help
     facilities; 'emacsbug.el', a package for reporting Emacs bugs;
     'picture.el', a mode for editing ASCII pictures; and 'view.el', a
     package for perusing files and buffers without editing them.

   * John Heidemann wrote 'mouse-copy.el' and 'mouse-drag.el', which
     provide alternative mouse-based editing and scrolling features.

   * Jon K Hellan wrote 'utf7.el', support for mail-safe transformation
     format of Unicode.

   * Karl Heuer wrote the original blessmail script, implemented the
     'intangible' text property, and rearranged the structure of the
     'Lisp_Object' type to allow for more data bits.

   * Manabu Higashida ported Emacs to MS-DOS.

   * Anders Holst wrote 'hippie-exp.el', a versatile completion and
     expansion package.

   * Tassilo Horn wrote DocView mode, allowing viewing of PDF,
     PostScript and DVI documents.

   * Khaled Hosny, Yamamoto Mitsuharu, and Eli Zaretskii implemented
     text shaping with HarfBuzz for Emacs.

   * Joakim Hove wrote 'html2text.el', a html to plain text converter.

   * Denis Howe wrote 'browse-url.el', a package for invoking a WWW
     browser to display a URL.

   * Lars Magne Ingebrigtsen did a major redesign of the Gnus
     news-reader and wrote many of its parts.  Several of these are now
     general components of Emacs, including: 'dns.el' for Domain Name
     Service lookups; 'format-spec.el' for formatting arbitrary format
     strings; 'netrc.el' for parsing of '.netrc' files; and
     'time-date.el' for general date and time handling.  He also wrote
     'network-stream.el', for opening network processes; 'url-queue.el',
     for controlling parallel downloads of URLs; and implemented libxml2
     support.  He also wrote 'eww.el', an Emacs Lisp web browser; and
     implemented native zlib decompression.  Components of Gnus have
     also been written by: Nagy Andras, David Blacka, Scott Byer,
     Ludovic Courte`s, Julien Danjou, Kevin Greiner, Kai Grossjohann, Joe
     Hildebrand, Paul Jarc, Simon Josefsson, Sascha Lu"decke, David
     Moore, Jim Radford, Benjamin Rutt, Raymond Scholz, Thomas Steffen,
     Reiner Steib, Jan Tatarik, Didier Verna, Ilja Weis, Katsumi
     Yamaoka, Teodor Zlatanov, and others (*note (gnus)Contributors::).

   * Andrew Innes contributed extensively to the MS-Windows support.

   * Seiichiro Inoue improved Emacs's XIM support.

   * Philip Jackson wrote 'find-cmd.el', to build a 'find' command-line.

   * Ulf Jasper wrote 'icalendar.el', a package for converting Emacs
     diary entries to and from the iCalendar format; 'newsticker.el', an
     RSS and Atom based Newsticker; and 'bubbles.el', a puzzle game.

   * Kyle Jones wrote 'life.el', a package to play Conway's Game of
     Life.

   * Terry Jones wrote 'shadow.el', a package for finding potential
     load-path problems when some Lisp file shadows another.

   * Simon Josefsson wrote 'dns-mode.el', an editing mode for Domain
     Name System master files; 'dig.el', a Domain Name System interface;
     'flow-fill.el', a package for interpreting RFC2646 formatted text
     in messages; 'fringe.el', a package for customizing the fringe;
     'imap.el', an Emacs Lisp library for talking to IMAP servers;
     'password-cache.el', a password reader; 'nnimap.el', the IMAP
     back-end for Gnus; 'url-imap.el' for the URL library; 'rfc2104.el',
     a hashed message authentication facility; the Gnus S/MIME and Sieve
     components; and 'tls.el' and 'starttls.el' for the Transport Layer
     Security protocol.

   * Arne J??rgensen wrote 'latexenc.el', a package to automatically
     guess the correct coding system in LaTeX files.

   * Alexandre Julliard wrote 'vc-git.el', support for the Git version
     control system.

   * Tomoji Kagatani implemented 'smtpmail.el', used for sending out
     mail with SMTP.

   * Ivan Kanis wrote 'vc-hg.el', support for the Mercurial version
     control system.

   * Henry Kautz wrote 'bib-mode.el', a mode for maintaining
     bibliography databases compatible with 'refer' (the 'troff'
     version) and 'lookbib', and 'refbib.el', a package to convert those
     databases to the format used by the LaTeX text formatting package.

   * Taichi Kawabata added support for Devanagari script and the Indian
     languages, and wrote 'ucs-normalize.el' for Unicode normalization.

   * Taro Kawagishi implemented the MD4 Message Digest Algorithm in
     Lisp; and wrote 'ntlm.el' and 'sasl-ntlm.el' for NT LanManager
     authentication support.

   * Howard Kaye wrote 'sort.el', commands to sort text in Emacs
     buffers.

   * Michael Kifer wrote 'ediff', an interactive interface to the
     'diff', 'patch', and 'merge' programs; and Viper, an emulator of
     the VI editor.

   * Richard King wrote the first version of 'userlock.el' and
     'filelock.c', which provide simple support for multiple users
     editing the same file.  He also wrote the initial version of
     'uniquify.el', a facility to make buffer names unique by adding
     parts of the file's name to the buffer name.

   * Peter Kleiweg wrote 'ps-mode.el', a mode for editing PostScript
     files and running a PostScript interpreter interactively from
     within Emacs.

   * Karel Kl???? contributed SELinux support, for preserving the
     Security-Enhanced Linux context of files on backup and copy.

   * Shuhei Kobayashi wrote 'hex-util.el', for operating on hexadecimal
     strings; and support for HMAC (Keyed-Hashing for Message
     Authentication).

   * Pavel Kobyakov wrote 'flymake.el', a minor mode for performing
     on-the-fly syntax checking.

   * David M. Koppelman wrote 'hi-lock.el', a minor mode for interactive
     automatic highlighting of parts of the buffer text.

   * Koseki Yoshinori wrote 'iimage.el', a minor mode for displaying
     inline images.

   * Robert Krawitz wrote the original 'xmenu.c', part of Emacs's pop-up
     menu support.

   * Sebastian Kremer wrote 'dired-mode', with contributions by Lawrence
     R. Dodd.  He also wrote 'ls-lisp.el', a Lisp emulation of the 'ls'
     command for platforms that don't have 'ls' as a standard program.

   * David K??gedal wrote 'tempo.el', providing support for easy
     insertion of boilerplate text and other common constructions.

   * Igor Kuzmin wrote 'cconv.el', providing closure conversion for
     statically scoped Emacs lisp.

   * Daniel LaLiberte wrote 'edebug.el', a source-level debugger for
     Emacs Lisp; 'cl-specs.el', specifications to help 'edebug' debug
     code written using David Gillespie's Common Lisp support; and
     'isearch.el', Emacs's incremental search minor mode.  He also
     co-wrote 'hideif.el' (q.v.).

   * Karl Landstrom and Daniel Colascione wrote 'js.el', a mode for
     editing JavaScript.

   * Vinicius Jose Latorre wrote the Emacs printing facilities, as well
     as 'ps-print' (with Jim Thompson, Jacques Duthen, and Kenichi
     Handa), a package for pretty-printing Emacs buffers to PostScript
     printers; 'delim-col.el', a package to arrange text into columns;
     'ebnf2ps.el', a package that translates EBNF grammar to a syntactic
     chart that can be printed to a PostScript printer; and
     'whitespace.el', a package that detects and cleans up excess
     whitespace in a file (building on an earlier version by Rajesh
     Vaidheeswarran).

   * Frederic Lepied wrote 'expand.el', which uses the abbrev mechanism
     for inserting programming constructs.

   * Peter Liljenberg wrote 'elint.el', a Lint-style code checker for
     Emacs Lisp programs.

   * Lars Lindberg wrote 'msb.el', which provides more flexible menus
     for buffer selection; co-wrote 'imenu.el' (q.v.); and rewrote
     'dabbrev.el', originally written by Don Morrison.

   * Anders Lindgren wrote 'autorevert.el', a package for automatically
     reverting files visited by Emacs that were changed on disk;
     'cwarn.el', a package to highlight suspicious C and C++ constructs;
     and 'follow.el', a minor mode to synchronize windows that show the
     same buffer.

   * Thomas Link wrote 'filesets.el', a package for handling sets of
     files.

   * Juri Linkov wrote 'misearch.el', extending isearch to multi-buffer
     searches; the code in 'files-x.el' for handling file- and
     directory-local variables; and the 'info-finder' feature that
     creates a virtual Info manual of package keywords.  He also
     implemented the Tab Bar and window tab-lines, and added numerous
     enhancements and improvements in I-search.

   * Leo Liu wrote 'pcmpl-x.el', providing completion for miscellaneous
     external tools; and revamped support for Octave in Emacs 24.4.

   * K??roly L??rentey wrote the multi-terminal code, which allows Emacs
     to run on graphical and text terminals simultaneously.

   * Martin Lorentzon wrote 'vc-annotate.el', support for version
     control annotation.

   * Dave Love wrote much of the code dealing with Unicode support and
     Latin-N unification.  He added support for many coding systems,
     including the various UTF-7 and UTF-16 coding systems.  He also
     wrote 'autoarg-mode', a global minor mode whereby digit keys supply
     prefix arguments; 'autoarg-kp-mode', which redefines the keypad
     numeric keys to digit arguments; 'autoconf.el', a mode for editing
     Autoconf files; 'cfengine.el', a mode for editing Cfengine files;
     'elide-head.el', a package for eliding boilerplate text from file
     headers; 'hl-line.el', a minor mode for highlighting the line in
     the current window on which point is; 'cap-words.el', a minor mode
     for motion in 'CapitalizedWordIdentifiers'; 'latin1-disp.el', a
     package that lets you display ISO 8859 characters on Latin-1
     terminals by setting up appropriate display tables; the version of
     'python.el' used prior to Emacs 24.3; 'smiley.el', a facility for
     displaying smiley faces; 'sym-comp.el', a library for performing
     mode-dependent symbol completion; 'benchmark.el' for timing code
     execution; and 'tool-bar.el', a mode to control the display of the
     Emacs tool bar.  With Riccardo Murri he wrote 'vc-bzr.el', support
     for the Bazaar version control system.

   * Eric Ludlam wrote the Speedbar package; 'checkdoc.el', for checking
     doc strings in Emacs Lisp programs; 'dframe.el', providing
     dedicated frame support modes; 'ezimage.el', a generalized way to
     place images over text; 'chart.el' for drawing bar charts etc.; and
     the EIEIO (Enhanced Implementation of Emacs Interpreted Objects)
     package.  He was also the main author of the CEDET (Collection of
     Emacs Development Environment Tools) package.  Portions were also
     written by Jan Moringen, David Ponce, and Joakim Verona.

   * Roland McGrath wrote 'compile.el' (since updated by Daniel
     Pfeiffer), a package for running compilations in a buffer, and then
     visiting the locations reported in error messages; 'etags.el', a
     package for jumping to function definitions and searching or
     replacing in all the files mentioned in a 'TAGS' file; with
     Sebastian Kremer 'find-dired.el', for using 'dired' commands on
     output from the 'find' program; 'grep.el' for running the 'grep'
     command; 'map-ynp.el', a general purpose boolean question-asker;
     'autoload.el', providing semi-automatic maintenance of autoload
     files.

   * Alan Mackenzie wrote the integrated AWK support in CC Mode, and
     maintained CC Mode from Emacs 22 onwards.

   * Michael McNamara and Wilson Snyder wrote Verilog mode.

   * Christopher J. Madsen wrote 'decipher.el', a package for cracking
     simple substitution ciphers.

   * Neil M. Mager wrote 'appt.el', functions to notify users of their
     appointments.  It finds appointments recorded in the diary files
     used by the 'calendar' package.

   * Ken Manheimer wrote 'allout.el', a mode for manipulating and
     formatting outlines, and 'icomplete.el', which provides incremental
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
