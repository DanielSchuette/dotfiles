     AVERAGE-WIDTH CAPABILITY]'.  Here's the description of each
     components of this vector:

     NAME
          The font name, a string.

     FILENAME
          The file name of the font as a string.  This can be 'nil' if
          the font back-end does not provide a way to find out the
          font's file name.

     PIXEL-SIZE
          The pixel size of the font used to open the font.

     MAX-WIDTH
          The maximum advance width of the font.

     ASCENT
     DESCENT
          The ascent and descent of this font.  The sum of these two
          numbers gives the font height.

     SPACE-WIDTH
          The width, in pixels, of the font's space character.

     AVERAGE-WIDTH
          The average width of the font characters.  If this is zero,
          Emacs uses the value of SPACE-WIDTH instead, when it
          calculates text layout on display.

     CAPABILITY
          A list whose first element is a symbol representing the font
          type, one of 'x', 'opentype', 'truetype', 'type1', 'pcf', or
          'bdf'.  For OpenType fonts, the list includes 2 additional
          elements describing the GSUB and GPOS features supported by
          the font.  Each of these elements is a list of the form
          '((SCRIPT (LANGSYS FEATURE ...) ...) ...)', where SCRIPT is a
          symbol representing an OpenType script tag, LANGSYS is a
          symbol representing an OpenType langsys tag (or 'nil', which
          stands for the default langsys), and each FEATURE is a symbol
          representing an OpenType feature tag.

   The following four functions return size information about fonts used
by various faces, allowing various layout considerations in Lisp
programs.  These functions take face remapping into consideration,
returning information about the remapped face, if the face in question
was remapped.  *Note Face Remapping::.

 -- Function: default-font-width
     This function returns the average width in pixels of the font used
     by the current buffer's default face, as that face is defined for
     the selected frame.

 -- Function: default-font-height
     This function returns the height in pixels of the font used by the
     current buffer's default face, as that face is defined for the
     selected frame.

 -- Function: window-font-width &optional window face
     This function returns the average width in pixels for the font used
     by FACE in WINDOW.  The specified WINDOW must be a live window.  If
     'nil' or omitted, WINDOW defaults to the selected window, and FACE
     defaults to the default face in WINDOW.

 -- Function: window-font-height &optional window face
     This function returns the height in pixels for the font used by
     FACE in WINDOW.  The specified WINDOW must be a live window.  If
     'nil' or omitted, WINDOW defaults to the selected window, and FACE
     defaults to the default face in WINDOW.

==============================================================================
File: elisp.info,  Node: |Fringes|,  Next: |Scroll_Bars|,  Prev: |Faces|,  Up: |Display|
==============================================================================

                                                                       *Fringes*

39.13 Fringes
=====--------

On graphical displays, Emacs draws "fringes" next to each window: thin
vertical strips down the sides which can display bitmaps indicating
truncation, continuation, horizontal scrolling, and so on.

MENU

* |Fringe_Size/Pos|::     Specifying where to put the window fringes.
* |Fringe_Indicators|::   Displaying indicator icons in the window fringes.
* |Fringe_Cursors|::      Displaying cursors in the right fringe.
* |Fringe_Bitmaps|::      Specifying bitmaps for fringe indicators.
* |Customizing_Bitmaps|:: Specifying your own bitmaps to use in the fringes.
* |Overlay_Arrow|::       Display of an arrow to indicate position.

==============================================================================
File: elisp.info,  Node: |Fringe_Size/Pos|,  Next: |Fringe_Indicators|,  Up: |Fringes|
==============================================================================

                                                               *Fringe_Size/Pos*

39.13.1 Fringe Size and Position
--------------------------------

The following buffer-local variables control the position and width of
fringes in windows showing that buffer.

 -- Variable: fringes-outside-margins
     The fringes normally appear between the display margins and the
     window text.  If the value is non-'nil', they appear outside the
     display margins.  *Note Display Margins::.

 -- Variable: left-fringe-width
     This variable, if non-'nil', specifies the width of the left fringe
     in pixels.  A value of 'nil' means to use the left fringe width
     from the window's frame.

 -- Variable: right-fringe-width
     This variable, if non-'nil', specifies the width of the right
     fringe in pixels.  A value of 'nil' means to use the right fringe
     width from the window's frame.

   Any buffer which does not specify values for these variables uses the
values specified by the 'left-fringe' and 'right-fringe' frame
parameters (*note Layout Parameters::).

   The above variables actually take effect via the function
'set-window-buffer' (*note Buffers and Windows::), which calls
'set-window-fringes' as a subroutine.  If you change one of these
variables, the fringe display is not updated in existing windows showing
the buffer, unless you call 'set-window-buffer' again in each affected
window.  You can also use 'set-window-fringes' to control the fringe
display in individual windows.

 -- Function: set-window-fringes window left &optional right
          outside-margins persistent
     This function sets the fringe widths of window WINDOW.  If WINDOW
     is 'nil', the selected window is used.

     The argument LEFT specifies the width in pixels of the left fringe,
     and likewise RIGHT for the right fringe.  A value of 'nil' for
     either one stands for the default width.  If OUTSIDE-MARGINS is
     non-'nil', that specifies that fringes should appear outside of the
     display margins.

     If WINDOW is not large enough to accommodate fringes of the desired
     width, this leaves the fringes of WINDOW unchanged.

     The values specified here may be later overridden by invoking
     'set-window-buffer' (*note Buffers and Windows::) on WINDOW with
     its KEEP-MARGINS argument 'nil' or omitted.  However, if the
     optional fifth argument PERSISTENT is non-'nil' and the other
     arguments are processed successfully, the values specified here
     unconditionally survive subsequent invocations of
     'set-window-buffer'.  This can be used to permanently turn off
     fringes in the minibuffer window, consult the description of
     'set-window-scroll-bars' for an example (*note Scroll Bars::).

 -- Function: window-fringes &optional window
     This function returns information about the fringes of a window
     WINDOW.  If WINDOW is omitted or 'nil', the selected window is
     used.  The value has the form '(LEFT-WIDTH RIGHT-WIDTH
     OUTSIDE-MARGINS PERSISTENT)'.

==============================================================================
File: elisp.info,  Node: |Fringe_Indicators|,  Next: |Fringe_Cursors|,  Prev: |Fringe_Size/Pos|,  Up: |Fringes|
==============================================================================

                                                             *Fringe_Indicators*

39.13.2 Fringe Indicators
-------------------------

"Fringe indicators" are tiny icons displayed in the window fringe to
indicate truncated or continued lines, buffer boundaries, etc.

 -- User Option: indicate-empty-lines
     When this is non-'nil', Emacs displays a special glyph in the
     fringe of each empty line at the end of the buffer, on graphical
     displays.  *Note Fringes::.  This variable is automatically
     buffer-local in every buffer.

 -- User Option: indicate-buffer-boundaries
     This buffer-local variable controls how the buffer boundaries and
     window scrolling are indicated in the window fringes.

     Emacs can indicate the buffer boundaries--that is, the first and
     last line in the buffer--with angle icons when they appear on the
     screen.  In addition, Emacs can display an up-arrow in the fringe
     to show that there is text above the screen, and a down-arrow to
     show there is text below the screen.

     There are three kinds of basic values:

     'nil'
          Don't display any of these fringe icons.
     'left'
          Display the angle icons and arrows in the left fringe.
     'right'
          Display the angle icons and arrows in the right fringe.
     any non-alist
          Display the angle icons in the left fringe and don't display
          the arrows.

     Otherwise the value should be an alist that specifies which fringe
     indicators to display and where.  Each element of the alist should
     have the form '(INDICATOR . POSITION)'.  Here, INDICATOR is one of
     'top', 'bottom', 'up', 'down', and 't' (which covers all the icons
     not yet specified), while POSITION is one of 'left', 'right' and
     'nil'.

     For example, '((top . left) (t . right))' places the top angle
     bitmap in left fringe, and the bottom angle bitmap as well as both
     arrow bitmaps in right fringe.  To show the angle bitmaps in the
     left fringe, and no arrow bitmaps, use '((top . left) (bottom .
     left))'.

 -- Variable: fringe-indicator-alist
     This buffer-local variable specifies the mapping from logical
     fringe indicators to the actual bitmaps displayed in the window
     fringes.  The value is an alist of elements '(INDICATOR .
     BITMAPS)', where INDICATOR specifies a logical indicator type and
     BITMAPS specifies the fringe bitmaps to use for that indicator.

     Each INDICATOR should be one of the following symbols:

     'truncation', 'continuation'.
          Used for truncation and continuation lines.

     'up', 'down', 'top', 'bottom', 'top-bottom'
          Used when 'indicate-buffer-boundaries' is non-'nil': 'up' and
          'down' indicate a buffer boundary lying above or below the
          window edge; 'top' and 'bottom' indicate the topmost and
          bottommost buffer text line; and 'top-bottom' indicates where
          there is just one line of text in the buffer.

     'empty-line'
          Used to indicate empty lines after the buffer end when
          'indicate-empty-lines' is non-'nil'.

     'overlay-arrow'
          Used for overlay arrows (*note Overlay Arrow::).

     Each BITMAPS value may be a list of symbols '(LEFT RIGHT [LEFT1
     RIGHT1])'.  The LEFT and RIGHT symbols specify the bitmaps shown in
     the left and/or right fringe, for the specific indicator.  LEFT1
     and RIGHT1 are specific to the 'bottom' and 'top-bottom'
     indicators, and are used to indicate that the last text line has no
     final newline.  Alternatively, BITMAPS may be a single symbol which
     is used in both left and right fringes.

     *Note Fringe Bitmaps::, for a list of standard bitmap symbols and
     how to define your own.  In addition, 'nil' represents the empty
     bitmap (i.e., an indicator that is not shown).

     When 'fringe-indicator-alist' has a buffer-local value, and there
     is no bitmap defined for a logical indicator, or the bitmap is 't',
     the corresponding value from the default value of
     'fringe-indicator-alist' is used.

==============================================================================
File: elisp.info,  Node: |Fringe_Cursors|,  Next: |Fringe_Bitmaps|,  Prev: |Fringe_Indicators|,  Up: |Fringes|
==============================================================================

                                                                *Fringe_Cursors*

39.13.3 Fringe Cursors
----------------------

When a line is exactly as wide as the window, Emacs displays the cursor
in the right fringe instead of using two lines.  Different bitmaps are
used to represent the cursor in the fringe depending on the current
buffer's cursor type.

 -- User Option: overflow-newline-into-fringe
     If this is non-'nil', lines exactly as wide as the window (not
     counting the final newline character) are not continued.  Instead,
     when point is at the end of the line, the cursor appears in the
     right fringe.

 -- Variable: fringe-cursor-alist
     This variable specifies the mapping from logical cursor type to the
     actual fringe bitmaps displayed in the right fringe.  The value is
     an alist where each element has the form '(CURSOR-TYPE . BITMAP)',
     which means to use the fringe bitmap BITMAP to display cursors of
     type CURSOR-TYPE.

     Each CURSOR-TYPE should be one of 'box', 'hollow', 'bar', 'hbar',
     or 'hollow-small'.  The first four have the same meanings as in the
     'cursor-type' frame parameter (*note Cursor Parameters::).  The
     'hollow-small' type is used instead of 'hollow' when the normal
     'hollow-rectangle' bitmap is too tall to fit on a specific display
     line.

     Each BITMAP should be a symbol specifying the fringe bitmap to be
     displayed for that logical cursor type.  *Note Fringe Bitmaps::.

     When 'fringe-cursor-alist' has a buffer-local value, and there is
     no bitmap defined for a cursor type, the corresponding value from
     the default value of 'fringes-indicator-alist' is used.

==============================================================================
File: elisp.info,  Node: |Fringe_Bitmaps|,  Next: |Customizing_Bitmaps|,  Prev: |Fringe_Cursors|,  Up: |Fringes|
==============================================================================

                                                                *Fringe_Bitmaps*

39.13.4 Fringe Bitmaps
----------------------

The "fringe bitmaps" are the actual bitmaps which represent the logical
fringe indicators for truncated or continued lines, buffer boundaries,
overlay arrows, etc.  Each bitmap is represented by a symbol.  These
symbols are referred to by the variable 'fringe-indicator-alist', which
maps fringe indicators to bitmaps (*note Fringe Indicators::), and the
variable 'fringe-cursor-alist', which maps fringe cursors to bitmaps
(*note Fringe Cursors::).

   Lisp programs can also directly display a bitmap in the left or right
fringe, by using a 'display' property for one of the characters
appearing in the line (*note Other Display Specs::).  Such a display
specification has the form

     (FRINGE BITMAP [FACE])

FRINGE is either the symbol 'left-fringe' or 'right-fringe'.  BITMAP is
a symbol identifying the bitmap to display.  The optional FACE names a
face whose foreground and background colors are to be used to display
the bitmap, using the attributes of the 'fringe' face for colors that
FACE didn't specify.  If FACE is omitted, that means to use the
attributes of the 'default' face for the colors which the 'fringe' face
didn't specify.  For predictable results that don't depend on the
attributes of the 'default' and 'fringe' faces, we recommend you never
omit FACE, but always provide a specific face.  In particular, if you
want the bitmap to be always displayed in the 'fringe' face, use
'fringe' as FACE.

   For instance, to display an arrow in the left fringe, using the
'warning' face, you could say something like:

     (overlay-put
      (make-overlay (point) (point))
      'before-string (propertize
                      "x" 'display
                      `(left-fringe right-arrow warning)))

   Here is a list of the standard fringe bitmaps defined in Emacs, and
how they are currently used in Emacs (via 'fringe-indicator-alist' and
'fringe-cursor-alist'):

'left-arrow', 'right-arrow'
     Used to indicate truncated lines.

'left-curly-arrow', 'right-curly-arrow'
     Used to indicate continued lines.

'right-triangle', 'left-triangle'
     The former is used by overlay arrows.  The latter is unused.

'up-arrow', 'down-arrow'
'bottom-left-angle', 'bottom-right-angle'
'top-left-angle', 'top-right-angle'
'left-bracket', 'right-bracket'
'empty-line'
     Used to indicate buffer boundaries.

'filled-rectangle', 'hollow-rectangle'
'filled-square', 'hollow-square'
'vertical-bar', 'horizontal-bar'
     Used for different types of fringe cursors.

'exclamation-mark', 'question-mark'
     Not used by core Emacs features.

The next subsection describes how to define your own fringe bitmaps.

 -- Function: fringe-bitmaps-at-pos &optional pos window
     This function returns the fringe bitmaps of the display line
     containing position POS in window WINDOW.  The return value has the
     form '(LEFT RIGHT OV)', where LEFT is the symbol for the fringe
     bitmap in the left fringe (or 'nil' if no bitmap), RIGHT is similar
     for the right fringe, and OV is non-'nil' if there is an overlay
     arrow in the left fringe.

     The value is 'nil' if POS is not visible in WINDOW.  If WINDOW is
     'nil', that stands for the selected window.  If POS is 'nil', that
     stands for the value of point in WINDOW.

==============================================================================
File: elisp.info,  Node: |Customizing_Bitmaps|,  Next: |Overlay_Arrow|,  Prev: |Fringe_Bitmaps|,  Up: |Fringes|
==============================================================================

                                                           *Customizing_Bitmaps*

39.13.5 Customizing Fringe Bitmaps
----------------------------------

 -- Function: define-fringe-bitmap bitmap bits &optional height width
          align
     This function defines the symbol BITMAP as a new fringe bitmap, or
     replaces an existing bitmap with that name.

     The argument BITS specifies the image to use.  It should be either
     a string or a vector of integers, where each element (an integer)
     corresponds to one row of the bitmap.  Each bit of an integer
     corresponds to one pixel of the bitmap, where the low bit
     corresponds to the rightmost pixel of the bitmap.  (Note that this
     order of bits is opposite of the order in XBM images; *note XBM
     Images::.)

     The height is normally the length of BITS.  However, you can
     specify a different height with non-'nil' HEIGHT.  The width is
     normally 8, but you can specify a different width with non-'nil'
     WIDTH.  The width must be an integer between 1 and 16.

     The argument ALIGN specifies the positioning of the bitmap relative
     to the range of rows where it is used; the default is to center the
     bitmap.  The allowed values are 'top', 'center', or 'bottom'.

     The ALIGN argument may also be a list '(ALIGN PERIODIC)' where
     ALIGN is interpreted as described above.  If PERIODIC is non-'nil',
     it specifies that the rows in 'bits' should be repeated enough
     times to reach the specified height.

 -- Function: destroy-fringe-bitmap bitmap
     This function destroys the fringe bitmap identified by BITMAP.  If
     BITMAP identifies a standard fringe bitmap, it actually restores
     the standard definition of that bitmap, instead of eliminating it
     entirely.

 -- Function: set-fringe-bitmap-face bitmap &optional face
     This sets the face for the fringe bitmap BITMAP to FACE.  If FACE
     is 'nil', it selects the 'fringe' face.  The bitmap's face controls
     the color to draw it in.

     FACE is merged with the 'fringe' face, so normally FACE should
     specify only the foreground color.

==============================================================================
File: elisp.info,  Node: |Overlay_Arrow|,  Prev: |Customizing_Bitmaps|,  Up: |Fringes|
==============================================================================

                                                                 *Overlay_Arrow*

39.13.6 The Overlay Arrow
-------------------------

The "overlay arrow" is useful for directing the user's attention to a
particular line in a buffer.  For example, in the modes used for
interface to debuggers, the overlay arrow indicates the line of code
about to be executed.  This feature has nothing to do with "overlays"
(*note Overlays::).

 -- Variable: overlay-arrow-string
     This variable holds the string to display to call attention to a
     particular line, or 'nil' if the arrow feature is not in use.  On a
     graphical display the contents of the string are ignored; instead a
     glyph is displayed in the fringe area to the left of the display
     area.

 -- Variable: overlay-arrow-position
     This variable holds a marker that indicates where to display the
     overlay arrow.  It should point at the beginning of a line.  On a
     non-graphical display the arrow text appears at the beginning of
     that line, overlaying any text that would otherwise appear.  Since
     the arrow is usually short, and the line usually begins with
     indentation, normally nothing significant is overwritten.

     The overlay-arrow string is displayed in any given buffer if the
     value of 'overlay-arrow-position' in that buffer points into that
     buffer.  Thus, it is possible to display multiple overlay arrow
     strings by creating buffer-local bindings of
     'overlay-arrow-position'.  However, it is usually cleaner to use
     'overlay-arrow-variable-list' to achieve this result.

   You can do a similar job by creating an overlay with a
'before-string' property.  *Note Overlay Properties::.

   You can define multiple overlay arrows via the variable
'overlay-arrow-variable-list'.

 -- Variable: overlay-arrow-variable-list
     This variable's value is a list of variables, each of which
     specifies the position of an overlay arrow.  The variable
     'overlay-arrow-position' has its normal meaning because it is on
     this list.

   Each variable on this list can have properties 'overlay-arrow-string'
and 'overlay-arrow-bitmap' that specify an overlay arrow string (for
text terminals) or fringe bitmap (for graphical terminals) to display at
the corresponding overlay arrow position.  If either property is not
set, the default 'overlay-arrow-string' or 'overlay-arrow' fringe
indicator is used.

==============================================================================
File: elisp.info,  Node: |Scroll_Bars|,  Next: |Window_Dividers|,  Prev: |Fringes|,  Up: |Display|
==============================================================================

                                                                   *Scroll_Bars*

39.14 Scroll Bars
=====------------

Normally the frame parameter 'vertical-scroll-bars' controls whether the
windows in the frame have vertical scroll bars, and whether they are on
the left or right.  The frame parameter 'scroll-bar-width' specifies how
wide they are ('nil' meaning the default).

   The frame parameter 'horizontal-scroll-bars' controls whether the
windows in the frame have horizontal scroll bars.  The frame parameter
'scroll-bar-height' specifies how high they are ('nil' meaning the
default).  *Note Layout Parameters::.

   Horizontal scroll bars are not available on all platforms.  The
function 'horizontal-scroll-bars-available-p' which takes no argument
returns non-'nil' if they are available on your system.

   The following three functions take as argument a live frame which
defaults to the selected one.

 -- Function: frame-current-scroll-bars &optional frame
     This function reports the scroll bar types for frame FRAME.  The
     value is a cons cell '(VERTICAL-TYPE . HORIZONTAL-TYPE)', where
     VERTICAL-TYPE is either 'left', 'right', or 'nil' (which means no
     vertical scroll bar.)  HORIZONTAL-TYPE is either 'bottom' or 'nil'
     (which means no horizontal scroll bar).

 -- Function: frame-scroll-bar-width &optional frame
     This function returns the width of vertical scroll bars of FRAME in
     pixels.

 -- Function: frame-scroll-bar-height &optional frame
     This function returns the height of horizontal scroll bars of FRAME
     in pixels.

   You can override the frame specific settings for individual windows
by using the following function:

 -- Function: set-window-scroll-bars window &optional width
          vertical-type height horizontal-type persistent
     This function sets the width and/or height and the types of scroll
     bars for window WINDOW.  If WINDOW is 'nil', the selected window is
     used.

     WIDTH specifies the width of the vertical scroll bar in pixels
     ('nil' means use the width specified for the frame).  VERTICAL-TYPE
     specifies whether to have a vertical scroll bar and, if so, where.
     The possible values are 'left', 'right', 't', which means to use
     the frame's default, and 'nil' for no vertical scroll bar.

     HEIGHT specifies the height of the horizontal scroll bar in pixels
     ('nil' means use the height specified for the frame).
     HORIZONTAL-TYPE specifies whether to have a horizontal scroll bar.
     The possible values are 'bottom', 't', which means to use the
     frame's default, and 'nil' for no horizontal scroll bar.  Note that
     for a mini window the value 't' has the same meaning as 'nil',
     namely to not show a horizontal scroll bar.  You have to explicitly
     specify 'bottom' in order to show a horizontal scroll bar in a mini
     window.

     If WINDOW is not large enough to accommodate a scroll bar of the
     desired dimension, this leaves the corresponding scroll bar
     unchanged.

     The values specified here may be later overridden by invoking
     'set-window-buffer' (*note Buffers and Windows::) on WINDOW with
     its KEEP-MARGINS argument 'nil' or omitted.  However, if the
     optional fifth argument PERSISTENT is non-'nil' and the other
     arguments are processed successfully, the values specified here
     unconditionally survive subsequent invocations of
     'set-window-buffer'.

   Using the PERSISTENT argument of 'set-window-scroll-bars' and
'set-window-fringes' (*note Fringe Size/Pos::) you can reliably and
permanently turn off scroll bars and/or fringes in any minibuffer window
by adding the following snippet to your early init file (*note Init
File::).

     (add-hook 'after-make-frame-functions
               (lambda (frame)
                 (set-window-scroll-bars
                  (minibuffer-window frame) 0 nil 0 nil t)
                 (set-window-fringes
                  (minibuffer-window frame) 0 0 nil t)))

   The following four functions take as argument a live window which
defaults to the selected one.

 -- Function: window-scroll-bars &optional window
     This function returns a list of the form '(WIDTH COLUMNS
     VERTICAL-TYPE HEIGHT LINES HORIZONTAL-TYPE PERSISTENT)'.

     The value WIDTH is the value that was specified for the width of
     the vertical scroll bar (which may be 'nil'); COLUMNS is the
     (possibly rounded) number of columns that the vertical scroll bar
     actually occupies.

     The value HEIGHT is the value that was specified for the height of
     the horizontal scroll bar (which may be 'nil'); LINES is the
     (possibly rounded) number of lines that the horizontally scroll bar
     actually occupies.

     The value of PERSISTENT is the value specified for WINDOW with the
     last successful invocation of 'set-window-scroll-bars', 'nil' if
     there never was one.

 -- Function: window-current-scroll-bars &optional window
     This function reports the scroll bar type for window WINDOW.  The
     value is a cons cell '(VERTICAL-TYPE . HORIZONTAL-TYPE)'.  Unlike
     'window-scroll-bars', this reports the scroll bar type actually
     used, once frame defaults and 'scroll-bar-mode' are taken into
     account.

 -- Function: window-scroll-bar-width &optional window
     This function returns the width in pixels of WINDOW's vertical
     scrollbar.

 -- Function: window-scroll-bar-height &optional window
     This function returns the height in pixels of WINDOW's horizontal
     scrollbar.

   If you do not specify a window's scroll bar settings via
'set-window-scroll-bars', the buffer-local variables
'vertical-scroll-bar', 'horizontal-scroll-bar', 'scroll-bar-width' and
'scroll-bar-height' in the buffer being displayed control the window's
scroll bars.  The function 'set-window-buffer' examines these variables.
If you change them in a buffer that is already visible in a window, you
can make the window take note of the new values by calling
'set-window-buffer' specifying the same buffer that is already
displayed.

   You can control the appearance of scroll bars for a particular buffer
by setting the following variables which automatically become
buffer-local when set.

 -- Variable: vertical-scroll-bar
     This variable specifies the location of the vertical scroll bar.
     The possible values are 'left', 'right', 't', which means to use
     the frame's default, and 'nil' for no scroll bar.

 -- Variable: horizontal-scroll-bar
     This variable specifies the location of the horizontal scroll bar.
     The possible values are 'bottom', 't', which means to use the
     frame's default, and 'nil' for no scroll bar.

 -- Variable: scroll-bar-width
     This variable specifies the width of the buffer's vertical scroll
     bars, measured in pixels.  A value of 'nil' means to use the value
     specified by the frame.

 -- Variable: scroll-bar-height
     This variable specifies the height of the buffer's horizontal
     scroll bar, measured in pixels.  A value of 'nil' means to use the
     value specified by the frame.

   Finally you can toggle the display of scroll bars on all frames by
customizing the variables 'scroll-bar-mode' and
'horizontal-scroll-bar-mode'.

 -- User Option: scroll-bar-mode
     This variable controls whether and where to put vertical scroll
     bars in all frames.  The possible values are 'nil' for no scroll
     bars, 'left' to put scroll bars on the left and 'right' to put
     scroll bars on the right.

 -- User Option: horizontal-scroll-bar-mode
     This variable controls whether to display horizontal scroll bars on
     all frames.

==============================================================================
File: elisp.info,  Node: |Window_Dividers|,  Next: |Display_Property|,  Prev: |Scroll_Bars|,  Up: |Display|
==============================================================================

                                                               *Window_Dividers*

39.15 Window Dividers
=====----------------

Window dividers are bars drawn between a frame's windows.  A right
divider is drawn between a window and any adjacent windows on the right.
Its width (thickness) is specified by the frame parameter
'right-divider-width'.  A bottom divider is drawn between a window and
adjacent windows on the bottom or the echo area.  Its width is specified
by the frame parameter 'bottom-divider-width'.  In either case,
specifying a width of zero means to not draw such dividers.  *Note
Layout Parameters::.

   Technically, a right divider belongs to the window on its left, which
means that its width contributes to the total width of that window.  A
bottom divider belongs to the window above it, which means that its
width contributes to the total height of that window.  *Note Window
Sizes::.  When a window has both, a right and a bottom divider, the
bottom divider prevails.  This means that a bottom divider is drawn over
the full total width of its window while the right divider ends above
the bottom divider.

   Dividers can be dragged with the mouse and are therefore useful for
adjusting the sizes of adjacent windows with the mouse.  They also serve
to visually set apart adjacent windows when no scroll bars or mode lines
are present.  The following three faces allow the customization of the
appearance of dividers:

'window-divider'
     When a divider is less than three pixels wide, it is drawn solidly
     with the foreground of this face.  For larger dividers this face is
     used for the inner part only, excluding the first and last pixel.

'window-divider-first-pixel'
     This is the face used for drawing the first pixel of a divider that
     is at least three pixels wide.  To obtain a solid appearance, set
     this to the same value used for the 'window-divider' face.

'window-divider-last-pixel'
     This is the face used for drawing the last pixel of a divider that
     is at least three pixels wide.  To obtain a solid appearance, set
     this to the same value used for the 'window-divider' face.

   You can get the sizes of the dividers of a specific window with the
following two functions.

 -- Function: window-right-divider-width &optional window
     Return the width (thickness) in pixels of WINDOW's right divider.
     WINDOW must be a live window and defaults to the selected one.  The
     return value is always zero for a rightmost window.

 -- Function: window-bottom-divider-width &optional window
     Return the width (thickness) in pixels of WINDOW's bottom divider.
     WINDOW must be a live window and defaults to the selected one.  The
     return value is zero for the minibuffer window or a bottommost
     window on a minibuffer-less frame.

==============================================================================
File: elisp.info,  Node: |Display_Property|,  Next: |Images|,  Prev: |Window_Dividers|,  Up: |Display|
==============================================================================

                                                              *Display_Property*

39.16 The 'display' Property
=====-----------------------

The 'display' text property (or overlay property) is used to insert
images into text, and to control other aspects of how text displays.
The value of the 'display' property should be a display specification,
or a list or vector containing several display specifications.  Display
specifications in the same 'display' property value generally apply in
parallel to the text they cover.

   If several sources (overlays and/or a text property) specify values
for the 'display' property, only one of the values takes effect,
following the rules of 'get-char-property'.  *Note Examining
Properties::.

   Some of the display specifications allow inclusion of Lisp forms,
which are evaluated at display time.  This could be unsafe in certain
situations, e.g., when the display specification was generated by some
external program/agent.  Wrapping a display specification in a list that
begins with the special symbol 'disable-eval', as in
'('disable-eval SPEC)', will disable evaluation of any Lisp in SPEC,
while still supporting all the other display property features.

   The rest of this section describes several kinds of display
specifications and what they mean.

MENU

* |Replacing_Specs|::      Display specs that replace the text.
* |Specified_Space|::      Displaying one space with a specified width.
* |Pixel_Specification|::  Specifying space width or height in pixels.
* |Other_Display_Specs|::     Displaying an image; adjusting the height,
                              spacing, and other properties of text.
* |Display_Margins|::     Displaying text or images to the side of the main text.

==============================================================================
File: elisp.info,  Node: |Replacing_Specs|,  Next: |Specified_Space|,  Up: |Display_Property|
==============================================================================

                                                               *Replacing_Specs*

39.16.1 Display Specs That Replace The Text
-------------------------------------------

Some kinds of display specifications specify something to display
instead of the text that has the property.  These are called "replacing"
display specifications.  Emacs does not allow the user to interactively
move point into the middle of buffer text that is replaced in this way.

   If a list of display specifications includes more than one replacing
display specification, the first overrides the rest.  Replacing display
specifications make most other display specifications irrelevant, since
those don't apply to the replacement.

   For replacing display specifications, "the text that has the
property" means all the consecutive characters that have the same Lisp
object as their 'display' property; these characters are replaced as a
single unit.  If two characters have different Lisp objects as their
'display' properties (i.e., objects which are not 'eq'), they are
handled separately.

   Here is an example which illustrates this point.  A string serves as
a replacing display specification, which replaces the text that has the
property with the specified string (*note Other Display Specs::).
Consider the following function:

     (defun foo ()
       (dotimes (i 5)
         (let ((string (concat "A"))
               (start (+ i i (point-min))))
           (put-text-property start (1+ start) 'display string)
           (put-text-property start (+ 2 start) 'display string))))

This function gives each of the first ten characters in the buffer a
'display' property which is a string '"A"', but they don't all get the
same string object.  The first two characters get the same string
object, so they are replaced with one 'A'; the fact that the display
property was assigned in two separate calls to 'put-text-property' is
irrelevant.  Similarly, the next two characters get a second string
('concat' creates a new string object), so they are replaced with one
'A'; and so on.  Thus, the ten characters appear as five A's.

==============================================================================
File: elisp.info,  Node: |Specified_Space|,  Next: |Pixel_Specification|,  Prev: |Replacing_Specs|,  Up: |Display_Property|
==============================================================================

                                                               *Specified_Space*

39.16.2 Specified Spaces
------------------------

To display a space of specified width and/or height, use a display
specification of the form '(space . PROPS)', where PROPS is a property
list (a list of alternating properties and values).  You can put this
property on one or more consecutive characters; a space of the specified
height and width is displayed in place of _all_ of those characters.
These are the properties you can use in PROPS to specify the weight of
the space:

':width WIDTH'
     If WIDTH is a number, it specifies that the space width should be
     WIDTH times the normal character width.  WIDTH can also be a "pixel
     width" specification (*note Pixel Specification::).

':relative-width FACTOR'
     Specifies that the width of the stretch should be computed from the
     first character in the group of consecutive characters that have
     the same 'display' property.  The space width is the pixel width of
     that character, multiplied by FACTOR.  (On text-mode terminals, the
     "pixel width" of a character is usually 1, but it could be more for
     TABs and double-width CJK characters.)

':align-to HPOS'
     Specifies that the space should be wide enough to reach HPOS.  If
     HPOS is a number, it is measured in units of the normal character
     width.  HPOS can also be a "pixel width" specification (*note Pixel
     Specification::).

   You should use one and only one of the above properties.  You can
also specify the height of the space, with these properties:

':height HEIGHT'
     Specifies the height of the space.  If HEIGHT is a number, it
     specifies that the space height should be HEIGHT times the normal
     character height.  The HEIGHT may also be a "pixel height"
     specification (*note Pixel Specification::).

':relative-height FACTOR'
     Specifies the height of the space, multiplying the ordinary height
     of the text having this display specification by FACTOR.

':ascent ASCENT'
     If the value of ASCENT is a non-negative number no greater than
     100, it specifies that ASCENT percent of the height of the space
     should be considered as the ascent of the space--that is, the part
     above the baseline.  The ascent may also be specified in pixel
     units with a "pixel ascent" specification (*note Pixel
     Specification::).

   Don't use both ':height' and ':relative-height' together.

   The ':width' and ':align-to' properties are supported on non-graphic
terminals, but the other space properties in this section are not.

   Note that space properties are treated as paragraph separators for
the purposes of reordering bidirectional text for display.  *Note
Bidirectional Display::, for the details.

==============================================================================
File: elisp.info,  Node: |Pixel_Specification|,  Next: |Other_Display_Specs|,  Prev: |Specified_Space|,  Up: |Display_Property|
==============================================================================

                                                           *Pixel_Specification*

39.16.3 Pixel Specification for Spaces
--------------------------------------

The value of the ':width', ':align-to', ':height', and ':ascent'
properties can be a special kind of expression that is evaluated during
redisplay.  The result of the evaluation is used as an absolute number
of pixels.

   The following expressions are supported:

       EXPR ::= NUM | (NUM) | UNIT | ELEM | POS | IMAGE | XWIDGET | FORM
       NUM  ::= INTEGER | FLOAT | SYMBOL
       UNIT ::= in | mm | cm | width | height
       ELEM ::= left-fringe | right-fringe | left-margin | right-margin
             |  scroll-bar | text
       POS  ::= left | center | right
       FORM ::= (NUM . EXPR) | (OP EXPR ...)
       OP   ::= + | -

   The form NUM specifies a fraction of the default frame font height or
width.  The form '(NUM)' specifies an absolute number of pixels.  If NUM
is a symbol, SYMBOL, its buffer-local variable binding is used; that
binding can be either a number or a cons cell of the forms shown above
(including yet another cons cell whose 'car' is a symbol that has a
buffer-local binding).

   The 'in', 'mm', and 'cm' units specify the number of pixels per inch,
millimeter, and centimeter, respectively.  The 'width' and 'height'
units correspond to the default width and height of the current face.
An image specification of the form '(image . PROPS)' (*note Image
Descriptors::) corresponds to the width or height of the specified
image.  Similarly, an xwidget specification of the form
'(xwidget . PROPS)' stands for the width or height of the specified
xwidget.  *Note Xwidgets::.

   The elements 'left-fringe', 'right-fringe', 'left-margin',
'right-margin', 'scroll-bar', and 'text' specify the width of the
corresponding area of the window.  When the window displays line numbers
(*note Size of Displayed Text::), the width of the 'text' area is
decreased by the screen space taken by the line-number display.

   The 'left', 'center', and 'right' positions can be used with
':align-to' to specify a position relative to the left edge, center, or
right edge of the text area.  When the window displays line numbers, the
'left' and the 'center' positions are offset to account for the screen
space taken by the line-number display.

   Any of the above window elements (except 'text') can also be used
with ':align-to' to specify that the position is relative to the left
edge of the given area.  Once the base offset for a relative position
has been set (by the first occurrence of one of these symbols), further
occurrences of these symbols are interpreted as the width of the
specified area.  For example, to align to the center of the left-margin,
use

     :align-to (+ left-margin (0.5 . left-margin))

   If no specific base offset is set for alignment, it is always
relative to the left edge of the text area.  For example, ':align-to 0'
in a header-line aligns with the first text column in the text area.
When the window displays line numbers, the text is considered to start
where the space used for line-number display ends.

   A value of the form '(NUM . EXPR)' stands for the product of the
values of NUM and EXPR.  For example, '(2 . in)' specifies a width of 2
inches, while '(0.5 . IMAGE)' specifies half the width (or height) of
the specified IMAGE (which should be given by its image spec).

   The form '(+ EXPR ...)' adds up the value of the expressions.  The
form '(- EXPR ...)' negates or subtracts the value of the expressions.

==============================================================================
File: elisp.info,  Node: |Other_Display_Specs|,  Next: |Display_Margins|,  Prev: |Pixel_Specification|,  Up: |Display_Property|
==============================================================================

                                                           *Other_Display_Specs*

39.16.4 Other Display Specifications
------------------------------------

Here are the other sorts of display specifications that you can use in
the 'display' text property.

'STRING'
     Display STRING instead of the text that has this property.

     Recursive display specifications are not supported--STRING's
     'display' properties, if any, are not used.

'(image . IMAGE-PROPS)'
     This kind of display specification is an image descriptor (*note
     Image Descriptors::).  When used as a display specification, it
     means to display the image instead of the text that has the display
     specification.

'(slice X Y WIDTH HEIGHT)'
     This specification together with 'image' specifies a "slice" (a
     partial area) of the image to display.  The elements Y and X
     specify the top left corner of the slice, within the image; WIDTH
     and HEIGHT specify the width and height of the slice.  Integers are
     numbers of pixels.  A floating-point number in the range 0.0-1.0
     stands for that fraction of the width or height of the entire
     image.

'((margin nil) STRING)'
     A display specification of this form means to display STRING
     instead of the text that has the display specification, at the same
     position as that text.  It is equivalent to using just STRING, but
     it is done as a special case of marginal display (*note Display
     Margins::).

'(left-fringe BITMAP [FACE])'
'(right-fringe BITMAP [FACE])'
     This display specification on any character of a line of text
     causes the specified BITMAP be displayed in the left or right
     fringes for that line, instead of the characters that have the
     display specification.  The optional FACE specifies the face whose
     colors are to be used for the bitmap display.  *Note Fringe
     Bitmaps::, for the details.

'(space-width FACTOR)'
     This display specification affects all the space characters within
     the text that has the specification.  It displays all of these
     spaces FACTOR times as wide as normal.  The element FACTOR should
     be an integer or float.  Characters other than spaces are not
     affected at all; in particular, this has no effect on tab
     characters.

'(height HEIGHT)'
     This display specification makes the text taller or shorter.  Here
     are the possibilities for HEIGHT:

     '(+ N)'
          This means to use a font that is N steps larger.  A "step" is
          defined by the set of available fonts--specifically, those that
          match what was otherwise specified for this text, in all
          attributes except height.  Each size for which a suitable font
          is available counts as another step.  N should be an integer.

     '(- N)'
          This means to use a font that is N steps smaller.

     a number, FACTOR
          A number, FACTOR, means to use a font that is FACTOR times as
          tall as the default font.

     a symbol, FUNCTION
          A symbol is a function to compute the height.  It is called
          with the current height as argument, and should return the new
          height to use.

     anything else, FORM
          If the HEIGHT value doesn't fit the previous possibilities, it
          is a form.  Emacs evaluates it to get the new height, with the
          symbol 'height' bound to the current specified font height.

'(raise FACTOR)'
     This kind of display specification raises or lowers the text it
     applies to, relative to the baseline of the line.  It is mainly
     meant to support display of subscripts and superscripts.

     The FACTOR must be a number, which is interpreted as a multiple of
     the height of the affected text.  If it is positive, that means to
     display the characters raised.  If it is negative, that means to
     display them lower down.

     Note that if the text also has a 'height' display specification,
     which was specified before (i.e. to the left of) 'raise', the
     latter will affect the amount of raising or lowering in pixels,
     because that is based on the height of the text being raised.
     Therefore, if you want to display a sub- or superscript that is
     smaller than the normal text height, consider specifying 'raise'
     before 'height'.

   You can make any display specification conditional.  To do that,
package it in another list of the form '(when CONDITION . SPEC)'.  Then
the specification SPEC applies only when CONDITION evaluates to a
non-'nil' value.  During the evaluation, 'object' is bound to the string
or buffer having the conditional 'display' property.  'position' and
'buffer-position' are bound to the position within 'object' and the
buffer position where the 'display' property was found, respectively.
Both positions can be different when 'object' is a string.

   Note that CONDITION will only be evaluated when redisplay examines
the text where this display spec is located, so this feature is best
suited for conditions that are relatively stable, i.e. yield, for each
particular buffer position, the same results on every evaluation.  If
the results change for the same text location, e.g., if the result
depends on the position of point, then the conditional specification
might not do what you want, because redisplay examines only those parts
of buffer text where it has reasons to assume that something changed
since the last display cycle.

==============================================================================
File: elisp.info,  Node: |Display_Margins|,  Prev: |Other_Display_Specs|,  Up: |Display_Property|
==============================================================================

                                                               *Display_Margins*

39.16.5 Displaying in the Margins
---------------------------------

A buffer can have blank areas called "display margins" on the left and
on the right.  Ordinary text never appears in these areas, but you can
put things into the display margins using the 'display' property.  There
is currently no way to make text or images in the margin
mouse-sensitive.

   The way to display something in the margins is to specify it in a
margin display specification in the 'display' property of some text.
This is a replacing display specification, meaning that the text you put
it on does not get displayed; the margin display appears, but that text
does not.

   A margin display specification looks like '((margin right-margin)
SPEC)' or '((margin left-margin) SPEC)'.  Here, SPEC is another display
specification that says what to display in the margin.  Typically it is
a string of text to display, or an image descriptor.

   To display something in the margin _in association with_ certain
buffer text, without altering or preventing the display of that text,
put a 'before-string' property on the text and put the margin display
specification on the contents of the before-string.

   Note that if the string to be displayed in the margin doesn't specify
a face, its face is determined using the same rules and priorities as it
is for strings displayed in the text area (*note Displaying Faces::).
If this results in undesirable "leaking" of faces into the margin, make
sure the string has an explicit face specified for it.

   Before the display margins can display anything, you must give them a
nonzero width.  The usual way to do that is to set these variables:

 -- Variable: left-margin-width
     This variable specifies the width of the left margin, in character
     cell (a.k.a. "column") units.  It is buffer-local in all buffers.
     A value of 'nil' means no left marginal area.

 -- Variable: right-margin-width
     This variable specifies the width of the right margin, in character
     cell units.  It is buffer-local in all buffers.  A value of 'nil'
     means no right marginal area.

   Setting these variables does not immediately affect the window.
These variables are checked when a new buffer is displayed in the
window.  Thus, you can make changes take effect by calling
'set-window-buffer'.  Do not use these variables to try to determine the
current width of the left or right margin.  Instead, use the function
'window-margins'.

   You can also set the margin widths immediately.

 -- Function: set-window-margins window left &optional right
     This function specifies the margin widths for window WINDOW, in
     character cell units.  The argument LEFT controls the left margin,
     and RIGHT controls the right margin (default '0').

     If WINDOW is not large enough to accommodate margins of the desired
     width, this leaves the margins of WINDOW unchanged.

     The values specified here may be later overridden by invoking
     'set-window-buffer' (*note Buffers and Windows::) on WINDOW with
     its KEEP-MARGINS argument 'nil' or omitted.

 -- Function: window-margins &optional window
     This function returns the width of the left and right margins of
     WINDOW as a cons cell of the form '(LEFT . RIGHT)'.  If one of the
     two marginal areas does not exist, its width is returned as 'nil';
     if neither of the two margins exist, the function returns '(nil)'.
     If WINDOW is 'nil', the selected window is used.

==============================================================================
File: elisp.info,  Node: |Images|,  Next: |Xwidgets|,  Prev: |Display_Property|,  Up: |Display|
==============================================================================

                                                                        *Images*

39.17 Images
=====-------

To display an image in an Emacs buffer, you must first create an image
descriptor, then use it as a display specifier in the 'display' property
of text that is displayed (*note Display Property::).

   Emacs is usually able to display images when it is run on a graphical
terminal.  Images cannot be displayed in a text terminal, on certain
graphical terminals that lack the support for this, or if Emacs is
compiled without image support.  You can use the function
'display-images-p' to determine if images can in principle be displayed
(*note Display Feature Testing::).

MENU

* |Image_Formats|::       Supported image formats.
* |Image_Descriptors|::   How to specify an image for use in ':display'.
* |XBM_Images|::          Special features for XBM format.
* |XPM_Images|::          Special features for XPM format.
* |ImageMagick_Images|::  Special features available through ImageMagick.
* |SVG_Images|::          Creating and manipulating SVG images.
* |Other_Image_Types|::   Various other formats are supported.
* |Defining_Images|::     Convenient ways to define an image for later use.
* |Showing_Images|::      Convenient ways to display an image once it is defined.
* |Multi_Frame_Images|::  Some images contain more than one frame.
* |Image_Cache|::         Internal mechanisms of image display.

==============================================================================
File: elisp.info,  Node: |Image_Formats|,  Next: |Image_Descriptors|,  Up: |Images|
==============================================================================

                                                                 *Image_Formats*

39.17.1 Image Formats
---------------------

Emacs can display a number of different image formats.  Some of these
image formats are supported only if particular support libraries are
installed.  On some platforms, Emacs can load support libraries on
demand; if so, the variable 'dynamic-library-alist' can be used to
modify the set of known names for these dynamic libraries.  *Note
Dynamic Libraries::.

   Supported image formats (and the required support libraries) include
PBM and XBM (which do not depend on support libraries and are always
available), XPM ('libXpm'), GIF ('libgif' or 'libungif'), JPEG
('libjpeg'), TIFF ('libtiff'), PNG ('libpng'), and SVG ('librsvg').

   Each of these image formats is associated with an "image type
symbol".  The symbols for the above formats are, respectively, 'pbm',
'xbm', 'xpm', 'gif', 'jpeg', 'tiff', 'png', and 'svg'.

   Furthermore, if you build Emacs with ImageMagick ('libMagickWand')
support, Emacs can display any image format that ImageMagick can.  *Note
ImageMagick Images::.  All images displayed via ImageMagick have type
symbol 'imagemagick'.

 -- Variable: image-types
     This variable contains a list of type symbols for image formats
     which are potentially supported in the current configuration.

     "Potentially" means that Emacs knows about the image types, not
     necessarily that they can be used (for example, they could depend
     on unavailable dynamic libraries).  To know which image types are
     really available, use 'image-type-available-p'.

 -- Function: image-type-available-p type
     This function returns non-'nil' if images of type TYPE can be
     loaded and displayed.  TYPE must be an image type symbol.

     For image types whose support libraries are statically linked, this
     function always returns 't'.  For image types whose support
     libraries are dynamically loaded, it returns 't' if the library
     could be loaded and 'nil' otherwise.

==============================================================================
File: elisp.info,  Node: |Image_Descriptors|,  Next: |XBM_Images|,  Prev: |Image_Formats|,  Up: |Images|
==============================================================================

                                                             *Image_Descriptors*

39.17.2 Image Descriptors
-------------------------

An "image descriptor" is a list which specifies the underlying data for
an image, and how to display it.  It is typically used as the value of a
'display' overlay or text property (*note Other Display Specs::); but
*Note Showing Images::, for convenient helper functions to insert images
into buffers.

   Each image descriptor has the form '(image . PROPS)', where PROPS is
a property list of alternating keyword symbols and values, including at
least the pair ':type TYPE' that specifies the image type.

   The following is a list of properties that are meaningful for all
image types (there are also properties which are meaningful only for
certain image types, as documented in the following subsections):

':type TYPE'
     The image type.  *Note Image Formats::.  Every image descriptor
     must include this property.

':file FILE'
     This says to load the image from file FILE.  If FILE is not an
     absolute file name, it is expanded relative to the 'images'
     subdirectory of 'data-directory', and failing that, relative to the
     directories listed by 'x-bitmap-file-path' (*note Face
     Attributes::).

':data DATA'
     This specifies the raw image data.  Each image descriptor must have
     either ':data' or ':file', but not both.

     For most image types, the value of a ':data' property should be a
     string containing the image data.  Some image types do not support
     ':data'; for some others, ':data' alone is not enough, so you need
     to use other image properties along with ':data'.  See the
     following subsections for details.

':margin MARGIN'
     This specifies how many pixels to add as an extra margin around the
     image.  The value, MARGIN, must be a non-negative number, or a pair
     '(X . Y)' of such numbers.  If it is a pair, X specifies how many
     pixels to add horizontally, and Y specifies how many pixels to add
     vertically.  If ':margin' is not specified, the default is zero.

':ascent ASCENT'
     This specifies the amount of the image's height to use for its
     ascent--that is, the part above the baseline.  The value, ASCENT,
     must be a number in the range 0 to 100, or the symbol 'center'.

     If ASCENT is a number, that percentage of the image's height is
     used for its ascent.

     If ASCENT is 'center', the image is vertically centered around a
     centerline which would be the vertical centerline of text drawn at
     the position of the image, in the manner specified by the text
     properties and overlays that apply to the image.

     If this property is omitted, it defaults to 50.

':relief RELIEF'
     This adds a shadow rectangle around the image.  The value, RELIEF,
     specifies the width of the shadow lines, in pixels.  If RELIEF is
     negative, shadows are drawn so that the image appears as a pressed
     button; otherwise, it appears as an unpressed button.

':width WIDTH, :height HEIGHT'
     The ':width' and ':height' keywords are used for scaling the image.
     If only one of them is specified, the other one will be calculated
     so as to preserve the aspect ratio.  If both are specified, aspect
     ratio may not be preserved.

':max-width MAX-WIDTH, :max-height MAX-HEIGHT'
     The ':max-width' and ':max-height' keywords are used for scaling if
     the size of the image exceeds these values.  If ':width' is set, it
     will have precedence over 'max-width', and if ':height' is set, it
     will have precedence over 'max-height', but you can otherwise mix
     these keywords as you wish.

     If both ':max-width' and ':height' are specified, but ':width' is
     not, preserving the aspect ratio might require that width exceeds
     ':max-width'.  If this happens, scaling will use a smaller value
     for the height so as to preserve the aspect ratio while not
     exceeding ':max-width'.  Similarly when both ':max-height' and
     ':width' are specified, but ':height' is not.  For example, if you
     have a 200x100 image and specify that ':width' should be 400 and
     ':max-height' should be 150, you'll end up with an image that is
     300x150: Preserving the aspect ratio and not exceeding the "max"
     setting.  This combination of parameters is a useful way of saying
     "display this image as large as possible, but no larger than the
     available display area".

':scale SCALE'
     This should be a number, where values higher than 1 means to
     increase the size, and lower means to decrease the size, by
     multiplying both the width and height.  For instance, a value of
     0.25 will make the image a quarter size of what it originally was.
     If the scaling makes the image larger than specified by
     ':max-width' or ':max-height', the resulting size will not exceed
     those two values.  If both ':scale' and ':height'/':width' are
     specified, the height/width will be adjusted by the specified
     scaling factor.

':rotation ANGLE'
     Specifies a rotation angle in degrees.  Only multiples of 90
     degrees are supported, unless the image type is 'imagemagick'.
     Positive values rotate clockwise, negative values
     counter-clockwise.  Rotation is performed after scaling and
     cropping.

':index FRAME'
     *Note Multi-Frame Images::.

':conversion ALGORITHM'
     This specifies a conversion algorithm that should be applied to the
     image before it is displayed; the value, ALGORITHM, specifies which
     algorithm.

     'laplace'
     'emboss'
          Specifies the Laplace edge detection algorithm, which blurs
          out small differences in color while highlighting larger
          differences.  People sometimes consider this useful for
          displaying the image for a disabled button.

     '(edge-detection :matrix MATRIX :color-adjust ADJUST)'
          Specifies a general edge-detection algorithm.  MATRIX must be
          either a nine-element list or a nine-element vector of
          numbers.  A pixel at position x/y in the transformed image is
          computed from original pixels around that position.  MATRIX
          specifies, for each pixel in the neighborhood of x/y, a factor
          with which that pixel will influence the transformed pixel;
          element 0 specifies the factor for the pixel at x-1/y-1,
          element 1 the factor for the pixel at x/y-1 etc., as shown
          below:
                 (x-1/y-1  x/y-1  x+1/y-1
                  x-1/y    x/y    x+1/y
                  x-1/y+1  x/y+1  x+1/y+1)

          The resulting pixel is computed from the color intensity of
          the color resulting from summing up the RGB values of
          surrounding pixels, multiplied by the specified factors, and
          dividing that sum by the sum of the factors' absolute values.

          Laplace edge-detection currently uses a matrix of
                 (1  0  0
                  0  0  0
                  0  0 -1)

          Emboss edge-detection uses a matrix of
                 ( 2 -1  0
                  -1  0  1
                   0  1 -2)

     'disabled'
          Specifies transforming the image so that it looks disabled.

':mask MASK'
     If MASK is 'heuristic' or '(heuristic BG)', build a clipping mask
     for the image, so that the background of a frame is visible behind
     the image.  If BG is not specified, or if BG is 't', determine the
     background color of the image by looking at the four corners of the
     image, assuming the most frequently occurring color from the
     corners is the background color of the image.  Otherwise, BG must
     be a list '(RED GREEN BLUE)' specifying the color to assume for the
     background of the image.

     If MASK is 'nil', remove a mask from the image, if it has one.
     Images in some formats include a mask which can be removed by
     specifying ':mask nil'.

':pointer SHAPE'
     This specifies the pointer shape when the mouse pointer is over
     this image.  *Note Pointer Shape::, for available pointer shapes.

':map MAP'
     This associates an image map of "hot spots" with this image.

     An image map is an alist where each element has the format '(AREA
     ID PLIST)'.  An AREA is specified as either a rectangle, a circle,
     or a polygon.

     A rectangle is a cons '(rect . ((X0 . Y0) . (X1 . Y1)))' which
     specifies the pixel coordinates of the upper left and bottom right
     corners of the rectangle area.

     A circle is a cons '(circle . ((X0 . Y0) . R))' which specifies the
     center and the radius of the circle; R may be a float or integer.

     A polygon is a cons '(poly . [X0 Y0 X1 Y1 ...])' where each pair in
     the vector describes one corner in the polygon.

     When the mouse pointer lies on a hot-spot area of an image, the
     PLIST of that hot-spot is consulted; if it contains a 'help-echo'
     property, that defines a tool-tip for the hot-spot, and if it
     contains a 'pointer' property, that defines the shape of the mouse
     cursor when it is on the hot-spot.  *Note Pointer Shape::, for
     available pointer shapes.

     When you click the mouse when the mouse pointer is over a hot-spot,
     an event is composed by combining the ID of the hot-spot with the
     mouse event; for instance, '[area4 mouse-1]' if the hot-spot's ID
     is 'area4'.

 -- Function: image-mask-p spec &optional frame
     This function returns 't' if image SPEC has a mask bitmap.  FRAME
     is the frame on which the image will be displayed.  FRAME 'nil' or
     omitted means to use the selected frame (*note Input Focus::).

 -- Function: image-transforms-p &optional frame
     This function returns non-'nil' if FRAME supports image scaling and
     rotation.  FRAME 'nil' or omitted means to use the selected frame
     (*note Input Focus::).  The returned list includes symbols that
     indicate which image transform operations are supported:

     'scale'
          Image scaling is supported by FRAME via the ':scale',
          ':width', ':height', ':max-width', and ':max-height'
          properties.
     'rotate90'
          Image rotation is supported by FRAME if the rotation angle is
          an integral multiple of 90 degrees.

     If image transforms are not supported, ':rotation', ':crop',
     ':width', ':height', ':scale', ':max-width' and ':max-height' will
     only be usable through ImageMagick, if available (*note ImageMagick
     Images::).

==============================================================================
File: elisp.info,  Node: |XBM_Images|,  Next: |XPM_Images|,  Prev: |Image_Descriptors|,  Up: |Images|
==============================================================================

                                                                    *XBM_Images*

39.17.3 XBM Images
------------------

To use XBM format, specify 'xbm' as the image type.  This image format
doesn't require an external library, so images of this type are always
supported.

   Additional image properties supported for the 'xbm' image type are:

':foreground FOREGROUND'
     The value, FOREGROUND, should be a string specifying the image
     foreground color, or 'nil' for the default color.  This color is
     used for each pixel in the XBM that is 1.  The default is the
     frame's foreground color.

':background BACKGROUND'
     The value, BACKGROUND, should be a string specifying the image
     background color, or 'nil' for the default color.  This color is
     used for each pixel in the XBM that is 0.  The default is the
     frame's background color.

   If you specify an XBM image using data within Emacs instead of an
external file, use the following three properties:

':data DATA'
     The value, DATA, specifies the contents of the image.  There are
     three formats you can use for DATA:

        * A vector of strings or bool-vectors, each specifying one line
          of the image.  Do specify ':height' and ':width'.

        * A string containing the same byte sequence as an XBM file
          would contain.  You must not specify ':height' and ':width' in
          this case, because omitting them is what indicates the data
          has the format of an XBM file.  The file contents specify the
          height and width of the image.

        * A string or a bool-vector containing the bits of the image
          (plus perhaps some extra bits at the end that will not be
          used).  It should contain at least 'STRIDE * HEIGHT' bits,
          where STRIDE is the smallest multiple of 8 greater than or
          equal to the width of the image.  In this case, you should
          specify ':height', ':width' and ':stride', both to indicate
          that the string contains just the bits rather than a whole XBM
          file, and to specify the size of the image.

':width WIDTH'
     The value, WIDTH, specifies the width of the image, in pixels.

':height HEIGHT'
     The value, HEIGHT, specifies the height of the image, in pixels.

':stride STRIDE'
     The number of bool vector entries stored for each row; the smallest
     multiple of 8 greater than or equal to WIDTH.

==============================================================================
File: elisp.info,  Node: |XPM_Images|,  Next: |ImageMagick_Images|,  Prev: |XBM_Images|,  Up: |Images|
==============================================================================

                                                                    *XPM_Images*

39.17.4 XPM Images
------------------

To use XPM format, specify 'xpm' as the image type.  The additional
image property ':color-symbols' is also meaningful with the 'xpm' image
type:

':color-symbols SYMBOLS'
     The value, SYMBOLS, should be an alist whose elements have the form
     '(NAME . COLOR)'.  In each element, NAME is the name of a color as
     it appears in the image file, and COLOR specifies the actual color
     to use for displaying that name.

==============================================================================
File: elisp.info,  Node: |ImageMagick_Images|,  Next: |SVG_Images|,  Prev: |XPM_Images|,  Up: |Images|
==============================================================================

                                                            *ImageMagick_Images*

39.17.5 ImageMagick Images
--------------------------

If your Emacs build has ImageMagick support, you can use the ImageMagick
library to load many image formats (*note (emacs)File Conveniences::).
The image type symbol for images loaded via ImageMagick is
'imagemagick', regardless of the actual underlying image format.

   To check for ImageMagick support, use the following:

     (image-type-available-p 'imagemagick)

 -- Function: imagemagick-types
     This function returns a list of image file extensions supported by
     the current ImageMagick installation.  Each list element is a
     symbol representing an internal ImageMagick name for an image type,
     such as 'BMP' for '.bmp' images.

 -- User Option: imagemagick-enabled-types
     The value of this variable is a list of ImageMagick image types
     which Emacs may attempt to render using ImageMagick.  Each list
     element should be one of the symbols in the list returned by
     'imagemagick-types', or an equivalent string.  Alternatively, a
     value of 't' enables ImageMagick for all possible image types.
     Regardless of the value of this variable,
     'imagemagick-types-inhibit' (see below) takes precedence.

 -- User Option: imagemagick-types-inhibit
     The value of this variable lists the ImageMagick image types which
     should never be rendered using ImageMagick, regardless of the value
     of 'imagemagick-enabled-types'.  A value of 't' disables
     ImageMagick entirely.

 -- Variable: image-format-suffixes
     This variable is an alist mapping image types to file name
     extensions.  Emacs uses this in conjunction with the ':format'
     image property (see below) to give a hint to the ImageMagick
     library as to the type of an image.  Each element has the form
     '(TYPE EXTENSION)', where TYPE is a symbol specifying an image
     content-type, and EXTENSION is a string that specifies the
     associated file name extension.

   Images loaded with ImageMagick support the following additional image
descriptor properties:

':background BACKGROUND'
     BACKGROUND, if non-'nil', should be a string specifying a color,
     which is used as the image's background color if the image supports
     transparency.  If the value is 'nil', it defaults to the frame's
     background color.

':format TYPE'
     The value, TYPE, should be a symbol specifying the type of the
     image data, as found in 'image-format-suffixes'.  This is used when
     the image does not have an associated file name, to provide a hint
     to ImageMagick to help it detect the image type.

':crop GEOMETRY'
     The value of GEOMETRY should be a list of the form '(WIDTH HEIGHT X
     Y)'.  WIDTH and HEIGHT specify the width and height of the cropped
     image.  If X is a positive number it specifies the offset of the
     cropped area from the left of the original image, and if negative
     the offset from the right.  If Y is a positive number it specifies
     the offset from the top of the original image, and if negative from
     the bottom.  If X or Y are 'nil' or unspecified the crop area will
     be centered on the original image.

     If the crop area is outside or overlaps the edge of the image it
     will be reduced to exclude any areas outside of the image.  This
     means it is not possible to use ':crop' to increase the size of the
     image by entering large WIDTH or HEIGHT values.

     Cropping is performed after scaling but before rotation.

==============================================================================
File: elisp.info,  Node: |SVG_Images|,  Next: |Other_Image_Types|,  Prev: |ImageMagick_Images|,  Up: |Images|
==============================================================================

                                                                    *SVG_Images*

39.17.6 SVG Images
------------------

SVG (Scalable Vector Graphics) is an XML format for specifying images.
If your Emacs build has SVG support, you can create and manipulate these
images with the following functions from the 'svg.el' library.

 -- Function: svg-create width height &rest args
     Create a new, empty SVG image with the specified dimensions.  ARGS
     is an argument plist with you can specify following:

     ':stroke-width'
          The default width (in pixels) of any lines created.

     ':stroke'
          The default stroke color on any lines created.

     This function returns an "SVG object", a Lisp data structure that
     specifies an SVG image, and all the following functions work on
     that structure.  The argument SVG in the following functions
     specifies such an SVG object.

 -- Function: svg-gradient svg id type stops
     Create a gradient in SVG with identifier ID.  TYPE specifies the
     gradient type, and can be either 'linear' or 'radial'.  STOPS is a
     list of percentage/color pairs.

     The following will create a linear gradient that goes from red at
     the start, to green 25% of the way, to blue at the end:

          (svg-gradient svg "gradient1" 'linear
                        '((0 . "red") (25 . "green") (100 . "blue")))

     The gradient created (and inserted into the SVG object) can later
     be used by all functions that create shapes.

   All the following functions take an optional list of keyword
parameters that alter the various attributes from their default values.
Valid attributes include:

':stroke-width'
     The width (in pixels) of lines drawn, and outlines around solid
     shapes.

':stroke-color'
     The color of lines drawn, and outlines around solid shapes.

':fill-color'
     The color used for solid shapes.

':id'
     The identified of the shape.

':gradient'
     If given, this should be the identifier of a previously defined
     gradient object.

':clip-path'
     Identifier of a clip path.

 -- Function: svg-rectangle svg x y width height &rest args
     Add to SVG a rectangle whose upper left corner is at position X/Y
     and whose size is WIDTH/HEIGHT.

          (svg-rectangle svg 100 100 500 500 :gradient "gradient1")

 -- Function: svg-circle svg x y radius &rest args
     Add to SVG a circle whose center is at X/Y and whose radius is
     RADIUS.

 -- Function: svg-ellipse svg x y x-radius y-radius &rest args
     Add to SVG an ellipse whose center is at X/Y, and whose horizontal
     radius is X-RADIUS and the vertical radius is Y-RADIUS.

 -- Function: svg-line svg x1 y1 x2 y2 &rest args
     Add to SVG a line that starts at X1/Y1 and extends to X2/Y2.

 -- Function: svg-polyline svg points &rest args
     Add to SVG a multiple-segment line (a.k.a. "polyline") that goes
     through POINTS, which is a list of X/Y position pairs.

          (svg-polyline svg '((200 . 100) (500 . 450) (80 . 100))
                        :stroke-color "green")

 -- Function: svg-polygon svg points &rest args
     Add a polygon to SVG where POINTS is a list of X/Y pairs that
     describe the outer circumference of the polygon.

          (svg-polygon svg '((100 . 100) (200 . 150) (150 . 90))
                       :stroke-color "blue" :fill-color "red")

 -- Function: svg-path svg commands &rest args
     Add the outline of a shape to SVG according to COMMANDS, see *note
     SVG Path Commands::.

     Coordinates by default are absolute.  To use coordinates relative
     to the last position, or - initially - to the origin, set the
     attribute :RELATIVE to 't'.  This attribute can be specified for
     the function or for individual commands.  If specified for the
     function, then all commands use relative coordinates by default.
     To make an individual command use absolute coordinates, set
     :RELATIVE to 'nil'.

          (svg-path svg
          	  '((moveto ((100 . 100)))
          	    (lineto ((200 . 0) (0 . 200) (-200 . 0)))
          	    (lineto ((100 . 100)) :relative nil))
          	  :stroke-color "blue"
          	  :fill-color "lightblue"
          	  :relative t)

 -- Function: svg-text svg text &rest args
     Add the specified TEXT to SVG.

          (svg-text
           svg "This is a text"
           :font-size "40"
           :font-weight "bold"
           :stroke "black"
           :fill "white"
           :font-family "impact"
           :letter-spacing "4pt"
           :x 300
           :y 400
           :stroke-width 1)

 -- Function: svg-embed svg image image-type datap &rest args
     Add an embedded (raster) image to SVG.  If DATAP is 'nil', IMAGE
     should be a file name; otherwise it should be a string containing
     the image data as raw bytes.  IMAGE-TYPE should be a MIME image
     type, for instance '"image/jpeg"'.

          (svg-embed svg "~/rms.jpg" "image/jpeg" nil
                     :width "100px" :height "100px"
                     :x "50px" :y "75px")

 -- Function: svg-clip-path svg &rest args
     Add a clipping path to SVG.  If applied to a shape via the
     :CLIP-PATH property, parts of that shape which lie outside of the
     clipping path are not drawn.

          (let ((clip-path (svg-clip-path svg :id "foo")))
            (svg-circle clip-path 200 200 175))
          (svg-rectangle svg 50 50 300 300
                         :fill-color "red"
                         :clip-path "url(#foo)")

 -- Function: svg-node svg tag &rest args
     Add the custom node TAG to SVG.

          (svg-node svg
                    'rect
                    :width 300 :height 200 :x 50 :y 100 :fill-color "green")

 -- Function: svg-remove svg id
     Remove the element with identifier 'id' from the 'svg'.

 -- Function: svg-image svg
     Finally, the 'svg-image' takes an SVG object as its argument and
     returns an image object suitable for use in functions like
     'insert-image'.

   Here's a complete example that creates and inserts an image with a
circle:

     (let ((svg (svg-create 400 400 :stroke-width 10)))
       (svg-gradient svg "gradient1" 'linear '((0 . "red") (100 . "blue")))
       (svg-circle svg 200 200 100 :gradient "gradient1"
                       :stroke-color "green")
       (insert-image (svg-image svg)))

SVG Path Commands
.....------------

"SVG paths" allow creation of complex images by combining lines, curves,
arcs, and other basic shapes.  The functions described below allow
invoking SVG path commands from a Lisp program.

 -- Command: moveto points
     Move the pen to the first point in POINTS.  Additional points are
     connected with lines.  POINTS is a list of X/Y coordinate pairs.
     Subsequent 'moveto' commands represent the start of a new
     "subpath".

          (svg-path svg '((moveto ((200 . 100) (100 . 200) (0 . 100))))
                    :fill "white" :stroke "black")

 -- Command: closepath
     End the current subpath by connecting it back to its initial point.
     A line is drawn along the connection.

          (svg-path svg '((moveto ((200 . 100) (100 . 200) (0 . 100)))
                          (closepath)
                          (moveto ((75 . 125) (100 . 150) (125 . 125)))
                          (closepath))
                    :fill "red" :stroke "black")

 -- Command: lineto points
     Draw a line from the current point to the first element in POINTS,
     a list of X/Y position pairs.  If more than one point is specified,
     draw a polyline.
          (svg-path svg '((moveto ((200 . 100)))
                          (lineto ((100 . 200) (0 . 100))))
                    :fill "yellow" :stroke "red")

 -- Command: horizontal-lineto x-coordinates
     Draw a horizontal line from the current point to the first element
     in X-COORDINATES.  Specifying multiple coordinates is possible,
     although usually this doesn't make sense.

          (svg-path svg '((moveto ((100 . 200)))
                          (horizontal-lineto (300)))
                    :stroke "green")

 -- Command: vertical-lineto y-coordinates
     Draw vertical lines.

          (svg-path svg '((moveto ((200 . 100)))
                          (vertical-lineto (300)))
                    :stroke "green")

 -- Command: curveto coordinate-sets
     Using the first element in COORDINATE-SETS, draw a cubic Be'zier
     curve from the current point.  If there are multiple coordinate
     sets, draw a polybezier.  Each coordinate set is a list of the form
     '(X1 Y1 X2 Y2 X Y)', where (X, Y) is the curve's end point.
     (X1, Y1) and (X2, Y2) are control points at the beginning and at
     the end, respectively.

          (svg-path svg '((moveto ((100 . 100)))
                          (curveto ((200 100 100 200 200 200)
                                    (300 200 0 100 100 100))))
                    :fill "transparent" :stroke "red")

 -- Command: smooth-curveto coordinate-sets
     Using the first element in COORDINATE-SETS, draw a cubic Be'zier
     curve from the current point.  If there are multiple coordinate
     sets, draw a polybezier.  Each coordinate set is a list of the form
     '(X2 Y2 X Y)', where (X, Y) is the curve's end point and (X2, Y2)
     is the corresponding control point.  The first control point is the
     reflection of the second control point of the previous command
     relative to the current point, if that command was 'curveto' or
     'smooth-curveto'.  Otherwise the first control point coincides with
     the current point.

          (svg-path svg '((moveto ((100 . 100)))
                          (curveto ((200 100 100 200 200 200)))
                          (smooth-curveto ((0 100 100 100))))
                    :fill "transparent" :stroke "blue")

 -- Command: quadratic-bezier-curveto coordinate-sets
     Using the first element in COORDINATE-SETS, draw a quadratic Be'zier
     curve from the current point.  If there are multiple coordinate
     sets, draw a polybezier.  Each coordinate set is a list of the form
     '(X1 Y1 X Y)', where (X, Y) is the curve's end point and (X1, Y1)
     is the control point.

          (svg-path svg '((moveto ((200 . 100)))
                          (quadratic-bezier-curveto ((300 100 300 200)))
                          (quadratic-bezier-curveto ((300 300 200 300)))
                          (quadratic-bezier-curveto ((100 300 100 200)))
                          (quadratic-bezier-curveto ((100 100 200 100))))
                    :fill "transparent" :stroke "pink")

 -- Command: smooth-quadratic-bezier-curveto coordinate-sets
     Using the first element in COORDINATE-SETS, draw a quadratic Be'zier
     curve from the current point.  If there are multiple coordinate
     sets, draw a polybezier.  Each coordinate set is a list of the form
     '(X Y)', where (X, Y) is the curve's end point.  The control point
     is the reflection of the control point of the previous command
     relative to the current point, if that command was
     'quadratic-bezier-curveto' or 'smooth-quadratic-bezier-curveto'.
     Otherwise the control point coincides with the current point.

          (svg-path svg '((moveto ((200 . 100)))
                          (quadratic-bezier-curveto ((300 100 300 200)))
                          (smooth-quadratic-bezier-curveto ((200 300)))
                          (smooth-quadratic-bezier-curveto ((100 200)))
                          (smooth-quadratic-bezier-curveto ((200 100))))
                    :fill "transparent" :stroke "lightblue")

 -- Command: elliptical-arc coordinate-sets
     Using the first element in COORDINATE-SETS, draw an elliptical arc
     from the current point.  If there are multiple coordinate sets,
     draw a sequence of elliptical arcs.  Each coordinate set is a list
     of the form '(RX RY X Y)', where (X, Y) is the end point of the
     ellipse, and (RX, RY) are its radii.  Attributes may be appended to
     the list:

     ':x-axis-rotation'
          The angle in degrees by which the x-axis of the ellipse is
          rotated relative to the x-axis of the current coordinate
          system.

     ':large-arc'
          If set to 't', draw an arc sweep greater than or equal to 180
          degrees.  Otherwise, draw an arc sweep smaller than or equal
          to 180 degrees.

     ':sweep'
          If set to 't', draw an arc in "positive angle direction".
          Otherwise, draw it in "negative angle direction".

          (svg-path svg '((moveto ((200 . 250)))
                          (elliptical-arc ((75 75 200 350))))
                    :fill "transparent" :stroke "red")
          (svg-path svg '((moveto ((200 . 250)))
                          (elliptical-arc ((75 75 200 350 :large-arc t))))
                    :fill "transparent" :stroke "green")
          (svg-path svg '((moveto ((200 . 250)))
                          (elliptical-arc ((75 75 200 350 :sweep t))))
                    :fill "transparent" :stroke "blue")
          (svg-path svg '((moveto ((200 . 250)))
                          (elliptical-arc ((75 75 200 350 :large-arc t
                                               :sweep t))))
                    :fill "transparent" :stroke "gray")
          (svg-path svg '((moveto ((160 . 100)))
                          (elliptical-arc ((40 100 80 0)))
                          (elliptical-arc ((40 100 -40 -70
                                               :x-axis-rotation -120)))
                          (elliptical-arc ((40 100 -40 70
                                               :x-axis-rotation -240))))
                    :stroke "pink" :fill "lightblue"
                    :relative t)

==============================================================================
File: elisp.info,  Node: |Other_Image_Types|,  Next: |Defining_Images|,  Prev: |SVG_Images|,  Up: |Images|
==============================================================================

                                                             *Other_Image_Types*

39.17.7 Other Image Types
-------------------------

For PBM images, specify image type 'pbm'.  Color, gray-scale and
monochromatic images are supported.  For mono PBM images, two additional
image properties are supported.

':foreground FOREGROUND'
     The value, FOREGROUND, should be a string specifying the image
     foreground color, or 'nil' for the default color.  This color is
     used for each pixel in the PBM that is 1.  The default is the
     frame's foreground color.

':background BACKGROUND'
     The value, BACKGROUND, should be a string specifying the image
     background color, or 'nil' for the default color.  This color is
     used for each pixel in the PBM that is 0.  The default is the
     frame's background color.

The remaining image types that Emacs can support are:

GIF
     Image type 'gif'.  Supports the ':index' property.  *Note
     Multi-Frame Images::.

JPEG
     Image type 'jpeg'.

PNG
     Image type 'png'.

TIFF
     Image type 'tiff'.  Supports the ':index' property.  *Note
     Multi-Frame Images::.

==============================================================================
File: elisp.info,  Node: |Defining_Images|,  Next: |Showing_Images|,  Prev: |Other_Image_Types|,  Up: |Images|
==============================================================================

                                                               *Defining_Images*

39.17.8 Defining Images
-----------------------

The functions 'create-image', 'defimage' and 'find-image' provide
convenient ways to create image descriptors.

 -- Function: create-image file-or-data &optional type data-p &rest
          props
     This function creates and returns an image descriptor which uses
     the data in FILE-OR-DATA.  FILE-OR-DATA can be a file name or a
     string containing the image data; DATA-P should be 'nil' for the
     former case, non-'nil' for the latter case.

     The optional argument TYPE is a symbol specifying the image type.
     If TYPE is omitted or 'nil', 'create-image' tries to determine the
     image type from the file's first few bytes, or else from the file's
     name.

     The remaining arguments, PROPS, specify additional image
     properties--for example,

          (create-image "foo.xpm" 'xpm nil :heuristic-mask t)

     The function returns 'nil' if images of this type are not
     supported.  Otherwise it returns an image descriptor.

 -- Macro: defimage symbol specs &optional doc
     This macro defines SYMBOL as an image name.  The arguments SPECS is
     a list which specifies how to display the image.  The third
     argument, DOC, is an optional documentation string.

     Each argument in SPECS has the form of a property list, and each
     one should specify at least the ':type' property and either the
     ':file' or the ':data' property.  The value of ':type' should be a
     symbol specifying the image type, the value of ':file' is the file
     to load the image from, and the value of ':data' is a string
     containing the actual image data.  Here is an example:

          (defimage test-image
            ((:type xpm :file "~/test1.xpm")
             (:type xbm :file "~/test1.xbm")))

     'defimage' tests each argument, one by one, to see if it is
     usable--that is, if the type is supported and the file exists.  The
     first usable argument is used to make an image descriptor which is
     stored in SYMBOL.

     If none of the alternatives will work, then SYMBOL is defined as
     'nil'.

 -- Function: image-property image property
     Return the value of PROPERTY in IMAGE.  Properties can be set by
     using 'setf'.  Setting a property to 'nil' will remove the property
     from the image.

 -- Function: find-image specs
     This function provides a convenient way to find an image satisfying
     one of a list of image specifications SPECS.

     Each specification in SPECS is a property list with contents
     depending on image type.  All specifications must at least contain
     the properties ':type TYPE' and either ':file FILE' or
     ':data DATA', where TYPE is a symbol specifying the image type,
     e.g., 'xbm', FILE is the file to load the image from, and DATA is a
     string containing the actual image data.  The first specification
     in the list whose TYPE is supported, and FILE exists, is used to
     construct the image specification to be returned.  If no
     specification is satisfied, 'nil' is returned.

     The image is looked for in 'image-load-path'.

 -- User Option: image-load-path
     This variable's value is a list of locations in which to search for
     image files.  If an element is a string or a variable symbol whose
     value is a string, the string is taken to be the name of a
     directory to search.  If an element is a variable symbol whose
     value is a list, that is taken to be a list of directories to
     search.

     The default is to search in the 'images' subdirectory of the
     directory specified by 'data-directory', then the directory
     specified by 'data-directory', and finally in the directories in
     'load-path'.  Subdirectories are not automatically included in the
     search, so if you put an image file in a subdirectory, you have to
     supply the subdirectory explicitly.  For example, to find the image
     'images/foo/bar.xpm' within 'data-directory', you should specify
     the image as follows:

          (defimage foo-image '((:type xpm :file "foo/bar.xpm")))

 -- Function: image-load-path-for-library library image &optional path
          no-error
     This function returns a suitable search path for images used by the
     Lisp package LIBRARY.

     The function searches for IMAGE first using 'image-load-path',
     excluding 'data-directory/images', and then in 'load-path',
     followed by a path suitable for LIBRARY, which includes
     '../../etc/images' and '../etc/images' relative to the library file
     itself, and finally in 'data-directory/images'.

     Then this function returns a list of directories which contains
     first the directory in which IMAGE was found, followed by the value
     of 'load-path'.  If PATH is given, it is used instead of
     'load-path'.

     If NO-ERROR is non-'nil' and a suitable path can't be found, don't
     signal an error.  Instead, return a list of directories as before,
     except that 'nil' appears in place of the image directory.

     Here is an example of using 'image-load-path-for-library':

          (defvar image-load-path) ; shush compiler
          (let* ((load-path (image-load-path-for-library
                              "mh-e" "mh-logo.xpm"))
                 (image-load-path (cons (car load-path)
                                        image-load-path)))
            (mh-tool-bar-folder-buttons-init))

   Images are automatically scaled when created based on the
'image-scaling-factor' variable.  The value is either a floating point
number (where numbers higher than 1 means to increase the size and lower
means to shrink the size), or the symbol 'auto', which will compute a
scaling factor based on the font pixel size.

==============================================================================
File: elisp.info,  Node: |Showing_Images|,  Next: |Multi_Frame_Images|,  Prev: |Defining_Images|,  Up: |Images|
==============================================================================

                                                                *Showing_Images*

39.17.9 Showing Images
----------------------

You can use an image descriptor by setting up the 'display' property
yourself, but it is easier to use the functions in this section.

 -- Function: insert-image image &optional string area slice
     This function inserts IMAGE in the current buffer at point.  The
     value IMAGE should be an image descriptor; it could be a value
     returned by 'create-image', or the value of a symbol defined with
     'defimage'.  The argument STRING specifies the text to put in the
     buffer to hold the image.  If it is omitted or 'nil',
     'insert-image' uses '" "' by default.

     The argument AREA specifies whether to put the image in a margin.
     If it is 'left-margin', the image appears in the left margin;
     'right-margin' specifies the right margin.  If AREA is 'nil' or
     omitted, the image is displayed at point within the buffer's text.

     The argument SLICE specifies a slice of the image to insert.  If
     SLICE is 'nil' or omitted the whole image is inserted.  Otherwise,
     SLICE is a list '(X Y WIDTH HEIGHT)' which specifies the X and Y
     positions and WIDTH and HEIGHT of the image area to insert.
     Integer values are in units of pixels.  A floating-point number in
     the range 0.0-1.0 stands for that fraction of the width or height
     of the entire image.

     Internally, this function inserts STRING in the buffer, and gives
     it a 'display' property which specifies IMAGE.  *Note Display
     Property::.

 -- Function: insert-sliced-image image &optional string area rows cols
     This function inserts IMAGE in the current buffer at point, like
     'insert-image', but splits the image into ROWSxCOLS equally sized
     slices.

     Emacs displays each slice as a separate image, and allows more
     intuitive scrolling up/down, instead of jumping up/down the entire
     image when paging through a buffer that displays (large) images.

 -- Function: put-image image pos &optional string area
     This function puts image IMAGE in front of POS in the current
     buffer.  The argument POS should be an integer or a marker.  It
     specifies the buffer position where the image should appear.  The
     argument STRING specifies the text that should hold the image as an
     alternative to the default.

     The argument IMAGE must be an image descriptor, perhaps returned by
     'create-image' or stored by 'defimage'.

     The argument AREA specifies whether to put the image in a margin.
     If it is 'left-margin', the image appears in the left margin;
     'right-margin' specifies the right margin.  If AREA is 'nil' or
     omitted, the image is displayed at point within the buffer's text.

     Internally, this function creates an overlay, and gives it a
     'before-string' property containing text that has a 'display'
     property whose value is the image.  (Whew!)

 -- Function: remove-images start end &optional buffer
     This function removes images in BUFFER between positions START and
     END.  If BUFFER is omitted or 'nil', images are removed from the
     current buffer.

     This removes only images that were put into BUFFER the way
     'put-image' does it, not images that were inserted with
     'insert-image' or in other ways.

 -- Function: image-size spec &optional pixels frame
     This function returns the size of an image as a pair
     '(WIDTH . HEIGHT)'.  SPEC is an image specification.  PIXELS
     non-'nil' means return sizes measured in pixels, otherwise return
     sizes measured in the default character size of FRAME (*note Frame
     Font::).  FRAME is the frame on which the image will be displayed.
     FRAME 'nil' or omitted means use the selected frame (*note Input
     Focus::).

 -- Variable: max-image-size
     This variable is used to define the maximum size of image that
     Emacs will load.  Emacs will refuse to load (and display) any image
     that is larger than this limit.

     If the value is an integer, it directly specifies the maximum image
     height and width, measured in pixels.  If it is floating point, it
     specifies the maximum image height and width as a ratio to the
     frame height and width.  If the value is non-numeric, there is no
     explicit limit on the size of images.

     The purpose of this variable is to prevent unreasonably large
     images from accidentally being loaded into Emacs.  It only takes
     effect the first time an image is loaded.  Once an image is placed
     in the image cache, it can always be displayed, even if the value
     of 'max-image-size' is subsequently changed (*note Image Cache::).

   Images inserted with the insertion functions above also get a local
keymap installed in the text properties (or overlays) that span the
displayed image.  This keymap defines the following commands:

'+'
     Increase the image size ('image-increase-size').  A prefix value of
     '4' means to increase the size by 40%.  The default is 20%.

'-'
     Decrease the image size ('image-increase-size').  A prefix value of
     '4' means to decrease the size by 40%.  The default is 20%.

'r'
     Rotate the image by 90 degrees clockwise ('image-rotate').  A
     prefix means to rotate by 90 degrees counter-clockwise instead.

'o'
     Save the image to a file ('image-save').

==============================================================================
File: elisp.info,  Node: |Multi_Frame_Images|,  Next: |Image_Cache|,  Prev: |Showing_Images|,  Up: |Images|
==============================================================================

                                                            *Multi_Frame_Images*

39.17.10 Multi-Frame Images
---------------------------

Some image files can contain more than one image.  We say that there are
multiple "frames" in the image.  At present, Emacs supports multiple
frames for GIF, TIFF, and certain ImageMagick formats such as DJVM.

   The frames can be used either to represent multiple pages (this is
usually the case with multi-frame TIFF files, for example), or to create
animation (usually the case with multi-frame GIF files).

   A multi-frame image has a property ':index', whose value is an
integer (counting from 0) that specifies which frame is being displayed.

 -- Function: image-multi-frame-p image
     This function returns non-'nil' if IMAGE contains more than one
     frame.  The actual return value is a cons '(NIMAGES . DELAY)',
     where NIMAGES is the number of frames and DELAY is the delay in
     seconds between them, or 'nil' if the image does not specify a
     delay.  Images that are intended to be animated usually specify a
     frame delay, whereas ones that are intended to be treated as
     multiple pages do not.

 -- Function: image-current-frame image
     This function returns the index of the current frame number for
     IMAGE, counting from 0.

 -- Function: image-show-frame image n &optional nocheck
     This function switches IMAGE to frame number N.  It replaces a
     frame number outside the valid range with that of the end of the
     range, unless NOCHECK is non-'nil'.  If IMAGE does not contain a
     frame with the specified number, the image displays as a hollow
     box.

 -- Function: image-animate image &optional index limit
     This function animates IMAGE.  The optional integer INDEX specifies
     the frame from which to start (default 0).  The optional argument
     LIMIT controls the length of the animation.  If omitted or 'nil',
     the image animates once only; if 't' it loops forever; if a number
     animation stops after that many seconds.

Animation operates by means of a timer.  Note that Emacs imposes a
minimum frame delay of 0.01 ('image-minimum-frame-delay') seconds.  If
the image itself does not specify a delay, Emacs uses
'image-default-frame-delay'.

 -- Function: image-animate-timer image
     This function returns the timer responsible for animating IMAGE, if
     there is one.

==============================================================================
File: elisp.info,  Node: |Image_Cache|,  Prev: |Multi_Frame_Images|,  Up: |Images|
==============================================================================

                                                                   *Image_Cache*

39.17.11 Image Cache
--------------------

Emacs caches images so that it can display them again more efficiently.
When Emacs displays an image, it searches the image cache for an
existing image specification 'equal' to the desired specification.  If a
match is found, the image is displayed from the cache.  Otherwise, Emacs
loads the image normally.

 -- Function: image-flush spec &optional frame
     This function removes the image with specification SPEC from the
     image cache of frame FRAME.  Image specifications are compared
     using 'equal'.  If FRAME is 'nil', it defaults to the selected
     frame.  If FRAME is 't', the image is flushed on all existing
     frames.

     In Emacs's current implementation, each graphical terminal
     possesses an image cache, which is shared by all the frames on that
     terminal (*note Multiple Terminals::).  Thus, refreshing an image
     in one frame also refreshes it in all other frames on the same
     terminal.

   One use for 'image-flush' is to tell Emacs about a change in an image
file.  If an image specification contains a ':file' property, the image
is cached based on the file's contents when the image is first
displayed.  Even if the file subsequently changes, Emacs continues
displaying the old version of the image.  Calling 'image-flush' flushes
the image from the cache, forcing Emacs to re-read the file the next
time it needs to display that image.

   Another use for 'image-flush' is for memory conservation.  If your
Lisp program creates a large number of temporary images over a period
much shorter than 'image-cache-eviction-delay' (see below), you can opt
to flush unused images yourself, instead of waiting for Emacs to do it
automatically.

 -- Function: clear-image-cache &optional filter
     This function clears an image cache, removing all the images stored
     in it.  If FILTER is omitted or 'nil', it clears the cache for the
     selected frame.  If FILTER is a frame, it clears the cache for that
     frame.  If FILTER is 't', all image caches are cleared.  Otherwise,
     FILTER is taken to be a file name, and all images associated with
     that file name are removed from all image caches.

   If an image in the image cache has not been displayed for a specified
period of time, Emacs removes it from the cache and frees the associated
memory.

 -- Variable: image-cache-eviction-delay
     This variable specifies the number of seconds an image can remain
     in the cache without being displayed.  When an image is not
     displayed for this length of time, Emacs removes it from the image
     cache.

     Under some circumstances, if the number of images in the cache
     grows too large, the actual eviction delay may be shorter than
     this.

     If the value is 'nil', Emacs does not remove images from the cache
     except when you explicitly clear it.  This mode can be useful for
     debugging.

==============================================================================
File: elisp.info,  Node: |Xwidgets|,  Next: |Buttons|,  Prev: |Images|,  Up: |Display|
==============================================================================

                                                                      *Xwidgets*

39.18 Embedded Native Widgets
=====------------------------

Emacs is able to display native widgets, such as GTK+ WebKit widgets, in
Emacs buffers when it was built with the necessary support libraries and
is running on a graphical terminal.  To test whether Emacs supports
display of embedded widgets, check that the 'xwidget-internal' feature
is available (*note Named Features::).

   To display an embedded widget in a buffer, you must first create an
xwidget object, and then use that object as the display specifier in a
'display' text or overlay property (*note Display Property::).

 -- Function: make-xwidget type title width height arguments &optional
          buffer
     This creates and returns an xwidget object.  If BUFFER is omitted
     or 'nil', it defaults to the current buffer.  If BUFFER names a
     buffer that doesn't exist, it will be created.  The TYPE identifies
     the type of the xwidget component, it can be one of the following:

     'webkit'
          The WebKit component.

     The WIDTH and HEIGHT arguments specify the widget size in pixels,
     and TITLE, a string, specifies its title.

 -- Function: xwidgetp object
     This function returns 't' if OBJECT is an xwidget, 'nil' otherwise.

 -- Function: xwidget-plist xwidget
     This function returns the property list of XWIDGET.

 -- Function: set-xwidget-plist xwidget plist
     This function replaces the property list of XWIDGET with a new
     property list given by PLIST.

 -- Function: xwidget-buffer xwidget
     This function returns the buffer of XWIDGET.

 -- Function: get-buffer-xwidgets buffer
     This function returns a list of xwidget objects associated with the
     BUFFER, which can be specified as a buffer object or a name of an
     existing buffer, a string.  The value is 'nil' if BUFFER contains
     no xwidgets.

 -- Function: xwidget-webkit-goto-uri xwidget uri
     This function browses the specified URI in the given XWIDGET.  The
     URI is a string that specifies the name of a file or a URL.

 -- Function: xwidget-webkit-execute-script xwidget script
     This function causes the browser widget specified by XWIDGET to
     execute the specified JavaScript 'script'.

 -- Function: xwidget-webkit-execute-script-rv xwidget script &optional
          default
     This function executes the specified SCRIPT like
     'xwidget-webkit-execute-script' does, but it also returns the
     script's return value as a string.  If SCRIPT doesn't return a
     value, this function returns DEFAULT, or 'nil' if DEFAULT was
     omitted.

 -- Function: xwidget-webkit-get-title xwidget
     This function returns the title of XWIDGET as a string.

 -- Function: xwidget-resize xwidget width height
     This function resizes the specified XWIDGET to the size
     WIDTHxHEIGHT pixels.

 -- Function: xwidget-size-request xwidget
     This function returns the desired size of XWIDGET as a list of the
     form '(WIDTH HEIGHT)'.  The dimensions are in pixels.

 -- Function: xwidget-info xwidget
     This function returns the attributes of XWIDGET as a vector of the
     form '[TYPE TITLE WIDTH HEIGHT]'.  The attributes are usually
     determined by 'make-xwidget' when the xwidget is created.

 -- Function: set-xwidget-query-on-exit-flag xwidget flag
     This function allows you to arrange that Emacs will ask the user
     for confirmation before exiting or before killing a buffer that has
     XWIDGET associated with it.  If FLAG is non-'nil', Emacs will query
     the user, otherwise it will not.

 -- Function: xwidget-query-on-exit-flag xwidget
     This function returns the current setting of XWIDGETs query-on-exit
     flag, either 't' or 'nil'.

==============================================================================
File: elisp.info,  Node: |Buttons|,  Next: |Abstract_Display|,  Prev: |Xwidgets|,  Up: |Display|
==============================================================================

                                                                       *Buttons*

39.19 Buttons
=====--------

The Button package defines functions for inserting and manipulating
"buttons" that can be activated with the mouse or via keyboard commands.
These buttons are typically used for various kinds of hyperlinks.

   A button is essentially a set of text or overlay properties, attached
to a stretch of text in a buffer.  These properties are called "button
properties".  One of these properties, the "action property", specifies
a function which is called when the user invokes the button using the
keyboard or the mouse.  The action function may examine the button and
use its other properties as desired.

   In some ways, the Button package duplicates the functionality in the
Widget package.  *Note Introduction: (widget)Top.  The advantage of the
Button package is that it is faster, smaller, and simpler to program.
From the point of view of the user, the interfaces produced by the two
packages are very similar.

MENU

* |Button_Properties|::      Button properties with special meanings.
* |Button_Types|::           Defining common properties for classes of buttons.
* |Making_Buttons|::         Adding buttons to Emacs buffers.
* |Manipulating_Buttons|::   Getting and setting properties of buttons.
* |Button_Buffer_Commands|:: Buffer-wide commands and bindings for buttons.

==============================================================================
File: elisp.info,  Node: |Button_Properties|,  Next: |Button_Types|,  Up: |Buttons|
==============================================================================

                                                             *Button_Properties*

39.19.1 Button Properties
-------------------------

Each button has an associated list of properties defining its appearance
and behavior, and other arbitrary properties may be used for application
specific purposes.  The following properties have special meaning to the
Button package:

'action'
     The function to call when the user invokes the button, which is
     passed the single argument BUTTON.  By default this is 'ignore',
     which does nothing.

'mouse-action'
     This is similar to 'action', and when present, will be used instead
     of 'action' for button invocations resulting from mouse-clicks
     (instead of the user hitting <RET>).  If not present, mouse-clicks
     use 'action' instead.

'face'
     This is an Emacs face controlling how buttons of this type are
     displayed; by default this is the 'button' face.

'mouse-face'
     This is an additional face which controls appearance during
     mouse-overs (merged with the usual button face); by default this is
     the usual Emacs 'highlight' face.

'keymap'
     The button's keymap, defining bindings active within the button
     region.  By default this is the usual button region keymap, stored
     in the variable 'button-map', which defines <RET> and <mouse-2> to
     invoke the button.

'type'
     The button type.  *Note Button Types::.

'help-echo'
     A string displayed by the Emacs tooltip help system; by default,
     '"mouse-2, RET: Push this button"'.  Alternatively, a function that
     returns, or a form that evaluates to, a string to be displayed or
     'nil'.  For details see *note Text help-echo::.

     The function is called with three arguments, WINDOW, OBJECT, and
     POS.  The second argument, OBJECT, is either the overlay that had
     the property (for overlay buttons), or the buffer containing the
     button (for text property buttons).  The other arguments have the
     same meaning as for the special text property 'help-echo'.

'follow-link'
     The 'follow-link' property, defining how a <mouse-1> click behaves
     on this button, *Note Clickable Text::.

'button'
     All buttons have a non-'nil' 'button' property, which may be useful
     in finding regions of text that comprise buttons (which is what the
     standard button functions do).

   There are other properties defined for the regions of text in a
button, but these are not generally interesting for typical uses.

==============================================================================
File: elisp.info,  Node: |Button_Types|,  Next: |Making_Buttons|,  Prev: |Button_Properties|,  Up: |Buttons|
==============================================================================

                                                                  *Button_Types*

39.19.2 Button Types
--------------------

Every button has a "button type", which defines default values for the
button's properties.  Button types are arranged in a hierarchy, with
specialized types inheriting from more general types, so that it's easy
to define special-purpose types of buttons for specific tasks.

 -- Function: define-button-type name &rest properties
     Define a button type called NAME (a symbol).  The remaining
     arguments form a sequence of PROPERTY VALUE pairs, specifying
     default property values for buttons with this type (a button's type
     may be set by giving it a 'type' property when creating the button,
     using the ':type' keyword argument).

     In addition, the keyword argument ':supertype' may be used to
     specify a button-type from which NAME inherits its default property
     values.  Note that this inheritance happens only when NAME is
     defined; subsequent changes to a supertype are not reflected in its
     subtypes.

   Using 'define-button-type' to define default properties for buttons
is not necessary--buttons without any specified type use the built-in
button-type 'button'--but it is encouraged, since doing so usually makes
the resulting code clearer and more efficient.

==============================================================================
File: elisp.info,  Node: |Making_Buttons|,  Next: |Manipulating_Buttons|,  Prev: |Button_Types|,  Up: |Buttons|
==============================================================================

                                                                *Making_Buttons*

39.19.3 Making Buttons
----------------------

Buttons are associated with a region of text, using an overlay or text
properties to hold button-specific information, all of which are
initialized from the button's type (which defaults to the built-in
button type 'button').  Like all Emacs text, the appearance of the
button is governed by the 'face' property; by default (via the 'face'
property inherited from the 'button' button-type) this is a simple
underline, like a typical web-page link.

   For convenience, there are two sorts of button-creation functions,
those that add button properties to an existing region of a buffer,
called 'make-...button', and those that also insert the button text,
called 'insert-...button'.

   The button-creation functions all take the '&rest' argument
PROPERTIES, which should be a sequence of PROPERTY VALUE pairs,
specifying properties to add to the button; see *note Button
Properties::.  In addition, the keyword argument ':type' may be used to
specify a button-type from which to inherit other properties; see *note
Button Types::.  Any properties not explicitly specified during creation
will be inherited from the button's type (if the type defines such a
property).

   The following functions add a button using an overlay (*note
Overlays::) to hold the button properties:

 -- Function: make-button beg end &rest properties
     This makes a button from BEG to END in the current buffer, and
     returns it.

 -- Function: insert-button label &rest properties
     This insert a button with the label LABEL at point, and returns it.

   The following functions are similar, but using text properties (*note
Text Properties::) to hold the button properties.  Such buttons do not
add markers to the buffer, so editing in the buffer does not slow down
if there is an extremely large numbers of buttons.  However, if there is
an existing face text property on the text (e.g., a face assigned by
Font Lock mode), the button face may not be visible.  Both of these
functions return the starting position of the new button.

 -- Function: make-text-button beg end &rest properties
     This makes a button from BEG to END in the current buffer, using
     text properties.

 -- Function: insert-text-button label &rest properties
     This inserts a button with the label LABEL at point, using text
     properties.

==============================================================================
File: elisp.info,  Node: |Manipulating_Buttons|,  Next: |Button_Buffer_Commands|,  Prev: |Making_Buttons|,  Up: |Buttons|
==============================================================================

                                                          *Manipulating_Buttons*

39.19.4 Manipulating Buttons
----------------------------

These are functions for getting and setting properties of buttons.
Often these are used by a button's invocation function to determine what
to do.

   Where a BUTTON parameter is specified, it means an object referring
to a specific button, either an overlay (for overlay buttons), or a
buffer-position or marker (for text property buttons).  Such an object
is passed as the first argument to a button's invocation function when
it is invoked.

 -- Function: button-start button
     Return the position at which BUTTON starts.

 -- Function: button-end button
     Return the position at which BUTTON ends.

 -- Function: button-get button prop
     Get the property of button BUTTON named PROP.

 -- Function: button-put button prop val
     Set BUTTON's PROP property to VAL.

 -- Function: button-activate button &optional use-mouse-action
     Call BUTTON's 'action' property (i.e., invoke the function that is
     the value of that property, passing it the single argument BUTTON).
     If USE-MOUSE-ACTION is non-'nil', try to invoke the button's
     'mouse-action' property instead of 'action'; if the button has no
     'mouse-action' property, use 'action' as normal.  If the
     'button-data' property is present in BUTTON, use that as the
     argument for the 'action' function instead of BUTTON.

 -- Function: button-label button
     Return BUTTON's text label.

 -- Function: button-type button
     Return BUTTON's button-type.

 -- Function: button-has-type-p button type
     Return 't' if BUTTON has button-type TYPE, or one of TYPE's
     subtypes.

 -- Function: button-at pos
     Return the button at position POS in the current buffer, or 'nil'.
     If the button at POS is a text property button, the return value is
     a marker pointing to POS.

 -- Function: button-type-put type prop val
     Set the button-type TYPE's PROP property to VAL.

 -- Function: button-type-get type prop
     Get the property of button-type TYPE named PROP.

 -- Function: button-type-subtype-p type supertype
     Return 't' if button-type TYPE is a subtype of SUPERTYPE.

==============================================================================
File: elisp.info,  Node: |Button_Buffer_Commands|,  Prev: |Manipulating_Buttons|,  Up: |Buttons|
==============================================================================

                                                        *Button_Buffer_Commands*

39.19.5 Button Buffer Commands
------------------------------

These are commands and functions for locating and operating on buttons
in an Emacs buffer.

   'push-button' is the command that a user uses to actually push a
button, and is bound by default in the button itself to <RET> and to
<mouse-2> using a local keymap in the button's overlay or text
properties.  Commands that are useful outside the buttons itself, such
as 'forward-button' and 'backward-button' are additionally available in
the keymap stored in 'button-buffer-map'; a mode which uses buttons may
want to use 'button-buffer-map' as a parent keymap for its keymap.

   If the button has a non-'nil' 'follow-link' property, and
'mouse-1-click-follows-link' is set, a quick <mouse-1> click will also
activate the 'push-button' command.  *Note Clickable Text::.

 -- Command: push-button &optional pos use-mouse-action
     Perform the action specified by a button at location POS.  POS may
     be either a buffer position or a mouse-event.  If USE-MOUSE-ACTION
     is non-'nil', or POS is a mouse-event (*note Mouse Events::), try
     to invoke the button's 'mouse-action' property instead of 'action';
     if the button has no 'mouse-action' property, use 'action' as
     normal.  POS defaults to point, except when 'push-button' is
     invoked interactively as the result of a mouse-event, in which
     case, the mouse event's position is used.  If there's no button at
     POS, do nothing and return 'nil', otherwise return 't'.

 -- Command: forward-button n &optional wrap display-message no-error
     Move to the Nth next button, or Nth previous button if N is
     negative.  If N is zero, move to the start of any button at point.
     If WRAP is non-'nil', moving past either end of the buffer
     continues from the other end.  If DISPLAY-MESSAGE is non-'nil', the
     button's help-echo string is displayed.  Any button with a
     non-'nil' 'skip' property is skipped over.  Returns the button
     found, and signals an error if no buttons can be found.  If
     NO-ERROR in non-'nil', return nil instead of signaling the error.

 -- Command: backward-button n &optional wrap display-message
     Move to the Nth previous button, or Nth next button if N is
     negative.  If N is zero, move to the start of any button at point.
     If WRAP is non-'nil', moving past either end of the buffer
     continues from the other end.  If DISPLAY-MESSAGE is non-'nil', the
     button's help-echo string is displayed.  Any button with a
     non-'nil' 'skip' property is skipped over.  Returns the button
     found, and signals an error if no buttons can be found.  If
     NO-ERROR in non-'nil', return nil instead of signaling the error.

 -- Function: next-button pos &optional count-current
 -- Function: previous-button pos &optional count-current
     Return the next button after (for 'next-button') or before (for
     'previous-button') position POS in the current buffer.  If
     COUNT-CURRENT is non-'nil', count any button at POS in the search,
     instead of starting at the next button.

==============================================================================
File: elisp.info,  Node: |Abstract_Display|,  Next: |Blinking|,  Prev: |Buttons|,  Up: |Display|
==============================================================================

                                                              *Abstract_Display*

39.20 Abstract Display
=====-----------------

The Ewoc package constructs buffer text that represents a structure of
Lisp objects, and updates the text to follow changes in that structure.
This is like the "view" component in the "model-view-controller" design
paradigm.  Ewoc means "Emacs's Widget for Object Collections".

   An "ewoc" is a structure that organizes information required to
construct buffer text that represents certain Lisp data.  The buffer
text of the ewoc has three parts, in order: first, fixed "header" text;
next, textual descriptions of a series of data elements (Lisp objects
that you specify); and last, fixed "footer" text.  Specifically, an ewoc
contains information on:

   * The buffer which its text is generated in.

   * The text's start position in the buffer.

   * The header and footer strings.

   * A doubly-linked chain of "nodes", each of which contains:

        * A "data element", a single Lisp object.

        * Links to the preceding and following nodes in the chain.

   * A "pretty-printer" function which is responsible for inserting the
     textual representation of a data element value into the current
     buffer.

   Typically, you define an ewoc with 'ewoc-create', and then pass the
resulting ewoc structure to other functions in the Ewoc package to build
nodes within it, and display it in the buffer.  Once it is displayed in
the buffer, other functions determine the correspondence between buffer
positions and nodes, move point from one node's textual representation
to another, and so forth.  *Note Abstract Display Functions::.

   A node "encapsulates" a data element much the way a variable holds a
value.  Normally, encapsulation occurs as a part of adding a node to the
ewoc.  You can retrieve the data element value and place a new value in
its place, like so:

     (ewoc-data NODE)
     => value

     (ewoc-set-data NODE NEW-VALUE)
     => NEW-VALUE

You can also use, as the data element value, a Lisp object (list or
vector) that is a container for the real value, or an index into some
other structure.  The example (*note Abstract Display Example::) uses
the latter approach.

   When the data changes, you will want to update the text in the
buffer.  You can update all nodes by calling 'ewoc-refresh', or just
specific nodes using 'ewoc-invalidate', or all nodes satisfying a
predicate using 'ewoc-map'.  Alternatively, you can delete invalid nodes
using 'ewoc-delete' or 'ewoc-filter', and add new nodes in their place.
Deleting a node from an ewoc deletes its associated textual description
from buffer, as well.

MENU

* |Abstract_Display_Functions|::  Functions in the Ewoc package.
* |Abstract_Display_Example|::    Example of using Ewoc.

==============================================================================
File: elisp.info,  Node: |Abstract_Display_Functions|,  Next: |Abstract_Display_Example|,  Up: |Abstract_Display|
==============================================================================

                                                    *Abstract_Display_Functions*

39.20.1 Abstract Display Functions
----------------------------------

In this subsection, EWOC and NODE stand for the structures described
above (*note Abstract Display::), while DATA stands for an arbitrary
Lisp object used as a data element.

 -- Function: ewoc-create pretty-printer &optional header footer nosep
     This constructs and returns a new ewoc, with no nodes (and thus no
     data elements).  PRETTY-PRINTER should be a function that takes one
     argument, a data element of the sort you plan to use in this ewoc,
     and inserts its textual description at point using 'insert' (and
     never 'insert-before-markers', because that would interfere with
     the Ewoc package's internal mechanisms).

     Normally, a newline is automatically inserted after the header, the
     footer and every node's textual description.  If NOSEP is
     non-'nil', no newline is inserted.  This may be useful for
     displaying an entire ewoc on a single line, for example, or for
     making nodes invisible by arranging for PRETTY-PRINTER to do
     nothing for those nodes.

     An ewoc maintains its text in the buffer that is current when you
     create it, so switch to the intended buffer before calling
     'ewoc-create'.

 -- Function: ewoc-buffer ewoc
     This returns the buffer where EWOC maintains its text.

 -- Function: ewoc-get-hf ewoc
     This returns a cons cell '(HEADER . FOOTER)' made from EWOC's
     header and footer.

 -- Function: ewoc-set-hf ewoc header footer
     This sets the header and footer of EWOC to the strings HEADER and
     FOOTER, respectively.

 -- Function: ewoc-enter-first ewoc data
 -- Function: ewoc-enter-last ewoc data
     These add a new node encapsulating DATA, putting it, respectively,
     at the beginning or end of EWOC's chain of nodes.

 -- Function: ewoc-enter-before ewoc node data
 -- Function: ewoc-enter-after ewoc node data
     These add a new node encapsulating DATA, adding it to EWOC before
     or after NODE, respectively.

 -- Function: ewoc-prev ewoc node
 -- Function: ewoc-next ewoc node
     These return, respectively, the previous node and the next node of
     NODE in EWOC.

 -- Function: ewoc-nth ewoc n
     This returns the node in EWOC found at zero-based index N.  A
     negative N means count from the end.  'ewoc-nth' returns 'nil' if N
     is out of range.

 -- Function: ewoc-data node
     This extracts the data encapsulated by NODE and returns it.

 -- Function: ewoc-set-data node data
     This sets the data encapsulated by NODE to DATA.

 -- Function: ewoc-locate ewoc &optional pos guess
     This determines the node in EWOC which contains point (or POS if
     specified), and returns that node.  If EWOC has no nodes, it
     returns 'nil'.  If POS is before the first node, it returns the
     first node; if POS is after the last node, it returns the last
     node.  The optional third arg GUESS should be a node that is likely
     to be near POS; this doesn't alter the result, but makes the
     function run faster.

 -- Function: ewoc-location node
     This returns the start position of NODE.

 -- Function: ewoc-goto-prev ewoc arg
 -- Function: ewoc-goto-next ewoc arg
     These move point to the previous or next, respectively, ARGth node
     in EWOC.  'ewoc-goto-prev' does not move if it is already at the
     first node or if EWOC is empty, whereas 'ewoc-goto-next' moves past
     the last node, returning 'nil'.  Excepting this special case, these
     functions return the node moved to.

 -- Function: ewoc-goto-node ewoc node
     This moves point to the start of NODE in EWOC.

 -- Function: ewoc-refresh ewoc
     This function regenerates the text of EWOC.  It works by deleting
     the text between the header and the footer, i.e., all the data
     elements' representations, and then calling the pretty-printer
     function for each node, one by one, in order.

 -- Function: ewoc-invalidate ewoc &rest nodes
     This is similar to 'ewoc-refresh', except that only NODES in EWOC
     are updated instead of the entire set.

 -- Function: ewoc-delete ewoc &rest nodes
     This deletes each node in NODES from EWOC.

 -- Function: ewoc-filter ewoc predicate &rest args
     This calls PREDICATE for each data element in EWOC and deletes
     those nodes for which PREDICATE returns 'nil'.  Any ARGS are passed
     to PREDICATE.

 -- Function: ewoc-collect ewoc predicate &rest args
     This calls PREDICATE for each data element in EWOC and returns a
     list of those elements for which PREDICATE returns non-'nil'.  The
     elements in the list are ordered as in the buffer.  Any ARGS are
     passed to PREDICATE.

 -- Function: ewoc-map map-function ewoc &rest args
     This calls MAP-FUNCTION for each data element in EWOC and updates
     those nodes for which MAP-FUNCTION returns non-'nil'.  Any ARGS are
     passed to MAP-FUNCTION.

==============================================================================
File: elisp.info,  Node: |Abstract_Display_Example|,  Prev: |Abstract_Display_Functions|,  Up: |Abstract_Display|
==============================================================================

                                                      *Abstract_Display_Example*

39.20.2 Abstract Display Example
--------------------------------

Here is a simple example using functions of the ewoc package to
implement a "color components" display, an area in a buffer that
represents a vector of three integers (itself representing a 24-bit RGB
value) in various ways.

     (setq colorcomp-ewoc nil
           colorcomp-data nil
           colorcomp-mode-map nil
           colorcomp-labels ["Red" "Green" "Blue"])

     (defun colorcomp-pp (data)
       (if data
           (let ((comp (aref colorcomp-data data)))
             (insert (aref colorcomp-labels data) "\t: #x"
                     (format "%02X" comp) " "
                     (make-string (ash comp -2) ?#) "\n"))
         (let ((cstr (format "#%02X%02X%02X"
                             (aref colorcomp-data 0)
                             (aref colorcomp-data 1)
                             (aref colorcomp-data 2)))
               (samp " (sample text) "))
           (insert "Color\t: "
                   (propertize samp 'face
                               `(foreground-color . ,cstr))
                   (propertize samp 'face
                               `(background-color . ,cstr))
                   "\n"))))

     (defun colorcomp (color)
       "Allow fiddling with COLOR in a new buffer.
     The buffer is in Color Components mode."
       (interactive "sColor (name or #RGB or #RRGGBB): ")
       (when (string= "" color)
         (setq color "green"))
       (unless (color-values color)
         (error "No such color: %S" color))
       (switch-to-buffer
        (generate-new-buffer (format "originally: %s" color)))
       (kill-all-local-variables)
       (setq major-mode 'colorcomp-mode
             mode-name "Color Components")
       (use-local-map colorcomp-mode-map)
       (erase-buffer)
       (buffer-disable-undo)
       (let ((data (apply 'vector (mapcar (lambda (n) (ash n -8))
                                          (color-values color))))
             (ewoc (ewoc-create 'colorcomp-pp
                                "\nColor Components\n\n"
                                (substitute-command-keys
                                 "\n\\{colorcomp-mode-map}"))))
         (set (make-local-variable 'colorcomp-data) data)
         (set (make-local-variable 'colorcomp-ewoc) ewoc)
         (ewoc-enter-last ewoc 0)
         (ewoc-enter-last ewoc 1)
         (ewoc-enter-last ewoc 2)
         (ewoc-enter-last ewoc nil)))

   This example can be extended to be a color selection widget (in other
words, the "controller" part of the "model-view-controller" design
paradigm) by defining commands to modify 'colorcomp-data' and to finish
the selection process, and a keymap to tie it all together conveniently.

     (defun colorcomp-mod (index limit delta)
       (let ((cur (aref colorcomp-data index)))
         (unless (= limit cur)
           (aset colorcomp-data index (+ cur delta)))
         (ewoc-invalidate
          colorcomp-ewoc
          (ewoc-nth colorcomp-ewoc index)
          (ewoc-nth colorcomp-ewoc -1))))

     (defun colorcomp-R-more () (interactive) (colorcomp-mod 0 255 1))
     (defun colorcomp-G-more () (interactive) (colorcomp-mod 1 255 1))
     (defun colorcomp-B-more () (interactive) (colorcomp-mod 2 255 1))
     (defun colorcomp-R-less () (interactive) (colorcomp-mod 0 0 -1))
     (defun colorcomp-G-less () (interactive) (colorcomp-mod 1 0 -1))
     (defun colorcomp-B-less () (interactive) (colorcomp-mod 2 0 -1))

     (defun colorcomp-copy-as-kill-and-exit ()
       "Copy the color components into the kill ring and kill the buffer.
     The string is formatted #RRGGBB (hash followed by six hex digits)."
       (interactive)
       (kill-new (format "#%02X%02X%02X"
                         (aref colorcomp-data 0)
                         (aref colorcomp-data 1)
                         (aref colorcomp-data 2)))
       (kill-buffer nil))

     (setq colorcomp-mode-map
           (let ((m (make-sparse-keymap)))
             (suppress-keymap m)
             (define-key m "i" 'colorcomp-R-less)
             (define-key m "o" 'colorcomp-R-more)
             (define-key m "k" 'colorcomp-G-less)
             (define-key m "l" 'colorcomp-G-more)
             (define-key m "," 'colorcomp-B-less)
             (define-key m "." 'colorcomp-B-more)
             (define-key m " " 'colorcomp-copy-as-kill-and-exit)
             m))

   Note that we never modify the data in each node, which is fixed when
the ewoc is created to be either 'nil' or an index into the vector
'colorcomp-data', the actual color components.

==============================================================================
File: elisp.info,  Node: |Blinking|,  Next: |Character_Display|,  Prev: |Abstract_Display|,  Up: |Display|
==============================================================================

                                                                      *Blinking*

39.21 Blinking Parentheses
=====---------------------

This section describes the mechanism by which Emacs shows a matching
open parenthesis when the user inserts a close parenthesis.

 -- Variable: blink-paren-function
     The value of this variable should be a function (of no arguments)
     to be called whenever a character with close parenthesis syntax is
     inserted.  The value of 'blink-paren-function' may be 'nil', in
     which case nothing is done.

 -- User Option: blink-matching-paren
     If this variable is 'nil', then 'blink-matching-open' does nothing.

 -- User Option: blink-matching-paren-distance
     This variable specifies the maximum distance to scan for a matching
     parenthesis before giving up.

 -- User Option: blink-matching-delay
     This variable specifies the number of seconds to keep indicating
     the matching parenthesis.  A fraction of a second often gives good
     results, but the default is 1, which works on all systems.

 -- Command: blink-matching-open
     This function is the default value of 'blink-paren-function'.  It
     assumes that point follows a character with close parenthesis
     syntax and applies the appropriate effect momentarily to the
     matching opening character.  If that character is not already on
     the screen, it displays the character's context in the echo area.
     To avoid long delays, this function does not search farther than
     'blink-matching-paren-distance' characters.

     Here is an example of calling this function explicitly.

          (defun interactive-blink-matching-open ()
            "Indicate momentarily the start of parenthesized sexp before point."
            (interactive)
            (let ((blink-matching-paren-distance
                   (buffer-size))
                  (blink-matching-paren t))
              (blink-matching-open)))

==============================================================================
File: elisp.info,  Node: |Character_Display|,  Next: |Beeping|,  Prev: |Blinking|,  Up: |Display|
==============================================================================

                                                             *Character_Display*

39.22 Character Display
=====------------------

This section describes how characters are actually displayed by Emacs.
Typically, a character is displayed as a "glyph" (a graphical symbol
which occupies one character position on the screen), whose appearance
corresponds to the character itself.  For example, the character 'a'
(character code 97) is displayed as 'a'.  Some characters, however, are
displayed specially.  For example, the formfeed character (character
code 12) is usually displayed as a sequence of two glyphs, '^L', while
the newline character (character code 10) starts a new screen line.

   You can modify how each character is displayed by defining a "display
table", which maps each character code into a sequence of glyphs.  *Note
Display Tables::.

MENU

* |Usual_Display|::       The usual conventions for displaying characters.
* |Display_Tables|::      What a display table consists of.
* |Active_Display_Table|::  How Emacs selects a display table to use.
* |Glyphs|::              How to define a glyph, and what glyphs mean.
* |Glyphless_Chars|::     How glyphless characters are drawn.

==============================================================================
File: elisp.info,  Node: |Usual_Display|,  Next: |Display_Tables|,  Up: |Character_Display|
==============================================================================

                                                                 *Usual_Display*

39.22.1 Usual Display Conventions
---------------------------------

Here are the conventions for displaying each character code (in the
absence of a display table, which can override these conventions; *note
Display Tables::).

   * The "printable ASCII characters", character codes 32 through 126
     (consisting of numerals, English letters, and symbols like '#') are
     displayed literally.

   * The tab character (character code 9) displays as whitespace
     stretching up to the next tab stop column.  *Note (emacs)Text
     Display::.  The variable 'tab-width' controls the number of spaces
     per tab stop (see below).

   * The newline character (character code 10) has a special effect: it
     ends the preceding line and starts a new line.

   * The non-printable "ASCII control characters"--character codes 0
     through 31, as well as the <DEL> character (character code
     127)--display in one of two ways according to the variable
     'ctl-arrow'.  If this variable is non-'nil' (the default), these
     characters are displayed as sequences of two glyphs, where the
     first glyph is '^' (a display table can specify a glyph to use
     instead of '^'); e.g., the <DEL> character is displayed as '^?'.

     If 'ctl-arrow' is 'nil', these characters are displayed as octal
     escapes (see below).

     This rule also applies to carriage return (character code 13), if
     that character appears in the buffer.  But carriage returns usually
     do not appear in buffer text; they are eliminated as part of
     end-of-line conversion (*note Coding System Basics::).

   * "Raw bytes" are non-ASCII characters with codes 128 through 255
     (*note Text Representations::).  These characters display as "octal
     escapes": sequences of four glyphs, where the first glyph is the
     ASCII code for '\', and the others are digit characters
     representing the character code in octal.  (A display table can
     specify a glyph to use instead of '\'.)

   * Each non-ASCII character with code above 255 is displayed
     literally, if the terminal supports it.  If the terminal does not
     support it, the character is said to be "glyphless", and it is
     usually displayed using a placeholder glyph.  For example, if a
     graphical terminal has no font for a character, Emacs usually
     displays a box containing the character code in hexadecimal.  *Note
     Glyphless Chars::.

   The above display conventions apply even when there is a display
table, for any character whose entry in the active display table is
'nil'.  Thus, when you set up a display table, you need only specify the
characters for which you want special behavior.

   The following variables affect how certain characters are displayed
on the screen.  Since they change the number of columns the characters
occupy, they also affect the indentation functions.  They also affect
how the mode line is displayed; if you want to force redisplay of the
mode line using the new values, call the function
'force-mode-line-update' (*note Mode Line Format::).

 -- User Option: ctl-arrow
     This buffer-local variable controls how control characters are
     displayed.  If it is non-'nil', they are displayed as a caret
     followed by the character: '^A'.  If it is 'nil', they are
     displayed as octal escapes: a backslash followed by three octal
     digits, as in '\001'.

 -- User Option: tab-width
     The value of this buffer-local variable is the spacing between tab
     stops used for displaying tab characters in Emacs buffers.  The
     value is in units of columns, and the default is 8.  Note that this
     feature is completely independent of the user-settable tab stops
     used by the command 'tab-to-tab-stop'.  *Note Indent Tabs::.

==============================================================================
File: elisp.info,  Node: |Display_Tables|,  Next: |Active_Display_Table|,  Prev: |Usual_Display|,  Up: |Character_Display|
==============================================================================

                                                                *Display_Tables*

39.22.2 Display Tables
----------------------

A display table is a special-purpose char-table (*note Char-Tables::),
with 'display-table' as its subtype, which is used to override the usual
character display conventions.  This section describes how to make,
inspect, and assign elements to a display table object.

 -- Function: make-display-table
     This creates and returns a display table.  The table initially has
     'nil' in all elements.

   The ordinary elements of the display table are indexed by character
codes; the element at index C says how to display the character code C.
The value should be 'nil' (which means to display the character C
according to the usual display conventions; *note Usual Display::), or a
vector of glyph codes (which means to display the character C as those
glyphs; *note Glyphs::).

   Warning: if you use the display table to change the display of
newline characters, the whole buffer will be displayed as one long line.

   The display table also has six "extra slots" which serve special
purposes.  Here is a table of their meanings; 'nil' in any slot means to
use the default for that slot, as stated below.

0
     The glyph for the end of a truncated screen line (the default for
     this is '$').  *Note Glyphs::.  On graphical terminals, Emacs by
     default uses arrows in the fringes to indicate truncation, so the
     display table has no effect, unless you disable the fringes (*note
     Window Fringes: (emacs)Fringes.).

1
     The glyph for the end of a continued line (the default is '\').  On
     graphical terminals, Emacs by default uses curved arrows in the
     fringes to indicate continuation, so the display table has no
     effect, unless you disable the fringes.

2
     The glyph for indicating a character displayed as an octal
     character code (the default is '\').

3
     The glyph for indicating a control character (the default is '^').

4
     A vector of glyphs for indicating the presence of invisible lines
     (the default is '...').  *Note Selective Display::.

5
     The glyph used to draw the border between side-by-side windows (the
     default is '|').  *Note Splitting Windows::.  This currently has
     effect only on text terminals; on graphical terminals, if vertical
     scroll bars are supported and in use, a scroll bar separates the
     two windows, and if there are no vertical scroll bars and no
     dividers (*note Window Dividers::), Emacs uses a thin line to
     indicate the border.

   For example, here is how to construct a display table that mimics the
effect of setting 'ctl-arrow' to a non-'nil' value (*note Glyphs::, for
the function 'make-glyph-code'):

     (setq disptab (make-display-table))
     (dotimes (i 32)
       (or (= i ?\t)
           (= i ?\n)
           (aset disptab i
                 (vector (make-glyph-code ?^ 'escape-glyph)
                         (make-glyph-code (+ i 64) 'escape-glyph)))))
     (aset disptab 127
           (vector (make-glyph-code ?^ 'escape-glyph)
                   (make-glyph-code ?? 'escape-glyph)))))

 -- Function: display-table-slot display-table slot
     This function returns the value of the extra slot SLOT of
     DISPLAY-TABLE.  The argument SLOT may be a number from 0 to 5
     inclusive, or a slot name (symbol).  Valid symbols are
     'truncation', 'wrap', 'escape', 'control', 'selective-display', and
     'vertical-border'.

 -- Function: set-display-table-slot display-table slot value
     This function stores VALUE in the extra slot SLOT of DISPLAY-TABLE.
     The argument SLOT may be a number from 0 to 5 inclusive, or a slot
     name (symbol).  Valid symbols are 'truncation', 'wrap', 'escape',
     'control', 'selective-display', and 'vertical-border'.

 -- Function: describe-display-table display-table
     This function displays a description of the display table
     DISPLAY-TABLE in a help buffer.

 -- Command: describe-current-display-table
     This command displays a description of the current display table in
     a help buffer.

==============================================================================
File: elisp.info,  Node: |Active_Display_Table|,  Next: |Glyphs|,  Prev: |Display_Tables|,  Up: |Character_Display|
==============================================================================

                                                          *Active_Display_Table*

39.22.3 Active Display Table
----------------------------

Each window can specify a display table, and so can each buffer.  The
window's display table, if there is one, takes precedence over the
buffer's display table.  If neither exists, Emacs tries to use the
standard display table; if that is 'nil', Emacs uses the usual character
display conventions (*note Usual Display::).

   Note that display tables affect how the mode line is displayed, so if
you want to force redisplay of the mode line using a new display table,
call 'force-mode-line-update' (*note Mode Line Format::).

 -- Function: window-display-table &optional window
     This function returns WINDOW's display table, or 'nil' if there is
     none.  The default for WINDOW is the selected window.

 -- Function: set-window-display-table window table
     This function sets the display table of WINDOW to TABLE.  The
     argument TABLE should be either a display table or 'nil'.

 -- Variable: buffer-display-table
     This variable is automatically buffer-local in all buffers; its
     value specifies the buffer's display table.  If it is 'nil', there
     is no buffer display table.

 -- Variable: standard-display-table
     The value of this variable is the standard display table, which is
     used when Emacs is displaying a buffer in a window with neither a
     window display table nor a buffer display table defined, or when
     Emacs is outputting text to the standard output or error streams.
     Although its default is typically 'nil', in an interactive session
     if the terminal cannot display curved quotes, its default maps
     curved quotes to ASCII approximations.  *Note Text Quoting Style::.

   The 'disp-table' library defines several functions for changing the
standard display table.

==============================================================================
File: elisp.info,  Node: |Glyphs|,  Next: |Glyphless_Chars|,  Prev: |Active_Display_Table|,  Up: |Character_Display|
==============================================================================

                                                                        *Glyphs*

39.22.4 Glyphs
--------------

A "glyph" is a graphical symbol which occupies a single character
position on the screen.  Each glyph is represented in Lisp as a "glyph
code", which specifies a character and optionally a face to display it
in (*note Faces::).  The main use of glyph codes is as the entries of
display tables (*note Display Tables::).  The following functions are
used to manipulate glyph codes:

 -- Function: make-glyph-code char &optional face
     This function returns a glyph code representing char CHAR with face
     FACE.  If FACE is omitted or 'nil', the glyph uses the default
     face; in that case, the glyph code is an integer.  If FACE is
     non-'nil', the glyph code is not necessarily an integer object.

 -- Function: glyph-char glyph
     This function returns the character of glyph code GLYPH.

 -- Function: glyph-face glyph
     This function returns face of glyph code GLYPH, or 'nil' if GLYPH
     uses the default face.

   You can set up a "glyph table" to change how glyph codes are actually
displayed on text terminals.  This feature is semi-obsolete; use
'glyphless-char-display' instead (*note Glyphless Chars::).

 -- Variable: glyph-table
     The value of this variable, if non-'nil', is the current glyph
     table.  It takes effect only on character terminals; on graphical
     displays, all glyphs are displayed literally.  The glyph table
     should be a vector whose Gth element specifies how to display glyph
     code G, where G is the glyph code for a glyph whose face is
     unspecified.  Each element should be one of the following:

     'nil'
          Display this glyph literally.

     a string
          Display this glyph by sending the specified string to the
          terminal.

     a glyph code
          Display the specified glyph code instead.

     Any integer glyph code greater than or equal to the length of the
     glyph table is displayed literally.

==============================================================================
File: elisp.info,  Node: |Glyphless_Chars|,  Prev: |Glyphs|,  Up: |Character_Display|
==============================================================================

                                                               *Glyphless_Chars*

39.22.5 Glyphless Character Display
-----------------------------------

"Glyphless characters" are characters which are displayed in a special
way, e.g., as a box containing a hexadecimal code, instead of being
displayed literally.  These include characters which are explicitly
defined to be glyphless, as well as characters for which there is no
available font (on a graphical display), and characters which cannot be
encoded by the terminal's coding system (on a text terminal).

 -- Variable: glyphless-char-display
     The value of this variable is a char-table which defines glyphless
     characters and how they are displayed.  Each entry must be one of
     the following display methods:

     'nil'
          Display the character in the usual way.

     'zero-width'
          Don't display the character.

     'thin-space'
          Display a thin space, 1-pixel wide on graphical displays, or
          1-character wide on text terminals.

     'empty-box'
          Display an empty box.

     'hex-code'
          Display a box containing the Unicode codepoint of the
          character, in hexadecimal notation.

     an ASCII string
          Display a box containing that string.  The string should
          contain at most 6 ASCII characters.

     a cons cell '(GRAPHICAL . TEXT)'
          Display with GRAPHICAL on graphical displays, and with TEXT on
          text terminals.  Both GRAPHICAL and TEXT must be one of the
          display methods described above.

     The 'thin-space', 'empty-box', 'hex-code', and ASCII string display
     methods are drawn with the 'glyphless-char' face.  On text
     terminals, a box is emulated by square brackets, '[]'.

     The char-table has one extra slot, which determines how to display
     any character that cannot be displayed with any available font, or
     cannot be encoded by the terminal's coding system.  Its value
     should be one of the above display methods, except 'zero-width' or
     a cons cell.

     If a character has a non-'nil' entry in an active display table,
     the display table takes effect; in this case, Emacs does not
     consult 'glyphless-char-display' at all.

 -- User Option: glyphless-char-display-control
     This user option provides a convenient way to set
     'glyphless-char-display' for groups of similar characters.  Do not
     set its value directly from Lisp code; the value takes effect only
     via a custom ':set' function (*note Variable Definitions::), which
     updates 'glyphless-char-display'.

     Its value should be an alist of elements '(GROUP . METHOD)', where
     GROUP is a symbol specifying a group of characters, and METHOD is a
     symbol specifying how to display them.

     GROUP should be one of the following:

     'c0-control'
          ASCII control characters 'U+0000' to 'U+001F', excluding the
          newline and tab characters (normally displayed as escape
          sequences like '^A'; *note How Text Is Displayed: (emacs)Text
          Display.).

     'c1-control'
          Non-ASCII, non-printing characters 'U+0080' to 'U+009F'
          (normally displayed as octal escape sequences like '\230').

     'format-control'
          Characters of Unicode General Category [Cf], such as U+200E
          LEFT-TO-RIGHT MARK, but excluding characters that have graphic
          images, such as U+00AD SOFT HYPHEN.

     'no-font'
          Characters for which there is no suitable font, or which
          cannot be encoded by the terminal's coding system.

     The METHOD symbol should be one of 'zero-width', 'thin-space',
     'empty-box', or 'hex-code'.  These have the same meanings as in
     'glyphless-char-display', above.

==============================================================================
File: elisp.info,  Node: |Beeping|,  Next: |Window_Systems|,  Prev: |Character_Display|,  Up: |Display|
==============================================================================

                                                                       *Beeping*

39.23 Beeping
=====--------

This section describes how to make Emacs ring the bell (or blink the
screen) to attract the user's attention.  Be conservative about how
often you do this; frequent bells can become irritating.  Also be
careful not to use just beeping when signaling an error is more
appropriate (*note Errors::).

 -- Function: ding &optional do-not-terminate
     This function beeps, or flashes the screen (see 'visible-bell'
     below).  It also terminates any keyboard macro currently executing
     unless DO-NOT-TERMINATE is non-'nil'.

 -- Function: beep &optional do-not-terminate
     This is a synonym for 'ding'.

 -- User Option: visible-bell
     This variable determines whether Emacs should flash the screen to
     represent a bell.  Non-'nil' means yes, 'nil' means no.  This is
     effective on graphical displays, and on text terminals provided the
     terminal's Termcap entry defines the visible bell capability
     ('vb').

 -- User Option: ring-bell-function
     If this is non-'nil', it specifies how Emacs should ring the bell.
     Its value should be a function of no arguments.  If this is
     non-'nil', it takes precedence over the 'visible-bell' variable.

==============================================================================
File: elisp.info,  Node: |Window_Systems|,  Next: |Tooltips|,  Prev: |Beeping|,  Up: |Display|
==============================================================================

                                                                *Window_Systems*

39.24 Window Systems
=====---------------

Emacs works with several window systems, most notably the X Window
System.  Both Emacs and X use the term "window", but use it differently.
An Emacs frame is a single window as far as X is concerned; the
individual Emacs windows are not known to X at all.

 -- Variable: window-system
     This terminal-local variable tells Lisp programs what window system
     Emacs is using for displaying the frame.  The possible values are

     'x'
          Emacs is displaying the frame using X.
     'w32'
          Emacs is displaying the frame using native MS-Windows GUI.
     'ns'
          Emacs is displaying the frame using the Nextstep interface
          (used on GNUstep and macOS).
     'pc'
          Emacs is displaying the frame using MS-DOS direct screen
          writes.
     'nil'
          Emacs is displaying the frame on a character-based terminal.

 -- Variable: initial-window-system
     This variable holds the value of 'window-system' used for the first
     frame created by Emacs during startup.  (When Emacs is invoked as a
     daemon, it does not create any initial frames, so
     'initial-window-system' is 'nil', except on MS-Windows, where it is
     still 'w32'.  *Note daemon: (emacs)Initial Options.)

 -- Function: window-system &optional frame
     This function returns a symbol whose name tells what window system
     is used for displaying FRAME (which defaults to the currently
     selected frame).  The list of possible symbols it returns is the
     same one documented for the variable 'window-system' above.

   Do _not_ use 'window-system' and 'initial-window-system' as
predicates or boolean flag variables, if you want to write code that
works differently on text terminals and graphic displays.  That is
because 'window-system' is not a good indicator of Emacs capabilities on
a given display type.  Instead, use 'display-graphic-p' or any of the
other 'display-*-p' predicates described in *note Display Feature
Testing::.

==============================================================================
File: elisp.info,  Node: |Tooltips|,  Next: |Bidirectional_Display|,  Prev: |Window_Systems|,  Up: |Display|
==============================================================================

                                                                      *Tooltips*

39.25 Tooltips
=====---------

"Tooltips" are special frames (*note Frames::) that are used to display
helpful hints (a.k.a. "tips") related to the current position of the
mouse pointer.  Emacs uses tooltips to display help strings about active
portions of text (*note Special Properties::) and about various UI
elements, such as menu items (*note Extended Menu Items::) and tool-bar
buttons (*note Tool Bar::).

 -- Function: tooltip-mode
     Tooltip Mode is a minor mode that enables display of tooltips.
     Turning off this mode causes the tooltips be displayed in the echo
     area.  On text-mode (a.k.a. "TTY") frames, tooltips are always
     displayed in the echo area.

   When Emacs is built with GTK+ support, it by default displays
tooltips using GTK+ functions, and the appearance of the tooltips is
then controlled by GTK+ settings.  GTK+ tooltips can be disabled by
changing the value of the variable 'x-gtk-use-system-tooltips' to 'nil'.
The rest of this subsection describes how to control non-GTK+ tooltips,
which are presented by Emacs itself.

   Tooltips are displayed in special frames called tooltip frames, which
have their own frame parameters (*note Frame Parameters::).  Unlike
other frames, the default parameters for tooltip frames are stored in a
special variable.

 -- User Option: tooltip-frame-parameters
     This customizable option holds the default frame parameters used
     for displaying tooltips.  Any font and color parameters are
     ignored, and the corresponding attributes of the 'tooltip' face are
     used instead.  If 'left' or 'top' parameters are included, they are
     used as absolute frame-relative coordinates where the tooltip
     should be shown.  (Mouse-relative position of the tooltip can be
     customized using the variables described in *note
     (emacs)Tooltips::.)  Note that the 'left' and 'top' parameters, if
     present, override the values of mouse-relative offsets.

   The 'tooltip' face determines the appearance of text shown in
tooltips.  It should generally use a variable-pitch font of size that is
preferably smaller than the default frame font.

 -- Variable: tooltip-functions
     This abnormal hook is a list of functions to call when Emacs needs
     to display a tooltip.  Each function is called with a single
     argument EVENT which is a copy of the last mouse movement event.
     If a function on this list actually displays the tooltip, it should
     return non-'nil', and then the rest of the functions will not be
     called.  The default value of this variable is a single function
     'tooltip-help-tips'.

   If you write your own function to be put on the 'tooltip-functions'
list, you may need to know the buffer of the mouse event that triggered
the tooltip display.  The following function provides that information.

 -- Function: tooltip-event-buffer event
     This function returns the buffer over which EVENT occurred.  Call
     it with the argument of the function from 'tooltip-functions' to
     obtain the buffer whose text triggered the tooltip.  Note that the
     event might occur not over a buffer (e.g., over the tool bar), in
     which case this function will return 'nil'.

   Other aspects of tooltip display are controlled by several
customizable settings; see *note (emacs)Tooltips::.

==============================================================================
File: elisp.info,  Node: |Bidirectional_Display|,  Prev: |Tooltips|,  Up: |Display|
==============================================================================

                                                         *Bidirectional_Display*

39.26 Bidirectional Display
=====----------------------

Emacs can display text written in scripts, such as Arabic, Farsi, and
Hebrew, whose natural ordering for horizontal text display runs from
right to left.  Furthermore, segments of Latin script and digits
embedded in right-to-left text are displayed left-to-right, while
segments of right-to-left script embedded in left-to-right text (e.g.,
Arabic or Hebrew text in comments or strings in a program source file)
are appropriately displayed right-to-left.  We call such mixtures of
left-to-right and right-to-left text "bidirectional text".  This section
describes the facilities and options for editing and displaying
bidirectional text.

   Text is stored in Emacs buffers and strings in "logical" (or
"reading") order, i.e., the order in which a human would read each
character.  In right-to-left and bidirectional text, the order in which
characters are displayed on the screen (called "visual order") is not
the same as logical order; the characters' screen positions do not
increase monotonically with string or buffer position.  In performing
this "bidirectional reordering", Emacs follows the Unicode Bidirectional
Algorithm (a.k.a. UBA), which is described in Annex #9 of the Unicode
standard (<http://www.unicode.org/reports/tr9/>).  Emacs provides a
"Full Bidirectionality" class implementation of the UBA, consistent with
the requirements of the Unicode Standard v9.0.  Note, however, that the
way Emacs displays continuation lines when text direction is opposite to
the base paragraph direction deviates from the UBA, which requires to
perform line wrapping before reordering text for display.

 -- Variable: bidi-display-reordering
     If the value of this buffer-local variable is non-'nil' (the
     default), Emacs performs bidirectional reordering for display.  The
     reordering affects buffer text, as well as display strings and
     overlay strings from text and overlay properties in the buffer
     (*note Overlay Properties::, and *note Display Property::).  If the
     value is 'nil', Emacs does not perform bidirectional reordering in
     the buffer.

     The default value of 'bidi-display-reordering' controls the
     reordering of strings which are not directly supplied by a buffer,
     including the text displayed in mode lines (*note Mode Line
     Format::) and header lines (*note Header Lines::).

   Emacs never reorders the text of a unibyte buffer, even if
'bidi-display-reordering' is non-'nil' in the buffer.  This is because
unibyte buffers contain raw bytes, not characters, and thus lack the
directionality properties required for reordering.  Therefore, to test
whether text in a buffer will be reordered for display, it is not enough
to test the value of 'bidi-display-reordering' alone.  The correct test
is this:

      (if (and enable-multibyte-characters
               bidi-display-reordering)
          ;; Buffer is being reordered for display
        )

   However, unibyte display and overlay strings _are_ reordered if their
parent buffer is reordered.  This is because plain-ASCII strings are
stored by Emacs as unibyte strings.  If a unibyte display or overlay
string includes non-ASCII characters, these characters are assumed to
have left-to-right direction.

   Text covered by 'display' text properties, by overlays with 'display'
properties whose value is a string, and by any other properties that
replace buffer text, is treated as a single unit when it is reordered
for display.  That is, the entire chunk of text covered by these
properties is reordered together.  Moreover, the bidirectional
properties of the characters in such a chunk of text are ignored, and
Emacs reorders them as if they were replaced with a single character
'U+FFFC', known as the "Object Replacement Character".  This means that
placing a display property over a portion of text may change the way
that the surrounding text is reordered for display.  To prevent this
unexpected effect, always place such properties on text whose
directionality is identical with text that surrounds it.

   Each paragraph of bidirectional text has a "base direction", either
right-to-left or left-to-right.  Left-to-right paragraphs are displayed
beginning at the left margin of the window, and are truncated or
continued when the text reaches the right margin.  Right-to-left
paragraphs are displayed beginning at the right margin, and are
continued or truncated at the left margin.

   Where exactly paragraphs start and end, for the purpose of the Emacs
UBA implementation, is determined by the following two buffer-local
variables (note that 'paragraph-start' and 'paragraph-separate' have no
influence on this).  By default both of these variables are 'nil', and
paragraphs are bounded by empty lines, i.e., lines that consist entirely
of zero or more whitespace characters followed by a newline.

 -- Variable: bidi-paragraph-start-re
     If non-'nil', this variable's value should be a regular expression
     matching a line that starts or separates two paragraphs.  The
     regular expression is always matched after a newline, so it is best
     to anchor it, i.e., begin it with a '"^"'.

 -- Variable: bidi-paragraph-separate-re
     If non-'nil', this variable's value should be a regular expression
     matching a line separates two paragraphs.  The regular expression
     is always matched after a newline, so it is best to anchor it,
     i.e., begin it with a '"^"'.

   If you modify any of these two variables, you should normally modify
both, to make sure they describe paragraphs consistently.  For example,
to have each new line start a new paragraph for bidi-reordering
purposes, set both variables to '"^"'.

   By default, Emacs determines the base direction of each paragraph by
looking at the text at its beginning.  The precise method of determining
the base direction is specified by the UBA; in a nutshell, the first
character in a paragraph that has an explicit directionality determines
the base direction of the paragraph.  However, sometimes a buffer may
need to force a certain base direction for its paragraphs.  For example,
buffers containing program source code should force all paragraphs to be
displayed left-to-right.  You can use following variable to do this:

 -- User Option: bidi-paragraph-direction
     If the value of this buffer-local variable is the symbol
     'right-to-left' or 'left-to-right', all paragraphs in the buffer
     are assumed to have that specified direction.  Any other value is
     equivalent to 'nil' (the default), which means to determine the
     base direction of each paragraph from its contents.

     Modes for program source code should set this to 'left-to-right'.
     Prog mode does this by default, so modes derived from Prog mode do
     not need to set this explicitly (*note Basic Major Modes::).

 -- Function: current-bidi-paragraph-direction &optional buffer
     This function returns the paragraph direction at point in the named
     BUFFER.  The returned value is a symbol, either 'left-to-right' or
     'right-to-left'.  If BUFFER is omitted or 'nil', it defaults to the
     current buffer.  If the buffer-local value of the variable
     'bidi-paragraph-direction' is non-'nil', the returned value will be
     identical to that value; otherwise, the returned value reflects the
     paragraph direction determined dynamically by Emacs.  For buffers
     whose value of 'bidi-display-reordering' is 'nil' as well as
     unibyte buffers, this function always returns 'left-to-right'.

   Sometimes there's a need to move point in strict visual order, either
to the left or to the right of its current screen position.  Emacs
provides a primitive to do that.

 -- Function: move-point-visually direction
     This function moves point of the currently selected window to the
     buffer position that appears immediately to the right or to the
     left of point on the screen.  If DIRECTION is positive, point will
     move one screen position to the right, otherwise it will move one
     screen position to the left.  Note that, depending on the
     surrounding bidirectional context, this could potentially move
     point many buffer positions away.  If invoked at the end of a
     screen line, the function moves point to the rightmost or leftmost
     screen position of the next or previous screen line, as appropriate
     for the value of DIRECTION.

     The function returns the new buffer position as its value.

   Bidirectional reordering can have surprising and unpleasant effects
when two strings with bidirectional content are juxtaposed in a buffer,
or otherwise programmatically concatenated into a string of text.  A
typical problematic case is when a buffer consists of sequences of text
fields separated by whitespace or punctuation characters, like Buffer
Menu mode or Rmail Summary Mode.  Because the punctuation characters
used as separators have "weak directionality", they take on the
directionality of surrounding text.  As result, a numeric field that
follows a field with bidirectional content can be displayed _to the
left_ of the preceding field, messing up the expected layout.  There are
several ways to avoid this problem:

   - Append the special character U+200E LEFT-TO-RIGHT MARK, or LRM, to
     the end of each field that may have bidirectional content, or
     prepend it to the beginning of the following field.  The function
     'bidi-string-mark-left-to-right', described below, comes in handy
     for this purpose.  (In a right-to-left paragraph, use U+200F
     RIGHT-TO-LEFT MARK, or RLM, instead.)  This is one of the solutions
     recommended by the UBA.

   - Include the tab character in the field separator.  The tab
     character plays the role of "segment separator" in bidirectional
     reordering, causing the text on either side to be reordered
     separately.

   - Separate fields with a 'display' property or overlay with a
     property value of the form '(space . PROPS)' (*note Specified
     Space::).  Emacs treats this display specification as a "paragraph
     separator", and reorders the text on either side separately.

 -- Function: bidi-string-mark-left-to-right string
     This function returns its argument STRING, possibly modified, such
     that the result can be safely concatenated with another string, or
     juxtaposed with another string in a buffer, without disrupting the
     relative layout of this string and the next one on display.  If the
     string returned by this function is displayed as part of a
     left-to-right paragraph, it will always appear on display to the
     left of the text that follows it.  The function works by examining
     the characters of its argument, and if any of those characters
     could cause reordering on display, the function appends the LRM
     character to the string.  The appended LRM character is made
     invisible by giving it an 'invisible' text property of 't' (*note
     Invisible Text::).

   The reordering algorithm uses the bidirectional properties of the
characters stored as their 'bidi-class' property (*note Character
Properties::).  Lisp programs can change these properties by calling the
'put-char-code-property' function.  However, doing this requires a
thorough understanding of the UBA, and is therefore not recommended.
Any changes to the bidirectional properties of a character have global
effect: they affect all Emacs frames and windows.

   Similarly, the 'mirroring' property is used to display the
appropriate mirrored character in the reordered text.  Lisp programs can
affect the mirrored display by changing this property.  Again, any such
changes affect all of Emacs display.

   The bidirectional properties of characters can be overridden by
inserting into the text special directional control characters,
LEFT-TO-RIGHT OVERRIDE (LRO) and RIGHT-TO-LEFT OVERRIDE (RLO).  Any
characters between a RLO and the following newline or POP DIRECTIONAL
FORMATTING (PDF) control character, whichever comes first, will be
displayed as if they were strong right-to-left characters, i.e. they
will be reversed on display.  Similarly, any characters between LRO and
PDF or newline will display as if they were strong left-to-right, and
will _not_ be reversed even if they are strong right-to-left characters.

   These overrides are useful when you want to make some text unaffected
by the reordering algorithm, and instead directly control the display
order.  But they can also be used for malicious purposes, known as
"phishing".  Specifically, a URL on a Web page or a link in an email
message can be manipulated to make its visual appearance unrecognizable,
or similar to some popular benign location, while the real location,
interpreted by a browser in the logical order, is very different.

   Emacs provides a primitive that applications can use to detect
instances of text whose bidirectional properties were overridden so as
to make a left-to-right character display as if it were a right-to-left
character, or vise versa.

 -- Function: bidi-find-overridden-directionality from to &optional
          object
     This function looks at the text of the specified OBJECT between
     positions FROM (inclusive) and TO (exclusive), and returns the
     first position where it finds a strong left-to-right character
     whose directional properties were forced to display the character
     as right-to-left, or for a strong right-to-left character that was
     forced to display as left-to-right.  If it finds no such characters
     in the specified region of text, it returns 'nil'.

     The optional argument OBJECT specifies which text to search, and
     defaults to the current buffer.  If OBJECT is non-'nil', it can be
     some other buffer, or it can be a string or a window.  If it is a
     string, the function searches that string.  If it is a window, the
     function searches the buffer displayed in that window.  If a buffer
     whose text you want to examine is displayed in some window, we
     recommend to specify it by that window, rather than pass the buffer
     to the function.  This is because telling the function about the
     window allows it to correctly account for window-specific overlays,
     which might change the result of the function if some text in the
     buffer is covered by overlays.

   When text that includes mixed right-to-left and left-to-right
characters and bidirectional controls is copied into a different
location, it can change its visual appearance, and also can affect the
visual appearance of the surrounding text at destination.  This is
because reordering of bidirectional text specified by the UBA has
non-trivial context-dependent effects both on the copied text and on the
text at copy destination that will surround it.

   Sometimes, a Lisp program may need to preserve the exact visual
appearance of the copied text at destination, and of the text that
surrounds the copy.  Lisp programs can use the following function to
achieve that effect.

 -- Function: buffer-substring-with-bidi-context start end &optional
          no-properties
     This function works similar to 'buffer-substring' (*note Buffer
     Contents::), but it prepends and appends to the copied text bidi
     directional control characters necessary to preserve the visual
     appearance of the text when it is inserted at another place.
     Optional argument NO-PROPERTIES, if non-'nil', means remove the
     text properties from the copy of the text.

==============================================================================
File: elisp.info,  Node: |System_Interface|,  Next: |Packaging|,  Prev: |Display|,  Up: |Top|
==============================================================================

                                                              *System_Interface*

40 Operating System Interface
*****========================

This chapter is about starting and getting out of Emacs, access to
values in the operating system environment, and terminal input, output.

   *Note Building Emacs::, for related information.  *Note Display::,
for additional operating system status information pertaining to the
terminal and the screen.

MENU

* |Starting_Up|::         Customizing Emacs startup processing.
* |Getting_Out|::         How exiting works (permanent or temporary).
* |System_Environment|::  Distinguish the name and kind of system.
* |User_Identification|:: Finding the name and user id of the user.
* |Time_of_Day|::         Getting the current time.
* |Time_Zone_Rules|::     Rules for time zones and daylight saving time.
* |Time_Conversion|::     Converting among timestamp forms.
* |Time_Parsing|::        Converting timestamps to text and vice versa.
* |Processor_Run_Time|::  Getting the run time used by Emacs.
* |Time_Calculations|::   Adding, subtracting, comparing times, etc.
* |Timers|::              Setting a timer to call a function at a certain time.
* |Idle_Timers|::         Setting a timer to call a function when Emacs has
                          been idle for a certain length of time.
* |Terminal_Input|::      Accessing and recording terminal input.
* |Terminal_Output|::     Controlling and recording terminal output.
* |Sound_Output|::        Playing sounds on the computer's speaker.
* |X11_Keysyms|::         Operating on key symbols for X Windows.
* |Batch_Mode|::          Running Emacs without terminal interaction.
* |Session_Management|::  Saving and restoring state with X Session Management.
* |Desktop_Notifications|:: Desktop notifications.
* |File_Notifications|::  File notifications.
* |Dynamic_Libraries|::   On-demand loading of support libraries.
* |Security_Considerations|:: Running Emacs in an unfriendly environment.

==============================================================================
File: elisp.info,  Node: |Starting_Up|,  Next: |Getting_Out|,  Up: |System_Interface|
==============================================================================

                                                                   *Starting_Up*

40.1 Starting Up Emacs
=====-----------------

This section describes what Emacs does when it is started, and how you
can customize these actions.

MENU

* |Startup_Summary|::         Sequence of actions Emacs performs at startup.
* |Init_File|::               Details on reading the init file.
* |Terminal_Specific|::       How the terminal-specific Lisp file is read.
* |Command_Line_Arguments|::  How command-line arguments are processed,
                              and how you can customize them.

==============================================================================
File: elisp.info,  Node: |Startup_Summary|,  Next: |Init_File|,  Up: Starting Up
==============================================================================

                                                               *Startup_Summary*

40.1.1 Summary: Sequence of Actions at Startup
----------------------------------------------

When Emacs is started up, it performs the following operations (see
'normal-top-level' in 'startup.el'):

  1. It adds subdirectories to 'load-path', by running the file named
     'subdirs.el' in each directory in the list.  Normally, this file
     adds the directory's subdirectories to the list, and those are
     scanned in their turn.  The files 'subdirs.el' are normally
     generated automatically when Emacs is installed.

  2. It loads any 'leim-list.el' that it finds in the 'load-path'
     directories.  This file is intended for registering input methods.
     The search is only for any personal 'leim-list.el' files that you
     may have created; it skips the directories containing the standard
     Emacs libraries (these should contain only a single 'leim-list.el'
     file, which is compiled into the Emacs executable).

  3. It sets the variable 'before-init-time' to the value of
     'current-time' (*note Time of Day::).  It also sets
     'after-init-time' to 'nil', which signals to Lisp programs that
     Emacs is being initialized.

  4. It sets the language environment and the terminal coding system, if
     requested by environment variables such as 'LANG'.

  5. It does some basic parsing of the command-line arguments.

  6. It loads your early init file (*note (emacs)Early Init File::).
     This is not done if the options '-q', '-Q', or '--batch' were
     specified.  If the '-u' option was specified, Emacs looks for the
     init file in that user's home directory instead.

  7. It calls the function 'package-activate-all' to activate any
     optional Emacs Lisp package that has been installed.  *Note
     Packaging Basics::.  However, Emacs doesn't activate the packages
     when 'package-enable-at-startup' is 'nil' or when it's started with
     one of the options '-q', '-Q', or '--batch'.  To activate the
     packages in the latter case, 'package-activate-all' should be
     called explicitly (e.g., via the '--funcall' option).

  8. If not running in batch mode, it initializes the window system that
     the variable 'initial-window-system' specifies (*note
     initial-window-system: Window Systems.).  The initialization
     function, 'window-system-initialization', is a "generic function"
     (*note Generic Functions::) whose actual implementation is
     different for each supported window system.  If the value of
     'initial-window-system' is WINDOWSYSTEM, then the appropriate
     implementation of the initialization function is defined in the
     file 'term/WINDOWSYSTEM-win.el'.  This file should have been
     compiled into the Emacs executable when it was built.

  9. It runs the normal hook 'before-init-hook'.

  10. If appropriate, it creates a graphical frame.  As part of creating
     the graphical frame, it initializes the window system specified by
     'initial-frame-alist' and 'default-frame-alist' (*note Initial
     Parameters::) for the graphical frame, by calling the
     'window-system-initialization' function for that window system.
     This is not done in batch (noninteractive) or daemon mode.

  11. It initializes the initial frame's faces, and sets up the menu bar
     and tool bar if needed.  If graphical frames are supported, it sets
     up the tool bar even if the current frame is not a graphical one,
     since a graphical frame may be created later on.

  12. It use 'custom-reevaluate-setting' to re-initialize the members of
     the list 'custom-delayed-init-variables'.  These are any pre-loaded
     user options whose default value depends on the run-time, rather
     than build-time, context.  *Note custom-initialize-delay: Building
     Emacs.

  13. It loads the library 'site-start', if it exists.  This is not done
     if the options '-Q' or '--no-site-file' were specified.

  14. It loads your init file (*note Init File::).  This is not done if
     the options '-q', '-Q', or '--batch' were specified.  If the '-u'
     option was specified, Emacs looks for the init file in that user's
     home directory instead.

  15. It loads the library 'default', if it exists.  This is not done if
     'inhibit-default-init' is non-'nil', nor if the options '-q', '-Q',
     or '--batch' were specified.

  16. It loads your abbrevs from the file specified by
     'abbrev-file-name', if that file exists and can be read (*note
     abbrev-file-name: Abbrev Files.).  This is not done if the option
     '--batch' was specified.

  17. It sets the variable 'after-init-time' to the value of
     'current-time'.  This variable was set to 'nil' earlier; setting it
     to the current time signals that the initialization phase is over,
     and, together with 'before-init-time', provides the measurement of
     how long it took.

  18. It runs the normal hook 'after-init-hook'.

  19. If the buffer 'scratch' exists and is still in Fundamental mode
     (as it should be by default), it sets its major mode according to
     'initial-major-mode'.

  20. If started on a text terminal, it loads the terminal-specific Lisp
     library (*note Terminal-Specific::), and runs the hook
     'tty-setup-hook'.  This is not done in '--batch' mode, nor if
     'term-file-prefix' is 'nil'.

  21. It displays the initial echo area message, unless you have
     suppressed that with 'inhibit-startup-echo-area-message'.

  22. It processes any command-line options that were not handled
     earlier.

  23. It now exits if the option '--batch' was specified.

  24. If the 'scratch' buffer exists and is empty, it inserts
     '(substitute-command-keys initial-scratch-message)' into that
     buffer.

  25. If 'initial-buffer-choice' is a string, it visits the file (or
     directory) with that name.  If it is a function, it calls the
     function with no arguments and selects the buffer that it returns.
     If one file is given as a command line argument, that file is
     visited and its buffer displayed alongside 'initial-buffer-choice'.
     If more than one file is given, all of the files are visited and
     the '*Buffer List*' buffer is displayed alongside
     'initial-buffer-choice'.

  26. It runs 'emacs-startup-hook'.

  27. It calls 'frame-notice-user-settings', which modifies the
     parameters of the selected frame according to whatever the init
     files specify.

  28. It runs 'window-setup-hook'.  The only difference between this
     hook and 'emacs-startup-hook' is that this one runs after the
     previously mentioned modifications to the frame parameters.

  29. It displays the "startup screen", which is a special buffer that
     contains information about copyleft and basic Emacs usage.  This is
     not done if 'inhibit-startup-screen' or 'initial-buffer-choice' are
     non-'nil', or if the '--no-splash' or '-Q' command-line options
     were specified.

  30. If a daemon was requested, it calls 'server-start'.  (On POSIX
     systems, if a background daemon was requested, it then detaches
     from the controlling terminal.)  *Note (emacs)Emacs Server::.

  31. If started by the X session manager, it calls
     'emacs-session-restore' passing it as argument the ID of the
     previous session.  *Note Session Management::.

The following options affect some aspects of the startup sequence.

 -- User Option: inhibit-startup-screen
     This variable, if non-'nil', inhibits the startup screen.  In that
     case, Emacs typically displays the 'scratch' buffer; but see
     'initial-buffer-choice', below.

     Do not set this variable in the init file of a new user, or in a
     way that affects more than one user, as that would prevent new
     users from receiving information about copyleft and basic Emacs
     usage.

     'inhibit-startup-message' and 'inhibit-splash-screen' are aliases
     for this variable.

 -- User Option: initial-buffer-choice
     If non-'nil', this variable is a string that specifies a file or
     directory for Emacs to display after starting up, instead of the
     startup screen.  If its value is a function, Emacs calls that
     function which must return a buffer which is then displayed.  If
     its value is 't', Emacs displays the 'scratch' buffer.

 -- User Option: inhibit-startup-echo-area-message
     This variable controls the display of the startup echo area
     message.  You can suppress the startup echo area message by adding
     text with this form to your init file:

          (setq inhibit-startup-echo-area-message
                "YOUR-LOGIN-NAME")

     Emacs explicitly checks for an expression as shown above in your
     init file; your login name must appear in the expression as a Lisp
     string constant.  You can also use the Customize interface.  Other
     methods of setting 'inhibit-startup-echo-area-message' to the same
     value do not inhibit the startup message.  This way, you can easily
     inhibit the message for yourself if you wish, but thoughtless
     copying of your init file will not inhibit the message for someone
     else.

 -- User Option: initial-scratch-message
     This variable, if non-'nil', should be a string, which is treated
     as documentation to be inserted into the 'scratch' buffer when
     Emacs starts up.  If it is 'nil', the 'scratch' buffer is empty.

The following command-line options affect some aspects of the startup
sequence.  *Note (emacs)Initial Options::.

'--no-splash'
     Do not display a splash screen.

'--batch'
     Run without an interactive terminal.  *Note Batch Mode::.

'--daemon'
'--bg-daemon'
'--fg-daemon'
     Do not initialize any display; just start a server.  (A
     "background" daemon automatically runs in the background.)

'--no-init-file'
'-q'
     Do not load either the init file, or the 'default' library.

'--no-site-file'
     Do not load the 'site-start' library.

'--quick'
'-Q'
     Equivalent to '-q --no-site-file --no-splash'.

==============================================================================
File: elisp.info,  Node: |Init_File|,  Next: |Terminal_Specific|,  Prev: |Startup_Summary|,  Up: |Starting_Up|
==============================================================================

                                                                     *Init_File*

40.1.2 The Init File
--------------------

When you start Emacs, it normally attempts to load your "init file".
This is either a file named '.emacs' or '.emacs.el' in your home
directory, or a file named 'init.el' in a subdirectory named '.emacs.d'
in your home directory.

   The command-line switches '-q', '-Q', and '-u' control whether and
where to find the init file; '-q' (and the stronger '-Q') says not to
load an init file, while '-u USER' says to load USER's init file instead
of yours.  *Note (emacs)Entering Emacs::.  If neither option is
specified, Emacs uses the 'LOGNAME' environment variable, or the 'USER'
(most systems) or 'USERNAME' (MS systems) variable, to find your home
directory and thus your init file; this way, even if you have su'd,
Emacs still loads your own init file.  If those environment variables
are absent, though, Emacs uses your user-id to find your home directory.

   Emacs also attempts to load a second init file, called the "early
init file", if it exists.  This is a file named 'early-init.el' in your
'~/.emacs.d' directory.  The difference between the early init file and
the regular init file is that the early init file is loaded much earlier
during the startup process, so you can use it to customize some things
that are initialized before loading the regular init file.  For example,
you can customize the process of initializing the package system, by
setting variables such as PACKAGE-LOAD-LIST or
PACKAGE-ENABLE-AT-STARTUP.  *Note (emacs)Package Installation::.

   An Emacs installation may have a "default init file", which is a Lisp
library named 'default.el'.  Emacs finds this file through the standard
search path for libraries (*note How Programs Do Loading::).  The Emacs
distribution does not come with this file; it is intended for local
customizations.  If the default init file exists, it is loaded whenever
you start Emacs.  But your own personal init file, if any, is loaded
first; if it sets 'inhibit-default-init' to a non-'nil' value, then
Emacs does not subsequently load the 'default.el' file.  In batch mode,
or if you specify '-q' (or '-Q'), Emacs loads neither your personal init
file nor the default init file.

   Another file for site-customization is 'site-start.el'.  Emacs loads
this _before_ the user's init file.  You can inhibit the loading of this
file with the option '--no-site-file'.

 -- User Option: site-run-file
     This variable specifies the site-customization file to load before
     the user's init file.  Its normal value is '"site-start"'.  The
     only way you can change it with real effect is to do so before
     dumping Emacs.

   *Note Init File Examples: (emacs)Init Examples, for examples of how
to make various commonly desired customizations in your '.emacs' file.

 -- User Option: inhibit-default-init
     If this variable is non-'nil', it prevents Emacs from loading the
     default initialization library file.  The default value is 'nil'.

 -- Variable: before-init-hook
     This normal hook is run, once, just before loading all the init
     files ('site-start.el', your init file, and 'default.el').  (The
     only way to change it with real effect is before dumping Emacs.)

 -- Variable: after-init-hook
     This normal hook is run, once, just after loading all the init
     files ('site-start.el', your init file, and 'default.el'), before
     loading the terminal-specific library (if started on a text
     terminal) and processing the command-line action arguments.

 -- Variable: emacs-startup-hook
     This normal hook is run, once, just after handling the command line
     arguments.  In batch mode, Emacs does not run this hook.

 -- Variable: window-setup-hook
     This normal hook is very similar to 'emacs-startup-hook'.  The only
     difference is that it runs slightly later, after setting of the
     frame parameters.  *Note window-setup-hook: Startup Summary.

 -- Variable: user-init-file
     This variable holds the absolute file name of the user's init file.
     If the actual init file loaded is a compiled file, such as
     '.emacs.elc', the value refers to the corresponding source file.

 -- Variable: user-emacs-directory
     This variable holds the name of the Emacs default directory.  It
     defaults to '${XDG_CONFIG_HOME-'~/.config'}/emacs/' if that
     directory exists and '~/.emacs.d/' and '~/.emacs' do not exist,
     otherwise to '~/.emacs.d/' on all platforms but MS-DOS.  Here,
     '${XDG_CONFIG_HOME-'~/.config'}' stands for the value of the
     environment variable 'XDG_CONFIG_HOME' if that variable is set, and
     for '~/.config' otherwise.  *Note How Emacs Finds Your Init File:
     (emacs)Find Init.

==============================================================================
File: elisp.info,  Node: |Terminal_Specific|,  Next: |Command_Line_Arguments|,  Prev: |Init_File|,  Up: |Starting_Up|
==============================================================================

                                                             *Terminal_Specific*

40.1.3 Terminal-Specific Initialization
---------------------------------------

Each terminal type can have its own Lisp library that Emacs loads when
run on that type of terminal.  The library's name is constructed by
concatenating the value of the variable 'term-file-prefix' and the
terminal type (specified by the environment variable 'TERM').  Normally,
'term-file-prefix' has the value '"term/"'; changing this is not
recommended.  If there is an entry matching 'TERM' in the
'term-file-aliases' association list, Emacs uses the associated value in
place of 'TERM'.  Emacs finds the file in the normal manner, by
searching the 'load-path' directories, and trying the '.elc' and '.el'
suffixes.

   The usual role of a terminal-specific library is to enable special
keys to send sequences that Emacs can recognize.  It may also need to
set or add to 'input-decode-map' if the Termcap or Terminfo entry does
not specify all the terminal's function keys.  *Note Terminal Input::.

   When the name of the terminal type contains a hyphen or underscore,
and no library is found whose name is identical to the terminal's name,
Emacs strips from the terminal's name the last hyphen or underscore and
everything that follows it, and tries again.  This process is repeated
until Emacs finds a matching library, or until there are no more hyphens
or underscores in the name (i.e., there is no terminal-specific
library).  For example, if the terminal name is 'xterm-256color' and
there is no 'term/xterm-256color.el' library, Emacs tries to load
'term/xterm.el'.  If necessary, the terminal library can evaluate
'(getenv "TERM")' to find the full name of the terminal type.

   Your init file can prevent the loading of the terminal-specific
library by setting the variable 'term-file-prefix' to 'nil'.

   You can also arrange to override some of the actions of the
terminal-specific library by using 'tty-setup-hook'.  This is a normal
hook that Emacs runs after initializing a new text terminal.  You could
use this hook to define initializations for terminals that do not have
their own libraries.  *Note Hooks::.

 -- User Option: term-file-prefix
     If the value of this variable is non-'nil', Emacs loads a
     terminal-specific initialization file as follows:

          (load (concat term-file-prefix (getenv "TERM")))

     You may set the 'term-file-prefix' variable to 'nil' in your init
     file if you do not wish to load the terminal-initialization file.

     On MS-DOS, Emacs sets the 'TERM' environment variable to
     'internal'.

 -- User Option: term-file-aliases
     This variable is an association list mapping terminal types to
     their aliases.  For example, an element of the form '("vt102" .
     "vt100")' means to treat a terminal of type 'vt102' like one of
     type 'vt100'.

 -- Variable: tty-setup-hook
     This variable is a normal hook that Emacs runs after initializing a
     new text terminal.  (This applies when Emacs starts up in
     non-windowed mode, and when making a tty 'emacsclient' connection.)
     The hook runs after loading your init file (if applicable) and the
     terminal-specific Lisp file, so you can use it to adjust the
     definitions made by that file.

     For a related feature, *note window-setup-hook: Init File.

==============================================================================
File: elisp.info,  Node: |Command_Line_Arguments|,  Prev: |Terminal_Specific|,  Up: |Starting_Up|
==============================================================================

                                                        *Command_Line_Arguments*

40.1.4 Command-Line Arguments
-----------------------------

You can use command-line arguments to request various actions when you
start Emacs.  Note that the recommended way of using Emacs is to start
it just once, after logging in, and then do all editing in the same
Emacs session (*note (emacs)Entering Emacs::).  For this reason, you
might not use command-line arguments very often; nonetheless, they can
be useful when invoking Emacs from session scripts or debugging Emacs.
This section describes how Emacs processes command-line arguments.

 -- Function: command-line
     This function parses the command line that Emacs was called with,
     processes it, and (amongst other things) loads the user's init file
     and displays the startup messages.

 -- Variable: command-line-processed
     The value of this variable is 't' once the command line has been
     processed.

     If you redump Emacs by calling 'dump-emacs' (*note Building
     Emacs::), you may wish to set this variable to 'nil' first in order
     to cause the new dumped Emacs to process its new command-line
     arguments.

 -- Variable: command-switch-alist
     This variable is an alist of user-defined command-line options and
     associated handler functions.  By default it is empty, but you can
     add elements if you wish.

     A "command-line option" is an argument on the command line, which
     has the form:

          -OPTION

     The elements of the 'command-switch-alist' look like this:

          (OPTION . HANDLER-FUNCTION)

     The CAR, OPTION, is a string, the name of a command-line option
     (including the initial hyphen).  The HANDLER-FUNCTION is called to
     handle OPTION, and receives the option name as its sole argument.

     In some cases, the option is followed in the command line by an
     argument.  In these cases, the HANDLER-FUNCTION can find all the
     remaining command-line arguments in the variable
     'command-line-args-left' (see below).  (The entire list of
     command-line arguments is in 'command-line-args'.)

     Note that the handling of 'command-switch-alist' doesn't treat
     equals signs in OPTION specially.  That is, if there's an option
     like '--name=value' on the command line, then only a
     'command-switch-alist' member whose 'car' is literally
     '--name=value' will match this option.  If you want to parse such
     options, you need to use 'command-line-functions' instead (see
     below).

     The command-line arguments are parsed by the 'command-line-1'
     function in the 'startup.el' file.  See also *note Command Line
     Arguments for Emacs Invocation: (emacs)Emacs Invocation.

 -- Variable: command-line-args
     The value of this variable is the list of command-line arguments
     passed to Emacs.

 -- Variable: command-line-args-left
     The value of this variable is the list of command-line arguments
     that have not yet been processed.

 -- Variable: command-line-functions
     This variable's value is a list of functions for handling an
     unrecognized command-line argument.  Each time the next argument to
     be processed has no special meaning, the functions in this list are
     called, in order of appearance, until one of them returns a
     non-'nil' value.

     These functions are called with no arguments.  They can access the
     command-line argument under consideration through the variable
     'argi', which is bound temporarily at this point.  The remaining
     arguments (not including the current one) are in the variable
     'command-line-args-left'.

     When a function recognizes and processes the argument in 'argi', it
     should return a non-'nil' value to say it has dealt with that
     argument.  If it has also dealt with some of the following
     arguments, it can indicate that by deleting them from
     'command-line-args-left'.

     If all of these functions return 'nil', then the argument is
     treated as a file name to visit.

==============================================================================
File: elisp.info,  Node: |Getting_Out|,  Next: |System_Environment|,  Prev: |Starting_Up|,  Up: |System_Interface|
==============================================================================

                                                                   *Getting_Out*

40.2 Getting Out of Emacs
=====--------------------

There are two ways to get out of Emacs: you can kill the Emacs job,
which exits permanently, or you can suspend it, which permits you to
reenter the Emacs process later.  (In a graphical environment, you can
of course simply switch to another application without doing anything
special to Emacs, then switch back to Emacs when you want.)

MENU

* |Killing_Emacs|::        Exiting Emacs irreversibly.
* |Suspending_Emacs|::     Exiting Emacs reversibly.

==============================================================================
File: elisp.info,  Node: |Killing_Emacs|,  Next: |Suspending_Emacs|,  Up: |Getting_Out|
==============================================================================

                                                                 *Killing_Emacs*

40.2.1 Killing Emacs
--------------------

Killing Emacs means ending the execution of the Emacs process.  If you
started Emacs from a terminal, the parent process normally resumes
control.  The low-level primitive for killing Emacs is 'kill-emacs'.

 -- Command: kill-emacs &optional exit-data
     This command calls the hook 'kill-emacs-hook', then exits the Emacs
     process and kills it.

     If EXIT-DATA is an integer, that is used as the exit status of the
     Emacs process.  (This is useful primarily in batch operation; see
     *note Batch Mode::.)

     If EXIT-DATA is a string, its contents are stuffed into the
     terminal input buffer so that the shell (or whatever program next
     reads input) can read them.

     If EXIT-DATA is neither an integer nor a string, or is omitted,
     that means to use the (system-specific) exit status which indicates
     successful program termination.

   The 'kill-emacs' function is normally called via the higher-level
command 'C-x C-c' ('save-buffers-kill-terminal').  *Note
(emacs)Exiting::.  It is also called automatically if Emacs receives a
'SIGTERM' or 'SIGHUP' operating system signal (e.g., when the
controlling terminal is disconnected), or if it receives a 'SIGINT'
signal while running in batch mode (*note Batch Mode::).

 -- Variable: kill-emacs-hook
     This normal hook is run by 'kill-emacs', before it kills Emacs.

     Because 'kill-emacs' can be called in situations where user
     interaction is impossible (e.g., when the terminal is
     disconnected), functions on this hook should not attempt to
     interact with the user.  If you want to interact with the user when
     Emacs is shutting down, use 'kill-emacs-query-functions', described
     below.

   When Emacs is killed, all the information in the Emacs process, aside
from files that have been saved, is lost.  Because killing Emacs
inadvertently can lose a lot of work, the 'save-buffers-kill-terminal'
command queries for confirmation if you have buffers that need saving or
subprocesses that are running.  It also runs the abnormal hook
'kill-emacs-query-functions':

 -- User Option: kill-emacs-query-functions
     When 'save-buffers-kill-terminal' is killing Emacs, it calls the
     functions in this hook, after asking the standard questions and
     before calling 'kill-emacs'.  The functions are called in order of
     appearance, with no arguments.  Each function can ask for
     additional confirmation from the user.  If any of them returns
     'nil', 'save-buffers-kill-emacs' does not kill Emacs, and does not
     run the remaining functions in this hook.  Calling 'kill-emacs'
     directly does not run this hook.

==============================================================================
File: elisp.info,  Node: |Suspending_Emacs|,  Prev: |Killing_Emacs|,  Up: |Getting_Out|
==============================================================================

                                                              *Suspending_Emacs*

40.2.2 Suspending Emacs
-----------------------

On text terminals, it is possible to "suspend Emacs", which means
stopping Emacs temporarily and returning control to its superior
process, which is usually the shell.  This allows you to resume editing
later in the same Emacs process, with the same buffers, the same kill
ring, the same undo history, and so on.  To resume Emacs, use the
appropriate command in the parent shell--most likely 'fg'.

   Suspending works only on a terminal device from which the Emacs
session was started.  We call that device the "controlling terminal" of
the session.  Suspending is not allowed if the controlling terminal is a
graphical terminal.  Suspending is usually not relevant in graphical
environments, since you can simply switch to another application without
doing anything special to Emacs.

   Some operating systems (those without 'SIGTSTP', or MS-DOS) do not
support suspension of jobs; on these systems, suspension actually
creates a new shell temporarily as a subprocess of Emacs.  Then you
would exit the shell to return to Emacs.

 -- Command: suspend-emacs &optional string
     This function stops Emacs and returns control to the superior
     process.  If and when the superior process resumes Emacs,
     'suspend-emacs' returns 'nil' to its caller in Lisp.

     This function works only on the controlling terminal of the Emacs
     session; to relinquish control of other tty devices, use
     'suspend-tty' (see below).  If the Emacs session uses more than one
     terminal, you must delete the frames on all the other terminals
     before suspending Emacs, or this function signals an error.  *Note
     Multiple Terminals::.

     If STRING is non-'nil', its characters are sent to Emacs's superior
     shell, to be read as terminal input.  The characters in STRING are
     not echoed by the superior shell; only the results appear.

     Before suspending, 'suspend-emacs' runs the normal hook
     'suspend-hook'.  After the user resumes Emacs, 'suspend-emacs' runs
     the normal hook 'suspend-resume-hook'.  *Note Hooks::.

     The next redisplay after resumption will redraw the entire screen,
     unless the variable 'no-redraw-on-reenter' is non-'nil'.  *Note
     Refresh Screen::.

     Here is an example of how you could use these hooks:

          (add-hook 'suspend-hook
                    (lambda () (or (y-or-n-p "Really suspend? ")
                                   (error "Suspend canceled"))))
          (add-hook 'suspend-resume-hook (lambda () (message "Resumed!")
                                           (sit-for 2)))

     Here is what you would see upon evaluating '(suspend-emacs "pwd")':

          ---------- Buffer: Minibuffer ----------
          Really suspend? y
          ---------- Buffer: Minibuffer ----------

          ---------- Parent Shell ----------
          bash$ /home/username
          bash$ fg

          ---------- Echo Area ----------
          Resumed!

     Note that 'pwd' is not echoed after Emacs is suspended.  But it is
     read and executed by the shell.

 -- Variable: suspend-hook
     This variable is a normal hook that Emacs runs before suspending.

 -- Variable: suspend-resume-hook
     This variable is a normal hook that Emacs runs on resuming after a
     suspension.

 -- Function: suspend-tty &optional tty
     If TTY specifies a terminal device used by Emacs, this function
     relinquishes the device and restores it to its prior state.  Frames
     that used the device continue to exist, but are not updated and
     Emacs doesn't read input from them.  TTY can be a terminal object,
     a frame (meaning the terminal for that frame), or 'nil' (meaning
     the terminal for the selected frame).  *Note Multiple Terminals::.

     If TTY is already suspended, this function does nothing.

     This function runs the hook 'suspend-tty-functions', passing the
     terminal object as an argument to each function.

 -- Function: resume-tty &optional tty
     This function resumes the previously suspended terminal device TTY;
     where TTY has the same possible values as it does for
     'suspend-tty'.

     This function reopens the terminal device, re-initializes it, and
     redraws it with that terminal's selected frame.  It then runs the
     hook 'resume-tty-functions', passing the terminal object as an
     argument to each function.

     If the same device is already used by another Emacs terminal, this
     function signals an error.  If TTY is not suspended, this function
     does nothing.

 -- Function: controlling-tty-p &optional tty
     This function returns non-'nil' if TTY is the controlling terminal
     of the Emacs session; TTY can be a terminal object, a frame
     (meaning the terminal for that frame), or 'nil' (meaning the
     terminal for the selected frame).

 -- Command: suspend-frame
     This command "suspends" a frame.  For GUI frames, it calls
     'iconify-frame' (*note Visibility of Frames::); for frames on text
     terminals, it calls either 'suspend-emacs' or 'suspend-tty',
     depending on whether the frame is displayed on the controlling
     terminal device or not.

==============================================================================
File: elisp.info,  Node: |System_Environment|,  Next: |User_Identification|,  Prev: |Getting_Out|,  Up: |System_Interface|
==============================================================================

                                                            *System_Environment*

40.3 Operating System Environment
=====----------------------------

Emacs provides access to variables in the operating system environment
through various functions.  These variables include the name of the
system, the user's UID, and so on.

 -- Variable: system-configuration
     This variable holds the standard GNU configuration name for the
     hardware/software configuration of your system, as a string.  For
     example, a typical value for a 64-bit GNU/Linux system is
     '"x86_64-unknown-linux-gnu"'.

 -- Variable: system-type
     The value of this variable is a symbol indicating the type of
     operating system Emacs is running on.  The possible values are:

     'aix'
          IBM's AIX.

     'berkeley-unix'
          Berkeley BSD and its variants.

     'cygwin'
          Cygwin, a POSIX layer on top of MS-Windows.

     'darwin'
          Darwin (macOS).

     'gnu'
          The GNU system (using the GNU kernel, which consists of the
          HURD and Mach).

     'gnu/linux'
          A GNU/Linux system--that is, a variant GNU system, using the
          Linux kernel.  (These systems are the ones people often call
          "Linux", but actually Linux is just the kernel, not the whole
          system.)

     'gnu/kfreebsd'
          A GNU (glibc-based) system with a FreeBSD kernel.

     'hpux'
          Hewlett-Packard HPUX operating system.

     'nacl'
          Google Native Client (NaCl) sandboxing system.

     'ms-dos'
          Microsoft's DOS.  Emacs compiled with DJGPP for MS-DOS binds
          'system-type' to 'ms-dos' even when you run it on MS-Windows.

     'usg-unix-v'
          AT&T Unix System V.

     'windows-nt'
          Microsoft Windows NT, 9X and later.  The value of
          'system-type' is always 'windows-nt', e.g., even on Windows
          10.

     We do not wish to add new symbols to make finer distinctions unless
     it is absolutely necessary!  In fact, we hope to eliminate some of
     these alternatives in the future.  If you need to make a finer
     distinction than 'system-type' allows for, you can test
     'system-configuration', e.g., against a regexp.

 -- Function: system-name
     This function returns the name of the machine you are running on,
     as a string.

 -- User Option: mail-host-address
     If this variable is non-'nil', it is used instead of 'system-name'
     for purposes of generating email addresses.  For example, it is
     used when constructing the default value of 'user-mail-address'.
     *Note User Identification::.

 -- Command: getenv var &optional frame
     This function returns the value of the environment variable VAR, as
     a string.  VAR should be a string.  If VAR is undefined in the
     environment, 'getenv' returns 'nil'.  It returns '""' if VAR is set
     but null.  Within Emacs, a list of environment variables and their
     values is kept in the variable 'process-environment'.

          (getenv "USER")
               => "lewis"

     The shell command 'printenv' prints all or part of the environment:

          bash$ printenv
          PATH=/usr/local/bin:/usr/bin:/bin
          USER=lewis
          TERM=xterm
          SHELL=/bin/bash
          HOME=/home/lewis
          ...

 -- Command: setenv variable &optional value substitute
     This command sets the value of the environment variable named
     VARIABLE to VALUE.  VARIABLE should be a string.  Internally, Emacs
     Lisp can handle any string.  However, normally VARIABLE should be a
     valid shell identifier, that is, a sequence of letters, digits and
     underscores, starting with a letter or underscore.  Otherwise,
     errors may occur if subprocesses of Emacs try to access the value
     of VARIABLE.  If VALUE is omitted or 'nil' (or, interactively, with
     a prefix argument), 'setenv' removes VARIABLE from the environment.
     Otherwise, VALUE should be a string.

     If the optional argument SUBSTITUTE is non-'nil', Emacs calls the
     function 'substitute-env-vars' to expand any environment variables
     in VALUE.

     'setenv' works by modifying 'process-environment'; binding that
     variable with 'let' is also reasonable practice.

     'setenv' returns the new value of VARIABLE, or 'nil' if it removed
     VARIABLE from the environment.

 -- Variable: process-environment
     This variable is a list of strings, each describing one environment
     variable.  The functions 'getenv' and 'setenv' work by means of
     this variable.

          process-environment
          => ("PATH=/usr/local/bin:/usr/bin:/bin"
              "USER=lewis"
              "TERM=xterm"
              "SHELL=/bin/bash"
              "HOME=/home/lewis"
              ...)

     If 'process-environment' contains multiple elements that specify
     the same environment variable, the first of these elements
     specifies the variable, and the others are ignored.

 -- Variable: initial-environment
     This variable holds the list of environment variables Emacs
     inherited from its parent process when Emacs started.

 -- Variable: path-separator
     This variable holds a string that says which character separates
     directories in a search path (as found in an environment variable).
     Its value is '":"' for Unix and GNU systems, and '";"' for MS
     systems.

 -- Function: parse-colon-path path
     This function takes a search path string such as the value of the
     'PATH' environment variable, and splits it at the separators,
     returning a list of directories.  'nil' in this list means the
     current directory.  Although the function's name says "colon", it
     actually uses the value of 'path-separator'.

          (parse-colon-path ":/foo:/bar")
               => (nil "/foo/" "/bar/")

 -- Variable: invocation-name
     This variable holds the program name under which Emacs was invoked.
     The value is a string, and does not include a directory name.

 -- Variable: invocation-directory
     This variable holds the directory in which the Emacs executable was
     located when it was run, or 'nil' if that directory cannot be
     determined.

 -- Variable: installation-directory
     If non-'nil', this is a directory within which to look for the
     'lib-src' and 'etc' subdirectories.  In an installed Emacs, it is
     normally 'nil'.  It is non-'nil' when Emacs can't find those
     directories in their standard installed locations, but can find
     them in a directory related somehow to the one containing the Emacs
     executable (i.e., 'invocation-directory').

 -- Function: load-average &optional use-float
     This function returns the current 1-minute, 5-minute, and 15-minute
     system load averages, in a list.  The load average indicates the
     number of processes trying to run on the system.

     By default, the values are integers that are 100 times the system
     load averages, but if USE-FLOAT is non-'nil', then they are
     returned as floating-point numbers without multiplying by 100.

     If it is impossible to obtain the load average, this function
     signals an error.  On some platforms, access to load averages
     requires installing Emacs as setuid or setgid so that it can read
     kernel information, and that usually isn't advisable.

     If the 1-minute load average is available, but the 5- or 15-minute
     averages are not, this function returns a shortened list containing
     the available averages.

          (load-average)
               => (169 48 36)
          (load-average t)
               => (1.69 0.48 0.36)

     The shell command 'uptime' returns similar information.

 -- Function: emacs-pid
     This function returns the process ID of the Emacs process, as an
     integer.

 -- Variable: tty-erase-char
     This variable holds the erase character that was selected in the
     system's terminal driver, before Emacs was started.

==============================================================================
File: elisp.info,  Node: |User_Identification|,  Next: |Time_of_Day|,  Prev: |System_Environment|,  Up: |System_Interface|
==============================================================================

                                                           *User_Identification*

40.4 User Identification
=====-------------------

 -- Variable: init-file-user
     This variable says which user's init files should be used by
     Emacs--or 'nil' if none.  '""' stands for the user who originally
     logged in.  The value reflects command-line options such as '-q' or
     '-u USER'.

     Lisp packages that load files of customizations, or any other sort
     of user profile, should obey this variable in deciding where to
     find it.  They should load the profile of the user name found in
     this variable.  If 'init-file-user' is 'nil', meaning that the
     '-q', '-Q', or '-batch' option was used, then Lisp packages should
     not load any customization files or user profile.

 -- User Option: user-mail-address
     This holds the email address of the user who is using Emacs.

 -- Function: user-login-name &optional uid
     This function returns the name under which the user is logged in.
     It uses the environment variables 'LOGNAME' or 'USER' if either is
     set.  Otherwise, the value is based on the effective UID, not the
     real UID.

     If you specify UID (a number), the result is the user name that
     corresponds to UID, or 'nil' if there is no such user.

 -- Function: user-real-login-name
     This function returns the user name corresponding to Emacs's real
     UID.  This ignores the effective UID, and the environment variables
     'LOGNAME' and 'USER'.

 -- Function: user-full-name &optional uid
     This function returns the full name of the logged-in user--or the
     value of the environment variable 'NAME', if that is set.

     If the Emacs process's user-id does not correspond to any known
     user (and provided 'NAME' is not set), the result is '"unknown"'.

     If UID is non-'nil', then it should be a number (a user-id) or a
     string (a login name).  Then 'user-full-name' returns the full name
     corresponding to that user-id or login name.  If you specify a
     user-id or login name that isn't defined, it returns 'nil'.

   The symbols 'user-login-name', 'user-real-login-name' and
'user-full-name' are variables as well as functions.  The functions
return the same values that the variables hold.  These variables allow
you to fake out Emacs by telling the functions what to return.  The
variables are also useful for constructing frame titles (*note Frame
Titles::).

 -- Function: user-real-uid
     This function returns the real UID of the user.

 -- Function: user-uid
     This function returns the effective UID of the user.

 -- Function: group-gid
     This function returns the effective GID of the Emacs process.

 -- Function: group-real-gid
     This function returns the real GID of the Emacs process.

 -- Function: system-users
     This function returns a list of strings, listing the user names on
     the system.  If Emacs cannot retrieve this information, the return
     value is a list containing just the value of
     'user-real-login-name'.

 -- Function: system-groups
     This function returns a list of strings, listing the names of user
     groups on the system.  If Emacs cannot retrieve this information,
     the return value is 'nil'.

 -- Function: group-name gid
     This function returns the group name that corresponds to the
     numeric group ID GID, or 'nil' if there is no such group.

==============================================================================
File: elisp.info,  Node: |Time_of_Day|,  Next: |Time_Zone_Rules|,  Prev: |User_Identification|,  Up: |System_Interface|
==============================================================================

                                                                   *Time_of_Day*

40.5 Time of Day
=====-----------

This section explains how to determine the current time and time zone.

   Many functions like 'current-time' and 'file-attributes' return "Lisp
timestamp" values that count seconds, and that can represent absolute
time by counting seconds since the "epoch" of 1970-01-01 00:00:00 UTC.

   Although traditionally Lisp timestamps were integer pairs, their form
has evolved and programs ordinarily should not depend on the current
default form.  If your program needs a particular timestamp form, you
can use the 'time-convert' function to convert it to the needed form.
*Note Time Conversion::.

   There are currently three forms of Lisp timestamps, each of which
represents a number of seconds:

   * An integer.  Although this is the simplest form, it cannot
     represent subsecond timestamps.

   * A pair of integers '(TICKS . HZ)', where HZ is positive.  This
     represents TICKS/HZ seconds, which is the same time as plain TICKS
     if HZ is 1.  A common value for HZ is 1000000000, for a
     nanosecond-resolution clock.(1)

   * A list of four integers '(HIGH LOW MICRO PICO)', where 0???LOW<65536,
     0???MICRO<1000000, and 0???PICO<1000000.  This represents the number of
     seconds using the formula: HIGH * 2**16 + LOW + MICRO * 10**-6 +
     PICO * 10**-12.  In some cases, functions may default to returning
     two- or three-element lists, with omitted MICRO and PICO components
     defaulting to zero.  On all current machines PICO is a multiple of
     1000, but this may change as higher-resolution clocks become
     available.

   Function arguments, e.g., the TIME argument to 'current-time-string',
accept a more-general "time value" format, which can be a Lisp
timestamp, 'nil' for the current time, a single floating-point number
for seconds, or a list '(HIGH LOW MICRO)' or '(HIGH LOW)' that is a
truncated list timestamp with missing elements taken to be zero.

   Time values can be converted to and from calendrical and other forms.
Some of these conversions rely on operating system functions that limit
the range of possible time values, and signal an error such as
'"Specified time is not representable"' if the limits are exceeded.  For
instance, a system may not support years before 1970, or years before
1901, or years far in the future.  You can convert a time value into a
human-readable string using 'format-time-string', into a Lisp timestamp
using 'time-convert', and into other forms using 'decode-time' and
'float-time'.  These functions are described in the following sections.

 -- Function: current-time-string &optional time zone
     This function returns the current time and date as a human-readable
     string.  The format does not vary for the initial part of the
     string, which contains the day of week, month, day of month, and
     time of day in that order: the number of characters used for these
     fields is always the same, although (unless you require English
     weekday or month abbreviations regardless of locale) it is
     typically more convenient to use 'format-time-string' than to
     extract fields from the output of 'current-time-string', as the
     year might not have exactly four digits, and additional information
     may some day be added at the end.

     The argument TIME, if given, specifies a time to format, instead of
     the current time.  The optional argument ZONE defaults to the
     current time zone rule.  *Note Time Zone Rules::.  The operating
     system limits the range of time and zone values.

          (current-time-string)
               => "Fri Nov  1 15:59:49 2019"

 -- Function: current-time
     This function returns the current time as a Lisp timestamp.
     Although the timestamp takes the form '(HIGH LOW MICRO PICO)' in
     the current Emacs release, this is planned to change in a future
     Emacs version.  You can use the 'time-convert' function to convert
     a timestamp to some other form.  *Note Time Conversion::.

 -- Function: float-time &optional time
     This function returns the current time as a floating-point number
     of seconds since the epoch.  The optional argument TIME, if given,
     specifies a time to convert instead of the current time.

     _Warning_: Since the result is floating point, it may not be exact.
     Do not use this function if precise time stamps are required.  For
     example, on typical systems '(float-time '(1 . 10))' displays as
     '0.1' but is slightly greater than 1/10.

     'time-to-seconds' is an alias for this function.

   ---------- Footnotes ----------

   (1) Currently HZ should be at least 65536 to avoid compatibility
warnings when the timestamp is passed to standard functions, as previous
versions of Emacs would interpret such a timestamps differently due to
backward-compatibility concerns.  These warnings are intended to be
removed in a future Emacs version.

==============================================================================
File: elisp.info,  Node: |Time_Zone_Rules|,  Next: |Time_Conversion|,  Prev: |Time_of_Day|,  Up: |System_Interface|
==============================================================================

                                                               *Time_Zone_Rules*

40.6 Time Zone Rules
=====---------------

The default time zone is determined by the 'TZ' environment variable.
*Note System Environment::.  For example, you can tell Emacs to default
to Universal Time with '(setenv "TZ" "UTC0")'.  If 'TZ' is not in the
environment, Emacs uses system wall clock time, which is a
platform-dependent default time zone.

   The set of supported 'TZ' strings is system-dependent.  GNU and many
other systems support the tzdata database, e.g., '"America/New_York"'
specifies the time zone and daylight saving time history for locations
near New York City.  GNU and most other systems support POSIX-style 'TZ'
strings, e.g., '"EST+5EDT,M4.1.0/2,M10.5.0/2"' specifies the rules used
in New York from 1987 through 2006.  All systems support the string
'"UTC0"' meaning Universal Time.

   Functions that convert to and from local time accept an optional
"time zone rule" argument, which specifies the conversion's time zone
and daylight saving time history.  If the time zone rule is omitted or
'nil', the conversion uses Emacs's default time zone.  If it is 't', the
conversion uses Universal Time.  If it is 'wall', the conversion uses
the system wall clock time.  If it is a string, the conversion uses the
time zone rule equivalent to setting 'TZ' to that string.  If it is a
list (OFFSET ABBR), where OFFSET is an integer number of seconds east of
Universal Time and ABBR is a string, the conversion uses a fixed time
zone with the given offset and abbreviation.  An integer OFFSET is
treated as if it were (OFFSET ABBR), where ABBR is a numeric
abbreviation on POSIX-compatible platforms and is unspecified on
MS-Windows.

 -- Function: current-time-zone &optional time zone
     This function returns a list describing the time zone that the user
     is in.

     The value has the form '(OFFSET ABBR)'.  Here OFFSET is an integer
     giving the number of seconds ahead of Universal Time (east of
     Greenwich).  A negative value means west of Greenwich.  The second
     element, ABBR, is a string giving an abbreviation for the time
     zone, e.g., '"CST"' for China Standard Time or for U.S. Central
     Standard Time.  Both elements can change when daylight saving time
     begins or ends; if the user has specified a time zone that does not
     use a seasonal time adjustment, then the value is constant through
     time.

     If the operating system doesn't supply all the information
     necessary to compute the value, the unknown elements of the list
     are 'nil'.

     The argument TIME, if given, specifies a time value to analyze
     instead of the current time.  The optional argument ZONE defaults
     to the current time zone rule.  The operating system limits the
     range of time and zone values.

==============================================================================
File: elisp.info,  Node: |Time_Conversion|,  Next: |Time_Parsing|,  Prev: |Time_Zone_Rules|,  Up: |System_Interface|
==============================================================================

                                                               *Time_Conversion*

40.7 Time Conversion
=====---------------

These functions convert time values (*note Time of Day::) to Lisp
timestamps, or into calendrical information and vice versa.

   Many 32-bit operating systems are limited to system times containing
32 bits of information in their seconds component; these systems
typically handle only the times from 1901-12-13 20:45:52 through
2038-01-19 03:14:07 Universal Time.  However, 64-bit and some 32-bit
operating systems have larger seconds components, and can represent
times far in the past or future.

   Calendrical conversion functions always use the Gregorian calendar,
even for dates before the Gregorian calendar was introduced.  Year
numbers count the number of years since the year 1 BC, and do not skip
zero as traditional Gregorian years do; for example, the year number -37
represents the Gregorian year 38 BC.

 -- Function: time-convert time &optional form
     This function converts a time value into a Lisp timestamp.
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
