found, and must be a keymap; then the second event's binding is found in
that keymap, and so on until all the events in the key sequence are used
up.  (The binding thus found for the last event may or may not be a
keymap.)  Thus, the process of key lookup is defined in terms of a
simpler process for looking up a single event in a keymap.  How that is
done depends on the type of object associated with the event in that
keymap.

   Let's use the term "keymap entry" to describe the value found by
looking up an event type in a keymap.  (This doesn't include the item
string and other extra elements in a keymap element for a menu item,
because 'lookup-key' and other key lookup functions don't include them
in the returned value.)  While any Lisp object may be stored in a keymap
as a keymap entry, not all make sense for key lookup.  Here is a table
of the meaningful types of keymap entries:

'nil'
     'nil' means that the events used so far in the lookup form an
     undefined key.  When a keymap fails to mention an event type at
     all, and has no default binding, that is equivalent to a binding of
     'nil' for that event type.

COMMAND
     The events used so far in the lookup form a complete key, and
     COMMAND is its binding.  *Note What Is a Function::.

ARRAY
     The array (either a string or a vector) is a keyboard macro.  The
     events used so far in the lookup form a complete key, and the array
     is its binding.  See *note Keyboard Macros::, for more information.

KEYMAP
     The events used so far in the lookup form a prefix key.  The next
     event of the key sequence is looked up in KEYMAP.

LIST
     The meaning of a list depends on what it contains:

        * If the CAR of LIST is the symbol 'keymap', then the list is a
          keymap, and is treated as a keymap (see above).

        * If the CAR of LIST is 'lambda', then the list is a lambda
          expression.  This is presumed to be a function, and is treated
          as such (see above).  In order to execute properly as a key
          binding, this function must be a command--it must have an
          'interactive' specification.  *Note Defining Commands::.

SYMBOL
     The function definition of SYMBOL is used in place of SYMBOL.  If
     that too is a symbol, then this process is repeated, any number of
     times.  Ultimately this should lead to an object that is a keymap,
     a command, or a keyboard macro.

     Note that keymaps and keyboard macros (strings and vectors) are not
     valid functions, so a symbol with a keymap, string, or vector as
     its function definition is invalid as a function.  It is, however,
     valid as a key binding.  If the definition is a keyboard macro,
     then the symbol is also valid as an argument to 'command-execute'
     (*note Interactive Call::).

     The symbol 'undefined' is worth special mention: it means to treat
     the key as undefined.  Strictly speaking, the key is defined, and
     its binding is the command 'undefined'; but that command does the
     same thing that is done automatically for an undefined key: it
     rings the bell (by calling 'ding') but does not signal an error.

     'undefined' is used in local keymaps to override a global key
     binding and make the key undefined locally.  A local binding of
     'nil' would fail to do this because it would not override the
     global binding.

ANYTHING ELSE
     If any other type of object is found, the events used so far in the
     lookup form a complete key, and the object is its binding, but the
     binding is not executable as a command.

   In short, a keymap entry may be a keymap, a command, a keyboard
macro, a symbol that leads to one of them, or 'nil'.

==============================================================================
File: elisp.info,  Node: |Functions_for_Key_Lookup|,  Next: |Changing_Key_Bindings|,  Prev: |Key_Lookup|,  Up: |Keymaps|
==============================================================================

                                                      *Functions_for_Key_Lookup*

22.11 Functions for Key Lookup
------------------------------

Here are the functions and variables pertaining to key lookup.

 -- Function: lookup-key keymap key &optional accept-defaults
     This function returns the definition of KEY in KEYMAP.  All the
     other functions described in this chapter that look up keys use
     'lookup-key'.  Here are examples:

          (lookup-key (current-global-map) "\C-x\C-f")
              => find-file
          (lookup-key (current-global-map) (kbd "C-x C-f"))
              => find-file
          (lookup-key (current-global-map) "\C-x\C-f12345")
              => 2

     If the string or vector KEY is not a valid key sequence according
     to the prefix keys specified in KEYMAP, it must be too long and
     have extra events at the end that do not fit into a single key
     sequence.  Then the value is a number, the number of events at the
     front of KEY that compose a complete key.

     If ACCEPT-DEFAULTS is non-'nil', then 'lookup-key' considers
     default bindings as well as bindings for the specific events in
     KEY.  Otherwise, 'lookup-key' reports only bindings for the
     specific sequence KEY, ignoring default bindings except when you
     explicitly ask about them.  (To do this, supply 't' as an element
     of KEY; see *note Format of Keymaps::.)

     If KEY contains a meta character (not a function key), that
     character is implicitly replaced by a two-character sequence: the
     value of 'meta-prefix-char', followed by the corresponding non-meta
     character.  Thus, the first example below is handled by conversion
     into the second example.

          (lookup-key (current-global-map) "\M-f")
              => forward-word
          (lookup-key (current-global-map) "\ef")
              => forward-word

     The KEYMAP argument can also be a list of keymaps.

     Unlike 'read-key-sequence', this function does not modify the
     specified events in ways that discard information (*note Key
     Sequence Input::).  In particular, it does not convert letters to
     lower case and it does not change drag events to clicks.

 -- Command: undefined
     Used in keymaps to undefine keys.  It calls 'ding', but does not
     cause an error.

 -- Function: local-key-binding key &optional accept-defaults
     This function returns the binding for KEY in the current local
     keymap, or 'nil' if it is undefined there.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in 'lookup-key' (above).

 -- Function: global-key-binding key &optional accept-defaults
     This function returns the binding for command KEY in the current
     global keymap, or 'nil' if it is undefined there.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in 'lookup-key' (above).

 -- Function: minor-mode-key-binding key &optional accept-defaults
     This function returns a list of all the active minor mode bindings
     of KEY.  More precisely, it returns an alist of pairs '(MODENAME .
     BINDING)', where MODENAME is the variable that enables the minor
     mode, and BINDING is KEY's binding in that mode.  If KEY has no
     minor-mode bindings, the value is 'nil'.

     If the first binding found is not a prefix definition (a keymap or
     a symbol defined as a keymap), all subsequent bindings from other
     minor modes are omitted, since they would be completely shadowed.
     Similarly, the list omits non-prefix bindings that follow prefix
     bindings.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in 'lookup-key' (above).

 -- User Option: meta-prefix-char
     This variable is the meta-prefix character code.  It is used for
     translating a meta character to a two-character sequence so it can
     be looked up in a keymap.  For useful results, the value should be
     a prefix event (*note Prefix Keys::).  The default value is 27,
     which is the ASCII code for <ESC>.

     As long as the value of 'meta-prefix-char' remains 27, key lookup
     translates 'M-b' into '<ESC> b', which is normally defined as the
     'backward-word' command.  However, if you were to set
     'meta-prefix-char' to 24, the code for 'C-x', then Emacs will
     translate 'M-b' into 'C-x b', whose standard binding is the
     'switch-to-buffer' command.  (Don't actually do this!)  Here is an
     illustration of what would happen:

          meta-prefix-char                    ; The default value.
               => 27
          (key-binding "\M-b")
               => backward-word
          ?\C-x                               ; The print representation
               => 24                          ;   of a character.
          (setq meta-prefix-char 24)
               => 24
          (key-binding "\M-b")
               => switch-to-buffer            ; Now, typing 'M-b' is
                                              ;   like typing 'C-x b'.

          (setq meta-prefix-char 27)          ; Avoid confusion!
               => 27                          ; Restore the default value!

     This translation of one event into two happens only for characters,
     not for other kinds of input events.  Thus, 'M-<F1>', a function
     key, is not converted into '<ESC> <F1>'.

==============================================================================
File: elisp.info,  Node: |Changing_Key_Bindings|,  Next: |Remapping_Commands|,  Prev: |Functions_for_Key_Lookup|,  Up: |Keymaps|
==============================================================================

                                                         *Changing_Key_Bindings*

22.12 Changing Key Bindings
---------------------------

The way to rebind a key is to change its entry in a keymap.  If you
change a binding in the global keymap, the change is effective in all
buffers (though it has no direct effect in buffers that shadow the
global binding with a local one).  If you change the current buffer's
local map, that usually affects all buffers using the same major mode.
The 'global-set-key' and 'local-set-key' functions are convenient
interfaces for these operations (*note Key Binding Commands::).  You can
also use 'define-key', a more general function; then you must explicitly
specify the map to change.

   When choosing the key sequences for Lisp programs to rebind, please
follow the Emacs conventions for use of various keys (*note Key Binding
Conventions::).

   In writing the key sequence to rebind, it is good to use the special
escape sequences for control and meta characters (*note String Type::).
The syntax '\C-' means that the following character is a control
character and '\M-' means that the following character is a meta
character.  Thus, the string '"\M-x"' is read as containing a single
'M-x', '"\C-f"' is read as containing a single 'C-f', and '"\M-\C-x"'
and '"\C-\M-x"' are both read as containing a single 'C-M-x'.  You can
also use this escape syntax in vectors, as well as others that aren't
allowed in strings; one example is '[?\C-\H-x home]'.  *Note Character
Type::.

   The key definition and lookup functions accept an alternate syntax
for event types in a key sequence that is a vector: you can use a list
containing modifier names plus one base event (a character or function
key name).  For example, '(control ?a)' is equivalent to '?\C-a' and
'(hyper control left)' is equivalent to 'C-H-left'.  One advantage of
such lists is that the precise numeric codes for the modifier bits don't
appear in compiled files.

   The functions below signal an error if KEYMAP is not a keymap, or if
KEY is not a string or vector representing a key sequence.  You can use
event types (symbols) as shorthand for events that are lists.  The 'kbd'
function (*note Key Sequences::) is a convenient way to specify the key
sequence.

 -- Function: define-key keymap key binding
     This function sets the binding for KEY in KEYMAP.  (If KEY is more
     than one event long, the change is actually made in another keymap
     reached from KEYMAP.)  The argument BINDING can be any Lisp object,
     but only certain types are meaningful.  (For a list of meaningful
     types, see *note Key Lookup::.)  The value returned by 'define-key'
     is BINDING.

     If KEY is '[t]', this sets the default binding in KEYMAP.  When an
     event has no binding of its own, the Emacs command loop uses the
     keymap's default binding, if there is one.

     Every prefix of KEY must be a prefix key (i.e., bound to a keymap)
     or undefined; otherwise an error is signaled.  If some prefix of
     KEY is undefined, then 'define-key' defines it as a prefix key so
     that the rest of KEY can be defined as specified.

     If there was previously no binding for KEY in KEYMAP, the new
     binding is added at the beginning of KEYMAP.  The order of bindings
     in a keymap makes no difference for keyboard input, but it does
     matter for menu keymaps (*note Menu Keymaps::).

   This example creates a sparse keymap and makes a number of bindings
in it:

     (setq map (make-sparse-keymap))
         => (keymap)
     (define-key map "\C-f" 'forward-char)
         => forward-char
     map
         => (keymap (6 . forward-char))

     ;; Build sparse submap for 'C-x' and bind 'f' in that.
     (define-key map (kbd "C-x f") 'forward-word)
         => forward-word
     map
     => (keymap
         (24 keymap                ; C-x
             (102 . forward-word)) ;      f
         (6 . forward-char))       ; C-f

     ;; Bind 'C-p' to the 'ctl-x-map'.
     (define-key map (kbd "C-p") ctl-x-map)
     ;; ctl-x-map
     => [nil ... find-file ... backward-kill-sentence]

     ;; Bind 'C-f' to 'foo' in the 'ctl-x-map'.
     (define-key map (kbd "C-p C-f") 'foo)
     => 'foo
     map
     => (keymap     ; Note 'foo' in 'ctl-x-map'.
         (16 keymap [nil ... foo ... backward-kill-sentence])
         (24 keymap
             (102 . forward-word))
         (6 . forward-char))

Note that storing a new binding for 'C-p C-f' actually works by changing
an entry in 'ctl-x-map', and this has the effect of changing the
bindings of both 'C-p C-f' and 'C-x C-f' in the default global map.

   The function 'substitute-key-definition' scans a keymap for keys that
have a certain binding and rebinds them with a different binding.
Another feature which is cleaner and can often produce the same results
is to remap one command into another (*note Remapping Commands::).

 -- Function: substitute-key-definition olddef newdef keymap &optional
          oldmap
     This function replaces OLDDEF with NEWDEF for any keys in KEYMAP
     that were bound to OLDDEF.  In other words, OLDDEF is replaced with
     NEWDEF wherever it appears.  The function returns 'nil'.

     For example, this redefines 'C-x C-f', if you do it in an Emacs
     with standard bindings:

          (substitute-key-definition
           'find-file 'find-file-read-only (current-global-map))

     If OLDMAP is non-'nil', that changes the behavior of
     'substitute-key-definition': the bindings in OLDMAP determine which
     keys to rebind.  The rebindings still happen in KEYMAP, not in
     OLDMAP.  Thus, you can change one map under the control of the
     bindings in another.  For example,

          (substitute-key-definition
            'delete-backward-char 'my-funny-delete
            my-map global-map)

     puts the special deletion command in 'my-map' for whichever keys
     are globally bound to the standard deletion command.

     Here is an example showing a keymap before and after substitution:

          (setq map (list 'keymap
                          (cons ?1 olddef-1)
                          (cons ?2 olddef-2)
                          (cons ?3 olddef-1)))
          => (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))

          (substitute-key-definition 'olddef-1 'newdef map)
          => nil
          map
          => (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))

 -- Function: suppress-keymap keymap &optional nodigits
     This function changes the contents of the full keymap KEYMAP by
     remapping 'self-insert-command' to the command 'undefined' (*note
     Remapping Commands::).  This has the effect of undefining all
     printing characters, thus making ordinary insertion of text
     impossible.  'suppress-keymap' returns 'nil'.

     If NODIGITS is 'nil', then 'suppress-keymap' defines digits to run
     'digit-argument', and '-' to run 'negative-argument'.  Otherwise it
     makes them undefined like the rest of the printing characters.

     The 'suppress-keymap' function does not make it impossible to
     modify a buffer, as it does not suppress commands such as 'yank'
     and 'quoted-insert'.  To prevent any modification of a buffer, make
     it read-only (*note Read Only Buffers::).

     Since this function modifies KEYMAP, you would normally use it on a
     newly created keymap.  Operating on an existing keymap that is used
     for some other purpose is likely to cause trouble; for example,
     suppressing 'global-map' would make it impossible to use most of
     Emacs.

     This function can be used to initialize the local keymap of a major
     mode for which insertion of text is not desirable.  But usually
     such a mode should be derived from 'special-mode' (*note Basic
     Major Modes::); then its keymap will automatically inherit from
     'special-mode-map', which is already suppressed.  Here is how
     'special-mode-map' is defined:

          (defvar special-mode-map
            (let ((map (make-sparse-keymap)))
              (suppress-keymap map)
              (define-key map "q" 'quit-window)
              ...
              map))

==============================================================================
File: elisp.info,  Node: |Remapping_Commands|,  Next: |Translation_Keymaps|,  Prev: |Changing_Key_Bindings|,  Up: |Keymaps|
==============================================================================

                                                            *Remapping_Commands*

22.13 Remapping Commands
------------------------

A special kind of key binding can be used to "remap" one command to
another, without having to refer to the key sequence(s) bound to the
original command.  To use this feature, make a key binding for a key
sequence that starts with the dummy event 'remap', followed by the
command name you want to remap; for the binding, specify the new
definition (usually a command name, but possibly any other valid
definition for a key binding).

   For example, suppose My mode provides a special command
'my-kill-line', which should be invoked instead of 'kill-line'.  To
establish this, its mode keymap should contain the following remapping:

     (define-key my-mode-map [remap kill-line] 'my-kill-line)

Then, whenever 'my-mode-map' is active, if the user types 'C-k' (the
default global key sequence for 'kill-line') Emacs will instead run
'my-kill-line'.

   Note that remapping only takes place through active keymaps; for
example, putting a remapping in a prefix keymap like 'ctl-x-map'
typically has no effect, as such keymaps are not themselves active.  In
addition, remapping only works through a single level; in the following
example,

     (define-key my-mode-map [remap kill-line] 'my-kill-line)
     (define-key my-mode-map [remap my-kill-line] 'my-other-kill-line)

'kill-line' is _not_ remapped to 'my-other-kill-line'.  Instead, if an
ordinary key binding specifies 'kill-line', it is remapped to
'my-kill-line'; if an ordinary binding specifies 'my-kill-line', it is
remapped to 'my-other-kill-line'.

   To undo the remapping of a command, remap it to 'nil'; e.g.,

     (define-key my-mode-map [remap kill-line] nil)

 -- Function: command-remapping command &optional position keymaps
     This function returns the remapping for COMMAND (a symbol), given
     the current active keymaps.  If COMMAND is not remapped (which is
     the usual situation), or not a symbol, the function returns 'nil'.
     'position' can optionally specify a buffer position or an event
     position to determine the keymaps to use, as in 'key-binding'.

     If the optional argument 'keymaps' is non-'nil', it specifies a
     list of keymaps to search in.  This argument is ignored if
     'position' is non-'nil'.

==============================================================================
File: elisp.info,  Node: |Translation_Keymaps|,  Next: |Key_Binding_Commands|,  Prev: |Remapping_Commands|,  Up: |Keymaps|
==============================================================================

                                                           *Translation_Keymaps*

22.14 Keymaps for Translating Sequences of Events
-------------------------------------------------

When the 'read-key-sequence' function reads a key sequence (*note Key
Sequence Input::), it uses "translation keymaps" to translate certain
event sequences into others.  The translation keymaps are
'input-decode-map', 'local-function-key-map', and 'key-translation-map'
(in order of priority).

   Translation keymaps have the same structure as other keymaps, but are
used differently: they specify translations to make while reading key
sequences, rather than bindings for complete key sequences.  As each key
sequence is read, it is checked against each translation keymap.  If one
of the translation keymaps binds K to a vector V, then whenever K
appears as a sub-sequence _anywhere_ in a key sequence, that
sub-sequence is replaced with the events in V.

   For example, VT100 terminals send '<ESC> O P' when the keypad key
<PF1> is pressed.  On such terminals, Emacs must translate that sequence
of events into a single event 'pf1'.  This is done by binding '<ESC> O
P' to '[pf1]' in 'input-decode-map'.  Thus, when you type 'C-c <PF1>' on
the terminal, the terminal emits the character sequence 'C-c <ESC> O P',
and 'read-key-sequence' translates this back into 'C-c <PF1>' and
returns it as the vector '[?\C-c pf1]'.

   Translation keymaps take effect only after Emacs has decoded the
keyboard input (via the input coding system specified by
'keyboard-coding-system').  *Note Terminal I/O Encoding::.

 -- Variable: input-decode-map
     This variable holds a keymap that describes the character sequences
     sent by function keys on an ordinary character terminal.

     The value of 'input-decode-map' is usually set up automatically
     according to the terminal's Terminfo or Termcap entry, but
     sometimes those need help from terminal-specific Lisp files.  Emacs
     comes with terminal-specific files for many common terminals; their
     main purpose is to make entries in 'input-decode-map' beyond those
     that can be deduced from Termcap and Terminfo.  *Note
     Terminal-Specific::.

 -- Variable: local-function-key-map
     This variable holds a keymap similar to 'input-decode-map' except
     that it describes key sequences which should be translated to
     alternative interpretations that are usually preferred.  It applies
     after 'input-decode-map' and before 'key-translation-map'.

     Entries in 'local-function-key-map' are ignored if they conflict
     with bindings made in the minor mode, local, or global keymaps.
     I.e., the remapping only applies if the original key sequence would
     otherwise not have any binding.

     'local-function-key-map' inherits from 'function-key-map'.  The
     latter should only be altered if you want the binding to apply in
     all terminals, so using the former is almost always preferred.

 -- Variable: key-translation-map
     This variable is another keymap used just like 'input-decode-map'
     to translate input events into other events.  It differs from
     'input-decode-map' in that it goes to work after
     'local-function-key-map' is finished rather than before; it
     receives the results of translation by 'local-function-key-map'.

     Just like 'input-decode-map', but unlike 'local-function-key-map',
     this keymap is applied regardless of whether the input key-sequence
     has a normal binding.  Note however that actual key bindings can
     have an effect on 'key-translation-map', even though they are
     overridden by it.  Indeed, actual key bindings override
     'local-function-key-map' and thus may alter the key sequence that
     'key-translation-map' receives.  Clearly, it is better to avoid
     this type of situation.

     The intent of 'key-translation-map' is for users to map one
     character set to another, including ordinary characters normally
     bound to 'self-insert-command'.

   You can use 'input-decode-map', 'local-function-key-map', and
'key-translation-map' for more than simple aliases, by using a function,
instead of a key sequence, as the translation of a key.  Then this
function is called to compute the translation of that key.

   The key translation function receives one argument, which is the
prompt that was specified in 'read-key-sequence'--or 'nil' if the key
sequence is being read by the editor command loop.  In most cases you
can ignore the prompt value.

   If the function reads input itself, it can have the effect of
altering the event that follows.  For example, here's how to define 'C-c
h' to turn the character that follows into a Hyper character:

     (defun hyperify (prompt)
       (let ((e (read-event)))
         (vector (if (numberp e)
                     (logior (ash 1 24) e)
                   (if (memq 'hyper (event-modifiers e))
                       e
                     (add-event-modifier "H-" e))))))

     (defun add-event-modifier (string e)
       (let ((symbol (if (symbolp e) e (car e))))
         (setq symbol (intern (concat string
                                      (symbol-name symbol))))
         (if (symbolp e)
             symbol
           (cons symbol (cdr e)))))

     (define-key local-function-key-map "\C-ch" 'hyperify)

22.14.1 Interaction with normal keymaps
---------------------------------------

The end of a key sequence is detected when that key sequence either is
bound to a command, or when Emacs determines that no additional event
can lead to a sequence that is bound to a command.

   This means that, while 'input-decode-map' and 'key-translation-map'
apply regardless of whether the original key sequence would have a
binding, the presence of such a binding can still prevent translation
from taking place.  For example, let us return to our VT100 example
above and add a binding for 'C-c <ESC>' to the global map; now when the
user hits 'C-c <PF1>' Emacs will fail to decode 'C-c <ESC> O P' into
'C-c <PF1>' because it will stop reading keys right after 'C-x <ESC>',
leaving 'O P' for later.  This is in case the user really hit 'C-c
<ESC>', in which case Emacs should not sit there waiting for the next
key to decide whether the user really pressed '<ESC>' or '<PF1>'.

   For that reason, it is better to avoid binding commands to key
sequences where the end of the key sequence is a prefix of a key
translation.  The main such problematic suffixes/prefixes are '<ESC>',
'M-O' (which is really '<ESC> O') and 'M-[' (which is really '<ESC> [').

==============================================================================
File: elisp.info,  Node: |Key_Binding_Commands|,  Next: |Scanning_Keymaps|,  Prev: |Translation_Keymaps|,  Up: |Keymaps|
==============================================================================

                                                          *Key_Binding_Commands*

22.15 Commands for Binding Keys
-------------------------------

This section describes some convenient interactive interfaces for
changing key bindings.  They work by calling 'define-key'.

   People often use 'global-set-key' in their init files (*note Init
File::) for simple customization.  For example,

     (global-set-key (kbd "C-x C-\\") 'next-line)

or

     (global-set-key [?\C-x ?\C-\\] 'next-line)

or

     (global-set-key [(control ?x) (control ?\\)] 'next-line)

redefines 'C-x C-\' to move down a line.

     (global-set-key [M-mouse-1] 'mouse-set-point)

redefines the first (leftmost) mouse button, entered with the Meta key,
to set point where you click.

   Be careful when using non-ASCII text characters in Lisp
specifications of keys to bind.  If these are read as multibyte text, as
they usually will be in a Lisp file (*note Loading Non-ASCII::), you
must type the keys as multibyte too.  For instance, if you use this:

     (global-set-key "o"" 'my-function) ; bind o-umlaut

or

     (global-set-key ?o" 'my-function) ; bind o-umlaut

and your language environment is multibyte Latin-1, these commands
actually bind the multibyte character with code 246, not the byte code
246 ('M-v') sent by a Latin-1 terminal.  In order to use this binding,
you need to teach Emacs how to decode the keyboard by using an
appropriate input method (*note Input Methods: (emacs)Input Methods.).

 -- Command: global-set-key key binding
     This function sets the binding of KEY in the current global map to
     BINDING.

          (global-set-key KEY BINDING)
          ???
          (define-key (current-global-map) KEY BINDING)

 -- Command: global-unset-key key
     This function removes the binding of KEY from the current global
     map.

     One use of this function is in preparation for defining a longer
     key that uses KEY as a prefix--which would not be allowed if KEY has
     a non-prefix binding.  For example:

          (global-unset-key "\C-l")
              => nil
          (global-set-key "\C-l\C-l" 'redraw-display)
              => nil

     This function is equivalent to using 'define-key' as follows:

          (global-unset-key KEY)
          ???
          (define-key (current-global-map) KEY nil)

 -- Command: local-set-key key binding
     This function sets the binding of KEY in the current local keymap
     to BINDING.

          (local-set-key KEY BINDING)
          ???
          (define-key (current-local-map) KEY BINDING)

 -- Command: local-unset-key key
     This function removes the binding of KEY from the current local
     map.

          (local-unset-key KEY)
          ???
          (define-key (current-local-map) KEY nil)

==============================================================================
File: elisp.info,  Node: |Scanning_Keymaps|,  Next: |Menu_Keymaps|,  Prev: |Key_Binding_Commands|,  Up: |Keymaps|
==============================================================================

                                                              *Scanning_Keymaps*

22.16 Scanning Keymaps
----------------------

This section describes functions used to scan all the current keymaps
for the sake of printing help information.

 -- Function: accessible-keymaps keymap &optional prefix
     This function returns a list of all the keymaps that can be reached
     (via zero or more prefix keys) from KEYMAP.  The value is an
     association list with elements of the form '(KEY . MAP)', where KEY
     is a prefix key whose definition in KEYMAP is MAP.

     The elements of the alist are ordered so that the KEY increases in
     length.  The first element is always '([] . KEYMAP)', because the
     specified keymap is accessible from itself with a prefix of no
     events.

     If PREFIX is given, it should be a prefix key sequence; then
     'accessible-keymaps' includes only the submaps whose prefixes start
     with PREFIX.  These elements look just as they do in the value of
     '(accessible-keymaps)'; the only difference is that some elements
     are omitted.

     In the example below, the returned alist indicates that the key
     <ESC>, which is displayed as '^[', is a prefix key whose definition
     is the sparse keymap '(keymap (83 . center-paragraph) (115 .
     foo))'.

          (accessible-keymaps (current-local-map))
          =>(([] keymap
                (27 keymap   ; Note this keymap for <ESC> is repeated below.
                    (83 . center-paragraph)
                    (115 . center-line))
                (9 . tab-to-tab-stop))

             ("^[" keymap
              (83 . center-paragraph)
              (115 . foo)))

     In the following example, 'C-h' is a prefix key that uses a sparse
     keymap starting with '(keymap (118 . describe-variable)...)'.
     Another prefix, 'C-x 4', uses a keymap which is also the value of
     the variable 'ctl-x-4-map'.  The event 'mode-line' is one of
     several dummy events used as prefixes for mouse actions in special
     parts of a window.

          (accessible-keymaps (current-global-map))
          => (([] keymap [set-mark-command beginning-of-line ...
                             delete-backward-char])
              ("^H" keymap (118 . describe-variable) ...
               (8 . help-for-help))
              ("^X" keymap [x-flush-mouse-queue ...
               backward-kill-sentence])
              ("^[" keymap [mark-sexp backward-sexp ...
               backward-kill-word])
              ("^X4" keymap (15 . display-buffer) ...)
              ([mode-line] keymap
               (S-mouse-2 . mouse-split-window-horizontally) ...))

     These are not all the keymaps you would see in actuality.

 -- Function: map-keymap function keymap
     The function 'map-keymap' calls FUNCTION once for each binding in
     KEYMAP.  It passes two arguments, the event type and the value of
     the binding.  If KEYMAP has a parent, the parent's bindings are
     included as well.  This works recursively: if the parent has itself
     a parent, then the grandparent's bindings are also included and so
     on.

     This function is the cleanest way to examine all the bindings in a
     keymap.

 -- Function: where-is-internal command &optional keymap firstonly
          noindirect no-remap
     This function is a subroutine used by the 'where-is' command (*note
     Help: (emacs)Help.).  It returns a list of all key sequences (of
     any length) that are bound to COMMAND in a set of keymaps.

     The argument COMMAND can be any object; it is compared with all
     keymap entries using 'eq'.

     If KEYMAP is 'nil', then the maps used are the current active
     keymaps, disregarding 'overriding-local-map' (that is, pretending
     its value is 'nil').  If KEYMAP is a keymap, then the maps searched
     are KEYMAP and the global keymap.  If KEYMAP is a list of keymaps,
     only those keymaps are searched.

     Usually it's best to use 'overriding-local-map' as the expression
     for KEYMAP.  Then 'where-is-internal' searches precisely the
     keymaps that are active.  To search only the global map, pass the
     value '(keymap)' (an empty keymap) as KEYMAP.

     If FIRSTONLY is 'non-ascii', then the value is a single vector
     representing the first key sequence found, rather than a list of
     all possible key sequences.  If FIRSTONLY is 't', then the value is
     the first key sequence, except that key sequences consisting
     entirely of ASCII characters (or meta variants of ASCII characters)
     are preferred to all other key sequences and that the return value
     can never be a menu binding.

     If NOINDIRECT is non-'nil', 'where-is-internal' doesn't look inside
     menu-items to find their commands.  This makes it possible to
     search for a menu-item itself.

     The fifth argument, NO-REMAP, determines how this function treats
     command remappings (*note Remapping Commands::).  There are two
     cases of interest:

     If a command OTHER-COMMAND is remapped to COMMAND:
          If NO-REMAP is 'nil', find the bindings for OTHER-COMMAND and
          treat them as though they are also bindings for COMMAND.  If
          NO-REMAP is non-'nil', include the vector '[remap
          OTHER-COMMAND]' in the list of possible key sequences, instead
          of finding those bindings.

     If COMMAND is remapped to OTHER-COMMAND:
          If NO-REMAP is 'nil', return the bindings for OTHER-COMMAND
          rather than COMMAND.  If NO-REMAP is non-'nil', return the
          bindings for COMMAND, ignoring the fact that it is remapped.

 -- Command: describe-bindings &optional prefix buffer-or-name
     This function creates a listing of all current key bindings, and
     displays it in a buffer named 'Help'.  The text is grouped by
     modes--minor modes first, then the major mode, then global bindings.

     If PREFIX is non-'nil', it should be a prefix key; then the listing
     includes only keys that start with PREFIX.

     When several characters with consecutive ASCII codes have the same
     definition, they are shown together, as 'FIRSTCHAR..LASTCHAR'.  In
     this instance, you need to know the ASCII codes to understand which
     characters this means.  For example, in the default global map, the
     characters '<SPC> .. ~' are described by a single line.  <SPC> is
     ASCII 32, '~' is ASCII 126, and the characters between them include
     all the normal printing characters, (e.g., letters, digits,
     punctuation, etc.); all these characters are bound to
     'self-insert-command'.

     If BUFFER-OR-NAME is non-'nil', it should be a buffer or a buffer
     name.  Then 'describe-bindings' lists that buffer's bindings,
     instead of the current buffer's.

==============================================================================
File: elisp.info,  Node: |Menu_Keymaps|,  Prev: |Scanning_Keymaps|,  Up: |Keymaps|
==============================================================================

                                                                  *Menu_Keymaps*

22.17 Menu Keymaps
------------------

A keymap can operate as a menu as well as defining bindings for keyboard
keys and mouse buttons.  Menus are usually actuated with the mouse, but
they can function with the keyboard also.  If a menu keymap is active
for the next input event, that activates the keyboard menu feature.

MENU

* |Defining_Menus|::     How to make a keymap that defines a menu.
* |Mouse_Menus|::        How users actuate the menu with the mouse.
* |Keyboard_Menus|::     How users actuate the menu with the keyboard.
* |Menu_Example|::       Making a simple menu.
* |Menu_Bar|::           How to customize the menu bar.
* |Tool_Bar|::           A tool bar is a row of images.
* |Modifying_Menus|::    How to add new items to a menu.
* |Easy_Menu|::      A convenience macro for making menus.

==============================================================================
File: elisp.info,  Node: |Defining_Menus|,  Next: |Mouse_Menus|,  Up: |Menu_Keymaps|
==============================================================================

                                                                *Defining_Menus*

22.17.1 Defining Menus
----------------------

A keymap acts as a menu if it has an "overall prompt string", which is a
string that appears as an element of the keymap.  (*Note Format of
Keymaps::.)  The string should describe the purpose of the menu's
commands.  Emacs displays the overall prompt string as the menu title in
some cases, depending on the toolkit (if any) used for displaying
menus.(1)  Keyboard menus also display the overall prompt string.

   The easiest way to construct a keymap with a prompt string is to
specify the string as an argument when you call 'make-keymap',
'make-sparse-keymap' (*note Creating Keymaps::), or
'define-prefix-command' (*note Definition of define-prefix-command::).
If you do not want the keymap to operate as a menu, don't specify a
prompt string for it.

 -- Function: keymap-prompt keymap
     This function returns the overall prompt string of KEYMAP, or 'nil'
     if it has none.

   The menu's items are the bindings in the keymap.  Each binding
associates an event type to a definition, but the event types have no
significance for the menu appearance.  (Usually we use pseudo-events,
symbols that the keyboard cannot generate, as the event types for menu
item bindings.)  The menu is generated entirely from the bindings that
correspond in the keymap to these events.

   The order of items in the menu is the same as the order of bindings
in the keymap.  Since 'define-key' puts new bindings at the front, you
should define the menu items starting at the bottom of the menu and
moving to the top, if you care about the order.  When you add an item to
an existing menu, you can specify its position in the menu using
'define-key-after' (*note Modifying Menus::).

MENU

* |Simple_Menu_Items|::       A simple kind of menu key binding.
* |Extended_Menu_Items|::     More complex menu item definitions.
* |Menu_Separators|::         Drawing a horizontal line through a menu.
* |Alias_Menu_Items|::        Using command aliases in menu items.

   ---------- Footnotes ----------

   (1) It is required for menus which do not use a toolkit, e.g., on a
text terminal.

==============================================================================
File: elisp.info,  Node: |Simple_Menu_Items|,  Next: |Extended_Menu_Items|,  Up: Defining Menus
==============================================================================

                                                             *Simple_Menu_Items*

22.17.1.1 Simple Menu Items
---------------------------

The simpler (and original) way to define a menu item is to bind some
event type (it doesn't matter what event type) to a binding like this:

     (ITEM-STRING . REAL-BINDING)

The CAR, ITEM-STRING, is the string to be displayed in the menu.  It
should be short--preferably one to three words.  It should describe the
action of the command it corresponds to.  Note that not all graphical
toolkits can display non-ASCII text in menus (it will work for keyboard
menus and will work to a large extent with the GTK+ toolkit).

   You can also supply a second string, called the help string, as
follows:

     (ITEM-STRING HELP . REAL-BINDING)

HELP specifies a help-echo string to display while the mouse is on that
item in the same way as 'help-echo' text properties (*note Help
display::).

   As far as 'define-key' is concerned, ITEM-STRING and HELP-STRING are
part of the event's binding.  However, 'lookup-key' returns just
REAL-BINDING, and only REAL-BINDING is used for executing the key.

   If REAL-BINDING is 'nil', then ITEM-STRING appears in the menu but
cannot be selected.

   If REAL-BINDING is a symbol and has a non-'nil' 'menu-enable'
property, that property is an expression that controls whether the menu
item is enabled.  Every time the keymap is used to display a menu, Emacs
evaluates the expression, and it enables the menu item only if the
expression's value is non-'nil'.  When a menu item is disabled, it is
displayed in a fuzzy fashion, and cannot be selected.

   The menu bar does not recalculate which items are enabled every time
you look at a menu.  This is because the X toolkit requires the whole
tree of menus in advance.  To force recalculation of the menu bar, call
'force-mode-line-update' (*note Mode Line Format::).

==============================================================================
File: elisp.info,  Node: |Extended_Menu_Items|,  Next: |Menu_Separators|,  Prev: |Simple_Menu_Items|,  Up: |Defining_Menus|
==============================================================================

                                                           *Extended_Menu_Items*

22.17.1.2 Extended Menu Items
-----------------------------

An extended-format menu item is a more flexible and also cleaner
alternative to the simple format.  You define an event type with a
binding that's a list starting with the symbol 'menu-item'.  For a
non-selectable string, the binding looks like this:

     (menu-item ITEM-NAME)

A string starting with two or more dashes specifies a separator line;
see *note Menu Separators::.

   To define a real menu item which can be selected, the extended format
binding looks like this:

     (menu-item ITEM-NAME REAL-BINDING
         . ITEM-PROPERTY-LIST)

Here, ITEM-NAME is an expression which evaluates to the menu item
string.  Thus, the string need not be a constant.

   The third element, REAL-BINDING, can be the command to execute (in
which case you get a normal menu item).  It can also be a keymap, which
will result in a submenu.  Finally, it can be 'nil', in which case you
will get a non-selectable menu item.  This is mostly useful when
creating separator lines and the like.

   The tail of the list, ITEM-PROPERTY-LIST, has the form of a property
list which contains other information.

   Here is a table of the properties that are supported:

':enable FORM'
     The result of evaluating FORM determines whether the item is
     enabled (non-'nil' means yes).  If the item is not enabled, you
     can't really click on it.

':visible FORM'
     The result of evaluating FORM determines whether the item should
     actually appear in the menu (non-'nil' means yes).  If the item
     does not appear, then the menu is displayed as if this item were
     not defined at all.

':help HELP'
     The value of this property, HELP, specifies a help-echo string to
     display while the mouse is on that item.  This is displayed in the
     same way as 'help-echo' text properties (*note Help display::).
     Note that this must be a constant string, unlike the 'help-echo'
     property for text and overlays.

':button (TYPE . SELECTED)'
     This property provides a way to define radio buttons and toggle
     buttons.  The CAR, TYPE, says which: it should be ':toggle' or
     ':radio'.  The CDR, SELECTED, should be a form; the result of
     evaluating it says whether this button is currently selected.

     A "toggle" is a menu item which is labeled as either on or off
     according to the value of SELECTED.  The command itself should
     toggle SELECTED, setting it to 't' if it is 'nil', and to 'nil' if
     it is 't'.  Here is how the menu item to toggle the
     'debug-on-error' flag is defined:

          (menu-item "Debug on Error" toggle-debug-on-error
                     :button (:toggle
                              . (and (boundp 'debug-on-error)
                                     debug-on-error)))

     This works because 'toggle-debug-on-error' is defined as a command
     which toggles the variable 'debug-on-error'.

     "Radio buttons" are a group of menu items, in which at any time one
     and only one is selected.  There should be a variable whose value
     says which one is selected at any time.  The SELECTED form for each
     radio button in the group should check whether the variable has the
     right value for selecting that button.  Clicking on the button
     should set the variable so that the button you clicked on becomes
     selected.

':key-sequence KEY-SEQUENCE'
     This property specifies which key sequence to display as keyboard
     equivalent.  Before Emacs displays KEY-SEQUENCE in the menu, it
     verifies that KEY-SEQUENCE is really equivalent to this menu item,
     so it only has an effect if you specify a correct key sequence.
     Specifying 'nil' for KEY-SEQUENCE is equivalent to the
     ':key-sequence' attribute being absent.

':keys STRING'
     This property specifies that STRING is the string to display as the
     keyboard equivalent for this menu item.  You can use the '\\[...]'
     documentation construct in STRING.

':filter FILTER-FN'
     This property provides a way to compute the menu item dynamically.
     The property value FILTER-FN should be a function of one argument;
     when it is called, its argument will be REAL-BINDING.  The function
     should return the binding to use instead.

     Emacs can call this function at any time that it does redisplay or
     operates on menu data structures, so you should write it so it can
     safely be called at any time.

==============================================================================
File: elisp.info,  Node: |Menu_Separators|,  Next: |Alias_Menu_Items|,  Prev: |Extended_Menu_Items|,  Up: |Defining_Menus|
==============================================================================

                                                               *Menu_Separators*

22.17.1.3 Menu Separators
-------------------------

A menu separator is a kind of menu item that doesn't display any
text--instead, it divides the menu into subparts with a horizontal line.
A separator looks like this in the menu keymap:

     (menu-item SEPARATOR-TYPE)

where SEPARATOR-TYPE is a string starting with two or more dashes.

   In the simplest case, SEPARATOR-TYPE consists of only dashes.  That
specifies the default kind of separator.  (For compatibility, '""' and
'-' also count as separators.)

   Certain other values of SEPARATOR-TYPE specify a different style of
separator.  Here is a table of them:

'"--no-line"'
'"--space"'
     An extra vertical space, with no actual line.

'"--single-line"'
     A single line in the menu's foreground color.

'"--double-line"'
     A double line in the menu's foreground color.

'"--single-dashed-line"'
     A single dashed line in the menu's foreground color.

'"--double-dashed-line"'
     A double dashed line in the menu's foreground color.

'"--shadow-etched-in"'
     A single line with a 3D sunken appearance.  This is the default,
     used separators consisting of dashes only.

'"--shadow-etched-out"'
     A single line with a 3D raised appearance.

'"--shadow-etched-in-dash"'
     A single dashed line with a 3D sunken appearance.

'"--shadow-etched-out-dash"'
     A single dashed line with a 3D raised appearance.

'"--shadow-double-etched-in"'
     Two lines with a 3D sunken appearance.

'"--shadow-double-etched-out"'
     Two lines with a 3D raised appearance.

'"--shadow-double-etched-in-dash"'
     Two dashed lines with a 3D sunken appearance.

'"--shadow-double-etched-out-dash"'
     Two dashed lines with a 3D raised appearance.

   You can also give these names in another style, adding a colon after
the double-dash and replacing each single dash with capitalization of
the following word.  Thus, '"--:singleLine"', is equivalent to
'"--single-line"'.

   You can use a longer form to specify keywords such as ':enable' and
':visible' for a menu separator:

   '(menu-item SEPARATOR-TYPE nil . ITEM-PROPERTY-LIST)'

   For example:

     (menu-item "--" nil :visible (boundp 'foo))

   Some systems and display toolkits don't really handle all of these
separator types.  If you use a type that isn't supported, the menu
displays a similar kind of separator that is supported.

==============================================================================
File: elisp.info,  Node: |Alias_Menu_Items|,  Prev: |Menu_Separators|,  Up: |Defining_Menus|
==============================================================================

                                                              *Alias_Menu_Items*

22.17.1.4 Alias Menu Items
--------------------------

Sometimes it is useful to make menu items that use the same command but
with different enable conditions.  The best way to do this in Emacs now
is with extended menu items; before that feature existed, it could be
done by defining alias commands and using them in menu items.  Here's an
example that makes two aliases for 'read-only-mode' and gives them
different enable conditions:

     (defalias 'make-read-only 'read-only-mode)
     (put 'make-read-only 'menu-enable '(not buffer-read-only))
     (defalias 'make-writable 'read-only-mode)
     (put 'make-writable 'menu-enable 'buffer-read-only)

   When using aliases in menus, often it is useful to display the
equivalent key bindings for the real command name, not the aliases
(which typically don't have any key bindings except for the menu
itself).  To request this, give the alias symbol a non-'nil'
'menu-alias' property.  Thus,

     (put 'make-read-only 'menu-alias t)
     (put 'make-writable 'menu-alias t)

causes menu items for 'make-read-only' and 'make-writable' to show the
keyboard bindings for 'read-only-mode'.

==============================================================================
File: elisp.info,  Node: |Mouse_Menus|,  Next: |Keyboard_Menus|,  Prev: |Defining_Menus|,  Up: |Menu_Keymaps|
==============================================================================

                                                                   *Mouse_Menus*

22.17.2 Menus and the Mouse
---------------------------

The usual way to make a menu keymap produce a menu is to make it the
definition of a prefix key.  (A Lisp program can explicitly pop up a
menu and receive the user's choice--see *note Pop-Up Menus::.)

   If the prefix key ends with a mouse event, Emacs handles the menu
keymap by popping up a visible menu, so that the user can select a
choice with the mouse.  When the user clicks on a menu item, the event
generated is whatever character or symbol has the binding that brought
about that menu item.  (A menu item may generate a series of events if
the menu has multiple levels or comes from the menu bar.)

   It's often best to use a button-down event to trigger the menu.  Then
the user can select a menu item by releasing the button.

   If the menu keymap contains a binding to a nested keymap, the nested
keymap specifies a "submenu".  There will be a menu item, labeled by the
nested keymap's item string, and clicking on this item automatically
pops up the specified submenu.  As a special exception, if the menu
keymap contains a single nested keymap and no other menu items, the menu
shows the contents of the nested keymap directly, not as a submenu.

   However, if Emacs is compiled without X toolkit support, or on text
terminals, submenus are not supported.  Each nested keymap is shown as a
menu item, but clicking on it does not automatically pop up the submenu.
If you wish to imitate the effect of submenus, you can do that by giving
a nested keymap an item string which starts with '@'.  This causes Emacs
to display the nested keymap using a separate "menu pane"; the rest of
the item string after the '@' is the pane label.  If Emacs is compiled
without X toolkit support, or if a menu is displayed on a text terminal,
menu panes are not used; in that case, a '@' at the beginning of an item
string is omitted when the menu label is displayed, and has no other
effect.

==============================================================================
File: elisp.info,  Node: |Keyboard_Menus|,  Next: |Menu_Example|,  Prev: |Mouse_Menus|,  Up: |Menu_Keymaps|
==============================================================================

                                                                *Keyboard_Menus*

22.17.3 Menus and the Keyboard
------------------------------

When a prefix key ending with a keyboard event (a character or function
key) has a definition that is a menu keymap, the keymap operates as a
keyboard menu; the user specifies the next event by choosing a menu item
with the keyboard.

   Emacs displays the keyboard menu with the map's overall prompt
string, followed by the alternatives (the item strings of the map's
bindings), in the echo area.  If the bindings don't all fit at once, the
user can type <SPC> to see the next line of alternatives.  Successive
uses of <SPC> eventually get to the end of the menu and then cycle
around to the beginning.  (The variable 'menu-prompt-more-char'
specifies which character is used for this; <SPC> is the default.)

   When the user has found the desired alternative from the menu, he or
she should type the corresponding character--the one whose binding is
that alternative.

 -- Variable: menu-prompt-more-char
     This variable specifies the character to use to ask to see the next
     line of a menu.  Its initial value is 32, the code for <SPC>.

==============================================================================
File: elisp.info,  Node: |Menu_Example|,  Next: |Menu_Bar|,  Prev: |Keyboard_Menus|,  Up: |Menu_Keymaps|
==============================================================================

                                                                  *Menu_Example*

22.17.4 Menu Example
--------------------

Here is a complete example of defining a menu keymap.  It is the
definition of the 'Replace' submenu in the 'Edit' menu in the menu bar,
and it uses the extended menu item format (*note Extended Menu Items::).
First we create the keymap, and give it a name:

     (defvar menu-bar-replace-menu (make-sparse-keymap "Replace"))

Next we define the menu items:

     (define-key menu-bar-replace-menu [tags-repl-continue]
       '(menu-item "Continue Replace" multifile-continue
                   :help "Continue last tags replace operation"))
     (define-key menu-bar-replace-menu [tags-repl]
       '(menu-item "Replace in tagged files" tags-query-replace
                   :help "Interactively replace a regexp in all tagged files"))
     (define-key menu-bar-replace-menu [separator-replace-tags]
       '(menu-item "--"))
     ;; ...

Note the symbols which the bindings are made for; these appear inside
square brackets, in the key sequence being defined.  In some cases, this
symbol is the same as the command name; sometimes it is different.
These symbols are treated as function keys, but they are not real
function keys on the keyboard.  They do not affect the functioning of
the menu itself, but they are echoed in the echo area when the user
selects from the menu, and they appear in the output of 'where-is' and
'apropos'.

   The menu in this example is intended for use with the mouse.  If a
menu is intended for use with the keyboard, that is, if it is bound to a
key sequence ending with a keyboard event, then the menu items should be
bound to characters or real function keys, that can be typed with the
keyboard.

   The binding whose definition is '("--")' is a separator line.  Like a
real menu item, the separator has a key symbol, in this case
'separator-replace-tags'.  If one menu has two separators, they must
have two different key symbols.

   Here is how we make this menu appear as an item in the parent menu:

     (define-key menu-bar-edit-menu [replace]
       (list 'menu-item "Replace" menu-bar-replace-menu))

Note that this incorporates the submenu keymap, which is the value of
the variable 'menu-bar-replace-menu', rather than the symbol
'menu-bar-replace-menu' itself.  Using that symbol in the parent menu
item would be meaningless because 'menu-bar-replace-menu' is not a
command.

   If you wanted to attach the same replace menu to a mouse click, you
can do it this way:

     (define-key global-map [C-S-down-mouse-1]
        menu-bar-replace-menu)

==============================================================================
File: elisp.info,  Node: |Menu_Bar|,  Next: |Tool_Bar|,  Prev: |Menu_Example|,  Up: |Menu_Keymaps|
==============================================================================

                                                                      *Menu_Bar*

22.17.5 The Menu Bar
--------------------

Emacs usually shows a "menu bar" at the top of each frame.  *Note
(emacs)Menu Bars::.  Menu bar items are subcommands of the fake function
key <MENU-BAR>, as defined in the active keymaps.

   To add an item to the menu bar, invent a fake function key of your
own (let's call it KEY), and make a binding for the key sequence
'[menu-bar KEY]'.  Most often, the binding is a menu keymap, so that
pressing a button on the menu bar item leads to another menu.

   When more than one active keymap defines the same function key for
the menu bar, the item appears just once.  If the user clicks on that
menu bar item, it brings up a single, combined menu containing all the
subcommands of that item--the global subcommands, the local subcommands,
and the minor mode subcommands.

   The variable 'overriding-local-map' is normally ignored when
determining the menu bar contents.  That is, the menu bar is computed
from the keymaps that would be active if 'overriding-local-map' were
'nil'.  *Note Active Keymaps::.

   Here's an example of setting up a menu bar item:

     ;; Make a menu keymap (with a prompt string)
     ;; and make it the menu bar item's definition.
     (define-key global-map [menu-bar words]
       (cons "Words" (make-sparse-keymap "Words")))

     ;; Define specific subcommands in this menu.
     (define-key global-map
       [menu-bar words forward]
       '("Forward word" . forward-word))
     (define-key global-map
       [menu-bar words backward]
       '("Backward word" . backward-word))

   A local keymap can cancel a menu bar item made by the global keymap
by rebinding the same fake function key with 'undefined' as the binding.
For example, this is how Dired suppresses the 'Edit' menu bar item:

     (define-key dired-mode-map [menu-bar edit] 'undefined)

Here, 'edit' is the symbol produced by a fake function key, it is used
by the global map for the 'Edit' menu bar item.  The main reason to
suppress a global menu bar item is to regain space for mode-specific
items.

 -- Variable: menu-bar-final-items
     Normally the menu bar shows global items followed by items defined
     by the local maps.

     This variable holds a list of fake function keys for items to
     display at the end of the menu bar rather than in normal sequence.
     The default value is '(help-menu)'; thus, the 'Help' menu item
     normally appears at the end of the menu bar, following local menu
     items.

 -- Variable: menu-bar-update-hook
     This normal hook is run by redisplay to update the menu bar
     contents, before redisplaying the menu bar.  You can use it to
     update menus whose contents should vary.  Since this hook is run
     frequently, we advise you to ensure that the functions it calls do
     not take much time in the usual case.

   Next to every menu bar item, Emacs displays a key binding that runs
the same command (if such a key binding exists).  This serves as a
convenient hint for users who do not know the key binding.  If a command
has multiple bindings, Emacs normally displays the first one it finds.
You can specify one particular key binding by assigning an
':advertised-binding' symbol property to the command.  *Note Keys in
Documentation::.

==============================================================================
File: elisp.info,  Node: |Tool_Bar|,  Next: |Modifying_Menus|,  Prev: |Menu_Bar|,  Up: |Menu_Keymaps|
==============================================================================

                                                                      *Tool_Bar*

22.17.6 Tool bars
-----------------

A "tool bar" is a row of clickable icons at the top of a frame, just
below the menu bar.  *Note (emacs)Tool Bars::.  Emacs normally shows a
tool bar on graphical displays.

   On each frame, the frame parameter 'tool-bar-lines' controls how many
lines' worth of height to reserve for the tool bar.  A zero value
suppresses the tool bar.  If the value is nonzero, and
'auto-resize-tool-bars' is non-'nil', the tool bar expands and contracts
automatically as needed to hold the specified contents.  If the value is
'grow-only', the tool bar expands automatically, but does not contract
automatically.

   The tool bar contents are controlled by a menu keymap attached to a
fake function key called <TOOL-BAR> (much like the way the menu bar is
controlled).  So you define a tool bar item using 'define-key', like
this:

     (define-key global-map [tool-bar KEY] ITEM)

where KEY is a fake function key to distinguish this item from other
items, and ITEM is a menu item key binding (*note Extended Menu
Items::), which says how to display this item and how it behaves.

   The usual menu keymap item properties, ':visible', ':enable',
':button', and ':filter', are useful in tool bar bindings and have their
normal meanings.  The REAL-BINDING in the item must be a command, not a
keymap; in other words, it does not work to define a tool bar icon as a
prefix key.

   The ':help' property specifies a help-echo string to display while
the mouse is on that item.  This is displayed in the same way as
'help-echo' text properties (*note Help display::).

   In addition, you should use the ':image' property; this is how you
specify the image to display in the tool bar:

':image IMAGE'
     IMAGE is either a single image specification (*note Images::) or a
     vector of four image specifications.  If you use a vector of four,
     one of them is used, depending on circumstances:

     item 0
          Used when the item is enabled and selected.
     item 1
          Used when the item is enabled and deselected.
     item 2
          Used when the item is disabled and selected.
     item 3
          Used when the item is disabled and deselected.

   The GTK+ and NS versions of Emacs ignores items 1 to 3, because
disabled and/or deselected images are autocomputed from item 0.

   If IMAGE is a single image specification, Emacs draws the tool bar
button in disabled state by applying an edge-detection algorithm to the
image.

   The ':rtl' property specifies an alternative image to use for
right-to-left languages.  Only the GTK+ version of Emacs supports this
at present.

   Like the menu bar, the tool bar can display separators (*note Menu
Separators::).  Tool bar separators are vertical rather than horizontal,
though, and only a single style is supported.  They are represented in
the tool bar keymap by '(menu-item "--")' entries; properties like
':visible' are not supported for tool bar separators.  Separators are
rendered natively in GTK+ and Nextstep tool bars; in the other cases,
they are rendered using an image of a vertical line.

   The default tool bar is defined so that items specific to editing do
not appear for major modes whose command symbol has a 'mode-class'
property of 'special' (*note Major Mode Conventions::).  Major modes may
add items to the global bar by binding '[tool-bar FOO]' in their local
map.  It makes sense for some major modes to replace the default tool
bar items completely, since not many can be accommodated conveniently,
and the default bindings make this easy by using an indirection through
'tool-bar-map'.

 -- Variable: tool-bar-map
     By default, the global map binds '[tool-bar]' as follows:

          (global-set-key [tool-bar]
                          `(menu-item ,(purecopy "tool bar") ignore
                                      :filter tool-bar-make-keymap))

     The function 'tool-bar-make-keymap', in turn, derives the actual
     tool bar map dynamically from the value of the variable
     'tool-bar-map'.  Hence, you should normally adjust the default
     (global) tool bar by changing that map.  Some major modes, such as
     Info mode, completely replace the global tool bar by making
     'tool-bar-map' buffer-local and setting it to a different keymap.

   There are two convenience functions for defining tool bar items, as
follows.

 -- Function: tool-bar-add-item icon def key &rest props
     This function adds an item to the tool bar by modifying
     'tool-bar-map'.  The image to use is defined by ICON, which is the
     base name of an XPM, XBM or PBM image file to be located by
     'find-image'.  Given a value '"exit"', say, 'exit.xpm', 'exit.pbm'
     and 'exit.xbm' would be searched for in that order on a color
     display.  On a monochrome display, the search order is '.pbm',
     '.xbm' and '.xpm'.  The binding to use is the command DEF, and KEY
     is the fake function key symbol in the prefix keymap.  The
     remaining arguments PROPS are additional property list elements to
     add to the menu item specification.

     To define items in some local map, bind 'tool-bar-map' with 'let'
     around calls of this function:
          (defvar foo-tool-bar-map
            (let ((tool-bar-map (make-sparse-keymap)))
              (tool-bar-add-item ...)
              ...
              tool-bar-map))

 -- Function: tool-bar-add-item-from-menu command icon &optional map
          &rest props
     This function is a convenience for defining tool bar items which
     are consistent with existing menu bar bindings.  The binding of
     COMMAND is looked up in the menu bar in MAP (default 'global-map')
     and modified to add an image specification for ICON, which is found
     in the same way as by 'tool-bar-add-item'.  The resulting binding
     is then placed in 'tool-bar-map', so use this function only for
     global tool bar items.

     MAP must contain an appropriate keymap bound to '[menu-bar]'.  The
     remaining arguments PROPS are additional property list elements to
     add to the menu item specification.

 -- Function: tool-bar-local-item-from-menu command icon in-map
          &optional from-map &rest props
     This function is used for making non-global tool bar items.  Use it
     like 'tool-bar-add-item-from-menu' except that IN-MAP specifies the
     local map to make the definition in.  The argument FROM-MAP is like
     the MAP argument of 'tool-bar-add-item-from-menu'.

 -- Variable: auto-resize-tool-bars
     If this variable is non-'nil', the tool bar automatically resizes
     to show all defined tool bar items--but not larger than a quarter of
     the frame's height.

     If the value is 'grow-only', the tool bar expands automatically,
     but does not contract automatically.  To contract the tool bar, the
     user has to redraw the frame by entering 'C-l'.

     If Emacs is built with GTK+ or Nextstep, the tool bar can only show
     one line, so this variable has no effect.

 -- Variable: auto-raise-tool-bar-buttons
     If this variable is non-'nil', tool bar items display in raised
     form when the mouse moves over them.

 -- Variable: tool-bar-button-margin
     This variable specifies an extra margin to add around tool bar
     items.  The value is an integer, a number of pixels.  The default
     is 4.

 -- Variable: tool-bar-button-relief
     This variable specifies the shadow width for tool bar items.  The
     value is an integer, a number of pixels.  The default is 1.

 -- Variable: tool-bar-border
     This variable specifies the height of the border drawn below the
     tool bar area.  An integer specifies height as a number of pixels.
     If the value is one of 'internal-border-width' (the default) or
     'border-width', the tool bar border height corresponds to the
     corresponding frame parameter.

   You can define a special meaning for clicking on a tool bar item with
the shift, control, meta, etc., modifiers.  You do this by setting up
additional items that relate to the original item through the fake
function keys.  Specifically, the additional items should use the
modified versions of the same fake function key used to name the
original item.

   Thus, if the original item was defined this way,

     (define-key global-map [tool-bar shell]
       '(menu-item "Shell" shell
                   :image (image :type xpm :file "shell.xpm")))

then here is how you can define clicking on the same tool bar image with
the shift modifier:

     (define-key global-map [tool-bar S-shell] 'some-command)

   *Note Function Keys::, for more information about how to add
modifiers to function keys.

==============================================================================
File: elisp.info,  Node: |Modifying_Menus|,  Next: |Easy_Menu|,  Prev: |Tool_Bar|,  Up: |Menu_Keymaps|
==============================================================================

                                                               *Modifying_Menus*

22.17.7 Modifying Menus
-----------------------

When you insert a new item in an existing menu, you probably want to put
it in a particular place among the menu's existing items.  If you use
'define-key' to add the item, it normally goes at the front of the menu.
To put it elsewhere in the menu, use 'define-key-after':

 -- Function: define-key-after map key binding &optional after
     Define a binding in MAP for KEY, with value BINDING, just like
     'define-key', but position the binding in MAP after the binding for
     the event AFTER.  The argument KEY should be of length one--a vector
     or string with just one element.  But AFTER should be a single
     event type--a symbol or a character, not a sequence.  The new
     binding goes after the binding for AFTER.  If AFTER is 't' or is
     omitted, then the new binding goes last, at the end of the keymap.
     However, new bindings are added before any inherited keymap.

     Here is an example:

          (define-key-after my-menu [drink]
            '("Drink" . drink-command) 'eat)

     makes a binding for the fake function key <DRINK> and puts it right
     after the binding for <EAT>.

     Here is how to insert an item called 'Work' in the 'Signals' menu
     of Shell mode, after the item 'break':

          (define-key-after
            (lookup-key shell-mode-map [menu-bar signals])
            [work] '("Work" . work-command) 'break)

==============================================================================
File: elisp.info,  Node: |Easy_Menu|,  Prev: |Modifying_Menus|,  Up: |Menu_Keymaps|
==============================================================================

                                                                     *Easy_Menu*

22.17.8 Easy Menu
-----------------

The following macro provides a convenient way to define pop-up menus
and/or menu bar menus.

 -- Macro: easy-menu-define symbol maps doc menu
     This macro defines a pop-up menu and/or menu bar submenu, whose
     contents are given by MENU.

     If SYMBOL is non-'nil', it should be a symbol; then this macro
     defines SYMBOL as a function for popping up the menu (*note Pop-Up
     Menus::), with DOC as its documentation string.  SYMBOL should not
     be quoted.

     Regardless of the value of SYMBOL, if MAPS is a keymap, the menu is
     added to that keymap, as a top-level menu for the menu bar (*note
     Menu Bar::).  It can also be a list of keymaps, in which case the
     menu is added separately to each of those keymaps.

     The first element of MENU must be a string, which serves as the
     menu label.  It may be followed by any number of the following
     keyword-argument pairs:

     ':filter FUNCTION'
          FUNCTION must be a function which, if called with one
          argument--the list of the other menu items--returns the actual
          items to be displayed in the menu.

     ':visible INCLUDE'
          INCLUDE is an expression; if it evaluates to 'nil', the menu
          is made invisible.  ':included' is an alias for ':visible'.

     ':active ENABLE'
          ENABLE is an expression; if it evaluates to 'nil', the menu is
          not selectable.  ':enable' is an alias for ':active'.

     The remaining elements in MENU are menu items.

     A menu item can be a vector of three elements, '[NAME CALLBACK
     ENABLE]'.  NAME is the menu item name (a string).  CALLBACK is a
     command to run, or an expression to evaluate, when the item is
     chosen.  ENABLE is an expression; if it evaluates to 'nil', the
     item is disabled for selection.

     Alternatively, a menu item may have the form:

             [ NAME CALLBACK [ KEYWORD ARG ]... ]

     where NAME and CALLBACK have the same meanings as above, and each
     optional KEYWORD and ARG pair should be one of the following:

     ':keys KEYS'
          KEYS is a string to display as keyboard equivalent to the menu
          item.  This is normally not needed, as keyboard equivalents
          are computed automatically.  KEYS is expanded with
          'substitute-command-keys' before it is displayed (*note Keys
          in Documentation::).

     ':key-sequence KEYS'
          KEYS is a hint indicating which key sequence to display as
          keyboard equivalent, in case the command is bound to several
          key sequences.  It has no effect if KEYS is not bound to same
          command as this menu item.

     ':active ENABLE'
          ENABLE is an expression; if it evaluates to 'nil', the item is
          make unselectable..  ':enable' is an alias for ':active'.

     ':visible INCLUDE'
          INCLUDE is an expression; if it evaluates to 'nil', the item
          is made invisible.  ':included' is an alias for ':visible'.

     ':label FORM'
          FORM is an expression that is evaluated to obtain a value
          which serves as the menu item's label (the default is NAME).

     ':suffix FORM'
          FORM is an expression that is dynamically evaluated and whose
          value is concatenated with the menu entry's label.

     ':style STYLE'
          STYLE is a symbol describing the type of menu item; it should
          be 'toggle' (a checkbox), or 'radio' (a radio button), or
          anything else (meaning an ordinary menu item).

     ':selected SELECTED'
          SELECTED is an expression; the checkbox or radio button is
          selected whenever the expression's value is non-'nil'.

     ':help HELP'
          HELP is a string describing the menu item.

     Alternatively, a menu item can be a string.  Then that string
     appears in the menu as unselectable text.  A string consisting of
     dashes is displayed as a separator (*note Menu Separators::).

     Alternatively, a menu item can be a list with the same format as
     MENU.  This is a submenu.

   Here is an example of using 'easy-menu-define' to define a menu
similar to the one defined in the example in *note Menu Bar:::

     (easy-menu-define words-menu global-map
       "Menu for word navigation commands."
       '("Words"
          ["Forward word" forward-word]
          ["Backward word" backward-word]))

==============================================================================
File: elisp.info,  Node: |Modes|,  Next: |Documentation|,  Prev: |Keymaps|,  Up: |Top|
==============================================================================

                                                                         *Modes*

23 Major and Minor Modes
========================

A "mode" is a set of definitions that customize Emacs behavior in useful
ways.  There are two varieties of modes: "minor modes", which provide
features that users can turn on and off while editing; and "major
modes", which are used for editing or interacting with a particular kind
of text.  Each buffer has exactly one "major mode" at a time.

   This chapter describes how to write both major and minor modes, how
to indicate them in the mode line, and how they run hooks supplied by
the user.  For related topics such as keymaps and syntax tables, see
*note Keymaps::, and *note Syntax Tables::.

MENU

* |Hooks|::             How to use hooks; how to write code that provides hooks.
* |Major_Modes|::       Defining major modes.
* |Minor_Modes|::       Defining minor modes.
* |Mode_Line_Format|::  Customizing the text that appears in the mode line.
* |Imenu|::             Providing a menu of definitions made in a buffer.
* |Font_Lock_Mode|::    How modes can highlight text according to syntax.
* |Auto_Indentation|::  How to teach Emacs to indent for a major mode.
* |Desktop_Save_Mode|:: How modes can have buffer state saved between
                        Emacs sessions.

==============================================================================
File: elisp.info,  Node: |Hooks|,  Next: |Major_Modes|,  Up: |Modes|
==============================================================================

                                                                         *Hooks*

23.1 Hooks
----------

A "hook" is a variable where you can store a function or functions to be
called on a particular occasion by an existing program.  Emacs provides
hooks for the sake of customization.  Most often, hooks are set up in
the init file (*note Init File::), but Lisp programs can set them also.
*Note Standard Hooks::, for a list of some standard hook variables.

   Most of the hooks in Emacs are "normal hooks".  These variables
contain lists of functions to be called with no arguments.  By
convention, whenever the hook name ends in '-hook', that tells you it is
normal.  We try to make all hooks normal, as much as possible, so that
you can use them in a uniform way.

   Every major mode command is supposed to run a normal hook called the
"mode hook" as one of the last steps of initialization.  This makes it
easy for a user to customize the behavior of the mode, by overriding the
buffer-local variable assignments already made by the mode.  Most minor
mode functions also run a mode hook at the end.  But hooks are used in
other contexts too.  For example, the hook 'suspend-hook' runs just
before Emacs suspends itself (*note Suspending Emacs::).

   The recommended way to add a hook function to a hook is by calling
'add-hook' (*note Setting Hooks::).  The hook functions may be any of
the valid kinds of functions that 'funcall' accepts (*note What Is a
Function::).  Most normal hook variables are initially void; 'add-hook'
knows how to deal with this.  You can add hooks either globally or
buffer-locally with 'add-hook'.

   If the hook variable's name does not end with '-hook', that indicates
it is probably an "abnormal hook".  That means the hook functions are
called with arguments, or their return values are used in some way.  The
hook's documentation says how the functions are called.  You can use
'add-hook' to add a function to an abnormal hook, but you must write the
function to follow the hook's calling convention.  By convention,
abnormal hook names end in '-functions'.

   If the variable's name ends in '-function', then its value is just a
single function, not a list of functions.  'add-hook' cannot be used to
modify such a _single function hook_, and you have to use 'add-function'
instead (*note Advising Functions::).

MENU

* |Running_Hooks|::    How to run a hook.
* |Setting_Hooks|::    How to put functions on a hook, or remove them.

==============================================================================
File: elisp.info,  Node: |Running_Hooks|,  Next: |Setting_Hooks|,  Up: Hooks
==============================================================================

                                                                 *Running_Hooks*

23.1.1 Running Hooks
--------------------

In this section, we document the 'run-hooks' function, which is used to
run a normal hook.  We also document the functions for running various
kinds of abnormal hooks.

 -- Function: run-hooks &rest hookvars
     This function takes one or more normal hook variable names as
     arguments, and runs each hook in turn.  Each argument should be a
     symbol that is a normal hook variable.  These arguments are
     processed in the order specified.

     If a hook variable has a non-'nil' value, that value should be a
     list of functions.  'run-hooks' calls all the functions, one by
     one, with no arguments.

     The hook variable's value can also be a single function--either a
     lambda expression or a symbol with a function definition--which
     'run-hooks' calls.  But this usage is obsolete.

     If the hook variable is buffer-local, the buffer-local variable
     will be used instead of the global variable.  However, if the
     buffer-local variable contains the element 't', the global hook
     variable will be run as well.

 -- Function: run-hook-with-args hook &rest args
     This function runs an abnormal hook by calling all the hook
     functions in HOOK, passing each one the arguments ARGS.

 -- Function: run-hook-with-args-until-failure hook &rest args
     This function runs an abnormal hook by calling each hook function
     in turn, stopping if one of them fails by returning 'nil'.  Each
     hook function is passed the arguments ARGS.  If this function stops
     because one of the hook functions fails, it returns 'nil';
     otherwise it returns a non-'nil' value.

 -- Function: run-hook-with-args-until-success hook &rest args
     This function runs an abnormal hook by calling each hook function,
     stopping if one of them succeeds by returning a non-'nil' value.
     Each hook function is passed the arguments ARGS.  If this function
     stops because one of the hook functions returns a non-'nil' value,
     it returns that value; otherwise it returns 'nil'.

==============================================================================
File: elisp.info,  Node: |Setting_Hooks|,  Prev: |Running_Hooks|,  Up: |Hooks|
==============================================================================

                                                                 *Setting_Hooks*

23.1.2 Setting Hooks
--------------------

Here's an example that adds a function to a mode hook to turn on Auto
Fill mode when in Lisp Interaction mode:

     (add-hook 'lisp-interaction-mode-hook 'auto-fill-mode)

   The value of a hook variable should be a list of functions.  You can
manipulate that list using the normal Lisp facilities, but the modular
way is to use the functions 'add-hook' and 'remove-hook', defined below.
They take care to handle some unusual situations and avoid problems.

   It works to put a 'lambda'-expression function on a hook, but we
recommend avoiding this because it can lead to confusion.  If you add
the same 'lambda'-expression a second time but write it slightly
differently, you will get two equivalent but distinct functions on the
hook.  If you then remove one of them, the other will still be on it.

 -- Function: add-hook hook function &optional depth local
     This function is the handy way to add function FUNCTION to hook
     variable HOOK.  You can use it for abnormal hooks as well as for
     normal hooks.  FUNCTION can be any Lisp function that can accept
     the proper number of arguments for HOOK.  For example,

          (add-hook 'text-mode-hook 'my-text-hook-function)

     adds 'my-text-hook-function' to the hook called 'text-mode-hook'.

     If FUNCTION is already present in HOOK (comparing using 'equal'),
     then 'add-hook' does not add it a second time.

     If FUNCTION has a non-'nil' property 'permanent-local-hook', then
     'kill-all-local-variables' (or changing major modes) won't delete
     it from the hook variable's local value.

     For a normal hook, hook functions should be designed so that the
     order in which they are executed does not matter.  Any dependence
     on the order is asking for trouble.  However, the order is
     predictable: normally, FUNCTION goes at the front of the hook list,
     so it is executed first (barring another 'add-hook' call).

     In some cases, it is important to control the relative ordering of
     functions on the hook.  The optional argument DEPTH lets you
     indicate where the function should be inserted in the list: it
     should then be a number between -100 and 100 where the higher the
     value, the closer to the end of the list the function should go.
     The DEPTH defaults to 0 and for backward compatibility when DEPTH
     is a non-nil symbol it is interpreted as a depth of 90.
     Furthermore, when DEPTH is strictly greater than 0 the function is
     added _after_ rather than before functions of the same depth.  One
     should never use a depth of 100 (or -100), because one can never be
     sure that no other function will ever need to come before (or
     after) us.

     'add-hook' can handle the cases where HOOK is void or its value is
     a single function; it sets or changes the value to a list of
     functions.

     If LOCAL is non-'nil', that says to add FUNCTION to the
     buffer-local hook list instead of to the global hook list.  This
     makes the hook buffer-local and adds 't' to the buffer-local value.
     The latter acts as a flag to run the hook functions in the default
     value as well as in the local value.

 -- Function: remove-hook hook function &optional local
     This function removes FUNCTION from the hook variable HOOK.  It
     compares FUNCTION with elements of HOOK using 'equal', so it works
     for both symbols and lambda expressions.

     If LOCAL is non-'nil', that says to remove FUNCTION from the
     buffer-local hook list instead of from the global hook list.

==============================================================================
File: elisp.info,  Node: |Major_Modes|,  Next: |Minor_Modes|,  Prev: |Hooks|,  Up: |Modes|
==============================================================================

                                                                   *Major_Modes*

23.2 Major Modes
----------------

Major modes specialize Emacs for editing or interacting with particular
kinds of text.  Each buffer has exactly one major mode at a time.  Every
major mode is associated with a "major mode command", whose name should
end in '-mode'.  This command takes care of switching to that mode in
the current buffer, by setting various buffer-local variables such as a
local keymap.  *Note Major Mode Conventions::.  Note that unlike minor
modes there is no way to "turn off" a major mode, instead the buffer
must be switched to a different one.  However, you can temporarily
"suspend" a major mode and later "restore" the suspended mode, see
below.

   The least specialized major mode is called "Fundamental mode", which
has no mode-specific definitions or variable settings.

 -- Command: fundamental-mode
     This is the major mode command for Fundamental mode.  Unlike other
     mode commands, it does _not_ run any mode hooks (*note Major Mode
     Conventions::), since you are not supposed to customize this mode.

 -- Function: major-mode-suspend
     This function works like 'fundamental-mode', in that it kills all
     buffer-local variables, but it also records the major mode in
     effect, so that it could subsequently be restored.  This function
     and 'major-mode-restore' (described next) are useful when you need
     to put a buffer under some specialized mode other than the one
     Emacs chooses for it automatically (*note Auto Major Mode::), but
     would also like to be able to switch back to the original mode
     later.

 -- Function: major-mode-restore &optional avoided-modes
     This function restores the major mode recorded by
     'major-mode-suspend'.  If no major mode was recorded, this function
     calls 'normal-mode' (*note normal-mode: Auto Major Mode.), but
     tries to force it not to choose any modes in AVOIDED-MODES, if that
     argument is non-'nil'.

   The easiest way to write a major mode is to use the macro
'define-derived-mode', which sets up the new mode as a variant of an
existing major mode.  *Note Derived Modes::.  We recommend using
'define-derived-mode' even if the new mode is not an obvious derivative
of another mode, as it automatically enforces many coding conventions
for you.  *Note Basic Major Modes::, for common modes to derive from.

   The standard GNU Emacs Lisp directory tree contains the code for
several major modes, in files such as 'text-mode.el', 'texinfo.el',
'lisp-mode.el', and 'rmail.el'.  You can study these libraries to see
how modes are written.

 -- User Option: major-mode
     The buffer-local value of this variable holds the symbol for the
     current major mode.  Its default value holds the default major mode
     for new buffers.  The standard default value is 'fundamental-mode'.

     If the default value is 'nil', then whenever Emacs creates a new
     buffer via a command such as 'C-x b' ('switch-to-buffer'), the new
     buffer is put in the major mode of the previously current buffer.
     As an exception, if the major mode of the previous buffer has a
     'mode-class' symbol property with value 'special', the new buffer
     is put in Fundamental mode (*note Major Mode Conventions::).

MENU

* |Major_Mode_Conventions|::  Coding conventions for keymaps, etc.
* |Auto_Major_Mode|::         How Emacs chooses the major mode automatically.
* |Mode_Help|::               Finding out how to use a mode.
* |Derived_Modes|::           Defining a new major mode based on another major
                              mode.
* |Basic_Major_Modes|::       Modes that other modes are often derived from.
* |Mode_Hooks|::              Hooks run at the end of major mode functions.
* |Tabulated_List_Mode|::     Parent mode for buffers containing tabulated data.
* |Generic_Modes|::           Defining a simple major mode that supports
                              comment syntax and Font Lock mode.
* |Example_Major_Modes|::     Text mode and Lisp modes.

==============================================================================
File: elisp.info,  Node: |Major_Mode_Conventions|,  Next: |Auto_Major_Mode|,  Up: |Major_Modes|
==============================================================================

                                                        *Major_Mode_Conventions*

23.2.1 Major Mode Conventions
-----------------------------

The code for every major mode should follow various coding conventions,
including conventions for local keymap and syntax table initialization,
function and variable names, and hooks.

   If you use the 'define-derived-mode' macro, it will take care of many
of these conventions automatically.  *Note Derived Modes::.  Note also
that Fundamental mode is an exception to many of these conventions,
because it represents the default state of Emacs.

   The following list of conventions is only partial.  Each major mode
should aim for consistency in general with other Emacs major modes, as
this makes Emacs as a whole more coherent.  It is impossible to list
here all the possible points where this issue might come up; if the
Emacs developers point out an area where your major mode deviates from
the usual conventions, please make it compatible.

   * Define a major mode command whose name ends in '-mode'.  When
     called with no arguments, this command should switch to the new
     mode in the current buffer by setting up the keymap, syntax table,
     and buffer-local variables in an existing buffer.  It should not
     change the buffer's contents.

   * Write a documentation string for this command that describes the
     special commands available in this mode.  *Note Mode Help::.

     The documentation string may include the special documentation
     substrings, '\[COMMAND]', '\{KEYMAP}', and '\<KEYMAP>', which allow
     the help display to adapt automatically to the user's own key
     bindings.  *Note Keys in Documentation::.

   * The major mode command should start by calling
     'kill-all-local-variables'.  This runs the normal hook
     'change-major-mode-hook', then gets rid of the buffer-local
     variables of the major mode previously in effect.  *Note Creating
     Buffer-Local::.

   * The major mode command should set the variable 'major-mode' to the
     major mode command symbol.  This is how 'describe-mode' discovers
     which documentation to print.

   * The major mode command should set the variable 'mode-name' to the
     "pretty" name of the mode, usually a string (but see *note Mode
     Line Data::, for other possible forms).  The name of the mode
     appears in the mode line.

   * Calling the major mode command twice in direct succession should
     not fail and should do the same thing as calling the command only
     once.  In other words, the major mode command should be idempotent.

   * Since all global names are in the same name space, all the global
     variables, constants, and functions that are part of the mode
     should have names that start with the major mode name (or with an
     abbreviation of it if the name is long).  *Note Coding
     Conventions::.

   * In a major mode for editing some kind of structured text, such as a
     programming language, indentation of text according to structure is
     probably useful.  So the mode should set 'indent-line-function' to
     a suitable function, and probably customize other variables for
     indentation.  *Note Auto-Indentation::.

   * The major mode should usually have its own keymap, which is used as
     the local keymap in all buffers in that mode.  The major mode
     command should call 'use-local-map' to install this local map.
     *Note Active Keymaps::, for more information.

     This keymap should be stored permanently in a global variable named
     'MODENAME-mode-map'.  Normally the library that defines the mode
     sets this variable.

     *Note Tips for Defining::, for advice about how to write the code
     to set up the mode's keymap variable.

   * The key sequences bound in a major mode keymap should usually start
     with 'C-c', followed by a control character, a digit, or '{', '}',
     '<', '>', ':' or ';'.  The other punctuation characters are
     reserved for minor modes, and ordinary letters are reserved for
     users.

     A major mode can also rebind the keys 'M-n', 'M-p' and 'M-s'.  The
     bindings for 'M-n' and 'M-p' should normally be some kind of moving
     forward and backward, but this does not necessarily mean cursor
     motion.

     It is legitimate for a major mode to rebind a standard key sequence
     if it provides a command that does the same job in a way better
     suited to the text this mode is used for.  For example, a major
     mode for editing a programming language might redefine 'C-M-a' to
     move to the beginning of a function in a way that works better for
     that language.  The recommended way of tailoring 'C-M-a' to the
     needs of a major mode is to set 'beginning-of-defun-function'
     (*note List Motion::) to invoke the function specific to the mode.

     It is also legitimate for a major mode to rebind a standard key
     sequence whose standard meaning is rarely useful in that mode.  For
     instance, minibuffer modes rebind 'M-r', whose standard meaning is
     rarely of any use in the minibuffer.  Major modes such as Dired or
     Rmail that do not allow self-insertion of text can reasonably
     redefine letters and other printing characters as special commands.

   * Major modes for editing text should not define <RET> to do anything
     other than insert a newline.  However, it is ok for specialized
     modes for text that users don't directly edit, such as Dired and
     Info modes, to redefine <RET> to do something entirely different.

   * Major modes should not alter options that are primarily a matter of
     user preference, such as whether Auto-Fill mode is enabled.  Leave
     this to each user to decide.  However, a major mode should
     customize other variables so that Auto-Fill mode will work usefully
     _if_ the user decides to use it.

   * The mode may have its own syntax table or may share one with other
     related modes.  If it has its own syntax table, it should store
     this in a variable named 'MODENAME-mode-syntax-table'.  *Note
     Syntax Tables::.

   * If the mode handles a language that has a syntax for comments, it
     should set the variables that define the comment syntax.  *Note
     Options Controlling Comments: (emacs)Options for Comments.

   * The mode may have its own abbrev table or may share one with other
     related modes.  If it has its own abbrev table, it should store
     this in a variable named 'MODENAME-mode-abbrev-table'.  If the
     major mode command defines any abbrevs itself, it should pass 't'
     for the SYSTEM-FLAG argument to 'define-abbrev'.  *Note Defining
     Abbrevs::.

   * The mode should specify how to do highlighting for Font Lock mode,
     by setting up a buffer-local value for the variable
     'font-lock-defaults' (*note Font Lock Mode::).

   * Each face that the mode defines should, if possible, inherit from
     an existing Emacs face.  *Note Basic Faces::, and *note Faces for
     Font Lock::.

   * The mode should specify how Imenu should find the definitions or
     sections of a buffer, by setting up a buffer-local value for the
     variable 'imenu-generic-expression', for the two variables
     'imenu-prev-index-position-function' and
     'imenu-extract-index-name-function', or for the variable
     'imenu-create-index-function' (*note Imenu::).

   * The mode can specify a local value for
     'eldoc-documentation-function' to tell ElDoc mode how to handle
     this mode.

   * The mode can specify how to complete various keywords by adding one
     or more buffer-local entries to the special hook
     'completion-at-point-functions'.  *Note Completion in Buffers::.

   * To make a buffer-local binding for an Emacs customization variable,
     use 'make-local-variable' in the major mode command, not
     'make-variable-buffer-local'.  The latter function would make the
     variable local to every buffer in which it is subsequently set,
     which would affect buffers that do not use this mode.  It is
     undesirable for a mode to have such global effects.  *Note
     Buffer-Local Variables::.

     With rare exceptions, the only reasonable way to use
     'make-variable-buffer-local' in a Lisp package is for a variable
     which is used only within that package.  Using it on a variable
     used by other packages would interfere with them.

   * Each major mode should have a normal "mode hook" named
     'MODENAME-mode-hook'.  The very last thing the major mode command
     should do is to call 'run-mode-hooks'.  This runs the normal hook
     'change-major-mode-after-body-hook', the mode hook, the function
     'hack-local-variables' (when the buffer is visiting a file), and
     then the normal hook 'after-change-major-mode-hook'.  *Note Mode
     Hooks::.

   * The major mode command may start by calling some other major mode
     command (called the "parent mode") and then alter some of its
     settings.  A mode that does this is called a "derived mode".  The
     recommended way to define one is to use the 'define-derived-mode'
     macro, but this is not required.  Such a mode should call the
     parent mode command inside a 'delay-mode-hooks' form.  (Using
     'define-derived-mode' does this automatically.)  *Note Derived
     Modes::, and *note Mode Hooks::.

   * If something special should be done if the user switches a buffer
     from this mode to any other major mode, this mode can set up a
     buffer-local value for 'change-major-mode-hook' (*note Creating
     Buffer-Local::).

   * If this mode is appropriate only for specially-prepared text
     produced by the mode itself (rather than by the user typing at the
     keyboard or by an external file), then the major mode command
     symbol should have a property named 'mode-class' with value
     'special', put on as follows:

          (put 'funny-mode 'mode-class 'special)

     This tells Emacs that new buffers created while the current buffer
     is in Funny mode should not be put in Funny mode, even though the
     default value of 'major-mode' is 'nil'.  By default, the value of
     'nil' for 'major-mode' means to use the current buffer's major mode
     when creating new buffers (*note Auto Major Mode::), but with such
     'special' modes, Fundamental mode is used instead.  Modes such as
     Dired, Rmail, and Buffer List use this feature.

     The function 'view-buffer' does not enable View mode in buffers
     whose mode-class is special, because such modes usually provide
     their own View-like bindings.

     The 'define-derived-mode' macro automatically marks the derived
     mode as special if the parent mode is special.  Special mode is a
     convenient parent for such modes to inherit from; *Note Basic Major
     Modes::.

   * If you want to make the new mode the default for files with certain
     recognizable names, add an element to 'auto-mode-alist' to select
     the mode for those file names (*note Auto Major Mode::).  If you
     define the mode command to autoload, you should add this element in
     the same file that calls 'autoload'.  If you use an autoload cookie
     for the mode command, you can also use an autoload cookie for the
     form that adds the element (*note autoload cookie::).  If you do
     not autoload the mode command, it is sufficient to add the element
     in the file that contains the mode definition.

   * The top-level forms in the file defining the mode should be written
     so that they may be evaluated more than once without adverse
     consequences.  For instance, use 'defvar' or 'defcustom' to set
     mode-related variables, so that they are not reinitialized if they
     already have a value (*note Defining Variables::).

==============================================================================
File: elisp.info,  Node: |Auto_Major_Mode|,  Next: |Mode_Help|,  Prev: |Major_Mode_Conventions|,  Up: |Major_Modes|
==============================================================================

                                                               *Auto_Major_Mode*

23.2.2 How Emacs Chooses a Major Mode
-------------------------------------

When Emacs visits a file, it automatically selects a major mode for the
buffer based on information in the file name or in the file itself.  It
also processes local variables specified in the file text.

 -- Command: normal-mode &optional find-file
     This function establishes the proper major mode and buffer-local
     variable bindings for the current buffer.  It calls 'set-auto-mode'
     (see below).  As of Emacs 26.1, it no longer runs
     'hack-local-variables', this now being done in 'run-mode-hooks' at
     the initialization of major modes (*note Mode Hooks::).

     If the FIND-FILE argument to 'normal-mode' is non-'nil',
     'normal-mode' assumes that the 'find-file' function is calling it.
     In this case, it may process local variables in the '-*-' line or
     at the end of the file.  The variable 'enable-local-variables'
     controls whether to do so.  *Note Local Variables in Files:
     (emacs)File Variables, for the syntax of the local variables
     section of a file.

     If you run 'normal-mode' interactively, the argument FIND-FILE is
     normally 'nil'.  In this case, 'normal-mode' unconditionally
     processes any file local variables.

     The function calls 'set-auto-mode' to choose and set a major mode.
     If this does not specify a mode, the buffer stays in the major mode
     determined by the default value of 'major-mode' (see below).

     'normal-mode' uses 'condition-case' around the call to the major
     mode command, so errors are caught and reported as a 'File mode
     specification error', followed by the original error message.

 -- Function: set-auto-mode &optional keep-mode-if-same
     This function selects and sets the major mode that is appropriate
     for the current buffer.  It bases its decision (in order of
     precedence) on the '-*-' line, on any 'mode:' local variable near
     the end of a file, on the '#!' line (using
     'interpreter-mode-alist'), on the text at the beginning of the
     buffer (using 'magic-mode-alist'), and finally on the visited file
     name (using 'auto-mode-alist').  *Note How Major Modes are Chosen:
     (emacs)Choosing Modes.  If 'enable-local-variables' is 'nil',
     'set-auto-mode' does not check the '-*-' line, or near the end of
     the file, for any mode tag.

     There are some file types where it is not appropriate to scan the
     file contents for a mode specifier.  For example, a tar archive may
     happen to contain, near the end of the file, a member file that has
     a local variables section specifying a mode for that particular
     file.  This should not be applied to the containing tar file.
     Similarly, a tiff image file might just happen to contain a first
     line that seems to match the '-*-' pattern.  For these reasons,
     both these file extensions are members of the list
     'inhibit-local-variables-regexps'.  Add patterns to this list to
     prevent Emacs searching them for local variables of any kind (not
     just mode specifiers).

     If KEEP-MODE-IF-SAME is non-'nil', this function does not call the
     mode command if the buffer is already in the proper major mode.
     For instance, 'set-visited-file-name' sets this to 't' to avoid
     killing buffer local variables that the user may have set.

 -- Function: set-buffer-major-mode buffer
     This function sets the major mode of BUFFER to the default value of
     'major-mode'; if that is 'nil', it uses the current buffer's major
     mode (if that is suitable).  As an exception, if BUFFER's name is
     'scratch', it sets the mode to 'initial-major-mode'.

     The low-level primitives for creating buffers do not use this
     function, but medium-level commands such as 'switch-to-buffer' and
     'find-file-noselect' use it whenever they create buffers.

 -- User Option: initial-major-mode
     The value of this variable determines the major mode of the initial
     'scratch' buffer.  The value should be a symbol that is a major
     mode command.  The default value is 'lisp-interaction-mode'.

 -- Variable: interpreter-mode-alist
     This variable specifies major modes to use for scripts that specify
     a command interpreter in a '#!' line.  Its value is an alist with
     elements of the form '(REGEXP . MODE)'; this says to use mode MODE
     if the file specifies an interpreter which matches '\\`REGEXP\\''.
     For example, one of the default elements is '("python[0-9.]*" .
     python-mode)'.

 -- Variable: magic-mode-alist
     This variable's value is an alist with elements of the form
     '(REGEXP . FUNCTION)', where REGEXP is a regular expression and
     FUNCTION is a function or 'nil'.  After visiting a file,
     'set-auto-mode' calls FUNCTION if the text at the beginning of the
     buffer matches REGEXP and FUNCTION is non-'nil'; if FUNCTION is
     'nil', 'auto-mode-alist' gets to decide the mode.

 -- Variable: magic-fallback-mode-alist
     This works like 'magic-mode-alist', except that it is handled only
     if 'auto-mode-alist' does not specify a mode for this file.

 -- Variable: auto-mode-alist
     This variable contains an association list of file name patterns
     (regular expressions) and corresponding major mode commands.
     Usually, the file name patterns test for suffixes, such as '.el'
     and '.c', but this need not be the case.  An ordinary element of
     the alist looks like '(REGEXP . MODE-FUNCTION)'.

     For example,

          (("\\`/tmp/fol/" . text-mode)
           ("\\.texinfo\\'" . texinfo-mode)
           ("\\.texi\\'" . texinfo-mode)
           ("\\.el\\'" . emacs-lisp-mode)
           ("\\.c\\'" . c-mode)
           ("\\.h\\'" . c-mode)
           ...)

     When you visit a file whose expanded file name (*note File Name
     Expansion::), with version numbers and backup suffixes removed
     using 'file-name-sans-versions' (*note File Name Components::),
     matches a REGEXP, 'set-auto-mode' calls the corresponding
     MODE-FUNCTION.  This feature enables Emacs to select the proper
     major mode for most files.

     If an element of 'auto-mode-alist' has the form '(REGEXP FUNCTION
     t)', then after calling FUNCTION, Emacs searches 'auto-mode-alist'
     again for a match against the portion of the file name that did not
     match before.  This feature is useful for uncompression packages:
     an entry of the form '("\\.gz\\'" FUNCTION t)' can uncompress the
     file and then put the uncompressed file in the proper mode
     according to the name sans '.gz'.

     Here is an example of how to prepend several pattern pairs to
     'auto-mode-alist'.  (You might use this sort of expression in your
     init file.)

          (setq auto-mode-alist
            (append
             ;; File name (within directory) starts with a dot.
             '(("/\\.[^/]*\\'" . fundamental-mode)
               ;; File name has no dot.
               ("/[^\\./]*\\'" . fundamental-mode)
               ;; File name ends in '.C'.
               ("\\.C\\'" . c++-mode))
             auto-mode-alist))

==============================================================================
File: elisp.info,  Node: |Mode_Help|,  Next: |Derived_Modes|,  Prev: |Auto_Major_Mode|,  Up: |Major_Modes|
==============================================================================

                                                                     *Mode_Help*

23.2.3 Getting Help about a Major Mode
--------------------------------------

The 'describe-mode' function provides information about major modes.  It
is normally bound to 'C-h m'.  It uses the value of the variable
'major-mode' (*note Major Modes::), which is why every major mode
command needs to set that variable.

 -- Command: describe-mode &optional buffer
     This command displays the documentation of the current buffer's
     major mode and minor modes.  It uses the 'documentation' function
     to retrieve the documentation strings of the major and minor mode
     commands (*note Accessing Documentation::).

     If called from Lisp with a non-'nil' BUFFER argument, this function
     displays the documentation for that buffer's major and minor modes,
     rather than those of the current buffer.

==============================================================================
File: elisp.info,  Node: |Derived_Modes|,  Next: |Basic_Major_Modes|,  Prev: |Mode_Help|,  Up: |Major_Modes|
==============================================================================

                                                                 *Derived_Modes*

23.2.4 Defining Derived Modes
-----------------------------

The recommended way to define a new major mode is to derive it from an
existing one using 'define-derived-mode'.  If there is no closely
related mode, you should inherit from either 'text-mode',
'special-mode', or 'prog-mode'.  *Note Basic Major Modes::.  If none of
these are suitable, you can inherit from 'fundamental-mode' (*note Major
Modes::).

 -- Macro: define-derived-mode variant parent name docstring
          keyword-args... body...
     This macro defines VARIANT as a major mode command, using NAME as
     the string form of the mode name.  VARIANT and PARENT should be
     unquoted symbols.

     The new command VARIANT is defined to call the function PARENT,
     then override certain aspects of that parent mode:

        * The new mode has its own sparse keymap, named 'VARIANT-map'.
          'define-derived-mode' makes the parent mode's keymap the
          parent of the new map, unless 'VARIANT-map' is already set and
          already has a parent.

        * The new mode has its own syntax table, kept in the variable
          'VARIANT-syntax-table', unless you override this using the
          ':syntax-table' keyword (see below).  'define-derived-mode'
          makes the parent mode's syntax-table the parent of
          'VARIANT-syntax-table', unless the latter is already set and
          already has a parent different from the standard syntax table.

        * The new mode has its own abbrev table, kept in the variable
          'VARIANT-abbrev-table', unless you override this using the
          ':abbrev-table' keyword (see below).

        * The new mode has its own mode hook, 'VARIANT-hook'.  It runs
          this hook, after running the hooks of its ancestor modes, with
          'run-mode-hooks', as the last thing it does, apart from
          running any ':after-hook' form it may have.  *Note Mode
          Hooks::.

     In addition, you can specify how to override other aspects of
     PARENT with BODY.  The command VARIANT evaluates the forms in BODY
     after setting up all its usual overrides, just before running the
     mode hooks.

     If PARENT has a non-'nil' 'mode-class' symbol property, then
     'define-derived-mode' sets the 'mode-class' property of VARIANT to
     the same value.  This ensures, for example, that if PARENT is a
     special mode, then VARIANT is also a special mode (*note Major Mode
     Conventions::).

     You can also specify 'nil' for PARENT.  This gives the new mode no
     parent.  Then 'define-derived-mode' behaves as described above,
     but, of course, omits all actions connected with PARENT.

     The argument DOCSTRING specifies the documentation string for the
     new mode.  'define-derived-mode' adds some general information
     about the mode's hook, followed by the mode's keymap, at the end of
     this documentation string.  If you omit DOCSTRING,
     'define-derived-mode' generates a documentation string.

     The KEYWORD-ARGS are pairs of keywords and values.  The values,
     except for ':after-hook''s, are evaluated.  The following keywords
     are currently supported:

     ':syntax-table'
          You can use this to explicitly specify a syntax table for the
          new mode.  If you specify a 'nil' value, the new mode uses the
          same syntax table as PARENT, or the standard syntax table if
          PARENT is 'nil'.  (Note that this does _not_ follow the
          convention used for non-keyword arguments that a 'nil' value
          is equivalent with not specifying the argument.)

     ':abbrev-table'
          You can use this to explicitly specify an abbrev table for the
          new mode.  If you specify a 'nil' value, the new mode uses the
          same abbrev table as PARENT, or
          'fundamental-mode-abbrev-table' if PARENT is 'nil'.  (Again, a
          'nil' value is _not_ equivalent to not specifying this
          keyword.)

     ':group'
          If this is specified, the value should be the customization
          group for this mode.  (Not all major modes have one.)  The
          command 'customize-mode' uses this.  'define-derived-mode'
          does _not_ automatically define the specified customization
          group.

     ':after-hook'
          This optional keyword specifies a single Lisp form to evaluate
          as the final act of the mode function, after the mode hooks
          have been run.  It should not be quoted.  Since the form might
          be evaluated after the mode function has terminated, it should
          not access any element of the mode function's local state.  An
          ':after-hook' form is useful for setting up aspects of the
          mode which depend on the user's settings, which in turn may
          have been changed in a mode hook.

     Here is a hypothetical example:

          (defvar hypertext-mode-map
            (let ((map (make-sparse-keymap)))
              (define-key map [down-mouse-3] 'do-hyper-link)
              map))

          (define-derived-mode hypertext-mode
            text-mode "Hypertext"
            "Major mode for hypertext."
            (setq-local case-fold-search nil))

     Do not write an 'interactive' spec in the definition;
     'define-derived-mode' does that automatically.

 -- Function: derived-mode-p &rest modes
     This function returns non-'nil' if the current major mode is
     derived from any of the major modes given by the symbols MODES.

==============================================================================
File: elisp.info,  Node: |Basic_Major_Modes|,  Next: |Mode_Hooks|,  Prev: |Derived_Modes|,  Up: |Major_Modes|
==============================================================================

                                                             *Basic_Major_Modes*

23.2.5 Basic Major Modes
------------------------

Apart from Fundamental mode, there are three major modes that other
major modes commonly derive from: Text mode, Prog mode, and Special
mode.  While Text mode is useful in its own right (e.g., for editing
files ending in '.txt'), Prog mode and Special mode exist mainly to let
other modes derive from them.

   As far as possible, new major modes should be derived, either
directly or indirectly, from one of these three modes.  One reason is
that this allows users to customize a single mode hook (e.g.,
'prog-mode-hook') for an entire family of relevant modes (e.g., all
programming language modes).

 -- Command: text-mode
     Text mode is a major mode for editing human languages.  It defines
     the '"' and '\' characters as having punctuation syntax (*note
     Syntax Class Table::), and binds 'M-<TAB>' to
     'ispell-complete-word' (*note (emacs)Spelling::).

     An example of a major mode derived from Text mode is HTML mode.
     *Note SGML and HTML Modes: (emacs)HTML Mode.

 -- Command: prog-mode
     Prog mode is a basic major mode for buffers containing programming
     language source code.  Most of the programming language major modes
     built into Emacs are derived from it.

     Prog mode binds 'parse-sexp-ignore-comments' to 't' (*note Motion
     via Parsing::) and 'bidi-paragraph-direction' to 'left-to-right'
     (*note Bidirectional Display::).

 -- Command: special-mode
     Special mode is a basic major mode for buffers containing text that
     is produced specially by Emacs, rather than directly from a file.
     Major modes derived from Special mode are given a 'mode-class'
     property of 'special' (*note Major Mode Conventions::).

     Special mode sets the buffer to read-only.  Its keymap defines
     several common bindings, including 'q' for 'quit-window' and 'g'
     for 'revert-buffer' (*note Reverting::).

     An example of a major mode derived from Special mode is Buffer Menu
     mode, which is used by the '*Buffer List*' buffer.  *Note Listing
     Existing Buffers: (emacs)List Buffers.

   In addition, modes for buffers of tabulated data can inherit from
Tabulated List mode, which is in turn derived from Special mode.  *Note
Tabulated List Mode::.

==============================================================================
File: elisp.info,  Node: |Mode_Hooks|,  Next: |Tabulated_List_Mode|,  Prev: |Basic_Major_Modes|,  Up: |Major_Modes|
==============================================================================

                                                                    *Mode_Hooks*

23.2.6 Mode Hooks
-----------------

Every major mode command should finish by running the mode-independent
normal hook 'change-major-mode-after-body-hook', its mode hook, and the
normal hook 'after-change-major-mode-hook'.  It does this by calling
'run-mode-hooks'.  If the major mode is a derived mode, that is if it
calls another major mode (the parent mode) in its body, it should do
this inside 'delay-mode-hooks' so that the parent won't run these hooks
itself.  Instead, the derived mode's call to 'run-mode-hooks' runs the
parent's mode hook too.  *Note Major Mode Conventions::.

   Emacs versions before Emacs 22 did not have 'delay-mode-hooks'.
Versions before 24 did not have 'change-major-mode-after-body-hook'.
When user-implemented major modes do not use 'run-mode-hooks' and have
not been updated to use these newer features, they won't entirely follow
these conventions: they may run the parent's mode hook too early, or
fail to run 'after-change-major-mode-hook'.  If you encounter such a
major mode, please correct it to follow these conventions.

   When you define a major mode using 'define-derived-mode', it
automatically makes sure these conventions are followed.  If you define
a major mode "by hand", not using 'define-derived-mode', use the
following functions to handle these conventions automatically.

 -- Function: run-mode-hooks &rest hookvars
     Major modes should run their mode hook using this function.  It is
     similar to 'run-hooks' (*note Hooks::), but it also runs
     'change-major-mode-after-body-hook', 'hack-local-variables' (when
     the buffer is visiting a file) (*note File Local Variables::), and
     'after-change-major-mode-hook'.  The last thing it does is to
     evaluate any ':after-hook' forms declared by parent modes (*note
     Derived Modes::).

     When this function is called during the execution of a
     'delay-mode-hooks' form, it does not run the hooks or
     'hack-local-variables' or evaluate the forms immediately.  Instead,
     it arranges for the next call to 'run-mode-hooks' to run them.

 -- Macro: delay-mode-hooks body...
     When one major mode command calls another, it should do so inside
     of 'delay-mode-hooks'.

     This macro executes BODY, but tells all 'run-mode-hooks' calls
     during the execution of BODY to delay running their hooks.  The
     hooks will actually run during the next call to 'run-mode-hooks'
     after the end of the 'delay-mode-hooks' construct.

 -- Variable: change-major-mode-after-body-hook
     This is a normal hook run by 'run-mode-hooks'.  It is run before
     the mode hooks.

 -- Variable: after-change-major-mode-hook
     This is a normal hook run by 'run-mode-hooks'.  It is run at the
     very end of every properly-written major mode command.

==============================================================================
File: elisp.info,  Node: |Tabulated_List_Mode|,  Next: |Generic_Modes|,  Prev: |Mode_Hooks|,  Up: |Major_Modes|
==============================================================================

                                                           *Tabulated_List_Mode*

23.2.7 Tabulated List mode
--------------------------

Tabulated List mode is a major mode for displaying tabulated data, i.e.,
data consisting of "entries", each entry occupying one row of text with
its contents divided into columns.  Tabulated List mode provides
facilities for pretty-printing rows and columns, and sorting the rows
according to the values in each column.  It is derived from Special mode
(*note Basic Major Modes::).

   Tabulated List mode is intended to be used as a parent mode by a more
specialized major mode.  Examples include Process Menu mode (*note
Process Information::) and Package Menu mode (*note (emacs)Package
Menu::).

   Such a derived mode should use 'define-derived-mode' in the usual
way, specifying 'tabulated-list-mode' as the second argument (*note
Derived Modes::).  The body of the 'define-derived-mode' form should
specify the format of the tabulated data, by assigning values to the
variables documented below; optionally, it can then call the function
'tabulated-list-init-header', which will populate a header with the
names of the columns.

   The derived mode should also define a "listing command".  This, not
the mode command, is what the user calls (e.g., 'M-x list-processes').
The listing command should create or switch to a buffer, turn on the
derived mode, specify the tabulated data, and finally call
'tabulated-list-print' to populate the buffer.

 -- User Option: tabulated-list-gui-sort-indicator-asc
     This variable specifies the character to be used on GUI frames as
     an indication that the column is sorted in the ascending order.

     Whenever you change the sort direction in Tabulated List buffers,
     this indicator toggles between ascending ("asc") and descending
     ("desc").

 -- User Option: tabulated-list-gui-sort-indicator-desc
     Like 'tabulated-list-gui-sort-indicator-asc', but used when the
     column is sorted in the descending order.

 -- User Option: tabulated-list-tty-sort-indicator-asc
     Like 'tabulated-list-gui-sort-indicator-asc', but used for
     text-mode frames.

 -- User Option: tabulated-list-tty-sort-indicator-desc
     Like 'tabulated-list-tty-sort-indicator-asc', but used when the
     column is sorted in the descending order.

 -- Variable: tabulated-list-format
     This buffer-local variable specifies the format of the Tabulated
     List data.  Its value should be a vector.  Each element of the
     vector represents a data column, and should be a list '(NAME WIDTH
     SORT)', where

        * NAME is the column's name (a string).

        * WIDTH is the width to reserve for the column (an integer).
          This is meaningless for the last column, which runs to the end
          of each line.

        * SORT specifies how to sort entries by the column.  If 'nil',
          the column cannot be used for sorting.  If 't', the column is
          sorted by comparing string values.  Otherwise, this should be
          a predicate function for 'sort' (*note Rearrangement::), which
          accepts two arguments with the same form as the elements of
          'tabulated-list-entries' (see below).

 -- Variable: tabulated-list-entries
     This buffer-local variable specifies the entries displayed in the
     Tabulated List buffer.  Its value should be either a list, or a
     function.

     If the value is a list, each list element corresponds to one entry,
     and should have the form '(ID CONTENTS)', where

        * ID is either 'nil', or a Lisp object that identifies the
          entry.  If the latter, the cursor stays on the same entry when
          re-sorting entries.  Comparison is done with 'equal'.

        * CONTENTS is a vector with the same number of elements as
          'tabulated-list-format'.  Each vector element is either a
          string, which is inserted into the buffer as-is, or a list
          '(LABEL . PROPERTIES)', which means to insert a text button by
          calling 'insert-text-button' with LABEL and PROPERTIES as
          arguments (*note Making Buttons::).

          There should be no newlines in any of these strings.

     Otherwise, the value should be a function which returns a list of
     the above form when called with no arguments.

 -- Variable: tabulated-list-revert-hook
     This normal hook is run prior to reverting a Tabulated List buffer.
     A derived mode can add a function to this hook to recompute
     'tabulated-list-entries'.

 -- Variable: tabulated-list-printer
     The value of this variable is the function called to insert an
     entry at point, including its terminating newline.  The function
     should accept two arguments, ID and CONTENTS, having the same
     meanings as in 'tabulated-list-entries'.  The default value is a
     function which inserts an entry in a straightforward way; a mode
     which uses Tabulated List mode in a more complex way can specify
     another function.

 -- Variable: tabulated-list-sort-key
     The value of this variable specifies the current sort key for the
     Tabulated List buffer.  If it is 'nil', no sorting is done.
     Otherwise, it should have the form '(NAME . FLIP)', where NAME is a
     string matching one of the column names in 'tabulated-list-format',
     and FLIP, if non-'nil', means to invert the sort order.

 -- Function: tabulated-list-init-header
     This function computes and sets 'header-line-format' for the
     Tabulated List buffer (*note Header Lines::), and assigns a keymap
     to the header line to allow sorting entries by clicking on column
     headers.

     Modes derived from Tabulated List mode should call this after
     setting the above variables (in particular, only after setting
     'tabulated-list-format').

 -- Function: tabulated-list-print &optional remember-pos update
     This function populates the current buffer with entries.  It should
     be called by the listing command.  It erases the buffer, sorts the
     entries specified by 'tabulated-list-entries' according to
     'tabulated-list-sort-key', then calls the function specified by
     'tabulated-list-printer' to insert each entry.

     If the optional argument REMEMBER-POS is non-'nil', this function
     looks for the ID element on the current line, if any, and tries to
     move to that entry after all the entries are (re)inserted.

     If the optional argument UPDATE is non-'nil', this function will
     only erase or add entries that have changed since the last print.
     This is several times faster if most entries haven't changed since
     the last time this function was called.  The only difference in
     outcome is that tags placed via 'tabulated-list-put-tag' will not
     be removed from entries that haven't changed (normally all tags are
     removed).

 -- Function: tabulated-list-delete-entry
     This function deletes the entry at point.

     It returns a list '(ID COLS)', where ID is the ID of the deleted
     entry and COLS is a vector of its column descriptors.  It moves
     point to the beginning of the current line.  It returns 'nil' if
     there is no entry at point.

     Note that this function only changes the buffer contents; it does
     not alter 'tabulated-list-entries'.

 -- Function: tabulated-list-get-id &optional pos
     This 'defsubst' returns the ID object from 'tabulated-list-entries'
     (if that is a list) or from the list returned by
     'tabulated-list-entries' (if it is a function).  If omitted or
     'nil', POS defaults to point.

 -- Function: tabulated-list-get-entry &optional pos
     This 'defsubst' returns the entry object from
     'tabulated-list-entries' (if that is a list) or from the list
     returned by 'tabulated-list-entries' (if it is a function).  This
     will be a vector for the ID at POS.  If there is no entry at POS,
     then the function returns 'nil'.

 -- Function: tabulated-list-header-overlay-p &optional POS
     This 'defsubst' returns non-nil if there is a fake header at POS.
     A fake header is used if 'tabulated-list-use-header-line' is 'nil'
     to put the column names at the beginning of the buffer.  If omitted
     or 'nil', POS defaults to 'point-min'.

 -- Function: tabulated-list-put-tag tag &optional advance
     This function puts TAG in the padding area of the current line.
     The padding area can be empty space at the beginning of the line,
     the width of which is governed by 'tabulated-list-padding'.  TAG
     should be a string, with a length less than or equal to
     'tabulated-list-padding'.  If ADVANCE is non-nil, this function
     advances point by one line.

 -- Function: tabulated-list-clear-all-tags
     This function clears all tags from the padding area in the current
     buffer.

 -- Function: tabulated-list-set-col col desc &optional
          change-entry-data
     This function changes the tabulated list entry at point, setting
     COL to DESC.  COL is the column number to change, or the name of
     the column to change.  DESC is the new column descriptor, which is
     inserted via 'tabulated-list-print-col'.

     If CHANGE-ENTRY-DATA is non-nil, this function modifies the
     underlying data (usually the column descriptor in the list
     'tabulated-list-entries') by setting the column descriptor of the
     vector to 'desc'.

==============================================================================
File: elisp.info,  Node: |Generic_Modes|,  Next: |Example_Major_Modes|,  Prev: |Tabulated_List_Mode|,  Up: |Major_Modes|
==============================================================================

                                                                 *Generic_Modes*

23.2.8 Generic Modes
--------------------

"Generic modes" are simple major modes with basic support for comment
syntax and Font Lock mode.  To define a generic mode, use the macro
'define-generic-mode'.  See the file 'generic-x.el' for some examples of
the use of 'define-generic-mode'.

 -- Macro: define-generic-mode mode comment-list keyword-list
          font-lock-list auto-mode-list function-list &optional
          docstring
     This macro defines a generic mode command named MODE (a symbol, not
     quoted).  The optional argument DOCSTRING is the documentation for
     the mode command.  If you do not supply it, 'define-generic-mode'
     generates one by default.

     The argument COMMENT-LIST is a list in which each element is either
     a character, a string of one or two characters, or a cons cell.  A
     character or a string is set up in the mode's syntax table as a
     comment starter.  If the entry is a cons cell, the CAR is set up as
     a comment starter and the CDR as a comment ender.  (Use 'nil' for
     the latter if you want comments to end at the end of the line.)
     Note that the syntax table mechanism has limitations about what
     comment starters and enders are actually possible.  *Note Syntax
     Tables::.

     The argument KEYWORD-LIST is a list of keywords to highlight with
     'font-lock-keyword-face'.  Each keyword should be a string.
     Meanwhile, FONT-LOCK-LIST is a list of additional expressions to
     highlight.  Each element of this list should have the same form as
     an element of 'font-lock-keywords'.  *Note Search-based
     Fontification::.

     The argument AUTO-MODE-LIST is a list of regular expressions to add
     to the variable 'auto-mode-alist'.  They are added by the execution
     of the 'define-generic-mode' form, not by expanding the macro call.

     Finally, FUNCTION-LIST is a list of functions for the mode command
     to call for additional setup.  It calls these functions just before
     it runs the mode hook variable 'MODE-hook'.

==============================================================================
File: elisp.info,  Node: |Example_Major_Modes|,  Prev: |Generic_Modes|,  Up: |Major_Modes|
==============================================================================

                                                           *Example_Major_Modes*

23.2.9 Major Mode Examples
--------------------------

Text mode is perhaps the simplest mode besides Fundamental mode.  Here
are excerpts from 'text-mode.el' that illustrate many of the conventions
listed above:

     ;; Create the syntax table for this mode.
     (defvar text-mode-syntax-table
       (let ((st (make-syntax-table)))
         (modify-syntax-entry ?\" ".   " st)
         (modify-syntax-entry ?\\ ".   " st)
         ;; Add 'p' so M-c on 'hello' leads to 'Hello', not 'hello'.
         (modify-syntax-entry ?' "w p" st)
         ...
         st)
       "Syntax table used while in `text-mode'.")

     ;; Create the keymap for this mode.
     (defvar text-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map "\e\t" 'ispell-complete-word)
         ...
         map)
       "Keymap for `text-mode'.
     Many other modes, such as `mail-mode', `outline-mode' and
     `indented-text-mode', inherit all the commands defined in this map.")

   Here is how the actual mode command is defined now:

     (define-derived-mode text-mode nil "Text"
       "Major mode for editing text written for humans to read.
     In this mode, paragraphs are delimited only by blank or white lines.
     You can thus get the full benefit of adaptive filling
      (see the variable `adaptive-fill-mode').
     \\{text-mode-map}
     Turning on Text mode runs the normal hook `text-mode-hook'."
       (setq-local text-mode-variant t)
       (setq-local require-final-newline mode-require-final-newline))

   The three Lisp modes (Lisp mode, Emacs Lisp mode, and Lisp
Interaction mode) have more features than Text mode and the code is
correspondingly more complicated.  Here are excerpts from 'lisp-mode.el'
that illustrate how these modes are written.

   Here is how the Lisp mode syntax and abbrev tables are defined:

     ;; Create mode-specific table variables.
     (define-abbrev-table 'lisp-mode-abbrev-table ()
       "Abbrev table for Lisp mode.")

     (defvar lisp-mode-syntax-table
       (let ((table (make-syntax-table lisp--mode-syntax-table)))
         (modify-syntax-entry ?\[ "_   " table)
         (modify-syntax-entry ?\] "_   " table)
         (modify-syntax-entry ?# "' 14" table)
         (modify-syntax-entry ?| "\" 23bn" table)
         table)
       "Syntax table used in `lisp-mode'.")

   The three modes for Lisp share much of their code.  For instance,
each calls the following function to set various variables:

     (defun lisp-mode-variables (&optional syntax keywords-case-insensitive elisp)
       (when syntax
         (set-syntax-table lisp-mode-syntax-table))
       ...

Amongst other things, this function sets up the 'comment-start' variable
to handle Lisp comments:

       (setq-local comment-start ";")
       ...

   Each of the different Lisp modes has a slightly different keymap.
For example, Lisp mode binds 'C-c C-z' to 'run-lisp', but the other Lisp
modes do not.  However, all Lisp modes have some commands in common.
The following code sets up the common commands:

     (defvar lisp-mode-shared-map
       (let ((map (make-sparse-keymap)))
         (set-keymap-parent map prog-mode-map)
         (define-key map "\e\C-q" 'indent-sexp)
         (define-key map "\177" 'backward-delete-char-untabify)
         map)
       "Keymap for commands shared by all sorts of Lisp modes.")

And here is the code to set up the keymap for Lisp mode:

     (defvar lisp-mode-map
       (let ((map (make-sparse-keymap))
             (menu-map (make-sparse-keymap "Lisp")))
         (set-keymap-parent map lisp-mode-shared-map)
         (define-key map "\e\C-x" 'lisp-eval-defun)
         (define-key map "\C-c\C-z" 'run-lisp)
         ...
         map)
       "Keymap for ordinary Lisp mode.
     All commands in `lisp-mode-shared-map' are inherited by this map.")

Finally, here is the major mode command for Lisp mode:

     (define-derived-mode lisp-mode prog-mode "Lisp"
       "Major mode for editing Lisp code for Lisps other than GNU Emacs Lisp.
     Commands:
     Delete converts tabs to spaces as it moves back.
     Blank lines separate paragraphs.  Semicolons start comments.

     \\{lisp-mode-map}
     Note that `run-lisp' may be used either to start an inferior Lisp job
     or to switch back to an existing one."
       (lisp-mode-variables nil t)
       (setq-local find-tag-default-function 'lisp-find-tag-default)
       (setq-local comment-start-skip
                   "\\(\\(^\\|[^\\\\\n]\\)\\(\\\\\\\\\\)*\\)\\(;+\\|#|\\) *")
       (setq imenu-case-fold-search t))

==============================================================================
File: elisp.info,  Node: |Minor_Modes|,  Next: |Mode_Line_Format|,  Prev: |Major_Modes|,  Up: |Modes|
==============================================================================

                                                                   *Minor_Modes*

23.3 Minor Modes
----------------

A "minor mode" provides optional features that users may enable or
disable independently of the choice of major mode.  Minor modes can be
enabled individually or in combination.

   Most minor modes implement features that are independent of the major
mode, and can thus be used with most major modes.  For example, Auto
Fill mode works with any major mode that permits text insertion.  A few
minor modes, however, are specific to a particular major mode.  For
example, Diff Auto Refine mode is a minor mode that is intended to be
used only with Diff mode.

   Ideally, a minor mode should have its desired effect regardless of
the other minor modes in effect.  It should be possible to activate and
deactivate minor modes in any order.

 -- Variable: minor-mode-list
     The value of this variable is a list of all minor mode commands.

MENU

* |Minor_Mode_Conventions|::      Tips for writing a minor mode.
* |Keymaps_and_Minor_Modes|::     How a minor mode can have its own keymap.
* |Defining_Minor_Modes|::        A convenient facility for defining minor modes.

==============================================================================
File: elisp.info,  Node: |Minor_Mode_Conventions|,  Next: |Keymaps_and_Minor_Modes|,  Up: |Minor_Modes|
==============================================================================

                                                        *Minor_Mode_Conventions*

23.3.1 Conventions for Writing Minor Modes
------------------------------------------

There are conventions for writing minor modes just as there are for
major modes (*note Major Modes::).  These conventions are described
below.  The easiest way to follow them is to use the macro
'define-minor-mode'.  *Note Defining Minor Modes::.

   * Define a variable whose name ends in '-mode'.  We call this the
     "mode variable".  The minor mode command should set this variable.
     The value will be 'nil' if the mode is disabled, and non-'nil' if
     the mode is enabled.  The variable should be buffer-local if the
     minor mode is buffer-local.

     This variable is used in conjunction with the 'minor-mode-alist' to
     display the minor mode name in the mode line.  It also determines
     whether the minor mode keymap is active, via 'minor-mode-map-alist'
     (*note Controlling Active Maps::).  Individual commands or hooks
     can also check its value.

   * Define a command, called the "mode command", whose name is the same
     as the mode variable.  Its job is to set the value of the mode
     variable, plus anything else that needs to be done to actually
     enable or disable the mode's features.

     The mode command should accept one optional argument.  If called
     interactively with no prefix argument, it should toggle the mode
     (i.e., enable if it is disabled, and disable if it is enabled).  If
     called interactively with a prefix argument, it should enable the
     mode if the argument is positive and disable it otherwise.

     If the mode command is called from Lisp (i.e., non-interactively),
     it should enable the mode if the argument is omitted or 'nil'; it
     should toggle the mode if the argument is the symbol 'toggle';
     otherwise it should treat the argument in the same way as for an
     interactive call with a numeric prefix argument, as described
     above.

     The following example shows how to implement this behavior (it is
     similar to the code generated by the 'define-minor-mode' macro):

          (interactive (list (or current-prefix-arg 'toggle)))
          (let ((enable
                 (if (eq arg 'toggle)
                     (not foo-mode) ; this is the mode's mode variable
                   (> (prefix-numeric-value arg) 0))))
            (if enable
                DO-ENABLE
              DO-DISABLE))

     The reason for this somewhat complex behavior is that it lets users
     easily toggle the minor mode interactively, and also lets the minor
     mode be easily enabled in a mode hook, like this:

          (add-hook 'text-mode-hook 'foo-mode)

     This behaves correctly whether or not 'foo-mode' was already
     enabled, since the 'foo-mode' mode command unconditionally enables
     the minor mode when it is called from Lisp with no argument.
     Disabling a minor mode in a mode hook is a little uglier:

          (add-hook 'text-mode-hook (lambda () (foo-mode -1)))

     However, this is not very commonly done.

     Enabling or disabling a minor mode twice in direct succession
     should not fail and should do the same thing as enabling or
     disabling it only once.  In other words, the minor mode command
     should be idempotent.

   * Add an element to 'minor-mode-alist' for each minor mode (*note
     Definition of minor-mode-alist::), if you want to indicate the
     minor mode in the mode line.  This element should be a list of the
     following form:

          (MODE-VARIABLE STRING)

     Here MODE-VARIABLE is the variable that controls enabling of the
     minor mode, and STRING is a short string, starting with a space, to
     represent the mode in the mode line.  These strings must be short
     so that there is room for several of them at once.

     When you add an element to 'minor-mode-alist', use 'assq' to check
     for an existing element, to avoid duplication.  For example:

          (unless (assq 'leif-mode minor-mode-alist)
            (push '(leif-mode " Leif") minor-mode-alist))

     or like this, using 'add-to-list' (*note List Variables::):

          (add-to-list 'minor-mode-alist '(leif-mode " Leif"))

   In addition, several major mode conventions (*note Major Mode
Conventions::) apply to minor modes as well: those regarding the names
of global symbols, the use of a hook at the end of the initialization
function, and the use of keymaps and other tables.

   The minor mode should, if possible, support enabling and disabling
via Custom (*note Customization::).  To do this, the mode variable
should be defined with 'defcustom', usually with ':type 'boolean'.  If
just setting the variable is not sufficient to enable the mode, you
should also specify a ':set' method which enables the mode by invoking
the mode command.  Note in the variable's documentation string that
setting the variable other than via Custom may not take effect.  Also,
mark the definition with an autoload cookie (*note autoload cookie::),
and specify a ':require' so that customizing the variable will load the
library that defines the mode.  For example:

     ;;;###autoload
     (defcustom msb-mode nil
       "Toggle msb-mode.
     Setting this variable directly does not take effect;
     use either \\[customize] or the function `msb-mode'."
       :set 'custom-set-minor-mode
       :initialize 'custom-initialize-default
       :version "20.4"
       :type    'boolean
       :group   'msb
       :require 'msb)

==============================================================================
File: elisp.info,  Node: |Keymaps_and_Minor_Modes|,  Next: |Defining_Minor_Modes|,  Prev: |Minor_Mode_Conventions|,  Up: |Minor_Modes|
==============================================================================

                                                       *Keymaps_and_Minor_Modes*

23.3.2 Keymaps and Minor Modes
------------------------------

Each minor mode can have its own keymap, which is active when the mode
is enabled.  To set up a keymap for a minor mode, add an element to the
alist 'minor-mode-map-alist'.  *Note Definition of
minor-mode-map-alist::.

   One use of minor mode keymaps is to modify the behavior of certain
self-inserting characters so that they do something else as well as
self-insert.  (Another way to customize 'self-insert-command' is through
'post-self-insert-hook', see *note Commands for Insertion::.  Apart from
this, the facilities for customizing 'self-insert-command' are limited
to special cases, designed for abbrevs and Auto Fill mode.  Do not try
substituting your own definition of 'self-insert-command' for the
standard one.  The editor command loop handles this function specially.)

   Minor modes may bind commands to key sequences consisting of 'C-c'
followed by a punctuation character.  However, sequences consisting of
'C-c' followed by one of '{}<>:;', or a control character or digit, are
reserved for major modes.  Also, 'C-c LETTER' is reserved for users.
*Note Key Binding Conventions::.

==============================================================================
File: elisp.info,  Node: |Defining_Minor_Modes|,  Prev: |Keymaps_and_Minor_Modes|,  Up: |Minor_Modes|
==============================================================================

                                                          *Defining_Minor_Modes*

23.3.3 Defining Minor Modes
---------------------------

The macro 'define-minor-mode' offers a convenient way of implementing a
mode in one self-contained definition.

 -- Macro: define-minor-mode mode doc [init-value [lighter [keymap]]]
          keyword-args... body...
     This macro defines a new minor mode whose name is MODE (a symbol).
     It defines a command named MODE to toggle the minor mode, with DOC
     as its documentation string.

     The toggle command takes one optional (prefix) argument.  If called
     interactively with no argument it toggles the mode on or off.  A
     positive prefix argument enables the mode, any other prefix
     argument disables it.  From Lisp, an argument of 'toggle' toggles
     the mode, whereas an omitted or 'nil' argument enables the mode.
     This makes it easy to enable the minor mode in a major mode hook,
     for example.  If DOC is 'nil', the macro supplies a default
     documentation string explaining the above.

     By default, it also defines a variable named MODE, which is set to
     't' or 'nil' by enabling or disabling the mode.  The variable is
     initialized to INIT-VALUE.  Except in unusual circumstances (see
     below), this value must be 'nil'.

     The string LIGHTER says what to display in the mode line when the
     mode is enabled; if it is 'nil', the mode is not displayed in the
     mode line.

     The optional argument KEYMAP specifies the keymap for the minor
     mode.  If non-'nil', it should be a variable name (whose value is a
     keymap), a keymap, or an alist of the form

          (KEY-SEQUENCE . DEFINITION)

     where each KEY-SEQUENCE and DEFINITION are arguments suitable for
     passing to 'define-key' (*note Changing Key Bindings::).  If KEYMAP
     is a keymap or an alist, this also defines the variable 'MODE-map'.

     The above three arguments INIT-VALUE, LIGHTER, and KEYMAP can be
     (partially) omitted when KEYWORD-ARGS are used.  The KEYWORD-ARGS
     consist of keywords followed by corresponding values.  A few
     keywords have special meanings:

     ':group GROUP'
          Custom group name to use in all generated 'defcustom' forms.
          Defaults to MODE without the possible trailing '-mode'.
          Warning: don't use this default group name unless you have
          written a 'defgroup' to define that group properly.  *Note
          Group Definitions::.

     ':global GLOBAL'
          If non-'nil', this specifies that the minor mode should be
          global rather than buffer-local.  It defaults to 'nil'.

          One of the effects of making a minor mode global is that the
          MODE variable becomes a customization variable.  Toggling it
          through the Customize interface turns the mode on and off, and
          its value can be saved for future Emacs sessions (*note
          (emacs)Saving Customizations::.  For the saved variable to
          work, you should ensure that the 'define-minor-mode' form is
          evaluated each time Emacs starts; for packages that are not
          part of Emacs, the easiest way to do this is to specify a
          ':require' keyword.

     ':init-value INIT-VALUE'
          This is equivalent to specifying INIT-VALUE positionally.

     ':lighter LIGHTER'
          This is equivalent to specifying LIGHTER positionally.

     ':keymap KEYMAP'
          This is equivalent to specifying KEYMAP positionally.

     ':variable PLACE'
          This replaces the default variable MODE, used to store the
          state of the mode.  If you specify this, the MODE variable is
          not defined, and any INIT-VALUE argument is unused.  PLACE can
          be a different named variable (which you must define
          yourself), or anything that can be used with the 'setf'
          function (*note Generalized Variables::).  PLACE can also be a
          cons '(GET . SET)', where GET is an expression that returns
          the current state, and SET is a function of one argument (a
          state) that sets it.

     ':after-hook AFTER-HOOK'
          This defines a single Lisp form which is evaluated after the
          mode hooks have run.  It should not be quoted.

     Any other keyword arguments are passed directly to the 'defcustom'
     generated for the variable MODE.

     The command named MODE first performs the standard actions such as
     setting the variable named MODE and then executes the BODY forms,
     if any.  It then runs the mode hook variable 'MODE-hook' and
     finishes by evaluating any form in ':after-hook'.

   The initial value must be 'nil' except in cases where (1) the mode is
preloaded in Emacs, or (2) it is painless for loading to enable the mode
even though the user did not request it.  For instance, if the mode has
no effect unless something else is enabled, and will always be loaded by
that time, enabling it by default is harmless.  But these are unusual
circumstances.  Normally, the initial value must be 'nil'.

   The name 'easy-mmode-define-minor-mode' is an alias for this macro.

   Here is an example of using 'define-minor-mode':

     (define-minor-mode hungry-mode
       "Toggle Hungry mode.
     Interactively with no argument, this command toggles the mode.
     A positive prefix argument enables the mode, any other prefix
     argument disables it.  From Lisp, argument omitted or nil enables
     the mode, `toggle' toggles the state.

     When Hungry mode is enabled, the control delete key
     gobbles all preceding whitespace except the last.
     See the command \\[hungry-electric-delete]."
      ;; The initial value.
      nil
      ;; The indicator for the mode line.
      " Hungry"
      ;; The minor mode bindings.
      '(([C-backspace] . hungry-electric-delete)))

This defines a minor mode named "Hungry mode", a command named
'hungry-mode' to toggle it, a variable named 'hungry-mode' which
indicates whether the mode is enabled, and a variable named
'hungry-mode-map' which holds the keymap that is active when the mode is
enabled.  It initializes the keymap with a key binding for 'C-<DEL>'.
There are no BODY forms--many minor modes don't need any.

   Here's an equivalent way to write it:

     (define-minor-mode hungry-mode
       "Toggle Hungry mode.
     ...rest of documentation as before..."
      ;; The initial value.
      :init-value nil
      ;; The indicator for the mode line.
      :lighter " Hungry"
      ;; The minor mode bindings.
      :keymap
      '(([C-backspace] . hungry-electric-delete)
        ([C-M-backspace]
         . (lambda ()
             (interactive)
             (hungry-electric-delete t)))))

 -- Macro: define-globalized-minor-mode global-mode mode turn-on
          keyword-args... body...
     This defines a global toggle named GLOBAL-MODE whose meaning is to
     enable or disable the buffer-local minor mode MODE in all buffers.
     It also executes the BODY forms.  To turn on the minor mode in a
     buffer, it uses the function TURN-ON; to turn off the minor mode,
     it calls MODE with -1 as argument.

     Globally enabling the mode also affects buffers subsequently
     created by visiting files, and buffers that use a major mode other
     than Fundamental mode; but it does not detect the creation of a new
     buffer in Fundamental mode.

     This defines the customization option GLOBAL-MODE (*note
     Customization::), which can be toggled in the Customize interface
     to turn the minor mode on and off.  As with 'define-minor-mode',
     you should ensure that the 'define-globalized-minor-mode' form is
     evaluated each time Emacs starts, for example by providing a
     ':require' keyword.

     Use ':group GROUP' in KEYWORD-ARGS to specify the custom group for
     the mode variable of the global minor mode.

     Generally speaking, when you define a globalized minor mode, you
     should also define a non-globalized version, so that people can use
     (or disable) it in individual buffers.  This also allows them to
     disable a globally enabled minor mode in a specific major mode, by
     using that mode's hook.

==============================================================================
File: elisp.info,  Node: |Mode_Line_Format|,  Next: |Imenu|,  Prev: |Minor_Modes|,  Up: |Modes|
==============================================================================

                                                              *Mode_Line_Format*

23.4 Mode Line Format
---------------------

Each Emacs window (aside from minibuffer windows) typically has a mode
line at the bottom, which displays status information about the buffer
displayed in the window.  The mode line contains information about the
buffer, such as its name, associated file, depth of recursive editing,
and major and minor modes.  A window can also have a "header line",
which is much like the mode line but appears at the top of the window.

   This section describes how to control the contents of the mode line
and header line.  We include it in this chapter because much of the
information displayed in the mode line relates to the enabled major and
minor modes.

MENU

* Base: Mode Line Basics.       Basic ideas of mode line control.
* Data: Mode Line Data.         The data structure that controls the mode line.
* Top: Mode Line Top.           The top level variable, mode-line-format.
* |Mode_Line_Variables|::         Variables used in that data structure.
* |%_Constructs|::                Putting information into a mode line.
* |Properties_in_Mode|::          Using text properties in the mode line.
* |Header_Lines|::                Like a mode line, but at the top.
* |Emulating_Mode_Line|::         Formatting text as the mode line would.

==============================================================================
File: elisp.info,  Node: |Mode_Line_Basics|,  Next: |Mode_Line_Data|,  Up: |Mode_Line_Format|
==============================================================================

                                                              *Mode_Line_Basics*

23.4.1 Mode Line Basics
-----------------------

The contents of each mode line are specified by the buffer-local
variable 'mode-line-format' (*note Mode Line Top::).  This variable
holds a "mode line construct": a template that controls what is
displayed on the buffer's mode line.  The value of 'header-line-format'
specifies the buffer's header line in the same way.  All windows for the
same buffer use the same 'mode-line-format' and 'header-line-format'
unless a 'mode-line-format' or 'header-line-format' parameter has been
specified for that window (*note Window Parameters::).

   For efficiency, Emacs does not continuously recompute each window's
mode line and header line.  It does so when circumstances appear to call
for it--for instance, if you change the window configuration, switch
buffers, narrow or widen the buffer, scroll, or modify the buffer.  If
you alter any of the variables referenced by 'mode-line-format' or
'header-line-format' (*note Mode Line Variables::), or any other data
structures that affect how text is displayed (*note Display::), you
should use the function 'force-mode-line-update' to update the display.

 -- Function: force-mode-line-update &optional all
     This function forces Emacs to update the current buffer's mode line
     and header line, based on the latest values of all relevant
     variables, during its next redisplay cycle.  If the optional
     argument ALL is non-'nil', it forces an update for all mode lines
     and header lines.

     This function also forces an update of the menu bar and frame
     title.

   The selected window's mode line is usually displayed in a different
color using the face 'mode-line'.  Other windows' mode lines appear in
the face 'mode-line-inactive' instead.  *Note Faces::.

==============================================================================
File: elisp.info,  Node: |Mode_Line_Data|,  Next: |Mode_Line_Top|,  Prev: |Mode_Line_Basics|,  Up: |Mode_Line_Format|
==============================================================================

                                                                *Mode_Line_Data*

23.4.2 The Data Structure of the Mode Line
------------------------------------------

The mode line contents are controlled by a data structure called a "mode
line construct", made up of lists, strings, symbols, and numbers kept in
buffer-local variables.  Each data type has a specific meaning for the
mode line appearance, as described below.  The same data structure is
used for constructing frame titles (*note Frame Titles::) and header
lines (*note Header Lines::).

   A mode line construct may be as simple as a fixed string of text, but
it usually specifies how to combine fixed strings with variables' values
to construct the text.  Many of these variables are themselves defined
to have mode line constructs as their values.

   Here are the meanings of various data types as mode line constructs:

'STRING'
     A string as a mode line construct appears verbatim except for
     "'%'-constructs" in it.  These stand for substitution of other
     data; see *note %-Constructs::.

     If parts of the string have 'face' properties, they control display
     of the text just as they would text in the buffer.  Any characters
     which have no 'face' properties are displayed, by default, in the
     face 'mode-line' or 'mode-line-inactive' (*note (emacs)Standard
     Faces::).  The 'help-echo' and 'keymap' properties in STRING have
     special meanings.  *Note Properties in Mode::.

'SYMBOL'
     A symbol as a mode line construct stands for its value.  The value
     of SYMBOL is used as a mode line construct, in place of SYMBOL.
     However, the symbols 't' and 'nil' are ignored, as is any symbol
     whose value is void.

     There is one exception: if the value of SYMBOL is a string, it is
     displayed verbatim: the '%'-constructs are not recognized.

     Unless SYMBOL is marked as risky (i.e., it has a non-'nil'
     'risky-local-variable' property), all text properties specified in
     SYMBOL's value are ignored.  This includes the text properties of
     strings in SYMBOL's value, as well as all ':eval' and ':propertize'
     forms in it.  (The reason for this is security: non-risky variables
     could be set automatically from file variables without prompting
     the user.)

'(STRING REST...)'
'(LIST REST...)'
     A list whose first element is a string or list means to process all
     the elements recursively and concatenate the results.  This is the
     most common form of mode line construct.

'(:eval FORM)'
     A list whose first element is the symbol ':eval' says to evaluate
     FORM, and use the result as a string to display.  Make sure this
     evaluation cannot load any files, as doing so could cause infinite
     recursion.

'(:propertize ELT PROPS...)'
     A list whose first element is the symbol ':propertize' says to
     process the mode line construct ELT recursively, then add the text
     properties specified by PROPS to the result.  The argument PROPS
     should consist of zero or more pairs TEXT-PROPERTY VALUE.  If ELT
     is or produces a string with text properties, all the characters of
     that string should have the same properties, or else some of them
     might be removed by ':propertize'.

'(SYMBOL THEN ELSE)'
     A list whose first element is a symbol that is not a keyword
     specifies a conditional.  Its meaning depends on the value of
     SYMBOL.  If SYMBOL has a non-'nil' value, the second element, THEN,
     is processed recursively as a mode line construct.  Otherwise, the
     third element, ELSE, is processed recursively.  You may omit ELSE;
     then the mode line construct displays nothing if the value of
     SYMBOL is 'nil' or void.

'(WIDTH REST...)'
     A list whose first element is an integer specifies truncation or
     padding of the results of REST.  The remaining elements REST are
     processed recursively as mode line constructs and concatenated
     together.  When WIDTH is positive, the result is space filled on
     the right if its width is less than WIDTH.  When WIDTH is negative,
     the result is truncated on the right to -WIDTH columns if its width
     exceeds -WIDTH.

     For example, the usual way to show what percentage of a buffer is
     above the top of the window is to use a list like this: '(-3
     "%p")'.

==============================================================================
File: elisp.info,  Node: |Mode_Line_Top|,  Next: |Mode_Line_Variables|,  Prev: |Mode_Line_Data|,  Up: |Mode_Line_Format|
==============================================================================

                                                                 *Mode_Line_Top*

23.4.3 The Top Level of Mode Line Control
-----------------------------------------

The variable in overall control of the mode line is 'mode-line-format'.

 -- User Option: mode-line-format
     The value of this variable is a mode line construct that controls
     the contents of the mode-line.  It is always buffer-local in all
     buffers.

     If you set this variable to 'nil' in a buffer, that buffer does not
     have a mode line.  (A window that is just one line tall also does
     not display a mode line.)

   The default value of 'mode-line-format' is designed to use the values
of other variables such as 'mode-line-position' and 'mode-line-modes'
(which in turn incorporates the values of the variables 'mode-name' and
'minor-mode-alist').  Very few modes need to alter 'mode-line-format'
itself.  For most purposes, it is sufficient to alter some of the
variables that 'mode-line-format' either directly or indirectly refers
to.

   If you do alter 'mode-line-format' itself, the new value should use
the same variables that appear in the default value (*note Mode Line
Variables::), rather than duplicating their contents or displaying the
information in another fashion.  This way, customizations made by the
user or by Lisp programs (such as 'display-time' and major modes) via
changes to those variables remain effective.

   Here is a hypothetical example of a 'mode-line-format' that might be
useful for Shell mode (in reality, Shell mode does not set
'mode-line-format'):

     (setq mode-line-format
       (list "-"
        'mode-line-mule-info
        'mode-line-modified
        'mode-line-frame-identification
        "%b--"
        ;; Note that this is evaluated while making the list.
        ;; It makes a mode line construct which is just a string.
        (getenv "HOST")
        ":"
        'default-directory
        "   "
        'global-mode-string
        "   %[("
        '(:eval (format-time-string "%F"))
        'mode-line-process
        'minor-mode-alist
        "%n"
        ")%]--"
        '(which-func-mode ("" which-func-format "--"))
        '(line-number-mode "L%l--")
        '(column-number-mode "C%c--")
        '(-3 "%p")))

(The variables 'line-number-mode', 'column-number-mode' and
'which-func-mode' enable particular minor modes; as usual, these
variable names are also the minor mode command names.)

==============================================================================
File: elisp.info,  Node: |Mode_Line_Variables|,  Next: |%_Constructs|,  Prev: |Mode_Line_Top|,  Up: |Mode_Line_Format|
==============================================================================

                                                           *Mode_Line_Variables*

23.4.4 Variables Used in the Mode Line
--------------------------------------

This section describes variables incorporated by the standard value of
'mode-line-format' into the text of the mode line.  There is nothing
inherently special about these variables; any other variables could have
the same effects on the mode line if the value of 'mode-line-format' is
changed to use them.  However, various parts of Emacs set these
variables on the understanding that they will control parts of the mode
line; therefore, practically speaking, it is essential for the mode line
to use them.  Also see *note (emacs)Optional Mode Line::.

 -- Variable: mode-line-mule-info
     This variable holds the value of the mode line construct that
     displays information about the language environment, buffer coding
     system, and current input method.  *Note Non-ASCII Characters::.

 -- Variable: mode-line-modified
     This variable holds the value of the mode line construct that
     displays whether the current buffer is modified.  Its default value
     displays '**' if the buffer is modified, '--' if the buffer is not
     modified, '%%' if the buffer is read only, and '%*' if the buffer
     is read only and modified.

     Changing this variable does not force an update of the mode line.

 -- Variable: mode-line-frame-identification
     This variable identifies the current frame.  Its default value
     displays '" "' if you are using a window system which can show
     multiple frames, or '"-%F "' on an ordinary terminal which shows
     only one frame at a time.

 -- Variable: mode-line-buffer-identification
     This variable identifies the buffer being displayed in the window.
     Its default value displays the buffer name, padded with spaces to
     at least 12 columns.

 -- Variable: mode-line-position
     This variable indicates the position in the buffer.  Its default
     value displays the buffer percentage and, optionally, the buffer
     size, the line number and the column number.

 -- User Option: mode-line-percent-position
     This option is used in 'mode-line-position'.  Its value specifies
     both the buffer percentage to display (one of 'nil', '"%o"',
     '"%p"', '"%P"' or '"%q"', *note %-Constructs::) and a width to
     space-fill or truncate to.  You are recommended to set this option
     with the 'customize-variable' facility.

 -- Variable: vc-mode
     The variable 'vc-mode', buffer-local in each buffer, records
     whether the buffer's visited file is maintained with version
     control, and, if so, which kind.  Its value is a string that
     appears in the mode line, or 'nil' for no version control.

 -- Variable: mode-line-modes
     This variable displays the buffer's major and minor modes.  Its
     default value also displays the recursive editing level,
     information on the process status, and whether narrowing is in
     effect.

 -- Variable: mode-line-remote
     This variable is used to show whether 'default-directory' for the
     current buffer is remote.

 -- Variable: mode-line-client
     This variable is used to identify 'emacsclient' frames.

   The following three variables are used in 'mode-line-modes':

 -- Variable: mode-name
     This buffer-local variable holds the "pretty" name of the current
     buffer's major mode.  Each major mode should set this variable so
     that the mode name will appear in the mode line.  The value does
     not have to be a string, but can use any of the data types valid in
     a mode-line construct (*note Mode Line Data::).  To compute the
     string that will identify the mode name in the mode line, use
     'format-mode-line' (*note Emulating Mode Line::).

 -- Variable: mode-line-process
     This buffer-local variable contains the mode line information on
     process status in modes used for communicating with subprocesses.
     It is displayed immediately following the major mode name, with no
     intervening space.  For example, its value in the 'shell' buffer
     is '(":%s")', which allows the shell to display its status along
     with the major mode as: '(Shell:run)'.  Normally this variable is
     'nil'.

 -- Variable: mode-line-front-space
     This variable is displayed at the front of the mode line.  By
     default, this construct is displayed right at the beginning of the
     mode line, except that if there is a memory-full message, it is
     displayed first.

 -- Variable: mode-line-end-spaces
     This variable is displayed at the end of the mode line.

 -- Variable: mode-line-misc-info
     Mode line construct for miscellaneous information.  By default,
     this shows the information specified by 'global-mode-string'.

 -- Variable: minor-mode-alist
     This variable holds an association list whose elements specify how
     the mode line should indicate that a minor mode is active.  Each
     element of the 'minor-mode-alist' should be a two-element list:

          (MINOR-MODE-VARIABLE MODE-LINE-STRING)

     More generally, MODE-LINE-STRING can be any mode line construct.
     It appears in the mode line when the value of MINOR-MODE-VARIABLE
     is non-'nil', and not otherwise.  These strings should begin with
     spaces so that they don't run together.  Conventionally, the
     MINOR-MODE-VARIABLE for a specific mode is set to a non-'nil' value
     when that minor mode is activated.

     'minor-mode-alist' itself is not buffer-local.  Each variable
     mentioned in the alist should be buffer-local if its minor mode can
     be enabled separately in each buffer.

 -- Variable: global-mode-string
     This variable holds a mode line construct that, by default, appears
     in the mode line just after the 'which-func-mode' minor mode if
     set, else after 'mode-line-modes'.  The command 'display-time' sets
     'global-mode-string' to refer to the variable
     'display-time-string', which holds a string containing the time and
     load information.

     The '%M' construct substitutes the value of 'global-mode-string',
     but that is obsolete, since the variable is included in the mode
     line from 'mode-line-format'.

   Here is a simplified version of the default value of
'mode-line-format'.  The real default value also specifies addition of
text properties.

     ("-"
      mode-line-mule-info
      mode-line-modified
      mode-line-frame-identification
      mode-line-buffer-identification
      "   "
      mode-line-position
      (vc-mode vc-mode)
      "   "
      mode-line-modes
      (which-func-mode ("" which-func-format "--"))
      (global-mode-string ("--" global-mode-string))
      "-%-")

==============================================================================
File: elisp.info,  Node: |%_Constructs|,  Next: |Properties_in_Mode|,  Prev: |Mode_Line_Variables|,  Up: |Mode_Line_Format|
==============================================================================

                                                                  *%_Constructs*

23.4.5 '%'-Constructs in the Mode Line
--------------------------------------

Strings used as mode line constructs can use certain '%'-constructs to
substitute various kinds of data.  The following is a list of the
defined '%'-constructs, and what they mean.

   In any construct except '%%', you can add a decimal integer after the
'%' to specify a minimum field width.  If the width is less, the field
is padded to that width.  Purely numeric constructs ('c', 'i', 'I', and
'l') are padded by inserting spaces to the left, and others are padded
by inserting spaces to the right.

'%b'
     The current buffer name, obtained with the 'buffer-name' function.
     *Note Buffer Names::.

'%c'
     The current column number of point, counting from zero starting at
     the left margin of the window.

'%C'
     The current column number of point, counting from one starting at
     the left margin of the window.

'%e'
     When Emacs is nearly out of memory for Lisp objects, a brief
     message saying so.  Otherwise, this is empty.

'%f'
     The visited file name, obtained with the 'buffer-file-name'
     function.  *Note Buffer File Name::.

'%F'
     The title (only on a window system) or the name of the selected
     frame.  *Note Basic Parameters::.

'%i'
     The size of the accessible part of the current buffer; basically
     '(- (point-max) (point-min))'.

'%I'
     Like '%i', but the size is printed in a more readable way by using
     'k' for 10^3, 'M' for 10^6, 'G' for 10^9, etc., to abbreviate.

'%l'
     The current line number of point, counting within the accessible
     portion of the buffer.

'%n'
     'Narrow' when narrowing is in effect; nothing otherwise (see
     'narrow-to-region' in *note Narrowing::).

'%o'
     The degree of "travel" of the window through (the visible portion
     of) the buffer, i.e.  the size of the text above the top of the
     window expressed as a percentage of all the text outside the
     window, or 'Top', 'Bottom' or 'All'.

'%p'
     The percentage of the buffer text above the top of window, or
     'Top', 'Bottom' or 'All'.  Note that the default mode line
     construct truncates this to three characters.

'%P'
     The percentage of the buffer text that is above the bottom of the
     window (which includes the text visible in the window, as well as
     the text above the top), plus 'Top' if the top of the buffer is
     visible on screen; or 'Bottom' or 'All'.

'%q'
     The percentages of text above both the top and the *bottom* of
     the window, separated by '-', or 'All'.

'%s'
     The status of the subprocess belonging to the current buffer,
     obtained with 'process-status'.  *Note Process Information::.

'%z'
     The mnemonics of keyboard, terminal, and buffer coding systems.

'%Z'
     Like '%z', but including the end-of-line format.

'%*'
     '%' if the buffer is read only (see 'buffer-read-only');
     '*' if the buffer is modified (see 'buffer-modified-p');
     '-' otherwise.  *Note Buffer Modification::.

'%+'
     '*' if the buffer is modified (see 'buffer-modified-p');
     '%' if the buffer is read only (see 'buffer-read-only');
     '-' otherwise.  This differs from '%*' only for a modified
     read-only buffer.  *Note Buffer Modification::.

'%&'
     '*' if the buffer is modified, and '-' otherwise.

'%['
     An indication of the depth of recursive editing levels (not
     counting minibuffer levels): one '[' for each editing level.  *Note
     Recursive Editing::.

'%]'
     One ']' for each recursive editing level (not counting minibuffer
     levels).

'%-'
     Dashes sufficient to fill the remainder of the mode line.

'%%'
     The character '%'--this is how to include a literal '%' in a string
     in which '%'-constructs are allowed.

   The following two '%'-constructs are still supported, but they are
obsolete, since you can get the same results with the variables
'mode-name' and 'global-mode-string'.

'%m'
     The value of 'mode-name'.

'%M'
     The value of 'global-mode-string'.

==============================================================================
File: elisp.info,  Node: |Properties_in_Mode|,  Next: |Header_Lines|,  Prev: |%_Constructs|,  Up: |Mode_Line_Format|
==============================================================================

                                                            *Properties_in_Mode*

23.4.6 Properties in the Mode Line
----------------------------------

Certain text properties are meaningful in the mode line.  The 'face'
property affects the appearance of text; the 'help-echo' property
associates help strings with the text, and 'keymap' can make the text
mouse-sensitive.

   There are four ways to specify text properties for text in the mode
line:

  1. Put a string with a text property directly into the mode line data
     structure.

  2. Put a text property on a mode line %-construct such as '%12b'; then
     the expansion of the %-construct will have that same text property.

  3. Use a '(:propertize ELT PROPS...)' construct to give ELT a text
     property specified by PROPS.

  4. Use a list containing ':eval FORM' in the mode line data structure,
     and make FORM evaluate to a string that has a text property.

   You can use the 'keymap' property to specify a keymap.  This keymap
only takes real effect for mouse clicks; binding character keys and
function keys to it has no effect, since it is impossible to move point
into the mode line.

   When the mode line refers to a variable which does not have a
non-'nil' 'risky-local-variable' property, any text properties given or
specified within that variable's values are ignored.  This is because
such properties could otherwise specify functions to be called, and
those functions could come from file local variables.

==============================================================================
File: elisp.info,  Node: |Header_Lines|,  Next: |Emulating_Mode_Line|,  Prev: |Properties_in_Mode|,  Up: |Mode_Line_Format|
==============================================================================

                                                                  *Header_Lines*

23.4.7 Window Header Lines
--------------------------

A window can have a "header line" at the top, just as it can have a mode
line at the bottom.  The header line feature works just like the mode
line feature, except that it's controlled by 'header-line-format':

 -- Variable: header-line-format
     This variable, local in every buffer, specifies how to display the
     header line, for windows displaying the buffer.  The format of the
     value is the same as for 'mode-line-format' (*note Mode Line
     Data::).  It is normally 'nil', so that ordinary buffers have no
     header line.

 -- Function: window-header-line-height &optional window
     This function returns the height in pixels of WINDOW's header line.
     WINDOW must be a live window, and defaults to the selected window.

   A window that is just one line tall never displays a header line.  A
window that is two lines tall cannot display both a mode line and a
header line at once; if it has a mode line, then it does not display a
header line.

==============================================================================
File: elisp.info,  Node: |Emulating_Mode_Line|,  Prev: |Header_Lines|,  Up: |Mode_Line_Format|
==============================================================================

                                                           *Emulating_Mode_Line*

23.4.8 Emulating Mode Line Formatting
-------------------------------------

You can use the function 'format-mode-line' to compute the text that
would appear in a mode line or header line based on a certain mode line
construct.

 -- Function: format-mode-line format &optional face window buffer
     This function formats a line of text according to FORMAT as if it
     were generating the mode line for WINDOW, but it also returns the
     text as a string.  The argument WINDOW defaults to the selected
     window.  If BUFFER is non-'nil', all the information used is taken
     from BUFFER; by default, it comes from WINDOW's buffer.

     The value string normally has text properties that correspond to
     the faces, keymaps, etc., that the mode line would have.  Any
     character for which no 'face' property is specified by FORMAT gets
     a default value determined by FACE.  If FACE is 't', that stands
     for either 'mode-line' if WINDOW is selected, otherwise
     'mode-line-inactive'.  If FACE is 'nil' or omitted, that stands for
     the default face.  If FACE is an integer, the value returned by
     this function will have no text properties.

     You can also specify other valid faces as the value of FACE.  If
     specified, that face provides the 'face' property for characters
     whose face is not specified by FORMAT.

     Note that using 'mode-line', 'mode-line-inactive', or 'header-line'
     as FACE will actually redisplay the mode line or the header line,
     respectively, using the current definitions of the corresponding
     face, in addition to returning the formatted string.  (Other faces
     do not cause redisplay.)

     For example, '(format-mode-line header-line-format)' returns the
     text that would appear in the selected window's header line ('""'
     if it has no header line).  '(format-mode-line header-line-format
     'header-line)' returns the same text, with each character carrying
     the face that it will have in the header line itself, and also
     redraws the header line.

==============================================================================
File: elisp.info,  Node: |Imenu|,  Next: |Font_Lock_Mode|,  Prev: |Mode_Line_Format|,  Up: |Modes|
==============================================================================

                                                                         *Imenu*

23.5 Imenu
----------

"Imenu" is a feature that lets users select a definition or section in
the buffer, from a menu which lists all of them, to go directly to that
location in the buffer.  Imenu works by constructing a buffer index
which lists the names and buffer positions of the definitions, or other
named portions of the buffer; then the user can choose one of them and
move point to it.  Major modes can add a menu bar item to use Imenu
using 'imenu-add-to-menubar'.

 -- Command: imenu-add-to-menubar name
     This function defines a local menu bar item named NAME to run
     Imenu.

   The user-level commands for using Imenu are described in the Emacs
Manual (*note Imenu: (emacs)Imenu.).  This section explains how to
customize Imenu's method of finding definitions or buffer portions for a
particular major mode.

   The usual and simplest way is to set the variable
'imenu-generic-expression':

 -- Variable: imenu-generic-expression
     This variable, if non-'nil', is a list that specifies regular
     expressions for finding definitions for Imenu.  Simple elements of
     'imenu-generic-expression' look like this:

          (MENU-TITLE REGEXP INDEX)

     Here, if MENU-TITLE is non-'nil', it says that the matches for this
     element should go in a submenu of the buffer index; MENU-TITLE
     itself specifies the name for the submenu.  If MENU-TITLE is 'nil',
     the matches for this element go directly in the top level of the
     buffer index.

     The second item in the list, REGEXP, is a regular expression (*note
     Regular Expressions::); anything in the buffer that it matches is
     considered a definition, something to mention in the buffer index.
     The third item, INDEX, is a non-negative integer that indicates
     which subexpression in REGEXP matches the definition's name.

     An element can also look like this:

          (MENU-TITLE REGEXP INDEX FUNCTION ARGUMENTS...)

     Each match for this element creates an index item, and when the
     index item is selected by the user, it calls FUNCTION with
     arguments consisting of the item name, the buffer position, and
     ARGUMENTS.

     For Emacs Lisp mode, 'imenu-generic-expression' could look like
     this:

          ((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2)
           ("Vars" "^\\s-*(def\\(var\\|const\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2)
           ("Types"
            "^\\s-*\
          (def\\(type\\|struct\\|class\\|ine-condition\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2))

     Setting this variable makes it buffer-local in the current buffer.

 -- Variable: imenu-case-fold-search
     This variable controls whether matching against the regular
     expressions in the value of 'imenu-generic-expression' is
     case-sensitive: 't', the default, means matching should ignore
     case.

     Setting this variable makes it buffer-local in the current buffer.

 -- Variable: imenu-syntax-alist
     This variable is an alist of syntax table modifiers to use while
     processing 'imenu-generic-expression', to override the syntax table
     of the current buffer.  Each element should have this form:

          (CHARACTERS . SYNTAX-DESCRIPTION)

     The CAR, CHARACTERS, can be either a character or a string.  The
     element says to give that character or characters the syntax
     specified by SYNTAX-DESCRIPTION, which is passed to
     'modify-syntax-entry' (*note Syntax Table Functions::).

     This feature is typically used to give word syntax to characters
     which normally have symbol syntax, and thus to simplify
     'imenu-generic-expression' and speed up matching.  For example,
     Fortran mode uses it this way:

          (setq imenu-syntax-alist '(("_$" . "w")))

     The 'imenu-generic-expression' regular expressions can then use
     '\\sw+' instead of '\\(\\sw\\|\\s_\\)+'.  Note that this technique
     may be inconvenient when the mode needs to limit the initial
     character of a name to a smaller set of characters than are allowed
     in the rest of a name.

     Setting this variable makes it buffer-local in the current buffer.

   Another way to customize Imenu for a major mode is to set the
variables 'imenu-prev-index-position-function' and
'imenu-extract-index-name-function':

 -- Variable: imenu-prev-index-position-function
     If this variable is non-'nil', its value should be a function that
     finds the next definition to put in the buffer index, scanning
     backward in the buffer from point.  It should return 'nil' if it
     doesn't find another definition before point.  Otherwise it should
     leave point at the place it finds a definition and return any
     non-'nil' value.

     Setting this variable makes it buffer-local in the current buffer.

 -- Variable: imenu-extract-index-name-function
     If this variable is non-'nil', its value should be a function to
     return the name for a definition, assuming point is in that
     definition as the 'imenu-prev-index-position-function' function
     would leave it.

     Setting this variable makes it buffer-local in the current buffer.

   The last way to customize Imenu for a major mode is to set the
variable 'imenu-create-index-function':

 -- Variable: imenu-create-index-function
     This variable specifies the function to use for creating a buffer
     index.  The function should take no arguments, and return an index
     alist for the current buffer.  It is called within
     'save-excursion', so where it leaves point makes no difference.

     The index alist can have three types of elements.  Simple elements
     look like this:

          (INDEX-NAME . INDEX-POSITION)

     Selecting a simple element has the effect of moving to position
     INDEX-POSITION in the buffer.  Special elements look like this:

          (INDEX-NAME INDEX-POSITION FUNCTION ARGUMENTS...)

     Selecting a special element performs:

          (funcall FUNCTION
                   INDEX-NAME INDEX-POSITION ARGUMENTS...)

     A nested sub-alist element looks like this:

          (MENU-TITLE . SUB-ALIST)

     It creates the submenu MENU-TITLE specified by SUB-ALIST.

     The default value of 'imenu-create-index-function' is
     'imenu-default-create-index-function'.  This function calls the
     value of 'imenu-prev-index-position-function' and the value of
     'imenu-extract-index-name-function' to produce the index alist.
     However, if either of these two variables is 'nil', the default
     function uses 'imenu-generic-expression' instead.

     Setting this variable makes it buffer-local in the current buffer.

==============================================================================
File: elisp.info,  Node: |Font_Lock_Mode|,  Next: |Auto_Indentation|,  Prev: |Imenu|,  Up: |Modes|
==============================================================================

                                                                *Font_Lock_Mode*

23.6 Font Lock Mode
-------------------

"Font Lock mode" is a buffer-local minor mode that automatically
attaches 'face' properties to certain parts of the buffer based on their
syntactic role.  How it parses the buffer depends on the major mode;
most major modes define syntactic criteria for which faces to use in
which contexts.  This section explains how to customize Font Lock for a
particular major mode.

   Font Lock mode finds text to highlight in two ways: through syntactic
parsing based on the syntax table, and through searching (usually for
regular expressions).  Syntactic fontification happens first; it finds
comments and string constants and highlights them.  Search-based
fontification happens second.

MENU

* |Font_Lock_Basics|::            Overview of customizing Font Lock.
* |Search_based_Fontification|::  Fontification based on regexps.
* |Customizing_Keywords|::        Customizing search-based fontification.
* |Other_Font_Lock_Variables|::   Additional customization facilities.
* |Levels_of_Font_Lock|::         Each mode can define alternative levels
                                  so that the user can select more or less.
* |Precalculated_Fontification|::  How Lisp programs that produce the buffer
                                  contents can also specify how to fontify it.
* |Faces_for_Font_Lock|::         Special faces specifically for Font Lock.
* |Syntactic_Font_Lock|::         Fontification based on syntax tables.
* |Multiline_Font_Lock|::         How to coerce Font Lock into properly
                                  highlighting multiline constructs.

==============================================================================
File: elisp.info,  Node: |Font_Lock_Basics|,  Next: |Search_based_Fontification|,  Up: |Font_Lock_Mode|
==============================================================================

                                                              *Font_Lock_Basics*

23.6.1 Font Lock Basics
-----------------------

The Font Lock functionality is based on several basic functions.  Each
of these calls the function specified by the corresponding variable.
This indirection allows major and minor modes to modify the way
fontification works in the buffers of that mode, and even use the Font
Lock mechanisms for features that have nothing to do with fontification.
(This is why the description below says "should" when it describes what
the functions do: the mode can customize the values of the corresponding
variables to do something entirely different.)  The variables mentioned
below are described in *note Other Font Lock Variables::.

'font-lock-fontify-buffer'
     This function should fontify the current buffer's accessible
     portion, by calling the function specified by
     'font-lock-fontify-buffer-function'.

'font-lock-unfontify-buffer'
     Used when turning Font Lock off to remove the fontification.  Calls
     the function specified by 'font-lock-unfontify-buffer-function'.

'font-lock-fontify-region beg end &optional loudly'
     Should fontify the region between BEG and END.  If LOUDLY is
     non-'nil', should display status messages while fontifying.  Calls
     the function specified by 'font-lock-fontify-region-function'.

'font-lock-unfontify-region beg end'
     Should remove fontification from the region between BEG and END.
     Calls the function specified by
     'font-lock-unfontify-region-function'.

'font-lock-flush &optional beg end'
     This function should mark the fontification of the region between
     BEG and END as outdated.  If not specified or 'nil', BEG and END
     default to the beginning and end of the buffer's accessible
     portion.  Calls the function specified by
     'font-lock-flush-function'.

'font-lock-ensure &optional beg end'
     This function should make sure the region between BEG and END has
     been fontified.  The optional arguments BEG and END default to the
     beginning and the end of the buffer's accessible portion.  Calls
     the function specified by 'font-lock-ensure-function'.

'font-lock-debug-fontify'
     This is a convenience command meant to be used when developing font
     locking for a mode, and should not be called from Lisp code.  It
     recomputes all the relevant variables and then calls
     'font-lock-fontify-region' on the entire buffer.

   There are several variables that control how Font Lock mode
highlights text.  But major modes should not set any of these variables
directly.  Instead, they should set 'font-lock-defaults' as a
buffer-local variable.  The value assigned to this variable is used, if
and when Font Lock mode is enabled, to set all the other variables.

 -- Variable: font-lock-defaults
     This variable is set by modes to specify how to fontify text in
     that mode.  It automatically becomes buffer-local when set.  If its
     value is 'nil', Font Lock mode does no highlighting, and you can
     use the 'Faces' menu (under 'Edit' and then 'Text Properties' in
     the menu bar) to assign faces explicitly to text in the buffer.

     If non-'nil', the value should look like this:

          (KEYWORDS [KEYWORDS-ONLY [CASE-FOLD
           [SYNTAX-ALIST OTHER-VARS...]]])

     The first element, KEYWORDS, indirectly specifies the value of
     'font-lock-keywords' which directs search-based fontification.  It
     can be a symbol, a variable or a function whose value is the list
     to use for 'font-lock-keywords'.  It can also be a list of several
     such symbols, one for each possible level of fontification.  The
     first symbol specifies the 'mode default' level of fontification,
     the next symbol level 1 fontification, the next level 2, and so on.
     The 'mode default' level is normally the same as level 1.  It is
     used when 'font-lock-maximum-decoration' has a 'nil' value.  *Note
     Levels of Font Lock::.

     The second element, KEYWORDS-ONLY, specifies the value of the
     variable 'font-lock-keywords-only'.  If this is omitted or 'nil',
     syntactic fontification (of strings and comments) is also
     performed.  If this is non-'nil', syntactic fontification is not
     performed.  *Note Syntactic Font Lock::.

     The third element, CASE-FOLD, specifies the value of
     'font-lock-keywords-case-fold-search'.  If it is non-'nil', Font
     Lock mode ignores case during search-based fontification.

     If the fourth element, SYNTAX-ALIST, is non-'nil', it should be a
     list of cons cells of the form '(CHAR-OR-STRING . STRING)'.  These
     are used to set up a syntax table for syntactic fontification; the
     resulting syntax table is stored in 'font-lock-syntax-table'.  If
     SYNTAX-ALIST is omitted or 'nil', syntactic fontification uses the
     syntax table returned by the 'syntax-table' function.  *Note Syntax
     Table Functions::.

     All the remaining elements (if any) are collectively called
     OTHER-VARS.  Each of these elements should have the form '(VARIABLE
     . VALUE)'--which means, make VARIABLE buffer-local and then set it
     to VALUE.  You can use these OTHER-VARS to set other variables that
     affect fontification, aside from those you can control with the
     first five elements.  *Note Other Font Lock Variables::.

   If your mode fontifies text explicitly by adding 'font-lock-face'
properties, it can specify '(nil t)' for 'font-lock-defaults' to turn
off all automatic fontification.  However, this is not required; it is
possible to fontify some things using 'font-lock-face' properties and
set up automatic fontification for other parts of the text.

==============================================================================
File: elisp.info,  Node: |Search_based_Fontification|,  Next: |Customizing_Keywords|,  Prev: |Font_Lock_Basics|,  Up: |Font_Lock_Mode|
==============================================================================

                                                    *Search_based_Fontification*

23.6.2 Search-based Fontification
---------------------------------

The variable which directly controls search-based fontification is
'font-lock-keywords', which is typically specified via the KEYWORDS
element in 'font-lock-defaults'.

 -- Variable: font-lock-keywords
     The value of this variable is a list of the keywords to highlight.
     Lisp programs should not set this variable directly.  Normally, the
     value is automatically set by Font Lock mode, using the KEYWORDS
     element in 'font-lock-defaults'.  The value can also be altered
     using the functions 'font-lock-add-keywords' and
     'font-lock-remove-keywords' (*note Customizing Keywords::).

   Each element of 'font-lock-keywords' specifies how to find certain
cases of text, and how to highlight those cases.  Font Lock mode
processes the elements of 'font-lock-keywords' one by one, and for each
element, it finds and handles all matches.  Ordinarily, once part of the
text has been fontified already, this cannot be overridden by a
subsequent match in the same text; but you can specify different
behavior using the OVERRIDE element of a SUBEXP-HIGHLIGHTER.

   Each element of 'font-lock-keywords' should have one of these forms:

'REGEXP'
     Highlight all matches for REGEXP using 'font-lock-keyword-face'.
     For example,

          ;; Highlight occurrences of the word 'foo'
          ;; using 'font-lock-keyword-face'.
          "\\<foo\\>"

     Be careful when composing these regular expressions; a poorly
     written pattern can dramatically slow things down!  The function
     'regexp-opt' (*note Regexp Functions::) is useful for calculating
     optimal regular expressions to match several keywords.

'FUNCTION'
     Find text by calling FUNCTION, and highlight the matches it finds
     using 'font-lock-keyword-face'.

     When FUNCTION is called, it receives one argument, the limit of the
     search; it should begin searching at point, and not search beyond
     the limit.  It should return non-'nil' if it succeeds, and set the
     match data to describe the match that was found.  Returning 'nil'
     indicates failure of the search.

     Fontification will call FUNCTION repeatedly with the same limit,
     and with point where the previous invocation left it, until
     FUNCTION fails.  On failure, FUNCTION need not reset point in any
     particular way.

'(MATCHER . SUBEXP)'
     In this kind of element, MATCHER is either a regular expression or
     a function, as described above.  The CDR, SUBEXP, specifies which
     subexpression of MATCHER should be highlighted (instead of the
     entire text that MATCHER matched).

          ;; Highlight the 'bar' in each occurrence of 'fubar',
          ;; using 'font-lock-keyword-face'.
          ("fu\\(bar\\)" . 1)

     If you use 'regexp-opt' to produce the regular expression MATCHER,
     you can use 'regexp-opt-depth' (*note Regexp Functions::) to
     calculate the value for SUBEXP.

'(MATCHER . FACESPEC)'
     In this kind of element, FACESPEC is an expression whose value
     specifies the face to use for highlighting.  In the simplest case,
     FACESPEC is a Lisp variable (a symbol) whose value is a face name.

          ;; Highlight occurrences of 'fubar',
          ;; using the face which is the value of 'fubar-face'.
          ("fubar" . fubar-face)

     However, FACESPEC can also evaluate to a list of this form:

          (face FACE PROP1 VAL1 PROP2 VAL2...)

     to specify the face FACE and various additional text properties to
     put on the text that matches.  If you do this, be sure to add the
     other text property names that you set in this way to the value of
     'font-lock-extra-managed-props' so that the properties will also be
     cleared out when they are no longer appropriate.  Alternatively,
     you can set the variable 'font-lock-unfontify-region-function' to a
     function that clears these properties.  *Note Other Font Lock
     Variables::.

'(MATCHER . SUBEXP-HIGHLIGHTER)'
     In this kind of element, SUBEXP-HIGHLIGHTER is a list which
     specifies how to highlight matches found by MATCHER.  It has the
     form:

          (SUBEXP FACESPEC [OVERRIDE [LAXMATCH]])

     The CAR, SUBEXP, is an integer specifying which subexpression of
     the match to fontify (0 means the entire matching text).  The
     second subelement, FACESPEC, is an expression whose value specifies
     the face, as described above.

     The last two values in SUBEXP-HIGHLIGHTER, OVERRIDE and LAXMATCH,
     are optional flags.  If OVERRIDE is 't', this element can override
     existing fontification made by previous elements of
     'font-lock-keywords'.  If it is 'keep', then each character is
     fontified if it has not been fontified already by some other
     element.  If it is 'prepend', the face specified by FACESPEC is
     added to the beginning of the 'font-lock-face' property.  If it is
     'append', the face is added to the end of the 'font-lock-face'
     property.

     If LAXMATCH is non-'nil', it means there should be no error if
     there is no subexpression numbered SUBEXP in MATCHER.  Obviously,
     fontification of the subexpression numbered SUBEXP will not occur.
     However, fontification of other subexpressions (and other regexps)
     will continue.  If LAXMATCH is 'nil', and the specified
     subexpression is missing, then an error is signaled which
     terminates search-based fontification.

     Here are some examples of elements of this kind, and what they do:

          ;; Highlight occurrences of either 'foo' or 'bar', using
          ;; 'foo-bar-face', even if they have already been highlighted.
          ;; 'foo-bar-face' should be a variable whose value is a face.
          ("foo\\|bar" 0 foo-bar-face t)

          ;; Highlight the first subexpression within each occurrence
          ;; that the function 'fubar-match' finds,
          ;; using the face which is the value of 'fubar-face'.
          (fubar-match 1 fubar-face)

'(MATCHER . ANCHORED-HIGHLIGHTER)'
     In this kind of element, ANCHORED-HIGHLIGHTER specifies how to
     highlight text that follows a match found by MATCHER.  So a match
     found by MATCHER acts as the anchor for further searches specified
     by ANCHORED-HIGHLIGHTER.  ANCHORED-HIGHLIGHTER is a list of the
     following form:

          (ANCHORED-MATCHER PRE-FORM POST-FORM
                                  SUBEXP-HIGHLIGHTERS...)

     Here, ANCHORED-MATCHER, like MATCHER, is either a regular
     expression or a function.  After a match of MATCHER is found, point
     is at the end of the match.  Now, Font Lock evaluates the form
     PRE-FORM.  Then it searches for matches of ANCHORED-MATCHER and
     uses SUBEXP-HIGHLIGHTERS to highlight these.  A SUBEXP-HIGHLIGHTER
     is as described above.  Finally, Font Lock evaluates POST-FORM.

     The forms PRE-FORM and POST-FORM can be used to initialize before,
     and cleanup after, ANCHORED-MATCHER is used.  Typically, PRE-FORM
     is used to move point to some position relative to the match of
     MATCHER, before starting with ANCHORED-MATCHER.  POST-FORM might be
     used to move back, before resuming with MATCHER.

     After Font Lock evaluates PRE-FORM, it does not search for
     ANCHORED-MATCHER beyond the end of the line.  However, if PRE-FORM
     returns a buffer position that is greater than the position of
     point after PRE-FORM is evaluated, then the position returned by
     PRE-FORM is used as the limit of the search instead.  It is
     generally a bad idea to return a position greater than the end of
     the line; in other words, the ANCHORED-MATCHER search should not
     span lines.

     For example,

          ;; Highlight occurrences of the word 'item' following
          ;; an occurrence of the word 'anchor' (on the same line)
          ;; in the value of 'item-face'.
          ("\\<anchor\\>" "\\<item\\>" nil nil (0 item-face))

     Here, PRE-FORM and POST-FORM are 'nil'.  Therefore searching for
     'item' starts at the end of the match of 'anchor', and searching
     for subsequent instances of 'anchor' resumes from where searching
     for 'item' concluded.

'(MATCHER HIGHLIGHTERS...)'
     This sort of element specifies several HIGHLIGHTER lists for a
     single MATCHER.  A HIGHLIGHTER list can be of the type
     SUBEXP-HIGHLIGHTER or ANCHORED-HIGHLIGHTER as described above.

     For example,

          ;; Highlight occurrences of the word 'anchor' in the value
          ;; of 'anchor-face', and subsequent occurrences of the word
          ;; 'item' (on the same line) in the value of 'item-face'.
          ("\\<anchor\\>" (0 anchor-face)
                          ("\\<item\\>" nil nil (0 item-face)))

'(eval . FORM)'
     Here FORM is an expression to be evaluated the first time this
     value of 'font-lock-keywords' is used in a buffer.  Its value
     should have one of the forms described in this table.

   Warning: Do not design an element of 'font-lock-keywords' to match
text which spans lines; this does not work reliably.  For details, *note
Multiline Font Lock::.

   You can use CASE-FOLD in 'font-lock-defaults' to specify the value of
'font-lock-keywords-case-fold-search' which says whether search-based
fontification should be case-insensitive.

 -- Variable: font-lock-keywords-case-fold-search
     Non-'nil' means that regular expression matching for the sake of
     'font-lock-keywords' should be case-insensitive.

==============================================================================
File: elisp.info,  Node: |Customizing_Keywords|,  Next: |Other_Font_Lock_Variables|,  Prev: |Search_based_Fontification|,  Up: |Font_Lock_Mode|
==============================================================================

                                                          *Customizing_Keywords*

23.6.3 Customizing Search-Based Fontification
---------------------------------------------

You can use 'font-lock-add-keywords' to add additional search-based
fontification rules to a major mode, and 'font-lock-remove-keywords' to
remove rules.

 -- Function: font-lock-add-keywords mode keywords &optional how
     This function adds highlighting KEYWORDS, for the current buffer or
     for major mode MODE.  The argument KEYWORDS should be a list with
     the same format as the variable 'font-lock-keywords'.

     If MODE is a symbol which is a major mode command name, such as
     'c-mode', the effect is that enabling Font Lock mode in MODE will
     add KEYWORDS to 'font-lock-keywords'.  Calling with a non-'nil'
     value of MODE is correct only in your '~/.emacs' file.

     If MODE is 'nil', this function adds KEYWORDS to
     'font-lock-keywords' in the current buffer.  This way of calling
     'font-lock-add-keywords' is usually used in mode hook functions.

     By default, KEYWORDS are added at the beginning of
     'font-lock-keywords'.  If the optional argument HOW is 'set', they
     are used to replace the value of 'font-lock-keywords'.  If HOW is
     any other non-'nil' value, they are added at the end of
     'font-lock-keywords'.

     Some modes provide specialized support you can use in additional
     highlighting patterns.  See the variables
     'c-font-lock-extra-types', 'c++-font-lock-extra-types', and
     'java-font-lock-extra-types', for example.

     Warning: Major mode commands must not call
     'font-lock-add-keywords' under any circumstances, either directly
     or indirectly, except through their mode hooks.  (Doing so would
     lead to incorrect behavior for some minor modes.)  They should set
     up their rules for search-based fontification by setting
     'font-lock-keywords'.

 -- Function: font-lock-remove-keywords mode keywords
     This function removes KEYWORDS from 'font-lock-keywords' for the
     current buffer or for major mode MODE.  As in
     'font-lock-add-keywords', MODE should be a major mode command name
     or 'nil'.  All the caveats and requirements for
     'font-lock-add-keywords' apply here too.  The argument KEYWORDS
     must exactly match the one used by the corresponding
     'font-lock-add-keywords'.

   For example, the following code adds two fontification patterns for C
mode: one to fontify the word 'FIXME', even in comments, and another to
fontify the words 'and', 'or' and 'not' as keywords.

     (font-lock-add-keywords 'c-mode
      '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
        ("\\<\\(and\\|or\\|not\\)\\>" . font-lock-keyword-face)))

This example affects only C mode proper.  To add the same patterns to C
mode _and_ all modes derived from it, do this instead:

     (add-hook 'c-mode-hook
      (lambda ()
       (font-lock-add-keywords nil
        '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
          ("\\<\\(and\\|or\\|not\\)\\>" .
           font-lock-keyword-face)))))

==============================================================================
File: elisp.info,  Node: |Other_Font_Lock_Variables|,  Next: |Levels_of_Font_Lock|,  Prev: |Customizing_Keywords|,  Up: |Font_Lock_Mode|
==============================================================================

                                                     *Other_Font_Lock_Variables*

23.6.4 Other Font Lock Variables
--------------------------------

This section describes additional variables that a major mode can set by
means of OTHER-VARS in 'font-lock-defaults' (*note Font Lock Basics::).

 -- Variable: font-lock-mark-block-function
     If this variable is non-'nil', it should be a function that is
     called with no arguments, to choose an enclosing range of text for
     refontification for the command 'M-o M-o'
     ('font-lock-fontify-block').

     The function should report its choice by placing the region around
     it.  A good choice is a range of text large enough to give proper
     results, but not too large so that refontification becomes slow.
     Typical values are 'mark-defun' for programming modes or
     'mark-paragraph' for textual modes.

 -- Variable: font-lock-extra-managed-props
     This variable specifies additional properties (other than
     'font-lock-face') that are being managed by Font Lock mode.  It is
     used by 'font-lock-default-unfontify-region', which normally only
     manages the 'font-lock-face' property.  If you want Font Lock to
     manage other properties as well, you must specify them in a
     FACESPEC in 'font-lock-keywords' as well as add them to this list.
     *Note Search-based Fontification::.

 -- Variable: font-lock-fontify-buffer-function
     Function to use for fontifying the buffer.  The default value is
     'font-lock-default-fontify-buffer'.

 -- Variable: font-lock-unfontify-buffer-function
     Function to use for unfontifying the buffer.  This is used when
     turning off Font Lock mode.  The default value is
     'font-lock-default-unfontify-buffer'.

 -- Variable: font-lock-fontify-region-function
     Function to use for fontifying a region.  It should take two
     arguments, the beginning and end of the region, and an optional
     third argument VERBOSE.  If VERBOSE is non-'nil', the function
     should print status messages.  The default value is
     'font-lock-default-fontify-region'.

 -- Variable: font-lock-unfontify-region-function
     Function to use for unfontifying a region.  It should take two
     arguments, the beginning and end of the region.  The default value
     is 'font-lock-default-unfontify-region'.

 -- Variable: font-lock-flush-function
     Function to use for declaring that a region's fontification is out
     of date.  It takes two arguments, the beginning and end of the
     region.  The default value of this variable is
     'font-lock-after-change-function'.

 -- Variable: font-lock-ensure-function
     Function to use for making sure a region of the current buffer has
     been fontified.  It is called with two arguments, the beginning and
     end of the region.  The default value of this variable is a
     function that calls 'font-lock-default-fontify-buffer' if the
     buffer is not fontified; the effect is to make sure the entire
     accessible portion of the buffer is fontified.

 -- Function: jit-lock-register function &optional contextual
     This function tells Font Lock mode to run the Lisp function
     FUNCTION any time it has to fontify or refontify part of the
     current buffer.  It calls FUNCTION before calling the default
     fontification functions, and gives it two arguments, START and END,
     which specify the region to be fontified or refontified.

     The optional argument CONTEXTUAL, if non-'nil', forces Font Lock
     mode to always refontify a syntactically relevant part of the
     buffer, and not just the modified lines.  This argument can usually
     be omitted.

     When Font Lock is activated in a buffer, it calls this function
     with a non-'nil' value of CONTEXTUAL if the value of
     'font-lock-keywords-only' (*note Syntactic Font Lock::) is 'nil'.

 -- Function: jit-lock-unregister function
     If FUNCTION was previously registered as a fontification function
     using 'jit-lock-register', this function unregisters it.

==============================================================================
File: elisp.info,  Node: |Levels_of_Font_Lock|,  Next: |Precalculated_Fontification|,  Prev: |Other_Font_Lock_Variables|,  Up: |Font_Lock_Mode|
==============================================================================

                                                           *Levels_of_Font_Lock*

23.6.5 Levels of Font Lock
--------------------------

Some major modes offer three different levels of fontification.  You can
define multiple levels by using a list of symbols for KEYWORDS in
'font-lock-defaults'.  Each symbol specifies one level of fontification;
it is up to the user to choose one of these levels, normally by setting
'font-lock-maximum-decoration' (*note (emacs)Font Lock::).  The chosen
level's symbol value is used to initialize 'font-lock-keywords'.

   Here are the conventions for how to define the levels of
fontification:

   * Level 1: highlight function declarations, file directives (such as
     include or import directives), strings and comments.  The idea is
     speed, so only the most important and top-level components are
     fontified.

   * Level 2: in addition to level 1, highlight all language keywords,
     including type names that act like keywords, as well as named
     constant values.  The idea is that all keywords (either syntactic
     or semantic) should be fontified appropriately.

   * Level 3: in addition to level 2, highlight the symbols being
     defined in function and variable declarations, and all builtin
     function names, wherever they appear.

==============================================================================
File: elisp.info,  Node: |Precalculated_Fontification|,  Next: |Faces_for_Font_Lock|,  Prev: |Levels_of_Font_Lock|,  Up: |Font_Lock_Mode|
==============================================================================

                                                   *Precalculated_Fontification*

23.6.6 Precalculated Fontification
----------------------------------

Some major modes such as 'list-buffers' and 'occur' construct the buffer
text programmatically.  The easiest way for them to support Font Lock
mode is to specify the faces of text when they insert the text in the
buffer.

   The way to do this is to specify the faces in the text with the
special text property 'font-lock-face' (*note Special Properties::).
When Font Lock mode is enabled, this property controls the display, just
like the 'face' property.  When Font Lock mode is disabled,
'font-lock-face' has no effect on the display.

   It is ok for a mode to use 'font-lock-face' for some text and also
use the normal Font Lock machinery.  But if the mode does not use the
normal Font Lock machinery, it should not set the variable
'font-lock-defaults'.  In this case the 'face' property will not be
overriden, so using the 'face' property could work too.  However, using
'font-lock-face' is generally preferable as it allows the user to
control the fontification by toggling 'font-lock-mode', and lets the
code work regardless of whether the mode uses Font Lock machinery or
not.

==============================================================================
File: elisp.info,  Node: |Faces_for_Font_Lock|,  Next: |Syntactic_Font_Lock|,  Prev: |Precalculated_Fontification|,  Up: |Font_Lock_Mode|
==============================================================================

                                                           *Faces_for_Font_Lock*

23.6.7 Faces for Font Lock
--------------------------

Font Lock mode can highlight using any face, but Emacs defines several
faces specifically for Font Lock to use to highlight text.  These "Font
Lock faces" are listed below.  They can also be used by major modes for
syntactic highlighting outside of Font Lock mode (*note Major Mode
Conventions::).

   Each of these symbols is both a face name, and a variable whose
default value is the symbol itself.  Thus, the default value of
'font-lock-comment-face' is 'font-lock-comment-face'.

   The faces are listed with descriptions of their typical usage, and in
order of greater to lesser prominence.  If a mode's syntactic categories
do not fit well with the usage descriptions, the faces can be assigned
using the ordering as a guide.

'font-lock-warning-face'
     for a construct that is peculiar (e.g., an unescaped confusable
     quote in an Emacs Lisp symbol like ''foo'), or that greatly changes
     the meaning of other text, like ';;;###autoload' in Emacs Lisp and
     '#error' in C.

'font-lock-function-name-face'
     for the name of a function being defined or declared.

'font-lock-variable-name-face'
     for the name of a variable being defined or declared.

'font-lock-keyword-face'
     for a keyword with special syntactic significance, like 'for' and
     'if' in C.

'font-lock-comment-face'
     for comments.

'font-lock-comment-delimiter-face'
     for comments delimiters, like '/*' and '*/' in C.  On most
     terminals, this inherits from 'font-lock-comment-face'.

'font-lock-type-face'
     for the names of user-defined data types.

'font-lock-constant-face'
     for the names of constants, like 'NULL' in C.

'font-lock-builtin-face'
     for the names of built-in functions.

'font-lock-preprocessor-face'
     for preprocessor commands.  This inherits, by default, from
     'font-lock-builtin-face'.

'font-lock-string-face'
     for string constants.

'font-lock-doc-face'
     for documentation strings in the code.  This inherits, by default,
     from 'font-lock-string-face'.

'font-lock-negation-char-face'
     for easily-overlooked negation characters.

==============================================================================
File: elisp.info,  Node: |Syntactic_Font_Lock|,  Next: |Multiline_Font_Lock|,  Prev: |Faces_for_Font_Lock|,  Up: |Font_Lock_Mode|
==============================================================================

                                                           *Syntactic_Font_Lock*

23.6.8 Syntactic Font Lock
--------------------------

Syntactic fontification uses a syntax table (*note Syntax Tables::) to
find and highlight syntactically relevant text.  If enabled, it runs
prior to search-based fontification.  The variable
'font-lock-syntactic-face-function', documented below, determines which
syntactic constructs to highlight.  There are several variables that
affect syntactic fontification; you should set them by means of
'font-lock-defaults' (*note Font Lock Basics::).

   Whenever Font Lock mode performs syntactic fontification on a stretch
of text, it first calls the function specified by
'syntax-propertize-function'.  Major modes can use this to apply
'syntax-table' text properties to override the buffer's syntax table in
special cases.  *Note Syntax Properties::.

 -- Variable: font-lock-keywords-only
     If the value of this variable is non-'nil', Font Lock does not do
     syntactic fontification, only search-based fontification based on
     'font-lock-keywords'.  It is normally set by Font Lock mode based
     on the KEYWORDS-ONLY element in 'font-lock-defaults'.  If the value
     is 'nil', Font Lock will call 'jit-lock-register' (*note Other Font
     Lock Variables::) to set up for automatic refontification of buffer
     text following a modified line to reflect the new syntactic context
     due to the change.

 -- Variable: font-lock-syntax-table
     This variable holds the syntax table to use for fontification of
     comments and strings.  It is normally set by Font Lock mode based
     on the SYNTAX-ALIST element in 'font-lock-defaults'.  If this value
     is 'nil', syntactic fontification uses the buffer's syntax table
     (the value returned by the function 'syntax-table'; *note Syntax
     Table Functions::).

 -- Variable: font-lock-syntactic-face-function
     If this variable is non-'nil', it should be a function to determine
     which face to use for a given syntactic element (a string or a
     comment).

     The function is called with one argument, the parse state at point
     returned by 'parse-partial-sexp', and should return a face.  The
     default value returns 'font-lock-comment-face' for comments and
     'font-lock-string-face' for strings (*note Faces for Font Lock::).

     This variable is normally set through the "other" elements in
     'font-lock-defaults':

          (setq-local font-lock-defaults
                      `(,python-font-lock-keywords
                        nil nil nil nil
                        (font-lock-syntactic-face-function
                         . python-font-lock-syntactic-face-function)))

==============================================================================
File: elisp.info,  Node: |Multiline_Font_Lock|,  Prev: |Syntactic_Font_Lock|,  Up: |Font_Lock_Mode|
==============================================================================

                                                           *Multiline_Font_Lock*

23.6.9 Multiline Font Lock Constructs
-------------------------------------

Normally, elements of 'font-lock-keywords' should not match across
multiple lines; that doesn't work reliably, because Font Lock usually
scans just part of the buffer, and it can miss a multi-line construct
that crosses the line boundary where the scan starts.  (The scan
normally starts at the beginning of a line.)

   Making elements that match multiline constructs work properly has two
aspects: correct _identification_ and correct _rehighlighting_.  The
first means that Font Lock finds all multiline constructs.  The second
means that Font Lock will correctly rehighlight all the relevant text
when a multiline construct is changed--for example, if some of the text
that was previously part of a multiline construct ceases to be part of
it.  The two aspects are closely related, and often getting one of them
to work will appear to make the other also work.  However, for reliable
results you must attend explicitly to both aspects.

   There are three ways to ensure correct identification of multiline
constructs:

   * Add a function to 'font-lock-extend-region-functions' that does the
     _identification_ and extends the scan so that the scanned text
     never starts or ends in the middle of a multiline construct.
   * Use the 'font-lock-fontify-region-function' hook similarly to
     extend the scan so that the scanned text never starts or ends in
     the middle of a multiline construct.
   * Somehow identify the multiline construct right when it gets
     inserted into the buffer (or at any point after that but before
     font-lock tries to highlight it), and mark it with a
     'font-lock-multiline' which will instruct font-lock not to start or
     end the scan in the middle of the construct.

   There are three ways to do rehighlighting of multiline constructs:

   * Place a 'font-lock-multiline' property on the construct.  This will
     rehighlight the whole construct if any part of it is changed.  In
     some cases you can do this automatically by setting the
     'font-lock-multiline' variable, which see.
   * Make sure 'jit-lock-contextually' is set and rely on it doing its
     job.  This will only rehighlight the part of the construct that
     follows the actual change, and will do it after a short delay.
     This only works if the highlighting of the various parts of your
     multiline construct never depends on text in subsequent lines.
     Since 'jit-lock-contextually' is activated by default, this can be
     an attractive solution.
   * Place a 'jit-lock-defer-multiline' property on the construct.  This
     works only if 'jit-lock-contextually' is used, and with the same
     delay before rehighlighting, but like 'font-lock-multiline', it
     also handles the case where highlighting depends on subsequent
     lines.

MENU

* |Font_Lock_Multiline|::         Marking multiline chunks with a text property.
* |Region_to_Refontify|::         Controlling which region gets refontified
                                  after a buffer change.

==============================================================================
File: elisp.info,  Node: |Font_Lock_Multiline|,  Next: |Region_to_Refontify|,  Up: |Multiline_Font_Lock|
==============================================================================

                                                           *Font_Lock_Multiline*

23.6.9.1 Font Lock Multiline
----------------------------

One way to ensure reliable rehighlighting of multiline Font Lock
constructs is to put on them the text property 'font-lock-multiline'.
It should be present and non-'nil' for text that is part of a multiline
construct.

   When Font Lock is about to highlight a range of text, it first
extends the boundaries of the range as necessary so that they do not
fall within text marked with the 'font-lock-multiline' property.  Then
it removes any 'font-lock-multiline' properties from the range, and
highlights it.  The highlighting specification (mostly
'font-lock-keywords') must reinstall this property each time, whenever
it is appropriate.

   Warning: don't use the 'font-lock-multiline' property on large
ranges of text, because that will make rehighlighting slow.

 -- Variable: font-lock-multiline
     If the 'font-lock-multiline' variable is set to 't', Font Lock will
     try to add the 'font-lock-multiline' property automatically on
     multiline constructs.  This is not a universal solution, however,
     since it slows down Font Lock somewhat.  It can miss some multiline
     constructs, or make the property larger or smaller than necessary.

     For elements whose MATCHER is a function, the function should
     ensure that submatch 0 covers the whole relevant multiline
     construct, even if only a small subpart will be highlighted.  It is
     often just as easy to add the 'font-lock-multiline' property by
     hand.

   The 'font-lock-multiline' property is meant to ensure proper
refontification; it does not automatically identify new multiline
constructs.  Identifying them requires that Font Lock mode operate on
large enough chunks at a time.  This will happen by accident on many
cases, which may give the impression that multiline constructs magically
work.  If you set the 'font-lock-multiline' variable non-'nil', this
impression will be even stronger, since the highlighting of those
constructs which are found will be properly updated from then on.  But
that does not work reliably.

   To find multiline constructs reliably, you must either manually place
the 'font-lock-multiline' property on the text before Font Lock mode
looks at it, or use 'font-lock-fontify-region-function'.

==============================================================================
File: elisp.info,  Node: |Region_to_Refontify|,  Prev: |Font_Lock_Multiline|,  Up: |Multiline_Font_Lock|
==============================================================================

                                                           *Region_to_Refontify*

23.6.9.2 Region to Fontify after a Buffer Change
------------------------------------------------

When a buffer is changed, the region that Font Lock refontifies is by
default the smallest sequence of whole lines that spans the change.
While this works well most of the time, sometimes it doesn't--for
example, when a change alters the syntactic meaning of text on an
earlier line.

   You can enlarge (or even reduce) the region to refontify by setting
the following variable:

 -- Variable: font-lock-extend-after-change-region-function
     This buffer-local variable is either 'nil' or a function for Font
     Lock mode to call to determine the region to scan and fontify.

     The function is given three parameters, the standard BEG, END, and
     OLD-LEN from 'after-change-functions' (*note Change Hooks::).  It
     should return either a cons of the beginning and end buffer
     positions (in that order) of the region to fontify, or 'nil' (which
     means choose the region in the standard way).  This function needs
     to preserve point, the match-data, and the current restriction.
     The region it returns may start or end in the middle of a line.

     Since this function is called after every buffer change, it should
     be reasonably fast.

==============================================================================
File: elisp.info,  Node: |Auto_Indentation|,  Next: |Desktop_Save_Mode|,  Prev: |Font_Lock_Mode|,  Up: |Modes|
==============================================================================

                                                              *Auto_Indentation*

23.7 Automatic Indentation of code
----------------------------------

For programming languages, an important feature of a major mode is to
provide automatic indentation.  There are two parts: one is to decide
what is the right indentation of a line, and the other is to decide when
to reindent a line.  By default, Emacs reindents a line whenever you
type a character in 'electric-indent-chars', which by default only
includes Newline.  Major modes can add chars to 'electric-indent-chars'
according to the syntax of the language.

   Deciding what is the right indentation is controlled in Emacs by
'indent-line-function' (*note Mode-Specific Indent::).  For some modes,
the _right_ indentation cannot be known reliably, typically because
indentation is significant so several indentations are valid but with
different meanings.  In that case, the mode should set
'electric-indent-inhibit' to make sure the line is not constantly
re-indented against the user's wishes.

   Writing a good indentation function can be difficult and to a large
extent it is still a black art.  Many major mode authors will start by
writing a simple indentation function that works for simple cases, for
example by comparing with the indentation of the previous text line.
For most programming languages that are not really line-based, this
tends to scale very poorly: improving such a function to let it handle
more diverse situations tends to become more and more difficult,
resulting in the end with a large, complex, unmaintainable indentation
function which nobody dares to touch.

   A good indentation function will usually need to actually parse the
text, according to the syntax of the language.  Luckily, it is not
necessary to parse the text in as much detail as would be needed for a
compiler, but on the other hand, the parser embedded in the indentation
code will want to be somewhat friendly to syntactically incorrect code.

   Good maintainable indentation functions usually fall into two
categories: either parsing forward from some safe starting point until
the position of interest, or parsing backward from the position of
interest.  Neither of the two is a clearly better choice than the other:
parsing backward is often more difficult than parsing forward because
programming languages are designed to be parsed forward, but for the
purpose of indentation it has the advantage of not needing to guess a
safe starting point, and it generally enjoys the property that only a
minimum of text will be analyzed to decide the indentation of a line, so
indentation will tend to be less affected by syntax errors in some
earlier unrelated piece of code.  Parsing forward on the other hand is
usually easier and has the advantage of making it possible to reindent
efficiently a whole region at a time, with a single parse.

   Rather than write your own indentation function from scratch, it is
often preferable to try and reuse some existing ones or to rely on a
generic indentation engine.  There are sadly few such engines.  The
CC-mode indentation code (used with C, C++, Java, Awk and a few other
such modes) has been made more generic over the years, so if your
language seems somewhat similar to one of those languages, you might try
to use that engine.  Another one is SMIE which takes an approach in the
spirit of Lisp sexps and adapts it to non-Lisp languages.

MENU

* |SMIE|::                        A simple minded indentation engine.

==============================================================================
File: elisp.info,  Node: |SMIE|,  Up: Auto-Indentation
==============================================================================

                                                                          *SMIE*

23.7.1 Simple Minded Indentation Engine
---------------------------------------

SMIE is a package that provides a generic navigation and indentation
engine.  Based on a very simple parser using an operator precedence
grammar, it lets major modes extend the sexp-based navigation of Lisp to
non-Lisp languages as well as provide a simple to use but reliable
auto-indentation.

   Operator precedence grammar is a very primitive technology for
parsing compared to some of the more common techniques used in
compilers.  It has the following characteristics: its parsing power is
very limited, and it is largely unable to detect syntax errors, but it
has the advantage of being algorithmically efficient and able to parse
forward just as well as backward.  In practice that means that SMIE can
use it for indentation based on backward parsing, that it can provide
both 'forward-sexp' and 'backward-sexp' functionality, and that it will
naturally work on syntactically incorrect code without any extra effort.
The downside is that it also means that most programming languages
cannot be parsed correctly using SMIE, at least not without resorting to
some special tricks (*note SMIE Tricks::).

MENU

* |SMIE_setup|::                  SMIE setup and features.
* |Operator_Precedence_Grammars|::  A very simple parsing technique.
* |SMIE_Grammar|::                Defining the grammar of a language.
* |SMIE_Lexer|::                  Defining tokens.
* |SMIE_Tricks|::                 Working around the parser's limitations.
* |SMIE_Indentation|::            Specifying indentation rules.
* |SMIE_Indentation_Helpers|::    Helper functions for indentation rules.
* |SMIE_Indentation_Example|::    Sample indentation rules.
* |SMIE_Customization|::          Customizing indentation.

==============================================================================
File: elisp.info,  Node: |SMIE_setup|,  Next: |Operator_Precedence_Grammars|,  Up: SMIE
==============================================================================

                                                                    *SMIE_setup*

23.7.1.1 SMIE Setup and Features
--------------------------------

SMIE is meant to be a one-stop shop for structural navigation and
various other features which rely on the syntactic structure of code, in
particular automatic indentation.  The main entry point is 'smie-setup'
which is a function typically called while setting up a major mode.

 -- Function: smie-setup grammar rules-function &rest keywords
     Setup SMIE navigation and indentation.  GRAMMAR is a grammar table
     generated by 'smie-prec2->grammar'.  RULES-FUNCTION is a set of
     indentation rules for use on 'smie-rules-function'.  KEYWORDS are
     additional arguments, which can include the following keywords:
        * ':forward-token' FUN: Specify the forward lexer to use.
        * ':backward-token' FUN: Specify the backward lexer to use.

   Calling this function is sufficient to make commands such as
'forward-sexp', 'backward-sexp', and 'transpose-sexps' be able to
properly handle structural elements other than just the paired
parentheses already handled by syntax tables.  For example, if the
provided grammar is precise enough, 'transpose-sexps' can correctly
transpose the two arguments of a '+' operator, taking into account the
precedence rules of the language.

   Calling 'smie-setup' is also sufficient to make <TAB> indentation
work in the expected way, extends 'blink-matching-paren' to apply to
elements like 'begin...end', and provides some commands that you can
bind in the major mode keymap.

vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
