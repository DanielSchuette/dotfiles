==============================================================================
File: elisp.info,  Node: |Top|,  Next: |Introduction|,  Up: (dir)
==============================================================================

                                                                           *Top*

Emacs Lisp
==========

This is the 'GNU Emacs Lisp Reference Manual' corresponding to Emacs
version 27.1.

   Copyright (C) 1990-1996, 1998-2020 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "GNU General Public
     License," with the Front-Cover Texts being "A GNU Manual," and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

MENU

* |Introduction|::            Introduction and conventions used.

* |Lisp_Data_Types|::         Data types of objects in Emacs Lisp.
* |Numbers|::                 Numbers and arithmetic functions.
* |Strings_and_Characters|::  Strings, and functions that work on them.
* |Lists|::                   Lists, cons cells, and related functions.
* |Sequences_Arrays_Vectors|::  Lists, strings and vectors are called sequences.
                                Certain functions act on any kind of sequence.
                                The description of vectors is here as well.
* |Records|::                 Compound objects with programmer-defined types.
* |Hash_Tables|::             Very fast lookup-tables.
* |Symbols|::                 Symbols represent names, uniquely.

* |Evaluation|::              How Lisp expressions are evaluated.
* |Control_Structures|::      Conditionals, loops, nonlocal exits.
* |Variables|::               Using symbols in programs to stand for values.
* |Functions|::               A function is a Lisp program
                              that can be invoked from other functions.
* |Macros|::                  Macros are a way to extend the Lisp language.
* |Customization|::           Making variables and faces customizable.

* |Loading|::                 Reading files of Lisp code into Lisp.
* |Byte_Compilation|::        Compilation makes programs run faster.
* |Debugging|::               Tools and tips for debugging Lisp programs.

* |Read_and_Print|::          Converting Lisp objects to text and back.
* |Minibuffers|::             Using the minibuffer to read input.
* |Command_Loop|::            How the editor command loop works,
                              and how you can call its subroutines.
* |Keymaps|::                 Defining the bindings from keys to commands.
* |Modes|::                   Defining major and minor modes.
* |Documentation|::           Writing and using documentation strings.

* |Files|::                   Accessing files.
* |Backups_and_Auto_Saving|:: Controlling how backups and auto-save
                              files are made.
* |Buffers|::                 Creating and using buffer objects.
* |Windows|::                 Manipulating windows and displaying buffers.
* |Frames|::                  Making multiple system-level windows.
* |Positions|::               Buffer positions and motion functions.
* |Markers|::                 Markers represent positions and update
                              automatically when the text is changed.

* |Text|::                    Examining and changing text in buffers.
* |Non_ASCII_Characters|::    Non-ASCII text in buffers and strings.
* |Searching_and_Matching|::  Searching buffers for strings or regexps.
* |Syntax_Tables|::           The syntax table controls word and list parsing.
* |Abbrevs|::                 How Abbrev mode works, and its data structures.

* |Threads|::                 Concurrency in Emacs Lisp.
* |Processes|::               Running and communicating with subprocesses.
* |Display|::                 Features for controlling the screen display.
* |System_Interface|::        Getting the user id, system type, environment
                              variables, and other such things.

* |Packaging|::               Preparing Lisp code for distribution.

Appendices

* |Antinews|::                Info for users downgrading to Emacs 26.
* |GNU_Free_Documentation_License|:: The license for this documentation.
* |GPL|::                     Conditions for copying and changing GNU Emacs.
* |Tips|::                    Advice and coding conventions for Emacs Lisp.
* |GNU_Emacs_Internals|::     Building and dumping Emacs;
                              internal data structures.
* |Standard_Errors|::         List of some standard error symbols.
* |Standard_Keymaps|::        List of some standard keymaps.
* |Standard_Hooks|::          List of some standard hook variables.

* |Index|::                   Index including concepts, functions, variables,
                              and other terms.



 -- The Detailed Node Listing --
 ----------------------

Here are other nodes that are subnodes of those already listed,
mentioned here so you can get to them in one step:

Introduction

* |Caveats|::                 Flaws and a request for help.
* |Lisp_History|::            Emacs Lisp is descended from Maclisp.
* |Conventions|::             How the manual is formatted.
* |Version_Info|::            Which Emacs version is running?
* |Acknowledgments|::         The authors, editors, and sponsors of this manual.

Conventions

* |Some_Terms|::              Explanation of terms we use in this manual.
* |nil_and_t|::               How the symbols 'nil' and 't' are used.
* |Evaluation_Notation|::     The format we use for examples of evaluation.
* |Printing_Notation|::       The format we use when examples print text.
* |Error_Messages|::          The format we use for examples of errors.
* |Buffer_Text_Notation|::    The format we use for buffer contents in examples.
* |Format_of_Descriptions|::  Notation for describing functions, variables, etc.

Format of Descriptions

* |A_Sample_Function_Description|::  A description of an imaginary
                                     function, 'foo'.
* |A_Sample_Variable_Description|::  A description of an imaginary
                                     variable, 'electric-future-map'.

Lisp Data Types

* |Printed_Representation|::  How Lisp objects are represented as text.
* |Special_Read_Syntax|::     An overview of all the special sequences.
* |Comments|::                Comments and their formatting conventions.
* |Programming_Types|::       Types found in all Lisp systems.
* |Editing_Types|::           Types specific to Emacs.
* |Circular_Objects|::        Read syntax for circular structure.
* |Type_Predicates|::         Tests related to types.
* |Equality_Predicates|::     Tests of equality between any two objects.
* |Mutability|::              Some objects should not be modified.

Programming Types

* |Integer_Type|::        Numbers without fractional parts.
* |Floating_Point_Type|:: Numbers with fractional parts and with a large range.
* |Character_Type|::      The representation of letters, numbers and
                          control characters.
* |Symbol_Type|::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* |Sequence_Type|::       Both lists and arrays are classified as sequences.
* |Cons_Cell_Type|::      Cons cells, and lists (which are made from cons cells).
* |Array_Type|::          Arrays include strings and vectors.
* |String_Type|::         An (efficient) array of characters.
* |Vector_Type|::         One-dimensional arrays.
* |Char_Table_Type|::     One-dimensional sparse arrays indexed by characters.
* |Bool_Vector_Type|::    One-dimensional arrays of 't' or 'nil'.
* |Hash_Table_Type|::     Super-fast lookup tables.
* |Function_Type|::       A piece of executable code you can call from elsewhere.
* |Macro_Type|::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* |Primitive_Function_Type|::     A function written in C, callable from Lisp.
* |Byte_Code_Type|::      A function written in Lisp, then compiled.
* |Record_Type|::         Compound objects with programmer-defined types.
* |Type_Descriptors|::    Objects holding information about types.
* |Autoload_Type|::       A type used for automatically loading seldom-used
                          functions.
* |Finalizer_Type|::      Runs code when no longer reachable.

Character Type

* |Basic_Char_Syntax|::       Syntax for regular characters.
* |General_Escape_Syntax|::   How to specify characters by their codes.
* |Ctl_Char_Syntax|::         Syntax for control characters.
* |Meta_Char_Syntax|::        Syntax for meta-characters.
* |Other_Char_Bits|::         Syntax for hyper-, super-, and alt-characters.

Cons Cell and List Types

* |Box_Diagrams|::            Drawing pictures of lists.
* |Dotted_Pair_Notation|::    A general syntax for cons cells.
* |Association_List_Type|::   A specially constructed list.

String Type

* |Syntax_for_Strings|::      How to specify Lisp strings.
* |Non_ASCII_in_Strings|::    International characters in strings.
* |Nonprinting_Characters|::  Literal unprintable characters in strings.
* |Text_Props_and_Strings|::  Strings with text properties.

Editing Types

* |Buffer_Type|::             The basic object of editing.
* |Marker_Type|::             A position in a buffer.
* |Window_Type|::             Buffers are displayed in windows.
* |Frame_Type|::              Windows subdivide frames.
* |Terminal_Type|::           A terminal device displays frames.
* |Window_Configuration_Type|::  Recording the way a frame is subdivided.
* |Frame_Configuration_Type|::   Recording the status of all frames.
* |Process_Type|::            A subprocess of Emacs running on the underlying OS.
* |Thread_Type|::             A thread of Emacs Lisp execution.
* |Mutex_Type|::              An exclusive lock for thread synchronization.
* |Condition_Variable_Type|::    Condition variable for thread synchronization.
* |Stream_Type|::             Receive or send characters.
* |Keymap_Type|::             What function a keystroke invokes.
* |Overlay_Type|::            How an overlay is represented.
* |Font_Type|::               Fonts for displaying text.

Numbers

* |Integer_Basics|::          Representation and range of integers.
* |Float_Basics|::            Representation and range of floating point.
* |Predicates_on_Numbers|::   Testing for numbers.
* |Comparison_of_Numbers|::   Equality and inequality predicates.
* |Numeric_Conversions|::     Converting float to integer and vice versa.
* |Arithmetic_Operations|::   How to add, subtract, multiply and divide.
* |Rounding_Operations|::     Explicitly rounding floating-point numbers.
* |Bitwise_Operations|::      Logical and, or, not, shifting.
* |Math_Functions|::          Trig, exponential and logarithmic functions.
* |Random_Numbers|::          Obtaining random integers, predictable or not.

Strings and Characters

* |String_Basics|::           Basic properties of strings and characters.
* |Predicates_for_Strings|::  Testing whether an object is a string or char.
* |Creating_Strings|::        Functions to allocate new strings.
* |Modifying_Strings|::       Altering the contents of an existing string.
* |Text_Comparison|::         Comparing characters or strings.
* |String_Conversion|::       Converting to and from characters and strings.
* |Formatting_Strings|::      'format': Emacs's analogue of 'printf'.
* |Case_Conversion|::         Case conversion functions.
* |Case_Tables|::             Customizing case conversion.

Lists

* |Cons_Cells|::              How lists are made out of cons cells.
* |List_related_Predicates|:: Is this object a list?  Comparing two lists.
* |List_Elements|::           Extracting the pieces of a list.
* |Building_Lists|::          Creating list structure.
* |List_Variables|::          Modifying lists stored in variables.
* |Modifying_Lists|::         Storing new pieces into an existing list.
* |Sets_And_Lists|::          A list can represent a finite mathematical set.
* |Association_Lists|::       A list can represent a finite relation or mapping.
* |Property_Lists|::          A list of paired elements.

Modifying Existing List Structure

* |Setcar|::                  Replacing an element in a list.
* |Setcdr|::                  Replacing part of the list backbone.
                              This can be used to remove or add elements.
* |Rearrangement|::           Reordering the elements in a list; combining lists.

Property Lists

* |Plists_and_Alists|::       Comparison of the advantages of property
                              lists and association lists.
* |Plist_Access|::            Accessing property lists stored elsewhere.

Sequences, Arrays, and Vectors

* |Sequence_Functions|::      Functions that accept any kind of sequence.
* |Arrays|::                  Characteristics of arrays in Emacs Lisp.
* |Array_Functions|::         Functions specifically for arrays.
* |Vectors|::                 Special characteristics of Emacs Lisp vectors.
* |Vector_Functions|::        Functions specifically for vectors.
* |Char_Tables|::             How to work with char-tables.
* |Bool_Vectors|::            How to work with bool-vectors.
* |Rings|::                   Managing a fixed-size ring of objects.

Records

* |Record_Functions|::        Functions for records.
* |Backward_Compatibility|::  Compatibility for cl-defstruct.

Hash Tables

* |Creating_Hash|::           Functions to create hash tables.
* |Hash_Access|::             Reading and writing the hash table contents.
* |Defining_Hash|::           Defining new comparison methods.
* |Other_Hash|::              Miscellaneous.

Symbols

* |Symbol_Components|::       Symbols have names, values, function definitions
                              and property lists.
* |Definitions|::             A definition says how a symbol will be used.
* |Creating_Symbols|::        How symbols are kept unique.
* |Symbol_Properties|::       Each symbol has a property list
                              for recording miscellaneous information.

Symbol Properties

* |Symbol_Plists|::           Accessing symbol properties.
* |Standard_Properties|::     Standard meanings of symbol properties.

Evaluation

* |Intro_Eval|::              Evaluation in the scheme of things.
* |Forms|::                   How various sorts of objects are evaluated.
* |Quoting|::                 Avoiding evaluation (to put constants in
                              the program).
* |Backquote|::               Easier construction of list structure.
* |Eval|::                    How to invoke the Lisp interpreter explicitly.
* |Deferred_Eval|::           Deferred and lazy evaluation of forms.

Kinds of Forms

* |Self_Evaluating_Forms|::   Forms that evaluate to themselves.
* |Symbol_Forms|::            Symbols evaluate as variables.
* |Classifying_Lists|::       How to distinguish various sorts of list forms.
* |Function_Indirection|::    When a symbol appears as the car of a list,
                              we find the real function via the symbol.
* |Function_Forms|::          Forms that call functions.
* |Macro_Forms|::             Forms that call macros.
* |Special_Forms|::           Special forms are idiosyncratic primitives,
                              most of them extremely important.
* |Autoloading|::             Functions set up to load files
                              containing their real definitions.

Control Structures

* |Sequencing|::              Evaluation in textual order.
* |Conditionals|::            'if', 'cond', 'when', 'unless'.
* |Combining_Conditions|::    'and', 'or', 'not'.
* |Pattern_Matching_Conditional|::  How to use 'pcase' and friends.
* |Iteration|::               'while' loops.
* |Generators|::              Generic sequences and coroutines.
* |Nonlocal_Exits|::          Jumping out of a sequence.

Nonlocal Exits

* |Catch_and_Throw|::         Nonlocal exits for the program's own purposes.
* |Examples_of_Catch|::       Showing how such nonlocal exits can be written.
* |Errors|::                  How errors are signaled and handled.
* |Cleanups|::                Arranging to run a cleanup form if an
                              error happens.

Errors

* |Signaling_Errors|::        How to report an error.
* |Processing_of_Errors|::    What Emacs does when you report an error.
* |Handling_Errors|::         How you can trap errors and continue execution.
* |Error_Symbols|::           How errors are classified for trapping them.

Variables

* |Global_Variables|::        Variable values that exist permanently, everywhere.
* |Constant_Variables|::      Variables that never change.
* |Local_Variables|::         Variable values that exist only temporarily.
* |Void_Variables|::          Symbols that lack values.
* |Defining_Variables|::      A definition says a symbol is used as a variable.
* |Tips_for_Defining|::       Things you should think about when you
                              define a variable.
* |Accessing_Variables|::     Examining values of variables whose names
                              are known only at run time.
* |Setting_Variables|::       Storing new values in variables.
* |Watching_Variables|::      Running a function when a variable is changed.
* |Variable_Scoping|::        How Lisp chooses among local and global values.
* |Buffer_Local_Variables|::  Variable values in effect only in one buffer.
* |File_Local_Variables|::    Handling local variable lists in files.
* |Directory_Local_Variables|:: Local variables common to all files in a
                                directory.
* |Connection_Local_Variables|::  Local variables common for remote connections.
* |Variable_Aliases|::        Variables that are aliases for other variables.
* |Variables_with_Restricted_Values|::  Non-constant variables whose value can
                                        _not_ be an arbitrary Lisp object.
* |Generalized_Variables|::   Extending the concept of variables.

Scoping Rules for Variable Bindings

* |Dynamic_Binding|::         The default for binding local variables in Emacs.
* |Dynamic_Binding_Tips|::    Avoiding problems with dynamic binding.
* |Lexical_Binding|::         A different type of local variable binding.
* |Using_Lexical_Binding|::   How to enable lexical binding.

Buffer-Local Variables

* |Intro_to_Buffer_Local|::   Introduction and concepts.
* |Creating_Buffer_Local|::   Creating and destroying buffer-local bindings.
* |Default_Value|::           The default value is seen in buffers
                              that don't have their own buffer-local values.

Generalized Variables

* |Setting_Generalized_Variables|::   The 'setf' macro.
* |Adding_Generalized_Variables|::    Defining new 'setf' forms.

Functions

* |What_Is_a_Function|::      Lisp functions vs. primitives; terminology.
* |Lambda_Expressions|::      How functions are expressed as Lisp objects.
* |Function_Names|::          A symbol can serve as the name of a function.
* |Defining_Functions|::      Lisp expressions for defining functions.
* |Calling_Functions|::       How to use an existing function.
* |Mapping_Functions|::       Applying a function to each element of a list, etc.
* |Anonymous_Functions|::     Lambda expressions are functions with no names.
* |Generic_Functions|::       Polymorphism, Emacs-style.
* |Function_Cells|::          Accessing or setting the function definition
                              of a symbol.
* |Closures|::                Functions that enclose a lexical environment.
* |Advising_Functions|::      Adding to the definition of a function.
* |Obsolete_Functions|::      Declaring functions obsolete.
* |Inline_Functions|::        Defining functions that the compiler
                              will expand inline.
* |Declare_Form|::          Adding additional information about a function.
* |Declaring_Functions|::     Telling the compiler that a function is defined.
* |Function_Safety|::         Determining whether a function is safe to call.
* |Related_Topics|::          Cross-references to specific Lisp primitives
                              that have a special bearing on how
                              functions work.

Lambda Expressions

* |Lambda_Components|::       The parts of a lambda expression.
* |Simple_Lambda|::           A simple example.
* |Argument_List|::           Details and special features of argument lists.
* |Function_Documentation|::  How to put documentation in a function.

Advising Emacs Lisp Functions

* |Core_Advising_Primitives|::  Primitives to manipulate advice.
* |Advising_Named_Functions|::  Advising named functions.
* |Advice_Combinators|::        Ways to compose advice.
* |Porting_Old_Advice|::        Adapting code using the old defadvice.

Macros

* |Simple_Macro|::            A basic example.
* |Expansion|::               How, when and why macros are expanded.
* |Compiling_Macros|::        How macros are expanded by the compiler.
* |Defining_Macros|::         How to write a macro definition.
* |Problems_with_Macros|::    Don't evaluate the macro arguments too many times.
                              Don't hide the user's variables.
* |Indenting_Macros|::        Specifying how to indent macro calls.

Common Problems Using Macros

* |Wrong_Time|::             Do the work in the expansion, not in the macro.
* |Argument_Evaluation|::    The expansion should evaluate each macro arg once.
* |Surprising_Local_Vars|::  Local variable bindings in the expansion
                              require special care.
* |Eval_During_Expansion|::  Don't evaluate them; put them in the expansion.
* |Repeated_Expansion|::     Avoid depending on how many times expansion is done.

Customization Settings

* |Common_Keywords|::         Common keyword arguments for all kinds of
                              customization declarations.
* |Group_Definitions|::       Writing customization group definitions.
* |Variable_Definitions|::    Declaring user options.
* |Customization_Types|::     Specifying the type of a user option.
* |Applying_Customizations|:: Functions to apply customization settings.
* |Custom_Themes|::           Writing Custom themes.

Customization Types

* |Simple_Types|::            Simple customization types: sexp, integer, etc.
* |Composite_Types|::         Build new types from other types or data.
* |Splicing_into_Lists|::     Splice elements into list with ':inline'.
* |Type_Keywords|::           Keyword-argument pairs in a customization type.
* |Defining_New_Types|::      Give your type a name.

Loading

* |How_Programs_Do_Loading|:: The 'load' function and others.
* |Load_Suffixes|::           Details about the suffixes that 'load' tries.
* |Library_Search|::          Finding a library to load.
* |Loading_Non_ASCII|::       Non-ASCII characters in Emacs Lisp files.
* |Autoload|::                Setting up a function to autoload.
* |Repeated_Loading|::        Precautions about loading a file twice.
* |Named_Features|::          Loading a library if it isn't already loaded.
* |Where_Defined|::           Finding which file defined a certain symbol.
* |Unloading|::               How to unload a library that was loaded.
* |Hooks_for_Loading|::       Providing code to be run when
                              particular libraries are loaded.
* |Dynamic_Modules|::         Modules provide additional Lisp primitives.

Byte Compilation

* |Speed_of_Byte_Code|::      An example of speedup from byte compilation.
* |Compilation_Functions|::   Byte compilation functions.
* |Docs_and_Compilation|::    Dynamic loading of documentation strings.
* |Dynamic_Loading|::         Dynamic loading of individual functions.
* |Eval_During_Compile|::     Code to be evaluated when you compile.
* |Compiler_Errors|::         Handling compiler error messages.
* |Byte_Code_Objects|::       The data type used for byte-compiled functions.
* |Disassembly|::             Disassembling byte-code; how to read byte-code.

Debugging Lisp Programs

* |Debugger|::                A debugger for the Emacs Lisp evaluator.
* |Edebug|::                  A source-level Emacs Lisp debugger.
* |Syntax_Errors|::           How to find syntax errors.
* |Test_Coverage|::           Ensuring you have tested all branches in your code.
* |Profiling|::               Measuring the resources that your code uses.

The Lisp Debugger

* |Error_Debugging|::         Entering the debugger when an error happens.
* |Infinite_Loops|::          Stopping and debugging a program that doesn't exit.
* |Function_Debugging|::      Entering it when a certain function is called.
* |Variable_Debugging|::      Entering it when a variable is modified.
* |Explicit_Debug|::          Entering it at a certain point in the program.
* |Using_Debugger|::          What the debugger does.
* |Backtraces|::              What you see while in the debugger.
* |Debugger_Commands|::       Commands used while in the debugger.
* |Invoking_the_Debugger|::   How to call the function 'debug'.
* |Internals_of_Debugger|::   Subroutines of the debugger, and global variables.

Edebug

* |Using_Edebug|::            Introduction to use of Edebug.
* |Instrumenting|::           You must instrument your code
                              in order to debug it with Edebug.
* |Edebug_Execution_Modes|::  Execution modes, stopping more or less often.
* |Jumping|::                 Commands to jump to a specified place.
* |Edebug_Misc|::             Miscellaneous commands.
* |Breaks|::                  Setting breakpoints to make the program stop.
* |Trapping_Errors|::         Trapping errors with Edebug.
* |Edebug_Views|::            Views inside and outside of Edebug.
* |Edebug_Eval|::             Evaluating expressions within Edebug.
* |Eval_List|::               Expressions whose values are displayed
                              each time you enter Edebug.
* |Printing_in_Edebug|::      Customization of printing.
* |Trace_Buffer|::            How to produce trace output in a buffer.
* |Coverage_Testing|::        How to test evaluation coverage.
* |The_Outside_Context|::     Data that Edebug saves and restores.
* |Edebug_and_Macros|::       Specifying how to handle macro calls.
* |Edebug_Options|::          Option variables for customizing Edebug.

Breaks

* |Breakpoints|::             Breakpoints at stop points.
* |Global_Break_Condition|::  Breaking on an event.
* |Source_Breakpoints|::      Embedding breakpoints in source code.

The Outside Context

* |Checking_Whether_to_Stop|::When Edebug decides what to do.
* |Edebug_Display_Update|::   When Edebug updates the display.
* |Edebug_Recursive_Edit|::   When Edebug stops execution.

Edebug and Macros

* |Instrumenting_Macro_Calls|::The basic problem.
* |Specification_List|::      How to specify complex patterns of evaluation.
* |Backtracking|::            What Edebug does when matching fails.
* |Specification_Examples|::  To help understand specifications.

Debugging Invalid Lisp Syntax

* |Excess_Open|::             How to find a spurious open paren or missing close.
* |Excess_Close|::            How to find a spurious close paren or missing open.

Reading and Printing Lisp Objects

* |Streams_Intro|::           Overview of streams, reading and printing.
* |Input_Streams|::           Various data types that can be used as
                              input streams.
* |Input_Functions|::         Functions to read Lisp objects from text.
* |Output_Streams|::          Various data types that can be used as
                              output streams.
* |Output_Functions|::        Functions to print Lisp objects as text.
* |Output_Variables|::        Variables that control what the printing
                              functions do.

Minibuffers

* |Intro_to_Minibuffers|::    Basic information about minibuffers.
* |Text_from_Minibuffer|::    How to read a straight text string.
* |Object_from_Minibuffer|::  How to read a Lisp object or expression.
* |Minibuffer_History|::      Recording previous minibuffer inputs
                              so the user can reuse them.
* |Initial_Input|::           Specifying initial contents for the minibuffer.
* |Completion|::              How to invoke and customize completion.
* |Yes_or_No_Queries|::       Asking a question with a simple answer.
* |Multiple_Queries|::        Asking a series of similar questions.
* |Reading_a_Password|::      Reading a password from the terminal.
* |Minibuffer_Commands|::     Commands used as key bindings in minibuffers.
* |Minibuffer_Windows|::      Operating on the special minibuffer windows.
* |Minibuffer_Contents|::     How such commands access the minibuffer text.
* |Recursive_Mini|::          Whether recursive entry to minibuffer is allowed.
* |Minibuffer_Misc|::         Various customization hooks and variables.

Completion

* |Basic_Completion|::        Low-level functions for completing strings.
* |Minibuffer_Completion|::   Invoking the minibuffer with completion.
* |Completion_Commands|::     Minibuffer commands that do completion.
* |High_Level_Completion|::   Convenient special cases of completion
                              (reading buffer names, variable names, etc.).
* |Reading_File_Names|::      Using completion to read file names and
                              shell commands.
* |Completion_Variables|::    Variables controlling completion behavior.
* |Programmed_Completion|::   Writing your own completion function.
* |Completion_in_Buffers|::   Completing text in ordinary buffers.

Command Loop

* |Command_Overview|::    How the command loop reads commands.
* |Defining_Commands|::   Specifying how a function should read arguments.
* |Interactive_Call|::    Calling a command, so that it will read arguments.
* |Distinguish_Interactive|::     Making a command distinguish interactive calls.
* |Command_Loop_Info|::   Variables set by the command loop for you to examine.
* |Adjusting_Point|::     Adjustment of point after a command.
* |Input_Events|::        What input looks like when you read it.
* |Reading_Input|::       How to read input events from the keyboard or mouse.
* |Special_Events|::      Events processed immediately and individually.
* |Waiting|::             Waiting for user input or elapsed time.
* |Quitting|::            How 'C-g' works.  How to catch or defer quitting.
* |Prefix_Command_Arguments|::    How the commands to set prefix args work.
* |Recursive_Editing|::   Entering a recursive edit,
                          and why you usually shouldn't.
* |Disabling_Commands|::  How the command loop handles disabled commands.
* |Command_History|::     How the command history is set up, and how accessed.
* |Keyboard_Macros|::     How keyboard macros are implemented.

Defining Commands

* |Using_Interactive|::       General rules for 'interactive'.
* |Interactive_Codes|::       The standard letter-codes for reading arguments
                              in various ways.
* |Interactive_Examples|::    Examples of how to read interactive arguments.
* |Generic_Commands|::        Select among command alternatives.


Input Events

* |Keyboard_Events|::         Ordinary characters - keys with symbols on them.
* |Function_Keys|::           Function keys - keys with names, not symbols.
* |Mouse_Events|::            Overview of mouse events.
* |Click_Events|::            Pushing and releasing a mouse button.
* |Drag_Events|::             Moving the mouse before releasing the button.
* |Button_Down_Events|::      A button was pushed and not yet released.
* |Repeat_Events|::           Double and triple click (or drag, or down).
* |Motion_Events|::           Just moving the mouse, not pushing a button.
* |Focus_Events|::            Moving the mouse between frames.
* |Misc_Events|::             Other events the system can generate.
* |Event_Examples|::          Examples of the lists for mouse events.
* |Classifying_Events|::      Finding the modifier keys in an event symbol.
                              Event types.
* |Accessing_Mouse|::         Functions to extract info from mouse events.
* |Accessing_Scroll|::        Functions to get info from scroll bar events.
* |Strings_of_Events|::       Special considerations for putting
                              keyboard character events in a string.

Reading Input

* |Key_Sequence_Input|::      How to read one key sequence.
* |Reading_One_Event|::       How to read just one event.
* |Event_Mod|::               How Emacs modifies events as they are read.
* |Invoking_the_Input_Method|::   How reading an event uses the input method.
* |Quoted_Character_Input|::  Asking the user to specify a character.
* |Event_Input_Misc|::        How to reread or throw away input events.

Keymaps

* |Key_Sequences|::           Key sequences as Lisp objects.
* |Keymap_Basics|::           Basic concepts of keymaps.
* |Format_of_Keymaps|::       What a keymap looks like as a Lisp object.
* |Creating_Keymaps|::        Functions to create and copy keymaps.
* |Inheritance_and_Keymaps|:: How one keymap can inherit the bindings
                              of another keymap.
* |Prefix_Keys|::             Defining a key with a keymap as its definition.
* |Active_Keymaps|::          How Emacs searches the active keymaps
                              for a key binding.
* |Searching_Keymaps|::       A pseudo-Lisp summary of searching active maps.
* |Controlling_Active_Maps|:: Each buffer has a local keymap
                               to override the standard (global) bindings.
                               A minor mode can also override them.
* |Key_Lookup|::              Finding a key's binding in one keymap.
* |Functions_for_Key_Lookup|::    How to request key lookup.
* |Changing_Key_Bindings|::   Redefining a key in a keymap.
* |Remapping_Commands|::      A keymap can translate one command to another.
* |Translation_Keymaps|::     Keymaps for translating sequences of events.
* |Key_Binding_Commands|::    Interactive interfaces for redefining keys.
* |Scanning_Keymaps|::        Looking through all keymaps, for printing help.
* |Menu_Keymaps|::            Defining a menu as a keymap.

Menu Keymaps

* |Defining_Menus|::          How to make a keymap that defines a menu.
* |Mouse_Menus|::             How users actuate the menu with the mouse.
* |Keyboard_Menus|::          How users actuate the menu with the keyboard.
* |Menu_Example|::            Making a simple menu.
* |Menu_Bar|::                How to customize the menu bar.
* |Tool_Bar|::                A tool bar is a row of images.
* |Modifying_Menus|::         How to add new items to a menu.
* |Easy_Menu|::               A convenience macro for defining menus.

Defining Menus

* |Simple_Menu_Items|::       A simple kind of menu key binding.
* |Extended_Menu_Items|::     More complex menu item definitions.
* |Menu_Separators|::         Drawing a horizontal line through a menu.
* |Alias_Menu_Items|::        Using command aliases in menu items.

Major and Minor Modes

* |Hooks|::              How to use hooks; how to write code that provides hooks.
* |Major_Modes|::        Defining major modes.
* |Minor_Modes|::        Defining minor modes.
* |Mode_Line_Format|::   Customizing the text that appears in the mode line.
* |Imenu|::              Providing a menu of definitions made in a buffer.
* |Font_Lock_Mode|::     How modes can highlight text according to syntax.
* |Auto_Indentation|::   How to teach Emacs to indent for a major mode.
* |Desktop_Save_Mode|::  How modes can have buffer state saved between
                         Emacs sessions.

Hooks

* |Running_Hooks|::      How to run a hook.
* |Setting_Hooks|::      How to put functions on a hook, or remove them.

Major Modes

* |Major_Mode_Conventions|::  Coding conventions for keymaps, etc.
* |Auto_Major_Mode|::         How Emacs chooses the major mode automatically.
* |Mode_Help|::               Finding out how to use a mode.
* |Derived_Modes|::           Defining a new major mode based on another major
                              mode.
* |Basic_Major_Modes|::       Modes that other modes are often derived from.
* |Mode_Hooks|::              Hooks run at the end of major mode functions.
* |Tabulated_List_Mode|::     Parent mode for buffers containing tabulated data.
* |Generic_Modes|::           Defining a simple major mode that supports
                              comment syntax and Font Lock mode.
* |Example_Major_Modes|::     Text mode and Lisp modes.

Minor Modes

* |Minor_Mode_Conventions|::  Tips for writing a minor mode.
* |Keymaps_and_Minor_Modes|:: How a minor mode can have its own keymap.
* |Defining_Minor_Modes|::    A convenient facility for defining minor modes.

Mode Line Format

* |Mode_Line_Basics|::        Basic ideas of mode line control.
* |Mode_Line_Data|::          The data structure that controls the mode line.
* |Mode_Line_Top|::           The top level variable, mode-line-format.
* |Mode_Line_Variables|::     Variables used in that data structure.
* |%_Constructs|::            Putting information into a mode line.
* |Properties_in_Mode|::      Using text properties in the mode line.
* |Header_Lines|::            Like a mode line, but at the top.
* |Emulating_Mode_Line|::     Formatting text as the mode line would.

Font Lock Mode

* |Font_Lock_Basics|::        Overview of customizing Font Lock.
* |Search_based_Fontification|::  Fontification based on regexps.
* |Customizing_Keywords|::    Customizing search-based fontification.
* |Other_Font_Lock_Variables|::   Additional customization facilities.
* |Levels_of_Font_Lock|::     Each mode can define alternative levels
                              so that the user can select more or less.
* |Precalculated_Fontification|:: How Lisp programs that produce the buffer
                                  contents can also specify how to fontify it.
* |Faces_for_Font_Lock|::     Special faces specifically for Font Lock.
* |Syntactic_Font_Lock|::     Fontification based on syntax tables.
* |Multiline_Font_Lock|::     How to coerce Font Lock into properly
                              highlighting multiline constructs.

Multiline Font Lock Constructs

* |Font_Lock_Multiline|::     Marking multiline chunks with a text property.
* |Region_to_Refontify|::     Controlling which region gets refontified
                              after a buffer change.

Automatic Indentation of code

* |SMIE|::                    A simple minded indentation engine.

Simple Minded Indentation Engine

* |SMIE_setup|::              SMIE setup and features.
* |Operator_Precedence_Grammars|:: A very simple parsing technique.
* |SMIE_Grammar|::            Defining the grammar of a language.
* |SMIE_Lexer|::              Defining tokens.
* |SMIE_Tricks|::             Working around the parser's limitations.
* |SMIE_Indentation|::        Specifying indentation rules.
* |SMIE_Indentation_Helpers|:: Helper functions for indentation rules.
* |SMIE_Indentation_Example|:: Sample indentation rules.
* |SMIE_Customization|::      Customizing indentation.

Documentation

* |Documentation_Basics|::    Where doc strings are defined and stored.
* |Accessing_Documentation|:: How Lisp programs can access doc strings.
* |Keys_in_Documentation|::   Substituting current key bindings.
* |Text_Quoting_Style|::      Quotation marks in doc strings and messages.
* |Describing_Characters|::   Making printable descriptions of
                              non-printing characters and key sequences.
* |Help_Functions|::          Subroutines used by Emacs help facilities.

Files

* |Visiting_Files|::          Reading files into Emacs buffers for editing.
* |Saving_Buffers|::          Writing changed buffers back into files.
* |Reading_from_Files|::      Reading files into buffers without visiting.
* |Writing_to_Files|::        Writing new files from parts of buffers.
* |File_Locks|::              Locking and unlocking files, to prevent
                              simultaneous editing by two people.
* |Information_about_Files|:: Testing existence, accessibility, size of files.
* |Changing_Files|::          Renaming files, changing permissions, etc.
* |File_Names|::              Decomposing and expanding file names.
* |Contents_of_Directories|:: Getting a list of the files in a directory.
* |Create/Delete_Dirs|::      Creating and Deleting Directories.
* |Magic_File_Names|::        Special handling for certain file names.
* |Format_Conversion|::       Conversion to and from various file formats.

Visiting Files

* |Visiting_Functions|::      The usual interface functions for visiting.
* |Subroutines_of_Visiting|:: Lower-level subroutines that they use.

Information about Files

* |Testing_Accessibility|::   Is a given file readable?  Writable?
* |Kinds_of_Files|::          Is it a directory?  A symbolic link?
* |Truenames|::               Eliminating symbolic links from a file name.
* |File_Attributes|::         File sizes, modification times, etc.
* |Extended_Attributes|::     Extended file attributes for access control.
* |Locating_Files|::          How to find a file in standard places.

File Names

* |File_Name_Components|::    The directory part of a file name, and the rest.
* |Relative_File_Names|::     Some file names are relative to a current directory.
* |Directory_Names|::         A directory's name as a directory
                              is different from its name as a file.
* |File_Name_Expansion|::     Converting relative file names to absolute ones.
* |Unique_File_Names|::       Generating names for temporary files.
* |File_Name_Completion|::    Finding the completions for a given file name.
* |Standard_File_Names|::     If your package uses a fixed file name,
                              how to handle various operating systems simply.

File Format Conversion

* |Format_Conversion_Overview|::   'insert-file-contents' and 'write-region'.
* |Format_Conversion_Round_Trip|:: Using 'format-alist'.
* |Format_Conversion_Piecemeal|::  Specifying non-paired conversion.

Backups and Auto-Saving

* |Backup_Files|::            How backup files are made; how their names
                              are chosen.
* |Auto_Saving|::             How auto-save files are made; how their
                              names are chosen.
* |Reverting|::               'revert-buffer', and how to customize
                              what it does.

Backup Files

* |Making_Backups|::          How Emacs makes backup files, and when.
* |Rename_or_Copy|::          Two alternatives: renaming the old file
                              or copying it.
* |Numbered_Backups|::        Keeping multiple backups for each source file.
* |Backup_Names|::            How backup file names are computed; customization.

Buffers

* |Buffer_Basics|::           What is a buffer?
* |Current_Buffer|::          Designating a buffer as current
                              so that primitives will access its contents.
* |Buffer_Names|::            Accessing and changing buffer names.
* |Buffer_File_Name|::        The buffer file name indicates which file
                              is visited.
* |Buffer_Modification|::     A buffer is "modified" if it needs to be saved.
* |Modification_Time|::       Determining whether the visited file was changed
                              behind Emacs's back.
* |Read_Only_Buffers|::       Modifying text is not allowed in a
                              read-only buffer.
* |Buffer_List|::             How to look at all the existing buffers.
* |Creating_Buffers|::        Functions that create buffers.
* |Killing_Buffers|::         Buffers exist until explicitly killed.
* |Indirect_Buffers|::        An indirect buffer shares text with some
                              other buffer.
* |Swapping_Text|::           Swapping text between two buffers.
* |Buffer_Gap|::              The gap in the buffer.

Windows

* |Basic_Windows|::           Basic information on using windows.
* |Windows_and_Frames|::      Relating windows to the frame they appear on.
* |Window_Sizes|::            Accessing a window's size.
* |Resizing_Windows|::        Changing the sizes of windows.
* |Preserving_Window_Sizes|:: Preserving the size of windows.
* |Splitting_Windows|::       Splitting one window into two windows.
* |Deleting_Windows|::        Deleting a window gives its space to other windows.
* |Recombining_Windows|::     Preserving the frame layout when splitting and
                              deleting windows.
* |Selecting_Windows|::       The selected window is the one that you edit in.
* |Cyclic_Window_Ordering|::  Moving around the existing windows.
* |Buffers_and_Windows|::     Each window displays the contents of a buffer.
* |Switching_Buffers|::       Higher-level functions for switching to a buffer.
* |Displaying_Buffers|::      Displaying a buffer in a suitable window.
* |Window_History|::          Each window remembers the buffers displayed in it.
* |Dedicated_Windows|::       How to avoid displaying another buffer in
                              a specific window.
* |Quitting_Windows|::        How to restore the state prior to displaying a
                              buffer.
* |Side_Windows|::            Special windows on a frame's sides.
* |Atomic_Windows|::          Preserving parts of the window layout.
* |Window_Point|::            Each window has its own location of point.
* |Window_Start_and_End|::    Buffer positions indicating which text is
                              on-screen in a window.
* |Textual_Scrolling|::       Moving text up and down through the window.
* |Vertical_Scrolling|::      Moving the contents up and down on the window.
* |Horizontal_Scrolling|::    Moving the contents sideways on the window.
* |Coordinates_and_Windows|:: Converting coordinates to windows.
* |Mouse_Window_Auto_selection|:: Automatically selecting windows with the mouse.
* |Window_Configurations|::   Saving and restoring the state of the screen.
* |Window_Parameters|::       Associating additional information with windows.
* |Window_Hooks|::            Hooks for scrolling, window size changes,
                              redisplay going past a certain point,
                              or window configuration changes.

Displaying Buffers

* |Choosing_Window|::         How to choose a window for displaying a buffer.
* |Buffer_Display_Action_Functions|:: Support functions for buffer display.
* |Buffer_Display_Action_Alists|:: Alists for fine-tuning buffer display
                              action functions.
* |Choosing_Window_Options|:: Extra options affecting how buffers are displayed.
* |Precedence_of_Action_Functions|:: A tutorial explaining the precedence of
                              buffer display action functions.
* |The_Zen_of_Buffer_Display|:: How to avoid that buffers get lost in between
                              windows.

Side Windows

* |Displaying_Buffers_in_Side_Windows|:: An action function for displaying
                              buffers in side windows.
* |Side_Window_Options_and_Functions|:: Further tuning of side windows.
* |Frame_Layouts_with_Side_Windows|:: Setting up frame layouts with side
                              windows.

Frames

* |Creating_Frames|::         Creating additional frames.
* |Multiple_Terminals|::      Displaying on several different devices.
* |Frame_Geometry|::          Geometric properties of frames.
* |Frame_Parameters|::        Controlling frame size, position, font, etc.
* |Terminal_Parameters|::     Parameters common for all frames on terminal.
* |Frame_Titles|::            Automatic updating of frame titles.
* |Deleting_Frames|::         Frames last until explicitly deleted.
* |Finding_All_Frames|::      How to examine all existing frames.
* |Minibuffers_and_Frames|::  How a frame finds the minibuffer to use.
* |Input_Focus|::             Specifying the selected frame.
* |Visibility_of_Frames|::    Frames may be visible or invisible, or icons.
* |Raising_and_Lowering|::    Raising, Lowering and Restacking Frames.
* |Frame_Configurations|::    Saving the state of all frames.
* |Child_Frames|::            Making a frame the child of another.
* |Mouse_Tracking|::          Getting events that say when the mouse moves.
* |Mouse_Position|::          Asking where the mouse is, or moving it.
* |Pop_Up_Menus|::            Displaying a menu for the user to select from.
* |Dialog_Boxes|::            Displaying a box to ask yes or no.
* |Pointer_Shape|::           Specifying the shape of the mouse pointer.
* |Window_System_Selections|::Transferring text to and from other X clients.
* |Drag_and_Drop|::           Internals of Drag-and-Drop implementation.
* |Color_Names|::             Getting the definitions of color names.
* |Text_Terminal_Colors|::    Defining colors for text terminals.
* |Resources|::               Getting resource values from the server.
* |Display_Feature_Testing|:: Determining the features of a terminal.

Frame Geometry

* |Frame_Layout|::            Basic layout of frames.
* |Frame_Font|::              The default font of a frame and how to set it.
* |Frame_Position|::          The position of a frame on its display.
* |Frame_Size|::              Specifying and retrieving a frame's size.
* |Implied_Frame_Resizing|::  Implied resizing of frames and how to prevent it.

Frame Parameters

* |Parameter_Access|::        How to change a frame's parameters.
* |Initial_Parameters|::      Specifying frame parameters when you make a frame.
* |Window_Frame_Parameters|:: List of frame parameters for window systems.
* |Geometry|::                Parsing geometry specifications.

Window Frame Parameters

* |Basic_Parameters|::        Parameters that are fundamental.
* |Position_Parameters|::     The position of the frame on the screen.
* |Size_Parameters|::         Frame's size.
* |Layout_Parameters|::       Size of parts of the frame, and
                              enabling or disabling some parts.
* |Buffer_Parameters|::       Which buffers have been or should be shown.
* |Frame_Interaction_Parameters|::  Parameters for interacting with other
                              frames.
* |Mouse_Dragging_Parameters|::  Parameters for resizing and moving
                              frames with the mouse.
* |Management_Parameters|::   Communicating with the window manager.
* |Cursor_Parameters|::       Controlling the cursor appearance.
* |Font_and_Color_Parameters|:: Fonts and colors for the frame text.

Positions

* |Point|::                   The special position where editing takes place.
* |Motion|::                  Changing point.
* |Excursions|::              Temporary motion and buffer changes.
* |Narrowing|::               Restricting editing to a portion of the buffer.

Motion

* |Character_Motion|::        Moving in terms of characters.
* |Word_Motion|::             Moving in terms of words.
* |Buffer_End_Motion|::       Moving to the beginning or end of the buffer.
* |Text_Lines|::              Moving in terms of lines of text.
* |Screen_Lines|::            Moving in terms of lines as displayed.
* |List_Motion|::             Moving by parsing lists and sexps.
* |Skipping_Characters|::     Skipping characters belonging to a certain set.

Markers

* |Overview_of_Markers|::     The components of a marker, and how it relocates.
* |Predicates_on_Markers|::   Testing whether an object is a marker.
* |Creating_Markers|::        Making empty markers or markers at certain places.
* |Information_from_Markers|::Finding the marker's buffer or character position.
* |Marker_Insertion_Types|::  Two ways a marker can relocate when you
                              insert where it points.
* |Moving_Markers|::          Moving the marker to a new buffer or position.
* |The_Mark|::                How the mark is implemented with a marker.
* |The_Region|::              How to access the region.

Text

* |Near_Point|::              Examining text in the vicinity of point.
* |Buffer_Contents|::         Examining text in a general fashion.
* |Comparing_Text|::          Comparing substrings of buffers.
* |Insertion|::               Adding new text to a buffer.
* |Commands_for_Insertion|::  User-level commands to insert text.
* |Deletion|::                Removing text from a buffer.
* |User_Level_Deletion|::     User-level commands to delete text.
* |The_Kill_Ring|::           Where removed text sometimes is saved for
                              later use.
* |Undo|::                    Undoing changes to the text of a buffer.
* |Maintaining_Undo|::        How to enable and disable undo information.
                              How to control how much information is kept.
* |Filling|::                 Functions for explicit filling.
* |Margins|::                 How to specify margins for filling commands.
* |Adaptive_Fill|::           Adaptive Fill mode chooses a fill prefix
                              from context.
* |Auto_Filling|::            How auto-fill mode is implemented to break lines.
* |Sorting|::                 Functions for sorting parts of the buffer.
* |Columns|::                 Computing horizontal positions, and using them.
* |Indentation|::             Functions to insert or adjust indentation.
* |Case_Changes|::            Case conversion of parts of the buffer.
* |Text_Properties|::         Assigning Lisp property lists to text characters.
* |Substitution|::            Replacing a given character wherever it appears.
* |Registers|::               How registers are implemented.  Accessing
                              the text or position stored in a register.
* |Transposition|::           Swapping two portions of a buffer.
* |Decompression|::           Dealing with compressed data.
* |Base_64|::                 Conversion to or from base 64 encoding.
* |Checksum/Hash|::           Computing cryptographic hashes.
* |GnuTLS_Cryptography|::     Cryptographic algorithms imported from GnuTLS.
* |Parsing_HTML/XML|::        Parsing HTML and XML.
* |Atomic_Changes|::          Installing several buffer changes atomically.
* |Change_Hooks|::            Supplying functions to be run when text is changed.

The Kill Ring

* |Kill_Ring_Concepts|::      What text looks like in the kill ring.
* |Kill_Functions|::          Functions that kill text.
* |Yanking|::                 How yanking is done.
* |Yank_Commands|::           Commands that access the kill ring.
* |Low_Level_Kill_Ring|::     Functions and variables for kill ring access.
* |Internals_of_Kill_Ring|::  Variables that hold kill ring data.

Indentation

* |Primitive_Indent|::        Functions used to count and insert indentation.
* |Mode_Specific_Indent|::    Customize indentation for different modes.
* |Region_Indent|::           Indent all the lines in a region.
* |Relative_Indent|::         Indent the current line based on previous lines.
* |Indent_Tabs|::             Adjustable, typewriter-like tab stops.
* |Motion_by_Indent|::        Move to first non-blank character.

Text Properties

* |Examining_Properties|::    Looking at the properties of one character.
* |Changing_Properties|::     Setting the properties of a range of text.
* |Property_Search|::         Searching for where a property changes value.
* |Special_Properties|::      Particular properties with special meanings.
* |Format_Properties|::       Properties for representing formatting of text.
* |Sticky_Properties|::       How inserted text gets properties from
                              neighboring text.
* |Lazy_Properties|::         Computing text properties in a lazy fashion
                              only when text is examined.
* |Clickable_Text|::          Using text properties to make regions of text
                              do something when you click on them.
* |Fields|::                  The 'field' property defines
                              fields within the buffer.
* |Not_Intervals|::           Why text properties do not use
                              Lisp-visible text intervals.

Parsing HTML and XML

* |Document_Object_Model|::   Access, manipulate and search the DOM.

Non-ASCII Characters

* |Text_Representations|::    How Emacs represents text.
* |Disabling_Multibyte|::     Controlling whether to use multibyte characters.
* |Converting_Representations|::  Converting unibyte to multibyte and vice versa.
* |Selecting_a_Representation|::  Treating a byte sequence as unibyte or multi.
* |Character_Codes|::         How unibyte and multibyte relate to
                                codes of individual characters.
* |Character_Properties|::    Character attributes that define their
                                behavior and handling.
* |Character_Sets|::          The space of possible character codes
                                is divided into various character sets.
* |Scanning_Charsets|::       Which character sets are used in a buffer?
* |Translation_of_Characters|::   Translation tables are used for conversion.
* |Coding_Systems|::          Coding systems are conversions for saving files.
* |Input_Methods|::           Input methods allow users to enter various
                                non-ASCII characters without special keyboards.
* |Locales|::                 Interacting with the POSIX locale.

Coding Systems

* |Coding_System_Basics|::    Basic concepts.
* |Encoding_and_I/O|::        How file I/O functions handle coding systems.
* |Lisp_and_Coding_Systems|:: Functions to operate on coding system names.
* |User_Chosen_Coding_Systems|::  Asking the user to choose a coding system.
* |Default_Coding_Systems|::  Controlling the default choices.
* |Specifying_Coding_Systems|::   Requesting a particular coding system
                                    for a single file operation.
* |Explicit_Encoding|::       Encoding or decoding text without doing I/O.
* |Terminal_I/O_Encoding|::   Use of encoding for terminal I/O.

Searching and Matching

* |String_Search|::           Search for an exact match.
* |Searching_and_Case|::      Case-independent or case-significant searching.
* |Regular_Expressions|::     Describing classes of strings.
* |Regexp_Search|::           Searching for a match for a regexp.
* |POSIX_Regexps|::           Searching POSIX-style for the longest match.
* |Match_Data|::              Finding out which part of the text matched,
                              after a string or regexp search.
* |Search_and_Replace|::      Commands that loop, searching and replacing.
* |Standard_Regexps|::        Useful regexps for finding sentences, pages,...

Regular Expressions

* |Syntax_of_Regexps|::       Rules for writing regular expressions.
* |Regexp_Example|::          Illustrates regular expression syntax.
* |Rx_Notation|::             An alternative, structured regexp notation.
* |Regexp_Functions|::        Functions for operating on regular expressions.

Syntax of Regular Expressions

* |Regexp_Special|::          Special characters in regular expressions.
* |Char_Classes|::            Character classes used in regular expressions.
* |Regexp_Backslash|::        Backslash-sequences in regular expressions.

The Match Data

* |Replacing_Match|::         Replacing a substring that was matched.
* |Simple_Match_Data|::       Accessing single items of match data,
                              such as where a particular subexpression started.
* |Entire_Match_Data|::       Accessing the entire match data at once, as a list.
* |Saving_Match_Data|::       Saving and restoring the match data.

Syntax Tables

* |Syntax_Basics|::           Basic concepts of syntax tables.
* |Syntax_Descriptors|::      How characters are classified.
* |Syntax_Table_Functions|::  How to create, examine and alter syntax tables.
* |Syntax_Properties|::       Overriding syntax with text properties.
* |Motion_and_Syntax|::       Moving over characters with certain syntaxes.
* |Parsing_Expressions|::     Parsing balanced expressions
                              using the syntax table.
* |Syntax_Table_Internals|::  How syntax table information is stored.
* |Categories|::              Another way of classifying character syntax.

Syntax Descriptors

* |Syntax_Class_Table|::      Table of syntax classes.
* |Syntax_Flags|::            Additional flags each character can have.

Parsing Expressions

* |Motion_via_Parsing|::      Motion functions that work by parsing.
* |Position_Parse|::          Determining the syntactic state of a position.
* |Parser_State|::            How Emacs represents a syntactic state.
* |Low_Level_Parsing|::       Parsing across a specified region.
* |Control_Parsing|::         Parameters that affect parsing.

Abbrevs and Abbrev Expansion

* |Abbrev_Tables|::           Creating and working with abbrev tables.
* |Defining_Abbrevs|::        Specifying abbreviations and their expansions.
* |Abbrev_Files|::            Saving abbrevs in files.
* |Abbrev_Expansion|::        Controlling expansion; expansion subroutines.
* |Standard_Abbrev_Tables|::  Abbrev tables used by various major modes.
* |Abbrev_Properties|::       How to read and set abbrev properties.
                            Which properties have which effect.
* |Abbrev_Table_Properties|:: How to read and set abbrev table properties.
                            Which properties have which effect.

Threads

* |Basic_Thread_Functions|::  Basic thread functions.
* |Mutexes|::                 Mutexes allow exclusive access to data.
* |Condition_Variables|::     Inter-thread events.
* |The_Thread_List|::         Show the active threads.

Processes

* |Subprocess_Creation|::     Functions that start subprocesses.
* |Shell_Arguments|::         Quoting an argument to pass it to a shell.
* |Synchronous_Processes|::   Details of using synchronous subprocesses.
* |Asynchronous_Processes|::  Starting up an asynchronous subprocess.
* |Deleting_Processes|::      Eliminating an asynchronous subprocess.
* |Process_Information|::     Accessing run-status and other attributes.
* |Input_to_Processes|::      Sending input to an asynchronous subprocess.
* |Signals_to_Processes|::    Stopping, continuing or interrupting
                              an asynchronous subprocess.
* |Output_from_Processes|::   Collecting output from an asynchronous subprocess.
* |Sentinels|::               Sentinels run when process run-status changes.
* |Query_Before_Exit|::       Whether to query if exiting will kill a process.
* |System_Processes|::        Accessing other processes running on your system.
* |Transaction_Queues|::      Transaction-based communication with subprocesses.
* |Network|::                 Opening network connections.
* |Network_Servers|::         Network servers let Emacs accept net connections.
* |Datagrams|::               UDP network connections.
* |Low_Level_Network|::       Lower-level but more general function
                              to create connections and servers.
* |Misc_Network|::            Additional relevant functions for net connections.
* |Serial_Ports|::            Communicating with serial ports.
* |Byte_Packing|::            Using bindat to pack and unpack binary data.

Receiving Output from Processes

* |Process_Buffers|::         By default, output is put in a buffer.
* |Filter_Functions|::        Filter functions accept output from the process.
* |Decoding_Output|::         Filters can get unibyte or multibyte strings.
* |Accepting_Output|::        How to wait until process output arrives.

Low-Level Network Access

* |Network_Processes|::       Using 'make-network-process'.
* |Network_Options|::         Further control over network connections.
* |Network_Feature_Testing|:: Determining which network features work on
                              the machine you are using.

Packing and Unpacking Byte Arrays

* |Bindat_Spec|::             Describing data layout.
* |Bindat_Functions|::        Doing the unpacking and packing.

Emacs Display

* |Refresh_Screen|::          Clearing the screen and redrawing everything on it.
* |Forcing_Redisplay|::       Forcing redisplay.
* |Truncation|::              Folding or wrapping long text lines.
* |The_Echo_Area|::           Displaying messages at the bottom of the screen.
* |Warnings|::                Displaying warning messages for the user.
* |Invisible_Text|::          Hiding part of the buffer text.
* |Selective_Display|::       Hiding part of the buffer text (the old way).
* |Temporary_Displays|::      Displays that go away automatically.
* |Overlays|::                Use overlays to highlight parts of the buffer.
* |Size_of_Displayed_Text|::  How large displayed text is.
* |Line_Height|::             Controlling the height of lines.
* |Faces|::                   A face defines a graphics style
                              for text characters: font, colors, etc.
* |Fringes|::                 Controlling window fringes.
* |Scroll_Bars|::             Controlling scroll bars.
* |Window_Dividers|::         Separating windows visually.
* |Display_Property|::        Enabling special display features.
* |Images|::                  Displaying images in Emacs buffers.
* |Buttons|::                 Adding clickable buttons to Emacs buffers.
* |Abstract_Display|::        Emacs's Widget for Object Collections.
* |Blinking|::                How Emacs shows the matching open parenthesis.
* |Character_Display|::       How Emacs displays individual characters.
* |Beeping|::                 Audible signal to the user.
* |Window_Systems|::          Which window system is being used.
* |Tooltips|::                Tooltip display in Emacs.
* |Bidirectional_Display|::   Display of bidirectional scripts, such as
                              Arabic and Farsi.

The Echo Area

* |Displaying_Messages|::     Explicitly displaying text in the echo area.
* |Progress|::                Informing user about progress of a long operation.
* |Logging_Messages|::        Echo area messages are logged for the user.
* |Echo_Area_Customization|:: Controlling the echo area.

Reporting Warnings

* |Warning_Basics|::          Warnings concepts and functions to report them.
* |Warning_Variables|::       Variables programs bind to customize
                              their warnings.
* |Warning_Options|::         Variables users set to control display of warnings.
* |Delayed_Warnings|::        Deferring a warning until the end of a command.

Overlays

* |Managing_Overlays|::       Creating and moving overlays.
* |Overlay_Properties|::      How to read and set properties.
                              What properties do to the screen display.
* |Finding_Overlays|::        Searching for overlays.

Faces

* |Face_Attributes|::         What is in a face?
* |Defining_Faces|::          How to define a face.
* |Attribute_Functions|::     Functions to examine and set face attributes.
* |Displaying_Faces|::        How Emacs combines the faces specified for
                              a character.
* |Face_Remapping|::          Remapping faces to alternative definitions.
* |Face_Functions|::          How to define and examine faces.
* |Auto_Faces|::              Hook for automatic face assignment.
* |Basic_Faces|::             Faces that are defined by default.
* |Font_Selection|::          Finding the best available font for a face.
* |Font_Lookup|::             Looking up the names of available fonts
                              and information about them.
* |Fontsets|::                A fontset is a collection of fonts
                              that handle a range of character sets.
* |Low_Level_Font|::          Lisp representation for character display fonts.

Fringes

* |Fringe_Size/Pos|::         Specifying where to put the window fringes.
* |Fringe_Indicators|::       Displaying indicator icons in the window fringes.
* |Fringe_Cursors|::          Displaying cursors in the right fringe.
* |Fringe_Bitmaps|::          Specifying bitmaps for fringe indicators.
* |Customizing_Bitmaps|::     Specifying your own bitmaps to use in the fringes.
* |Overlay_Arrow|::           Display of an arrow to indicate position.

The 'display' Property

* |Replacing_Specs|::         Display specs that replace the text.
* |Specified_Space|::         Displaying one space with a specified width.
* |Pixel_Specification|::     Specifying space width or height in pixels.
* |Other_Display_Specs|::     Displaying an image; adjusting the height,
                              spacing, and other properties of text.
* |Display_Margins|::         Displaying text or images to the side of
                              the main text.

Images

* |Image_Formats|::           Supported image formats.
* |Image_Descriptors|::       How to specify an image for use in ':display'.
* |XBM_Images|::              Special features for XBM format.
* |XPM_Images|::              Special features for XPM format.
* |ImageMagick_Images|::      Special features available through ImageMagick.
* |Other_Image_Types|::       Various other formats are supported.
* |Defining_Images|::         Convenient ways to define an image for later use.
* |Showing_Images|::          Convenient ways to display an image once
                              it is defined.
* |Multi_Frame_Images|::      Some images contain more than one frame.
* |Image_Cache|::             Internal mechanisms of image display.

Buttons

* |Button_Properties|::       Button properties with special meanings.
* |Button_Types|::            Defining common properties for classes of buttons.
* |Making_Buttons|::          Adding buttons to Emacs buffers.
* |Manipulating_Buttons|::    Getting and setting properties of buttons.
* |Button_Buffer_Commands|::  Buffer-wide commands and bindings for buttons.

Abstract Display

* |Abstract_Display_Functions|::  Functions in the Ewoc package.
* |Abstract_Display_Example|::    Example of using Ewoc.

Character Display

* |Usual_Display|::       The usual conventions for displaying characters.
* |Display_Tables|::      What a display table consists of.
* |Active_Display_Table|::  How Emacs selects a display table to use.
* |Glyphs|::              How to define a glyph, and what glyphs mean.
* |Glyphless_Chars|::     How glyphless characters are drawn.

Operating System Interface

* |Starting_Up|::             Customizing Emacs startup processing.
* |Getting_Out|::             How exiting works (permanent or temporary).
* |System_Environment|::      Distinguish the name and kind of system.
* |User_Identification|::     Finding the name and user id of the user.
* |Time_of_Day|::             Getting the current time.
* |Time_Conversion|::         Converting among timestamp forms.
* |Time_Parsing|::            Converting timestamps to text and vice versa.
* |Processor_Run_Time|::      Getting the run time used by Emacs.
* |Time_Calculations|::       Adding, subtracting, comparing times, etc.
* |Timers|::                  Setting a timer to call a function at a
                              certain time.
* |Idle_Timers|::             Setting a timer to call a function when Emacs has
                              been idle for a certain length of time.
* |Terminal_Input|::          Accessing and recording terminal input.
* |Terminal_Output|::         Controlling and recording terminal output.
* |Sound_Output|::            Playing sounds on the computer's speaker.
* |X11_Keysyms|::             Operating on key symbols for X Windows.
* |Batch_Mode|::              Running Emacs without terminal interaction.
* |Session_Management|::      Saving and restoring state with
                              X Session Management.
* |Desktop_Notifications|::   Desktop notifications.
* |File_Notifications|::      File notifications.
* |Dynamic_Libraries|::       On-demand loading of support libraries.
* |Security_Considerations|:: Running Emacs in an unfriendly environment.

Starting Up Emacs

* |Startup_Summary|::         Sequence of actions Emacs performs at startup.
* |Init_File|::               Details on reading the init file.
* |Terminal_Specific|::       How the terminal-specific Lisp file is read.
* |Command_Line_Arguments|::  How command-line arguments are processed,
                              and how you can customize them.

Getting Out of Emacs

* |Killing_Emacs|::           Exiting Emacs irreversibly.
* |Suspending_Emacs|::        Exiting Emacs reversibly.

Terminal Input

* |Input_Modes|::             Options for how input is processed.
* |Recording_Input|::         Saving histories of recent or all input events.

Preparing Lisp code for distribution

* |Packaging_Basics|::        The basic concepts of Emacs Lisp packages.
* |Simple_Packages|::         How to package a single .el file.
* |Multi_file_Packages|::     How to package multiple files.
* |Package_Archives|::        Maintaining package archives.

Tips and Conventions

* |Coding_Conventions|::      Conventions for clean and robust programs.
* |Key_Binding_Conventions|:: Which keys should be bound by which programs.
* |Programming_Tips|::        Making Emacs code fit smoothly in Emacs.
* |Compilation_Tips|::        Making compiled code run fast.
* |Warning_Tips|::            Turning off compiler warnings.
* |Documentation_Tips|::      Writing readable documentation strings.
* |Comment_Tips|::            Conventions for writing comments.
* |Library_Headers|::         Standard headers for library packages.

GNU Emacs Internals

* |Building_Emacs|::          How the dumped Emacs is made.
* |Pure_Storage|::            Kludge to make preloaded Lisp functions shareable.
* |Garbage_Collection|::      Reclaiming space for Lisp objects no longer used.
* |Stack_allocated_Objects|:: Temporary conses and strings on C stack.
* |Memory_Usage|::            Info about total size of Lisp objects made so far.
* |C_Dialect|::               What C variant Emacs is written in.
* |Writing_Emacs_Primitives|::  Writing C code for Emacs.
* |Writing_Dynamic_Modules|::   Writing loadable modules for Emacs.
* |Object_Internals|::        Data formats of buffers, windows, processes.
* |C_Integer_Types|::         How C integer types are used inside Emacs.

Writing Dynamic Modules

* |Module_Initialization|::
* |Module_Functions|::
* |Module_Values|::
* |Module_Misc|::
* |Module_Nonlocal|::

Object Internals

* |Buffer_Internals|::        Components of a buffer structure.
* |Window_Internals|::        Components of a window structure.
* |Process_Internals|::       Components of a process structure.

==============================================================================
File: elisp.info,  Node: |Introduction|,  Next: |Lisp_Data_Types|,  Prev: |Top|,  Up: |Top|
==============================================================================

                                                                  *Introduction*

1 Introduction
==============

Most of the GNU Emacs text editor is written in the programming language
called Emacs Lisp.  You can write new code in Emacs Lisp and install it
as an extension to the editor.  However, Emacs Lisp is more than a mere
extension language; it is a full computer programming language in its
own right.  You can use it as you would any other programming language.

   Because Emacs Lisp is designed for use in an editor, it has special
features for scanning and parsing text as well as features for handling
files, buffers, displays, subprocesses, and so on.  Emacs Lisp is
closely integrated with the editing facilities; thus, editing commands
are functions that can also conveniently be called from Lisp programs,
and parameters for customization are ordinary Lisp variables.

   This manual attempts to be a full description of Emacs Lisp.  For a
beginner's introduction to Emacs Lisp, see 'An Introduction to Emacs
Lisp Programming', by Bob Chassell, also published by the Free Software
Foundation.  This manual presumes considerable familiarity with the use
of Emacs for editing; see 'The GNU Emacs Manual' for this basic
information.

   Generally speaking, the earlier chapters describe features of Emacs
Lisp that have counterparts in many programming languages, and later
chapters describe features that are peculiar to Emacs Lisp or relate
specifically to editing.

   This is the 'GNU Emacs Lisp Reference Manual', corresponding to Emacs
version 27.1.

MENU

* |Caveats|::             Flaws and a request for help.
* |Lisp_History|::        Emacs Lisp is descended from Maclisp.
* |Conventions|::         How the manual is formatted.
* |Version_Info|::        Which Emacs version is running?
* |Acknowledgments|::     The authors, editors, and sponsors of this manual.

==============================================================================
File: elisp.info,  Node: |Caveats|,  Next: |Lisp_History|,  Up: |Introduction|
==============================================================================

                                                                       *Caveats*

1.1 Caveats
-----------

This manual has gone through numerous drafts.  It is nearly complete but
not flawless.  There are a few topics that are not covered, either
because we consider them secondary (such as most of the individual
modes) or because they are yet to be written.  Because we are not able
to deal with them completely, we have left out several parts
intentionally.

   The manual should be fully correct in what it does cover, and it is
therefore open to criticism on anything it says--from specific examples
and descriptive text, to the ordering of chapters and sections.  If
something is confusing, or you find that you have to look at the sources
or experiment to learn something not covered in the manual, then perhaps
the manual should be fixed.  Please let us know.

   As you use this manual, we ask that you send corrections as soon as
you find them.  If you think of a simple, real life example for a
function or group of functions, please make an effort to write it up and
send it in.  Please reference any comments to the node name and function
or variable name, as appropriate.  Also state the number of the edition
you are criticizing.

   Please send comments and corrections using 'M-x report-emacs-bug'.

==============================================================================
File: elisp.info,  Node: |Lisp_History|,  Next: |Conventions|,  Prev: |Caveats|,  Up: |Introduction|
==============================================================================

                                                                  *Lisp_History*

1.2 Lisp History
----------------

Lisp (LISt Processing language) was first developed in the late 1950s at
the Massachusetts Institute of Technology for research in artificial
intelligence.  The great power of the Lisp language makes it ideal for
other purposes as well, such as writing editing commands.

   Dozens of Lisp implementations have been built over the years, each
with its own idiosyncrasies.  Many of them were inspired by Maclisp,
which was written in the 1960s at MIT's Project MAC.  Eventually the
implementers of the descendants of Maclisp came together and developed a
standard for Lisp systems, called Common Lisp.  In the meantime, Gerry
Sussman and Guy Steele at MIT developed a simplified but very powerful
dialect of Lisp, called Scheme.

   GNU Emacs Lisp is largely inspired by Maclisp, and a little by Common
Lisp.  If you know Common Lisp, you will notice many similarities.
However, many features of Common Lisp have been omitted or simplified in
order to reduce the memory requirements of GNU Emacs.  Sometimes the
simplifications are so drastic that a Common Lisp user might be very
confused.  We will occasionally point out how GNU Emacs Lisp differs
from Common Lisp.  If you don't know Common Lisp, don't worry about it;
this manual is self-contained.

   A certain amount of Common Lisp emulation is available via the
'cl-lib' library.  *Note Overview: (cl)Top.

   Emacs Lisp is not at all influenced by Scheme; but the GNU project
has an implementation of Scheme, called Guile.  We use it in all new GNU
software that calls for extensibility.

==============================================================================
File: elisp.info,  Node: |Conventions|,  Next: |Version_Info|,  Prev: |Lisp_History|,  Up: |Introduction|
==============================================================================

                                                                   *Conventions*

1.3 Conventions
---------------

This section explains the notational conventions that are used in this
manual.  You may want to skip this section and refer back to it later.

MENU

* |Some_Terms|::               Explanation of terms we use in this manual.
* |nil_and_t|::                How the symbols 'nil' and 't' are used.
* |Evaluation_Notation|::      The format we use for examples of evaluation.
* |Printing_Notation|::        The format we use when examples print text.
* |Error_Messages|::           The format we use for examples of errors.
* |Buffer_Text_Notation|::     The format we use for buffer contents in examples.
* |Format_of_Descriptions|::   Notation for describing functions, variables, etc.

==============================================================================
File: elisp.info,  Node: |Some_Terms|,  Next: |nil_and_t|,  Up: |Conventions|
==============================================================================

                                                                    *Some_Terms*

1.3.1 Some Terms
----------------

Throughout this manual, the phrases "the Lisp reader" and "the Lisp
printer" refer to those routines in Lisp that convert textual
representations of Lisp objects into actual Lisp objects, and vice
versa.  *Note Printed Representation::, for more details.  You, the
person reading this manual, are thought of as the programmer and are
addressed as "you".  The user is the person who uses Lisp programs,
including those you write.

   Examples of Lisp code are formatted like this: '(list 1 2 3)'.  Names
that represent metasyntactic variables, or arguments to a function being
described, are formatted like this: FIRST-NUMBER.

==============================================================================
File: elisp.info,  Node: |nil_and_t|,  Next: |Evaluation_Notation|,  Prev: |Some_Terms|,  Up: |Conventions|
==============================================================================

                                                                     *nil_and_t*

1.3.2 'nil' and 't'
-------------------

In Emacs Lisp, the symbol 'nil' has three separate meanings: it is a
symbol with the name 'nil'; it is the logical truth value FALSE; and it
is the empty list--the list of zero elements.  When used as a variable,
'nil' always has the value 'nil'.

   As far as the Lisp reader is concerned, '()' and 'nil' are identical:
they stand for the same object, the symbol 'nil'.  The different ways of
writing the symbol are intended entirely for human readers.  After the
Lisp reader has read either '()' or 'nil', there is no way to determine
which representation was actually written by the programmer.

   In this manual, we write '()' when we wish to emphasize that it means
the empty list, and we write 'nil' when we wish to emphasize that it
means the truth value FALSE.  That is a good convention to use in Lisp
programs also.

     (cons 'foo ())                ; Emphasize the empty list
     (setq foo-flag nil)           ; Emphasize the truth value FALSE

   In contexts where a truth value is expected, any non-'nil' value is
considered to be TRUE.  However, 't' is the preferred way to represent
the truth value TRUE.  When you need to choose a value that represents
TRUE, and there is no other basis for choosing, use 't'.  The symbol 't'
always has the value 't'.

   In Emacs Lisp, 'nil' and 't' are special symbols that always evaluate
to themselves.  This is so that you do not need to quote them to use
them as constants in a program.  An attempt to change their values
results in a 'setting-constant' error.  *Note Constant Variables::.

 -- Function: booleanp object
     Return non-'nil' if OBJECT is one of the two canonical boolean
     values: 't' or 'nil'.

==============================================================================
File: elisp.info,  Node: |Evaluation_Notation|,  Next: |Printing_Notation|,  Prev: |nil_and_t|,  Up: |Conventions|
==============================================================================

                                                           *Evaluation_Notation*

1.3.3 Evaluation Notation
-------------------------

A Lisp expression that you can evaluate is called a "form".  Evaluating
a form always produces a result, which is a Lisp object.  In the
examples in this manual, this is indicated with '=>':

     (car '(1 2))
          => 1

You can read this as "'(car '(1 2))' evaluates to 1".

   When a form is a macro call, it expands into a new form for Lisp to
evaluate.  We show the result of the expansion with '==>'.  We may or may
not show the result of the evaluation of the expanded form.

     (third '(a b c))
          ==> (car (cdr (cdr '(a b c))))
          => c

   To help describe one form, we sometimes show another form that
produces identical results.  The exact equivalence of two forms is
indicated with '???'.

     (make-sparse-keymap) ??? (list 'keymap)

==============================================================================
File: elisp.info,  Node: |Printing_Notation|,  Next: |Error_Messages|,  Prev: |Evaluation_Notation|,  Up: |Conventions|
==============================================================================

                                                             *Printing_Notation*

1.3.4 Printing Notation
-----------------------

Many of the examples in this manual print text when they are evaluated.
If you execute example code in a Lisp Interaction buffer (such as the
buffer 'scratch'), the printed text is inserted into the buffer.  If
you execute the example by other means (such as by evaluating the
function 'eval-region'), the printed text is displayed in the echo area.

   Examples in this manual indicate printed text with '-|', irrespective
of where that text goes.  The value returned by evaluating the form
follows on a separate line with '=>'.

     (progn (prin1 'foo) (princ "\n") (prin1 'bar))
          -| foo
          -| bar
          => bar

==============================================================================
File: elisp.info,  Node: |Error_Messages|,  Next: |Buffer_Text_Notation|,  Prev: |Printing_Notation|,  Up: |Conventions|
==============================================================================

                                                                *Error_Messages*

1.3.5 Error Messages
--------------------

Some examples signal errors.  This normally displays an error message in
the echo area.  We show the error message on a line starting with
'error->'.  Note that 'error->' itself does not appear in the echo area.

     (+ 23 'x)
     error-> Wrong type argument: number-or-marker-p, x

==============================================================================
File: elisp.info,  Node: |Buffer_Text_Notation|,  Next: |Format_of_Descriptions|,  Prev: |Error_Messages|,  Up: |Conventions|
==============================================================================

                                                          *Buffer_Text_Notation*

1.3.6 Buffer Text Notation
--------------------------

Some examples describe modifications to the contents of a buffer, by
showing the before and after versions of the text.  These examples show
the contents of the buffer in question between two lines of dashes
containing the buffer name.  In addition, '-!-' indicates the location of
point.  (The symbol for point, of course, is not part of the text in the
buffer; it indicates the place _between_ two characters where point is
currently located.)

     ---------- Buffer: foo ----------
     This is the -!-contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          => nil
     ---------- Buffer: foo ----------
     This is the changed -!-contents of foo.
     ---------- Buffer: foo ----------

==============================================================================
File: elisp.info,  Node: |Format_of_Descriptions|,  Prev: |Buffer_Text_Notation|,  Up: |Conventions|
==============================================================================

                                                        *Format_of_Descriptions*

1.3.7 Format of Descriptions
----------------------------

Functions, variables, macros, commands, user options, and special forms
are described in this manual in a uniform format.  The first line of a
description contains the name of the item followed by its arguments, if
any.  The category--function, variable, or whatever--appears at the
beginning of the line.  The description follows on succeeding lines,
sometimes with examples.

MENU

* |A_Sample_Function_Description|::       A description of an imaginary
                                          function, 'foo'.
* |A_Sample_Variable_Description|::       A description of an imaginary
                                          variable,
                                          'electric-future-map'.

==============================================================================
File: elisp.info,  Node: |A_Sample_Function_Description|,  Next: |A_Sample_Variable_Description|,  Up: |Format_of_Descriptions|
==============================================================================

                                                 *A_Sample_Function_Description*

1.3.7.1 A Sample Function Description
-------------------------------------

In a function description, the name of the function being described
appears first.  It is followed on the same line by a list of argument
names.  These names are also used in the body of the description, to
stand for the values of the arguments.

   The appearance of the keyword '&optional' in the argument list
indicates that the subsequent arguments may be omitted (omitted
arguments default to 'nil').  Do not write '&optional' when you call the
function.

   The keyword '&rest' (which must be followed by a single argument
name) indicates that any number of arguments can follow.  The single
argument name following '&rest' receives, as its value, a list of all
the remaining arguments passed to the function.  Do not write '&rest'
when you call the function.

   Here is a description of an imaginary function 'foo':

 -- Function: foo integer1 &optional integer2 &rest integers
     The function 'foo' subtracts INTEGER1 from INTEGER2, then adds all
     the rest of the arguments to the result.  If INTEGER2 is not
     supplied, then the number 19 is used by default.

          (foo 1 5 3 9)
               => 16
          (foo 5)
               => 14

     More generally,

          (foo W X Y...)
          ???
          (+ (- X W) Y...)

   By convention, any argument whose name contains the name of a type
(e.g., INTEGER, INTEGER1 or BUFFER) is expected to be of that type.  A
plural of a type (such as BUFFERS) often means a list of objects of that
type.  An argument named OBJECT may be of any type.  (For a list of
Emacs object types, *note Lisp Data Types::.)  An argument with any
other sort of name (e.g., NEW-FILE) is specific to the function; if the
function has a documentation string, the type of the argument should be
described there (*note Documentation::).

   *Note Lambda Expressions::, for a more complete description of
arguments modified by '&optional' and '&rest'.

   Command, macro, and special form descriptions have the same format,
but the word 'Function' is replaced by 'Command', 'Macro', or 'Special
Form', respectively.  Commands are simply functions that may be called
interactively; macros process their arguments differently from functions
(the arguments are not evaluated), but are presented the same way.

   The descriptions of macros and special forms use a more complex
notation to specify optional and repeated arguments, because they can
break the argument list down into separate arguments in more complicated
ways.  '[OPTIONAL-ARG]' means that OPTIONAL-ARG is optional and
'REPEATED-ARGS...' stands for zero or more arguments.  Parentheses are
used when several arguments are grouped into additional levels of list
structure.  Here is an example:

 -- Special Form: count-loop (var [from to [inc]]) body...
     This imaginary special form implements a loop that executes the
     BODY forms and then increments the variable VAR on each iteration.
     On the first iteration, the variable has the value FROM; on
     subsequent iterations, it is incremented by one (or by INC if that
     is given).  The loop exits before executing BODY if VAR equals TO.
     Here is an example:

          (count-loop (i 0 10)
            (prin1 i) (princ " ")
            (prin1 (aref vector i))
            (terpri))

     If FROM and TO are omitted, VAR is bound to 'nil' before the loop
     begins, and the loop exits if VAR is non-'nil' at the beginning of
     an iteration.  Here is an example:

          (count-loop (done)
            (if (pending)
                (fixit)
              (setq done t)))

     In this special form, the arguments FROM and TO are optional, but
     must both be present or both absent.  If they are present, INC may
     optionally be specified as well.  These arguments are grouped with
     the argument VAR into a list, to distinguish them from BODY, which
     includes all remaining elements of the form.

==============================================================================
File: elisp.info,  Node: |A_Sample_Variable_Description|,  Prev: |A_Sample_Function_Description|,  Up: |Format_of_Descriptions|
==============================================================================

                                                 *A_Sample_Variable_Description*

1.3.7.2 A Sample Variable Description
-------------------------------------

A "variable" is a name that can be "bound" (or "set") to an object.  The
object to which a variable is bound is called a "value"; we say also
that variable holds that value.  Although nearly all variables can be
set by the user, certain variables exist specifically so that users can
change them; these are called "user options".  Ordinary variables and
user options are described using a format like that for functions,
except that there are no arguments.

   Here is a description of the imaginary 'electric-future-map'
variable.

 -- Variable: electric-future-map
     The value of this variable is a full keymap used by Electric
     Command Future mode.  The functions in this map allow you to edit
     commands you have not yet thought about executing.

   User option descriptions have the same format, but 'Variable' is
replaced by 'User Option'.

==============================================================================
File: elisp.info,  Node: |Version_Info|,  Next: |Acknowledgments|,  Prev: |Conventions|,  Up: |Introduction|
==============================================================================

                                                                  *Version_Info*

1.4 Version Information
-----------------------

These facilities provide information about which version of Emacs is in
use.

 -- Command: emacs-version &optional here
     This function returns a string describing the version of Emacs that
     is running.  It is useful to include this string in bug reports.

          (emacs-version)
            => "GNU Emacs 26.1 (build 1, x86_64-unknown-linux-gnu,
                       GTK+ Version 3.16) of 2017-06-01"

     If HERE is non-'nil', it inserts the text in the buffer before
     point, and returns 'nil'.  When this function is called
     interactively, it prints the same information in the echo area, but
     giving a prefix argument makes HERE non-'nil'.

 -- Variable: emacs-build-time
     The value of this variable indicates the time at which Emacs was
     built.  It uses the style of 'current-time' (*note Time of Day::),
     or is 'nil' if the information is not available.

          emacs-build-time
               => (20614 63694 515336 438000)

 -- Variable: emacs-version
     The value of this variable is the version of Emacs being run.  It
     is a string such as '"26.1"'.  A value with three numeric
     components, such as '"26.0.91"', indicates an unreleased test
     version.  (Prior to Emacs 26.1, the string includes an extra final
     component with the integer that is now stored in
     'emacs-build-number'; e.g., '"25.1.1"'.)

 -- Variable: emacs-major-version
     The major version number of Emacs, as an integer.  For Emacs
     version 23.1, the value is 23.

 -- Variable: emacs-minor-version
     The minor version number of Emacs, as an integer.  For Emacs
     version 23.1, the value is 1.

 -- Variable: emacs-build-number
     An integer that increments each time Emacs is built in the same
     directory (without cleaning).  This is only of relevance when
     developing Emacs.

 -- Variable: emacs-repository-version
     A string that gives the repository revision from which Emacs was
     built.  If Emacs was built outside revision control, the value is
     'nil'.

 -- Variable: emacs-repository-branch
     A string that gives the repository branch from which Emacs was
     built.  In the most cases this is '"master"'.  If Emacs was built
     outside revision control, the value is 'nil'.

==============================================================================
File: elisp.info,  Node: |Acknowledgments|,  Prev: |Version_Info|,  Up: |Introduction|
==============================================================================

                                                               *Acknowledgments*

1.5 Acknowledgments
-------------------

This manual was originally written by Robert Krawitz, Bil Lewis, Dan
LaLiberte, Richard M. Stallman and Chris Welty, the volunteers of the
GNU manual group, in an effort extending over several years.  Robert J.
Chassell helped to review and edit the manual, with the support of the
Defense Advanced Research Projects Agency, ARPA Order 6082, arranged by
Warren A. Hunt, Jr. of Computational Logic, Inc.  Additional sections
have since been written by Miles Bader, Lars Brinkhoff, Chong Yidong,
Kenichi Handa, Lute Kamstra, Juri Linkov, Glenn Morris, Thien-Thi
Nguyen, Dan Nicolaescu, Martin Rudalics, Kim F. Storm, Luc Teirlinck,
and Eli Zaretskii, and others.

   Corrections were supplied by Drew Adams, Juanma Barranquero, Karl
Berry, Jim Blandy, Bard Bloom, Stephane Boucher, David Boyes, Alan
Carroll, Richard Davis, Lawrence R. Dodd, Peter Doornbosch, David A.
Duff, Chris Eich, Beverly Erlebacher, David Eckelkamp, Ralf Fassel,
Eirik Fuller, Stephen Gildea, Bob Glickstein, Eric Hanchrow, Jesper
Harder, George Hartzell, Nathan Hess, Masayuki Ida, Dan Jacobson, Jak
Kirman, Bob Knighten, Frederick M. Korz, Joe Lammens, Glenn M. Lewis, K.
Richard Magill, Brian Marick, Roland McGrath, Stefan Monnier, Skip
Montanaro, John Gardiner Myers, Thomas A. Peterson, Francesco Potort??,
Friedrich Pukelsheim, Arnold D. Robbins, Raul Rockwell, Jason Rumney,
Per Starba"ck, Shinichirou Sugou, Kimmo Suominen, Edward Tharp, Bill
Trost, Rickard Westman, Jean White, Eduard Wiebe, Matthew Wilding, Carl
Witty, Dale Worley, Rusty Wright, and David D. Zuhn.

   For a more complete list of contributors, please see the relevant
change log entries in the Emacs source repository.

==============================================================================
File: elisp.info,  Node: |Lisp_Data_Types|,  Next: |Numbers|,  Prev: |Introduction|,  Up: |Top|
==============================================================================

                                                               *Lisp_Data_Types*

2 Lisp Data Types
=================

A Lisp "object" is a piece of data used and manipulated by Lisp
programs.  For our purposes, a "type" or "data type" is a set of
possible objects.

   Every object belongs to at least one type.  Objects of the same type
have similar structures and may usually be used in the same contexts.
Types can overlap, and objects can belong to two or more types.
Consequently, we can ask whether an object belongs to a particular type,
but not for _the_ type of an object.

   A few fundamental object types are built into Emacs.  These, from
which all other types are constructed, are called "primitive types".
Each object belongs to one and only one primitive type.  These types
include "integer", "float", "cons", "symbol", "string", "vector",
"hash-table", "subr", "byte-code function", and "record", plus several
special types, such as "buffer", that are related to editing.  (*Note
Editing Types::.)

   Each primitive type has a corresponding Lisp function that checks
whether an object is a member of that type.

   Lisp is unlike many other languages in that its objects are
"self-typing": the primitive type of each object is implicit in the
object itself.  For example, if an object is a vector, nothing can treat
it as a number; Lisp knows it is a vector, not a number.

   In most languages, the programmer must declare the data type of each
variable, and the type is known by the compiler but not represented in
the data.  Such type declarations do not exist in Emacs Lisp.  A Lisp
variable can have any type of value, and it remembers whatever value you
store in it, type and all.  (Actually, a small number of Emacs Lisp
variables can only take on values of a certain type.  *Note Variables
with Restricted Values::.)

   This chapter describes the purpose, printed representation, and read
syntax of each of the standard types in GNU Emacs Lisp.  Details on how
to use these types can be found in later chapters.

MENU

* |Printed_Representation|::      How Lisp objects are represented as text.
* |Special_Read_Syntax|::         An overview of all the special sequences.
* |Comments|::                    Comments and their formatting conventions.
* |Programming_Types|::           Types found in all Lisp systems.
* |Editing_Types|::               Types specific to Emacs.
* |Circular_Objects|::            Read syntax for circular structure.
* |Type_Predicates|::             Tests related to types.
* |Equality_Predicates|::         Tests of equality between any two objects.
* |Mutability|::                  Some objects should not be modified.

==============================================================================
File: elisp.info,  Node: |Printed_Representation|,  Next: |Special_Read_Syntax|,  Up: |Lisp_Data_Types|
==============================================================================

                                                        *Printed_Representation*

2.1 Printed Representation and Read Syntax
------------------------------------------

The "printed representation" of an object is the format of the output
generated by the Lisp printer (the function 'prin1') for that object.
Every data type has a unique printed representation.  The "read syntax"
of an object is the format of the input accepted by the Lisp reader (the
function 'read') for that object.  This is not necessarily unique; many
kinds of object have more than one syntax.  *Note Read and Print::.

   In most cases, an object's printed representation is also a read
syntax for the object.  However, some types have no read syntax, since
it does not make sense to enter objects of these types as constants in a
Lisp program.  These objects are printed in "hash notation", which
consists of the characters '#<', a descriptive string (typically the
type name followed by the name of the object), and a closing '>'.  For
example:

     (current-buffer)
          => #<buffer objects.texi>

Hash notation cannot be read at all, so the Lisp reader signals the
error 'invalid-read-syntax' whenever it encounters '#<'.

   In other languages, an expression is text; it has no other form.  In
Lisp, an expression is primarily a Lisp object and only secondarily the
text that is the object's read syntax.  Often there is no need to
emphasize this distinction, but you must keep it in the back of your
mind, or you will occasionally be very confused.

   When you evaluate an expression interactively, the Lisp interpreter
first reads the textual representation of it, producing a Lisp object,
and then evaluates that object (*note Evaluation::).  However,
evaluation and reading are separate activities.  Reading returns the
Lisp object represented by the text that is read; the object may or may
not be evaluated later.  *Note Input Functions::, for a description of
'read', the basic function for reading objects.

==============================================================================
File: elisp.info,  Node: |Special_Read_Syntax|,  Next: |Comments|,  Prev: |Printed_Representation|,  Up: |Lisp_Data_Types|
==============================================================================

                                                           *Special_Read_Syntax*

2.2 Special Read Syntax
-----------------------

Emacs Lisp represents many special objects and constructs via special
hash notations.

'#<...>'
     Objects that have no read syntax are presented like this (*note
     Printed Representation::).

'##'
     The printed representation of an interned symbol whose name is an
     empty string (*note Symbol Type::).

'#''
     This is a shortcut for 'function', see *note Anonymous Functions::.

'#:'
     The printed representation of an uninterned symbol whose name is
     FOO is '#:FOO' (*note Symbol Type::).

'#N'
     When printing circular structures, this construct is used to
     represent where the structure loops back onto itself, and 'N' is
     the starting list count:

          (let ((a (list 1)))
            (setcdr a a))
          => (1 . #0)

'#N='
'#N#'
     '#N=' gives the name to an object, and '#N#' represents that
     object, so when reading back the object, they will be the same
     object instead of copies (*note Circular Objects::).

'#@N'
     Skip the next 'N' characters (*note Comments::).

'#xN'
     'N' represented as a hexadecimal number ('#x2a').

'#oN'
     'N' represented as an octal number ('#o52').

'#bN'
     'N' represented as a binary number ('#b101010').

'#(...)'
     String text properties (*note Text Props and Strings::).

'#^'
     A char table (*note Char-Table Type::).

'#s(hash-table ...)'
     A hash table (*note Hash Table Type::).

'?C'
     A character (*note Basic Char Syntax::).

'#$'
     The current file name in byte-compiled files (*note Docs and
     Compilation::).  This is not meant to be used in Emacs Lisp source
     files.

'#@N'
     Skip the next 'N' characters (*note Comments::).  This is used in
     byte-compiled files, and is not meant to be used in Emacs Lisp
     source files.

==============================================================================
File: elisp.info,  Node: |Comments|,  Next: |Programming_Types|,  Prev: |Special_Read_Syntax|,  Up: |Lisp_Data_Types|
==============================================================================

                                                                      *Comments*

2.3 Comments
------------

A "comment" is text that is written in a program only for the sake of
humans that read the program, and that has no effect on the meaning of
the program.  In Lisp, an unescaped semicolon (';') starts a comment if
it is not within a string or character constant.  The comment continues
to the end of line.  The Lisp reader discards comments; they do not
become part of the Lisp objects which represent the program within the
Lisp system.

   The '#@COUNT' construct, which skips the next COUNT characters, is
useful for program-generated comments containing binary data.  The Emacs
Lisp byte compiler uses this in its output files (*note Byte
Compilation::).  It isn't meant for source files, however.

   *Note Comment Tips::, for conventions for formatting comments.

==============================================================================
File: elisp.info,  Node: |Programming_Types|,  Next: |Editing_Types|,  Prev: |Comments|,  Up: |Lisp_Data_Types|
==============================================================================

                                                             *Programming_Types*

2.4 Programming Types
---------------------

There are two general categories of types in Emacs Lisp: those having to
do with Lisp programming, and those having to do with editing.  The
former exist in many Lisp implementations, in one form or another.  The
latter are unique to Emacs Lisp.

MENU

* |Integer_Type|::        Numbers without fractional parts.
* |Floating_Point_Type|:: Numbers with fractional parts and with a large range.
* |Character_Type|::      The representation of letters, numbers and
                        control characters.
* |Symbol_Type|::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* |Sequence_Type|::       Both lists and arrays are classified as sequences.
* |Cons_Cell_Type|::      Cons cells, and lists (which are made from cons cells).
* |Array_Type|::          Arrays include strings and vectors.
* |String_Type|::         An (efficient) array of characters.
* |Vector_Type|::         One-dimensional arrays.
* |Char_Table_Type|::     One-dimensional sparse arrays indexed by characters.
* |Bool_Vector_Type|::    One-dimensional arrays of 't' or 'nil'.
* |Hash_Table_Type|::     Super-fast lookup tables.
* |Function_Type|::       A piece of executable code you can call from elsewhere.
* |Macro_Type|::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* |Primitive_Function_Type|::     A function written in C, callable from Lisp.
* |Byte_Code_Type|::      A function written in Lisp, then compiled.
* |Record_Type|::         Compound objects with programmer-defined types.
* |Type_Descriptors|::    Objects holding information about types.
* |Autoload_Type|::       A type used for automatically loading seldom-used
                        functions.
* |Finalizer_Type|::      Runs code when no longer reachable.

==============================================================================
File: elisp.info,  Node: |Integer_Type|,  Next: |Floating_Point_Type|,  Up: |Programming_Types|
==============================================================================

                                                                  *Integer_Type*

2.4.1 Integer Type
------------------

Under the hood, there are two kinds of integers--small integers, called
"fixnums", and large integers, called "bignums".

   The range of values for a fixnum depends on the machine.  The minimum
range is -536,870,912 to 536,870,911 (30 bits; i.e., -2**29 to 2**29 -
1) but many machines provide a wider range.

   Bignums can have arbitrary precision.  Operations that overflow a
fixnum will return a bignum instead.

   All numbers can be compared with 'eql' or '='; fixnums can also be
compared with 'eq'.  To test whether an integer is a fixnum or a bignum,
you can compare it to 'most-negative-fixnum' and 'most-positive-fixnum',
or you can use the convenience predicates 'fixnump' and 'bignump' on any
object.

   The read syntax for integers is a sequence of (base ten) digits with
an optional sign at the beginning and an optional period at the end.
The printed representation produced by the Lisp interpreter never has a
leading '+' or a final '.'.

     -1               ; The integer -1.
     1                ; The integer 1.
     1.               ; Also the integer 1.
     +1               ; Also the integer 1.


   *Note Numbers::, for more information.

==============================================================================
File: elisp.info,  Node: |Floating_Point_Type|,  Next: |Character_Type|,  Prev: |Integer_Type|,  Up: |Programming_Types|
==============================================================================

                                                           *Floating_Point_Type*

2.4.2 Floating-Point Type
-------------------------

Floating-point numbers are the computer equivalent of scientific
notation; you can think of a floating-point number as a fraction
together with a power of ten.  The precise number of significant figures
and the range of possible exponents is machine-specific; Emacs uses the
C data type 'double' to store the value, and internally this records a
power of 2 rather than a power of 10.

   The printed representation for floating-point numbers requires either
a decimal point (with at least one digit following), an exponent, or
both.  For example, '1500.0', '+15e2', '15.0e+2', '+1500000e-3', and
'.15e4' are five ways of writing a floating-point number whose value is
1500.  They are all equivalent.

   *Note Numbers::, for more information.

==============================================================================
File: elisp.info,  Node: |Character_Type|,  Next: |Symbol_Type|,  Prev: |Floating_Point_Type|,  Up: |Programming_Types|
==============================================================================

                                                                *Character_Type*

2.4.3 Character Type
--------------------

A "character" in Emacs Lisp is nothing more than an integer.  In other
words, characters are represented by their character codes.  For
example, the character 'A' is represented as the integer 65.

   Individual characters are used occasionally in programs, but it is
more common to work with _strings_, which are sequences composed of
characters.  *Note String Type::.

   Characters in strings and buffers are currently limited to the range
of 0 to 4194303--twenty two bits (*note Character Codes::).  Codes 0
through 127 are ASCII codes; the rest are non-ASCII (*note Non-ASCII
Characters::).  Characters that represent keyboard input have a much
wider range, to encode modifier keys such as Control, Meta and Shift.

   There are special functions for producing a human-readable textual
description of a character for the sake of messages.  *Note Describing
Characters::.

MENU

* |Basic_Char_Syntax|::      Syntax for regular characters.
* |General_Escape_Syntax|::  How to specify characters by their codes.
* |Ctl_Char_Syntax|::        Syntax for control characters.
* |Meta_Char_Syntax|::       Syntax for meta-characters.
* |Other_Char_Bits|::        Syntax for hyper-, super-, and alt-characters.

==============================================================================
File: elisp.info,  Node: |Basic_Char_Syntax|,  Next: |General_Escape_Syntax|,  Up: |Character_Type|
==============================================================================

                                                             *Basic_Char_Syntax*

2.4.3.1 Basic Char Syntax
-------------------------

Since characters are really integers, the printed representation of a
character is a decimal number.  This is also a possible read syntax for
a character, but writing characters that way in Lisp programs is not
clear programming.  You should _always_ use the special read syntax
formats that Emacs Lisp provides for characters.  These syntax formats
start with a question mark.

   The usual read syntax for alphanumeric characters is a question mark
followed by the character; thus, '?A' for the character 'A', '?B' for
the character 'B', and '?a' for the character 'a'.

   For example:

     ?Q => 81     ?q => 113

   You can use the same syntax for punctuation characters.  However, if
the punctuation character has a special syntactic meaning in Lisp, you
must quote it with a '\'.  For example, '?\(' is the way to write the
open-paren character.  Likewise, if the character is '\', you must use a
second '\' to quote it: '?\\'.

   You can express the characters control-g, backspace, tab, newline,
vertical tab, formfeed, space, return, del, and escape as '?\a', '?\b',
'?\t', '?\n', '?\v', '?\f', '?\s', '?\r', '?\d', and '?\e',
respectively.  ('?\s' followed by a dash has a different meaning--it
applies the Super modifier to the following character.)  Thus,

     ?\a => 7                 ; control-g, 'C-g'
     ?\b => 8                 ; backspace, <BS>, 'C-h'
     ?\t => 9                 ; tab, <TAB>, 'C-i'
     ?\n => 10                ; newline, 'C-j'
     ?\v => 11                ; vertical tab, 'C-k'
     ?\f => 12                ; formfeed character, 'C-l'
     ?\r => 13                ; carriage return, <RET>, 'C-m'
     ?\e => 27                ; escape character, <ESC>, 'C-['
     ?\s => 32                ; space character, <SPC>
     ?\\ => 92                ; backslash character, '\'
     ?\d => 127               ; delete character, <DEL>

   These sequences which start with backslash are also known as "escape
sequences", because backslash plays the role of an escape character;
this has nothing to do with the character <ESC>.  '\s' is meant for use
in character constants; in string constants, just write the space.

   A backslash is allowed, and harmless, preceding any character without
a special escape meaning; thus, '?\+' is equivalent to '?+'.  There is
no reason to add a backslash before most characters.  However, you must
add a backslash before any of the characters '()[]\;"', and you should
add a backslash before any of the characters '|'`#.,' to avoid confusing
the Emacs commands for editing Lisp code.  You should also add a
backslash before Unicode characters which resemble the previously
mentioned ASCII ones, to avoid confusing people reading your code.
Emacs will highlight some non-escaped commonly confused characters such
as ''' to encourage this.  You can also add a backslash before
whitespace characters such as space, tab, newline and formfeed.
However, it is cleaner to use one of the easily readable escape
sequences, such as '\t' or '\s', instead of an actual whitespace
character such as a tab or a space.  (If you do write backslash followed
by a space, you should write an extra space after the character constant
to separate it from the following text.)

==============================================================================
File: elisp.info,  Node: |General_Escape_Syntax|,  Next: |Ctl_Char_Syntax|,  Prev: |Basic_Char_Syntax|,  Up: |Character_Type|
==============================================================================

                                                         *General_Escape_Syntax*

2.4.3.2 General Escape Syntax
-----------------------------

In addition to the specific escape sequences for special important
control characters, Emacs provides several types of escape syntax that
you can use to specify non-ASCII text characters.

  1. You can specify characters by their Unicode names, if any.
     '?\N{NAME}' represents the Unicode character named NAME.  Thus,
     '?\N{LATIN SMALL LETTER A WITH GRAVE}' is equivalent to '?a`' and
     denotes the Unicode character U+00E0.  To simplify entering
     multi-line strings, you can replace spaces in the names by
     non-empty sequences of whitespace (e.g., newlines).

  2. You can specify characters by their Unicode values.  '?\N{U+X}'
     represents a character with Unicode code point X, where X is a
     hexadecimal number.  Also, '?\uXXXX' and '?\UXXXXXXXX' represent
     code points XXXX and XXXXXXXX, respectively, where each X is a
     single hexadecimal digit.  For example, '?\N{U+E0}', '?\u00e0' and
     '?\U000000E0' are all equivalent to '?a`' and to '?\N{LATIN SMALL
     LETTER A WITH GRAVE}'.  The Unicode Standard defines code points
     only up to 'U+10FFFF', so if you specify a code point higher than
     that, Emacs signals an error.

  3. You can specify characters by their hexadecimal character codes.  A
     hexadecimal escape sequence consists of a backslash, 'x', and the
     hexadecimal character code.  Thus, '?\x41' is the character 'A',
     '?\x1' is the character 'C-a', and '?\xe0' is the character 'a`'
     ('a' with grave accent).  You can use any number of hex digits, so
     you can represent any character code in this way.

  4. You can specify characters by their character code in octal.  An
     octal escape sequence consists of a backslash followed by up to
     three octal digits; thus, '?\101' for the character 'A', '?\001'
     for the character 'C-a', and '?\002' for the character 'C-b'.  Only
     characters up to octal code 777 can be specified this way.

   These escape sequences may also be used in strings.  *Note Non-ASCII
in Strings::.

==============================================================================
File: elisp.info,  Node: |Ctl_Char_Syntax|,  Next: |Meta_Char_Syntax|,  Prev: |General_Escape_Syntax|,  Up: |Character_Type|
==============================================================================

                                                               *Ctl_Char_Syntax*

2.4.3.3 Control-Character Syntax
--------------------------------

Control characters can be represented using yet another read syntax.
This consists of a question mark followed by a backslash, caret, and the
corresponding non-control character, in either upper or lower case.  For
example, both '?\^I' and '?\^i' are valid read syntax for the character
'C-i', the character whose value is 9.

   Instead of the '^', you can use 'C-'; thus, '?\C-i' is equivalent to
'?\^I' and to '?\^i':

     ?\^I => 9     ?\C-I => 9

   In strings and buffers, the only control characters allowed are those
that exist in ASCII; but for keyboard input purposes, you can turn any
character into a control character with 'C-'.  The character codes for
these non-ASCII control characters include the 2**26 bit as well as the
code for the corresponding non-control character.  Ordinary text
terminals have no way of generating non-ASCII control characters, but
you can generate them straightforwardly using X and other window
systems.

   For historical reasons, Emacs treats the <DEL> character as the
control equivalent of '?':

     ?\^? => 127     ?\C-? => 127

As a result, it is currently not possible to represent the character
'Control-?', which is a meaningful input character under X, using '\C-'.
It is not easy to change this, as various Lisp files refer to <DEL> in
this way.

   For representing control characters to be found in files or strings,
we recommend the '^' syntax; for control characters in keyboard input,
we prefer the 'C-' syntax.  Which one you use does not affect the
meaning of the program, but may guide the understanding of people who
read it.

==============================================================================
File: elisp.info,  Node: |Meta_Char_Syntax|,  Next: |Other_Char_Bits|,  Prev: |Ctl_Char_Syntax|,  Up: |Character_Type|
==============================================================================

                                                              *Meta_Char_Syntax*

2.4.3.4 Meta-Character Syntax
-----------------------------

A "meta character" is a character typed with the <META> modifier key.
The integer that represents such a character has the 2**27 bit set.  We
use high bits for this and other modifiers to make possible a wide range
of basic character codes.

   In a string, the 2**7 bit attached to an ASCII character indicates a
meta character; thus, the meta characters that can fit in a string have
codes in the range from 128 to 255, and are the meta versions of the
ordinary ASCII characters.  *Note Strings of Events::, for details about
<META>-handling in strings.

   The read syntax for meta characters uses '\M-'.  For example, '?\M-A'
stands for 'M-A'.  You can use '\M-' together with octal character codes
(see below), with '\C-', or with any other syntax for a character.
Thus, you can write 'M-A' as '?\M-A', or as '?\M-\101'.  Likewise, you
can write 'C-M-b' as '?\M-\C-b', '?\C-\M-b', or '?\M-\002'.

==============================================================================
File: elisp.info,  Node: |Other_Char_Bits|,  Prev: |Meta_Char_Syntax|,  Up: |Character_Type|
==============================================================================

                                                               *Other_Char_Bits*

2.4.3.5 Other Character Modifier Bits
-------------------------------------

The case of a graphic character is indicated by its character code; for
example, ASCII distinguishes between the characters 'a' and 'A'.  But
ASCII has no way to represent whether a control character is upper case
or lower case.  Emacs uses the 2**25 bit to indicate that the shift key
was used in typing a control character.  This distinction is possible
only when you use X terminals or other special terminals; ordinary text
terminals do not report the distinction.  The Lisp syntax for the shift
bit is '\S-'; thus, '?\C-\S-o' or '?\C-\S-O' represents the
shifted-control-o character.

   The X Window System defines three other modifier bits that can be set
in a character: "hyper", "super" and "alt".  The syntaxes for these bits
are '\H-', '\s-' and '\A-'.  (Case is significant in these prefixes.)
Thus, '?\H-\M-\A-x' represents 'Alt-Hyper-Meta-x'.  (Note that '\s' with
no following '-' represents the space character.)  Numerically, the bit
values are 2**22 for alt, 2**23 for super and 2**24 for hyper.

==============================================================================
File: elisp.info,  Node: |Symbol_Type|,  Next: |Sequence_Type|,  Prev: |Character_Type|,  Up: |Programming_Types|
==============================================================================

                                                                   *Symbol_Type*

2.4.4 Symbol Type
-----------------

A "symbol" in GNU Emacs Lisp is an object with a name.  The symbol name
serves as the printed representation of the symbol.  In ordinary Lisp
use, with one single obarray (*note Creating Symbols::), a symbol's name
is unique--no two symbols have the same name.

   A symbol can serve as a variable, as a function name, or to hold a
property list.  Or it may serve only to be distinct from all other Lisp
objects, so that its presence in a data structure may be recognized
reliably.  In a given context, usually only one of these uses is
intended.  But you can use one symbol in all of these ways,
independently.

   A symbol whose name starts with a colon (':') is called a "keyword
symbol".  These symbols automatically act as constants, and are normally
used only by comparing an unknown symbol with a few specific
alternatives.  *Note Constant Variables::.

   A symbol name can contain any characters whatever.  Most symbol names
are written with letters, digits, and the punctuation characters
'-+=*/'.  Such names require no special punctuation; the characters of
the name suffice as long as the name does not look like a number.  (If
it does, write a '\' at the beginning of the name to force
interpretation as a symbol.)  The characters '_~!@$%^&:<>{}?' are less
often used but also require no special punctuation.  Any other
characters may be included in a symbol's name by escaping them with a
backslash.  In contrast to its use in strings, however, a backslash in
the name of a symbol simply quotes the single character that follows the
backslash.  For example, in a string, '\t' represents a tab character;
in the name of a symbol, however, '\t' merely quotes the letter 't'.  To
have a symbol with a tab character in its name, you must actually use a
tab (preceded with a backslash).  But it's rare to do such a thing.

     Common Lisp note: In Common Lisp, lower case letters are always
     folded to upper case, unless they are explicitly escaped.  In Emacs
     Lisp, upper case and lower case letters are distinct.

   Here are several examples of symbol names.  Note that the '+' in the
fourth example is escaped to prevent it from being read as a number.
This is not necessary in the sixth example because the rest of the name
makes it invalid as a number.

     foo                 ; A symbol named 'foo'.
     FOO                 ; A symbol named 'FOO', different from 'foo'.
     1+                  ; A symbol named '1+'
                         ;   (not '+1', which is an integer).
     \+1                 ; A symbol named '+1'
                         ;   (not a very readable name).
     \(*\ 1\ 2\)         ; A symbol named '(* 1 2)' (a worse name).
     +-*/_~!@$%^&=:<>{}  ; A symbol named '+-*/_~!@$%^&=:<>{}'.
                         ;   These characters need not be escaped.

   As an exception to the rule that a symbol's name serves as its
printed representation, '##' is the printed representation for an
interned symbol whose name is an empty string.  Furthermore, '#:FOO' is
the printed representation for an uninterned symbol whose name is FOO.
(Normally, the Lisp reader interns all symbols; *note Creating
Symbols::.)

==============================================================================
File: elisp.info,  Node: |Sequence_Type|,  Next: |Cons_Cell_Type|,  Prev: |Symbol_Type|,  Up: |Programming_Types|
==============================================================================

                                                                 *Sequence_Type*

2.4.5 Sequence Types
--------------------

A "sequence" is a Lisp object that represents an ordered set of
elements.  There are two kinds of sequence in Emacs Lisp: "lists" and
"arrays".

   Lists are the most commonly-used sequences.  A list can hold elements
of any type, and its length can be easily changed by adding or removing
elements.  See the next subsection for more about lists.

   Arrays are fixed-length sequences.  They are further subdivided into
strings, vectors, char-tables and bool-vectors.  Vectors can hold
elements of any type, whereas string elements must be characters, and
bool-vector elements must be 't' or 'nil'.  Char-tables are like vectors
except that they are indexed by any valid character code.  The
characters in a string can have text properties like characters in a
buffer (*note Text Properties::), but vectors do not support text
properties, even when their elements happen to be characters.

   Lists, strings and the other array types also share important
similarities.  For example, all have a length L, and all have elements
which can be indexed from zero to L minus one.  Several functions,
called sequence functions, accept any kind of sequence.  For example,
the function 'length' reports the length of any kind of sequence.  *Note
Sequences Arrays Vectors::.

   It is generally impossible to read the same sequence twice, since
sequences are always created anew upon reading.  If you read the read
syntax for a sequence twice, you get two sequences with equal contents.
There is one exception: the empty list '()' always stands for the same
object, 'nil'.

==============================================================================
File: elisp.info,  Node: |Cons_Cell_Type|,  Next: |Array_Type|,  Prev: |Sequence_Type|,  Up: |Programming_Types|
==============================================================================

                                                                *Cons_Cell_Type*

2.4.6 Cons Cell and List Types
------------------------------

A "cons cell" is an object that consists of two slots, called the CAR
slot and the CDR slot.  Each slot can "hold" any Lisp object.  We also
say that the CAR of this cons cell is whatever object its CAR slot
currently holds, and likewise for the CDR.

   A "list" is a series of cons cells, linked together so that the CDR
slot of each cons cell holds either the next cons cell or the empty
list.  The empty list is actually the symbol 'nil'.  *Note Lists::, for
details.  Because most cons cells are used as part of lists, we refer to
any structure made out of cons cells as a "list structure".

     A note to C programmers: a Lisp list thus works as a "linked list"
     built up of cons cells.  Because pointers in Lisp are implicit, we
     do not distinguish between a cons cell slot holding a value versus
     pointing to the value.

   Because cons cells are so central to Lisp, we also have a word for an
object which is not a cons cell.  These objects are called "atoms".

   The read syntax and printed representation for lists are identical,
and consist of a left parenthesis, an arbitrary number of elements, and
a right parenthesis.  Here are examples of lists:

     (A 2 "A")            ; A list of three elements.
     ()                   ; A list of no elements (the empty list).
     nil                  ; A list of no elements (the empty list).
     ("A ()")             ; A list of one element: the string '"A ()"'.
     (A ())               ; A list of two elements: 'A' and the empty list.
     (A nil)              ; Equivalent to the previous.
     ((A B C))            ; A list of one element
                          ;   (which is a list of three elements).

   Upon reading, each object inside the parentheses becomes an element
of the list.  That is, a cons cell is made for each element.  The CAR
slot of the cons cell holds the element, and its CDR slot refers to the
next cons cell of the list, which holds the next element in the list.
The CDR slot of the last cons cell is set to hold 'nil'.

   The names CAR and CDR derive from the history of Lisp.  The original
Lisp implementation ran on an IBM 704 computer which divided words into
two parts, the address and the decrement; CAR was an instruction to
extract the contents of the address part of a register, and CDR an
instruction to extract the contents of the decrement.  By contrast, cons
cells are named for the function 'cons' that creates them, which in turn
was named for its purpose, the construction of cells.

MENU

* |Box_Diagrams|::                Drawing pictures of lists.
* |Dotted_Pair_Notation|::        A general syntax for cons cells.
* |Association_List_Type|::       A specially constructed list.

==============================================================================
File: elisp.info,  Node: |Box_Diagrams|,  Next: |Dotted_Pair_Notation|,  Up: |Cons_Cell_Type|
==============================================================================

                                                                  *Box_Diagrams*

2.4.6.1 Drawing Lists as Box Diagrams
-------------------------------------

A list can be illustrated by a diagram in which the cons cells are shown
as pairs of boxes, like dominoes.  (The Lisp reader cannot read such an
illustration; unlike the textual notation, which can be understood by
both humans and computers, the box illustrations can be understood only
by humans.)  This picture represents the three-element list '(rose
violet buttercup)':

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

   In this diagram, each box represents a slot that can hold or refer to
any Lisp object.  Each pair of boxes represents a cons cell.  Each arrow
represents a reference to a Lisp object, either an atom or another cons
cell.

   In this example, the first box, which holds the CAR of the first cons
cell, refers to or holds 'rose' (a symbol).  The second box, holding the
CDR of the first cons cell, refers to the next pair of boxes, the second
cons cell.  The CAR of the second cons cell is 'violet', and its CDR is
the third cons cell.  The CDR of the third (and last) cons cell is
'nil'.

   Here is another diagram of the same list, '(rose violet buttercup)',
sketched in a different manner:

      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------

   A list with no elements in it is the "empty list"; it is identical to
the symbol 'nil'.  In other words, 'nil' is both a symbol and a list.

   Here is the list '(A ())', or equivalently '(A nil)', depicted with
boxes and arrows:

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> A        --> nil

   Here is a more complex illustration, showing the three-element list,
'((pine needles) oak maple)', the first element of which is a
two-element list:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --> oak      --> maple
          |
          |     --- ---      --- ---
           --> |   |   |--> |   |   |--> nil
                --- ---      --- ---
                 |            |
                 |            |
                  --> pine     --> needles

   The same list represented in the second box notation looks like this:

      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   o   |   o------->| oak   |   o------->| maple |  nil |
     |   |   |      |     |       |      |     |       |      |
      -- | ---------       --------------       --------------
         |
         |
         |        --------------       ----------------
         |       | car   | cdr  |     | car     | cdr  |
          ------>| pine  |   o------->| needles |  nil |
                 |       |      |     |         |      |
                  --------------       ----------------

==============================================================================
File: elisp.info,  Node: |Dotted_Pair_Notation|,  Next: |Association_List_Type|,  Prev: |Box_Diagrams|,  Up: |Cons_Cell_Type|
==============================================================================

                                                          *Dotted_Pair_Notation*

2.4.6.2 Dotted Pair Notation
----------------------------

"Dotted pair notation" is a general syntax for cons cells that
represents the CAR and CDR explicitly.  In this syntax, '(A . B)' stands
for a cons cell whose CAR is the object A and whose CDR is the object B.
Dotted pair notation is more general than list syntax because the CDR
does not have to be a list.  However, it is more cumbersome in cases
where list syntax would work.  In dotted pair notation, the list '(1 2
3)' is written as '(1 . (2 . (3 . nil)))'.  For 'nil'-terminated lists,
you can use either notation, but list notation is usually clearer and
more convenient.  When printing a list, the dotted pair notation is only
used if the CDR of a cons cell is not a list.

   Here's an example using boxes to illustrate dotted pair notation.
This example shows the pair '(rose . violet)':

         --- ---
        |   |   |--> violet
         --- ---
          |
          |
           --> rose

   You can combine dotted pair notation with list notation to represent
conveniently a chain of cons cells with a non-'nil' final CDR.  You
write a dot after the last element of the list, followed by the CDR of
the final cons cell.  For example, '(rose violet . buttercup)' is
equivalent to '(rose . (violet . buttercup))'.  The object looks like
this:

         --- ---      --- ---
        |   |   |--> |   |   |--> buttercup
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   The syntax '(rose . violet . buttercup)' is invalid because there is
nothing that it could mean.  If anything, it would say to put
'buttercup' in the CDR of a cons cell whose CDR is already used for
'violet'.

   The list '(rose violet)' is equivalent to '(rose . (violet))', and
looks like this:

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   Similarly, the three-element list '(rose violet buttercup)' is
equivalent to '(rose . (violet . (buttercup)))'.  It looks like this:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

==============================================================================
File: elisp.info,  Node: |Association_List_Type|,  Prev: |Dotted_Pair_Notation|,  Up: |Cons_Cell_Type|
==============================================================================

                                                         *Association_List_Type*

2.4.6.3 Association List Type
-----------------------------

An "association list" or "alist" is a specially-constructed list whose
elements are cons cells.  In each element, the CAR is considered a
"key", and the CDR is considered an "associated value".  (In some cases,
the associated value is stored in the CAR of the CDR.)  Association
lists are often used as stacks, since it is easy to add or remove
associations at the front of the list.

   For example,

     (setq alist-of-colors
           '((rose . red) (lily . white) (buttercup . yellow)))

sets the variable 'alist-of-colors' to an alist of three elements.  In
the first element, 'rose' is the key and 'red' is the value.

   *Note Association Lists::, for a further explanation of alists and
for functions that work on alists.  *Note Hash Tables::, for another
kind of lookup table, which is much faster for handling a large number
of keys.

==============================================================================
File: elisp.info,  Node: |Array_Type|,  Next: |String_Type|,  Prev: |Cons_Cell_Type|,  Up: |Programming_Types|
==============================================================================

                                                                    *Array_Type*

2.4.7 Array Type
----------------

An "array" is composed of an arbitrary number of slots for holding or
referring to other Lisp objects, arranged in a contiguous block of
memory.  Accessing any element of an array takes approximately the same
amount of time.  In contrast, accessing an element of a list requires
time proportional to the position of the element in the list.  (Elements
at the end of a list take longer to access than elements at the
beginning of a list.)

   Emacs defines four types of array: strings, vectors, bool-vectors,
and char-tables.

   A string is an array of characters and a vector is an array of
arbitrary objects.  A bool-vector can hold only 't' or 'nil'.  These
kinds of array may have any length up to the largest fixnum, subject to
system architecture limits and available memory.  Char-tables are sparse
arrays indexed by any valid character code; they can hold arbitrary
objects.

   The first element of an array has index zero, the second element has
index 1, and so on.  This is called "zero-origin" indexing.  For
example, an array of four elements has indices 0, 1, 2, and 3.  The
largest possible index value is one less than the length of the array.
Once an array is created, its length is fixed.

   All Emacs Lisp arrays are one-dimensional.  (Most other programming
languages support multidimensional arrays, but they are not essential;
you can get the same effect with nested one-dimensional arrays.)  Each
type of array has its own read syntax; see the following sections for
details.

   The array type is a subset of the sequence type, and contains the
string type, the vector type, the bool-vector type, and the char-table
type.

==============================================================================
File: elisp.info,  Node: |String_Type|,  Next: |Vector_Type|,  Prev: |Array_Type|,  Up: |Programming_Types|
==============================================================================

                                                                   *String_Type*

2.4.8 String Type
-----------------

A "string" is an array of characters.  Strings are used for many
purposes in Emacs, as can be expected in a text editor; for example, as
the names of Lisp symbols, as messages for the user, and to represent
text extracted from buffers.  Strings in Lisp are constants: evaluation
of a string returns the same string.

   *Note Strings and Characters::, for functions that operate on
strings.

MENU

* |Syntax_for_Strings|::      How to specify Lisp strings.
* |Non_ASCII_in_Strings|::    International characters in strings.
* |Nonprinting_Characters|::  Literal unprintable characters in strings.
* |Text_Props_and_Strings|::  Strings with text properties.

==============================================================================
File: elisp.info,  Node: |Syntax_for_Strings|,  Next: |Non_ASCII_in_Strings|,  Up: |String_Type|
==============================================================================

                                                            *Syntax_for_Strings*

2.4.8.1 Syntax for Strings
--------------------------

The read syntax for a string is a double-quote, an arbitrary number of
characters, and another double-quote, '"like this"'.  To include a
double-quote in a string, precede it with a backslash; thus, '"\""' is a
string containing just one double-quote character.  Likewise, you can
include a backslash by preceding it with another backslash, like this:
'"this \\ is a single embedded backslash"'.

   The newline character is not special in the read syntax for strings;
if you write a new line between the double-quotes, it becomes a
character in the string.  But an escaped newline--one that is preceded by
'\'--does not become part of the string; i.e., the Lisp reader ignores an
escaped newline while reading a string.  An escaped space '\ ' is
likewise ignored.

     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          => "It is useful to include newlines
     in documentation strings,
     but the newline is ignored if escaped."

==============================================================================
File: elisp.info,  Node: |Non_ASCII_in_Strings|,  Next: |Nonprinting_Characters|,  Prev: |Syntax_for_Strings|,  Up: |String_Type|
==============================================================================

                                                          *Non_ASCII_in_Strings*

2.4.8.2 Non-ASCII Characters in Strings
---------------------------------------

There are two text representations for non-ASCII characters in Emacs
strings: multibyte and unibyte (*note Text Representations::).  Roughly
speaking, unibyte strings store raw bytes, while multibyte strings store
human-readable text.  Each character in a unibyte string is a byte,
i.e., its value is between 0 and 255.  By contrast, each character in a
multibyte string may have a value between 0 to 4194303 (*note Character
Type::).  In both cases, characters above 127 are non-ASCII.

   You can include a non-ASCII character in a string constant by writing
it literally.  If the string constant is read from a multibyte source,
such as a multibyte buffer or string, or a file that would be visited as
multibyte, then Emacs reads each non-ASCII character as a multibyte
character and automatically makes the string a multibyte string.  If the
string constant is read from a unibyte source, then Emacs reads the
non-ASCII character as unibyte, and makes the string unibyte.

   Instead of writing a character literally into a multibyte string, you
can write it as its character code using an escape sequence.  *Note
General Escape Syntax::, for details about escape sequences.

   If you use any Unicode-style escape sequence '\uNNNN' or '\U00NNNNNN'
in a string constant (even for an ASCII character), Emacs automatically
assumes that it is multibyte.

   You can also use hexadecimal escape sequences ('\xN') and octal
escape sequences ('\N') in string constants.  *But beware:* If a string
constant contains hexadecimal or octal escape sequences, and these
escape sequences all specify unibyte characters (i.e., less than 256),
and there are no other literal non-ASCII characters or Unicode-style
escape sequences in the string, then Emacs automatically assumes that it
is a unibyte string.  That is to say, it assumes that all non-ASCII
characters occurring in the string are 8-bit raw bytes.

   In hexadecimal and octal escape sequences, the escaped character code
may contain a variable number of digits, so the first subsequent
character which is not a valid hexadecimal or octal digit terminates the
escape sequence.  If the next character in a string could be interpreted
as a hexadecimal or octal digit, write '\ ' (backslash and space) to
terminate the escape sequence.  For example, '\xe0\ ' represents one
character, 'a' with grave accent.  '\ ' in a string constant is just
like backslash-newline; it does not contribute any character to the
string, but it does terminate any preceding hex escape.

==============================================================================
File: elisp.info,  Node: |Nonprinting_Characters|,  Next: |Text_Props_and_Strings|,  Prev: |Non_ASCII_in_Strings|,  Up: |String_Type|
==============================================================================

                                                        *Nonprinting_Characters*

2.4.8.3 Nonprinting Characters in Strings
-----------------------------------------

You can use the same backslash escape-sequences in a string constant as
in character literals (but do not use the question mark that begins a
character constant).  For example, you can write a string containing the
nonprinting characters tab and 'C-a', with commas and spaces between
them, like this: '"\t, \C-a"'.  *Note Character Type::, for a
description of the read syntax for characters.

   However, not all of the characters you can write with backslash
escape-sequences are valid in strings.  The only control characters that
a string can hold are the ASCII control characters.  Strings do not
distinguish case in ASCII control characters.

   Properly speaking, strings cannot hold meta characters; but when a
string is to be used as a key sequence, there is a special convention
that provides a way to represent meta versions of ASCII characters in a
string.  If you use the '\M-' syntax to indicate a meta character in a
string constant, this sets the 2**7 bit of the character in the string.
If the string is used in 'define-key' or 'lookup-key', this numeric code
is translated into the equivalent meta character.  *Note Character
Type::.

   Strings cannot hold characters that have the hyper, super, or alt
modifiers.

==============================================================================
File: elisp.info,  Node: |Text_Props_and_Strings|,  Prev: |Nonprinting_Characters|,  Up: |String_Type|
==============================================================================

                                                        *Text_Props_and_Strings*

2.4.8.4 Text Properties in Strings
----------------------------------

A string can hold properties for the characters it contains, in addition
to the characters themselves.  This enables programs that copy text
between strings and buffers to copy the text's properties with no
special effort.  *Note Text Properties::, for an explanation of what
text properties mean.  Strings with text properties use a special read
and print syntax:

     #("CHARACTERS" PROPERTY-DATA...)

where PROPERTY-DATA consists of zero or more elements, in groups of
three as follows:

     BEG END PLIST

The elements BEG and END are integers, and together specify a range of
indices in the string; PLIST is the property list for that range.  For
example,

     #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))

represents a string whose textual contents are 'foo bar', in which the
first three characters have a 'face' property with value 'bold', and the
last three have a 'face' property with value 'italic'.  (The fourth
character has no text properties, so its property list is 'nil'.  It is
not actually necessary to mention ranges with 'nil' as the property
list, since any characters not mentioned in any range will default to
having no properties.)

==============================================================================
File: elisp.info,  Node: |Vector_Type|,  Next: |Char_Table_Type|,  Prev: |String_Type|,  Up: |Programming_Types|
==============================================================================

                                                                   *Vector_Type*

2.4.9 Vector Type
-----------------

A "vector" is a one-dimensional array of elements of any type.  It takes
a constant amount of time to access any element of a vector.  (In a
list, the access time of an element is proportional to the distance of
the element from the beginning of the list.)

   The printed representation of a vector consists of a left square
bracket, the elements, and a right square bracket.  This is also the
read syntax.  Like numbers and strings, vectors are considered constants
for evaluation.

     [1 "two" (three)]      ; A vector of three elements.
          => [1 "two" (three)]

   *Note Vectors::, for functions that work with vectors.

==============================================================================
File: elisp.info,  Node: |Char_Table_Type|,  Next: |Bool_Vector_Type|,  Prev: |Vector_Type|,  Up: |Programming_Types|
==============================================================================

                                                               *Char_Table_Type*

2.4.10 Char-Table Type
----------------------

A "char-table" is a one-dimensional array of elements of any type,
indexed by character codes.  Char-tables have certain extra features to
make them more useful for many jobs that involve assigning information
to character codes--for example, a char-table can have a parent to
inherit from, a default value, and a small number of extra slots to use
for special purposes.  A char-table can also specify a single value for
a whole character set.

   The printed representation of a char-table is like a vector except
that there is an extra '#^' at the beginning.(1)

   *Note Char-Tables::, for special functions to operate on char-tables.
Uses of char-tables include:

   * Case tables (*note Case Tables::).

   * Character category tables (*note Categories::).

   * Display tables (*note Display Tables::).

   * Syntax tables (*note Syntax Tables::).

   ---------- Footnotes ----------

   (1) You may also encounter '#^^', used for sub-char-tables.

==============================================================================
File: elisp.info,  Node: |Bool_Vector_Type|,  Next: |Hash_Table_Type|,  Prev: |Char_Table_Type|,  Up: |Programming_Types|
==============================================================================

                                                              *Bool_Vector_Type*

2.4.11 Bool-Vector Type
-----------------------

A "bool-vector" is a one-dimensional array whose elements must be 't' or
'nil'.

   The printed representation of a bool-vector is like a string, except
that it begins with '#&' followed by the length.  The string constant
that follows actually specifies the contents of the bool-vector as a
bitmap--each character in the string contains 8 bits, which specify the
next 8 elements of the bool-vector (1 stands for 't', and 0 for 'nil').
The least significant bits of the character correspond to the lowest
indices in the bool-vector.

     (make-bool-vector 3 t)
          => #&3"^G"
     (make-bool-vector 3 nil)
          => #&3"^@"

These results make sense, because the binary code for 'C-g' is 111 and
'C-@' is the character with code 0.

   If the length is not a multiple of 8, the printed representation
shows extra elements, but these extras really make no difference.  For
instance, in the next example, the two bool-vectors are equal, because
only the first 3 bits are used:

     (equal #&3"\377" #&3"\007")
          => t

==============================================================================
File: elisp.info,  Node: |Hash_Table_Type|,  Next: |Function_Type|,  Prev: |Bool_Vector_Type|,  Up: |Programming_Types|
==============================================================================

                                                               *Hash_Table_Type*

2.4.12 Hash Table Type
----------------------

A hash table is a very fast kind of lookup table, somewhat like an alist
in that it maps keys to corresponding values, but much faster.  The
printed representation of a hash table specifies its properties and
contents, like this:

     (make-hash-table)
          => #s(hash-table size 65 test eql rehash-size 1.5
                                  rehash-threshold 0.8125 data ())

*Note Hash Tables::, for more information about hash tables.

==============================================================================
File: elisp.info,  Node: |Function_Type|,  Next: |Macro_Type|,  Prev: |Hash_Table_Type|,  Up: |Programming_Types|
==============================================================================

                                                                 *Function_Type*

2.4.13 Function Type
--------------------

Lisp functions are executable code, just like functions in other
programming languages.  In Lisp, unlike most languages, functions are
also Lisp objects.  A non-compiled function in Lisp is a lambda
expression: that is, a list whose first element is the symbol 'lambda'
(*note Lambda Expressions::).

   In most programming languages, it is impossible to have a function
without a name.  In Lisp, a function has no intrinsic name.  A lambda
expression can be called as a function even though it has no name; to
emphasize this, we also call it an "anonymous function" (*note Anonymous
Functions::).  A named function in Lisp is just a symbol with a valid
function in its function cell (*note Defining Functions::).

   Most of the time, functions are called when their names are written
in Lisp expressions in Lisp programs.  However, you can construct or
obtain a function object at run time and then call it with the primitive
functions 'funcall' and 'apply'.  *Note Calling Functions::.

==============================================================================
File: elisp.info,  Node: |Macro_Type|,  Next: |Primitive_Function_Type|,  Prev: |Function_Type|,  Up: |Programming_Types|
==============================================================================

                                                                    *Macro_Type*

2.4.14 Macro Type
-----------------

A "Lisp macro" is a user-defined construct that extends the Lisp
language.  It is represented as an object much like a function, but with
different argument-passing semantics.  A Lisp macro has the form of a
list whose first element is the symbol 'macro' and whose CDR is a Lisp
function object, including the 'lambda' symbol.

   Lisp macro objects are usually defined with the built-in 'defmacro'
macro, but any list that begins with 'macro' is a macro as far as Emacs
is concerned.  *Note Macros::, for an explanation of how to write a
macro.

   Warning: Lisp macros and keyboard macros (*note Keyboard Macros::)
are entirely different things.  When we use the word "macro" without
qualification, we mean a Lisp macro, not a keyboard macro.

==============================================================================
File: elisp.info,  Node: |Primitive_Function_Type|,  Next: |Byte_Code_Type|,  Prev: |Macro_Type|,  Up: |Programming_Types|
==============================================================================

                                                       *Primitive_Function_Type*

2.4.15 Primitive Function Type
------------------------------

A "primitive function" is a function callable from Lisp but written in
the C programming language.  Primitive functions are also called "subrs"
or "built-in functions".  (The word "subr" is derived from
"subroutine".)  Most primitive functions evaluate all their arguments
when they are called.  A primitive function that does not evaluate all
its arguments is called a "special form" (*note Special Forms::).

   It does not matter to the caller of a function whether the function
is primitive.  However, this does matter if you try to redefine a
primitive with a function written in Lisp.  The reason is that the
primitive function may be called directly from C code.  Calls to the
redefined function from Lisp will use the new definition, but calls from
C code may still use the built-in definition.  Therefore, *we discourage
redefinition of primitive functions*.

   The term "function" refers to all Emacs functions, whether written in
Lisp or C.  *Note Function Type::, for information about the functions
written in Lisp.

   Primitive functions have no read syntax and print in hash notation
with the name of the subroutine.

     (symbol-function 'car)          ; Access the function cell
                                     ;   of the symbol.
          => #<subr car>
     (subrp (symbol-function 'car))  ; Is this a primitive function?
          => t                       ; Yes.

==============================================================================
File: elisp.info,  Node: |Byte_Code_Type|,  Next: |Record_Type|,  Prev: |Primitive_Function_Type|,  Up: |Programming_Types|
==============================================================================

                                                                *Byte_Code_Type*

2.4.16 Byte-Code Function Type
------------------------------

"Byte-code function objects" are produced by byte-compiling Lisp code
(*note Byte Compilation::).  Internally, a byte-code function object is
much like a vector; however, the evaluator handles this data type
specially when it appears in a function call.  *Note Byte-Code
Objects::.

   The printed representation and read syntax for a byte-code function
object is like that for a vector, with an additional '#' before the
opening '['.

==============================================================================
File: elisp.info,  Node: |Record_Type|,  Next: |Type_Descriptors|,  Prev: |Byte_Code_Type|,  Up: |Programming_Types|
==============================================================================

                                                                   *Record_Type*

2.4.17 Record Type
------------------

A "record" is much like a 'vector'.  However, the first element is used
to hold its type as returned by 'type-of'.  The purpose of records is to
allow programmers to create objects with new types that are not built
into Emacs.

   *Note Records::, for functions that work with records.

==============================================================================
File: elisp.info,  Node: |Type_Descriptors|,  Next: |Autoload_Type|,  Prev: |Record_Type|,  Up: |Programming_Types|
==============================================================================

                                                              *Type_Descriptors*

2.4.18 Type Descriptors
-----------------------

A "type descriptor" is a 'record' which holds information about a type.
Slot 1 in the record must be a symbol naming the type, and 'type-of'
relies on this to return the type of 'record' objects.  No other type
descriptor slot is used by Emacs; they are free for use by Lisp
extensions.

   An example of a type descriptor is any instance of
'cl-structure-class'.

==============================================================================
File: elisp.info,  Node: |Autoload_Type|,  Next: |Finalizer_Type|,  Prev: |Type_Descriptors|,  Up: |Programming_Types|
==============================================================================

                                                                 *Autoload_Type*

2.4.19 Autoload Type
--------------------

An "autoload object" is a list whose first element is the symbol
'autoload'.  It is stored as the function definition of a symbol, where
it serves as a placeholder for the real definition.  The autoload object
says that the real definition is found in a file of Lisp code that
should be loaded when necessary.  It contains the name of the file, plus
some other information about the real definition.

   After the file has been loaded, the symbol should have a new function
definition that is not an autoload object.  The new definition is then
called as if it had been there to begin with.  From the user's point of
view, the function call works as expected, using the function definition
in the loaded file.

   An autoload object is usually created with the function 'autoload',
which stores the object in the function cell of a symbol.  *Note
Autoload::, for more details.

==============================================================================
File: elisp.info,  Node: |Finalizer_Type|,  Prev: |Autoload_Type|,  Up: |Programming_Types|
==============================================================================

                                                                *Finalizer_Type*

2.4.20 Finalizer Type
---------------------

A "finalizer object" helps Lisp code clean up after objects that are no
longer needed.  A finalizer holds a Lisp function object.  When a
finalizer object becomes unreachable after a garbage collection pass,
Emacs calls the finalizer's associated function object.  When deciding
whether a finalizer is reachable, Emacs does not count references from
finalizer objects themselves, allowing you to use finalizers without
having to worry about accidentally capturing references to finalized
objects themselves.

   Errors in finalizers are printed to 'Messages'.  Emacs runs a given
finalizer object's associated function exactly once, even if that
function fails.

 -- Function: make-finalizer function
     Make a finalizer that will run FUNCTION.  FUNCTION will be called
     after garbage collection when the returned finalizer object becomes
     unreachable.  If the finalizer object is reachable only through
     references from finalizer objects, it does not count as reachable
     for the purpose of deciding whether to run FUNCTION.  FUNCTION will
     be run once per finalizer object.

==============================================================================
File: elisp.info,  Node: |Editing_Types|,  Next: |Circular_Objects|,  Prev: |Programming_Types|,  Up: |Lisp_Data_Types|
==============================================================================

                                                                 *Editing_Types*

2.5 Editing Types
-----------------

The types in the previous section are used for general programming
purposes, and most of them are common to most Lisp dialects.  Emacs Lisp
provides several additional data types for purposes connected with
editing.

MENU

* |Buffer_Type|::         The basic object of editing.
* |Marker_Type|::         A position in a buffer.
* |Window_Type|::         Buffers are displayed in windows.
* |Frame_Type|::          Windows subdivide frames.
* |Terminal_Type|::       A terminal device displays frames.
* |Window_Configuration_Type|::   Recording the way a frame is subdivided.
* |Frame_Configuration_Type|::    Recording the status of all frames.
* |Process_Type|::        A subprocess of Emacs running on the underlying OS.
* |Thread_Type|::         A thread of Emacs Lisp execution.
* |Mutex_Type|::          An exclusive lock for thread synchronization.
* |Condition_Variable_Type|::     Condition variable for thread synchronization.
* |Stream_Type|::         Receive or send characters.
* |Keymap_Type|::         What function a keystroke invokes.
* |Overlay_Type|::        How an overlay is represented.
* |Font_Type|::           Fonts for displaying text.

==============================================================================
File: elisp.info,  Node: |Buffer_Type|,  Next: |Marker_Type|,  Up: |Editing_Types|
==============================================================================

                                                                   *Buffer_Type*

2.5.1 Buffer Type
-----------------

A "buffer" is an object that holds text that can be edited (*note
Buffers::).  Most buffers hold the contents of a disk file (*note
Files::) so they can be edited, but some are used for other purposes.
Most buffers are also meant to be seen by the user, and therefore
displayed, at some time, in a window (*note Windows::).  But a buffer
need not be displayed in any window.  Each buffer has a designated
position called "point" (*note Positions::); most editing commands act
on the contents of the current buffer in the neighborhood of point.  At
any time, one buffer is the "current buffer".

   The contents of a buffer are much like a string, but buffers are not
used like strings in Emacs Lisp, and the available operations are
different.  For example, you can insert text efficiently into an
existing buffer, altering the buffer's contents, whereas inserting text
into a string requires concatenating substrings, and the result is an
entirely new string object.

   Many of the standard Emacs functions manipulate or test the
characters in the current buffer; a whole chapter in this manual is
devoted to describing these functions (*note Text::).

   Several other data structures are associated with each buffer:

   * a local syntax table (*note Syntax Tables::);

   * a local keymap (*note Keymaps::); and,

   * a list of buffer-local variable bindings (*note Buffer-Local
     Variables::).

   * overlays (*note Overlays::).

   * text properties for the text in the buffer (*note Text
     Properties::).

The local keymap and variable list contain entries that individually
override global bindings or values.  These are used to customize the
behavior of programs in different buffers, without actually changing the
programs.

   A buffer may be "indirect", which means it shares the text of another
buffer, but presents it differently.  *Note Indirect Buffers::.

   Buffers have no read syntax.  They print in hash notation, showing
the buffer name.

     (current-buffer)
          => #<buffer objects.texi>

==============================================================================
File: elisp.info,  Node: |Marker_Type|,  Next: |Window_Type|,  Prev: |Buffer_Type|,  Up: |Editing_Types|
==============================================================================

                                                                   *Marker_Type*

2.5.2 Marker Type
-----------------

A "marker" denotes a position in a specific buffer.  Markers therefore
have two components: one for the buffer, and one for the position.
Changes in the buffer's text automatically relocate the position value
as necessary to ensure that the marker always points between the same
two characters in the buffer.

   Markers have no read syntax.  They print in hash notation, giving the
current character position and the name of the buffer.

     (point-marker)
          => #<marker at 10779 in objects.texi>

   *Note Markers::, for information on how to test, create, copy, and
move markers.

==============================================================================
File: elisp.info,  Node: |Window_Type|,  Next: |Frame_Type|,  Prev: |Marker_Type|,  Up: |Editing_Types|
==============================================================================

                                                                   *Window_Type*

2.5.3 Window Type
-----------------

A "window" describes the portion of the terminal screen that Emacs uses
to display a buffer.  Every window has one associated buffer, whose
contents appear in the window.  By contrast, a given buffer may appear
in one window, no window, or several windows.

   Though many windows may exist simultaneously, at any time one window
is designated the "selected window".  This is the window where the
cursor is (usually) displayed when Emacs is ready for a command.  The
selected window usually displays the current buffer (*note Current
Buffer::), but this is not necessarily the case.

   Windows are grouped on the screen into frames; each window belongs to
one and only one frame.  *Note Frame Type::.

   Windows have no read syntax.  They print in hash notation, giving the
window number and the name of the buffer being displayed.  The window
numbers exist to identify windows uniquely, since the buffer displayed
in any given window can change frequently.

     (selected-window)
          => #<window 1 on objects.texi>

   *Note Windows::, for a description of the functions that work on
windows.

==============================================================================
File: elisp.info,  Node: |Frame_Type|,  Next: |Terminal_Type|,  Prev: |Window_Type|,  Up: |Editing_Types|
==============================================================================

                                                                    *Frame_Type*

2.5.4 Frame Type
----------------

A "frame" is a screen area that contains one or more Emacs windows; we
also use the term "frame" to refer to the Lisp object that Emacs uses to
refer to the screen area.

   Frames have no read syntax.  They print in hash notation, giving the
frame's title, plus its address in core (useful to identify the frame
uniquely).

     (selected-frame)
          => #<frame emacs@psilocin.gnu.org 0xdac80>

   *Note Frames::, for a description of the functions that work on
frames.

==============================================================================
File: elisp.info,  Node: |Terminal_Type|,  Next: |Window_Configuration_Type|,  Prev: |Frame_Type|,  Up: |Editing_Types|
==============================================================================

                                                                 *Terminal_Type*

2.5.5 Terminal Type
-------------------

A "terminal" is a device capable of displaying one or more Emacs frames
(*note Frame Type::).

   Terminals have no read syntax.  They print in hash notation giving
the terminal's ordinal number and its TTY device file name.

     (get-device-terminal nil)
          => #<terminal 1 on /dev/tty>

==============================================================================
File: elisp.info,  Node: |Window_Configuration_Type|,  Next: |Frame_Configuration_Type|,  Prev: |Terminal_Type|,  Up: |Editing_Types|
==============================================================================

                                                     *Window_Configuration_Type*

2.5.6 Window Configuration Type
-------------------------------

A "window configuration" stores information about the positions, sizes,
and contents of the windows in a frame, so you can recreate the same
arrangement of windows later.

   Window configurations do not have a read syntax; their print syntax
looks like '#<window-configuration>'.  *Note Window Configurations::,
for a description of several functions related to window configurations.

==============================================================================
File: elisp.info,  Node: |Frame_Configuration_Type|,  Next: |Process_Type|,  Prev: |Window_Configuration_Type|,  Up: |Editing_Types|
==============================================================================

                                                      *Frame_Configuration_Type*

2.5.7 Frame Configuration Type
------------------------------

A "frame configuration" stores information about the positions, sizes,
and contents of the windows in all frames.  It is not a primitive
type--it is actually a list whose CAR is 'frame-configuration' and whose
CDR is an alist.  Each alist element describes one frame, which appears
as the CAR of that element.

   *Note Frame Configurations::, for a description of several functions
related to frame configurations.

==============================================================================
File: elisp.info,  Node: |Process_Type|,  Next: |Thread_Type|,  Prev: |Frame_Configuration_Type|,  Up: |Editing_Types|
==============================================================================

                                                                  *Process_Type*

2.5.8 Process Type
------------------

The word "process" usually means a running program.  Emacs itself runs
in a process of this sort.  However, in Emacs Lisp, a process is a Lisp
object that designates a subprocess created by the Emacs process.
Programs such as shells, GDB, ftp, and compilers, running in
subprocesses of Emacs, extend the capabilities of Emacs.  An Emacs
subprocess takes textual input from Emacs and returns textual output to
Emacs for further manipulation.  Emacs can also send signals to the
subprocess.

   Process objects have no read syntax.  They print in hash notation,
giving the name of the process:

     (process-list)
          => (#<process shell>)

   *Note Processes::, for information about functions that create,
delete, return information about, send input or signals to, and receive
output from processes.

==============================================================================
File: elisp.info,  Node: |Thread_Type|,  Next: |Mutex_Type|,  Prev: |Process_Type|,  Up: |Editing_Types|
==============================================================================

                                                                   *Thread_Type*

2.5.9 Thread Type
-----------------

A "thread" in Emacs represents a separate thread of Emacs Lisp
execution.  It runs its own Lisp program, has its own current buffer,
and can have subprocesses locked to it, i.e. subprocesses whose output
only this thread can accept.  *Note Threads::.

   Thread objects have no read syntax.  They print in hash notation,
giving the name of the thread (if it has been given a name) or its
address in core:

     (all-threads)
         => (#<thread 0176fc40>)

==============================================================================
File: elisp.info,  Node: |Mutex_Type|,  Next: |Condition_Variable_Type|,  Prev: |Thread_Type|,  Up: |Editing_Types|
==============================================================================

                                                                    *Mutex_Type*

2.5.10 Mutex Type
-----------------

A "mutex" is an exclusive lock that threads can own and disown, in order
to synchronize between them.  *Note Mutexes::.

   Mutex objects have no read syntax.  They print in hash notation,
giving the name of the mutex (if it has been given a name) or its
address in core:

     (make-mutex "my-mutex")
         => #<mutex my-mutex>
     (make-mutex)
         => #<mutex 01c7e4e0>

==============================================================================
File: elisp.info,  Node: |Condition_Variable_Type|,  Next: |Stream_Type|,  Prev: |Mutex_Type|,  Up: |Editing_Types|
==============================================================================

                                                       *Condition_Variable_Type*

2.5.11 Condition Variable Type
------------------------------

A "condition variable" is a device for a more complex thread
synchronization than the one supported by a mutex.  A thread can wait on
a condition variable, to be woken up when some other thread notifies the
condition.

   Condition variable objects have no read syntax.  They print in hash
notation, giving the name of the condition variable (if it has been
given a name) or its address in core:

     (make-condition-variable (make-mutex))
         => #<condvar 01c45ae8>

==============================================================================
File: elisp.info,  Node: |Stream_Type|,  Next: |Keymap_Type|,  Prev: |Condition_Variable_Type|,  Up: |Editing_Types|
==============================================================================

                                                                   *Stream_Type*

2.5.12 Stream Type
------------------

A "stream" is an object that can be used as a source or sink for
characters--either to supply characters for input or to accept them as
output.  Many different types can be used this way: markers, buffers,
strings, and functions.  Most often, input streams (character sources)
obtain characters from the keyboard, a buffer, or a file, and output
streams (character sinks) send characters to a buffer, such as a
'Help' buffer, or to the echo area.

   The object 'nil', in addition to its other meanings, may be used as a
stream.  It stands for the value of the variable 'standard-input' or
'standard-output'.  Also, the object 't' as a stream specifies input
using the minibuffer (*note Minibuffers::) or output in the echo area
(*note The Echo Area::).

   Streams have no special printed representation or read syntax, and
print as whatever primitive type they are.

   *Note Read and Print::, for a description of functions related to
streams, including parsing and printing functions.

==============================================================================
File: elisp.info,  Node: |Keymap_Type|,  Next: |Overlay_Type|,  Prev: |Stream_Type|,  Up: |Editing_Types|
==============================================================================

                                                                   *Keymap_Type*

2.5.13 Keymap Type
------------------

A "keymap" maps keys typed by the user to commands.  This mapping
controls how the user's command input is executed.  A keymap is actually
a list whose CAR is the symbol 'keymap'.

   *Note Keymaps::, for information about creating keymaps, handling
prefix keys, local as well as global keymaps, and changing key bindings.

==============================================================================
File: elisp.info,  Node: |Overlay_Type|,  Next: |Font_Type|,  Prev: |Keymap_Type|,  Up: |Editing_Types|
==============================================================================

                                                                  *Overlay_Type*

2.5.14 Overlay Type
-------------------

An "overlay" specifies properties that apply to a part of a buffer.
Each overlay applies to a specified range of the buffer, and contains a
property list (a list whose elements are alternating property names and
values).  Overlay properties are used to present parts of the buffer
temporarily in a different display style.  Overlays have no read syntax,
and print in hash notation, giving the buffer name and range of
positions.

   *Note Overlays::, for information on how you can create and use
overlays.

==============================================================================
File: elisp.info,  Node: |Font_Type|,  Prev: |Overlay_Type|,  Up: |Editing_Types|
==============================================================================

                                                                     *Font_Type*

2.5.15 Font Type
----------------

A "font" specifies how to display text on a graphical terminal.  There
are actually three separate font types--"font objects", "font specs", and
"font entities"--each of which has slightly different properties.  None
of them have a read syntax; their print syntax looks like
'#<font-object>', '#<font-spec>', and '#<font-entity>' respectively.
*Note Low-Level Font::, for a description of these Lisp objects.

==============================================================================
File: elisp.info,  Node: |Circular_Objects|,  Next: |Type_Predicates|,  Prev: |Editing_Types|,  Up: |Lisp_Data_Types|
==============================================================================

                                                              *Circular_Objects*

2.6 Read Syntax for Circular Objects
------------------------------------

To represent shared or circular structures within a complex of Lisp
objects, you can use the reader constructs '#N=' and '#N#'.

   Use '#N=' before an object to label it for later reference;
subsequently, you can use '#N#' to refer the same object in another
place.  Here, N is some integer.  For example, here is how to make a
list in which the first element recurs as the third element:

     (#1=(a) b #1#)

This differs from ordinary syntax such as this

     ((a) b (a))

which would result in a list whose first and third elements look alike
but are not the same Lisp object.  This shows the difference:

     (prog1 nil
       (setq x '(#1=(a) b #1#)))
     (eq (nth 0 x) (nth 2 x))
          => t
     (setq x '((a) b (a)))
     (eq (nth 0 x) (nth 2 x))
          => nil

   You can also use the same syntax to make a circular structure, which
appears as an element within itself.  Here is an example:

     #1=(a #1#)

This makes a list whose second element is the list itself.  Here's how
you can see that it really works:

     (prog1 nil
       (setq x '#1=(a #1#)))
     (eq x (cadr x))
          => t

   The Lisp printer can produce this syntax to record circular and
shared structure in a Lisp object, if you bind the variable
'print-circle' to a non-'nil' value.  *Note Output Variables::.

==============================================================================
File: elisp.info,  Node: |Type_Predicates|,  Next: |Equality_Predicates|,  Prev: |Circular_Objects|,  Up: |Lisp_Data_Types|
==============================================================================

                                                               *Type_Predicates*

2.7 Type Predicates
-------------------

The Emacs Lisp interpreter itself does not perform type checking on the
actual arguments passed to functions when they are called.  It could not
do so, since function arguments in Lisp do not have declared data types,
as they do in other programming languages.  It is therefore up to the
individual function to test whether each actual argument belongs to a
type that the function can use.

   All built-in functions do check the types of their actual arguments
when appropriate, and signal a 'wrong-type-argument' error if an
argument is of the wrong type.  For example, here is what happens if you
pass an argument to '+' that it cannot handle:

     (+ 2 'a)
          error-> Wrong type argument: number-or-marker-p, a

   If you want your program to handle different types differently, you
must do explicit type checking.  The most common way to check the type
of an object is to call a "type predicate" function.  Emacs has a type
predicate for each type, as well as some predicates for combinations of
types.

   A type predicate function takes one argument; it returns 't' if the
argument belongs to the appropriate type, and 'nil' otherwise.
Following a general Lisp convention for predicate functions, most type
predicates' names end with 'p'.

   Here is an example which uses the predicates 'listp' to check for a
list and 'symbolp' to check for a symbol.

     (defun add-on (x)
       (cond ((symbolp x)
              ;; If X is a symbol, put it on LIST.
              (setq list (cons x list)))
             ((listp x)
              ;; If X is a list, add its elements to LIST.
              (setq list (append x list)))
             (t
              ;; We handle only symbols and lists.
              (error "Invalid argument %s in add-on" x))))

   Here is a table of predefined type predicates, in alphabetical order,
with references to further information.

'atom'
     *Note atom: List-related Predicates.

'arrayp'
     *Note arrayp: Array Functions.

'bignump'
     *Note floatp: Predicates on Numbers.

'bool-vector-p'
     *Note bool-vector-p: Bool-Vectors.

'booleanp'
     *Note booleanp: nil and t.

'bufferp'
     *Note bufferp: Buffer Basics.

'byte-code-function-p'
     *Note byte-code-function-p: Byte-Code Type.

'case-table-p'
     *Note case-table-p: Case Tables.

'char-or-string-p'
     *Note char-or-string-p: Predicates for Strings.

'char-table-p'
     *Note char-table-p: Char-Tables.

'commandp'
     *Note commandp: Interactive Call.

'condition-variable-p'
     *Note condition-variable-p: Condition Variables.

'consp'
     *Note consp: List-related Predicates.

'custom-variable-p'
     *Note custom-variable-p: Variable Definitions.

'fixnump'
     *Note floatp: Predicates on Numbers.

'floatp'
     *Note floatp: Predicates on Numbers.

'fontp'
     *Note Low-Level Font::.

'frame-configuration-p'
     *Note frame-configuration-p: Frame Configurations.

'frame-live-p'
     *Note frame-live-p: Deleting Frames.

'framep'
     *Note framep: Frames.

'functionp'
     *Note functionp: Functions.

'hash-table-p'
     *Note hash-table-p: Other Hash.

'integer-or-marker-p'
     *Note integer-or-marker-p: Predicates on Markers.

'integerp'
     *Note integerp: Predicates on Numbers.

'keymapp'
     *Note keymapp: Creating Keymaps.

'keywordp'
     *Note Constant Variables::.

'listp'
     *Note listp: List-related Predicates.

'markerp'
     *Note markerp: Predicates on Markers.

'mutexp'
     *Note mutexp: Mutexes.

'nlistp'
     *Note nlistp: List-related Predicates.

'number-or-marker-p'
     *Note number-or-marker-p: Predicates on Markers.

'numberp'
     *Note numberp: Predicates on Numbers.

'overlayp'
     *Note overlayp: Overlays.

'processp'
     *Note processp: Processes.

'recordp'
     *Note recordp: Record Type.

'sequencep'
     *Note sequencep: Sequence Functions.

'string-or-null-p'
     *Note string-or-null-p: Predicates for Strings.

'stringp'
     *Note stringp: Predicates for Strings.

'subrp'
     *Note subrp: Function Cells.

'symbolp'
     *Note symbolp: Symbols.

'syntax-table-p'
     *Note syntax-table-p: Syntax Tables.

'threadp'
     *Note threadp: Basic Thread Functions.

'vectorp'
     *Note vectorp: Vectors.

'wholenump'
     *Note wholenump: Predicates on Numbers.

'window-configuration-p'
     *Note window-configuration-p: Window Configurations.

'window-live-p'
     *Note window-live-p: Deleting Windows.

'windowp'
     *Note windowp: Basic Windows.

   The most general way to check the type of an object is to call the
function 'type-of'.  Recall that each object belongs to one and only one
primitive type; 'type-of' tells you which one (*note Lisp Data Types::).
But 'type-of' knows nothing about non-primitive types.  In most cases,
it is more convenient to use type predicates than 'type-of'.

 -- Function: type-of object
     This function returns a symbol naming the primitive type of OBJECT.
     The value is one of the symbols 'bool-vector', 'buffer',
     'char-table', 'compiled-function', 'condition-variable', 'cons',
     'finalizer', 'float', 'font-entity', 'font-object', 'font-spec',
     'frame', 'hash-table', 'integer', 'marker', 'mutex', 'overlay',
     'process', 'string', 'subr', 'symbol', 'thread', 'vector',
     'window', or 'window-configuration'.  However, if OBJECT is a
     record, the type specified by its first slot is returned; *note
     Records::.

          (type-of 1)
               => integer
          (type-of 'nil)
               => symbol
          (type-of '())    ; '()' is 'nil'.
               => symbol
          (type-of '(x))
               => cons
          (type-of (record 'foo))
               => foo

==============================================================================
File: elisp.info,  Node: |Equality_Predicates|,  Next: |Mutability|,  Prev: |Type_Predicates|,  Up: |Lisp_Data_Types|
==============================================================================

                                                           *Equality_Predicates*

2.8 Equality Predicates
-----------------------

Here we describe functions that test for equality between two objects.
Other functions test equality of contents between objects of specific
types, e.g., strings.  For these predicates, see the appropriate chapter
describing the data type.

 -- Function: eq object1 object2
     This function returns 't' if OBJECT1 and OBJECT2 are the same
     object, and 'nil' otherwise.

     If OBJECT1 and OBJECT2 are symbols with the same name, they are
     normally the same object--but see *note Creating Symbols:: for
     exceptions.  For other non-numeric types (e.g., lists, vectors,
     strings), two arguments with the same contents or elements are not
     necessarily 'eq' to each other: they are 'eq' only if they are the
     same object, meaning that a change in the contents of one will be
     reflected by the same change in the contents of the other.

     If OBJECT1 and OBJECT2 are numbers with differing types or values,
     then they cannot be the same object and 'eq' returns 'nil'.  If
     they are fixnums with the same value, then they are the same object
     and 'eq' returns 't'.  If they were computed separately but happen
     to have the same value and the same non-fixnum numeric type, then
     they might or might not be the same object, and 'eq' returns 't' or
     'nil' depending on whether the Lisp interpreter created one object
     or two.

          (eq 'foo 'foo)
               => t

          (eq ?A ?A)
               => t

          (eq 3.0 3.0)
               => t or nil
          ;; Equal floats may or may not be the same object.

          (eq (make-string 3 ?A) (make-string 3 ?A))
               => nil

          (eq "asdf" "asdf")
               => t or nil
          ;; Equal string constants or may not be the same object.

          (eq '(1 (2 (3))) '(1 (2 (3))))
               => nil

          (setq foo '(1 (2 (3))))
               => (1 (2 (3)))
          (eq foo foo)
               => t
          (eq foo '(1 (2 (3))))
               => nil

          (eq [(1 2) 3] [(1 2) 3])
               => nil

          (eq (point-marker) (point-marker))
               => nil

     The 'make-symbol' function returns an uninterned symbol, distinct
     from the symbol that is used if you write the name in a Lisp
     expression.  Distinct symbols with the same name are not 'eq'.
     *Note Creating Symbols::.

          (eq (make-symbol "foo") 'foo)
               => nil

     The Emacs Lisp byte compiler may collapse identical literal
     objects, such as literal strings, into references to the same
     object, with the effect that the byte-compiled code will compare
     such objects as 'eq', while the interpreted version of the same
     code will not.  Therefore, your code should never rely on objects
     with the same literal contents being either 'eq' or not 'eq', it
     should instead use functions that compare object contents such as
     'equal', described below.  Similarly, your code should not modify
     literal objects (e.g., put text properties on literal strings),
     since doing that might affect other literal objects of the same
     contents, if the byte compiler collapses them.

 -- Function: equal object1 object2
     This function returns 't' if OBJECT1 and OBJECT2 have equal
     components, and 'nil' otherwise.  Whereas 'eq' tests if its
     arguments are the same object, 'equal' looks inside nonidentical
     arguments to see if their elements or contents are the same.  So,
     if two objects are 'eq', they are 'equal', but the converse is not
     always true.

          (equal 'foo 'foo)
               => t

          (equal 456 456)
               => t

          (equal "asdf" "asdf")
               => t
          (eq "asdf" "asdf")
               => nil

          (equal '(1 (2 (3))) '(1 (2 (3))))
               => t
          (eq '(1 (2 (3))) '(1 (2 (3))))
               => nil

          (equal [(1 2) 3] [(1 2) 3])
               => t
          (eq [(1 2) 3] [(1 2) 3])
               => nil

          (equal (point-marker) (point-marker))
               => t

          (eq (point-marker) (point-marker))
               => nil

     Comparison of strings is case-sensitive, but does not take account
     of text properties--it compares only the characters in the strings.
     *Note Text Properties::.  Use 'equal-including-properties' to also
     compare text properties.  For technical reasons, a unibyte string
     and a multibyte string are 'equal' if and only if they contain the
     same sequence of character codes and all these codes are in the
     range 0 through 127 (ASCII).

          (equal "asdf" "ASDF")
               => nil

     However, two distinct buffers are never considered 'equal', even if
     their textual contents are the same.

   For 'equal', equality is defined recursively; for example, given two
cons cells X and Y, '(equal X Y)' returns 't' if and only if both the
expressions below return 't':

     (equal (car X) (car Y))
     (equal (cdr X) (cdr Y))

   Comparing circular lists may therefore cause deep recursion that
leads to an error, and this may result in counterintuitive behavior such
as '(equal a b)' returning 't' whereas '(equal b a)' signals an error.

 -- Function: equal-including-properties object1 object2
     This function behaves like 'equal' in all cases but also requires
     that for two strings to be equal, they have the same text
     properties.

          (equal "asdf" (propertize "asdf" 'asdf t))
               => t
          (equal-including-properties "asdf"
                                      (propertize "asdf" 'asdf t))
               => nil

==============================================================================
File: elisp.info,  Node: |Mutability|,  Prev: |Equality_Predicates|,  Up: |Lisp_Data_Types|
==============================================================================

                                                                    *Mutability*

2.9 Mutability
--------------

Some Lisp objects should never change.  For example, the Lisp expression
'"aaa"' yields a string, but you should not change its contents.  And
some objects cannot be changed; for example, although you can create a
new number by calculating one, Lisp provides no operation to change the
value of an existing number.

   Other Lisp objects are "mutable": it is safe to change their values
via destructive operations involving side effects.  For example, an
existing marker can be changed by moving the marker to point to
somewhere else.

   Although numbers never change and all markers are mutable, some types
have members some of which are mutable and others not.  These types
include conses, vectors, and strings.  For example, although '"cons"'
and '(symbol-name 'cons)' both yield strings that should not be changed,
'(copy-sequence "cons")' and '(make-string 3 ?a)' both yield mutable
strings that can be changed via later calls to 'aset'.

   A mutable object stops being mutable if it is part of an expression
that is evaluated.  For example:

     (let* ((x (list 0.5))
            (y (eval (list 'quote x))))
       (setcar x 1.5) ;; The program should not do this.
       y)

Although the list '(0.5)' was mutable when it was created, it should not
have been changed via 'setcar' because it given to 'eval'.  The reverse
does not occur: an object that should not be changed never becomes
mutable afterwards.

   If a program attempts to change objects that should not be changed,
the resulting behavior is undefined: the Lisp interpreter might signal
an error, or it might crash or behave unpredictably in other ways.(1)

   When similar constants occur as parts of a program, the Lisp
interpreter might save time or space by reusing existing constants or
their components.  For example, '(eq "abc" "abc")' returns 't' if the
interpreter creates only one instance of the string literal '"abc"', and
returns 'nil' if it creates two instances.  Lisp programs should be
written so that they work regardless of whether this optimization is in
use.

   ---------- Footnotes ----------

   (1) This is the behavior specified for languages like Common Lisp and
C for constants, and this differs from languages like JavaScript and
Python where an interpreter is required to signal an error if a program
attempts to change an immutable object.  Ideally the Emacs Lisp
interpreter will evolve in latter direction.

==============================================================================
File: elisp.info,  Node: |Numbers|,  Next: |Strings_and_Characters|,  Prev: |Lisp_Data_Types|,  Up: |Top|
==============================================================================

                                                                       *Numbers*

3 Numbers
=========

GNU Emacs supports two numeric data types: "integers" and
"floating-point numbers".  Integers are whole numbers such as -3, 0, 7,
13, and 511.  Floating-point numbers are numbers with fractional parts,
such as -4.5, 0.0, and 2.71828.  They can also be expressed in
exponential notation: '1.5e2' is the same as '150.0'; here, 'e2' stands
for ten to the second power, and that is multiplied by 1.5.  Integer
computations are exact.  Floating-point computations often involve
rounding errors, as the numbers have a fixed amount of precision.

MENU

* |Integer_Basics|::            Representation and range of integers.
* |Float_Basics|::              Representation and range of floating point.
* |Predicates_on_Numbers|::     Testing for numbers.
* |Comparison_of_Numbers|::     Equality and inequality predicates.
* |Numeric_Conversions|::       Converting float to integer and vice versa.
* |Arithmetic_Operations|::     How to add, subtract, multiply and divide.
* |Rounding_Operations|::       Explicitly rounding floating-point numbers.
* |Bitwise_Operations|::        Logical and, or, not, shifting.
* |Math_Functions|::            Trig, exponential and logarithmic functions.
* |Random_Numbers|::            Obtaining random integers, predictable or not.

==============================================================================
File: elisp.info,  Node: |Integer_Basics|,  Next: |Float_Basics|,  Up: |Numbers|
==============================================================================

                                                                *Integer_Basics*

3.1 Integer Basics
------------------

The Lisp reader reads an integer as a nonempty sequence of decimal
digits with optional initial sign and optional final period.

      1               ; The integer 1.
      1.              ; The integer 1.
     +1               ; Also the integer 1.
     -1               ; The integer -1.
      0               ; The integer 0.
     -0               ; The integer 0.

   The syntax for integers in bases other than 10 consists of '#'
followed by a radix indication followed by one or more digits.  The
radix indications are 'b' for binary, 'o' for octal, 'x' for hex, and
'RADIXr' for radix RADIX.  Thus, '#bINTEGER' reads INTEGER in binary,
and '#RADIXrINTEGER' reads INTEGER in radix RADIX.  Allowed values of
RADIX run from 2 to 36, and allowed digits are the first RADIX
characters taken from '0'-'9', 'A'-'Z'.  Letter case is ignored and
there is no initial sign or final period.  For example:

     #b101100 => 44
     #o54 => 44
     #x2c => 44
     #24r1k => 44

   To understand how various functions work on integers, especially the
bitwise operators (*note Bitwise Operations::), it is often helpful to
view the numbers in their binary form.

   In binary, the decimal integer 5 looks like this:

     ...000101

(The ellipsis '...' stands for a conceptually infinite number of bits
that match the leading bit; here, an infinite number of 0 bits.  Later
examples also use this '...' notation.)

   The integer -1 looks like this:

     ...111111

-1 is represented as all ones.  (This is called "two's complement"
notation.)

   Subtracting 4 from -1 returns the negative integer -5.  In binary,
the decimal integer 4 is 100.  Consequently, -5 looks like this:

     ...111011

   Many of the functions described in this chapter accept markers for
arguments in place of numbers.  (*Note Markers::.)  Since the actual
arguments to such functions may be either numbers or markers, we often
give these arguments the name NUMBER-OR-MARKER.  When the argument value
is a marker, its position value is used and its buffer is ignored.

   In Emacs Lisp, text characters are represented by integers.  Any
integer between zero and the value of '(max-char)', inclusive, is
considered to be valid as a character.  *Note Character Codes::.

   Integers in Emacs Lisp are not limited to the machine word size.
Under the hood, though, there are two kinds of integers: smaller ones,
called "fixnums", and larger ones, called "bignums".  Although Emacs
Lisp code ordinarily should not depend on whether an integer is a fixnum
or a bignum, older Emacs versions support only fixnums, some functions
in Emacs still accept only fixnums, and older Emacs Lisp code may have
trouble when given bignums.  For example, while older Emacs Lisp code
could safely compare integers for numeric equality with 'eq', the
presence of bignums means that equality predicates like 'eql' and '='
should now be used to compare integers.

   The range of values for bignums is limited by the amount of main
memory, by machine characteristics such as the size of the word used to
represent a bignum's exponent, and by the 'integer-width' variable.
These limits are typically much more generous than the limits for
fixnums.  A bignum is never numerically equal to a fixnum; Emacs always
represents an integer in fixnum range as a fixnum, not a bignum.

   The range of values for a fixnum depends on the machine.  The minimum
range is -536,870,912 to 536,870,911 (30 bits; i.e., -2**29 to 2**29 -
1), but many machines provide a wider range.

 -- Variable: most-positive-fixnum
     The value of this variable is the greatest "small" integer that
     Emacs Lisp can handle.  Typical values are 2**29 - 1 on 32-bit and
     2**61 - 1 on 64-bit platforms.

 -- Variable: most-negative-fixnum
     The value of this variable is the numerically least "small" integer
     that Emacs Lisp can handle.  It is negative.  Typical values are
     -2**29 on 32-bit and -2**61 on 64-bit platforms.

 -- Variable: integer-width
     The value of this variable is a nonnegative integer that controls
     whether Emacs signals a range error when a large integer would be
     calculated.  Integers with absolute values less than 2**N, where N
     is this variable's value, do not signal a range error.  Attempts to
     create larger integers typically signal a range error, although
     there might be no signal if a larger integer can be created
     cheaply.  Setting this variable to a large number can be costly if
     a computation creates huge integers.

==============================================================================
File: elisp.info,  Node: |Float_Basics|,  Next: |Predicates_on_Numbers|,  Prev: |Integer_Basics|,  Up: |Numbers|
==============================================================================

                                                                  *Float_Basics*

3.2 Floating-Point Basics
-------------------------

Floating-point numbers are useful for representing numbers that are not
integral.  The range of floating-point numbers is the same as the range
of the C data type 'double' on the machine you are using.  On all
computers supported by Emacs, this is IEEE binary64 floating point
format, which is standardized by IEEE Std 754-2019 and is discussed
further in David Goldberg's paper "What Every Computer Scientist Should
Know About Floating-Point Arithmetic
(https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)".  On
modern platforms, floating-point operations follow the IEEE-754 standard
closely; however, results are not always rounded correctly on some
obsolescent platforms, notably 32-bit x86.

   The read syntax for floating-point numbers requires either a decimal
point, an exponent, or both.  Optional signs ('+' or '-') precede the
number and its exponent.  For example, '1500.0', '+15e2', '15.0e+2',
'+1500000e-3', and '.15e4' are five ways of writing a floating-point
number whose value is 1500.  They are all equivalent.  Like Common Lisp,
Emacs Lisp requires at least one digit after any decimal point in a
floating-point number; '1500.' is an integer, not a floating-point
number.

   Emacs Lisp treats '-0.0' as numerically equal to ordinary zero with
respect to numeric comparisons like '='.  This follows the IEEE
floating-point standard, which says '-0.0' and '0.0' are numerically
equal even though other operations can distinguish them.

   The IEEE floating-point standard supports positive infinity and
negative infinity as floating-point values.  It also provides for a
class of values called NaN, or "not a number"; numerical functions
return such values in cases where there is no correct answer.  For
example, '(/ 0.0 0.0)' returns a NaN.  A NaN is never numerically equal
to any value, not even to itself.  NaNs carry a sign and a significand,
and non-numeric functions treat two NaNs as equal when their signs and
significands agree.  Significands of NaNs are machine-dependent, as are
the digits in their string representation.

   When NaNs and signed zeros are involved, non-numeric functions like
'eql', 'equal', 'sxhash-eql', 'sxhash-equal' and 'gethash' determine
whether values are indistinguishable, not whether they are numerically
equal.  For example, when X and Y are the same NaN, '(equal x y)'
returns 't' whereas '(= x y)' uses numeric comparison and returns 'nil';
conversely, '(equal 0.0 -0.0)' returns 'nil' whereas '(= 0.0 -0.0)'
returns 't'.

   Here are read syntaxes for these special floating-point values:

infinity
     '1.0e+INF' and '-1.0e+INF'
not-a-number
     '0.0e+NaN' and '-0.0e+NaN'

   The following functions are specialized for handling floating-point
numbers:

 -- Function: isnan x
     This predicate returns 't' if its floating-point argument is a NaN,
     'nil' otherwise.

 -- Function: frexp x
     This function returns a cons cell '(S . E)', where S and E are
     respectively the significand and exponent of the floating-point
     number X.

     If X is finite, then S is a floating-point number between 0.5
     (inclusive) and 1.0 (exclusive), E is an integer, and X = S * 2**E.
     If X is zero or infinity, then S is the same as X.  If X is a NaN,
     then S is also a NaN.  If X is zero, then E is 0.

 -- Function: ldexp s e
     Given a numeric significand S and an integer exponent E, this
     function returns the floating point number S * 2**E.

 -- Function: copysign x1 x2
     This function copies the sign of X2 to the value of X1, and returns
     the result.  X1 and X2 must be floating point.

 -- Function: logb x
     This function returns the binary exponent of X.  More precisely, if
     X is finite and nonzero, the value is the logarithm base 2 of |x|,
     rounded down to an integer.  If X is zero or infinite, the value is
     infinity; if X is a NaN, the value is a NaN.

          (logb 10)
               => 3
          (logb 10.0e20)
               => 69
          (logb 0)
               => -1.0e+INF

==============================================================================
File: elisp.info,  Node: |Predicates_on_Numbers|,  Next: |Comparison_of_Numbers|,  Prev: |Float_Basics|,  Up: |Numbers|
==============================================================================

                                                         *Predicates_on_Numbers*

3.3 Type Predicates for Numbers
-------------------------------

The functions in this section test for numbers, or for a specific type
of number.  The functions 'integerp' and 'floatp' can take any type of
Lisp object as argument (they would not be of much use otherwise), but
the 'zerop' predicate requires a number as its argument.  See also
'integer-or-marker-p' and 'number-or-marker-p', in *note Predicates on
Markers::.

 -- Function: bignump object
     This predicate tests whether its argument is a large integer, and
     returns 't' if so, 'nil' otherwise.  Unlike small integers, large
     integers can be '=' or 'eql' even if they are not 'eq'.

 -- Function: fixnump object
     This predicate tests whether its argument is a small integer, and
     returns 't' if so, 'nil' otherwise.  Small integers can be compared
     with 'eq'.

 -- Function: floatp object
     This predicate tests whether its argument is floating point and
     returns 't' if so, 'nil' otherwise.

 -- Function: integerp object
     This predicate tests whether its argument is an integer, and
     returns 't' if so, 'nil' otherwise.

 -- Function: numberp object
     This predicate tests whether its argument is a number (either
     integer or floating point), and returns 't' if so, 'nil' otherwise.

 -- Function: natnump object
     This predicate (whose name comes from the phrase "natural number")
     tests to see whether its argument is a nonnegative integer, and
     returns 't' if so, 'nil' otherwise.  0 is considered non-negative.

     'wholenump' is a synonym for 'natnump'.

 -- Function: zerop number
     This predicate tests whether its argument is zero, and returns 't'
     if so, 'nil' otherwise.  The argument must be a number.

     '(zerop x)' is equivalent to '(= x 0)'.

==============================================================================
File: elisp.info,  Node: |Comparison_of_Numbers|,  Next: |Numeric_Conversions|,  Prev: |Predicates_on_Numbers|,  Up: |Numbers|
==============================================================================

                                                         *Comparison_of_Numbers*

3.4 Comparison of Numbers
-------------------------

To test numbers for numerical equality, you should normally use '='
instead of non-numeric comparison predicates like 'eq', 'eql' and
'equal'.  Distinct floating-point and large integer objects can be
numerically equal.  If you use 'eq' to compare them, you test whether
they are the same _object_; if you use 'eql' or 'equal', you test
whether their values are _indistinguishable_.  In contrast, '=' uses
numeric comparison, and sometimes returns 't' when a non-numeric
comparison would return 'nil' and vice versa.  *Note Float Basics::.

   In Emacs Lisp, if two fixnums are numerically equal, they are the
same Lisp object.  That is, 'eq' is equivalent to '=' on fixnums.  It is
sometimes convenient to use 'eq' for comparing an unknown value with a
fixnum, because 'eq' does not report an error if the unknown value is
not a number--it accepts arguments of any type.  By contrast, '=' signals
an error if the arguments are not numbers or markers.  However, it is
better programming practice to use '=' if you can, even for comparing
integers.

   Sometimes it is useful to compare numbers with 'eql' or 'equal',
which treat two numbers as equal if they have the same data type (both
integers, or both floating point) and the same value.  By contrast, '='
can treat an integer and a floating-point number as equal.  *Note
Equality Predicates::.

   There is another wrinkle: because floating-point arithmetic is not
exact, it is often a bad idea to check for equality of floating-point
values.  Usually it is better to test for approximate equality.  Here's
a function to do this:

     (defvar fuzz-factor 1.0e-6)
     (defun approx-equal (x y)
       (or (= x y)
           (< (/ (abs (- x y))
                 (max (abs x) (abs y)))
              fuzz-factor)))

 -- Function: = number-or-marker &rest number-or-markers
     This function tests whether all its arguments are numerically
     equal, and returns 't' if so, 'nil' otherwise.

 -- Function: eql value1 value2
     This function acts like 'eq' except when both arguments are
     numbers.  It compares numbers by type and numeric value, so that
     '(eql 1.0 1)' returns 'nil', but '(eql 1.0 1.0)' and '(eql 1 1)'
     both return 't'.  This can be used to compare large integers as
     well as small ones.

 -- Function: /= number-or-marker1 number-or-marker2
     This function tests whether its arguments are numerically equal,
     and returns 't' if they are not, and 'nil' if they are.

 -- Function: < number-or-marker &rest number-or-markers
     This function tests whether each argument is strictly less than the
     following argument.  It returns 't' if so, 'nil' otherwise.

 -- Function: <= number-or-marker &rest number-or-markers
     This function tests whether each argument is less than or equal to
     the following argument.  It returns 't' if so, 'nil' otherwise.

 -- Function: > number-or-marker &rest number-or-markers
     This function tests whether each argument is strictly greater than
     the following argument.  It returns 't' if so, 'nil' otherwise.

 -- Function: >= number-or-marker &rest number-or-markers
     This function tests whether each argument is greater than or equal
     to the following argument.  It returns 't' if so, 'nil' otherwise.

 -- Function: max number-or-marker &rest numbers-or-markers
     This function returns the largest of its arguments.

          (max 20)
               => 20
          (max 1 2.5)
               => 2.5
          (max 1 3 2.5)
               => 3

 -- Function: min number-or-marker &rest numbers-or-markers
     This function returns the smallest of its arguments.

          (min -4 1)
               => -4

 -- Function: abs number
     This function returns the absolute value of NUMBER.

==============================================================================
File: elisp.info,  Node: |Numeric_Conversions|,  Next: |Arithmetic_Operations|,  Prev: |Comparison_of_Numbers|,  Up: |Numbers|
==============================================================================

                                                           *Numeric_Conversions*

3.5 Numeric Conversions
-----------------------

To convert an integer to floating point, use the function 'float'.

 -- Function: float number
     This returns NUMBER converted to floating point.  If NUMBER is
     already floating point, 'float' returns it unchanged.

   There are four functions to convert floating-point numbers to
integers; they differ in how they round.  All accept an argument NUMBER
and an optional argument DIVISOR.  Both arguments may be integers or
floating-point numbers.  DIVISOR may also be 'nil'.  If DIVISOR is 'nil'
or omitted, these functions convert NUMBER to an integer, or return it
unchanged if it already is an integer.  If DIVISOR is non-'nil', they
divide NUMBER by DIVISOR and convert the result to an integer.  If
DIVISOR is zero (whether integer or floating point), Emacs signals an
'arith-error' error.

 -- Function: truncate number &optional divisor
     This returns NUMBER, converted to an integer by rounding towards
     zero.

          (truncate 1.2)
               => 1
          (truncate 1.7)
               => 1
          (truncate -1.2)
               => -1
          (truncate -1.7)
               => -1

 -- Function: floor number &optional divisor
     This returns NUMBER, converted to an integer by rounding downward
     (towards negative infinity).

     If DIVISOR is specified, this uses the kind of division operation
     that corresponds to 'mod', rounding downward.

          (floor 1.2)
               => 1
          (floor 1.7)
               => 1
          (floor -1.2)
               => -2
          (floor -1.7)
               => -2
          (floor 5.99 3)
               => 1

 -- Function: ceiling number &optional divisor
     This returns NUMBER, converted to an integer by rounding upward
     (towards positive infinity).

          (ceiling 1.2)
               => 2
          (ceiling 1.7)
               => 2
          (ceiling -1.2)
               => -1
          (ceiling -1.7)
               => -1

 -- Function: round number &optional divisor
     This returns NUMBER, converted to an integer by rounding towards
     the nearest integer.  Rounding a value equidistant between two
     integers returns the even integer.

          (round 1.2)
               => 1
          (round 1.7)
               => 2
          (round -1.2)
               => -1
          (round -1.7)
               => -2

==============================================================================
File: elisp.info,  Node: |Arithmetic_Operations|,  Next: |Rounding_Operations|,  Prev: |Numeric_Conversions|,  Up: |Numbers|
==============================================================================

                                                         *Arithmetic_Operations*

3.6 Arithmetic Operations
-------------------------

Emacs Lisp provides the traditional four arithmetic operations
(addition, subtraction, multiplication, and division), as well as
remainder and modulus functions, and functions to add or subtract 1.
Except for '%', each of these functions accepts both integer and
floating-point arguments, and returns a floating-point number if any
argument is floating point.

 -- Function: 1+ number-or-marker
     This function returns NUMBER-OR-MARKER plus 1.  For example,

          (setq foo 4)
               => 4
          (1+ foo)
               => 5

     This function is not analogous to the C operator '++'--it does not
     increment a variable.  It just computes a sum.  Thus, if we
     continue,

          foo
               => 4

     If you want to increment the variable, you must use 'setq', like
     this:

          (setq foo (1+ foo))
               => 5

 -- Function: 1- number-or-marker
     This function returns NUMBER-OR-MARKER minus 1.

 -- Function: + &rest numbers-or-markers
     This function adds its arguments together.  When given no
     arguments, '+' returns 0.

          (+)
               => 0
          (+ 1)
               => 1
          (+ 1 2 3 4)
               => 10

 -- Function: - &optional number-or-marker &rest more-numbers-or-markers
     The '-' function serves two purposes: negation and subtraction.
     When '-' has a single argument, the value is the negative of the
     argument.  When there are multiple arguments, '-' subtracts each of
     the MORE-NUMBERS-OR-MARKERS from NUMBER-OR-MARKER, cumulatively.
     If there are no arguments, the result is 0.

          (- 10 1 2 3 4)
               => 0
          (- 10)
               => -10
          (-)
               => 0

 -- Function: * &rest numbers-or-markers
     This function multiplies its arguments together, and returns the
     product.  When given no arguments, '*' returns 1.

          (*)
               => 1
          (* 1)
               => 1
          (* 1 2 3 4)
               => 24

 -- Function: / number &rest divisors
     With one or more DIVISORS, this function divides NUMBER by each
     divisor in DIVISORS in turn, and returns the quotient.  With no
     DIVISORS, this function returns 1/NUMBER, i.e., the multiplicative
     inverse of NUMBER.  Each argument may be a number or a marker.

     If all the arguments are integers, the result is an integer,
     obtained by rounding the quotient towards zero after each division.

          (/ 6 2)
               => 3
          (/ 5 2)
               => 2
          (/ 5.0 2)
               => 2.5
          (/ 5 2.0)
               => 2.5
          (/ 5.0 2.0)
               => 2.5
          (/ 4.0)
               => 0.25
          (/ 4)
               => 0
          (/ 25 3 2)
               => 4
          (/ -17 6)
               => -2

     If you divide an integer by the integer 0, Emacs signals an
     'arith-error' error (*note Errors::).  Floating-point division of a
     nonzero number by zero yields either positive or negative infinity
     (*note Float Basics::).

 -- Function: % dividend divisor
     This function returns the integer remainder after division of
     DIVIDEND by DIVISOR.  The arguments must be integers or markers.

     For any two integers DIVIDEND and DIVISOR,

          (+ (% DIVIDEND DIVISOR)
             (* (/ DIVIDEND DIVISOR) DIVISOR))

     always equals DIVIDEND if DIVISOR is nonzero.

          (% 9 4)
               => 1
          (% -9 4)
               => -1
          (% 9 -4)
               => 1
          (% -9 -4)
               => -1

 -- Function: mod dividend divisor
     This function returns the value of DIVIDEND modulo DIVISOR; in
     other words, the remainder after division of DIVIDEND by DIVISOR,
     but with the same sign as DIVISOR.  The arguments must be numbers
     or markers.

     Unlike '%', 'mod' permits floating-point arguments; it rounds the
     quotient downward (towards minus infinity) to an integer, and uses
     that quotient to compute the remainder.

     If DIVISOR is zero, 'mod' signals an 'arith-error' error if both
     arguments are integers, and returns a NaN otherwise.

          (mod 9 4)
               => 1
          (mod -9 4)
               => 3
          (mod 9 -4)
               => -3
          (mod -9 -4)
               => -1
          (mod 5.5 2.5)
               => .5

     For any two numbers DIVIDEND and DIVISOR,

          (+ (mod DIVIDEND DIVISOR)
             (* (floor DIVIDEND DIVISOR) DIVISOR))

     always equals DIVIDEND, subject to rounding error if either
     argument is floating point and to an 'arith-error' if DIVIDEND is
     an integer and DIVISOR is 0.  For 'floor', see *note Numeric
     Conversions::.

==============================================================================
File: elisp.info,  Node: |Rounding_Operations|,  Next: |Bitwise_Operations|,  Prev: |Arithmetic_Operations|,  Up: |Numbers|
==============================================================================

                                                           *Rounding_Operations*

3.7 Rounding Operations
-----------------------

The functions 'ffloor', 'fceiling', 'fround', and 'ftruncate' take a
floating-point argument and return a floating-point result whose value
is a nearby integer.  'ffloor' returns the nearest integer below;
'fceiling', the nearest integer above; 'ftruncate', the nearest integer
in the direction towards zero; 'fround', the nearest integer.

 -- Function: ffloor float
     This function rounds FLOAT to the next lower integral value, and
     returns that value as a floating-point number.

 -- Function: fceiling float
     This function rounds FLOAT to the next higher integral value, and
     returns that value as a floating-point number.

 -- Function: ftruncate float
     This function rounds FLOAT towards zero to an integral value, and
     returns that value as a floating-point number.

 -- Function: fround float
     This function rounds FLOAT to the nearest integral value, and
     returns that value as a floating-point number.  Rounding a value
     equidistant between two integers returns the even integer.

==============================================================================
File: elisp.info,  Node: |Bitwise_Operations|,  Next: |Math_Functions|,  Prev: |Rounding_Operations|,  Up: |Numbers|
==============================================================================

                                                            *Bitwise_Operations*

3.8 Bitwise Operations on Integers
----------------------------------

In a computer, an integer is represented as a binary number, a sequence
of "bits" (digits which are either zero or one).  Conceptually the bit
sequence is infinite on the left, with the most-significant bits being
all zeros or all ones.  A bitwise operation acts on the individual bits
of such a sequence.  For example, "shifting" moves the whole sequence
left or right one or more places, reproducing the same pattern moved
over.

   The bitwise operations in Emacs Lisp apply only to integers.

 -- Function: ash integer1 count
     'ash' ("arithmetic shift") shifts the bits in INTEGER1 to the left
     COUNT places, or to the right if COUNT is negative.  Left shifts
     introduce zero bits on the right; right shifts discard the
     rightmost bits.  Considered as an integer operation, 'ash'
     multiplies INTEGER1 by 2**COUNT, and then converts the result to an
     integer by rounding downward, toward minus infinity.

     Here are examples of 'ash', shifting a pattern of bits one place to
     the left and to the right.  These examples show only the low-order
     bits of the binary pattern; leading bits all agree with the
     highest-order bit shown.  As you can see, shifting left by one is
     equivalent to multiplying by two, whereas shifting right by one is
     equivalent to dividing by two and then rounding toward minus
     infinity.

          (ash 7 1) => 14
          ;; Decimal 7 becomes decimal 14.
          ...000111
               =>
          ...001110

          (ash 7 -1) => 3
          ...000111
               =>
          ...000011

          (ash -7 1) => -14
          ...111001
               =>
          ...110010

          (ash -7 -1) => -4
          ...111001
               =>
          ...111100

     Here are examples of shifting left or right by two bits:

                            ;         binary values
          (ash 5 2)         ;   5  =  ...000101
               => 20         ;      =  ...010100
          (ash -5 2)        ;  -5  =  ...111011
               => -20        ;      =  ...101100
          (ash 5 -2)
               => 1          ;      =  ...000001
          (ash -5 -2)
               => -2         ;      =  ...111110

 -- Function: lsh integer1 count
     'lsh', which is an abbreviation for "logical shift", shifts the
     bits in INTEGER1 to the left COUNT places, or to the right if COUNT
     is negative, bringing zeros into the vacated bits.  If COUNT is
     negative, then INTEGER1 must be either a fixnum or a positive
     bignum, and 'lsh' treats a negative fixnum as if it were unsigned
     by subtracting twice 'most-negative-fixnum' before shifting,
     producing a nonnegative result.  This quirky behavior dates back to
     when Emacs supported only fixnums; nowadays 'ash' is a better
     choice.

     As 'lsh' behaves like 'ash' except when INTEGER1 and COUNT1 are
     both negative, the following examples focus on these exceptional
     cases.  These examples assume 30-bit fixnums.

                           ;      binary values
          (ash -7 -1)      ; -7 = ...111111111111111111111111111001
               => -4        ;    = ...111111111111111111111111111100
          (lsh -7 -1)
               => 536870908 ;    = ...011111111111111111111111111100
          (ash -5 -2)      ; -5 = ...111111111111111111111111111011
               => -2        ;    = ...111111111111111111111111111110
          (lsh -5 -2)
               => 268435454 ;    = ...001111111111111111111111111110

 -- Function: logand &rest ints-or-markers
     This function returns the bitwise AND of the arguments: the Nth bit
     is 1 in the result if, and only if, the Nth bit is 1 in all the
     arguments.

     For example, using 4-bit binary numbers, the bitwise AND of 13 and
     12 is 12: 1101 combined with 1100 produces 1100.  In both the
     binary numbers, the leftmost two bits are both 1 so the leftmost
     two bits of the returned value are both 1.  However, for the
     rightmost two bits, each is 0 in at least one of the arguments, so
     the rightmost two bits of the returned value are both 0.

     Therefore,

          (logand 13 12)
               => 12

     If 'logand' is not passed any argument, it returns a value of -1.
     This number is an identity element for 'logand' because its binary
     representation consists entirely of ones.  If 'logand' is passed
     just one argument, it returns that argument.

                             ;        binary values

          (logand 14 13)     ; 14  =  ...001110
                             ; 13  =  ...001101
               => 12         ; 12  =  ...001100

          (logand 14 13 4)   ; 14  =  ...001110
                             ; 13  =  ...001101
                             ;  4  =  ...000100
               => 4          ;  4  =  ...000100

          (logand)
               => -1         ; -1  =  ...111111

 -- Function: logior &rest ints-or-markers
     This function returns the bitwise inclusive OR of its arguments:
     the Nth bit is 1 in the result if, and only if, the Nth bit is 1 in
     at least one of the arguments.  If there are no arguments, the
     result is 0, which is an identity element for this operation.  If
     'logior' is passed just one argument, it returns that argument.

                             ;        binary values

          (logior 12 5)      ; 12  =  ...001100
                             ;  5  =  ...000101
               => 13         ; 13  =  ...001101

          (logior 12 5 7)    ; 12  =  ...001100
                             ;  5  =  ...000101
                             ;  7  =  ...000111
               => 15         ; 15  =  ...001111

 -- Function: logxor &rest ints-or-markers
     This function returns the bitwise exclusive OR of its arguments:
     the Nth bit is 1 in the result if, and only if, the Nth bit is 1 in
     an odd number of the arguments.  If there are no arguments, the
     result is 0, which is an identity element for this operation.  If
     'logxor' is passed just one argument, it returns that argument.

                             ;        binary values

          (logxor 12 5)      ; 12  =  ...001100
                             ;  5  =  ...000101
               => 9          ;  9  =  ...001001

          (logxor 12 5 7)    ; 12  =  ...001100
                             ;  5  =  ...000101
                             ;  7  =  ...000111
               => 14         ; 14  =  ...001110

 -- Function: lognot integer
     This function returns the bitwise complement of its argument: the
     Nth bit is one in the result if, and only if, the Nth bit is zero
     in INTEGER, and vice-versa.  The result equals -1 - INTEGER.

          (lognot 5)
               => -6
          ;;  5  =  ...000101
          ;; becomes
          ;; -6  =  ...111010

 -- Function: logcount integer
     This function returns the "Hamming weight" of INTEGER: the number
     of ones in the binary representation of INTEGER.  If INTEGER is
     negative, it returns the number of zero bits in its two's
     complement binary representation.  The result is always
     nonnegative.

          (logcount 43)     ;  43 = ...000101011
               => 4
          (logcount -43)    ; -43 = ...111010101
               => 3

==============================================================================
File: elisp.info,  Node: |Math_Functions|,  Next: |Random_Numbers|,  Prev: |Bitwise_Operations|,  Up: |Numbers|
==============================================================================

                                                                *Math_Functions*

3.9 Standard Mathematical Functions
-----------------------------------

These mathematical functions allow integers as well as floating-point
numbers as arguments.

 -- Function: sin arg
 -- Function: cos arg
 -- Function: tan arg
     These are the basic trigonometric functions, with argument ARG
     measured in radians.

 -- Function: asin arg
     The value of '(asin ARG)' is a number between -pi/2 and pi/2
     (inclusive) whose sine is ARG.  If ARG is out of range (outside
     [-1, 1]), 'asin' returns a NaN.

 -- Function: acos arg
     The value of '(acos ARG)' is a number between 0 and pi (inclusive)
     whose cosine is ARG.  If ARG is out of range (outside [-1, 1]),
     'acos' returns a NaN.

 -- Function: atan y &optional x
     The value of '(atan Y)' is a number between -pi/2 and pi/2
     (exclusive) whose tangent is Y.  If the optional second argument X
     is given, the value of '(atan y x)' is the angle in radians between
     the vector '[X, Y]' and the 'X' axis.

 -- Function: exp arg
     This is the exponential function; it returns e to the power ARG.

 -- Function: log arg &optional base
     This function returns the logarithm of ARG, with base BASE.  If you
     don't specify BASE, the natural base e is used.  If ARG or BASE is
     negative, 'log' returns a NaN.

 -- Function: expt x y
     This function returns X raised to power Y.  If both arguments are
     integers and Y is nonnegative, the result is an integer; in this
     case, overflow signals an error, so watch out.  If X is a finite
     negative number and Y is a finite non-integer, 'expt' returns a
     NaN.

 -- Function: sqrt arg
     This returns the square root of ARG.  If ARG is finite and less
     than zero, 'sqrt' returns a NaN.

   In addition, Emacs defines the following common mathematical
constants:

 -- Variable: float-e
     The mathematical constant e (2.71828...).

 -- Variable: float-pi
     The mathematical constant pi (3.14159...).

==============================================================================
File: elisp.info,  Node: |Random_Numbers|,  Prev: |Math_Functions|,  Up: |Numbers|
==============================================================================

                                                                *Random_Numbers*

3.10 Random Numbers
-------------------

A deterministic computer program cannot generate true random numbers.
For most purposes, "pseudo-random numbers" suffice.  A series of
pseudo-random numbers is generated in a deterministic fashion.  The
numbers are not truly random, but they have certain properties that
mimic a random series.  For example, all possible values occur equally
often in a pseudo-random series.

   Pseudo-random numbers are generated from a "seed value".  Starting
from any given seed, the 'random' function always generates the same
sequence of numbers.  By default, Emacs initializes the random seed at
startup, in such a way that the sequence of values of 'random' (with
overwhelming likelihood) differs in each Emacs run.

   Sometimes you want the random number sequence to be repeatable.  For
example, when debugging a program whose behavior depends on the random
number sequence, it is helpful to get the same behavior in each program
run.  To make the sequence repeat, execute '(random "")'.  This sets the
seed to a constant value for your particular Emacs executable (though it
may differ for other Emacs builds).  You can use other strings to choose
various seed values.

 -- Function: random &optional limit
     This function returns a pseudo-random integer.  Repeated calls
     return a series of pseudo-random integers.

     If LIMIT is a positive fixnum, the value is chosen to be
     nonnegative and less than LIMIT.  Otherwise, the value might be any
     fixnum, i.e., any integer from 'most-negative-fixnum' through
     'most-positive-fixnum' (*note Integer Basics::).

     If LIMIT is 't', it means to choose a new seed as if Emacs were
     restarting, typically from the system entropy.  On systems lacking
     entropy pools, choose the seed from less-random volatile data such
     as the current time.

     If LIMIT is a string, it means to choose a new seed based on the
     string's contents.

==============================================================================
File: elisp.info,  Node: |Strings_and_Characters|,  Next: |Lists|,  Prev: |Numbers|,  Up: |Top|
==============================================================================

                                                        *Strings_and_Characters*

4 Strings and Characters
========================

A string in Emacs Lisp is an array that contains an ordered sequence of
characters.  Strings are used as names of symbols, buffers, and files;
to send messages to users; to hold text being copied between buffers;
and for many other purposes.  Because strings are so important, Emacs
Lisp has many functions expressly for manipulating them.  Emacs Lisp
programs use strings more often than individual characters.

   *Note Strings of Events::, for special considerations for strings of
keyboard character events.

MENU

* Basics: String Basics.      Basic properties of strings and characters.
* |Predicates_for_Strings|::    Testing whether an object is a string or char.
* |Creating_Strings|::          Functions to allocate new strings.
* |Modifying_Strings|::         Altering the contents of an existing string.
* |Text_Comparison|::           Comparing characters or strings.
* |String_Conversion|::         Converting to and from characters and strings.
* |Formatting_Strings|::        'format': Emacs's analogue of 'printf'.
* |Custom_Format_Strings|::     Formatting custom 'format' specifications.
* |Case_Conversion|::           Case conversion functions.
* |Case_Tables|::               Customizing case conversion.

==============================================================================
File: elisp.info,  Node: |String_Basics|,  Next: |Predicates_for_Strings|,  Up: Strings and Characters
==============================================================================

                                                                 *String_Basics*

vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
